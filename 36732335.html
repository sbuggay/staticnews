<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689411653434" as="style"/><link rel="stylesheet" href="styles.css?v=1689411653434"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.paulgraham.com/thist.html">History of T (2001)</a> <span class="domain">(<a href="http://www.paulgraham.com">www.paulgraham.com</a>)</span></div><div class="subtext"><span>swatson741</span> | <span>18 comments</span></div><br/><div><div id="36732624" class="c"><input type="checkbox" id="c-36732624" checked=""/><div class="controls bullet"><span class="by">jpmattia</span><span>|</span><a href="#36732934">next</a><span>|</span><label class="collapse" for="c-36732624">[-]</label><label class="expand" for="c-36732624">[1 more]</label></div><br/><div class="children"><div class="content">A totally tangential comment on CS at Yale during that era: Yale was very nice to the local towns and allowed high school students to take classes, so in 1981 I took their intro to CS. The bulk of the course was run in APL, with a bit of pascal at the end.<p>But the thing I remember most? The computer room was in the basement of the music annex, which had a bunch of practice rooms. So the geeks would all be hacking away on a bunch of VT100s while the sounds of musicians training to be professionals rained down from above. It was a great place to hack on machines!<p>[I then took Sussman&#x2F;Abelson&#x27;s intro course (SICP) at MIT about a year later, which was quite a contrast. Or maybe I was much more mature, having left high school. :) ]</div><br/></div></div><div id="36732934" class="c"><input type="checkbox" id="c-36732934" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36732624">prev</a><span>|</span><a href="#36733173">next</a><span>|</span><label class="collapse" for="c-36732934">[-]</label><label class="expand" for="c-36732934">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>History of T (2001)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17784416">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17784416</a> - Aug 2018 (38 comments)<p><i>Olin Shivers: History of T</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8897473">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8897473</a> - Jan 2015 (1 comment)<p><i>History of T</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6778754">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6778754</a> - Nov 2013 (42 comments)<p><i>Olin Shivers: History of T</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3646093">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3646093</a> - Feb 2012 (1 comment)<p><i>History of T</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=255245">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=255245</a> - July 2008 (27 comments)</div><br/></div></div><div id="36733173" class="c"><input type="checkbox" id="c-36733173" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#36732934">prev</a><span>|</span><a href="#36732987">next</a><span>|</span><label class="collapse" for="c-36733173">[-]</label><label class="expand" for="c-36733173">[7 more]</label></div><br/><div class="children"><div class="content">Can someone in the know please elaborate on why dynamic scoping was considered more efficient than lexical scoping?</div><br/><div id="36733917" class="c"><input type="checkbox" id="c-36733917" checked=""/><div class="controls bullet"><span class="by">neonscribe</span><span>|</span><a href="#36733173">parent</a><span>|</span><a href="#36733723">next</a><span>|</span><label class="collapse" for="c-36733917">[-]</label><label class="expand" for="c-36733917">[1 more]</label></div><br/><div class="children"><div class="content">Dynamic scoping is usually implemented with shallow binding, where a single value cell for a variable is located at a fixed address, with each new binding saving and restoring the enclosing value on the stack. This allows constant time variable access, even in an interpreter working directly from S-expressions without a compilation phase. Lexical scoping in a pure interpreter requires a linear search through an environment. In compiled code, lexically-scoped variable access is more efficient than dynamically-scoped variable access, since it can be implemented with either a stack location at a fixed offset in the frame, or inside a closure object at a fixed offset.</div><br/></div></div><div id="36733723" class="c"><input type="checkbox" id="c-36733723" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36733173">parent</a><span>|</span><a href="#36733917">prev</a><span>|</span><a href="#36733759">next</a><span>|</span><label class="collapse" for="c-36733723">[-]</label><label class="expand" for="c-36733723">[3 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s just one global instead of constant space added to all the closures&#x2F;stacks.  One map of symbols to values, not a whole world of them. If I had to guess.</div><br/><div id="36734826" class="c"><input type="checkbox" id="c-36734826" checked=""/><div class="controls bullet"><span class="by">lsp_trw</span><span>|</span><a href="#36733173">root</a><span>|</span><a href="#36733723">parent</a><span>|</span><a href="#36733863">next</a><span>|</span><label class="collapse" for="c-36734826">[-]</label><label class="expand" for="c-36734826">[1 more]</label></div><br/><div class="children"><div class="content">You can get away with having a single global state variable so long as it&#x27;s an association table and you keep track of what variables you&#x27;ve introduced. I believe that the reason why people thought it would be slow then was that no one had used a data structure that could store multiple results for the same value.</div><br/></div></div><div id="36733863" class="c"><input type="checkbox" id="c-36733863" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36733173">root</a><span>|</span><a href="#36733723">parent</a><span>|</span><a href="#36734826">prev</a><span>|</span><a href="#36733759">next</a><span>|</span><label class="collapse" for="c-36733863">[-]</label><label class="expand" for="c-36733863">[1 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t think dynamic scoping saves you space; with either dynamic scoping or lexical scoping, each call to a function that binds three variables must allocate space for three values.  the only difference from that perspective is that, with dynamic scoping (and shallow binding!), the newly allocated space holds the old values of the variables, while with lexical scoping (or deep binding) it holds the new values<p>some implementations of dynamic scoping with shallow binding store each of the three values in a separate cons cell, doubling the space cost, but that&#x27;s not essential to the dynamic&#x2F;lexical distinction</div><br/></div></div></div></div><div id="36733759" class="c"><input type="checkbox" id="c-36733759" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36733173">parent</a><span>|</span><a href="#36733723">prev</a><span>|</span><a href="#36732987">next</a><span>|</span><label class="collapse" for="c-36733759">[-]</label><label class="expand" for="c-36733759">[2 more]</label></div><br/><div class="children"><div class="content">useful context is that in most programs a very significant fraction of the instruction mix consists of reads of local variables; another significant fraction consists of passing arguments to subroutines and calling them.  so the efficiency of these two operations is usually what is relevant<p>with dynamic scoping, the current value of a given variable is always in the same location in memory, so you can just fetch it from that constant location; when you enter or exit a scope that binds that variable, you push or pop that value onto a stack.  a function pointer is just a (tagged) pointer to a piece of code, typically in machine language but sometimes an s-expression or something<p>with lexical scoping, in an environment that supports recursion, the usual implementation is that you have to index off the frame pointer to find the current location of the variable.  worse, if your lexical scoping supports nested scopes (which is generally necessary for higher-order programming), you may need to follow index off the frame pointer to find the closure display pointer, then index off the closure pointer to find the variable&#x27;s value.  and then, if it&#x27;s mutable, it probably needs to be separately boxed (rather than just copied into the closure when the closure is created, which would mean changes made to its value by the inner scope wouldn&#x27;t be visible to the outer scope that originally created it), which means that accessing its value involves indexing off the frame pointer to find the context or closure display pointer, indexing off the closure display pointer to find the pointer to the variable, and then dereferencing that pointer to get the actual value.  also, supporting closures in this way means that function pointers aren&#x27;t just pointers to compiled code; they&#x27;re a dynamically allocated record containing a pointer to the compiled code and a context pointer, like in pascal, with a corresponding extra indirection (and hidden argument, but that&#x27;s free) every time you call a function.<p>there&#x27;s a tradeoff available where they can <i>just</i> be those two pointers, instead of taking the approach I described earlier where the closure display is a potentially arbitrarily large object; but in that case accessing a variable captured from a surrounding scope can involve following an arbitrarily long chain of context pointers to outer scopes, and it also kind of requires you to heap-allocate your stack frames and not garbage-collect them until the last closure from within them dies, so it&#x27;s a common approach in pascal (and gcc uses it for nested functions in c, with a little bit of dynamic code generation on the stack to keep its function pointers to a single word) but not in lisps<p>dybvig&#x27;s dissertation about how he wrote <i>chez</i> scheme is a good source for explanations on this, and also explains how to implement call&#x2F;cc with reasonable efficiency.  <a href="http:&#x2F;&#x2F;agl.cs.unm.edu&#x2F;~williams&#x2F;cs491&#x2F;three-imp.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;agl.cs.unm.edu&#x2F;~williams&#x2F;cs491&#x2F;three-imp.pdf</a><p>current cpus and operating systems favor lexical scoping more than those in the late 01970s and early 01980s for a variety of reasons.  one is that they are, of course, just much faster and have much more memory.  also, though, address sizes are larger, and instruction sizes are smaller, so it&#x27;s no longer such a slam-dunk trivial thing to just fetch a word from some absolute address; the absolute address doesn&#x27;t fit inside a single instruction, so you have to compute it by offsetting from a base register, fetch it from memory (perhaps with a pc-relative load instruction), or compose it over the course of two or more instrutions.  and currently popular operating systems prefer all your code to be position-independent, so it may be inconvenient to put the variable value at a fixed absolute address anyway; if you try, you may find upon disassembling the code that you&#x27;re actually indexing into a got or something.  finally, though i don&#x27;t know if this figured into the lispers&#x27; world, 8-bit cpus like the 6502 and 8080 were especially terrible at indexing, in a way that computers hadn&#x27;t been since the 01950s and haven&#x27;t been since, which made the performance gain of absolute addressing more significant<p>i don&#x27;t know enough about addressing modes on machines like the vax, the dorado, and the pdp-10 to know what the cost was, but on arm and risc-v (and so i assume mips) you can index off the stack pointer with an immediate constant for free; it doesn&#x27;t even require an extra clock cycle<p>a couple of points in favor of the efficiency of lexical scoping: when you have a cache, having all your local variables packed together into a stack frame is better than having them scattered all over the symbol table; popping a stack frame is a constant-time operation (adding a constant to the stack pointer, typically), while restoring <i>n</i> values on exiting a dynamic scope requires <i>n</i> operations; and the space usage of local variables on a call stack only includes the variables currently in scope, rather than all the distinct variable names used anywhere in the program, as is the case with lexical scoping<p>in a sense, the way you handle callee-saved registers in assembly language is pretty much the same as how you handle dynamically-scoped variables: on entry to a subroutine that changes r4 or rbp, you save its current value on a stack, and on exit you restore that value, and any value you put there can be seen by your callees.  oddly enough, this turns out to be another efficiency advantage for lexical scoping; with dynamic scoping, when you call another function, the language semantics are that it could change any of your local variable values before it returns, so it&#x27;s not safe for the compiler to cache its value in a cpu register across the call.  (unless the variable is assigned to that cpu register for your entire program, that is, which requires whole-program optimizations that run counter to the lisp zeitgeist.)  this has become an increasingly big deal as the relative cost of accessing memory instead of a cpu register has steadily increased over the last 40 years<p>i&#x27;m no expert in this stuff, though i did implement a subset of scheme with recursion, lexical scoping, closures, and enough power to run its own compiler (and basically nothing else): <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;urscheme" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;urscheme</a> so i could totally be wrong about any of this stuff</div><br/><div id="36734375" class="c"><input type="checkbox" id="c-36734375" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36733173">root</a><span>|</span><a href="#36733759">parent</a><span>|</span><a href="#36732987">next</a><span>|</span><label class="collapse" for="c-36734375">[-]</label><label class="expand" for="c-36734375">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget that lexicals can be subject to some nice optimizations. A lexical variable that is loaded with a constant and never assigned can be constant-propagated, and disappear. Lexical variables that aren&#x27;t captured in closures can be moved into registers.<p>There are more opportunities to do these kinds of things with lexical variables compared to dynamic, because we don&#x27;t know what happens with a dynamic variable when some function is called that we know nothing about. If a scope calls any functions at all whose definitions are not available or cannot be analyzed, then it has to be assumed that any dynamic variable used in the scope is also accessed and mutated by those functions, which defeats these optimizations.<p>When native code is generated, VM temporary registers can be allocated to real machine registers; any variables that have been moved to VM temp registers benefit.<p>Your observation is spot on that the discipline for saving and restoring registers is like binding and unbinding dynamic variables. But there is only a fixed, relatively small number of registers, which makes it practical to save and restore them transparently at thread context switches. This means that even under multi-threading, procedures can just save and restore registers as if everything were single-threaded.
Dynamic variables under threading cannot be treated by saving and restoring. That would require each thread to have its own, which would be expensive to switch. (The top-level&#x2F;global bindings of dynamics have to be seen by all threads, also, which means that if threads have their own file of dynamic variables, there nevertheless has to be some indirection so that threads can share the global bindings.)<p>Under a deep binding strategy for dynamic scope, you have an environment chain of scopes for dynamic variables. That scope is rooted at a single pointer, which <i>can</i> be turned into a thread context: so one word of thread context switches dynamic scopes.  With deep binding, some optimizations are possible: when a scope is entered that references a dynamic variable, that variable can be looked up in the deep environment to retrieve its value cell, and that value cell can be forwarded into the lexical frame or a register. All the accesses of the variable in the scope refer to that register, which provides a quick indirection to the variable, without the environmental lookup having to be repeated. Dynamic variables can also be forwarded to aliases at the top of the environment for faster lookup next time. We cannot move a dynamic variable from a deeper frame to the top frame, because that would make it disappear from some upstream scope we have to return to. But we can plant an alias which references the same location.</div><br/></div></div></div></div></div></div><div id="36732987" class="c"><input type="checkbox" id="c-36732987" checked=""/><div class="controls bullet"><span class="by">NikkiA</span><span>|</span><a href="#36733173">prev</a><span>|</span><a href="#36732628">next</a><span>|</span><label class="collapse" for="c-36732987">[-]</label><label class="expand" for="c-36732987">[2 more]</label></div><br/><div class="children"><div class="content">It has a homepage, with sources, now:<p><a href="http:&#x2F;&#x2F;mumble.net&#x2F;~jar&#x2F;tproject&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;mumble.net&#x2F;~jar&#x2F;tproject&#x2F;</a></div><br/><div id="36733169" class="c"><input type="checkbox" id="c-36733169" checked=""/><div class="controls bullet"><span class="by">NikkiA</span><span>|</span><a href="#36732987">parent</a><span>|</span><a href="#36732628">next</a><span>|</span><label class="collapse" for="c-36733169">[-]</label><label class="expand" for="c-36733169">[1 more]</label></div><br/><div class="children"><div class="content">In particular, I find it amusing the comment about CLOS using send and smalltalk message passing semantics, xlisp was the last common lisp I remember that used smalltalk style message passing for it&#x27;s OO, and it deprecated it in the early 90s in favor of a new system before rewriting itself as a scheme instead of a common lisp.<p>In fact, when we were taught common lisp in &#x27;91, we were specifically warned that the xlisp that we were using was an outlier in using messages, and that we should semi-ignore that when we came across a &#x27;real&#x27; common lisp variant.</div><br/></div></div></div></div><div id="36732628" class="c"><input type="checkbox" id="c-36732628" checked=""/><div class="controls bullet"><span class="by">brianpan</span><span>|</span><a href="#36732987">prev</a><span>|</span><a href="#36733136">next</a><span>|</span><label class="collapse" for="c-36732628">[-]</label><label class="expand" for="c-36732628">[3 more]</label></div><br/><div class="children"><div class="content">I think this is from 2001 per Wayback. I hate that PG&#x27;s essays don&#x27;t have dates.</div><br/><div id="36733908" class="c"><input type="checkbox" id="c-36733908" checked=""/><div class="controls bullet"><span class="by">akkartik</span><span>|</span><a href="#36732628">parent</a><span>|</span><a href="#36732907">next</a><span>|</span><label class="collapse" for="c-36733908">[-]</label><label class="expand" for="c-36733908">[1 more]</label></div><br/><div class="children"><div class="content">PG&#x27;s essays do have dates. Try clicking through to all the items in <a href="http:&#x2F;&#x2F;paulgraham.com&#x2F;articles.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;paulgraham.com&#x2F;articles.html</a>. I can&#x27;t remember ever seeing one that didn&#x27;t have month and year.<p>OP wasn&#x27;t written by PG, though. There&#x27;s no index for such posts that I&#x27;m aware of, so I don&#x27;t know what their information architecture is.</div><br/></div></div><div id="36732907" class="c"><input type="checkbox" id="c-36732907" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#36732628">parent</a><span>|</span><a href="#36733908">prev</a><span>|</span><a href="#36733136">next</a><span>|</span><label class="collapse" for="c-36732907">[-]</label><label class="expand" for="c-36732907">[1 more]</label></div><br/><div class="children"><div class="content">Same. Even if essays are timeless, it still helps to know the context in which they were written.</div><br/></div></div></div></div><div id="36733136" class="c"><input type="checkbox" id="c-36733136" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#36732628">prev</a><span>|</span><a href="#36733103">next</a><span>|</span><label class="collapse" for="c-36733136">[-]</label><label class="expand" for="c-36733136">[1 more]</label></div><br/><div class="children"><div class="content">As someone who loves Lisp and PL research in general, I enjoyed reading this article!  I&#x27;m familiar with the original Scheme papers and I&#x27;ve been slowly reading <i>Compiling with Continuations</i>.  It&#x27;s really cool hearing the personal accounts of those who worked on interesting projects!</div><br/></div></div><div id="36733103" class="c"><input type="checkbox" id="c-36733103" checked=""/><div class="controls bullet"><span class="by">cherrypickin</span><span>|</span><a href="#36733136">prev</a><span>|</span><a href="#36733246">next</a><span>|</span><label class="collapse" for="c-36733103">[-]</label><label class="expand" for="c-36733103">[1 more]</label></div><br/><div class="children"><div class="content">Olin Shivers’s PhD thesis is critical reading for anyone looking to analyze modern dynamic languages. Super interesting.  Look back to look forward.</div><br/></div></div></div></div></div></div></div></body></html>