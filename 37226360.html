<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692781262601" as="style"/><link rel="stylesheet" href="styles.css?v=1692781262601"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bitecode.dev/p/asyncio-twisted-tornado-gevent-walk">Asyncio, twisted, tornado, gevent walk into a bar</a> <span class="domain">(<a href="https://www.bitecode.dev">www.bitecode.dev</a>)</span></div><div class="subtext"><span>BiteCode_dev</span> | <span>62 comments</span></div><br/><div><div id="37232016" class="c"><input type="checkbox" id="c-37232016" checked=""/><div class="controls bullet"><span class="by">smilliken</span><span>|</span><a href="#37227383">next</a><span>|</span><label class="collapse" for="c-37232016">[-]</label><label class="expand" for="c-37232016">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using gevent for 12+ years in a large codebase that uses it everwhere. It&#x27;s wonderful, and I&#x27;m totally spoiled by how well it interoperates with code that wasn&#x27;t designed to be async (especially library code that I don&#x27;t want to refactor before using). There&#x27;s no boilerplate. It takes no time to teach new people, and rarely do they even need to understand how async even works to write the correct code. I think it&#x27;s a shame that asyncio became the defacto approach from cpython, because it would have been so much better for the ecosystem if cpython blessed gevent as the recommended approach. Still, gevent continues to be the best solution today and beyond.</div><br/><div id="37232382" class="c"><input type="checkbox" id="c-37232382" checked=""/><div class="controls bullet"><span class="by">sandGorgon</span><span>|</span><a href="#37232016">parent</a><span>|</span><a href="#37227383">next</a><span>|</span><label class="collapse" for="c-37232382">[-]</label><label class="expand" for="c-37232382">[1 more]</label></div><br/><div class="children"><div class="content">agreed. There is an equivalent in Java - RxJava used extensively and android and somewhat on server.
Everytime i use it, i get a lot of hate.<p>We use it in EdgeChains  <a href="https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;edgechains">https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;edgechains</a></div><br/></div></div></div></div><div id="37227383" class="c"><input type="checkbox" id="c-37227383" checked=""/><div class="controls bullet"><span class="by">shanemhansen</span><span>|</span><a href="#37232016">prev</a><span>|</span><a href="#37228919">next</a><span>|</span><label class="collapse" for="c-37227383">[-]</label><label class="expand" for="c-37227383">[10 more]</label></div><br/><div class="children"><div class="content">Great article. I had the misfortune of writing a bunch of twisted code over a decade ago and I wanted to remind the author that twisted has a feature called &quot;inline callbacks&quot; that allow you to use yield. <a href="https:&#x2F;&#x2F;twisted.org&#x2F;documents&#x2F;16.4.1&#x2F;core&#x2F;howto&#x2F;defer-intro.html#inline-callbacks-using-yield" rel="nofollow noreferrer">https:&#x2F;&#x2F;twisted.org&#x2F;documents&#x2F;16.4.1&#x2F;core&#x2F;howto&#x2F;defer-intro....</a><p>So twisted code can actually look like:<p><pre><code>    @inlineCallbacks
    def doIt():
        responseBody = yield makeRequest(&quot;GET&quot;, &quot;&#x2F;users&quot;)
        returnValue(json.loads(responseBody))
</code></pre>
iirc `returnValue` throws an exception of a specific type. It&#x27;s ugly, but it&#x27;s also the logical implementation of async on top of yield&#x2F;generators.</div><br/><div id="37229861" class="c"><input type="checkbox" id="c-37229861" checked=""/><div class="controls bullet"><span class="by">bevenky</span><span>|</span><a href="#37227383">parent</a><span>|</span><a href="#37227932">next</a><span>|</span><label class="collapse" for="c-37229861">[-]</label><label class="expand" for="c-37229861">[4 more]</label></div><br/><div class="children"><div class="content">This is so nostalgic. I actually met my cofounder on github due to a discussion on twisted vs gevent back in 2011. I had my inital code in twisted and he wrote the gevent piece. Fast forward 12 years and we still use gevent at <a href="http:&#x2F;&#x2F;plivo.com" rel="nofollow noreferrer">http:&#x2F;&#x2F;plivo.com</a> :)<p>Some of our initial code snippets:<p># Twisted<p>def __protocolSendRaw(self, name, args=&quot;&quot;):
     deferred = defer.Deferred()
     self.__EventQueue.append((name, deferred))
     self.rawSend(&quot;%s %s&quot; % (name, args))
     return deferred<p># Gevent<p>def _protocol_sendmsg(self, name, args=None, async=False):
        if self._closing_state:
            return Event()
        _async_res = gevent.event.AsyncResult()
        _uuid, event = _async_res.get()
        return event</div><br/><div id="37231824" class="c"><input type="checkbox" id="c-37231824" checked=""/><div class="controls bullet"><span class="by">kldx</span><span>|</span><a href="#37227383">root</a><span>|</span><a href="#37229861">parent</a><span>|</span><a href="#37231977">next</a><span>|</span><label class="collapse" for="c-37231824">[-]</label><label class="expand" for="c-37231824">[2 more]</label></div><br/><div class="children"><div class="content">Off topic: PLIVO, the norwegian term actually is a protocol used by critical services here. Thought you might find it interesting :)<p>&gt; PLIVO (an abbreviation for ongoing life-threatening violence) is a procedure for cooperation between the police, the fire service, the rescue service and the healthcare system in incidents where life-threatening violence is perpetrated against several people.</div><br/><div id="37233278" class="c"><input type="checkbox" id="c-37233278" checked=""/><div class="controls bullet"><span class="by">bevenky</span><span>|</span><a href="#37227383">root</a><span>|</span><a href="#37231824">parent</a><span>|</span><a href="#37231977">next</a><span>|</span><label class="collapse" for="c-37233278">[-]</label><label class="expand" for="c-37233278">[1 more]</label></div><br/><div class="children"><div class="content">Nice, did not know this.. Plivo in latvian means flying high, thats was one of the languages we named it based on.</div><br/></div></div></div></div><div id="37231977" class="c"><input type="checkbox" id="c-37231977" checked=""/><div class="controls bullet"><span class="by">joshxyz</span><span>|</span><a href="#37227383">root</a><span>|</span><a href="#37229861">parent</a><span>|</span><a href="#37231824">prev</a><span>|</span><a href="#37227932">next</a><span>|</span><label class="collapse" for="c-37231977">[-]</label><label class="expand" for="c-37231977">[1 more]</label></div><br/><div class="children"><div class="content">damn i had memories of using plivo back in 2012 2013 2014</div><br/></div></div></div></div><div id="37227932" class="c"><input type="checkbox" id="c-37227932" checked=""/><div class="controls bullet"><span class="by">plq</span><span>|</span><a href="#37227383">parent</a><span>|</span><a href="#37229861">prev</a><span>|</span><a href="#37228532">next</a><span>|</span><label class="collapse" for="c-37227932">[-]</label><label class="expand" for="c-37227932">[1 more]</label></div><br/><div class="children"><div class="content">returnValue raises a specific exception that inlineCallbacks understands and translates to a normal return value. It was a hack that was only needed for python versions that couldn&#x27;t have generators return non-None values. With modern versions, you don&#x27;t need it anymore -- just use return.</div><br/></div></div><div id="37228532" class="c"><input type="checkbox" id="c-37228532" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#37227383">parent</a><span>|</span><a href="#37227932">prev</a><span>|</span><a href="#37228883">next</a><span>|</span><label class="collapse" for="c-37228532">[-]</label><label class="expand" for="c-37228532">[1 more]</label></div><br/><div class="children"><div class="content">While inlineCallbacks exists, and indeed works, I would recommend not using it. I recall it not interacting with mypy particularly well, and in general being such a hack it had some annoying sharp edges. Explicit callbacks might be annoying but at least they are extremely clear on what&#x27;s happening.</div><br/></div></div><div id="37231923" class="c"><input type="checkbox" id="c-37231923" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#37227383">parent</a><span>|</span><a href="#37228883">prev</a><span>|</span><a href="#37227566">next</a><span>|</span><label class="collapse" for="c-37231923">[-]</label><label class="expand" for="c-37231923">[1 more]</label></div><br/><div class="children"><div class="content">My last job (2019 - 2022) was in part shepherding a 2013-era Python 2 Tornado-and-Motor (yes the async implementation of the MongoDB driver for Python) application into Python 3 and such modern niceties.<p>Absolutely fuck yield-raise based async implementations. Just remembering those induces psychic damage; implementing async as a massive hack on top of the language is impressive but also the kind of thing we&#x27;re going to whisper to junior engineers as scary campfire stories for DECADES.</div><br/></div></div><div id="37227566" class="c"><input type="checkbox" id="c-37227566" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37227383">parent</a><span>|</span><a href="#37231923">prev</a><span>|</span><a href="#37228919">next</a><span>|</span><label class="collapse" for="c-37227566">[-]</label><label class="expand" for="c-37227566">[1 more]</label></div><br/><div class="children"><div class="content">Also, asyncio started like this as well.</div><br/></div></div></div></div><div id="37228919" class="c"><input type="checkbox" id="c-37228919" checked=""/><div class="controls bullet"><span class="by">Fizzadar</span><span>|</span><a href="#37227383">prev</a><span>|</span><a href="#37226364">next</a><span>|</span><label class="collapse" for="c-37228919">[-]</label><label class="expand" for="c-37228919">[2 more]</label></div><br/><div class="children"><div class="content">Really good write up. Been using gevent in pyinfra[1] for years and swear by it. Had some pains with setup, and am usually very wary of such magic, but it’s just really solid. Mostly write go these days though which has taken the shine off for sure!<p>Twisted, however, is a different beast. Have spent s decent chunk of time working on Matrix synapse homeserver[2], written in twisted, and oh my it just sucks.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Fizzadar&#x2F;pyinfra">https:&#x2F;&#x2F;github.com&#x2F;Fizzadar&#x2F;pyinfra</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;synapse">https:&#x2F;&#x2F;github.com&#x2F;matrix-org&#x2F;synapse</a></div><br/></div></div><div id="37226364" class="c"><input type="checkbox" id="c-37226364" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37228919">prev</a><span>|</span><a href="#37233097">next</a><span>|</span><label class="collapse" for="c-37226364">[-]</label><label class="expand" for="c-37226364">[4 more]</label></div><br/><div class="children"><div class="content"><i>Summary</i>:<p>Concurrency has a lot to do with sharing one resource, and Python has dedicated tools to deal with that depending on the resource you must share.<p>If you have to share one CPU while waiting on the network, then the specialized tools for this are asyncio, twisted, trio, gevent, etc.<p>Asyncio is the current standard to do this, but tornado, gevent and twisted solved this problem more than a decade ago. While trio and curio are showing us what the future could look like.<p>But chances are, you should use none of them.</div><br/><div id="37228422" class="c"><input type="checkbox" id="c-37228422" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#37226364">parent</a><span>|</span><a href="#37233097">next</a><span>|</span><label class="collapse" for="c-37228422">[-]</label><label class="expand" for="c-37228422">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But chances are, you should use none of them.<p>So, no event-oriented programming in Python, or by some other mechanism, or…?</div><br/><div id="37228518" class="c"><input type="checkbox" id="c-37228518" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37226364">root</a><span>|</span><a href="#37228422">parent</a><span>|</span><a href="#37233097">next</a><span>|</span><label class="collapse" for="c-37228518">[-]</label><label class="expand" for="c-37228518">[2 more]</label></div><br/><div class="children"><div class="content">From the conclusion of the article:<p>&gt; If you need to get a few URLS fast, a ThreadPoolExecutor is likely the Pareto solution, 99% of the time.<p>I agree with this. ThreadPoolExecutor is easy to use. In general, using threads in Python to handle concurrent I&#x2F;O is pretty simple and plenty performant.</div><br/><div id="37232272" class="c"><input type="checkbox" id="c-37232272" checked=""/><div class="controls bullet"><span class="by">zo1</span><span>|</span><a href="#37226364">root</a><span>|</span><a href="#37228518">parent</a><span>|</span><a href="#37233097">next</a><span>|</span><label class="collapse" for="c-37232272">[-]</label><label class="expand" for="c-37232272">[1 more]</label></div><br/><div class="children"><div class="content">Or just use an async Http client with a little asyncio snippet. Depends on what you&#x27;re comfortable with and what code you have running already.<p>If you&#x27;re a junior and have no clue, your best bet is to ask a senior in your team though.</div><br/></div></div></div></div></div></div></div></div><div id="37233097" class="c"><input type="checkbox" id="c-37233097" checked=""/><div class="controls bullet"><span class="by">wasmitnetzen</span><span>|</span><a href="#37226364">prev</a><span>|</span><a href="#37232688">next</a><span>|</span><label class="collapse" for="c-37233097">[-]</label><label class="expand" for="c-37233097">[2 more]</label></div><br/><div class="children"><div class="content">That cashier analogy seems quite bad. You&#x27;re looking for an example of cooperative multitasking and you&#x27;re taking customers waiting in a line, the least cooperative group of people in the world? Also, I have never seen a store setup where a cashier is shared between two lines and is handling the other line while they are waiting for your payment to go through.<p>I feel like car sharing services are a better analogy. If you&#x27;re not using the car, someone else can.</div><br/><div id="37233196" class="c"><input type="checkbox" id="c-37233196" checked=""/><div class="controls bullet"><span class="by">baggiponte</span><span>|</span><a href="#37233097">parent</a><span>|</span><a href="#37232688">next</a><span>|</span><label class="collapse" for="c-37233196">[-]</label><label class="expand" for="c-37233196">[1 more]</label></div><br/><div class="children"><div class="content">I don’t fully disagree, but I get that the author just wanted something straightforward and oversimplified because the scope of the article was something else.</div><br/></div></div></div></div><div id="37232688" class="c"><input type="checkbox" id="c-37232688" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37233097">prev</a><span>|</span><a href="#37230013">next</a><span>|</span><label class="collapse" for="c-37232688">[-]</label><label class="expand" for="c-37232688">[2 more]</label></div><br/><div class="children"><div class="content">I have always had a hard time with this parallel &#x2F; concurrent distinction.  I think it’s because of how many layers of abstraction the machine has.  Many threads per core.  Many cores per package.  Multiple packages on a motherboard.<p>Is there a practical distinction?  It feels like there isn’t.  It’s not as if a two CPU machine can run two Python processes “in parallel” as opposed to “concurrently”.  I have 100 other processes running too.  It’s all concurrency, and never parallel.<p>Perhaps the author and others are distinguishing between concurrency that can happen at the granularity of any instruction (e.g. threading) compared to cooperative yielding that only happens when await is called (e.g. asyncio.)</div><br/><div id="37233045" class="c"><input type="checkbox" id="c-37233045" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37232688">parent</a><span>|</span><a href="#37230013">next</a><span>|</span><label class="collapse" for="c-37233045">[-]</label><label class="expand" for="c-37233045">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there a practical distinction?<p>I’m not sure if this will help, but I think of it like - parallelism is running the same task in multiple threads &#x2F; on multiple cores at once. And concurrency is “concurrently” running different tasks on one core.<p>Nodejs is a purely single threaded runtime. Let’s say you have a web server in node processing http requests.<p>- Your program implements <i>concurrency</i> by yielding back to the event loop instead of blocking. Request 1 comes in, and then sends a query to the database. While we wait for the database to respond to the query, we can process request 2.<p>- You usually implement <i>parallelism</i> with nodejs by running multiple instances of your nodejs server process across all your cores. (Then use a program like nginx to load balance requests across all the node processes.)<p>The GPU might be a better example. When rendering a frame, the graphics card runs a small program (called a fragment shader) for every pixel on the screen. A 4090 has ~16000 cores which can all run the same fragment shader on different pixels at the same time. This is called parallelism, not concurrency. Concurrency would be if you had two video games open at once and your graphics card was quickly swapping between rendering frames for game A and game B.</div><br/></div></div></div></div><div id="37230013" class="c"><input type="checkbox" id="c-37230013" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#37232688">prev</a><span>|</span><a href="#37232716">next</a><span>|</span><label class="collapse" for="c-37230013">[-]</label><label class="expand" for="c-37230013">[8 more]</label></div><br/><div class="children"><div class="content">Is it true that these frameworks only work with async compatible libraries? Will a typical pypi lib work with them? For example, a css or xpath parsing library, or date time library - do I have to worry about those blocking and not working properly with asyncio or the others? Or only network and file reading libs?<p>I wish the article had spent more time on this. Without more info I would probably just use what the author mentions at the end as the Pareto ideal solution (ThreadPoolExecutor) because usually async frameworks in not historically async languages end up being islands within the larger community that need their own bespoke libraries.</div><br/><div id="37230043" class="c"><input type="checkbox" id="c-37230043" checked=""/><div class="controls bullet"><span class="by">btreecat</span><span>|</span><a href="#37230013">parent</a><span>|</span><a href="#37230959">next</a><span>|</span><label class="collapse" for="c-37230043">[-]</label><label class="expand" for="c-37230043">[6 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t use IO&#x2F;make any external calls when you are parsing, or doing date time, so they don&#x27;t have an opportunity to &quot;cooperate&quot; by letting another thread execute while they wait for the IO to finish.</div><br/><div id="37230062" class="c"><input type="checkbox" id="c-37230062" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#37230013">root</a><span>|</span><a href="#37230043">parent</a><span>|</span><a href="#37230959">next</a><span>|</span><label class="collapse" for="c-37230062">[-]</label><label class="expand" for="c-37230062">[5 more]</label></div><br/><div class="children"><div class="content">Thanks. So even chewy compute operations (parsing a big html page then running a complicated xpath against it) are ok? What would be an example of blocking - is it just network io? Presumably file io too?<p>Update: I think I’m conflating a bit what I want to speed up with what is allowed. Presumably heavy compute stuff is perfectly compatible with asyncio but it won’t speed it up - it would speed up a lot of io operations. ThreadPoolExecutor can speed up heavy compute by parallelizing (if it’s heavy enough) but may be overkill for just downloading 20 web pages at once.</div><br/><div id="37230744" class="c"><input type="checkbox" id="c-37230744" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37230013">root</a><span>|</span><a href="#37230062">parent</a><span>|</span><a href="#37230119">next</a><span>|</span><label class="collapse" for="c-37230744">[-]</label><label class="expand" for="c-37230744">[1 more]</label></div><br/><div class="children"><div class="content">The basic idea is that file IO and socket IO will allow a task to be suspended while the IO is happening, and let another task do its work.<p>On top of that, you can write a C extension that will let you run compute heavy work in a way that allows your task to be suspended (for example, the C extension spins up its own thread). This extension has to be &quot;very careful&quot;, basically by avoiding touching Python-side data during this work.<p>The way this sort of stuff ends up working is you pass data into a C extension, and that extension takes ownership of the data or copies it or whatever, does what it needs, then gives Python back some result.<p>But if you&#x27;re just pure-Python compute heavy, then your task won&#x27;t be suspended. So everything will run, but your compute-heavy stuff will hog the CPU, and won&#x27;t be suspended. (Though if you have compute heavy work that is, like, looping over data, you could add `sleep(0)` between every couple of iterations. This gives other tasks a chance to run! This could be good enough to prevent weird bottlenecks).<p>But the ultimate thing is if you have N compute-heavy tasks, you probably won&#x27;t get speed advantages. If you have 1 compute-heavy task and N IO-heavy tasks, you can get advantages (even if the IO-heavy stuff is interspersed). But if you have N compute-heavy tasks and not much IO-heavy tasks, multiprocessing can get you where you want (since it&#x27;s usually IO-heavy stuff that is helped out the most with async&#x2F;await)</div><br/></div></div><div id="37230119" class="c"><input type="checkbox" id="c-37230119" checked=""/><div class="controls bullet"><span class="by">btreecat</span><span>|</span><a href="#37230013">root</a><span>|</span><a href="#37230062">parent</a><span>|</span><a href="#37230744">prev</a><span>|</span><a href="#37231436">next</a><span>|</span><label class="collapse" for="c-37230119">[-]</label><label class="expand" for="c-37230119">[1 more]</label></div><br/><div class="children"><div class="content">If you are parsing a big thing of text, there is no opportunity for your thread to pause the CPU and say &quot;ok other threads, I have to wait on some external data&quot; and then hand over the CPU resources.<p>But if you are trying to make a network request, disk or memory access, or any HID stuff, you might have to wait on that thing to do it&#x27;s job and get back to you. At this point you can tell your thread to raise it&#x27;s hand and say &quot;hey, I don&#x27;t know how long, but I know I need to wait for this thing to finish, so while I wait someone else can use the CPU, but when I am done waiting, I will need the CPU back.&quot; This is the core idea of &quot;cooperative threads&quot; or green threads or co-routines or any sort of thread that is at the language runtime level and not at the OS level.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cooperative_multitasking" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cooperative_multitasking</a><p>So consider if the task you are doing is asking for data from &quot;somewhere external to my thread&quot; then you might be able to make that call non-blocking to enable more throughput.<p>Hope that helps explain it!</div><br/></div></div><div id="37231436" class="c"><input type="checkbox" id="c-37231436" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#37230013">root</a><span>|</span><a href="#37230062">parent</a><span>|</span><a href="#37230119">prev</a><span>|</span><a href="#37230172">next</a><span>|</span><label class="collapse" for="c-37231436">[-]</label><label class="expand" for="c-37231436">[1 more]</label></div><br/><div class="children"><div class="content">CPU-heavy operations are <i>allowed</i>, strictly speaking, they&#x27;re just &quot;impolite&quot; and may cause subtle problems.<p>for example, say you have an aiohttp-backed web server, and in the handler for some URL route, you do a CPU-bound computation that takes 5 full seconds to execute.<p>a crucial thing to remember is that asyncio programs, by default, are still single-threaded. so for those 5 seconds, your computation is the only thing running. other event loop tasks are unable to run. the loop is &quot;blocked&quot; in the same way it would be as if you called `time.sleep()` (not `await asyncio.sleep()`, but the regular synchronous sleep method) or made a blocking IO call (in a pathological case, you might open and read a file on a remote NFS share mounted over a WAN link, for example)<p>now, suppose your web server exposes an `&#x2F;alive` healthcheck endpoint. during that 5-second interval where you&#x27;re hogging both the CPU and the event loop, aiohttp won&#x27;t be able to dispatch requests to the healthcheck endpoint. if your load balancer has a 3-second timeout for those healthchecks, from its perspective the service will appear to be flapping between online and offline, even though the service itself never actually goes down.<p>the &quot;polite&quot; thing to do, for this sort of big CPU-bound task, is to hand them off to a ThreadPoolExecutor like you said (or ProcessPoolExecutor if you have GIL concerns) with `loop.run_in_executor` [0]. that gives you a future, and when you `await` the future you are politely yielding the event loop to allow other tasks to run, such as those requests to the healthcheck endpoint.<p>0: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-eventloop.html#asy...</a></div><br/></div></div><div id="37230172" class="c"><input type="checkbox" id="c-37230172" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#37230013">root</a><span>|</span><a href="#37230062">parent</a><span>|</span><a href="#37231436">prev</a><span>|</span><a href="#37230959">next</a><span>|</span><label class="collapse" for="c-37230172">[-]</label><label class="expand" for="c-37230172">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  it would speed up a lot of io operations<p>It doesn&#x27;t speed up the I&#x2F;O operation, but allows the CPU to continue executing other code rather than blocking and waiting (and the program becoming unresponsive).<p>If your app is querying a database ten times per user request and averaging 5-10ms per query, your CPU is spending 50-100ms doing nothing but waiting on the network to finish so it can resume executing the code that comes next. That&#x27;s time other code that has CPU instructions that can execute now would benefit from.</div><br/></div></div></div></div></div></div><div id="37230959" class="c"><input type="checkbox" id="c-37230959" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37230013">parent</a><span>|</span><a href="#37230043">prev</a><span>|</span><a href="#37232716">next</a><span>|</span><label class="collapse" for="c-37230959">[-]</label><label class="expand" for="c-37230959">[1 more]</label></div><br/><div class="children"><div class="content">asyncio yes. gevent no. if you patch at an entrypoint you&#x27;ll be ok 99 times out of 100.</div><br/></div></div></div></div><div id="37232716" class="c"><input type="checkbox" id="c-37232716" checked=""/><div class="controls bullet"><span class="by">damagednoob</span><span>|</span><a href="#37230013">prev</a><span>|</span><a href="#37232791">next</a><span>|</span><label class="collapse" for="c-37232716">[-]</label><label class="expand" for="c-37232716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You have to understand that async programming is hard, and no matter how good the tooling is, it&#x27;s going to make your code more difficult to manage. It has a high price.<p>Is it unfashionable to say that NodeJS got this right with &gt; v7.6? It&#x27;s always felt pretty straightforward to me but perhaps it just suits my mindset. It&#x27;s only when I try to do this in other languages (e.g. Python or Ruby) that it starts to feel clunky.</div><br/></div></div><div id="37232791" class="c"><input type="checkbox" id="c-37232791" checked=""/><div class="controls bullet"><span class="by">wraptile</span><span>|</span><a href="#37232716">prev</a><span>|</span><a href="#37228667">next</a><span>|</span><label class="collapse" for="c-37232791">[-]</label><label class="expand" for="c-37232791">[1 more]</label></div><br/><div class="children"><div class="content">Honestly asyncio is good and you shouldn&#x27;t bother with twisted, tornato or gevent ever unless you inherit an existing code base. I like trio features but code quickly turns super verbose ang ugly with the abdundance of with statements - maybe with it&#x27;s more bearable with a bit of syntax sugar.</div><br/></div></div><div id="37228667" class="c"><input type="checkbox" id="c-37228667" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#37232791">prev</a><span>|</span><a href="#37232494">next</a><span>|</span><label class="collapse" for="c-37228667">[-]</label><label class="expand" for="c-37228667">[2 more]</label></div><br/><div class="children"><div class="content">I struggle to call fastapi a microframework, or even bundle it in the same category as flask. Starlette, the actually small framework at the core of fastapi, fits the description better and would have deserved a mention imho.</div><br/><div id="37229044" class="c"><input type="checkbox" id="c-37229044" checked=""/><div class="controls bullet"><span class="by">throwmeout123</span><span>|</span><a href="#37228667">parent</a><span>|</span><a href="#37232494">next</a><span>|</span><label class="collapse" for="c-37229044">[-]</label><label class="expand" for="c-37229044">[1 more]</label></div><br/><div class="children"><div class="content">But its also not a framework as it offers barely any facilities for mid+ size projects, which immediately start to crack under the weight of trying to reimplement Django</div><br/></div></div></div></div><div id="37232494" class="c"><input type="checkbox" id="c-37232494" checked=""/><div class="controls bullet"><span class="by">6r17</span><span>|</span><a href="#37228667">prev</a><span>|</span><a href="#37227959">next</a><span>|</span><label class="collapse" for="c-37232494">[-]</label><label class="expand" for="c-37232494">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used gEvent, but while asyncio doesn&#x27;t completely burn the code-base I&#x27;ve met projects that were built on tornado and for which it was disastrous.<p>What I really like about asyncio is that there isn&#x27;t much of deps or forced loop in order to get it working.<p>But I could be mislead and just not know how it is achieved in tornado, does gEvent burn the codebase as well ?</div><br/></div></div><div id="37227959" class="c"><input type="checkbox" id="c-37227959" checked=""/><div class="controls bullet"><span class="by">plq</span><span>|</span><a href="#37232494">prev</a><span>|</span><a href="#37227567">next</a><span>|</span><label class="collapse" for="c-37227959">[-]</label><label class="expand" for="c-37227959">[3 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the said black magic (for amd64&#x2F;unix) that the gevent project relies on:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;python-greenlet&#x2F;greenlet&#x2F;blob&#x2F;master&#x2F;src&#x2F;greenlet&#x2F;platform&#x2F;switch_amd64_unix.h">https:&#x2F;&#x2F;github.com&#x2F;python-greenlet&#x2F;greenlet&#x2F;blob&#x2F;master&#x2F;src&#x2F;...</a><p>I still think it&#x27;s too much for a Python project -- if you think you need this in 2023, maybe you need to reevaluate? I&#x27;d seriously have another look at Go.</div><br/><div id="37228374" class="c"><input type="checkbox" id="c-37228374" checked=""/><div class="controls bullet"><span class="by">d1l</span><span>|</span><a href="#37227959">parent</a><span>|</span><a href="#37228117">next</a><span>|</span><label class="collapse" for="c-37228374">[-]</label><label class="expand" for="c-37228374">[1 more]</label></div><br/><div class="children"><div class="content">All greenlet does is allow the Python frames to managed separately from the C call stack - it is very similar to what Pypy is also doing. I don&#x27;t think your characterization is at all accurate.</div><br/></div></div><div id="37228117" class="c"><input type="checkbox" id="c-37228117" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#37227959">parent</a><span>|</span><a href="#37228374">prev</a><span>|</span><a href="#37227567">next</a><span>|</span><label class="collapse" for="c-37228117">[-]</label><label class="expand" for="c-37228117">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s surprisingly readable and understandable. Nice work by the authors for encapsulating it so well.</div><br/></div></div></div></div><div id="37227567" class="c"><input type="checkbox" id="c-37227567" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#37227959">prev</a><span>|</span><a href="#37230439">next</a><span>|</span><label class="collapse" for="c-37227567">[-]</label><label class="expand" for="c-37227567">[3 more]</label></div><br/><div class="children"><div class="content">Eventlet (Linden Labs) actually owns the bar, then.<p>Edit<p>Green threads &gt; Green threads in other languages: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Green_thread#Green_threads_in_other_languages" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Green_thread#Green_threads_in_...</a><p>Coroutine &gt; Comparison with &gt; Threads, Generators: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coroutine#Implementations_for_C" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coroutine#Implementations_for_...</a> :<p>&gt; <i>Generators, also known as</i> semicoroutines<i>, [8] are a subset of coroutines. Specifically, while both can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines&#x27; ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator&#x27;s caller.[9] That is, since generators are primarily used to simplify the writing of iterators, the yield statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.</i><p>&gt; (<i>However, it is still possible to implement coroutines on top of a generator facility</i>)<p>Asynchronous I&#x2F;O &gt; Forms &gt; Light-weight processes or threads: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asynchronous_I&#x2F;O#Light-weight_processes_or_threads" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asynchronous_I&#x2F;O#Light-weight_...</a><p>Async&#x2F;Await &gt; History, Benefits and criticisms: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Async&#x2F;await" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Async&#x2F;await</a></div><br/><div id="37229165" class="c"><input type="checkbox" id="c-37229165" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37227567">parent</a><span>|</span><a href="#37230439">next</a><span>|</span><label class="collapse" for="c-37229165">[-]</label><label class="expand" for="c-37229165">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That is, since generators are primarily used to simplify the writing of iterators, the yield statement in a generator does not specify a coroutine to jump to, but rather passes a value back to a parent routine.<p>Another term for this asymmetric coroutine, as opposed to symmetric coroutine. Coroutines in Lua are asymmetric, but they&#x27;re not generally referred to as generators as they&#x27;re much more capable than what are called generators in other languages, like Python. This is largely because Lua&#x27;s coroutines are stackful rather than stackless, which is an orthogonal, more pertinent dimension when implementing concurrency frameworks.<p>You can implement symmetric coroutines using asymmetric coroutines, and vice versa, by implementing a higher-level library that implements one using the other. So in principle they have equivalent expressive power, formally speaking. Ultimately the distinction between these terms, including generator, comes down to implementation details and your objective. And just because a language name-drops one of these terms doesn&#x27;t mean what they provide will be as useful or convenient in practice as a similarly named feature in another language. Other dimensions--stack semantics, type system integration, etc--can easily prove the determining factor in how useful they are.</div><br/><div id="37230382" class="c"><input type="checkbox" id="c-37230382" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#37227567">root</a><span>|</span><a href="#37229165">parent</a><span>|</span><a href="#37230439">next</a><span>|</span><label class="collapse" for="c-37230382">[-]</label><label class="expand" for="c-37230382">[1 more]</label></div><br/><div class="children"><div class="content">PROMPT: Generate a table of per- process&#x2F;thread&#x2F;greenthread&#x2F;coroutine costs in terms of stack&#x2F;less&#x2F;heap overhead, CPU cache thrashing impact, and compatibility with various OS schedulers that are or are not preferred to eBPF<p>Is it necessary to use a library like trio for nonblocking io in lua, or are the stdlib methods all nonblocking with big-O complexity as URIs in the docstrings?<p>Trio docs &gt; notes on async generators: 
<a href="https:&#x2F;&#x2F;trio.readthedocs.io&#x2F;en&#x2F;stable&#x2F;reference-core.html#notes-on-async-generators" rel="nofollow noreferrer">https:&#x2F;&#x2F;trio.readthedocs.io&#x2F;en&#x2F;stable&#x2F;reference-core.html#no...</a></div><br/></div></div></div></div></div></div><div id="37230439" class="c"><input type="checkbox" id="c-37230439" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#37227567">prev</a><span>|</span><a href="#37229204">next</a><span>|</span><label class="collapse" for="c-37230439">[-]</label><label class="expand" for="c-37230439">[5 more]</label></div><br/><div class="children"><div class="content">&gt;They will not make two calculations at the same time (can&#x27;t use several CPU cores like with multiprocessing)<p>Not true. Future executors can run in processors pool (with different cores) or using threads (same core, different event loops.)<p>&gt;You have to understand that async programming is hard, and no matter how good the tooling is, it&#x27;s going to make your code more difficult to manage. It has a high price.<p>Dude starts out with an article that lists the entire kitchen sink for concurrency; Neglecting to mention that literally none of these libraries are even considered by Python devs. Then concludes that writing async code is too hard (writing &#x27;await&#x27; before a call is too hard.)<p>To me this entire article reads like someone&#x27;s attempt to over-complicate things by trying to overwhelm you with information to seem impressive even though 99% of it is irrelevant to the discussion. Then makes a non-sequitur conclusion to make it seem like only &#x27;experts&#x27; ought to touch any of this because [for you] (le simple-minded pleb) you will inevitably break everything. Lmao, fuck that, that&#x27;s condescending as hell. Literally just using async def for functions that do IO and write await. There&#x27;s a few things to learn but any dev is capable of doing it.<p>&gt;I’ll add you probably should not go with asyncio manually. Use a higher level asyncio based lib, or better, framework. Async is hard enough as it is.<p>Horrible advice. Asyncio is high level already and comes standard in Python 3.6 &gt;=. You will get far more trouble using third-party concurrency libraries than trying to use the Python library which is actually very elegant and well-supported. Twisted sucks, by the way.</div><br/><div id="37230591" class="c"><input type="checkbox" id="c-37230591" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#37230439">parent</a><span>|</span><a href="#37229204">next</a><span>|</span><label class="collapse" for="c-37230591">[-]</label><label class="expand" for="c-37230591">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Literally just using async def for functions that do IO and write await.<p>If only it were that simple.<p>&gt; You will get far more trouble using third-party concurrency libraries than trying to use the Python library which is actually very elegant<p>Again, you overlook the fact that asyncio requires you to explicitly launch a concurrent context. Asyncio is fine, but it is not &quot;elegant&quot; because of this.</div><br/><div id="37230702" class="c"><input type="checkbox" id="c-37230702" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#37230439">root</a><span>|</span><a href="#37230591">parent</a><span>|</span><a href="#37229204">next</a><span>|</span><label class="collapse" for="c-37230702">[-]</label><label class="expand" for="c-37230702">[3 more]</label></div><br/><div class="children"><div class="content">&gt; asyncio requires you to explicitly launch a concurrent context<p>`asyncio.run()` [0] was added in 3.7, and as far as I know is the current recommended way to do this.<p>as shown in the asyncio &quot;hello world&quot; example [1], you can write your main() function to be async, and then the entire process runs asynchronously from the beginning.<p>and as shown on that page, you can also use `python -m asyncio` to get a REPL with a running event loop where using `await` will work as you&#x27;d expect it to.<p>one of my biggest quibbles with a lot of asyncio demo code snippets is the use of `loop.run_until_complete()` [2] and similar lower-level primitives. in most asyncio applications you simply want to start the loop as early as possible with `asyncio.run(main())`, let it run for the duration, and have the entire process exist in async-land.<p>0: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-runner.html#asyncio.run" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-runner.html#asynci...</a><p>1: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio.html</a><p>2: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40143289&#x2F;why-do-most-asyncio-examples-use-loop-run-until-complete" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40143289&#x2F;why-do-most-asy...</a></div><br/><div id="37230752" class="c"><input type="checkbox" id="c-37230752" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#37230439">root</a><span>|</span><a href="#37230702">parent</a><span>|</span><a href="#37229204">next</a><span>|</span><label class="collapse" for="c-37230752">[-]</label><label class="expand" for="c-37230752">[2 more]</label></div><br/><div class="children"><div class="content">Yes, these are some ways to get that context. But it can be difficult to do correctly for brownfield projects or libraries, especially if you need to support both sync and async. Not elegant!</div><br/><div id="37230821" class="c"><input type="checkbox" id="c-37230821" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#37230439">root</a><span>|</span><a href="#37230752">parent</a><span>|</span><a href="#37229204">next</a><span>|</span><label class="collapse" for="c-37230821">[-]</label><label class="expand" for="c-37230821">[1 more]</label></div><br/><div class="children"><div class="content">&gt; especially if you need to support both sync and async<p>I don&#x27;t think there&#x27;s any possible way to do that elegantly.<p>maybe gevent-style monkeypatching makes it <i>look</i> elegant, but there&#x27;s a whole pile of inelegant stuff happening under the covers to present that illusion.<p>and I would say that almost by definition, if you&#x27;re monkeypatching the stdlib, you are banished from the realm of elegance.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37229204" class="c"><input type="checkbox" id="c-37229204" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37230439">prev</a><span>|</span><a href="#37228929">next</a><span>|</span><label class="collapse" for="c-37229204">[-]</label><label class="expand" for="c-37229204">[1 more]</label></div><br/><div class="children"><div class="content">gevent is the way to go these days tbh. asyncio is close but the dependency on async-aware libraries can be problematic.<p>surprised the author ended on the note that none of these are relevant - i use a lot of these tools on a weekly basis.</div><br/></div></div><div id="37228929" class="c"><input type="checkbox" id="c-37228929" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#37229204">prev</a><span>|</span><a href="#37228238">next</a><span>|</span><label class="collapse" for="c-37228929">[-]</label><label class="expand" for="c-37228929">[1 more]</label></div><br/><div class="children"><div class="content">I picked gevent for a greenfield backend (in IoT&#x2F;ML space) back in 2019.  No regrets. The main contender was asyncio, which was the hot-new-thing at the time (still is, I guess). At the time, I did not feel that the ecosystem and programming practices for asyncio were good enough. That has of course matured a lot now, so it is no longer an issue. But I would actually still consider gevent again for a new project today. Possibly the asyncio web frameworks (ie FastAPI) have the edge over gevent-compatible (ie Flask) though, which might tip the scales.<p>I remember using Twisted some 10 years ago. Never again...</div><br/></div></div><div id="37228238" class="c"><input type="checkbox" id="c-37228238" checked=""/><div class="controls bullet"><span class="by">DishyDev</span><span>|</span><a href="#37228929">prev</a><span>|</span><a href="#37227351">next</a><span>|</span><label class="collapse" for="c-37228238">[-]</label><label class="expand" for="c-37228238">[1 more]</label></div><br/><div class="children"><div class="content">Great write up on something I depend on a lot but don&#x27;t understand well.<p>This also answers something I&#x27;ve always wondered about which is how Twisted and Tornado fit into the Python web framework landscape and whether I should use them. Tornado always seemed popular but slow and less intuitive than Flask&#x2F;Django. And then Twisted was a far lower level library but people were still building APIs on it.<p>Where does Eventlet fit into the picture? Is it a similar box of magic monkey patches like GEvent?</div><br/></div></div><div id="37227351" class="c"><input type="checkbox" id="c-37227351" checked=""/><div class="controls bullet"><span class="by">butz</span><span>|</span><a href="#37228238">prev</a><span>|</span><a href="#37231255">next</a><span>|</span><label class="collapse" for="c-37227351">[-]</label><label class="expand" for="c-37227351">[2 more]</label></div><br/><div class="children"><div class="content">Took me a while to figure out that real content of the website hides under whole page covering popup.</div><br/><div id="37227581" class="c"><input type="checkbox" id="c-37227581" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37227351">parent</a><span>|</span><a href="#37231255">next</a><span>|</span><label class="collapse" for="c-37227581">[-]</label><label class="expand" for="c-37227581">[1 more]</label></div><br/><div class="children"><div class="content">Damn, I explicitly disabled the subscribe wall in the settings. WTF?</div><br/></div></div></div></div><div id="37231255" class="c"><input type="checkbox" id="c-37231255" checked=""/><div class="controls bullet"><span class="by">tguvot</span><span>|</span><a href="#37227351">prev</a><span>|</span><a href="#37228364">next</a><span>|</span><label class="collapse" for="c-37231255">[-]</label><label class="expand" for="c-37231255">[1 more]</label></div><br/><div class="children"><div class="content">I personally really loved to use Twisted back in a day. it did take same time to figure out what exactly &quot;inline callbacks&quot; did, but after this it was easy.<p>I still miss Perspective Broker and Producers&#x2F;Consumers. Those things were rather powerful.</div><br/></div></div><div id="37228364" class="c"><input type="checkbox" id="c-37228364" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37231255">prev</a><span>|</span><a href="#37229932">next</a><span>|</span><label class="collapse" for="c-37228364">[-]</label><label class="expand" for="c-37228364">[1 more]</label></div><br/><div class="children"><div class="content">I love how I read the setup, then clicked on the comments and got the punchline delivered perfectly by Hacker News:<p>“We&#x27;re having some trouble serving your request. Sorry!”</div><br/></div></div><div id="37229932" class="c"><input type="checkbox" id="c-37229932" checked=""/><div class="controls bullet"><span class="by">kodablah</span><span>|</span><a href="#37228364">prev</a><span>|</span><a href="#37230036">next</a><span>|</span><label class="collapse" for="c-37229932">[-]</label><label class="expand" for="c-37229932">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only danger is if you call gevent.monkey.patch_all() too late.<p>Gevent takes over, often making advanced asyncio not work on gevent programs. Patching things globally should obviously be seen as dangerous in itself.</div><br/></div></div><div id="37230036" class="c"><input type="checkbox" id="c-37230036" checked=""/><div class="controls bullet"><span class="by">infotogivenm</span><span>|</span><a href="#37229932">prev</a><span>|</span><a href="#37230690">next</a><span>|</span><label class="collapse" for="c-37230036">[-]</label><label class="expand" for="c-37230036">[1 more]</label></div><br/><div class="children"><div class="content">Kids these days will never know the struggle of having to search for libraries that were not just in your language, but also could interop with your inane monkey-patching-based concurrency model of choice. Python used to be an absolutely horrendous language for anything involving concurrency, nearly as bad as ruby. Anyways, long live asyncio.</div><br/></div></div><div id="37230690" class="c"><input type="checkbox" id="c-37230690" checked=""/><div class="controls bullet"><span class="by">staticautomatic</span><span>|</span><a href="#37230036">prev</a><span>|</span><a href="#37231224">next</a><span>|</span><label class="collapse" for="c-37230690">[-]</label><label class="expand" for="c-37230690">[1 more]</label></div><br/><div class="children"><div class="content">I still have nightmares about Twisted’s documentation.</div><br/></div></div><div id="37231224" class="c"><input type="checkbox" id="c-37231224" checked=""/><div class="controls bullet"><span class="by">totorovirus</span><span>|</span><a href="#37230690">prev</a><span>|</span><a href="#37227993">next</a><span>|</span><label class="collapse" for="c-37231224">[-]</label><label class="expand" for="c-37231224">[1 more]</label></div><br/><div class="children"><div class="content">How is FastAPI in large projects?</div><br/></div></div><div id="37227993" class="c"><input type="checkbox" id="c-37227993" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#37231224">prev</a><span>|</span><a href="#37229505">next</a><span>|</span><label class="collapse" for="c-37227993">[-]</label><label class="expand" for="c-37227993">[2 more]</label></div><br/><div class="children"><div class="content">ever look at a twisted stack trace?</div><br/><div id="37228150" class="c"><input type="checkbox" id="c-37228150" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37227993">parent</a><span>|</span><a href="#37229505">next</a><span>|</span><label class="collapse" for="c-37228150">[-]</label><label class="expand" for="c-37228150">[1 more]</label></div><br/><div class="children"><div class="content">And worse, when you do, something loop back.</div><br/></div></div></div></div></div></div></div></div></div></body></html>