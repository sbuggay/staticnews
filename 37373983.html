<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693818074588" as="style"/><link rel="stylesheet" href="styles.css?v=1693818074588"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://betterprogramming.pub/a-taste-of-coq-and-correct-code-by-construction-111bf74d3b98">How to write correct code by construction using the Coq Proof Assistant</a> <span class="domain">(<a href="https://betterprogramming.pub">betterprogramming.pub</a>)</span></div><div class="subtext"><span>ingve</span> | <span>51 comments</span></div><br/><div><div id="37374200" class="c"><input type="checkbox" id="c-37374200" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#37375205">next</a><span>|</span><label class="collapse" for="c-37374200">[-]</label><label class="expand" for="c-37374200">[2 more]</label></div><br/><div class="children"><div class="content">Interesting article, they list applied use of the theory on mainstream tools, things I never see on my readings. <a href="https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;popl18&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;popl18&#x2F;</a> for instance. Very cool</div><br/><div id="37376016" class="c"><input type="checkbox" id="c-37376016" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#37374200">parent</a><span>|</span><a href="#37375205">next</a><span>|</span><label class="collapse" for="c-37376016">[-]</label><label class="expand" for="c-37376016">[1 more]</label></div><br/><div class="children"><div class="content">Also take a look at Dafny, Why3&#x2F;WhyML, and Ada&#x2F;SPARK. Very pragmatic tools that are getting some industry adoption.<p>Coq and Isabelle also see some use, but they are more costly to use in my experience.</div><br/></div></div></div></div><div id="37375205" class="c"><input type="checkbox" id="c-37375205" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#37374200">prev</a><span>|</span><a href="#37374590">next</a><span>|</span><label class="collapse" for="c-37375205">[-]</label><label class="expand" for="c-37375205">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re already familiar with a functional programming language like Haskell or OCaml, you have the background to work through my Coq tutorial here: <a href="https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;proofs&#x2F;tree&#x2F;main&#x2F;proofs&#x2F;Tutorial">https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;proofs&#x2F;tree&#x2F;main&#x2F;proofs&#x2F;Tutor...</a><p>My goal with this tutorial was to introduce the core aspects of the language (dependent types, tactics, etc.) from first principles. If you&#x27;re fascinated by proof assistants like Coq or Lean and want to understand how to use them, this tutorial is written for you.<p>Any feedback is appreciated!</div><br/><div id="37377740" class="c"><input type="checkbox" id="c-37377740" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#37375205">parent</a><span>|</span><a href="#37374590">next</a><span>|</span><label class="collapse" for="c-37377740">[-]</label><label class="expand" for="c-37377740">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done <i>Logical Foundations</i> and part of <i>Programming Language Foundations</i>, and some of the stuff in your tutorial is new to me (especially dependent types).<p>Your tutorial is very interesting, but in comparison to the <i>Software Foundations</i> series you have relatively few exercises and they&#x27;re all at the end of the chapter. I found it helpful to do exercises as I went along, in many cases testing or exercising my knowledge of a new concept or Coq feature right away. So I would suggest writing more exercises and sprinkling them closer to where some of the material is introduced.<p>Also, some of your exercises in some chapters have a pretty steep ramp-up in difficulty, so again it might be nice to have exercises that gradually build in difficulty.<p>These are probably important considerations when readers are going to be working through this material entirely on their own and it might be their first exposure to Coq. (I think your tutorial says it was previously presented in-person, which has got to be a lot easier, since people can ask questions!)<p>Thanks for writing and sharing this material!</div><br/><div id="37378083" class="c"><input type="checkbox" id="c-37378083" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#37375205">root</a><span>|</span><a href="#37377740">parent</a><span>|</span><a href="#37374590">next</a><span>|</span><label class="collapse" for="c-37378083">[-]</label><label class="expand" for="c-37378083">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your feedback!</div><br/></div></div></div></div></div></div><div id="37374590" class="c"><input type="checkbox" id="c-37374590" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#37375205">prev</a><span>|</span><a href="#37374314">next</a><span>|</span><label class="collapse" for="c-37374590">[-]</label><label class="expand" for="c-37374590">[1 more]</label></div><br/><div class="children"><div class="content">Software Foundations in Coq by Michael Ryan Clarkson [0] is great introduction to this topic.<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLre5AT9JnKShFK9l9HYzkZugkJSsXioFs">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLre5AT9JnKShFK9l9HYzk...</a></div><br/></div></div><div id="37374314" class="c"><input type="checkbox" id="c-37374314" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#37374590">prev</a><span>|</span><a href="#37376722">next</a><span>|</span><label class="collapse" for="c-37374314">[-]</label><label class="expand" for="c-37374314">[8 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t tell if this is pseudocode or what proof in coq usually looks like:<p>Theorem NestedTreeContains1:<p><pre><code>  forall (t: tree),
    t = Node example 2 (Node Nil 3 Nil) 

  -&gt; 

    contains 1 t = true.
</code></pre>
Proof.<p>nail.<p>wreck t.<p>- wat.<p>- wreck H into Ht1, Hv and Ht2.<p><pre><code>  sub Hv.
  evaluate.
  sub Ht1.
  just ExampleTreeContains1.
</code></pre>
Qed.<p>Theorem, forall, qed look fairly likely. Are there built-in operations in coq called &#x27;wat&#x27; and &#x27;wreck&#x27;?</div><br/><div id="37374408" class="c"><input type="checkbox" id="c-37374408" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#37374314">parent</a><span>|</span><a href="#37374374">next</a><span>|</span><label class="collapse" for="c-37374408">[-]</label><label class="expand" for="c-37374408">[4 more]</label></div><br/><div class="children"><div class="content">A cursory search reveals they&#x27;re not builtin, but were written for the talk: <a href="https:&#x2F;&#x2F;github.com&#x2F;awalterschulze&#x2F;ccc-talk&#x2F;blob&#x2F;main&#x2F;Coq&#x2F;src&#x2F;BST&#x2F;ConstructionToolbox.v">https:&#x2F;&#x2F;github.com&#x2F;awalterschulze&#x2F;ccc-talk&#x2F;blob&#x2F;main&#x2F;Coq&#x2F;src...</a><p><pre><code>    nail ~= intros
    wat ~= discriminate
    etc.</code></pre></div><br/><div id="37374633" class="c"><input type="checkbox" id="c-37374633" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#37374314">root</a><span>|</span><a href="#37374408">parent</a><span>|</span><a href="#37374758">next</a><span>|</span><label class="collapse" for="c-37374633">[-]</label><label class="expand" for="c-37374633">[2 more]</label></div><br/><div class="children"><div class="content">&quot;wreck&quot; is actually &quot;destruct&quot;, &quot;same&quot; is &quot;reflexivity&quot;...<p>It boggles the mind why the author would make up fanciful new names for the fundamental tactics in this &quot;how to&quot; article.</div><br/><div id="37377421" class="c"><input type="checkbox" id="c-37377421" checked=""/><div class="controls bullet"><span class="by">21eleven</span><span>|</span><a href="#37374314">root</a><span>|</span><a href="#37374633">parent</a><span>|</span><a href="#37374758">next</a><span>|</span><label class="collapse" for="c-37377421">[-]</label><label class="expand" for="c-37377421">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s giving a talk, it&#x27;s for the lulz<p>If you are giving a talk on a theorem proving programing language you&#x27;re gonna want to make it fun</div><br/></div></div></div></div><div id="37374758" class="c"><input type="checkbox" id="c-37374758" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#37374314">root</a><span>|</span><a href="#37374408">parent</a><span>|</span><a href="#37374633">prev</a><span>|</span><a href="#37374374">next</a><span>|</span><label class="collapse" for="c-37374758">[-]</label><label class="expand" for="c-37374758">[1 more]</label></div><br/><div class="children"><div class="content">The only useful ltac I see in there is compare, which can save a lot of tedious rewrites, when needing that frequently.</div><br/></div></div></div></div><div id="37374374" class="c"><input type="checkbox" id="c-37374374" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#37374314">parent</a><span>|</span><a href="#37374408">prev</a><span>|</span><a href="#37376079">next</a><span>|</span><label class="collapse" for="c-37374374">[-]</label><label class="expand" for="c-37374374">[1 more]</label></div><br/><div class="children"><div class="content">I used Coq in one class in school, and I never encountered wat or wreck. It’s possible they’re user- or library-defined tactics.<p>One thing I think is important about Coq is that it really is meant to be interactive. Even after a fair amount of usage I still find it somewhat tricky to just read a proof, especially a nontrivial one. A good IDE will show you a panel that includes all your hypothesis and requirements so far, updating as you run each line</div><br/></div></div><div id="37376079" class="c"><input type="checkbox" id="c-37376079" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#37374314">parent</a><span>|</span><a href="#37374374">prev</a><span>|</span><a href="#37374361">next</a><span>|</span><label class="collapse" for="c-37376079">[-]</label><label class="expand" for="c-37376079">[1 more]</label></div><br/><div class="children"><div class="content">As other people note, a lot of those seem to be local aliases defined by the author.<p>But the most important thing to understand about Coq is that it&#x27;s meant to be read in an IDE. The IDE will show you, at each step, what has been proved and what remains to be proved. The &quot;tactics&quot; you see above basically mean, &quot;At this point in the proof, we can make progress by substituting Hv. And in context, this will make sense.<p>But without being able to see the proof state at each step, Coq can be incredibly cryptic.</div><br/></div></div><div id="37374361" class="c"><input type="checkbox" id="c-37374361" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#37374314">parent</a><span>|</span><a href="#37376079">prev</a><span>|</span><a href="#37376722">next</a><span>|</span><label class="collapse" for="c-37374361">[-]</label><label class="expand" for="c-37374361">[1 more]</label></div><br/><div class="children"><div class="content">They are not built-in, no. <a href="https:&#x2F;&#x2F;github.com&#x2F;awalterschulze&#x2F;ccc-talk&#x2F;blob&#x2F;1e781326d2e3c372b6d49bc2f6ff5737dc6757d8&#x2F;Coq&#x2F;src&#x2F;BST&#x2F;ConstructionToolbox.v#L24">https:&#x2F;&#x2F;github.com&#x2F;awalterschulze&#x2F;ccc-talk&#x2F;blob&#x2F;1e781326d2e3...</a></div><br/></div></div></div></div><div id="37374905" class="c"><input type="checkbox" id="c-37374905" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37376722">prev</a><span>|</span><a href="#37374429">next</a><span>|</span><label class="collapse" for="c-37374905">[-]</label><label class="expand" for="c-37374905">[6 more]</label></div><br/><div class="children"><div class="content">I find the introduction interesting, it somehow clicked. Devs are like  toddlers playing with wooden bricks, who are demanded to scale up this act of building to the level of a grown up&#x27;s house.<p>In fact it often feels that way. You&#x27;re either asked to extend or improve existing constructions that feel like sticks and stones bound together with rubber bands. Or one feels excited for being allowed to make up such a construction as a demo, not knowing it will be used as a basis for a production-quality construction.<p>I&#x27;m not sure if mathematical proof is the way to go. There&#x27;s just too much code to cover for this approach to be realistic.<p>Most problems are born on the drawing table. The designs seem right on paper and only in practice, during or after building, they become visable.</div><br/><div id="37375234" class="c"><input type="checkbox" id="c-37375234" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#37374905">parent</a><span>|</span><a href="#37375105">next</a><span>|</span><label class="collapse" for="c-37375234">[-]</label><label class="expand" for="c-37375234">[3 more]</label></div><br/><div class="children"><div class="content">Yep, we build a foundation with plywood and styrofoam and then someone comes and asks you to build a skyscraper on top of it.</div><br/><div id="37377011" class="c"><input type="checkbox" id="c-37377011" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#37374905">root</a><span>|</span><a href="#37375234">parent</a><span>|</span><a href="#37375707">next</a><span>|</span><label class="collapse" for="c-37377011">[-]</label><label class="expand" for="c-37377011">[1 more]</label></div><br/><div class="children"><div class="content">While I do think proof constructed code could be superior, I am not convinced for two reasons:<p>1. The problem expressed here has to do with a particular, well understood problem. It is not subject to the whims or constraint needs of the &quot;customer&quot;. Proof construction is great when the problem is properly understood, I don&#x27;t know how well it handles constantly changing requirements. (This encompasses business and interaction constraints too - perhaps you can construct a provable correct UI, but will it be engaging or usable?)<p>2. Test driven development can guide high quality code construction, arguably at lower construction cost. That is the reason I&#x27;d argue this has not taken off in comparison to traditional &quot;test&quot; based design.<p>You can argue it produces lower quality code, and you&#x27;d probably be right. But in comparison to construction of complex, rich design, I suspect that it produces faster results at lower cost. The provable solution will win out...eventually. Depends on whether it can make significant marker penetration once it is complete.<p>Nevertheless, yes of course we should be building foundations witb concrete not plywood and Styrofoam, so this is a good development. I do think a proper engineering approach with test based verification can build a &quot;somewhat concrete&quot; foundation, at least.</div><br/></div></div><div id="37375707" class="c"><input type="checkbox" id="c-37375707" checked=""/><div class="controls bullet"><span class="by">trwaw</span><span>|</span><a href="#37374905">root</a><span>|</span><a href="#37375234">parent</a><span>|</span><a href="#37377011">prev</a><span>|</span><a href="#37375105">next</a><span>|</span><label class="collapse" for="c-37375707">[-]</label><label class="expand" for="c-37375707">[1 more]</label></div><br/><div class="children"><div class="content">We build a train and then someone asks to turn it into a skyscraper because skyscrapers are the in thing now.  It already looks like one on its side, how hard can it be to turn it right side up?</div><br/></div></div></div></div><div id="37375105" class="c"><input type="checkbox" id="c-37375105" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#37374905">parent</a><span>|</span><a href="#37375234">prev</a><span>|</span><a href="#37375862">next</a><span>|</span><label class="collapse" for="c-37375105">[-]</label><label class="expand" for="c-37375105">[1 more]</label></div><br/><div class="children"><div class="content">Turning a foam architectural model into a house without the required cost investment because the foam model was “so quick to make” feels like a frustratingly accurate description.</div><br/></div></div></div></div><div id="37374429" class="c"><input type="checkbox" id="c-37374429" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#37374905">prev</a><span>|</span><a href="#37375157">next</a><span>|</span><label class="collapse" for="c-37374429">[-]</label><label class="expand" for="c-37374429">[3 more]</label></div><br/><div class="children"><div class="content">The article shows how interesting properties can be proved (with a nontrivial amount of effort). That&#x27;s cool, but I wouldn&#x27;t call it correct by construction.</div><br/><div id="37374885" class="c"><input type="checkbox" id="c-37374885" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#37374429">parent</a><span>|</span><a href="#37374901">next</a><span>|</span><label class="collapse" for="c-37374885">[-]</label><label class="expand" for="c-37374885">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a standard phrase in the formal methods field, [0] emphasising that it&#x27;s an alternative to the usual approach where we hope that our testing (which can never be complete) is enough to catch all the worrisome bugs.<p>Personally, this article didn&#x27;t strike me as being very easy to follow, or as being the most compelling demonstration of the value of formal methods. At the risk of going off-topic: if you&#x27;re not seeing the point, I recommend this example using SPARK, a non-functional language. [1]<p>[0] <a href="https:&#x2F;&#x2F;betterprogramming.pub&#x2F;a-taste-of-coq-and-correct-code-by-construction-111bf74d3b98" rel="nofollow noreferrer">https:&#x2F;&#x2F;betterprogramming.pub&#x2F;a-taste-of-coq-and-correct-cod...</a><p>[1] <a href="https:&#x2F;&#x2F;docs.adacore.com&#x2F;spark2014-docs&#x2F;html&#x2F;ug&#x2F;en&#x2F;tutorial.html#proving-spark-programs" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.adacore.com&#x2F;spark2014-docs&#x2F;html&#x2F;ug&#x2F;en&#x2F;tutorial....</a></div><br/></div></div><div id="37374901" class="c"><input type="checkbox" id="c-37374901" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#37374429">parent</a><span>|</span><a href="#37374885">prev</a><span>|</span><a href="#37375157">next</a><span>|</span><label class="collapse" for="c-37374901">[-]</label><label class="expand" for="c-37374901">[1 more]</label></div><br/><div class="children"><div class="content">Right, not all of the techniques shown yield code that’s correct by construction. For example, an argument was indirectly given, and that error was only found after writing a theorem involving it and finding it was impossible to prove.<p>In the section “Correct BST by Construction”, they explain the technique of requiring every constructor of a BST to supply a proof that it maintains the properties of a BST. Any modification to a BST constructs a new BST (since Coq is pure), so any operations on a BST must also supply a proof of their correctness. <i>That</i> is correct by construction.</div><br/></div></div></div></div><div id="37375157" class="c"><input type="checkbox" id="c-37375157" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#37374429">prev</a><span>|</span><a href="#37375730">next</a><span>|</span><label class="collapse" for="c-37375157">[-]</label><label class="expand" for="c-37375157">[9 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some software where it&#x27;s important not to have bugs and know exactly what it does, and some where any attempt to specify what it&#x27;s supposed to be doing, let alone fixing all the bugs, is a waste of time. (And things in between...)<p>Currently, a lot of instances of the first situation get the treatment befitting the second. This is because it&#x27;s still too hard to use these tools at scale. However, the trend is certainly towards improving tooling and the cost of doing this will go down a lot.<p>Maybe in a hundred years programming will be replaced by either &quot;formally specify what you want&quot;, if you know what you want, (AI fills in implementation of <i>how</i> it does what you want, as well as a proof that it does) or, if you only very roughly know what you want, explain it to the chatbot and answer it&#x27;s questions.</div><br/><div id="37375816" class="c"><input type="checkbox" id="c-37375816" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#37375157">parent</a><span>|</span><a href="#37375578">next</a><span>|</span><label class="collapse" for="c-37375816">[-]</label><label class="expand" for="c-37375816">[1 more]</label></div><br/><div class="children"><div class="content">In the general case, the &quot;write the spec and the AI does the rest&quot; boils down to automated theorem proving, and I&#x27;m optimistic AIs will get pretty good at this in a lot of useful situations.<p>Even today, in  limited well-defined problem spaces, there are sometimes good algorithms for this sort of thing. See Dana Angluin&#x27;s algorithm for learning the DFA that recognizes a regular language given through an interactive process of having the user provide examples&#x2F;counterexamples, which serve to provide an increasingly constrained spec.</div><br/></div></div><div id="37375578" class="c"><input type="checkbox" id="c-37375578" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#37375157">parent</a><span>|</span><a href="#37375816">prev</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37375578">[-]</label><label class="expand" for="c-37375578">[6 more]</label></div><br/><div class="children"><div class="content">AI probably disrupts programming in the next couple of decades, where they produce not only software but static and dynamic validation artifacts of correctness. It’s sad though, I would have really liked to see how human programming could improve with better tooling, it seems like a lot of formal specification work (and program synthesis using such) could be improvised with just better user interfaces.</div><br/><div id="37376181" class="c"><input type="checkbox" id="c-37376181" checked=""/><div class="controls bullet"><span class="by">rgmerk</span><span>|</span><a href="#37375157">root</a><span>|</span><a href="#37375578">parent</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37376181">[-]</label><label class="expand" for="c-37376181">[5 more]</label></div><br/><div class="children"><div class="content">So the AI spat out code and a formal spec and a theorem prover spat out a proof that the code is consistent with the formal spec?<p>Great.<p>Does the formal spec represent a complete and accurate description of what the code is supposed to do?<p><i>shrugs</i></div><br/><div id="37376264" class="c"><input type="checkbox" id="c-37376264" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#37375157">root</a><span>|</span><a href="#37376181">parent</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37376264">[-]</label><label class="expand" for="c-37376264">[4 more]</label></div><br/><div class="children"><div class="content">If an LML can write an essay that humans can read, surely it’s conceivable that it could spit out proofs&#x2F;tests&#x2F;docs etc…in a human readable form. So really, you can just decide for yourself then.</div><br/><div id="37376693" class="c"><input type="checkbox" id="c-37376693" checked=""/><div class="controls bullet"><span class="by">rgmerk</span><span>|</span><a href="#37375157">root</a><span>|</span><a href="#37376264">parent</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37376693">[-]</label><label class="expand" for="c-37376693">[3 more]</label></div><br/><div class="children"><div class="content"><i>So really, you can just decide for yourself then</i><p>Even if you can understand what the proof proves (not a given) do you personally understand the actual requirements for the software perfectly?</div><br/><div id="37376887" class="c"><input type="checkbox" id="c-37376887" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#37375157">root</a><span>|</span><a href="#37376693">parent</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37376887">[-]</label><label class="expand" for="c-37376887">[2 more]</label></div><br/><div class="children"><div class="content">Building software is a conversation right? Your specification starts out vague, the AI makes a bunch of assumptions, and then you just say “oh, I really didn’t want that”, wash rinse and repeat.</div><br/><div id="37377040" class="c"><input type="checkbox" id="c-37377040" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#37375157">root</a><span>|</span><a href="#37376887">parent</a><span>|</span><a href="#37375558">next</a><span>|</span><label class="collapse" for="c-37377040">[-]</label><label class="expand" for="c-37377040">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced this is adequate, your specifications will be come rather unweildy.<p>If you employed this approach, I would want to pair it at a minimum with a test suite.<p>Even then, how do you know that your system (covered by hill climbing suites of tests that pass), has correct behavior for all things you didn&#x27;t specify?<p>You don&#x27;t. Better to build from the ground up formally than fight with &quot;AI&quot; that probably got it worse than wrong first try.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37375730" class="c"><input type="checkbox" id="c-37375730" checked=""/><div class="controls bullet"><span class="by">fortran77</span><span>|</span><a href="#37375157">prev</a><span>|</span><a href="#37374127">next</a><span>|</span><label class="collapse" for="c-37375730">[-]</label><label class="expand" for="c-37375730">[3 more]</label></div><br/><div class="children"><div class="content">Why was the title changed? Isn&#x27;t HN policy to use the original title unless it&#x27;s very misleading?</div><br/><div id="37375805" class="c"><input type="checkbox" id="c-37375805" checked=""/><div class="controls bullet"><span class="by">grzm</span><span>|</span><a href="#37375730">parent</a><span>|</span><a href="#37375865">next</a><span>|</span><label class="collapse" for="c-37375805">[-]</label><label class="expand" for="c-37375805">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;dang changed it to the subtitle because it was trollish: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37374404">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37374404</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>