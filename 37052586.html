<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691571664234" as="style"/><link rel="stylesheet" href="styles.css?v=1691571664234"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://downfall.page/">Downfall Attacks</a> <span class="domain">(<a href="https://downfall.page">downfall.page</a>)</span></div><div class="subtext"><span>WalterSobchak</span> | <span>243 comments</span></div><br/><div><div id="37055529" class="c"><input type="checkbox" id="c-37055529" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37053352">next</a><span>|</span><label class="collapse" for="c-37055529">[-]</label><label class="expand" for="c-37055529">[55 more]</label></div><br/><div class="children"><div class="content">What I find odd is that after the initial Spectre attacks, there have been a long string of these attacks discovered by outside researchers and then patched by the chipmakers.<p>In principle it seems like the chipmakers should hold all the cards when it comes to discovery: they are experts in speculative execution, know exactly how their chips work and have massive existing validation suites, simulators and internal machine-readable specifications for the low-level operations of these chips.<p>Outside researches need to reverse all this by probing a black box (plus a few much-worse-than-insider sources like patents).<p>Yet years after the initial disclosures it&#x27;s still random individuals or groups who are discovering these? Perhaps pre-Spectre this attack vector wasn&#x27;t even considered, but once the general mechanism was obvious did the chip-makers not simply set their biggest brains down and say &quot;go through this with a fine-toothed comb looking for other Spectre attacks&quot;?<p>Maybe they <i>did</i> and are well aware of all these attacks but to save face and performance hits they simply hold on to them hoping nobody makes them public?</div><br/><div id="37059859" class="c"><input type="checkbox" id="c-37059859" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055603">next</a><span>|</span><label class="collapse" for="c-37059859">[-]</label><label class="expand" for="c-37059859">[1 more]</label></div><br/><div class="children"><div class="content">One possibility nobody mentioned yet: the chip vendors don&#x27;t invest a ton of time looking for them because they don&#x27;t actually matter that much.<p>Bear in mind, security researchers are incentivized to find things to build their reputation. It&#x27;s very often the case that they claim something is a world-shaking security vulnerability when in reality it doesn&#x27;t matter much for real world attackers. Has anyone ever found a speculation attack in the wild? I think the answer might be no. In which case, why would chip vendors invest tons of money into this? Real customers aren&#x27;t being hurt by it except in the sense that when an external researcher forces action, they&#x27;re made to release new microcode that slows things down. Note how all their mitigations for these attacks always have off switches: not something you usually see in security fixes. It&#x27;s because in many, many cases, these attacks just don&#x27;t matter. All software running on the same physical core or even the same physical CPU is either running at the same trust level, or sandboxed so heavily it can&#x27;t mount the attack.</div><br/></div></div><div id="37055603" class="c"><input type="checkbox" id="c-37055603" checked=""/><div class="controls bullet"><span class="by">infinityio</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37059859">prev</a><span>|</span><a href="#37055727">next</a><span>|</span><label class="collapse" for="c-37055603">[-]</label><label class="expand" for="c-37055603">[11 more]</label></div><br/><div class="children"><div class="content">This could be a case of survivorship bias - we don&#x27;t know how many spectre-like bugs <i>did</i> get patched, because they never made it to the public</div><br/><div id="37056031" class="c"><input type="checkbox" id="c-37056031" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055603">parent</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37056031">[-]</label><label class="expand" for="c-37056031">[7 more]</label></div><br/><div class="children"><div class="content">I considered this, but we have pretty good evidence that the chipmakers have not been busily secretly patching Spectre attacks:<p>1) Microcode updates are visible and Spectre fixes are hard to hide: most have performance impacts and most require coordination from the kernel to enable or make effective (which are visible for Linux). There have been a large number of microcode changes tied to published attacks and corresponding fixes, but no corresponding &quot;mystery&quot; updates and hidden kernel fixes to my knowledge which have a similar shape to Spectre fixes.<p>It&#x27;s <i>possible</i> they could wait to try to bundle these fixes into a microcode update that arrives for another reason, but the performance impacts and kernel-side changes are harder to hide.<p>2) If this were the case, we&#x27;d expect independent researches to be at least in part re-discovering these attacks, rather than finding completely new ones. This would lead to a case where an attack was already resolved in a release microcode version. To my knowledge this hasn&#x27;t really happened.</div><br/><div id="37056302" class="c"><input type="checkbox" id="c-37056302" checked=""/><div class="controls bullet"><span class="by">mabbo</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056031">parent</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37056302">[-]</label><label class="expand" for="c-37056302">[6 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to patch the errors found during the initial R&amp;D. The patch was made before the hardware was ever sold.<p>What&#x27;s left are the attack vectors that Intel&#x27;s greatest minds didn&#x27;t discover.</div><br/><div id="37056927" class="c"><input type="checkbox" id="c-37056927" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056302">parent</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37056927">[-]</label><label class="expand" for="c-37056927">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, but it leads the odd assumption that the vendor managed to fix N side-channel attacks before release but 0 thereafter, while random individuals fixed M thereafter over a period of years with N &gt;&gt; M.<p>This seems to be much less likely than the conclusion that vendors are not in fact fixing many prior to the release and then stopping &quot;cold turkey&quot; after that. Especially since these attacks seem to cross chip versions, in many cases 6+ generations of chips: if vendors had substantial and increasing efforts on new chip versions they&#x27;d also be catching issues that applied to old released chips as well. We don&#x27;t see that happening.</div><br/><div id="37057780" class="c"><input type="checkbox" id="c-37057780" checked=""/><div class="controls bullet"><span class="by">rzwitserloot</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056927">parent</a><span>|</span><a href="#37057270">next</a><span>|</span><label class="collapse" for="c-37057780">[-]</label><label class="expand" for="c-37057780">[1 more]</label></div><br/><div class="children"><div class="content">This. Downfall affects CPUs released almost a decade ago. The argument of &#x27;Intel caught a ton of these and downfall is the one that got away&#x27; doesn&#x27;t add up. Surely Intel would find at least one issue during development of a new chip that has the property that it _also_ affects older chips. They can hardware-fix it before ever releasing their new chip, but unless they just decided to ignore the vulnerability in their older chips, they&#x27;d have starte work on a patch or at least on contacting OS vendors.<p>None of which is easy to do without the public at large figuring out what happend.<p>Conclusion: That is highly unlikely to have ever happened. Therefore, this isn&#x27;t survivor bias and it really is bizarre that chip vendors (or, at least, Intel) doesn&#x27;t look for this stuff or at least didn&#x27;t find this.</div><br/></div></div><div id="37057270" class="c"><input type="checkbox" id="c-37057270" checked=""/><div class="controls bullet"><span class="by">Panzer04</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056927">parent</a><span>|</span><a href="#37057780">prev</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37057270">[-]</label><label class="expand" for="c-37057270">[3 more]</label></div><br/><div class="children"><div class="content">If a bug is not known, most of the incentives to the vendor are to not bother investigating, I suspect.<p>You could spend arbitrary amounts of time looking for these bugs and find nothing. Simpler and easier to offer a bounty or something and fix it then. If no one publicly finds the bug it doesn&#x27;t matter to the mfg (and it wouldn&#x27;t surprise me if there&#x27;s truth to your supposition that they know about the bug but wait to fix until someone reports it - no public backlash so long as the bug is unknown)<p>Fixing bugs prior to release seems easy and free, though, especially since many more eyes would also be on the &quot;new&quot; in progress architecture, and proper hardware mitigations that don&#x27;t cost a lot of performance can be made.</div><br/><div id="37058695" class="c"><input type="checkbox" id="c-37058695" checked=""/><div class="controls bullet"><span class="by">skolsuper</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057270">parent</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37058695">[-]</label><label class="expand" for="c-37058695">[2 more]</label></div><br/><div class="children"><div class="content">What about the incentive to release &quot;the most secure chips on the market&quot;, are you discounting that a bit too much?<p>Granted that human nature tends to mean these factors don&#x27;t have a high enough weight, e.g. it&#x27;s not the safest airplanes that sell the most, it&#x27;s the cheapest ones that meet the regulations, and the regulations drive safety improvements, for the most part</div><br/><div id="37058873" class="c"><input type="checkbox" id="c-37058873" checked=""/><div class="controls bullet"><span class="by">Panzer04</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37058695">parent</a><span>|</span><a href="#37055935">next</a><span>|</span><label class="collapse" for="c-37058873">[-]</label><label class="expand" for="c-37058873">[1 more]</label></div><br/><div class="children"><div class="content">I guess there&#x27;s probably some margin in it - if both parties seem about equally vulnerable, there&#x27;s not much lost. You could expend a lot of effort into security, but the nature of these bugs is still that they are fairly rare, often require pretty significant hurdles, etc. The mfg. could probably spend a lot more money and find a few extra bugs, but who knows if they would have turned into &quot;real&quot; exploits?<p>Remember that this particular bug isn&#x27;t actually present on the newest chips either - and 12th&#x2F;13th gen were shipping before Intel was informed of this bug - so it was fixed eventually, probably incidentally as a result of design changes.<p>The unknown factor is how much additional money you&#x27;d have to invest to gain additional security, given how esoteric many of these bugs are.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37055935" class="c"><input type="checkbox" id="c-37055935" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055603">parent</a><span>|</span><a href="#37056031">prev</a><span>|</span><a href="#37056267">next</a><span>|</span><label class="collapse" for="c-37055935">[-]</label><label class="expand" for="c-37055935">[2 more]</label></div><br/><div class="children"><div class="content">Or the problem could be with methodology, and the wrong people are in charge of the right people left, and so the mindset for testing is just wrong.<p>Also you’re dealing with a company that has been running to stand still for a long time. There’s been a lot of pressure to meet numbers that they simply cannot keep up with. At some point people cheat, unconsciously or consciously, to achieve the impossible.</div><br/><div id="37056045" class="c"><input type="checkbox" id="c-37056045" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055935">parent</a><span>|</span><a href="#37056267">next</a><span>|</span><label class="collapse" for="c-37056045">[-]</label><label class="expand" for="c-37056045">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also you’re dealing with a company that has been running to stand still for a long time<p>I&#x27;m not just talking about Intel, but also Arm and AMD. As far as I know none of these has obviously been making proactive Spectre fixes.</div><br/></div></div></div></div><div id="37056267" class="c"><input type="checkbox" id="c-37056267" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055603">parent</a><span>|</span><a href="#37055935">prev</a><span>|</span><a href="#37055727">next</a><span>|</span><label class="collapse" for="c-37056267">[-]</label><label class="expand" for="c-37056267">[1 more]</label></div><br/><div class="children"><div class="content">We also don&#x27;t know how many are still out there unreported and part of the secret zero-day caches of various intelligence agencies.</div><br/></div></div></div></div><div id="37055727" class="c"><input type="checkbox" id="c-37055727" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055603">prev</a><span>|</span><a href="#37058799">next</a><span>|</span><label class="collapse" for="c-37055727">[-]</label><label class="expand" for="c-37055727">[6 more]</label></div><br/><div class="children"><div class="content">The logic in this comment rubs me the wrong way. You could use the same train of thought to postulate programmers that have made 2 memory safety errors are nefarious instead of simply human.<p>When billions use something I expect them to find more problems, flaws, and exploits in it than the creator&#x2F;manufacturer did. The presence of this does nothing to indicate (or refute) any further conclusion about why.</div><br/><div id="37056094" class="c"><input type="checkbox" id="c-37056094" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055727">parent</a><span>|</span><a href="#37058799">next</a><span>|</span><label class="collapse" for="c-37056094">[-]</label><label class="expand" for="c-37056094">[5 more]</label></div><br/><div class="children"><div class="content">I think the comparison between CPU and software exploits holds at a very high level, but in the case of software the gap between internal and external researches seems lower. Much software is open-source, in which case the play field is almost level and even closed source software is available in assembly which exposes the entire attack surface in a reasonably consumable form.<p>Software reverse-engineering is a hugely popular, fairly accessible field with good tools. Hardware not so much.<p>&gt; When billions use something I expect them to find more problems, flaws, and exploits in it than the creator&#x2F;manufacturer did. The presence of this does nothing to indicate (or refute) any further conclusion about why.<p>To be very clear none of these errors have been found by billions of random users but by a few interested third parties: many of them working as students with microscopic funding levels and no apparent inside information.<p>I&#x27;m not actually suggesting that the nefarious explanation holds: I&#x27;m genuinely curious.</div><br/><div id="37056638" class="c"><input type="checkbox" id="c-37056638" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056094">parent</a><span>|</span><a href="#37058799">next</a><span>|</span><label class="collapse" for="c-37056638">[-]</label><label class="expand" for="c-37056638">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I agree significant gaps in the playing fields are really there. By significant I mean something that explains it should be e.g. 10x harder or something to the point it&#x27;s supposed to be suspicious how the ratio is indicative of something off. Sure, you don&#x27;t get to see how they laid out the transistors of the CPU but that&#x27;s not how these attacks work it&#x27;s by some oversight in memory handling not that different from software. They analyze how individual assembly instructions behave in certain scenarios vs how they are designed to behave. Compare this to the process of attacking closed source software like Windows, sift through a bunch of assembly in a debugger and see what gets left behind or compared incorrectly, and it&#x27;s not glaringly different just because hardware is involved. Difficult, sure, but far from anything to suggest it should be uncommon. More importantly, by definition you don&#x27;t really get to see all of the things they do catch. Maybe they are getting 90% of other related vulnerabilities with the patches but you only hear about the 10% that weren&#x27;t covered by it because that&#x27;s the only thing someone is going to publish&#x2F;get a cve for&#x2F;make the front page of HN.<p>The point isn&#x27;t that billions of users all actively try to exploit software it&#x27;s that if you have billions of users then even if 0.01% try to then that&#x27;s still a hell of a lot more external bug finders than internal bug finders.<p>Yeah nothing against you or genuine curiosity it&#x27;s just when a comment sets up a series of logic and concludes with a leading question then the conversation is damned to largely revolve around the leading question instead of genuine answers.</div><br/><div id="37056877" class="c"><input type="checkbox" id="c-37056877" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056638">parent</a><span>|</span><a href="#37057649">next</a><span>|</span><label class="collapse" for="c-37056877">[-]</label><label class="expand" for="c-37056877">[1 more]</label></div><br/><div class="children"><div class="content">I dabble in this space (hardware reverse-engineering) and write software for a living and in my opinion the gaps are huge.<p>I should disclose have been paid by a chip-maker for a blog post that I wrote which &quot;disclosed&quot; an optimization which could be uses for a side channel attack (though I did not even suggest that aspect) and which was subsequently patched away via a microcode update. The whole process was very surprising to me in that there must have been several people inside the chip-maker who knew about the optimization I described in much deeper detail ... after all they conceived and implemented it.<p>So by what path does a blog post mentioning it get treated as the disclosure that results it it being removed when they knew about it all along?<p>&gt; that&#x27;s not how these attacks work it&#x27;s by some oversight in memory handling not that different from software.<p>I think it is very different. Assembly is merely a somewhat less convenient form of the original semantics that embeds all the relevant semantics related to the attack surface since the original source has been &quot;erased&quot;. Many analysis tools such as fuzzers operate directly on assembly with little loss in functionality.<p>These attacks are against completely unspecified aspects of the instruction execution and lean heavily on the actual hardware implementation (almost at the level of &quot;how the transistors are laid out&quot;) such as what hidden buffers are used, when they are filled, how they are shared with sibling threads, etc.<p>In my  experience there are very few people interested in these details outside of the vendors themselves and these folks and the ones creating the exploits would fit in a modestly sized lecture hall. The scope has increased a bit lately (see Tavis&#x27;s fuzzer work) but it was originally a small group with little or no funding.</div><br/></div></div><div id="37057649" class="c"><input type="checkbox" id="c-37057649" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056638">parent</a><span>|</span><a href="#37056877">prev</a><span>|</span><a href="#37058799">next</a><span>|</span><label class="collapse" for="c-37057649">[-]</label><label class="expand" for="c-37057649">[2 more]</label></div><br/><div class="children"><div class="content">This reminds me of lock manufactures vs The Lockpicking Lawyer. He is able to pick nearly every damn lock out there, yet they have all the design resources and money to hire people like him to make better locks.</div><br/><div id="37059492" class="c"><input type="checkbox" id="c-37059492" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057649">parent</a><span>|</span><a href="#37058799">next</a><span>|</span><label class="collapse" for="c-37059492">[-]</label><label class="expand" for="c-37059492">[1 more]</label></div><br/><div class="children"><div class="content">I had a failed startup where we warned our customers they were using suppliers without sufficient qualifications, insurance, etc. Nobody wanted the product, even for free. At a system level, they chose to use cowboy tradespeople and cover the risk with &quot;plausible deniability&quot;, because the market wouldn&#x27;t pay them to only use quality.<p>It&#x27;s like a Gresham&#x27;s law - eventually the lowest quality dominates the market, because that&#x27;s what maximises profit.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37058799" class="c"><input type="checkbox" id="c-37058799" checked=""/><div class="controls bullet"><span class="by">whoisthemachine</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055727">prev</a><span>|</span><a href="#37057001">next</a><span>|</span><label class="collapse" for="c-37058799">[-]</label><label class="expand" for="c-37058799">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same as any product, the product team wants a faster, cheaper product, yesterday. Security and trust is secondary, because if you&#x27;re lucky enough, that will fall on the next product team.<p>Beyond that, processors contain billions (or trillions?) of possible outcomes from a set of inputs. Testing for all of these just to verify reliability and stamp out logic bugs is really hard due to the combinatorial explosion. Putting security testing on top just complicates matter further. The best they can probably do is map out potential ways in which their <i>general purpose</i> processors could be used for specific nefarious uses.</div><br/></div></div><div id="37057001" class="c"><input type="checkbox" id="c-37057001" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37058799">prev</a><span>|</span><a href="#37057511">next</a><span>|</span><label class="collapse" for="c-37057001">[-]</label><label class="expand" for="c-37057001">[2 more]</label></div><br/><div class="children"><div class="content">Maybe they&#x27;re simply victims of Kernighan&#x27;s Law of Debugging: &quot;Everyone knows that debugging is twice as hard as writing a program in the first place. So if you&#x27;re as clever as you can be when you write it, how will you ever debug it?&quot;<p>There is no doubt that Intel make chips &quot;as clever as they can&quot;. Hence, by definition, they can&#x27;t fully debug them.</div><br/><div id="37057365" class="c"><input type="checkbox" id="c-37057365" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057001">parent</a><span>|</span><a href="#37057511">next</a><span>|</span><label class="collapse" for="c-37057365">[-]</label><label class="expand" for="c-37057365">[1 more]</label></div><br/><div class="children"><div class="content">If debugging is what we call it when fixing things, does that mean we&#x27;re &quot;bugging&quot; when we make it?</div><br/></div></div></div></div><div id="37057511" class="c"><input type="checkbox" id="c-37057511" checked=""/><div class="controls bullet"><span class="by">dougall</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37057001">prev</a><span>|</span><a href="#37057082">next</a><span>|</span><label class="collapse" for="c-37057511">[-]</label><label class="expand" for="c-37057511">[1 more]</label></div><br/><div class="children"><div class="content">Yeah... I don&#x27;t know if you saw Rodrigo Branco&#x27;s damning &quot;The Microarchitectures That I Saw And The Ones That I Hope To One Day See&quot;:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WlcQrx7VK00">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WlcQrx7VK00</a>
<a href="https:&#x2F;&#x2F;hardwear.io&#x2F;usa-2023&#x2F;presentation&#x2F;the-microarchitectures-that-I-saw-and-the-ones-that-I-hope-to-one-day-see.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;hardwear.io&#x2F;usa-2023&#x2F;presentation&#x2F;the-microarchitect...</a><p>But it definitely seems to be a culture&#x2F;disclosure problem.<p>(Also, hi - hope things are going well! We miss you on Mastodon)</div><br/></div></div><div id="37057082" class="c"><input type="checkbox" id="c-37057082" checked=""/><div class="controls bullet"><span class="by">yyyk</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37057511">prev</a><span>|</span><a href="#37055621">next</a><span>|</span><label class="collapse" for="c-37057082">[-]</label><label class="expand" for="c-37057082">[4 more]</label></div><br/><div class="children"><div class="content">The chipmakers don&#x27;t have an incentive to look too hard for speculation security issues beyond a bit of PR. If they succeed, they lose money and marketshare, while their &#x27;insecure&#x27; opponents gain and at most patches later. And in fairness, a lot of these bugs are rather theoretical. Until buyers take these bugs much more seriously, this isn&#x27;t going to change.</div><br/><div id="37057955" class="c"><input type="checkbox" id="c-37057955" checked=""/><div class="controls bullet"><span class="by">peddling-brink</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057082">parent</a><span>|</span><a href="#37055621">next</a><span>|</span><label class="collapse" for="c-37057955">[-]</label><label class="expand" for="c-37057955">[3 more]</label></div><br/><div class="children"><div class="content">Clouds take these vulns seriously, and have a lot to lose, and have deep wallets. I&#x27;d be surprised if this topic didn&#x27;t come up when large purchases are discussed.<p>Not that there are many alternatives..</div><br/><div id="37058291" class="c"><input type="checkbox" id="c-37058291" checked=""/><div class="controls bullet"><span class="by">ComodoHacker</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057955">parent</a><span>|</span><a href="#37058146">next</a><span>|</span><label class="collapse" for="c-37058291">[-]</label><label class="expand" for="c-37058291">[1 more]</label></div><br/><div class="children"><div class="content">And this flaw was found by researcher working for a cloud vendor. I wouldn&#x27;t be surprised if they already have some special long-term agreements.</div><br/></div></div></div></div></div></div><div id="37055621" class="c"><input type="checkbox" id="c-37055621" checked=""/><div class="controls bullet"><span class="by">hackermatic</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37057082">prev</a><span>|</span><a href="#37056457">next</a><span>|</span><label class="collapse" for="c-37055621">[-]</label><label class="expand" for="c-37055621">[2 more]</label></div><br/><div class="children"><div class="content">A fundamental problem is that the attack surface is so, so huge. Even if their security researchers are doing blue-sky research on both very small and very broad areas of processor functionality, they&#x27;re going to miss a lot.<p>And in line with that and<p>&gt;Maybe they _did_ and are well aware of all these attacks but to save face and performance hits they simply hold on to them hoping nobody makes them public?<p>... maybe they <i>have</i> patched a number of issues and just never announced them.</div><br/><div id="37056140" class="c"><input type="checkbox" id="c-37056140" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055621">parent</a><span>|</span><a href="#37056457">next</a><span>|</span><label class="collapse" for="c-37056140">[-]</label><label class="expand" for="c-37056140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A fundamental problem is that the attack surface is so, so huge. Even if their security researchers are doing blue-sky research on both very small and very broad areas of processor functionality, they&#x27;re going to miss a lot.<p>Sure. If they had patched a bunch of Spectre vulnerabilities and independent researchers had discovered a few more that would be one thing, but as far as I can tell they have patched _zero_ while independent researches have found many and it has been years since the initial attack. Many of these follow very similar patterns and &quot;in what cases is protected data exposed via speculative execution&quot; is something that an architect or engineer could definitely assess.</div><br/></div></div></div></div><div id="37056457" class="c"><input type="checkbox" id="c-37056457" checked=""/><div class="controls bullet"><span class="by">CTDOCodebases</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055621">prev</a><span>|</span><a href="#37055729">next</a><span>|</span><label class="collapse" for="c-37056457">[-]</label><label class="expand" for="c-37056457">[3 more]</label></div><br/><div class="children"><div class="content">And maybe just maybe when the Snowden revelations started to come out some people woke up and realised that the companies who design the processors used in the vast majority of computers are from the US.<p><a href="https:&#x2F;&#x2F;www.theverge.com&#x2F;2013&#x2F;12&#x2F;20&#x2F;5231006&#x2F;nsa-paid-10-million-for-a-back-door-into-rsa-encryption-according-to" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.theverge.com&#x2F;2013&#x2F;12&#x2F;20&#x2F;5231006&#x2F;nsa-paid-10-mill...</a></div><br/><div id="37056948" class="c"><input type="checkbox" id="c-37056948" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056457">parent</a><span>|</span><a href="#37055729">next</a><span>|</span><label class="collapse" for="c-37056948">[-]</label><label class="expand" for="c-37056948">[2 more]</label></div><br/><div class="children"><div class="content">Since Applied Cryptograhy and everyday since publication it&#x27;s been well-known and well-understood that NSA&#x27;s never-ending efforts to weaken systems to make it easier for them to do their work wrecks havoc and costs billions to everyone else.  Luckily their attempt to get everyone to adopt a PRNG that was broken on-purpose was thwarted.<p>But who&#x27;s to say that any chipmaker gets bribed to backdoor their design to allow the reading of any page of RAM from any protection level doesn&#x27;t happen?   It would make their job super easy.</div><br/><div id="37059202" class="c"><input type="checkbox" id="c-37059202" checked=""/><div class="controls bullet"><span class="by">CTDOCodebases</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056948">parent</a><span>|</span><a href="#37055729">next</a><span>|</span><label class="collapse" for="c-37059202">[-]</label><label class="expand" for="c-37059202">[1 more]</label></div><br/><div class="children"><div class="content">Some people might say “don’t attribute to malice what can be attributed to incompetence” but introducing bugs via bribing an insider or even getting one of your people a job at Intel or AMD would be a very clever way to give yourself the keys to (nearly) all the castles.<p>Just don’t forget to patch the microcode on your own systems.</div><br/></div></div></div></div></div></div><div id="37055729" class="c"><input type="checkbox" id="c-37055729" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056457">prev</a><span>|</span><a href="#37058894">next</a><span>|</span><label class="collapse" for="c-37055729">[-]</label><label class="expand" for="c-37055729">[9 more]</label></div><br/><div class="children"><div class="content"><i>&gt;In principle it seems like the chipmakers should hold all the cards when it comes to discovery: they are experts in speculative execution, know exactly how their chips work and have massive existing validation suites, simulators and internal machine-readable specifications for the low-level operations of these chips.</i><p>I hope you&#x27;re not in charge of hiring QA. Bugs are often found by people who AREN&#x27;T thinking like the developers whichstart wearing blinders on how they&#x27;re stuff should work and stop trying stupid things.</div><br/><div id="37056242" class="c"><input type="checkbox" id="c-37056242" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055729">parent</a><span>|</span><a href="#37056370">next</a><span>|</span><label class="collapse" for="c-37056242">[-]</label><label class="expand" for="c-37056242">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not directly in charge of hiring QA, no!<p>I think this sort of excuses the initial blindness to Spectre style attacks in the first place, but once the basic pattern was clear it doesn&#x27;t excuse the subsequent lack of discovering any of the subsequent issues.<p>It is as if someone found a bug by examining the assembly language of your process which was caused by unsafe inlined `strcpy` calls (though they could not see the source, so they had no idea strcpy was the problem), and then over a the subsequent 6 years other people slowly found more strcpy issues in your application using brute-force black-box engineering and meanwhile you never just grepped your (closed) source for strcpy uses and audited them or used many of the compiler or runtime mitigations against this issue.</div><br/><div id="37056280" class="c"><input type="checkbox" id="c-37056280" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056242">parent</a><span>|</span><a href="#37056370">next</a><span>|</span><label class="collapse" for="c-37056280">[-]</label><label class="expand" for="c-37056280">[1 more]</label></div><br/><div class="children"><div class="content">That still seems like a job for QA and you do have a good point. If there&#x27;s an attack using one technique, there should be an audit to make sure that technique can&#x27;t be modified to be used in other nasty ways, then have those tests part of the test suite.</div><br/></div></div></div></div><div id="37056370" class="c"><input type="checkbox" id="c-37056370" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055729">parent</a><span>|</span><a href="#37056242">prev</a><span>|</span><a href="#37058133">next</a><span>|</span><label class="collapse" for="c-37056370">[-]</label><label class="expand" for="c-37056370">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I hope you&#x27;re not in charge of hiring QA.<p>This seems unnecessarily harsh. The whole post would be improved by removing that sentence IMO.</div><br/><div id="37056483" class="c"><input type="checkbox" id="c-37056483" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056370">parent</a><span>|</span><a href="#37058133">next</a><span>|</span><label class="collapse" for="c-37056483">[-]</label><label class="expand" for="c-37056483">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the camp that developers shouldn&#x27;t be responsible for having a transcendental ability to predict future (example) security holes. If one appears, it&#x27;s really the QA&#x27;s job to document it and experiment with other similar vectors of attack. The developers are, you know: developing. Bring them back in when the security issues needs to be fixed, once it&#x27;s found just how big the problem is.</div><br/><div id="37057080" class="c"><input type="checkbox" id="c-37057080" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056483">parent</a><span>|</span><a href="#37058133">next</a><span>|</span><label class="collapse" for="c-37057080">[-]</label><label class="expand" for="c-37057080">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t the functions of &quot;development&quot; and &quot;QA&quot; both reside under the umbrella of the chip-maker though?<p>In fact, chip-makers famously invest an insane amount of money into &quot;QA&quot; (aka &quot;validation&quot;) and many features or lack thereof are often put down to the cost of QA rather than the cost of development.</div><br/><div id="37057828" class="c"><input type="checkbox" id="c-37057828" checked=""/><div class="controls bullet"><span class="by">IIsi50MHz</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37057080">parent</a><span>|</span><a href="#37058133">next</a><span>|</span><label class="collapse" for="c-37057828">[-]</label><label class="expand" for="c-37057828">[1 more]</label></div><br/><div class="children"><div class="content">Possibly. When I worked at a place that designed a &quot;simple&quot; chip that was just a more energy efficient and very parallel version of its FPGA, the fab that was contracted to make it insisted on validating it themselves. It consisted primarily of a lot of copy-paste of the primary logic to build as many paths as would fit on the die. They described it as &quot;unusually dense&quot; and, I heard they later said that they&#x27;d never seen a design that dense. The validation process was partly described as people manually driving a car through a 3D model, making sure there were no unexpected junctions or other divergences. This process took months longer than their initial estimate, allegedly due to the density.<p>I guess you could say this was &quot;under the umbrella of the chip-maker&quot;, though we had little say in it aside from pressing them for progress as our final product&#x27;s shipdates came and left. When we finally got the first samples, power consumption was, I think, an order of magnitude higher than expected. Our lead engineer struggled to get it down without going to a smaller process that we could barely afford (and given the delays already, could probably not have afforded to wait for). We thus thought we had working logic, but our case designs were scuttled. After enlarging the cases to accommodate extra cooling, our base unit was more than ten times taller, and our next size up, while the same height, was three times longer. Highest units had a water cooling system[1].<p>Our QA was able to find other sorts of flaws, like misprinted unpopulated circuit boards, software faults on the host, or when we received shoddy interlink cables that either melted under test[2] or other cables that scrambled communications[3].<p>All of which is to say, that many other pressing issues can interfere with doing what you feel you ought to be doing. At least at our scale. I can&#x27;t speak for the likes of big guys like Intel or AMD, but it&#x27;s possible that unfound faults or known unpatched flaws can ship because resources were committed elsewhere or fabrication leadtimes preclude waiting. This is not to say that shipping a security flaw is okay, but rather that sometimes you think you&#x27;ve done you&#x27;re due diligence, or sometimes your choices seem to be &quot;Ship, ship late, or never ship.&quot;. The answer you pick can be existential, so you hope you&#x27;ve picked the least bad option.<p>[1] Misbegotten, because &quot;beauty of the promo images&quot;.<p>[2] Conductors much thinner than spec, not initially observed because both ends were fitted with moulded plugs.<p>[3] Longer than spec, initially recieved with enthusiasm by assembly staff, before an engineer investigating a difficulty saw them and exclaimed, &quot;No-no-no! That&#x27;s longer than I am tall! Stray capacitance alone will kill the communication.&quot;. (He uncharacteristic&#x27;ly exagerated here. While they were three times longer than expected,  this was at most .40 times his height.)</div><br/></div></div></div></div></div></div></div></div><div id="37058133" class="c"><input type="checkbox" id="c-37058133" checked=""/><div class="controls bullet"><span class="by">mekoka</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055729">parent</a><span>|</span><a href="#37056370">prev</a><span>|</span><a href="#37057414">next</a><span>|</span><label class="collapse" for="c-37058133">[-]</label><label class="expand" for="c-37058133">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I hope you&#x27;re not in charge of hiring QA.<p>Why the personal attack? The logic is sound. Isn&#x27;t QA typically part of the same organization?</div><br/></div></div><div id="37057414" class="c"><input type="checkbox" id="c-37057414" checked=""/><div class="controls bullet"><span class="by">netheril96</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055729">parent</a><span>|</span><a href="#37058133">prev</a><span>|</span><a href="#37058894">next</a><span>|</span><label class="collapse" for="c-37057414">[-]</label><label class="expand" for="c-37057414">[1 more]</label></div><br/><div class="children"><div class="content">No QA is able to find out a Spectre vulnerability. QA is irrelevant in this conversation.</div><br/></div></div></div></div><div id="37058894" class="c"><input type="checkbox" id="c-37058894" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055729">prev</a><span>|</span><a href="#37056917">next</a><span>|</span><label class="collapse" for="c-37058894">[-]</label><label class="expand" for="c-37058894">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe they did and are well aware of all these attacks but to save face and performance hits they simply hold on to them hoping nobody makes them public?<p>Or they chose not to look for these types of bugs in the first place, for those reasons.</div><br/></div></div><div id="37056917" class="c"><input type="checkbox" id="c-37056917" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37058894">prev</a><span>|</span><a href="#37056402">next</a><span>|</span><label class="collapse" for="c-37056917">[-]</label><label class="expand" for="c-37056917">[1 more]</label></div><br/><div class="children"><div class="content">The intersection of probabilistic optimization and timing based side channels is a gift that will never ever fully go away.<p>Everything _really fast_ which is approximately any very mature systems gear has probabilistic optimization in it now, and that&#x27;s where a great deal of modern performance comes from.<p>Even thermals and power draws produce side channels. Eradicating every side channel is untenable, research is required to understand what side channels are tenable, then we have to patch them up as best we can.<p>I&#x27;m waiting for the one where we find that binning is involved in an integrated way, and that some arbitrary sub-population of popular chips turn out to much more exploitable than others due to particular paths being disabled and leaking extra timing info. That&#x27;ll be a really fun and awful day.</div><br/></div></div><div id="37056402" class="c"><input type="checkbox" id="c-37056402" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056917">prev</a><span>|</span><a href="#37057451">next</a><span>|</span><label class="collapse" for="c-37056402">[-]</label><label class="expand" for="c-37056402">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re last statement is half right. They probably don&#x27;t bother looking for them that hard because if they look for them they might find them and then have to make their CPUs slower before launch.</div><br/></div></div><div id="37057451" class="c"><input type="checkbox" id="c-37057451" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056402">prev</a><span>|</span><a href="#37055937">next</a><span>|</span><label class="collapse" for="c-37057451">[-]</label><label class="expand" for="c-37057451">[1 more]</label></div><br/><div class="children"><div class="content">I think there are simply very few humans performing competent vulnerability research (proactive discovery, not reactive patching) in public.</div><br/></div></div><div id="37055937" class="c"><input type="checkbox" id="c-37055937" checked=""/><div class="controls bullet"><span class="by">z3t4</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37057451">prev</a><span>|</span><a href="#37056923">next</a><span>|</span><label class="collapse" for="c-37055937">[-]</label><label class="expand" for="c-37055937">[1 more]</label></div><br/><div class="children"><div class="content">You are describing a creator bias, there are probably a better name, where you think the ones who created something knows it best. For example, you could create a programming language, a game, or anything, and you think that you know it better then someone who use it for several hours every day. The larger the user base the less likely you are better or know it better then all users.</div><br/></div></div><div id="37056923" class="c"><input type="checkbox" id="c-37056923" checked=""/><div class="controls bullet"><span class="by">chrsw</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055937">prev</a><span>|</span><a href="#37055616">next</a><span>|</span><label class="collapse" for="c-37056923">[-]</label><label class="expand" for="c-37056923">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s more money to be made in performance and efficiency than security. If chipmakers could design and build the perfect processor, they would. But like anything else complex, there are compromises everywhere.</div><br/><div id="37057104" class="c"><input type="checkbox" id="c-37057104" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37056923">parent</a><span>|</span><a href="#37055616">next</a><span>|</span><label class="collapse" for="c-37057104">[-]</label><label class="expand" for="c-37057104">[1 more]</label></div><br/><div class="children"><div class="content">Granted but the vendors accept these are serious problems given that they are immediately patched and the mitigation all enabled by default even at significant performance cost (most chip generations are down double digit perf % based versus &quot;zero mitigations&quot; at this int).<p>So they don&#x27;t need to build the &quot;perfect processor&quot; but why aren&#x27;t they discovering any of these issues themselves?</div><br/></div></div></div></div><div id="37055616" class="c"><input type="checkbox" id="c-37055616" checked=""/><div class="controls bullet"><span class="by">Method-X</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056923">prev</a><span>|</span><a href="#37056327">next</a><span>|</span><label class="collapse" for="c-37055616">[-]</label><label class="expand" for="c-37055616">[3 more]</label></div><br/><div class="children"><div class="content">Like how car companies will do a cost&#x2F;benefit analysis to see if a recall is worth it.</div><br/><div id="37055701" class="c"><input type="checkbox" id="c-37055701" checked=""/><div class="controls bullet"><span class="by">david-gpu</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055616">parent</a><span>|</span><a href="#37056327">next</a><span>|</span><label class="collapse" for="c-37055701">[-]</label><label class="expand" for="c-37055701">[2 more]</label></div><br/><div class="children"><div class="content">Having worked in the industry, my gut feeling is that chipmakers don&#x27;t invest all that much in looking for and preventing these sorts of attacks.<p>When working on a new feature, you are desperately trying to deliver on time something that adds value in the sorts of scenarios that it was designed for. And that is already hard enough.</div><br/><div id="37059109" class="c"><input type="checkbox" id="c-37059109" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055701">parent</a><span>|</span><a href="#37056327">next</a><span>|</span><label class="collapse" for="c-37059109">[-]</label><label class="expand" for="c-37059109">[1 more]</label></div><br/><div class="children"><div class="content">The industry as a whole is yet to have the same liability laws as the car industry.<p>When it comes, and it will come, that will change.</div><br/></div></div></div></div></div></div><div id="37056327" class="c"><input type="checkbox" id="c-37056327" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37055616">prev</a><span>|</span><a href="#37056305">next</a><span>|</span><label class="collapse" for="c-37056327">[-]</label><label class="expand" for="c-37056327">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably that they are aware of several vulnerabilities, such is life. But they are unable to prioritize them and assess which to solve first, they need external auditors using black box techniques to help them identify which are exploitable by external attackers, so they can fix that one, and not the other non issues</div><br/></div></div><div id="37056305" class="c"><input type="checkbox" id="c-37056305" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056327">prev</a><span>|</span><a href="#37055965">next</a><span>|</span><label class="collapse" for="c-37056305">[-]</label><label class="expand" for="c-37056305">[1 more]</label></div><br/><div class="children"><div class="content">My guess: There are a lot more researchers on the outside than inside. And also incentives - you would need a red team at Intel who tries to attack their own chips, and those people would be even fewer. And the best people may want to stay independent.</div><br/></div></div><div id="37055965" class="c"><input type="checkbox" id="c-37055965" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37055529">parent</a><span>|</span><a href="#37056305">prev</a><span>|</span><a href="#37053352">next</a><span>|</span><label class="collapse" for="c-37055965">[-]</label><label class="expand" for="c-37055965">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that nobody wants to admit that the old, stodgy mainframe guys were right 30 years ago and that sharing <i>anything</i> always results in an exfiltration surface.<p>Nobody wants to be the first to take proper steps because they have to either:<p>1) Partition hardware properly so that users are genuinely isolated.  This costs silicon area that nobody wants to pay for.<p>2) Stop all the speculative bullshit.  This throws performance into rewind and will put chip performance back a decade or two that nobody wants to pay for.<p>Until people are willing to value security enough to put real money behind it, this will continue ad nauseam.</div><br/><div id="37056415" class="c"><input type="checkbox" id="c-37056415" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#37055529">root</a><span>|</span><a href="#37055965">parent</a><span>|</span><a href="#37053352">next</a><span>|</span><label class="collapse" for="c-37056415">[-]</label><label class="expand" for="c-37056415">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add that the status quo has done pretty well, and many of these exploits are fixed.  It&#x27;s also worth noting that a lot of the exploits in question may be known, but the people working on them couldn&#x27;t theorize a practical exploit.  How many web browser sandbox breaches have there been over the years?  Far less than the CPU exploits in the past several years.  The latter can have a much bigger impact though.<p>The biggest risk target seems to be shared servers, and you often don&#x27;t <i>know</i> who you&#x27;re sharing with, so is it worth trying?  It seems to be usually, no... in a specific target, maybe.</div><br/></div></div></div></div></div></div><div id="37053352" class="c"><input type="checkbox" id="c-37053352" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37055529">prev</a><span>|</span><a href="#37053357">next</a><span>|</span><label class="collapse" for="c-37053352">[-]</label><label class="expand" for="c-37053352">[33 more]</label></div><br/><div class="children"><div class="content">The Intel paper link is dead, this seems to be the right one:<p><a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;software-security-guidance&#x2F;technical-documentation&#x2F;gather-data-sampling.html?wapkw=gather%20data%20sampling" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>General caveats: are there many clouds that still run  workloads from different users on the same physical core? I thought most had changed their schedulers years ago so you can&#x27;t get cross-domain leaks between hyperthreads anymore. Claiming that it affects all users on the internet seems like a massive over-exaggeration, as he hasn&#x27;t demonstrated any kind of browser based exploit and even if such a thing did exist, it&#x27;d affect only a tiny minority of targeted users, as AFAIK many years after the introduction of Spectre nobody has ever found a specex attack in the wild (or have they?)<p>I think the more interesting thing here is that it continues the long run of speculation bugs that always seem to be patchable in microcode. When this stuff first appeared there was the looming fear that we&#x27;d have to be regularly junking and replacing the physical chips en masse, but has that ever been necessary? AFAIK all of the bugs could be addressed via a mix of software and microcode changes, sometimes at the cost of some performance in some cases. But there&#x27;s never been a bug that needed new physical silicon (except for the early versions of AMD SEV, which were genuinely jailbroken in unpatchable ways).</div><br/><div id="37054791" class="c"><input type="checkbox" id="c-37054791" checked=""/><div class="controls bullet"><span class="by">kiririn</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37053480">next</a><span>|</span><label class="collapse" for="c-37054791">[-]</label><label class="expand" for="c-37054791">[8 more]</label></div><br/><div class="children"><div class="content">&gt;are there many clouds that still run workloads from different users on the same physical core?<p>There are a vast number of VPS providers out there that aren’t AWS&#x2F;GCP&#x2F;Azure&#x2F;etc where the answer is yes. Even the ones that sell ‘dedicated’ cores, which really just means unmetered cpu</div><br/><div id="37055063" class="c"><input type="checkbox" id="c-37055063" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054791">parent</a><span>|</span><a href="#37055430">next</a><span>|</span><label class="collapse" for="c-37055063">[-]</label><label class="expand" for="c-37055063">[5 more]</label></div><br/><div class="children"><div class="content">What about burstable instances on AWS, and whatever is the equivalent in other clouds? Hard to imagine those having a dedicated core, would probably defeat the purpose.</div><br/><div id="37055462" class="c"><input type="checkbox" id="c-37055462" checked=""/><div class="controls bullet"><span class="by">schlarpc</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37055063">parent</a><span>|</span><a href="#37055289">next</a><span>|</span><label class="collapse" for="c-37055462">[-]</label><label class="expand" for="c-37055462">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-design-of-aws-nitro-system&#x2F;the-ec2-approach-to-preventing-side-channels.html#:~:text=However%2C%20even%20burstable%20instances%20never%20share%20the%20same%20core%20at%20the%20same%20time%2C%20and%20virtual%20memory%20pages%20are%20never%20shared%20across%20instances" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-desi...</a>.</div><br/></div></div><div id="37055289" class="c"><input type="checkbox" id="c-37055289" checked=""/><div class="controls bullet"><span class="by">watermelon0</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37055063">parent</a><span>|</span><a href="#37055462">prev</a><span>|</span><a href="#37055430">next</a><span>|</span><label class="collapse" for="c-37055289">[-]</label><label class="expand" for="c-37055289">[3 more]</label></div><br/><div class="children"><div class="content">Not just burstable instances.<p>AWS Fargate, container as a service, allows specifying 0.25 or 0.5 CPU, and I would be surprised if those weren&#x27;t shared.<p>Same probably? also applies to AWS Lambda.</div><br/><div id="37056444" class="c"><input type="checkbox" id="c-37056444" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37055289">parent</a><span>|</span><a href="#37056510">next</a><span>|</span><label class="collapse" for="c-37056444">[-]</label><label class="expand" for="c-37056444">[1 more]</label></div><br/><div class="children"><div class="content">My guess is there&#x27;s likely less value in trying to target those kinds of environments... Just poking random data out of lambda or low end vps neighbors is a needle in a haystack the size of the moon in terms of finding anything useful.<p>It&#x27;s more likely useful as part of a group of exploits to hit an individual, targeted system.</div><br/></div></div><div id="37056510" class="c"><input type="checkbox" id="c-37056510" checked=""/><div class="controls bullet"><span class="by">c2h5oh</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37055289">parent</a><span>|</span><a href="#37056444">prev</a><span>|</span><a href="#37055430">next</a><span>|</span><label class="collapse" for="c-37056510">[-]</label><label class="expand" for="c-37056510">[1 more]</label></div><br/><div class="children"><div class="content">Worse: by default it&#x27;s not CPU but VCPU - a single core with multithreading = 2 VCPU</div><br/></div></div></div></div></div></div><div id="37055430" class="c"><input type="checkbox" id="c-37055430" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054791">parent</a><span>|</span><a href="#37055063">prev</a><span>|</span><a href="#37053480">next</a><span>|</span><label class="collapse" for="c-37055430">[-]</label><label class="expand" for="c-37055430">[2 more]</label></div><br/><div class="children"><div class="content">Per the paper, this looks like an attack against speculated instructions that modify the store forward buffer.   The details aren&#x27;t super clear, but that seems extremely unlikely to survive a context switch.  In practice this is probably only an attack against hyperthread code running simultaneously on the same CPU, which I&#x27;d expect cloud hosts to have eliminated long ago.</div><br/><div id="37057349" class="c"><input type="checkbox" id="c-37057349" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37055430">parent</a><span>|</span><a href="#37053480">next</a><span>|</span><label class="collapse" for="c-37057349">[-]</label><label class="expand" for="c-37057349">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the way AWS has stock language like “AWS has designed and implemented its infrastructure with protections against this class of issues” supports the idea that you’re probably not getting anywhere with exploits of this class on a major cloud host any more.</div><br/></div></div></div></div></div></div><div id="37053480" class="c"><input type="checkbox" id="c-37053480" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37054791">prev</a><span>|</span><a href="#37054413">next</a><span>|</span><label class="collapse" for="c-37053480">[-]</label><label class="expand" for="c-37053480">[8 more]</label></div><br/><div class="children"><div class="content">The Spectre attack had to be patched in the kernel in a way that significantly slowed down execution on Intel CPU:s: <a href="https:&#x2F;&#x2F;www.notebookcheck.net&#x2F;Spectre-v2-mitigation-wreaks-havoc-on-the-performance-of-some-Intel-CPUs-as-AMD-chips-come-out-largely-unscathed.607925.0.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.notebookcheck.net&#x2F;Spectre-v2-mitigation-wreaks-h...</a></div><br/><div id="37057410" class="c"><input type="checkbox" id="c-37057410" checked=""/><div class="controls bullet"><span class="by">dmatech</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37053480">parent</a><span>|</span><a href="#37053724">next</a><span>|</span><label class="collapse" for="c-37057410">[-]</label><label class="expand" for="c-37057410">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s interesting is that the FDIV bug from 1994 could also be worked around, but Intel recalled and wrote off those processors[1].  For their latest several problems, their response was more of a &quot;sucks to be you&quot;.  While they provided microcode updates and worked with OS vendors, there were performance impacts that materially affected the value of the chips.<p>1. <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;history&#x2F;history-1994-annual-report.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;history&#x2F;history-1994...</a></div><br/><div id="37059187" class="c"><input type="checkbox" id="c-37059187" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37057410">parent</a><span>|</span><a href="#37053724">next</a><span>|</span><label class="collapse" for="c-37059187">[-]</label><label class="expand" for="c-37059187">[1 more]</label></div><br/><div class="children"><div class="content">The software workaround for the FDIV bug required the actual userspace software to be modified and recompiled. There was a decade of pre-existing software out there that would be hard to fix, especially in the days before most people had the internet.<p>There was nothing the OS could do to work around the bug, short of disabling the entire FPU and falling back to expensive software emulation of all floating point math.<p>The workarounds for all these speculation bugs can be mostly applied at the operating system and&#x2F;or microcode level, and is comparably cheap.</div><br/></div></div></div></div><div id="37053724" class="c"><input type="checkbox" id="c-37053724" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37053480">parent</a><span>|</span><a href="#37057410">prev</a><span>|</span><a href="#37054413">next</a><span>|</span><label class="collapse" for="c-37053724">[-]</label><label class="expand" for="c-37053724">[5 more]</label></div><br/><div class="children"><div class="content">Yes, I think that&#x27;s what I said? Every attack no matter how deep it seemed to be has been patchable in microcode, sometimes at a cost in performance. But so far nobody had to toss the physical silicon, at least not with Intel. The malleability of these chips is quite fascinating.</div><br/><div id="37056709" class="c"><input type="checkbox" id="c-37056709" checked=""/><div class="controls bullet"><span class="by">sigotirandolas</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37053724">parent</a><span>|</span><a href="#37054550">next</a><span>|</span><label class="collapse" for="c-37056709">[-]</label><label class="expand" for="c-37056709">[1 more]</label></div><br/><div class="children"><div class="content">On some Skylake CPUs to get full mitigations you are taking a 30% performance penalty _and_ you need to disable SMT which is often another double digit penalty. It&#x27;s not a literal &quot;toss the physical silicon&quot;, but it&#x27;s getting there.<p>In fact my thesis is that it&#x27;s never a literal &quot;toss the physical silicon&quot; because the kernel is able to take control when switching between tasks so (with help from the microcode) it&#x27;s able to wipe all potential speculation vectors (at an arbitrarily expensive cost) before switching to the next task. This also explains why SMT is unfixably broken on some processors, since by design the kernel does not intervene in the task switching on the virtual cores.</div><br/></div></div><div id="37054550" class="c"><input type="checkbox" id="c-37054550" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37053724">parent</a><span>|</span><a href="#37056709">prev</a><span>|</span><a href="#37054413">next</a><span>|</span><label class="collapse" for="c-37054550">[-]</label><label class="expand" for="c-37054550">[3 more]</label></div><br/><div class="children"><div class="content">The meltdown and spectre mitigations weren&#x27;t patched in microcode, they were patched by changing the internal calling methods of the kernel.</div><br/><div id="37054775" class="c"><input type="checkbox" id="c-37054775" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054550">parent</a><span>|</span><a href="#37054413">next</a><span>|</span><label class="collapse" for="c-37054775">[-]</label><label class="expand" for="c-37054775">[2 more]</label></div><br/><div class="children"><div class="content">I think it was both. There were initial software only patches, but those were quickly superseded by microcode+kernel patches, where microcode added features the kernel enabled. IBRS or something like that.</div><br/><div id="37054883" class="c"><input type="checkbox" id="c-37054883" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054775">parent</a><span>|</span><a href="#37054413">next</a><span>|</span><label class="collapse" for="c-37054883">[-]</label><label class="expand" for="c-37054883">[1 more]</label></div><br/><div class="children"><div class="content">It was both, and none of them completely addressed the problem. They did need new hardware for that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37054413" class="c"><input type="checkbox" id="c-37054413" checked=""/><div class="controls bullet"><span class="by">vladvasiliu</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37053480">prev</a><span>|</span><a href="#37054435">next</a><span>|</span><label class="collapse" for="c-37054413">[-]</label><label class="expand" for="c-37054413">[7 more]</label></div><br/><div class="children"><div class="content">&gt; General caveats: are there many clouds that still run workloads from different users on the same physical core? I thought most had changed their schedulers years ago so you can&#x27;t get cross-domain leaks between hyperthreads anymore.<p>Isn&#x27;t this the whole point of AWS&#x27; t instances? It&#x27;s my understanding that they are &quot;shared&quot; at the core level, or else there wouldn&#x27;t be a reason for the CPU credit balance thing.</div><br/><div id="37054531" class="c"><input type="checkbox" id="c-37054531" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054413">parent</a><span>|</span><a href="#37054435">next</a><span>|</span><label class="collapse" for="c-37054531">[-]</label><label class="expand" for="c-37054531">[6 more]</label></div><br/><div class="children"><div class="content">They are definitely time-sliced among tenants and very possibly two tenants may run at the same time on two hardware threads on the same core: but you could have a viable burstable instance with time-slicing alone.</div><br/><div id="37056559" class="c"><input type="checkbox" id="c-37056559" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054531">parent</a><span>|</span><a href="#37054435">next</a><span>|</span><label class="collapse" for="c-37056559">[-]</label><label class="expand" for="c-37056559">[5 more]</label></div><br/><div class="children"><div class="content">Nevermind, AWS explicitly documents that all instance types, including burstable, never co-locate different tenants on the same physical core at the same time:<p><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-design-of-aws-nitro-system&#x2F;the-ec2-approach-to-preventing-side-channels.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-desi...</a></div><br/><div id="37056752" class="c"><input type="checkbox" id="c-37056752" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37056559">parent</a><span>|</span><a href="#37054435">next</a><span>|</span><label class="collapse" for="c-37056752">[-]</label><label class="expand" for="c-37056752">[4 more]</label></div><br/><div class="children"><div class="content">It only seems to document that there&#x27;s group scheduling for SMT cores. But that doesn&#x27;t prevent issues due to switching between customers on the same physical core, no?<p>&quot;It is possible, however, for two burstable performance EC2 instances to run sequentially (not simultaneously) on the same core. It is also possible for physical memory pages to be reused, remapped, and swapped in and out as virtual memory pages. However, even burstable instances never share the same core at the same time, and virtual memory pages are never shared across instances. &quot;<p>I only started reading the paper - so I very well might be wrong here - but it doesn&#x27;t look to me like you need victim&#x2F;attacker to be scheduled simultaneously on two SMT threads, but that a single core sequentially executing victim &#x2F; attacker code would be vulnerable. It&#x27;s possible that the cross-customer &quot;context switch&quot; is larger than the the vulnerable window, but I&#x27;d not want to bet on it.</div><br/><div id="37057117" class="c"><input type="checkbox" id="c-37057117" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37056752">parent</a><span>|</span><a href="#37054435">next</a><span>|</span><label class="collapse" for="c-37057117">[-]</label><label class="expand" for="c-37057117">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But that doesn&#x27;t prevent issues due to switching between customers on the same physical core, no?<p>Yes they are explicit that customers may be time-shared on a physical core (&quot;burstable&quot; instances don&#x27;t really make sense without that). Most of these attacks aren&#x27;t known to be possible in that scenario and in any case the mitigations are much easier since flushing sensitive state at group scheduling boundaries is much less costly than permanent dynamic changes to how concurrent SMT threads interact.</div><br/><div id="37057269" class="c"><input type="checkbox" id="c-37057269" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37057117">parent</a><span>|</span><a href="#37058161">next</a><span>|</span><label class="collapse" for="c-37057269">[-]</label><label class="expand" for="c-37057269">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s certainly easier to mitigate at a boundary that&#x27;s already as costly as switching between VMs.<p>The paper documents that disabling SMT does <i>not</i> entirely mitigate the problem (In 9.1). They briefly mention trying instructions to avoid the microarchitectural leaks, but don&#x27;t go into more detail than mentioning verw isn&#x27;t sufficient.<p>They state that a switch to&#x2F;from SGX, with SMT disabled, doesn&#x27;t prevent the attacks. See 8.1. That&#x27;s not the same as a cross-vm switch, but it&#x27;s certainly interesting that the attempts at flushing microarchitectural state when exiting SGX don&#x27;t provide protection.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37054435" class="c"><input type="checkbox" id="c-37054435" checked=""/><div class="controls bullet"><span class="by">pwarner</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37054413">prev</a><span>|</span><a href="#37054271">next</a><span>|</span><label class="collapse" for="c-37054435">[-]</label><label class="expand" for="c-37054435">[2 more]</label></div><br/><div class="children"><div class="content">I think most if not all cloud VMs dedicate a core to you.
Well, there are some that share like the T series on AWS and I think other clouds have similar, but my bet is they can put in an extra &quot;flush&quot; between users to prevent cross tenant leakage.<p>Of course cross process leakage for a single tenant is an issue, in cloud or on prem, and folks will have to decide how much they trust the processes on their machine to not become evil...</div><br/></div></div><div id="37054271" class="c"><input type="checkbox" id="c-37054271" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37054435">prev</a><span>|</span><a href="#37054377">next</a><span>|</span><label class="collapse" for="c-37054271">[-]</label><label class="expand" for="c-37054271">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Claiming that it affects all users on the internet seems like a massive over-exaggeration, as he hasn&#x27;t demonstrated any kind of browser based exploit and even if such a thing did exist<p>He&#x27;s saying it likely affects &quot;everyone on the Internet&quot; because most servers are vulnerable.</div><br/><div id="37054771" class="c"><input type="checkbox" id="c-37054771" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054271">parent</a><span>|</span><a href="#37058206">next</a><span>|</span><label class="collapse" for="c-37054771">[-]</label><label class="expand" for="c-37054771">[1 more]</label></div><br/><div class="children"><div class="content">Most servers being vulnerable to a local attack is generally pretty boring news.</div><br/></div></div></div></div><div id="37054377" class="c"><input type="checkbox" id="c-37054377" checked=""/><div class="controls bullet"><span class="by">amarshall</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37054271">prev</a><span>|</span><a href="#37054498">next</a><span>|</span><label class="collapse" for="c-37054377">[-]</label><label class="expand" for="c-37054377">[2 more]</label></div><br/><div class="children"><div class="content">&gt; same physical core…between hyperthreads<p>These are not the same thing. Afaik, most “vCPU” are hyperthreads, not physical cores.<p>&gt; I thought most had changed their schedulers years ago so you can&#x27;t get cross-domain leaks between hyperthreads anymore<p>It would be great to have a source on this.</div><br/><div id="37054462" class="c"><input type="checkbox" id="c-37054462" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#37053352">root</a><span>|</span><a href="#37054377">parent</a><span>|</span><a href="#37054498">next</a><span>|</span><label class="collapse" for="c-37054462">[-]</label><label class="expand" for="c-37054462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These are not the same thing. Afaik, most “vCPU” are hyperthreads, not physical cores.<p>OP didn&#x27;t say otherwise. They are saying that public clouds do not let work from different tenants run on the <i>same</i> physical core (on <i>different</i> hyperthreads) <i>at the same time</i>.<p>This doesn&#x27;t prevent you from selling 1 hyperthread as 1 vCPU, it just means there are some scheduling restrictions and your smallest instance type will probably have 2 vCPUs if you have SMT-2 hardware (and that&#x27;s exactly what you see on AWS outside of the burstable instance types).</div><br/></div></div></div></div><div id="37054498" class="c"><input type="checkbox" id="c-37054498" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37053352">parent</a><span>|</span><a href="#37054377">prev</a><span>|</span><a href="#37053357">next</a><span>|</span><label class="collapse" for="c-37054498">[-]</label><label class="expand" for="c-37054498">[2 more]</label></div><br/><div class="children"><div class="content">Does Digital Ocean count as a major cloud player?</div><br/></div></div></div></div><div id="37053357" class="c"><input type="checkbox" id="c-37053357" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#37053352">prev</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37053357">[-]</label><label class="expand" for="c-37053357">[67 more]</label></div><br/><div class="children"><div class="content">Once again it seems clear that running code from two security domains on the same physical processor cores is just not possible to get right, and we should probably just stop doing it.<p>There are really only two common cases for this anyway. VMs and JavaScript.<p>For VMs we just need to give up on it. Dedicate specific cores to specific VMs or at least customers.<p>For JavaScript it’s a bit harder.<p>Either way, we need to not be giving up performance for the the normal case.</div><br/><div id="37053398" class="c"><input type="checkbox" id="c-37053398" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37059568">next</a><span>|</span><label class="collapse" for="c-37053398">[-]</label><label class="expand" for="c-37053398">[25 more]</label></div><br/><div class="children"><div class="content">&gt; For JavaScript it’s a bit harder.<p>&quot;We should probably just stop doing it&quot; works for me.</div><br/><div id="37053659" class="c"><input type="checkbox" id="c-37053659" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053398">parent</a><span>|</span><a href="#37059568">next</a><span>|</span><label class="collapse" for="c-37053659">[-]</label><label class="expand" for="c-37053659">[24 more]</label></div><br/><div class="children"><div class="content">Agreed. Browsers are now nothing but an application platform of APIs (<a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API</a>). For some reason they still retain the vestigial HTML, CSS and JS, but really all you need is bytecode that calls an ABI, and a widget toolkit that talks to a rendering API. Then we can finally ship apps to users without the shackles of how a browser wants to interpret and render some markup.<p>The idea of security &quot;sandboxes&quot; is quaint, but have been defeated pretty much since their inception. And the only reason we have &quot;frontend developers&quot; rather than just &quot;developers&quot; is HTML&#x2F;CSS&#x2F;JS&#x2F;DOM&#x2F;etc is a byzantine relic we refuse to let go of. Just let us deliver regular-old apps to users and control how they&#x27;re displayed in regular programming languages. Let users can find any app in any online marketplace based on open standards.</div><br/><div id="37057655" class="c"><input type="checkbox" id="c-37057655" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053659">parent</a><span>|</span><a href="#37057329">next</a><span>|</span><label class="collapse" for="c-37057655">[-]</label><label class="expand" for="c-37057655">[11 more]</label></div><br/><div class="children"><div class="content">HTML&#x2F;CSS is one of the easiest way to develop GUIs, one of the most visually flexible, and one of very few things this side of ncurses that runs everywhere.  Actually, without hacks, there are probably more end user devices with a browser than a command line.<p>It&#x27;s also highly standardized.  Regular programming languages have dozens of GUI toolkits, or at least one per platform.<p>I&#x27;d rather we go the other way, and build the browser into the OS, so that desktop apps just serve a perfectly standard web server, with an API to launch a special OS client with slightly more native integration(Toolbar icons, closing the process when the browser closes, etc), to make native app dev easier and hopefully more popular.<p>Security sandboxes mostly work.  People aren&#x27;t constantly getting viruses from clicking the wrong link, at least not quite as much.  They&#x27;re not perfect, but they&#x27;re better than having to completely trust 100 different sites unsandboxed, and they can be improved.   I&#x27;d rather have crappy security than no security at all.</div><br/><div id="37057774" class="c"><input type="checkbox" id="c-37057774" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057655">parent</a><span>|</span><a href="#37058561">next</a><span>|</span><label class="collapse" for="c-37057774">[-]</label><label class="expand" for="c-37057774">[8 more]</label></div><br/><div class="children"><div class="content">If by &quot;highly standardized&quot; you mean &quot;you don&#x27;t get a choice in what you can do or how it works&quot;, I agree.<p>Native mobile apps thrive despite this magical web browser working everywhere, because the web browser simply doesn&#x27;t do what native apps do. You may enjoy that, but a million businesses and billions of users out there don&#x27;t agree, because they use native apps. There were 255 billion native mobile app downloads in 2022, generating billions in revenue. That&#x27;s not a mistake or accident; that&#x27;s a market filling a need.<p>If we really want an application platform that works everywhere, then let&#x27;s stop dicking around with these stupid document hypertext viewers and build a <i>real</i> app platform that works everywhere.</div><br/><div id="37058621" class="c"><input type="checkbox" id="c-37058621" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057774">parent</a><span>|</span><a href="#37057862">next</a><span>|</span><label class="collapse" for="c-37058621">[-]</label><label class="expand" for="c-37058621">[1 more]</label></div><br/><div class="children"><div class="content">There are probably more website visits than that.  People download games and bank apps and things like that, stuff they expect to use frequently, want fast access or offline ability, of they need hardware access.<p>There are still tons of things that don&#x27;t need an app.  Things that are inherently online and not accessed frequently work fine as sites.<p>The web doesn&#x27;t limit what you can do that much, it limits how you can do it, which I think is a good thing. Less to break (Android API levels have the same effect) with fewer original lines of code.  Less focus on clever and interesting code and more focus on UI and features (Although they try their best to reinvent the same js framework 1000 times).<p>A lot of the limitations are probably just Mozzilla hating anything that could be used for tracking, and not trusting users to manage permissions.  The trend has been pretty strongly towards making the web very close to native apps, with all kinds of APIs.<p>Native apps fill a use case very well, that the web does not. That doesn&#x27;t make the web obsolete.</div><br/></div></div><div id="37057862" class="c"><input type="checkbox" id="c-37057862" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057774">parent</a><span>|</span><a href="#37058621">prev</a><span>|</span><a href="#37057925">next</a><span>|</span><label class="collapse" for="c-37057862">[-]</label><label class="expand" for="c-37057862">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Native mobile apps thrive despite this magical web browser working everywhere<p>There’s also user behavior. Many users are conditioned to get software through the App Store. I’ve seen this be a driving factor for quite a few web native applications spinning up native dev teams and shipping native clients.<p>Many folks are surprised to see just how far you can push a browser app and how small the gap between web and browser has become for well built applications, including native-like things like Bluetooth, NFC, USB, etc. (see: <a href="https:&#x2F;&#x2F;youmightnotneedelectron.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;youmightnotneedelectron.com&#x2F;</a>)<p>Have hacked with quite a few devs&#x2F;companies that had a fully functioning offline capable web native application. The most requested feature they’d get? “I want to download it from the App Store.” (Usually in the form of “I can’t find your app in the App Store”)<p>I suspect this is why the PWA experience on mobile devices hasn’t been well paved and why some App Store policies call out “don’t just wrap a browser view in a native app” - they want to keep users coming in the front door of a marketplace where they collect a cut off the top of all transactions.</div><br/><div id="37058636" class="c"><input type="checkbox" id="c-37058636" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057862">parent</a><span>|</span><a href="#37057925">next</a><span>|</span><label class="collapse" for="c-37058636">[-]</label><label class="expand" for="c-37058636">[3 more]</label></div><br/><div class="children"><div class="content">We really need to standardize &quot;just wrapping a browser view&quot;.  Why are we shipping a whole browser when we could be shipping a zip file of HTML with some metadata, and maybe a few tiny native helper utilities?</div><br/><div id="37058923" class="c"><input type="checkbox" id="c-37058923" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37058636">parent</a><span>|</span><a href="#37058851">next</a><span>|</span><label class="collapse" for="c-37058923">[-]</label><label class="expand" for="c-37058923">[1 more]</label></div><br/><div class="children"><div class="content">This is standardized for many years and called PWA. There are ways to interact with native helper utilities as well (simplest is just run http server on localhost), but not for mobile apps.<p>For mobile apps you can use webview component which will use system browser. You don&#x27;t need to ship the entire browser (actually you can&#x27;t even do that on iOS).</div><br/></div></div><div id="37058851" class="c"><input type="checkbox" id="c-37058851" checked=""/><div class="controls bullet"><span class="by">asaddhamani</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37058636">parent</a><span>|</span><a href="#37058923">prev</a><span>|</span><a href="#37057925">next</a><span>|</span><label class="collapse" for="c-37058851">[-]</label><label class="expand" for="c-37058851">[1 more]</label></div><br/><div class="children"><div class="content">This is how PWAs work on smartphones. I recall coming across some electron alternatives that use the system webview and those are able to generate binaries hundreds of kilobytes in size. But you lose out on access to many of the modern APIs due to Safari there.</div><br/></div></div></div></div></div></div><div id="37057925" class="c"><input type="checkbox" id="c-37057925" checked=""/><div class="controls bullet"><span class="by">parasubvert</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057774">parent</a><span>|</span><a href="#37057862">prev</a><span>|</span><a href="#37058561">next</a><span>|</span><label class="collapse" for="c-37057925">[-]</label><label class="expand" for="c-37057925">[2 more]</label></div><br/><div class="children"><div class="content">You are delusional and terribly out of your depth if you think even a sizable minority has any interest in getting rid of hypertext and the web.   Networked native apps are useless without the web architecture as the glue to integrate between them.   It is highly likely that URIs, HTTP and hyperlinks will still be a foundational elements of our technology world in a hundred years.</div><br/><div id="37058672" class="c"><input type="checkbox" id="c-37058672" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057925">parent</a><span>|</span><a href="#37058561">next</a><span>|</span><label class="collapse" for="c-37058672">[-]</label><label class="expand" for="c-37058672">[1 more]</label></div><br/><div class="children"><div class="content">HTTP != HTML&#x2F;CSS. You are applying a [Strawman Argument]</div><br/></div></div></div></div></div></div><div id="37058561" class="c"><input type="checkbox" id="c-37058561" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37057655">parent</a><span>|</span><a href="#37057774">prev</a><span>|</span><a href="#37057329">next</a><span>|</span><label class="collapse" for="c-37058561">[-]</label><label class="expand" for="c-37058561">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d rather we go the other way, and build the browser into the OS<p>This didn&#x27;t work out that great with MSIE.</div><br/><div id="37059029" class="c"><input type="checkbox" id="c-37059029" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37058561">parent</a><span>|</span><a href="#37057329">next</a><span>|</span><label class="collapse" for="c-37059029">[-]</label><label class="expand" for="c-37059029">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d didn&#x27;t work for Firefox OS either, and I&#x27;m not exactly sure why.<p>But it seems to have worked great for years for Chromebooks!</div><br/></div></div></div></div></div></div><div id="37057329" class="c"><input type="checkbox" id="c-37057329" checked=""/><div class="controls bullet"><span class="by">istjohn</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053659">parent</a><span>|</span><a href="#37057655">prev</a><span>|</span><a href="#37053861">next</a><span>|</span><label class="collapse" for="c-37057329">[-]</label><label class="expand" for="c-37057329">[1 more]</label></div><br/><div class="children"><div class="content">The web started as a graph of hyperlinked documents, and that use case hasn&#x27;t gone away. SPA&#x27;s aren&#x27;t the internet.</div><br/></div></div><div id="37053861" class="c"><input type="checkbox" id="c-37053861" checked=""/><div class="controls bullet"><span class="by">sidewndr46</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053659">parent</a><span>|</span><a href="#37057329">prev</a><span>|</span><a href="#37054508">next</a><span>|</span><label class="collapse" for="c-37053861">[-]</label><label class="expand" for="c-37053861">[10 more]</label></div><br/><div class="children"><div class="content">If someone created a way for WASM to talk to an SDL equivalent, it&#x27;d probably end use of HTML &amp; CSS</div><br/><div id="37054454" class="c"><input type="checkbox" id="c-37054454" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37054376">next</a><span>|</span><label class="collapse" for="c-37054454">[-]</label><label class="expand" for="c-37054454">[3 more]</label></div><br/><div class="children"><div class="content">If so, all people relying on (often limited even with html that contains text) accessibility features will have to sit in a corner and cry.</div><br/><div id="37055373" class="c"><input type="checkbox" id="c-37055373" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054454">parent</a><span>|</span><a href="#37054376">next</a><span>|</span><label class="collapse" for="c-37055373">[-]</label><label class="expand" for="c-37055373">[2 more]</label></div><br/><div class="children"><div class="content">I think that should be addressable.</div><br/><div id="37057489" class="c"><input type="checkbox" id="c-37057489" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055373">parent</a><span>|</span><a href="#37054376">next</a><span>|</span><label class="collapse" for="c-37057489">[-]</label><label class="expand" for="c-37057489">[1 more]</label></div><br/><div class="children"><div class="content">Why do I get the feeling some company will address the issue by offering them a comfy chair and a free box of tissues?</div><br/></div></div></div></div></div></div><div id="37054376" class="c"><input type="checkbox" id="c-37054376" checked=""/><div class="controls bullet"><span class="by">throwaway12245</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37054454">prev</a><span>|</span><a href="#37057695">next</a><span>|</span><label class="collapse" for="c-37054376">[-]</label><label class="expand" for="c-37054376">[1 more]</label></div><br/><div class="children"><div class="content">WASM has support for SDL for a long time: <a href="https:&#x2F;&#x2F;www.jamesfmackenzie.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;webassembly-graphics-with-sdl&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jamesfmackenzie.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;webassembly-graph...</a></div><br/></div></div><div id="37057695" class="c"><input type="checkbox" id="c-37057695" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37054376">prev</a><span>|</span><a href="#37054641">next</a><span>|</span><label class="collapse" for="c-37057695">[-]</label><label class="expand" for="c-37057695">[1 more]</label></div><br/><div class="children"><div class="content">That sounds awful. People would be jamming entire 10MB toolkits into WASM to do things that HTML could do, and performance would probably suffer.<p>HTML is declarative.  The machine understands it.  I like things machines can understand and optimize.  Things that you can write automated tools to work with because it&#x27;s not a full turing machine.   If you want to make a screen reader, you can.  If you want to reflow for mobile in a better way, you can, because you know what&#x27;s text and what&#x27;s an image.<p>Just giving people a programming environment and the ability to draw some pixels, the browser has no idea what the intent is. There&#x27;s nothing to optimize unless the individual sites do, and I doubt they have Google and Mozilla&#x27;s budget.<p>We already have too many unnecessary powerful imperative systems out there.</div><br/></div></div><div id="37054641" class="c"><input type="checkbox" id="c-37054641" checked=""/><div class="controls bullet"><span class="by">t0astbread</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37057695">prev</a><span>|</span><a href="#37055362">next</a><span>|</span><label class="collapse" for="c-37054641">[-]</label><label class="expand" for="c-37054641">[1 more]</label></div><br/><div class="children"><div class="content">If tri-state logic becomes viable it&#x27;s game over for binary!</div><br/></div></div><div id="37055362" class="c"><input type="checkbox" id="c-37055362" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37054641">prev</a><span>|</span><a href="#37054320">next</a><span>|</span><label class="collapse" for="c-37055362">[-]</label><label class="expand" for="c-37055362">[2 more]</label></div><br/><div class="children"><div class="content">IF GTK&#x2F;Qt etc can render to canvas using WebGPU while compiled to assembly, I think game is almost over than too IF there&#x27;s a way to lazy load application modules.<p>Think Autodesk products. Certain parts (wasm modules) only load when you hover over a menu while overall app loads within milliseconds because it just has the main window and such.</div><br/><div id="37058005" class="c"><input type="checkbox" id="c-37058005" checked=""/><div class="controls bullet"><span class="by">slondr</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055362">parent</a><span>|</span><a href="#37054320">next</a><span>|</span><label class="collapse" for="c-37058005">[-]</label><label class="expand" for="c-37058005">[1 more]</label></div><br/><div class="children"><div class="content">This has been possible for years. I actually got in the habit of porting my qt projects to the web target because they ran better than native compiled on some of my older machines.</div><br/></div></div></div></div><div id="37054320" class="c"><input type="checkbox" id="c-37054320" checked=""/><div class="controls bullet"><span class="by">yvdriess</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053861">parent</a><span>|</span><a href="#37055362">prev</a><span>|</span><a href="#37054508">next</a><span>|</span><label class="collapse" for="c-37054320">[-]</label><label class="expand" for="c-37054320">[1 more]</label></div><br/><div class="children"><div class="content">And so closing the great circle of UI framework technologies.</div><br/></div></div></div></div><div id="37054508" class="c"><input type="checkbox" id="c-37054508" checked=""/><div class="controls bullet"><span class="by">xigency</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053659">parent</a><span>|</span><a href="#37053861">prev</a><span>|</span><a href="#37059568">next</a><span>|</span><label class="collapse" for="c-37054508">[-]</label><label class="expand" for="c-37054508">[1 more]</label></div><br/><div class="children"><div class="content">I do think there’s never been a better time to reinvent the web, including basic technologies like HTML and JavaScript.<p>For example, picking up more elements of semantic web and distributed systems and leveraging interconnected devices.</div><br/></div></div></div></div></div></div><div id="37059568" class="c"><input type="checkbox" id="c-37059568" checked=""/><div class="controls bullet"><span class="by">kristjank</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37053398">prev</a><span>|</span><a href="#37055979">next</a><span>|</span><label class="collapse" for="c-37059568">[-]</label><label class="expand" for="c-37059568">[1 more]</label></div><br/><div class="children"><div class="content">Do you really think that giving up on getting things done right is the way to progress computing? While AMD has it&#x27;s own spectrum of problems and not-quite-there security features, most of their vulnyerabilities have been fixed in microcode shortly after disclosure.<p>We as an industry should stop excusing chipmakers from doing their jobs and reject broken products. It&#x27;s brand loyalty all over again, like when Apple does something retarded like losing the headphone jack and the whole industry follows, breaking years of interoperability.<p>When the products&#x2F;services we buy break, we should demand better, not lower our expectations.</div><br/></div></div><div id="37055979" class="c"><input type="checkbox" id="c-37055979" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37059568">prev</a><span>|</span><a href="#37055082">next</a><span>|</span><label class="collapse" for="c-37055979">[-]</label><label class="expand" for="c-37055979">[3 more]</label></div><br/><div class="children"><div class="content">There’s a marketing opportunity here to put multi-core back in the spotlight. Most workloads have reached the point of diminishing returns for adding more cores to a CPU, but if it turns out we need more cores just so we can run more concurrent processes (or browser tabs) securely, then here come the 128-core laptop chips…</div><br/><div id="37059909" class="c"><input type="checkbox" id="c-37059909" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055979">parent</a><span>|</span><a href="#37058987">next</a><span>|</span><label class="collapse" for="c-37059909">[-]</label><label class="expand" for="c-37059909">[1 more]</label></div><br/><div class="children"><div class="content">From a user’s perspective I often think that applications which run multiple processes, demand multiple threads and large chunks of memory are too entitled.<p>I know it’s a (not even) half baked thought. But there’s something to that. We never really think of “how many resources is this application allowed to demand?”<p>Software would be orders of magnitudes faster if there was some standard, sensible way of giving applications fixed resource buckets.</div><br/></div></div><div id="37058987" class="c"><input type="checkbox" id="c-37058987" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055979">parent</a><span>|</span><a href="#37059909">prev</a><span>|</span><a href="#37055082">next</a><span>|</span><label class="collapse" for="c-37058987">[-]</label><label class="expand" for="c-37058987">[1 more]</label></div><br/><div class="children"><div class="content">Intel playing 4D chess to sell more new hardware</div><br/></div></div></div></div><div id="37055082" class="c"><input type="checkbox" id="c-37055082" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37055979">prev</a><span>|</span><a href="#37054059">next</a><span>|</span><label class="collapse" for="c-37055082">[-]</label><label class="expand" for="c-37055082">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Once again it seems clear that running code from two security domains on the same physical processor cores is just not possible to get right, and we should probably just stop doing it.</i><p>Yes. This has had its heyday: the era of the time-shared systems, from the 1960&#x27;s, right into the 1990&#x27;s (Unix systems with multiple users having &quot;shell accounts&quot;, at universities and ISP&#x27;s and such). These CPU attacks show us that secure time-shared systems where users run arbitrary machine code is no longer feasible.<p>There will still be time sharing where users trust each other, like workers on the same projects accessing a build machine and whatnot.</div><br/></div></div><div id="37054059" class="c"><input type="checkbox" id="c-37054059" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37055082">prev</a><span>|</span><a href="#37055313">next</a><span>|</span><label class="collapse" for="c-37054059">[-]</label><label class="expand" for="c-37054059">[1 more]</label></div><br/><div class="children"><div class="content">It is sort of like the second law of thermodynamics (before statistical mechanics came around and cleared things up): sure, maybe not well founded in some analytical or philosophical sense, but experimentally bulletproof to the point where anyone who tries to sell you otherwise would be regarded very suspiciously. The idea that any two programs running on a computer can be prevented from snooping on each other.</div><br/></div></div><div id="37055313" class="c"><input type="checkbox" id="c-37055313" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37054059">prev</a><span>|</span><a href="#37056109">next</a><span>|</span><label class="collapse" for="c-37055313">[-]</label><label class="expand" for="c-37055313">[4 more]</label></div><br/><div class="children"><div class="content">Once you &quot;dedicate cores to specific VMs&quot; you will find that chip designers can also screw that up, just like they can screw up protection within a core. So you might as well proclaim that &quot;impossible to get right&quot; preemptively.</div><br/><div id="37056380" class="c"><input type="checkbox" id="c-37056380" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055313">parent</a><span>|</span><a href="#37056109">next</a><span>|</span><label class="collapse" for="c-37056380">[-]</label><label class="expand" for="c-37056380">[3 more]</label></div><br/><div class="children"><div class="content">They said physical processor. I took this to mean chip. Of course you can&#x27;t trust chips on the same mother board (there could be a bug where they can read the same memory), so you need a network boundary. So different rack on the server, for each [boundary, however you define that...]</div><br/><div id="37057752" class="c"><input type="checkbox" id="c-37057752" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37056380">parent</a><span>|</span><a href="#37057634">next</a><span>|</span><label class="collapse" for="c-37057752">[-]</label><label class="expand" for="c-37057752">[1 more]</label></div><br/><div class="children"><div class="content">Regarding VM&#x2F;core&#x2F;chip&#x2F;motherboard boundaries ...<p>A number of vexing CPU security vulnerabilities have resulted from a general class of optimizations that share cache resources (memory, TLBs, branch prediction tables, etc.) across different domains, which enables cross-domain attacks.<p>There is a potential for vulnerabilities even when the domains are separated by a network boundary ... if those domains view the world through some shared cache at the network layer.</div><br/></div></div><div id="37057634" class="c"><input type="checkbox" id="c-37057634" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37056380">parent</a><span>|</span><a href="#37057752">prev</a><span>|</span><a href="#37056109">next</a><span>|</span><label class="collapse" for="c-37057634">[-]</label><label class="expand" for="c-37057634">[1 more]</label></div><br/><div class="children"><div class="content">They said physical processor <i>core</i>, and elsewhere just <i>core</i>.  That does not mean chip.</div><br/></div></div></div></div></div></div><div id="37056109" class="c"><input type="checkbox" id="c-37056109" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37055313">prev</a><span>|</span><a href="#37053517">next</a><span>|</span><label class="collapse" for="c-37056109">[-]</label><label class="expand" for="c-37056109">[1 more]</label></div><br/><div class="children"><div class="content">This seems like a job for Arm or RISC-V or ???<p>Sacrifice IPC&#x2F;core to reduce gates per core, stuff more cores into a square centimeter, pin processes to cores or groups of cores, keep thread preemption cheap, but let thread migration take as long as it takes.<p>Arm already has asymmetric multiprocessing, which I feel like is halfway there. Or maybe a third. Fifteen years ago asynchrony primitives weren’t what they are today. I think there’s more flexibility to design a core around current or emerging primitives instead of the old ways.  And then there are kernel primitives like io_uring meant to reduce system call overhead, amortizing over multiple calls. If you split the difference, you could afford to allow individual calls to get several times more expensive, while juggling five or ten at once for the cost of two.</div><br/></div></div><div id="37053517" class="c"><input type="checkbox" id="c-37053517" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37056109">prev</a><span>|</span><a href="#37053994">next</a><span>|</span><label class="collapse" for="c-37053517">[-]</label><label class="expand" for="c-37053517">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wondered if we can&#x27;t give a dedicated core to the browser.  Of course, then web pages can steal from other web pages.  Maybe task switching needs to erect much higher barriers between security contexts, a complete flush or so?</div><br/><div id="37053638" class="c"><input type="checkbox" id="c-37053638" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053517">parent</a><span>|</span><a href="#37056391">next</a><span>|</span><label class="collapse" for="c-37053638">[-]</label><label class="expand" for="c-37053638">[3 more]</label></div><br/><div class="children"><div class="content">I wish chips would come with a core devoted to running this kind of untrusted code; maybe they could take something like an old bonnell atom core, strip out the hyper threading, and run JavaScript on that.<p>If a script can’t run happily on a core like that, it should really be a program anyway, and I don’t want to run it.</div><br/><div id="37053755" class="c"><input type="checkbox" id="c-37053755" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053638">parent</a><span>|</span><a href="#37056391">next</a><span>|</span><label class="collapse" for="c-37053755">[-]</label><label class="expand" for="c-37053755">[2 more]</label></div><br/><div class="children"><div class="content">I’m not saying you’re wrong, but I have a hard time believing web developers would be capable of writing code efficient enough to share a single core. LinkedIn was slamming my CPU so much that I isolated it in a separate browser</div><br/><div id="37053844" class="c"><input type="checkbox" id="c-37053844" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053755">parent</a><span>|</span><a href="#37056391">next</a><span>|</span><label class="collapse" for="c-37053844">[-]</label><label class="expand" for="c-37053844">[1 more]</label></div><br/><div class="children"><div class="content">I think you are right, my wish involves living in a slightly different universe where the web has taken a slightly less silly direction of development.</div><br/></div></div></div></div></div></div><div id="37056391" class="c"><input type="checkbox" id="c-37056391" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053517">parent</a><span>|</span><a href="#37053638">prev</a><span>|</span><a href="#37053620">next</a><span>|</span><label class="collapse" for="c-37056391">[-]</label><label class="expand" for="c-37056391">[1 more]</label></div><br/><div class="children"><div class="content">You would need a dedicated core per <i>tab</i>.<p>Partitioning tabs according to trust would be ~fine, but laborious and error-prone.</div><br/></div></div><div id="37053620" class="c"><input type="checkbox" id="c-37053620" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053517">parent</a><span>|</span><a href="#37056391">prev</a><span>|</span><a href="#37053994">next</a><span>|</span><label class="collapse" for="c-37053620">[-]</label><label class="expand" for="c-37053620">[2 more]</label></div><br/><div class="children"><div class="content">It probably would be possible to add a new instruction that causes the processor to flush all state in exchange for sacrificing task switching speed. Of course it might still have bugs, but you could imagine that it would be easier to get right.<p>Of course, it’s not doing much for the billions of devices that exist.<p>I would hope that we could find a software solution that web browsers can implement so that devices can be patched.<p>Either way, I would want such a solution to not compromise performance in the case where code is running in the same security context.<p>This is what I don’t like about existing mitigations. It’s making computers slower in many contexts where they don’t need to be.</div><br/><div id="37055165" class="c"><input type="checkbox" id="c-37055165" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053620">parent</a><span>|</span><a href="#37053994">next</a><span>|</span><label class="collapse" for="c-37055165">[-]</label><label class="expand" for="c-37055165">[1 more]</label></div><br/><div class="children"><div class="content">Software can choose to invalidate all cache, fence access, and the like today. It may not be a single instruction but it&#x27;s not far off. Usually something like &quot;just don&#x27;t JIT 3rd party JS to native code&quot; is &quot;secure enough&quot; most don&#x27;t want to go down that route though. For cloud (reputable) providers just don&#x27;t allow more than 1 VM to be assigned to a core at the same time and flush everything between if they are time shared. The mitigations are the way to keep the most overall performance outside those who are most concerned with maximum security, so they are the most popular.</div><br/></div></div></div></div></div></div><div id="37053994" class="c"><input type="checkbox" id="c-37053994" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37053517">prev</a><span>|</span><a href="#37056558">next</a><span>|</span><label class="collapse" for="c-37053994">[-]</label><label class="expand" for="c-37053994">[2 more]</label></div><br/><div class="children"><div class="content">So one should never install software from more than one company on a computer?</div><br/><div id="37057690" class="c"><input type="checkbox" id="c-37057690" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053994">parent</a><span>|</span><a href="#37056558">next</a><span>|</span><label class="collapse" for="c-37057690">[-]</label><label class="expand" for="c-37057690">[1 more]</label></div><br/><div class="children"><div class="content">You install App X from Vendor Y on to vSystem Z.<p>Vector is found to get untrusted code C to run in the user area on Z via exploit in X that Y has not acknowledged, so researchers publish a CVE with an example.<p>C starts trying to read memory from threads shared on same vCPU, revealing db connection string used by X, the nonce and salt for hashing.<p>Attacker now has the keys to the entire kingdom.</div><br/></div></div></div></div><div id="37056558" class="c"><input type="checkbox" id="c-37056558" checked=""/><div class="controls bullet"><span class="by">accrual</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37053994">prev</a><span>|</span><a href="#37053956">next</a><span>|</span><label class="collapse" for="c-37056558">[-]</label><label class="expand" for="c-37056558">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Once again it seems clear that running code from two security domains on the same physical processor cores is just not possible to get right, and we should probably just stop doing it.<p>I believe this is why OpenBSD disabled SMT by default in June of 2018. [0]<p>It can still be enabled with a simple &#x27;sysctl&#x27;, though.<p>[0] <a href="https:&#x2F;&#x2F;www.mail-archive.com&#x2F;source-changes@openbsd.org&#x2F;msg99141.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mail-archive.com&#x2F;source-changes@openbsd.org&#x2F;msg9...</a></div><br/></div></div><div id="37053427" class="c"><input type="checkbox" id="c-37053427" checked=""/><div class="controls bullet"><span class="by">malfist</span><span>|</span><a href="#37053357">parent</a><span>|</span><a href="#37053956">prev</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37053427">[-]</label><label class="expand" for="c-37053427">[19 more]</label></div><br/><div class="children"><div class="content">This is an unreasonable position. Vulnerabilities can be fixed</div><br/><div id="37055379" class="c"><input type="checkbox" id="c-37055379" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053427">parent</a><span>|</span><a href="#37053634">next</a><span>|</span><label class="collapse" for="c-37055379">[-]</label><label class="expand" for="c-37055379">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is an unreasonable position. Vulnerabilities can be fixed<p>That&#x27;s a highly optimistic position, to the point of being almost wishful thinking.<p>The vulnerability being talked about today has been around since 2014 according to the report. Possibly being exploited for unknown number of years since. Sure, maybe we can workaround this one, now.<p>Other similar ones to be published years into the future are also there today being likely exploited as we speak.<p>Running untrusted code on the same silicon as sensitive code (data), is unlikely to ever actually be truly safe.</div><br/><div id="37056014" class="c"><input type="checkbox" id="c-37056014" checked=""/><div class="controls bullet"><span class="by">alerighi</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055379">parent</a><span>|</span><a href="#37053634">next</a><span>|</span><label class="collapse" for="c-37056014">[-]</label><label class="expand" for="c-37056014">[4 more]</label></div><br/><div class="children"><div class="content">The real problem here is the x86 architecture. We should stop using it. It&#x27;s too complex, it&#x27;s full of stuff made for backward compatibility purposes, it has too many instructions that may have unpredictable results, and for that exact reason it&#x27;s extremely difficult to get things right. Somewhere in the thousands of instructions that it has you will surely find a bug.<p>We should move forward. Apple did a great job with the M{1,2} processors. Not only they are fantastic in terms of performance and energy usage, but also (to this moment) they don&#x27;t seem to suffer from these issues. The reason is that the CPU is simpler, and a simpler thing is easy to design right in the first place.</div><br/><div id="37056783" class="c"><input type="checkbox" id="c-37056783" checked=""/><div class="controls bullet"><span class="by">pseudalopex</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37056014">parent</a><span>|</span><a href="#37058194">next</a><span>|</span><label class="collapse" for="c-37056783">[-]</label><label class="expand" for="c-37056783">[2 more]</label></div><br/><div class="children"><div class="content">Meltdown and Spectre affected ARM and POWER CPUs. Apple&#x27;s included. PACMAN affected M1. The real problem is speculative execution seemingly.</div><br/><div id="37057444" class="c"><input type="checkbox" id="c-37057444" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37056783">parent</a><span>|</span><a href="#37058194">next</a><span>|</span><label class="collapse" for="c-37057444">[-]</label><label class="expand" for="c-37057444">[1 more]</label></div><br/><div class="children"><div class="content">Performance sorta hinges on it.  It could be that the cheaper way the chipmakers deal with it is to phase out the 4core set and push the cores on a die higher, and to do that--incorporate an older core design into dedicated cores for untrusted code.<p>This would also require changes at the OS-makers to tag thread forks for trusted and untrusted behavior.<p>Essentially: instead of shutting down SMT for the entire machine, make the customer &quot;prove&quot; the code is safe for elevation or else it gets scheduled as non-SMT.</div><br/></div></div></div></div><div id="37058194" class="c"><input type="checkbox" id="c-37058194" checked=""/><div class="controls bullet"><span class="by">petergeoghegan</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37056014">parent</a><span>|</span><a href="#37056783">prev</a><span>|</span><a href="#37053634">next</a><span>|</span><label class="collapse" for="c-37058194">[-]</label><label class="expand" for="c-37058194">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The real problem here is the x86 architecture<p>Even if we could say for sure that x86 has been disproportionately affected by speculative execution bugs (which already seems dubious), that could easily be due to a kind of selection bias. Presumably security researchers as a group more or less focus on the most popular and relevant ISAs&#x2F;microarchitectures.</div><br/></div></div></div></div></div></div><div id="37053634" class="c"><input type="checkbox" id="c-37053634" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053427">parent</a><span>|</span><a href="#37055379">prev</a><span>|</span><a href="#37054917">next</a><span>|</span><label class="collapse" for="c-37053634">[-]</label><label class="expand" for="c-37053634">[1 more]</label></div><br/><div class="children"><div class="content">Vulnerabilities are like unreliable cars. It doesn&#x27;t matter so much if they can be fixed, it&#x27;s the very, very high opportunity cost of needing to be fixed, when you were busy doing something else of high value.<p>Responsible people tend to pick the small consequence now over the unknowable distribution of consequences later.</div><br/></div></div><div id="37054917" class="c"><input type="checkbox" id="c-37054917" checked=""/><div class="controls bullet"><span class="by">pseudalopex</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053427">parent</a><span>|</span><a href="#37053634">prev</a><span>|</span><a href="#37053473">next</a><span>|</span><label class="collapse" for="c-37054917">[-]</label><label class="expand" for="c-37054917">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Vulnerabilities can be fixed<p>Not always the damage.</div><br/></div></div><div id="37053473" class="c"><input type="checkbox" id="c-37053473" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053427">parent</a><span>|</span><a href="#37054917">prev</a><span>|</span><a href="#37053490">next</a><span>|</span><label class="collapse" for="c-37053473">[-]</label><label class="expand" for="c-37053473">[1 more]</label></div><br/><div class="children"><div class="content">You are assuming that white hats discover them early enough before black hats.</div><br/></div></div><div id="37053490" class="c"><input type="checkbox" id="c-37053490" checked=""/><div class="controls bullet"><span class="by">2OEH8eoCRo0</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053427">parent</a><span>|</span><a href="#37053473">prev</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37053490">[-]</label><label class="expand" for="c-37053490">[10 more]</label></div><br/><div class="children"><div class="content">The mitigation here can incur a whopping 50% performance penalty. At what point can customers return these CPUs for either being defective or sue for false advertising? If they can&#x27;t safely meet the target performance they shouldn&#x27;t be doing these tricks at all.</div><br/><div id="37054124" class="c"><input type="checkbox" id="c-37054124" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37053490">parent</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37054124">[-]</label><label class="expand" for="c-37054124">[9 more]</label></div><br/><div class="children"><div class="content">Did processor companies <i>ever advertise</i> that processors guaranteed certain security properties of the software they execute?<p>Aren&#x27;t system designers at fault for coming up with the idea of a context switch and <i>assuming</i> that we can trust a processor not to leak details across artificial software constructed boundaries?</div><br/><div id="37059460" class="c"><input type="checkbox" id="c-37059460" checked=""/><div class="controls bullet"><span class="by">autoexec</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054124">parent</a><span>|</span><a href="#37057760">next</a><span>|</span><label class="collapse" for="c-37059460">[-]</label><label class="expand" for="c-37059460">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did processor companies ever advertise that processors guaranteed certain security properties<p>It&#x27;s not the guaranteed security as much as the advertised speed that&#x27;s the issue. If they put out a chip which could only be used at half the advertised speed or else it would catch on fire, nobody would argue that they should be let off the hook because they didn&#x27;t guarantee that the chips were fireproof in their ads.<p>If the chips can&#x27;t perform at advertised speeds safely during typical use they&#x27;re not delivering what was advertised.</div><br/></div></div><div id="37057760" class="c"><input type="checkbox" id="c-37057760" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054124">parent</a><span>|</span><a href="#37059460">prev</a><span>|</span><a href="#37055519">next</a><span>|</span><label class="collapse" for="c-37057760">[-]</label><label class="expand" for="c-37057760">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Aren&#x27;t system designers at fault for coming up with the idea of a context switch<p>Context switching was in the Apollo 11 guidance computer
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xx7Lfh5SKUQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xx7Lfh5SKUQ</a><p>The problem is that cycle-speed boosts left the industry cic. 2012-or-so.  All the perf boost we get these days is by optimizing the instruction sequencing and multiprocessing.  This is why languages like Go popped up (making the advanced programming topic of multiprogramming an entry-level accomplishment) and you now see the &#x27;async&#x27; decorator plastered everywhere in C#, and so-on.<p>Keeping the security context intact and separated is a gargantuan task.<p>To me it makes more sense to add &quot;lousy cores&quot; to the die and force the operator to declare the launching threads are safe for SMT, else the job gets scheduled to the less-performing core where the pipelining is safer.   It delegates responsibility to the chip-gobbler, forces them to understand the tradeoff for performance, until some elegant solution is found for side channel attacks like this.</div><br/></div></div><div id="37055519" class="c"><input type="checkbox" id="c-37055519" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054124">parent</a><span>|</span><a href="#37057760">prev</a><span>|</span><a href="#37055284">next</a><span>|</span><label class="collapse" for="c-37055519">[-]</label><label class="expand" for="c-37055519">[1 more]</label></div><br/><div class="children"><div class="content">According to OP, SGX is also vulnerable. There has been quite some marketing around the supposed security properties of SGX, yes.</div><br/></div></div><div id="37055284" class="c"><input type="checkbox" id="c-37055284" checked=""/><div class="controls bullet"><span class="by">rvnx</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054124">parent</a><span>|</span><a href="#37055519">prev</a><span>|</span><a href="#37055698">next</a><span>|</span><label class="collapse" for="c-37055284">[-]</label><label class="expand" for="c-37055284">[3 more]</label></div><br/><div class="children"><div class="content">But wait, how is it even considered a processor bug ?<p>You write data inside the registers, yes, other processes can read these registers.<p>It always been like this, and is absolutely normal.<p>It&#x27;s the responsibility of the operating system to clear the registers if it is switching context.</div><br/><div id="37056037" class="c"><input type="checkbox" id="c-37056037" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055284">parent</a><span>|</span><a href="#37055731">prev</a><span>|</span><a href="#37055698">next</a><span>|</span><label class="collapse" for="c-37056037">[-]</label><label class="expand" for="c-37056037">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But wait, how is it even considered a processor bug ?<p>These side channel attacks allow an attacker to read registers from other processes before any context switching has occurred, or independently of any context switching (even if the OS has been written to correctly clear state).</div><br/></div></div></div></div><div id="37055698" class="c"><input type="checkbox" id="c-37055698" checked=""/><div class="controls bullet"><span class="by">IlliOnato</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37054124">parent</a><span>|</span><a href="#37055284">prev</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37055698">[-]</label><label class="expand" for="c-37055698">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I am sure the customers can sue, but would they win? I find it unlikely.</div><br/><div id="37057978" class="c"><input type="checkbox" id="c-37057978" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37053357">root</a><span>|</span><a href="#37055698">parent</a><span>|</span><a href="#37054341">next</a><span>|</span><label class="collapse" for="c-37057978">[-]</label><label class="expand" for="c-37057978">[1 more]</label></div><br/><div class="children"><div class="content">AMD has the same problem (Inception).   Predictive instruction pipelining makes timing and context separation harder.   Even if you are on s390x or M1 it&#x27;s not like you are safe either.   This is a whole field of study.<p>In my mind the better mitigation is to put control over trusted code back to the user and to do that you have to add less-performant cores onto the die and force the operator to elevate (or not) to SMT.<p>Right now it&#x27;s an all-or-nothing proposition for the whole board.   I would like to think that you can take your untrusted code and stick it on the less-performy cores with the safer instruction pipelining scheme so an actual physical barrier exists.<p>If that was in the chip architecture, then it&#x27;s up to OS vendors to surface it in a way that developers understand, and then down to the operator to decide upon configuration.<p>You are never going to get a perfect-solve from the chipmakers on this where the consumer has to do nothing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37054341" class="c"><input type="checkbox" id="c-37054341" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#37053357">prev</a><span>|</span><a href="#37055455">next</a><span>|</span><label class="collapse" for="c-37054341">[-]</label><label class="expand" for="c-37054341">[1 more]</label></div><br/><div class="children"><div class="content">Intel Security Advisory: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;software-security-guidance&#x2F;technical-documentation&#x2F;gather-data-sampling.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>Linux Kernel merge:
<a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id=64094e7e3118aff4b0be8ff713c242303e139834" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div><div id="37055455" class="c"><input type="checkbox" id="c-37055455" checked=""/><div class="controls bullet"><span class="by">zerocrates</span><span>|</span><a href="#37054341">prev</a><span>|</span><a href="#37056195">next</a><span>|</span><label class="collapse" for="c-37055455">[-]</label><label class="expand" for="c-37055455">[3 more]</label></div><br/><div class="children"><div class="content">Only up to 11th gen... it didn&#x27;t seem like this could have been disclosed to Intel soon enough for them to have fixed it for 12th gen, so had they just happened to fix it while fixing something else, or what?<p>Decided to look in the paper and &quot;Intel states that newer CPUs such as Alder Lake, Raptor Lake, and Sapphire Rapids are unaffected, although not a security consideration and seems just a side effect of a significantly modified architecture.&quot; So basically they just randomly fixed it, or at least made this particular exploit nonworkable.</div><br/><div id="37057905" class="c"><input type="checkbox" id="c-37057905" checked=""/><div class="controls bullet"><span class="by">broodbucket</span><span>|</span><a href="#37055455">parent</a><span>|</span><a href="#37056195">next</a><span>|</span><label class="collapse" for="c-37057905">[-]</label><label class="expand" for="c-37057905">[2 more]</label></div><br/><div class="children"><div class="content">Microarchitectural behaviour changes from generation to generation, and thus so do side effects.  Fixing things by accident (and also introducing new problems by accident) are relatively frequent occurrences</div><br/><div id="37058054" class="c"><input type="checkbox" id="c-37058054" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#37055455">root</a><span>|</span><a href="#37057905">parent</a><span>|</span><a href="#37056195">next</a><span>|</span><label class="collapse" for="c-37058054">[-]</label><label class="expand" for="c-37058054">[1 more]</label></div><br/><div class="children"><div class="content">Fix one big bug, get two small bugs...</div><br/></div></div></div></div></div></div><div id="37056195" class="c"><input type="checkbox" id="c-37056195" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37055455">prev</a><span>|</span><a href="#37052886">next</a><span>|</span><label class="collapse" for="c-37056195">[-]</label><label class="expand" for="c-37056195">[6 more]</label></div><br/><div class="children"><div class="content">See this LWN story: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;940783&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;940783&#x2F;</a><p>on Linux, any cpus that don&#x27;t have updated microcode will have AVX completely disabled as a mitigation for this issue. That&#x27;s rather harsh if you ask me and would be very noticeable. Now I&#x27;m interested in finding out if I can get updated microcode..</div><br/><div id="37058135" class="c"><input type="checkbox" id="c-37058135" checked=""/><div class="controls bullet"><span class="by">hansendc</span><span>|</span><a href="#37056195">parent</a><span>|</span><a href="#37057403">next</a><span>|</span><label class="collapse" for="c-37058135">[-]</label><label class="expand" for="c-37058135">[2 more]</label></div><br/><div class="children"><div class="content">The AVX disable is only when you use &quot;gather_data_sampling=force&quot;.  The default is to leave AVX alone and proclaim the system to be vulnerable.<p>From <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id=553a5c03e90a" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a> :<p>&gt; Specifying &quot;gather_data_sampling=force&quot; will use the microcode mitigation when 
&gt; available or disable AVX on affected systems where the microcode hasn&#x27;t been 
&gt; updated to include the mitigation.<p>Disclaimer: I work on Linux at Intel.  I probably wrote or tweaked the documentation and changelogs that are confusing folks.</div><br/><div id="37060193" class="c"><input type="checkbox" id="c-37060193" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37056195">root</a><span>|</span><a href="#37058135">parent</a><span>|</span><a href="#37057403">next</a><span>|</span><label class="collapse" for="c-37060193">[-]</label><label class="expand" for="c-37060193">[1 more]</label></div><br/><div class="children"><div class="content">Great, thanks for the clarification</div><br/></div></div></div></div><div id="37057403" class="c"><input type="checkbox" id="c-37057403" checked=""/><div class="controls bullet"><span class="by">Bu9818</span><span>|</span><a href="#37056195">parent</a><span>|</span><a href="#37058135">prev</a><span>|</span><a href="#37057321">next</a><span>|</span><label class="collapse" for="c-37057403">[-]</label><label class="expand" for="c-37057403">[2 more]</label></div><br/><div class="children"><div class="content">`[    0.000000] microcode: updated early: 0x27 -&gt; 0x28, date = 2019-11-12`<p>I&#x27;m on haswell. Is there a list of what CPUs get updated microcode? Sad.</div><br/><div id="37057788" class="c"><input type="checkbox" id="c-37057788" checked=""/><div class="controls bullet"><span class="by">starlevel003</span><span>|</span><a href="#37056195">root</a><span>|</span><a href="#37057403">parent</a><span>|</span><a href="#37057321">next</a><span>|</span><label class="collapse" for="c-37057788">[-]</label><label class="expand" for="c-37057788">[1 more]</label></div><br/><div class="children"><div class="content">haswell isn&#x27;t vulnerable, it only affects skylake or later</div><br/></div></div></div></div><div id="37057321" class="c"><input type="checkbox" id="c-37057321" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37056195">parent</a><span>|</span><a href="#37057403">prev</a><span>|</span><a href="#37052886">next</a><span>|</span><label class="collapse" for="c-37057321">[-]</label><label class="expand" for="c-37057321">[1 more]</label></div><br/><div class="children"><div class="content">Maybe that&#x27;s not the default? Not entirely clear from the text.</div><br/></div></div></div></div><div id="37052886" class="c"><input type="checkbox" id="c-37052886" checked=""/><div class="controls bullet"><span class="by">v8xi</span><span>|</span><a href="#37056195">prev</a><span>|</span><a href="#37055415">next</a><span>|</span><label class="collapse" for="c-37052886">[-]</label><label class="expand" for="c-37052886">[7 more]</label></div><br/><div class="children"><div class="content">From FAQ:  
[Q] How long have users been exposed to this vulnerability?  
[A] At least nine years. The affected processors have been around since 2014.<p>Amazing how these vulnerabilities sit around unnoticed for years and then it takes two weeks for someone to code up an exploit.</div><br/><div id="37052926" class="c"><input type="checkbox" id="c-37052926" checked=""/><div class="controls bullet"><span class="by">robotnikman</span><span>|</span><a href="#37052886">parent</a><span>|</span><a href="#37053198">next</a><span>|</span><label class="collapse" for="c-37052926">[-]</label><label class="expand" for="c-37052926">[2 more]</label></div><br/><div class="children"><div class="content">I have a feeling the time spent searching for the vulnerability in the first place was more than 2 weeks though.</div><br/><div id="37055084" class="c"><input type="checkbox" id="c-37055084" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#37052886">root</a><span>|</span><a href="#37052926">parent</a><span>|</span><a href="#37053198">next</a><span>|</span><label class="collapse" for="c-37055084">[-]</label><label class="expand" for="c-37055084">[1 more]</label></div><br/><div class="children"><div class="content">Those things come in waves. Once the first large CPU vulnerability was found then more followed soon. I think it&#x27;s obvious why this is so.</div><br/></div></div></div></div><div id="37053198" class="c"><input type="checkbox" id="c-37053198" checked=""/><div class="controls bullet"><span class="by">Liquix</span><span>|</span><a href="#37052886">parent</a><span>|</span><a href="#37052926">prev</a><span>|</span><a href="#37056384">next</a><span>|</span><label class="collapse" for="c-37053198">[-]</label><label class="expand" for="c-37053198">[3 more]</label></div><br/><div class="children"><div class="content">All a publication indicates is that a white&#x2F;grey hat researcher has discovered the vulnerability. There is no way to know if or how many times the same flaw has been exploited by less scrupulous parties in the interim.</div><br/><div id="37053637" class="c"><input type="checkbox" id="c-37053637" checked=""/><div class="controls bullet"><span class="by">mrob</span><span>|</span><a href="#37052886">root</a><span>|</span><a href="#37053198">parent</a><span>|</span><a href="#37053914">next</a><span>|</span><label class="collapse" for="c-37053637">[-]</label><label class="expand" for="c-37053637">[1 more]</label></div><br/><div class="children"><div class="content">And information leak exploits are less likely to be detected than arbitrary code execution. If somebody is exploiting a buffer overflow, they need to get it exactly right, or they&#x27;ll probably crash the process, which can be logged and noticed. The only sign of somebody attempting Downfall or similar attacks is increased CPU use, which has many benign causes.</div><br/></div></div><div id="37053914" class="c"><input type="checkbox" id="c-37053914" checked=""/><div class="controls bullet"><span class="by">ibejoeb</span><span>|</span><a href="#37052886">root</a><span>|</span><a href="#37053198">parent</a><span>|</span><a href="#37053637">prev</a><span>|</span><a href="#37056384">next</a><span>|</span><label class="collapse" for="c-37053914">[-]</label><label class="expand" for="c-37053914">[1 more]</label></div><br/><div class="children"><div class="content">Since it is in a class of other well known vulnerabilities, I&#x27;m going to assume that there has been quite a bit of active research by state-operated and state-sponsored labs. I think it&#x27;s more likely than not that this has been exploited.</div><br/></div></div></div></div><div id="37056384" class="c"><input type="checkbox" id="c-37056384" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#37052886">parent</a><span>|</span><a href="#37053198">prev</a><span>|</span><a href="#37055415">next</a><span>|</span><label class="collapse" for="c-37056384">[-]</label><label class="expand" for="c-37056384">[1 more]</label></div><br/><div class="children"><div class="content">Likely work based off of previous exploits.</div><br/></div></div></div></div><div id="37055415" class="c"><input type="checkbox" id="c-37055415" checked=""/><div class="controls bullet"><span class="by">bironran</span><span>|</span><a href="#37052886">prev</a><span>|</span><a href="#37052674">next</a><span>|</span><label class="collapse" for="c-37055415">[-]</label><label class="expand" for="c-37055415">[3 more]</label></div><br/><div class="children"><div class="content">Worth to note that GCP has this patched (<a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;support&#x2F;bulletins#gcp-2023-024" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;support&#x2F;bulletins#gcp-2023-024</a>)</div><br/><div id="37056225" class="c"><input type="checkbox" id="c-37056225" checked=""/><div class="controls bullet"><span class="by">palcu</span><span>|</span><a href="#37055415">parent</a><span>|</span><a href="#37058778">next</a><span>|</span><label class="collapse" for="c-37056225">[-]</label><label class="expand" for="c-37056225">[1 more]</label></div><br/><div class="children"><div class="content">My adjacent teams in London who work in SRE on Google Cloud (GCE) got some well deserved doughnuts today for rolling out the patches on time.</div><br/></div></div><div id="37058778" class="c"><input type="checkbox" id="c-37058778" checked=""/><div class="controls bullet"><span class="by">zgluck</span><span>|</span><a href="#37055415">parent</a><span>|</span><a href="#37056225">prev</a><span>|</span><a href="#37052674">next</a><span>|</span><label class="collapse" for="c-37058778">[-]</label><label class="expand" for="c-37058778">[1 more]</label></div><br/><div class="children"><div class="content">Corresponding AWS notice:<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;security&#x2F;security-bulletins&#x2F;AWS-2023-007&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;security&#x2F;security-bulletins&#x2F;AWS-2023-...</a><p><i>AWS customers’ data and instances are not affected by this issue, and no customer action is required. AWS has designed and implemented its infrastructure with protections against this class of issues. Amazon EC2 instances, including Lambda, Fargate, and other AWS-managed compute and container services protect customer data against GDS through microcode and software based mitigations.</i></div><br/></div></div></div></div><div id="37052674" class="c"><input type="checkbox" id="c-37052674" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#37055415">prev</a><span>|</span><a href="#37058973">next</a><span>|</span><label class="collapse" for="c-37052674">[-]</label><label class="expand" for="c-37052674">[11 more]</label></div><br/><div class="children"><div class="content">This is a huge performance hit - up to 50% it is claimed!
70% of modern intel processors are affected apparently as well.</div><br/><div id="37053602" class="c"><input type="checkbox" id="c-37053602" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#37052674">parent</a><span>|</span><a href="#37053500">next</a><span>|</span><label class="collapse" for="c-37053602">[-]</label><label class="expand" for="c-37053602">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Red Hat’s internal performance testing of a worst-case microbenchmark showed a significant slowdown. However, more realistic applications that utilize vector gathering showed only low single-digit percentage slowdowns.&quot;<p><a href="https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7027704" rel="nofollow noreferrer">https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7027704</a><p>Performance Impact<p>The performance impact of the microcode mitigation is limited to applications that use the gather instructions provided by Intel Advanced Vector Extensions (AVX2 and AVX-512) and the CLWB instruction. Actual performance impact will depend on how heavily an application uses those instructions. Red Hat’s internal performance testing of a worst-case microbenchmark showed a significant slowdown. However, more realistic applications that utilize vector gathering showed only low single-digit percentage slowdowns.<p>If the user decides to disable the mitigation after doing a thorough risk analysis (for example the system isn’t multi-tenant and doesn’t execute untrusted code), the user can disable the mitigation. After applying the microcode and kernel updates, the user can disable the mitigation by adding gather_data_samping=off to the kernel command line.Alternatively, to disable all CPU speculative execution mitigations, including GDS, use mitigations=off.</div><br/></div></div><div id="37053500" class="c"><input type="checkbox" id="c-37053500" checked=""/><div class="controls bullet"><span class="by">ablated_maquis</span><span>|</span><a href="#37052674">parent</a><span>|</span><a href="#37053602">prev</a><span>|</span><a href="#37053006">next</a><span>|</span><label class="collapse" for="c-37053500">[-]</label><label class="expand" for="c-37053500">[2 more]</label></div><br/><div class="children"><div class="content">Is that 50% overhead for &quot;Gather&quot; instructions? If that is the case, then if 10% of instructions are &quot;gathers&quot; in your workload then that would be 5% overall.</div><br/><div id="37053506" class="c"><input type="checkbox" id="c-37053506" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37052674">root</a><span>|</span><a href="#37053500">parent</a><span>|</span><a href="#37053006">next</a><span>|</span><label class="collapse" for="c-37053506">[-]</label><label class="expand" for="c-37053506">[1 more]</label></div><br/><div class="children"><div class="content">Something like that, yeah.</div><br/></div></div></div></div><div id="37053006" class="c"><input type="checkbox" id="c-37053006" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#37052674">parent</a><span>|</span><a href="#37053500">prev</a><span>|</span><a href="#37053187">next</a><span>|</span><label class="collapse" for="c-37053006">[-]</label><label class="expand" for="c-37053006">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>some workloads</i> may experience up to 50% overhead<p>They word there are &quot;some
workloads&quot;, I suspect that performance hit is rare.</div><br/><div id="37054986" class="c"><input type="checkbox" id="c-37054986" checked=""/><div class="controls bullet"><span class="by">jgtrosh</span><span>|</span><a href="#37052674">root</a><span>|</span><a href="#37053006">parent</a><span>|</span><a href="#37053187">next</a><span>|</span><label class="collapse" for="c-37054986">[-]</label><label class="expand" for="c-37054986">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that HPC systems which run applications whose performance strongly depends on efficient data scatter gather will immediately disable the mitigation.</div><br/></div></div></div></div><div id="37053187" class="c"><input type="checkbox" id="c-37053187" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37052674">parent</a><span>|</span><a href="#37053006">prev</a><span>|</span><a href="#37054576">next</a><span>|</span><label class="collapse" for="c-37053187">[-]</label><label class="expand" for="c-37053187">[2 more]</label></div><br/><div class="children"><div class="content">Key context you elided: &quot;This depends on whether Gather is in the critical execution path of a program.&quot;</div><br/><div id="37053338" class="c"><input type="checkbox" id="c-37053338" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#37052674">root</a><span>|</span><a href="#37053187">parent</a><span>|</span><a href="#37054576">next</a><span>|</span><label class="collapse" for="c-37053338">[-]</label><label class="expand" for="c-37053338">[1 more]</label></div><br/><div class="children"><div class="content">Well yes. That is the up to part.</div><br/></div></div></div></div><div id="37054576" class="c"><input type="checkbox" id="c-37054576" checked=""/><div class="controls bullet"><span class="by">graton</span><span>|</span><a href="#37052674">parent</a><span>|</span><a href="#37053187">prev</a><span>|</span><a href="#37055369">next</a><span>|</span><label class="collapse" for="c-37054576">[-]</label><label class="expand" for="c-37054576">[2 more]</label></div><br/><div class="children"><div class="content">It is kind of like thinking that it is a huge sale at a store when they say &quot;Up to 70% off&quot;. And there are like two things in the whole store which are 70% off.<p>I am always suspicious of &quot;up to&quot; claims.</div><br/><div id="37055846" class="c"><input type="checkbox" id="c-37055846" checked=""/><div class="controls bullet"><span class="by">IlliOnato</span><span>|</span><a href="#37052674">root</a><span>|</span><a href="#37054576">parent</a><span>|</span><a href="#37055369">next</a><span>|</span><label class="collapse" for="c-37055846">[-]</label><label class="expand" for="c-37055846">[1 more]</label></div><br/><div class="children"><div class="content">I always translate such weasel words to their more straightforward equivalent.
&quot;Up to 70% off&quot; means for me &quot;Nothing in our store is discounted by more than 70%&quot; :-)</div><br/></div></div></div></div></div></div><div id="37058973" class="c"><input type="checkbox" id="c-37058973" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37052674">prev</a><span>|</span><a href="#37054499">next</a><span>|</span><label class="collapse" for="c-37058973">[-]</label><label class="expand" for="c-37058973">[1 more]</label></div><br/><div class="children"><div class="content">Speculative execution seems like a never-ending rabbit hole of vulnerabilities. Though I feel like most of them end up being in Intel chips for some reason</div><br/></div></div><div id="37054499" class="c"><input type="checkbox" id="c-37054499" checked=""/><div class="controls bullet"><span class="by">ngneer</span><span>|</span><a href="#37058973">prev</a><span>|</span><a href="#37055301">next</a><span>|</span><label class="collapse" for="c-37054499">[-]</label><label class="expand" for="c-37054499">[2 more]</label></div><br/><div class="children"><div class="content">I do not doubt the severity of the flaw, but most practical attacks end up being far more mundane. Consider SolarWinds, for example. No dazzling tricks needed, whatever gets the job done.</div><br/><div id="37058526" class="c"><input type="checkbox" id="c-37058526" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#37054499">parent</a><span>|</span><a href="#37055301">next</a><span>|</span><label class="collapse" for="c-37058526">[-]</label><label class="expand" for="c-37058526">[1 more]</label></div><br/><div class="children"><div class="content">Has there even be a documented practical attack in the wild?</div><br/></div></div></div></div><div id="37055301" class="c"><input type="checkbox" id="c-37055301" checked=""/><div class="controls bullet"><span class="by">ancris</span><span>|</span><a href="#37054499">prev</a><span>|</span><a href="#37057516">next</a><span>|</span><label class="collapse" for="c-37055301">[-]</label><label class="expand" for="c-37055301">[10 more]</label></div><br/><div class="children"><div class="content">At this rate, with all these vulnerabilities and mitigations, we&#x27;ll rollback CPU performance back at least 10 years.</div><br/><div id="37057393" class="c"><input type="checkbox" id="c-37057393" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#37055301">parent</a><span>|</span><a href="#37055804">next</a><span>|</span><label class="collapse" for="c-37057393">[-]</label><label class="expand" for="c-37057393">[5 more]</label></div><br/><div class="children"><div class="content">It seems to me like most don&#x27;t have a fundamental gut feel for what speculative execution actually is and the implications of &quot;not getting it&quot;. At some level we need to fight for performance. My operating systems are only getting slower and shittier. I cannot fathom my CPUs going backwards too. Security must take a back seat at <i>some</i> point. You can&#x27;t put bubble wrap and warning labels over everything or it becomes useless. The most dangerous tools are typically the most effective.<p>The CPUs are vulnerable because of the exact way in which they are being applied to a problem. Speculative execution is not inherently unsafe. Whatever future predicted memory prefetching shenanigans are going on in my CPU over here have absolutely <i>ZERO</i> impact on your CPU over there. <i>Certainly</i> someone could figure out a protocol&#x2F;system&#x2F;architecture that capitalizes on this notion that &quot;2 different CPUs are indeed different CPUs&quot;.<p>One can see how any perspective here still causes trouble for Amazon, Microsoft, et. al., but that was a business risk they signed up for the moment they intended to squeeze every last drop of subscriber revenue out of the hardware. Why should <i>everyone else on earth</i> have to suffer crappier performance by default because of the business&#x2F;software practices of a select few?</div><br/><div id="37057977" class="c"><input type="checkbox" id="c-37057977" checked=""/><div class="controls bullet"><span class="by">parasubvert</span><span>|</span><a href="#37055301">root</a><span>|</span><a href="#37057393">parent</a><span>|</span><a href="#37057914">next</a><span>|</span><label class="collapse" for="c-37057977">[-]</label><label class="expand" for="c-37057977">[1 more]</label></div><br/><div class="children"><div class="content">These vulnerabilities have a lot less to do with cloud providers, and a lot to do with networked computers in general.  It&#x27;s not unreasonable to expect this exploit to be done via web browser, as was demonstrated with prior speculative execution exploits.<p>Fundamentally, the only reason we need speculative execution is that we haven&#x27;t updated our software to be more concurrent (reflecting how chips have kept pace with Moore&#x27;s law for 15+ years), we still program as if we&#x27;re in the 1970s.<p>This may turn into a great opportunity to force a rebuild a lot of ancient code.<p>For more information: C is not a Low Level Language  <a href="https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=3212479" rel="nofollow noreferrer">https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=3212479</a></div><br/></div></div><div id="37057914" class="c"><input type="checkbox" id="c-37057914" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#37055301">root</a><span>|</span><a href="#37057393">parent</a><span>|</span><a href="#37057977">prev</a><span>|</span><a href="#37059010">next</a><span>|</span><label class="collapse" for="c-37057914">[-]</label><label class="expand" for="c-37057914">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; Why should everyone else on earth have to suffer crappier performance by default because of the business&#x2F;software practices of a select few?
</code></pre>
The author states in the article that they believe this may be exploitable from javascript in a browser. Just to hammer the point home, any web page could steal anything in memory on your computer. Spectre was also browser-exploitable, and was mitigated there partly by making access to high precision timers privileged. This is very much not a problem that only impacts cloud providers.</div><br/></div></div></div></div><div id="37055804" class="c"><input type="checkbox" id="c-37055804" checked=""/><div class="controls bullet"><span class="by">IlliOnato</span><span>|</span><a href="#37055301">parent</a><span>|</span><a href="#37057393">prev</a><span>|</span><a href="#37055387">next</a><span>|</span><label class="collapse" for="c-37055804">[-]</label><label class="expand" for="c-37055804">[3 more]</label></div><br/><div class="children"><div class="content">The only 100% reliable way is to turn off branch prediction completely, and yes, this would make the processors at least 2 times slower, perhaps more.<p>Too bad that apparently nothing came out of the Mill architecture. My limited understanding is that this architecture would not have such vulnerabilities.<p>Of course it&#x27;s possible it would have others :-) but being much simpler, at least conceptually, perhaps it would have less and easier to mitigate. Oh well.</div><br/><div id="37057320" class="c"><input type="checkbox" id="c-37057320" checked=""/><div class="controls bullet"><span class="by">Panzer04</span><span>|</span><a href="#37055301">root</a><span>|</span><a href="#37055804">parent</a><span>|</span><a href="#37055387">next</a><span>|</span><label class="collapse" for="c-37057320">[-]</label><label class="expand" for="c-37057320">[2 more]</label></div><br/><div class="children"><div class="content">Given the classic stack overflow branch predictor question, you are underselling things quite a lot - a factor of 6 on those older processors in question, and who knows on modern processors.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;11227809&#x2F;why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;11227809&#x2F;why-is-processi...</a></div><br/><div id="37057849" class="c"><input type="checkbox" id="c-37057849" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#37055301">root</a><span>|</span><a href="#37057320">parent</a><span>|</span><a href="#37055387">next</a><span>|</span><label class="collapse" for="c-37057849">[-]</label><label class="expand" for="c-37057849">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d give at least a single order of magnitude for most code; maybe closer to two even.</div><br/></div></div></div></div></div></div><div id="37055387" class="c"><input type="checkbox" id="c-37055387" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#37055301">parent</a><span>|</span><a href="#37055804">prev</a><span>|</span><a href="#37057516">next</a><span>|</span><label class="collapse" for="c-37055387">[-]</label><label class="expand" for="c-37055387">[1 more]</label></div><br/><div class="children"><div class="content">Yep it&#x27;s almost like Moore&#x27;s Law in reverse.</div><br/></div></div></div></div><div id="37057516" class="c"><input type="checkbox" id="c-37057516" checked=""/><div class="controls bullet"><span class="by">CanaryLayout</span><span>|</span><a href="#37055301">prev</a><span>|</span><a href="#37053205">next</a><span>|</span><label class="collapse" for="c-37057516">[-]</label><label class="expand" for="c-37057516">[1 more]</label></div><br/><div class="children"><div class="content">The NES incorporated a chipset that buried an entire 6502 inside.  You can get a Rockchip ARM chip for the price of a pizza that incorporates mixed cores on the die.   Maybe the chipmakers don&#x27;t NEED to solve every edge case until the end of time, but delegate side channel attack mitigations like this back to the chipgobblers (us).<p>Hear me out:   Instead of making SMT an all-or-nothing pre oposition, we have &quot;lousy cores&quot; where untrusted code goes and make the customer &quot;prove&quot; it should get elevation to the cores with SMT?<p>I dont&#x27;t want to clobber my chip that&#x27;s running the mega-important payroll jobs where no one can load anything else on to the board under pain of death. However I would like to be forced into tagging what is safe to run SMT else I get stuck on the safer cores.<p>I might be an intern who has no idea what any of this stuff means and goes to Google it, then learn what this attack vector truly is.   Then makes a plan on how to defend against it.<p>Am I crazy?</div><br/></div></div><div id="37053205" class="c"><input type="checkbox" id="c-37053205" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37057516">prev</a><span>|</span><a href="#37055547">next</a><span>|</span><label class="collapse" for="c-37053205">[-]</label><label class="expand" for="c-37053205">[3 more]</label></div><br/><div class="children"><div class="content">&gt; [Q] Should other processor vendors and designers be concerned?<p>&gt; [A] Other processors have shared SRAM memory inside the core, such as hardware register files and fill buffers. Manufacturers must design shared memory units with extra care to prevent data from leaking across different security domains and invest more in security validation and testing.<p>Not sure what to make of this wording. Thinly veiled threat? Hint that other embargoes are in place?</div><br/><div id="37053613" class="c"><input type="checkbox" id="c-37053613" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#37053205">parent</a><span>|</span><a href="#37053226">next</a><span>|</span><label class="collapse" for="c-37053613">[-]</label><label class="expand" for="c-37053613">[1 more]</label></div><br/><div class="children"><div class="content">AMD had a similar vulnerability recently (Zenbleed) that used speculative evaluation misprediction to create an effective &quot;use-after-free&quot; bug that would reveal the contents of the internal SIMD register file <a href="https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html</a>, that might be what is being referenced here.</div><br/></div></div><div id="37053226" class="c"><input type="checkbox" id="c-37053226" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37053205">parent</a><span>|</span><a href="#37053613">prev</a><span>|</span><a href="#37055547">next</a><span>|</span><label class="collapse" for="c-37053226">[-]</label><label class="expand" for="c-37053226">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not super revelatory given all the other Meltdown&#x2F;Spectre bugs.  I wouldn&#x27;t read too much into it.</div><br/></div></div></div></div><div id="37055547" class="c"><input type="checkbox" id="c-37055547" checked=""/><div class="controls bullet"><span class="by">errantmind</span><span>|</span><a href="#37053205">prev</a><span>|</span><a href="#37053592">next</a><span>|</span><label class="collapse" for="c-37055547">[-]</label><label class="expand" for="c-37055547">[4 more]</label></div><br/><div class="children"><div class="content">The Linux mitigation can be disabled with gather_data_sampling=off in the kernel boot parameters.<p>Be warned, apparently Grub had some kind of problem back in August 2022 and this pre-existing bug broke my boot completely when I updated grub for the above mitigation. I had to boot into a live ISO and reinstall grub to fix it.</div><br/><div id="37058680" class="c"><input type="checkbox" id="c-37058680" checked=""/><div class="controls bullet"><span class="by">ftaghn</span><span>|</span><a href="#37055547">parent</a><span>|</span><a href="#37055634">next</a><span>|</span><label class="collapse" for="c-37058680">[-]</label><label class="expand" for="c-37058680">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Be warned, apparently Grub had some kind of problem back in August 2022<p>Are you referring to this?
<a href="https:&#x2F;&#x2F;archlinux.org&#x2F;news&#x2F;grub-bootloader-upgrade-and-configuration-incompatibilities&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;archlinux.org&#x2F;news&#x2F;grub-bootloader-upgrade-and-confi...</a><p>This isn&#x27;t the first time, and won&#x27;t be the last time, something like that happens with grub, and it&#x27;s entirely an issue with the user not doing what they should when they run archlinux or some other minimalist distribution that doesn&#x27;t automate the process of updating grub.<p>Grub uses a configuration file generator that reads from the human readable&#x2F;editable &#x2F;etc&#x2F;default&#x2F;grub and creates a &#x2F;boot&#x2F;grub&#x2F;grub.cfg, and the result of that generator doesn&#x27;t have a stable &quot;interface&quot;. At any time, an update to grub might read grub.cfg incorrectly, if you do not generate it again.<p>99% of the linux distributions out there had no breakage with grub because they run the grub-mkconfig command every time grub is updated through grub-install. It is automated within the scripts included in the packaging of the distribution and the user will never see any of this in Debian, Ubuntu, Fedora etc. If a newer grub package comes out on those distro, the scripts will run both grub-install and grub-mkconfig. There will never be a mismatch between the grub binary versions and the config file state.<p>Arch Linux users who knew how grub works also had no issue. If you update grub, you must regenerate the config file (it&#x27;s a &quot;if you update&quot; because arch linux, by default, will NOT automatically update grub at all, updating the package is not the same as updating grub). If you edit the config file and regenerate it when you have a newer grub package installed, you must also update the grub binaries. So any time you do something with grub, you MUST run grub-install, then grub-mkconfig. Doing only one of the two is akin to doing a partial upgrade, which is a no-no.<p>If, as I suspect, you&#x27;re an arch user, I would recommend switching to systemd-boot, which doesn&#x27;t even need a configuration file at all if you set up your system to follow its conventions and use unified kernel images. EFI binaries are automatically scanned and shown in the menu and it uses EFI variables to remember the few settings you can interactively edit, like the preferred kernel to boot. It&#x27;s robust and only has what is needed in a small, KISS boot manager. It can&#x27;t even be truly called a boot loader because that part is managed by efistub which is part of the unified kernel image. Very unlike grub, which has the whole kitchen sink, including its own implementation of a ton of filesystems..</div><br/></div></div><div id="37055634" class="c"><input type="checkbox" id="c-37055634" checked=""/><div class="controls bullet"><span class="by">Lt_Riza_Hawkeye</span><span>|</span><a href="#37055547">parent</a><span>|</span><a href="#37058680">prev</a><span>|</span><a href="#37053592">next</a><span>|</span><label class="collapse" for="c-37055634">[-]</label><label class="expand" for="c-37055634">[2 more]</label></div><br/><div class="children"><div class="content">Simply removing the parameter didn&#x27;t fix it? Or you just reinstalled grub to be sure it would work</div><br/><div id="37055648" class="c"><input type="checkbox" id="c-37055648" checked=""/><div class="controls bullet"><span class="by">errantmind</span><span>|</span><a href="#37055547">root</a><span>|</span><a href="#37055634">parent</a><span>|</span><a href="#37053592">next</a><span>|</span><label class="collapse" for="c-37055648">[-]</label><label class="expand" for="c-37055648">[1 more]</label></div><br/><div class="children"><div class="content">The parameter was unrelated to the issue with grub but I thought I&#x27;d mention the grub issue in case anyone else gets surprised like me.</div><br/></div></div></div></div></div></div><div id="37053592" class="c"><input type="checkbox" id="c-37053592" checked=""/><div class="controls bullet"><span class="by">aestetix</span><span>|</span><a href="#37055547">prev</a><span>|</span><a href="#37058916">next</a><span>|</span><label class="collapse" for="c-37053592">[-]</label><label class="expand" for="c-37053592">[1 more]</label></div><br/><div class="children"><div class="content">I just did a cursory readthrough. Am I correct to think this feels a bit like heartbleed, but for CPU registers rather than memory?</div><br/></div></div><div id="37058916" class="c"><input type="checkbox" id="c-37058916" checked=""/><div class="controls bullet"><span class="by">sholladay</span><span>|</span><a href="#37053592">prev</a><span>|</span><a href="#37053049">next</a><span>|</span><label class="collapse" for="c-37058916">[-]</label><label class="expand" for="c-37058916">[1 more]</label></div><br/><div class="children"><div class="content">It feels like chipmakers never learned to &quot;Make it work, make it right, make it fast&quot;, in that order. But then, hindsight is 20&#x2F;20.<p>How much slower would processors be if they got rid of all complex &#x2F; risky optimizations? How much performance could we gain back with more expensive components, more integration (e.g. SoCs), and other approaches that are unlikely to lead to security problems?</div><br/></div></div><div id="37053049" class="c"><input type="checkbox" id="c-37053049" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#37058916">prev</a><span>|</span><a href="#37052846">next</a><span>|</span><label class="collapse" for="c-37053049">[-]</label><label class="expand" for="c-37053049">[1 more]</label></div><br/><div class="children"><div class="content">Ouch, I wander if they received a bug bounty from Intel for this...</div><br/></div></div><div id="37052846" class="c"><input type="checkbox" id="c-37052846" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#37053049">prev</a><span>|</span><a href="#37059258">next</a><span>|</span><label class="collapse" for="c-37052846">[-]</label><label class="expand" for="c-37052846">[8 more]</label></div><br/><div class="children"><div class="content">Geez! This seems like a _really_ big attack vector. Anyone on the security side have some caveats?</div><br/><div id="37053025" class="c"><input type="checkbox" id="c-37053025" checked=""/><div class="controls bullet"><span class="by">Chabsff</span><span>|</span><a href="#37052846">parent</a><span>|</span><a href="#37059258">next</a><span>|</span><label class="collapse" for="c-37053025">[-]</label><label class="expand" for="c-37053025">[7 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m reading this right, the caveat is that the exploit only lets you read registers that have been saved for context-switching.<p>So, in order to extract data, that data must be in constant active use (i.e. loaded in a register) at the time of the attack.</div><br/><div id="37053189" class="c"><input type="checkbox" id="c-37053189" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#37052846">root</a><span>|</span><a href="#37053025">parent</a><span>|</span><a href="#37053092">next</a><span>|</span><label class="collapse" for="c-37053189">[-]</label><label class="expand" for="c-37053189">[1 more]</label></div><br/><div class="children"><div class="content">It claims to also allow you to read any data loaded into a vector register, any data loaded from a {rep mov} (i.e. memcpy), any data used by crypto acceleration, and a bunch more. Basically, the only data it does not let you read is regular loads into the regular GPRs (i.e. what would be a register load in a RISC architecture) though if you save&#x2F;restore during context switches using the special instructions you will leak the values at the time of the context switch.<p>This is about as close to a total cross-process data leak as can be imagined.</div><br/></div></div><div id="37053092" class="c"><input type="checkbox" id="c-37053092" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#37052846">root</a><span>|</span><a href="#37053025">parent</a><span>|</span><a href="#37053189">prev</a><span>|</span><a href="#37059258">next</a><span>|</span><label class="collapse" for="c-37053092">[-]</label><label class="expand" for="c-37053092">[5 more]</label></div><br/><div class="children"><div class="content">Would environmental variables be something that shows up in context-switching?</div><br/><div id="37053221" class="c"><input type="checkbox" id="c-37053221" checked=""/><div class="controls bullet"><span class="by">ZephyrP</span><span>|</span><a href="#37052846">root</a><span>|</span><a href="#37053092">parent</a><span>|</span><a href="#37053192">next</a><span>|</span><label class="collapse" for="c-37053221">[-]</label><label class="expand" for="c-37053221">[1 more]</label></div><br/><div class="children"><div class="content">In general, not really, but the most common string comparison instruction in x86_64 leaves the last character of <i>one</i> of the strings being compared with the other one just being a pointer into the C-style string.</div><br/></div></div><div id="37053192" class="c"><input type="checkbox" id="c-37053192" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37052846">root</a><span>|</span><a href="#37053092">parent</a><span>|</span><a href="#37053221">prev</a><span>|</span><a href="#37053170">next</a><span>|</span><label class="collapse" for="c-37053192">[-]</label><label class="expand" for="c-37053192">[1 more]</label></div><br/><div class="children"><div class="content">Typically not, but only because they are not typically accessed frequently.</div><br/></div></div></div></div></div></div></div></div><div id="37059258" class="c"><input type="checkbox" id="c-37059258" checked=""/><div class="controls bullet"><span class="by">isoprophlex</span><span>|</span><a href="#37052846">prev</a><span>|</span><a href="#37053761">next</a><span>|</span><label class="collapse" for="c-37059258">[-]</label><label class="expand" for="c-37059258">[1 more]</label></div><br/><div class="children"><div class="content">I guess Moore&#x27;s law isn&#x27;t exactly dead, but it doesn&#x27;t seem to be alive either... Moore&#x27;s law is undead?</div><br/></div></div><div id="37053761" class="c"><input type="checkbox" id="c-37053761" checked=""/><div class="controls bullet"><span class="by">GartzenDeHaes</span><span>|</span><a href="#37059258">prev</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37053761">[-]</label><label class="expand" for="c-37053761">[7 more]</label></div><br/><div class="children"><div class="content">How could an attacker gain the level of knowledge necessary to accomplish this without compromising the target process?</div><br/><div id="37054254" class="c"><input type="checkbox" id="c-37054254" checked=""/><div class="controls bullet"><span class="by">dwrodri</span><span>|</span><a href="#37053761">parent</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37054254">[-]</label><label class="expand" for="c-37054254">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only done a quick read through the link, but I think the model they imply is that a malicious user could rent a Cloud VM in AWS&#x2F;Azure&#x2F;GCP&#x2F;etc and then sniff the contents of SIMD registers, similar to the Zenbleed attack which was also disclosed recently[1]. This is a big deal because optimized implementations of strcpy, strlen, and memcpy in glibc all use SIMD registers, and glibc is everywhere.<p>1: <a href="https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html</a></div><br/><div id="37058383" class="c"><input type="checkbox" id="c-37058383" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#37053761">root</a><span>|</span><a href="#37054254">parent</a><span>|</span><a href="#37055214">next</a><span>|</span><label class="collapse" for="c-37058383">[-]</label><label class="expand" for="c-37058383">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK none of the cloud vendors run multiple customer&#x27;s VMs at the same time on the same core; even the &quot;shared-core&quot; virtual machines don&#x27;t share timeslices (AWS goes into detail about this here[1]).<p>[1]: <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-design-of-aws-nitro-system&#x2F;the-ec2-approach-to-preventing-side-channels.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;whitepapers&#x2F;latest&#x2F;security-desi...</a></div><br/></div></div><div id="37055214" class="c"><input type="checkbox" id="c-37055214" checked=""/><div class="controls bullet"><span class="by">GartzenDeHaes</span><span>|</span><a href="#37053761">root</a><span>|</span><a href="#37054254">parent</a><span>|</span><a href="#37058383">prev</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37055214">[-]</label><label class="expand" for="c-37055214">[4 more]</label></div><br/><div class="children"><div class="content">How do they know what data is in the registers? In the linked article, the person running the attack code knows what is running on the target. The target is also conveniently waiting for the attack code to run without doing anything other than referencing the target data.</div><br/><div id="37057377" class="c"><input type="checkbox" id="c-37057377" checked=""/><div class="controls bullet"><span class="by">dwrodri</span><span>|</span><a href="#37053761">root</a><span>|</span><a href="#37055214">parent</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37057377">[-]</label><label class="expand" for="c-37057377">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m gonna get put on a list for typing this out but I&#x27;ll clarify:<p>1. Bad guy creates cloud account and spawns 10 of the cheapest VMs across different data centers, let&#x27;s say this costs a total of, what... $50 a month?<p>2. Bad guy reads this paper, and makes a program that frequently samples SIMD registers. Contents get dumped to stdout and then streamed over an encrypted line to a RAID array hosted in $COUNTRY_WITHOUT_US_EXTRADITION.<p>3. Bad guy writes program to sift through data dumps on RAID array for passwords, encryption keys, etc.<p>If you create a cloud instance right now that has an SSH login on port 22, you stream the SSH login logs and see a steady stream of attempted logins to your device. While the marginal cost of brute forcing SSH logins is free (no cloud VM needed) and my proposed scenario isn&#x27;t, I think this is a very real scenario that needs monitoring.</div><br/><div id="37058620" class="c"><input type="checkbox" id="c-37058620" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#37053761">root</a><span>|</span><a href="#37057377">parent</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37058620">[-]</label><label class="expand" for="c-37058620">[2 more]</label></div><br/><div class="children"><div class="content">hmmm. Does this not assume that a cpu is shared among exactly 2 tenants over a long period of time?<p>And can‘t the cloud provider simply block access to the cpu api? Like they don’t allow you to create your own threads?<p>Just trying to understand this.</div><br/><div id="37058789" class="c"><input type="checkbox" id="c-37058789" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#37053761">root</a><span>|</span><a href="#37058620">parent</a><span>|</span><a href="#37056331">next</a><span>|</span><label class="collapse" for="c-37058789">[-]</label><label class="expand" for="c-37058789">[1 more]</label></div><br/><div class="children"><div class="content">A VM cloud provider can&#x27;t block you from running at least one thread, which is all the malicious threads required for this attack.<p>However none of the big cloud providers share CPU cores between users to combat exactly this kind of thing. I really wish the people that did these disclosures were more up-front about this, instead of saying vague things like &quot;frequently happens on modern-day computers&quot;. Though I guess you can assume that if an attack would work on AWS the researcher would definitely mention it, so the lack of such an explicit claim almost ensures the attack is not viable on major clouds.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37056331" class="c"><input type="checkbox" id="c-37056331" checked=""/><div class="controls bullet"><span class="by">Aaronmacaron</span><span>|</span><a href="#37053761">prev</a><span>|</span><a href="#37053145">next</a><span>|</span><label class="collapse" for="c-37056331">[-]</label><label class="expand" for="c-37056331">[1 more]</label></div><br/><div class="children"><div class="content">Are there any known attacks which exploited Spectre or Meltdown vulnerabilities? And is it likely that this vulnerability will be successfully used to perform attacks?</div><br/></div></div><div id="37053145" class="c"><input type="checkbox" id="c-37053145" checked=""/><div class="controls bullet"><span class="by">nwmcsween</span><span>|</span><a href="#37056331">prev</a><span>|</span><a href="#37054122">next</a><span>|</span><label class="collapse" for="c-37053145">[-]</label><label class="expand" for="c-37053145">[3 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t RTFA but would zeroing registers fix this (-mzero-caller-saved-regs=used)?</div><br/><div id="37054245" class="c"><input type="checkbox" id="c-37054245" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#37053145">parent</a><span>|</span><a href="#37053842">next</a><span>|</span><label class="collapse" for="c-37054245">[-]</label><label class="expand" for="c-37054245">[1 more]</label></div><br/><div class="children"><div class="content">In modern CPUs registers are a high-level abstract concept (see register renaming), so writing to a register doesn&#x27;t have any specific location to overwrite.<p>Recent Zenbleed vulnerability was an example of that — clearing of a register was setting a temporary boolean saying it&#x27;s zeroed instead of writing actual zeros.</div><br/></div></div><div id="37053842" class="c"><input type="checkbox" id="c-37053842" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#37053145">parent</a><span>|</span><a href="#37054245">prev</a><span>|</span><a href="#37054122">next</a><span>|</span><label class="collapse" for="c-37053842">[-]</label><label class="expand" for="c-37053842">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so. This vulnerability is leaking data from a load-buffer, not directly from registers. It affects data that is loaded in bulk or to vector registers.<p>However, general purpose registers are also loaded passing through this buffer during context switches.</div><br/></div></div></div></div><div id="37054122" class="c"><input type="checkbox" id="c-37054122" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#37053145">prev</a><span>|</span><a href="#37053552">next</a><span>|</span><label class="collapse" for="c-37054122">[-]</label><label class="expand" for="c-37054122">[1 more]</label></div><br/><div class="children"><div class="content">I am a little unclear on the attack. What data in the temporal buffer is being forwarded to the attacking vpgather?<p>Is the content of the temporal buffer just being blindly forwarded during speculative execution even if the indexed address of the attacking vpgather does not match?<p>Otherwise how is the speculative vpgather allowed to load the values of the temporal buffer?<p>If it is not blind is it a virtual address match? I guess it could also be a not-Present mapping physical match as well? I can not think of any other possibility off the top of my head.<p>If it is a blind forward that is pretty amazingly bad.</div><br/></div></div><div id="37053552" class="c"><input type="checkbox" id="c-37053552" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#37054122">prev</a><span>|</span><a href="#37059505">next</a><span>|</span><label class="collapse" for="c-37053552">[-]</label><label class="expand" for="c-37053552">[1 more]</label></div><br/><div class="children"><div class="content">This is one of many similar previous attacks, and more of these attacks will continue to come out and be increasingly weaponized. From now on the assumption must be that same-core computing is not secure.</div><br/></div></div><div id="37059505" class="c"><input type="checkbox" id="c-37059505" checked=""/><div class="controls bullet"><span class="by">entriesfull</span><span>|</span><a href="#37053552">prev</a><span>|</span><a href="#37056425">next</a><span>|</span><label class="collapse" for="c-37059505">[-]</label><label class="expand" for="c-37059505">[1 more]</label></div><br/><div class="children"><div class="content">So this is literally the same thing as AMD&#x27;s Zenbleed vulnerability? Ridiculous how these companies make so much money and are completely incompetent at handling security.<p>Theoretically, this can be mitigated permanently by disabling hyper-threading?</div><br/></div></div><div id="37056425" class="c"><input type="checkbox" id="c-37056425" checked=""/><div class="controls bullet"><span class="by">basedrum</span><span>|</span><a href="#37059505">prev</a><span>|</span><a href="#37053312">next</a><span>|</span><label class="collapse" for="c-37056425">[-]</label><label class="expand" for="c-37056425">[2 more]</label></div><br/><div class="children"><div class="content">Can someone explain why the ssh video at 2:25, where the 256bit comparison is pasted in, it doesn&#x27;t match? The first two colon separated number sets do match, but not the following two?</div><br/><div id="37056970" class="c"><input type="checkbox" id="c-37056970" checked=""/><div class="controls bullet"><span class="by">stordoff</span><span>|</span><a href="#37056425">parent</a><span>|</span><a href="#37053312">next</a><span>|</span><label class="collapse" for="c-37056970">[-]</label><label class="expand" for="c-37056970">[1 more]</label></div><br/><div class="children"><div class="content">At the end of this video? <a href="https:&#x2F;&#x2F;downfall.page&#x2F;media&#x2F;gds_aes.mp4" rel="nofollow noreferrer">https:&#x2F;&#x2F;downfall.page&#x2F;media&#x2F;gds_aes.mp4</a> They appear to match to me, albeit with the last few characters hidden by the timer. They are visible when the key is copied though.</div><br/></div></div></div></div><div id="37053312" class="c"><input type="checkbox" id="c-37053312" checked=""/><div class="controls bullet"><span class="by">thewataccount</span><span>|</span><a href="#37056425">prev</a><span>|</span><a href="#37056368">next</a><span>|</span><label class="collapse" for="c-37053312">[-]</label><label class="expand" for="c-37053312">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone know what type of workloads this effects the performance of the most? Is this specialty-type of workloads or are general webserver&#x2F;database&#x2F;coding&#x2F;compiling&#x2F;gaming&#x2F;desktop usages effected?</div><br/></div></div><div id="37056368" class="c"><input type="checkbox" id="c-37056368" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#37053312">prev</a><span>|</span><a href="#37053462">next</a><span>|</span><label class="collapse" for="c-37056368">[-]</label><label class="expand" for="c-37056368">[2 more]</label></div><br/><div class="children"><div class="content">So it seems like speculative execution cannot be disabled. What’s the mitigation here? Nothing and wait for patch or significant redesign?</div><br/><div id="37056401" class="c"><input type="checkbox" id="c-37056401" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#37056368">parent</a><span>|</span><a href="#37053462">next</a><span>|</span><label class="collapse" for="c-37056401">[-]</label><label class="expand" for="c-37056401">[1 more]</label></div><br/><div class="children"><div class="content">&gt;What’s the mitigation here?<p>Replace the buggy CISC CPU. Ideally with a less complex thus highly likely less buggy RISC one.</div><br/></div></div></div></div><div id="37053462" class="c"><input type="checkbox" id="c-37053462" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#37056368">prev</a><span>|</span><label class="collapse" for="c-37053462">[-]</label><label class="expand" for="c-37053462">[4 more]</label></div><br/><div class="children"><div class="content">Is there an overview page of all these processor data leak bugs the last 10 years? It feels like there has been an enormous surge in them.</div><br/><div id="37053554" class="c"><input type="checkbox" id="c-37053554" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37053462">parent</a><span>|</span><a href="#37056288">next</a><span>|</span><label class="collapse" for="c-37053554">[-]</label><label class="expand" for="c-37053554">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a compilation: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transient_execution_CPU_vulnerability" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transient_execution_CPU_vulner...</a></div><br/></div></div><div id="37058230" class="c"><input type="checkbox" id="c-37058230" checked=""/><div class="controls bullet"><span class="by">liamkearney</span><span>|</span><a href="#37053462">parent</a><span>|</span><a href="#37056288">prev</a><span>|</span><label class="collapse" for="c-37058230">[-]</label><label class="expand" for="c-37058230">[1 more]</label></div><br/><div class="children"><div class="content">As seen in the attack demo video the kernel advises of some. You can ‘cat &#x2F;proc&#x2F;cpuinfo’ and look for them there.</div><br/></div></div></div></div></div></div></div></div></div></body></html>