<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703062865710" as="style"/><link rel="stylesheet" href="styles.css?v=1703062865710"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://floppy.cafe/">Bit banging a 3.5&quot; floppy drive</a> <span class="domain">(<a href="https://floppy.cafe">floppy.cafe</a>)</span></div><div class="subtext"><span>brk</span> | <span>75 comments</span></div><br/><div><div id="38703617" class="c"><input type="checkbox" id="c-38703617" checked=""/><div class="controls bullet"><span class="by">VogonPoetry</span><span>|</span><a href="#38699855">next</a><span>|</span><label class="collapse" for="c-38703617">[-]</label><label class="expand" for="c-38703617">[1 more]</label></div><br/><div class="children"><div class="content">I think the software decoding technique used here is incomplete.<p>Consider what would happen if a data sector contained 12 * 0x00, 3 * 0xA1, 0xFE, ... then this implementation could mis-sync. On real hardware you&#x27;d have to be even more unlucky to have the CRC match -- which also isn&#x27;t checked in this implementation. Using this as-is on real floppies could result in reading corrupt data. It would be possible to construct a floppy that would read correctly on real hardware and sometimes mis-read data with the current SW implementation.<p>The problem is that the 0xA1 bytes on the disk are special. The 0xA1 bytes are MFM encoded with a missing clock pulse -- making them &quot;0xA1 syncs&quot; that don&#x27;t match an 0xA1 data byte.<p>This is what I think dragontamer is alluding to in another thread -- you cannot properly decode the header unless you also recognize the missing clock pulse. So it is important to do the clock recovery in order to notice this.<p>The special encoding is also present for 5.25 and early hard drives using MFM encodings.</div><br/></div></div><div id="38699855" class="c"><input type="checkbox" id="c-38699855" checked=""/><div class="controls bullet"><span class="by">wolpoli</span><span>|</span><a href="#38703617">prev</a><span>|</span><a href="#38702860">next</a><span>|</span><label class="collapse" for="c-38699855">[-]</label><label class="expand" for="c-38699855">[28 more]</label></div><br/><div class="children"><div class="content">&gt; Fun fact! floppy disks actually contain a lot more surface area than 1.44mb. By my calculation, you&#x27;ll get closer to 1.70mb but a lot of that extra space is earmarked for synchronization barriers and sector &#x2F; track metadata.<p>This explains the 2M utility that allowed storing about 1.8mb on a floppy disk. It was fun playing with it.</div><br/><div id="38700341" class="c"><input type="checkbox" id="c-38700341" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#38699855">parent</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38700341">[-]</label><label class="expand" for="c-38700341">[16 more]</label></div><br/><div class="children"><div class="content">I think this is a case where a picture is worth a thousand words.  This excellent article &quot;Visualizing Commodore 1541 Disk Contents&quot; [1] by Michael Steil about the Commodore 64 disk format, includes visualizations of the magnetic flux as stored on disk.<p>This bit is particularly relevant: <a href="https:&#x2F;&#x2F;www.pagetable.com&#x2F;docs&#x2F;visualize_1541&#x2F;sector.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pagetable.com&#x2F;docs&#x2F;visualize_1541&#x2F;sector.png</a>  See the solid bit at the end of the sector, just before the next header?  You <i>could</i> squeeze a few more bytes in there, but if the drive motor is just slightly too fast, it&#x27;ll overwrite the next sector.  That&#x27;s why there&#x27;s a gap, tolerance for timing variation.<p>Most floppy drive technologies wrote blindly, guessing where they were on the disk based on timing estimates since the controller last saw a sector header.  This is also why disks needed to be &quot;formatted&quot;.  Not just in the sense of writing the file system data structures, but writing out all the sector headers.  This had to be done all at once with the same drive, due to those small timing variations.<p>[1] <a href="https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=1070" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=1070</a></div><br/><div id="38700589" class="c"><input type="checkbox" id="c-38700589" checked=""/><div class="controls bullet"><span class="by">brk</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700341">parent</a><span>|</span><a href="#38700497">next</a><span>|</span><label class="collapse" for="c-38700589">[-]</label><label class="expand" for="c-38700589">[4 more]</label></div><br/><div class="children"><div class="content">I recall it was also not unheard of to have floppy drives that could be incompatible with each other. A drive that was a tad slow might format a disk that would work for itself, and other drive, but that disk might not work in a drive that was a tad too fast (and vice-versa). This wasn&#x27;t common, just frequently enough to occur so occasionally as to always be baffling, particularly in an office with lots of PCs.<p>Then there were things like Spiradisc (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spiradisc" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spiradisc</a>), which created incompatibilities by design.</div><br/><div id="38701184" class="c"><input type="checkbox" id="c-38701184" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700589">parent</a><span>|</span><a href="#38703512">next</a><span>|</span><label class="collapse" for="c-38701184">[-]</label><label class="expand" for="c-38701184">[1 more]</label></div><br/><div class="children"><div class="content">This happened with tape drives too. Head alignment or track alignment a little bit off and you&#x27;d start to lose the high pretty quickly.</div><br/></div></div><div id="38703512" class="c"><input type="checkbox" id="c-38703512" checked=""/><div class="controls bullet"><span class="by">15457345234</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700589">parent</a><span>|</span><a href="#38701184">prev</a><span>|</span><a href="#38700497">next</a><span>|</span><label class="collapse" for="c-38703512">[-]</label><label class="expand" for="c-38703512">[2 more]</label></div><br/><div class="children"><div class="content">At high school (in the 1.44mb &#x2F; w95 era) I encountered a floppy disk that had literally two different filesystems on it depending on what machine you read it in. Not entirely sure how that worked. One machine showed one filesystem, the rest showed another.<p>I guess the alignment on that one particular drive must have been ridiculously far off baseline.</div><br/><div id="38705716" class="c"><input type="checkbox" id="c-38705716" checked=""/><div class="controls bullet"><span class="by">ggeorgovassilis</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38703512">parent</a><span>|</span><a href="#38700497">next</a><span>|</span><label class="collapse" for="c-38705716">[-]</label><label class="expand" for="c-38705716">[1 more]</label></div><br/><div class="children"><div class="content">I remember that, too. Got such a floppy from a computer magazine. I think one was for the PC and then other for Amiga or Atari.</div><br/></div></div></div></div></div></div><div id="38700497" class="c"><input type="checkbox" id="c-38700497" checked=""/><div class="controls bullet"><span class="by">examiga500</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700341">parent</a><span>|</span><a href="#38700589">prev</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38700497">[-]</label><label class="expand" for="c-38700497">[11 more]</label></div><br/><div class="children"><div class="content">Amiga had floppy drives that could read&#x2F;write 1.76MB on HD disks and 880K on SD floppys. I think this was possible because they could control the speed.</div><br/><div id="38700811" class="c"><input type="checkbox" id="c-38700811" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700497">parent</a><span>|</span><a href="#38703371">next</a><span>|</span><label class="collapse" for="c-38700811">[-]</label><label class="expand" for="c-38700811">[1 more]</label></div><br/><div class="children"><div class="content">Mac drives had finer control over the motor RPM. Amiga drives read&#x2F;wrote a track at a time and had no sector gaps.<p><a href="https:&#x2F;&#x2F;porterolsen.wordpress.com&#x2F;2016&#x2F;06&#x2F;15&#x2F;accessing-mac-formatted-floppy-disks-without-the-kryoflux&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;porterolsen.wordpress.com&#x2F;2016&#x2F;06&#x2F;15&#x2F;accessing-mac-f...</a>
<a href="https:&#x2F;&#x2F;c65gs.blogspot.com&#x2F;2023&#x2F;10&#x2F;reading-amiga-disks-in-mega65.html?m=1#:~:text=The%20following%20are%20details%20about,No%20gaps%20written%20between%20sectors" rel="nofollow noreferrer">https:&#x2F;&#x2F;c65gs.blogspot.com&#x2F;2023&#x2F;10&#x2F;reading-amiga-disks-in-me...</a>.</div><br/></div></div><div id="38703371" class="c"><input type="checkbox" id="c-38703371" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700497">parent</a><span>|</span><a href="#38700811">prev</a><span>|</span><a href="#38704948">next</a><span>|</span><label class="collapse" for="c-38703371">[-]</label><label class="expand" for="c-38703371">[3 more]</label></div><br/><div class="children"><div class="content">This was due to different track format.<p>Specifically, AmigaOS&#x27;s floppies write one sector after another, with a single gap in the entire track.<p>Whereas the IBM PC format has a gap in each sector. This is because RAM was more expensive back then, thus holding an entire track in memory would have an associated cost.</div><br/><div id="38704931" class="c"><input type="checkbox" id="c-38704931" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38703371">parent</a><span>|</span><a href="#38704948">next</a><span>|</span><label class="collapse" for="c-38704931">[-]</label><label class="expand" for="c-38704931">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Whereas the IBM PC format has a gap in each sector. This is because RAM was more expensive back then, thus holding an entire track in memory would have an associated cost.<p>A major factor - I&#x27;d argue even more significant than cost of memory - was that the IBM PC used an off-the-shelf floppy disk controller chip (NEC uPDC765A), which was hardwired to support the industry-standard IBM floppy track format (which had evolved from IBM&#x27;s 3740 mainframe data entry system, introduced in 1973), and didn&#x27;t support the Amiga&#x27;s custom track format. Whereas, the Amiga could do this because it didn&#x27;t actually have a floppy disk controller-the functionality of controlling floppy disks was in part contained in their custom ASICs, and in part implemented in software by the CPU. Unlike the Amiga, the original IBM PC eschewed proprietary ASICs in favour of off-the-shelf chips, in order to minimise time-to-market.</div><br/><div id="38706219" class="c"><input type="checkbox" id="c-38706219" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38704931">parent</a><span>|</span><a href="#38704948">next</a><span>|</span><label class="collapse" for="c-38706219">[-]</label><label class="expand" for="c-38706219">[1 more]</label></div><br/><div class="children"><div class="content">True, they use these pre-existing standard controllers. But these standard controllers and the track format were indeed designed in that way due to the ram limitation.<p>Ironically, it is possible to read arbitrary formats with the debug read track operation. Yet, it needs to find one triple sync word somewhere in the track; a controller limitation.<p>Unfortunately, the Amiga standard track format didn&#x27;t account for that, and uses the same sync word (the 4489 one) but double.<p>It could have been designed to use a different sync word, and include a triple 4489 at the track start, but they didn&#x27;t think about it at the time.<p>Some tricks bit-banging the controller allow for writing arbitrary tracks.<p>It is also possible to read arbitrary tracks, if there&#x27;s two floppy drives and a standard ibm pc formatted disk is present in the other one, by switching the drive after the controller has started reading.</div><br/></div></div></div></div></div></div><div id="38704948" class="c"><input type="checkbox" id="c-38704948" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700497">parent</a><span>|</span><a href="#38703371">prev</a><span>|</span><a href="#38701710">next</a><span>|</span><label class="collapse" for="c-38704948">[-]</label><label class="expand" for="c-38704948">[1 more]</label></div><br/><div class="children"><div class="content">Thanks to the pluggable device layer, you could push that to 984kB or 1968kB with diskspare¹.  The incredible thing, IMO, is that the implementation is only 5kB(<i>seven</i> times smaller than the formatted English docs).<p>¹ <a href="https:&#x2F;&#x2F;aminet.net&#x2F;package&#x2F;disk&#x2F;misc&#x2F;Diskspr3" rel="nofollow noreferrer">https:&#x2F;&#x2F;aminet.net&#x2F;package&#x2F;disk&#x2F;misc&#x2F;Diskspr3</a></div><br/></div></div><div id="38701710" class="c"><input type="checkbox" id="c-38701710" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38700497">parent</a><span>|</span><a href="#38704948">prev</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38701710">[-]</label><label class="expand" for="c-38701710">[5 more]</label></div><br/><div class="children"><div class="content">The only HD drive ever available for Amiga was sold with some 4000 units - a modded Chinon FZ357A spinning at half rpm because nobody at commodore knew how to update PLL circuit in Denise. 1.76MB capacity was reached by not using standard PC format.<p>Microsoft itself was shipping software on ordinary PC floppies formatted for 1.68MB <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distribution_Media_Format" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distribution_Media_Format</a></div><br/><div id="38703024" class="c"><input type="checkbox" id="c-38703024" checked=""/><div class="controls bullet"><span class="by">Cockbrand</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701710">parent</a><span>|</span><a href="#38703393">next</a><span>|</span><label class="collapse" for="c-38703024">[-]</label><label class="expand" for="c-38703024">[1 more]</label></div><br/><div class="children"><div class="content">My A3000 has an HD floppy drive. I was surprised to find that out, as I hadn&#x27;t been aware that Amigas with these drives existed.</div><br/></div></div><div id="38703393" class="c"><input type="checkbox" id="c-38703393" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701710">parent</a><span>|</span><a href="#38703024">prev</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38703393">[-]</label><label class="expand" for="c-38703393">[3 more]</label></div><br/><div class="children"><div class="content">Not Denise, Paula.<p>Denise is the video chip. Paula handles interrupts, audio, the floppy data signal (control logic signals are in CIA) as well as the uart.</div><br/><div id="38704672" class="c"><input type="checkbox" id="c-38704672" checked=""/><div class="controls bullet"><span class="by">bcrl</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38703393">parent</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38704672">[-]</label><label class="expand" for="c-38704672">[2 more]</label></div><br/><div class="children"><div class="content">Paula being the only chip that had absolutely zero changes from the Amiga 1000 to the 4000.  That fact alone is a sad example of Commodore&#x27;s mismanagement of the platform.  Well, except for the CIA which traces its lineage even further back to the C64.</div><br/><div id="38706193" class="c"><input type="checkbox" id="c-38706193" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38704672">parent</a><span>|</span><a href="#38699934">next</a><span>|</span><label class="collapse" for="c-38706193">[-]</label><label class="expand" for="c-38706193">[1 more]</label></div><br/><div class="children"><div class="content">Try Commodore The Inside Story (book) for more depressing knowledge.<p>Management just didn&#x27;t let their engineers&#x2F;architects get things done.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38699934" class="c"><input type="checkbox" id="c-38699934" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#38699855">parent</a><span>|</span><a href="#38700341">prev</a><span>|</span><a href="#38701635">next</a><span>|</span><label class="collapse" for="c-38699934">[-]</label><label class="expand" for="c-38699934">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.os2museum.com&#x2F;wp&#x2F;the-xdf-diskette-format&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.os2museum.com&#x2F;wp&#x2F;the-xdf-diskette-format&#x2F;</a> has tons of details on IBM&#x27;s contemporary and somewhat similar format.</div><br/></div></div><div id="38701635" class="c"><input type="checkbox" id="c-38701635" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38699855">parent</a><span>|</span><a href="#38699934">prev</a><span>|</span><a href="#38702760">next</a><span>|</span><label class="collapse" for="c-38701635">[-]</label><label class="expand" for="c-38701635">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I ever got a stable disk above 1.6MB. Which was just enough for a few things but generally not worth it.<p>The motors in the disk drives could be controlled directly, and you could pack the tracks tighter by stepping the motor just a little bit less than you were supposed to.  And in theory if you did it right, other disk drives could read it.<p>&#x27;In theory&#x27; is carrying a lot there. I tended to find 1.5something to 1.6something worked and anything higher rarely ever did.</div><br/><div id="38701720" class="c"><input type="checkbox" id="c-38701720" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701635">parent</a><span>|</span><a href="#38701937">next</a><span>|</span><label class="collapse" for="c-38701720">[-]</label><label class="expand" for="c-38701720">[2 more]</label></div><br/><div class="children"><div class="content">Microsoft had no problem with 1680KB <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distribution_Media_Format" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distribution_Media_Format</a></div><br/><div id="38705380" class="c"><input type="checkbox" id="c-38705380" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701720">parent</a><span>|</span><a href="#38701937">next</a><span>|</span><label class="collapse" for="c-38705380">[-]</label><label class="expand" for="c-38705380">[1 more]</label></div><br/><div class="children"><div class="content">This is probably only suitable for write-once PC media as the timing would be quite tight for reliably modifying individual sectors in place.</div><br/></div></div></div></div><div id="38701937" class="c"><input type="checkbox" id="c-38701937" checked=""/><div class="controls bullet"><span class="by">scoot</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701635">parent</a><span>|</span><a href="#38701720">prev</a><span>|</span><a href="#38702760">next</a><span>|</span><label class="collapse" for="c-38701937">[-]</label><label class="expand" for="c-38701937">[5 more]</label></div><br/><div class="children"><div class="content">Could you really step less than a standard track? I would have assumed that the stepper motor&#x27;s steps are track aligned, so either you step, or you don&#x27;t...</div><br/><div id="38704277" class="c"><input type="checkbox" id="c-38704277" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701937">parent</a><span>|</span><a href="#38702644">next</a><span>|</span><label class="collapse" for="c-38704277">[-]</label><label class="expand" for="c-38704277">[1 more]</label></div><br/><div class="children"><div class="content">Too late to edit.<p>It was extra sectors not tracks, although is looks like some people added another track or three at the edge of the disk.</div><br/></div></div><div id="38702644" class="c"><input type="checkbox" id="c-38702644" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701937">parent</a><span>|</span><a href="#38704277">prev</a><span>|</span><a href="#38702724">next</a><span>|</span><label class="collapse" for="c-38702644">[-]</label><label class="expand" for="c-38702644">[1 more]</label></div><br/><div class="children"><div class="content">I’d imagine it’s very hardware specific</div><br/></div></div><div id="38702724" class="c"><input type="checkbox" id="c-38702724" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38701937">parent</a><span>|</span><a href="#38702644">prev</a><span>|</span><a href="#38702760">next</a><span>|</span><label class="collapse" for="c-38702724">[-]</label><label class="expand" for="c-38702724">[2 more]</label></div><br/><div class="children"><div class="content">No, no standard Shugart interface compatible floppy allows you to do that.</div><br/><div id="38703340" class="c"><input type="checkbox" id="c-38703340" checked=""/><div class="controls bullet"><span class="by">scoot</span><span>|</span><a href="#38699855">root</a><span>|</span><a href="#38702724">parent</a><span>|</span><a href="#38702760">next</a><span>|</span><label class="collapse" for="c-38703340">[-]</label><label class="expand" for="c-38703340">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, yes, the article seems to confirm that:<p>&quot;There are 80 tracks on your average 3.5&quot; floppy drive. You can select a given track by pulsing the STEP pin and combining it with the direction select pin.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="38702760" class="c"><input type="checkbox" id="c-38702760" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#38699855">parent</a><span>|</span><a href="#38701635">prev</a><span>|</span><a href="#38701563">next</a><span>|</span><label class="collapse" for="c-38702760">[-]</label><label class="expand" for="c-38702760">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft was able to distribute Windows 95 in fewer floppies by creating their own floppy disk format called DMF that used utilized more sectors per track.</div><br/></div></div><div id="38701563" class="c"><input type="checkbox" id="c-38701563" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#38699855">parent</a><span>|</span><a href="#38702760">prev</a><span>|</span><a href="#38702860">next</a><span>|</span><label class="collapse" for="c-38701563">[-]</label><label class="expand" for="c-38701563">[1 more]</label></div><br/><div class="children"><div class="content">A 2M utility allows storing 1.8M? That&#x27;s not confusing at all!</div><br/></div></div></div></div><div id="38702860" class="c"><input type="checkbox" id="c-38702860" checked=""/><div class="controls bullet"><span class="by">anotherevan</span><span>|</span><a href="#38699855">prev</a><span>|</span><a href="#38699885">next</a><span>|</span><label class="collapse" for="c-38702860">[-]</label><label class="expand" for="c-38702860">[7 more]</label></div><br/><div class="children"><div class="content">One of my first jobs in the early 90&#x27;s was to write a device driver for a floppy disk drive in an embedded system. There was the drive itself, the floppy disk controller chip, and the direct memory access (DMA) chip. I only had the specs for the latter two in English.<p>Analysing the circuits, I saw the controller chip was wired such that use of the DMA chip was software configurable, so I thought beaut, I&#x27;ll write and test the first iteration without DMA, then add and test that after.<p>Couldn&#x27;t get it working. Scratched my head for a while until, while discussing it with one of the hardware engineers, was told that while the controller chip had been wired software configurable, the floppy drive itself was hard-wired to use DMA. If only I had the spec for that I would have figured it out!<p>So added usage of the DMA chip… success!</div><br/><div id="38703350" class="c"><input type="checkbox" id="c-38703350" checked=""/><div class="controls bullet"><span class="by">bogantech</span><span>|</span><a href="#38702860">parent</a><span>|</span><a href="#38704961">next</a><span>|</span><label class="collapse" for="c-38703350">[-]</label><label class="expand" for="c-38703350">[3 more]</label></div><br/><div class="children"><div class="content">What kind of floppy drive was this? PC and just about every floppy drive I&#x27;ve ever seen only has motor, step, read &#x2F; write data etc signals and no concept of DMA etc which would solely be handled by the FDC itself</div><br/><div id="38703818" class="c"><input type="checkbox" id="c-38703818" checked=""/><div class="controls bullet"><span class="by">anotherevan</span><span>|</span><a href="#38702860">root</a><span>|</span><a href="#38703350">parent</a><span>|</span><a href="#38704961">next</a><span>|</span><label class="collapse" for="c-38703818">[-]</label><label class="expand" for="c-38703818">[2 more]</label></div><br/><div class="children"><div class="content">It looks like a fairly standard floppy drive. I might be misremembering or misinterpreted the particulars due to neither me and the hardware guy being able to speak the other&#x27;s native tongue that well, but the upshot was despite what the circuit told me about the configurability of the controller chip, it was not going to work without DMA.</div><br/><div id="38704471" class="c"><input type="checkbox" id="c-38704471" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#38702860">root</a><span>|</span><a href="#38703818">parent</a><span>|</span><a href="#38704961">next</a><span>|</span><label class="collapse" for="c-38704471">[-]</label><label class="expand" for="c-38704471">[1 more]</label></div><br/><div class="children"><div class="content">The linked article shows the &quot;standard&quot; pinout for a 3.5&quot; floppy drive, and it&#x27;s clear the interface is below the level of anything like DMA.<p>I assume even if you were using something that <i>looked</i> like a standard floppy drive, it was using a higher level interface, or was including something like the controller ISA board in the &quot;interface&quot;.</div><br/></div></div></div></div></div></div><div id="38704961" class="c"><input type="checkbox" id="c-38704961" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#38702860">parent</a><span>|</span><a href="#38703350">prev</a><span>|</span><a href="#38704353">next</a><span>|</span><label class="collapse" for="c-38704961">[-]</label><label class="expand" for="c-38704961">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>If only I had the spec for that I would have figured it out!</i><p>It turned out that &quot;vendors not providing datasheet&quot; has forever been the problem for hardware developers.</div><br/></div></div><div id="38704353" class="c"><input type="checkbox" id="c-38704353" checked=""/><div class="controls bullet"><span class="by">pictureofabear</span><span>|</span><a href="#38702860">parent</a><span>|</span><a href="#38704961">prev</a><span>|</span><a href="#38699885">next</a><span>|</span><label class="collapse" for="c-38704353">[-]</label><label class="expand" for="c-38704353">[2 more]</label></div><br/><div class="children"><div class="content">Are you Australian? After &quot;beaut&quot; your whole comment flipped to an Aussie accent.</div><br/><div id="38704764" class="c"><input type="checkbox" id="c-38704764" checked=""/><div class="controls bullet"><span class="by">anotherevan</span><span>|</span><a href="#38702860">root</a><span>|</span><a href="#38704353">parent</a><span>|</span><a href="#38699885">next</a><span>|</span><label class="collapse" for="c-38704764">[-]</label><label class="expand" for="c-38704764">[1 more]</label></div><br/><div class="children"><div class="content">Well I wrote the whole thing with an Aussie accent. &quot;Beaut&quot; was just the first giveaway. :-)</div><br/></div></div></div></div></div></div><div id="38699885" class="c"><input type="checkbox" id="c-38699885" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#38702860">prev</a><span>|</span><a href="#38702733">next</a><span>|</span><label class="collapse" for="c-38699885">[-]</label><label class="expand" for="c-38699885">[4 more]</label></div><br/><div class="children"><div class="content">Interesting and fun project! I found the MFM encoding page particularly enlightening as it explained why you have to write a full sector at a time on a floppy, even though there&#x27;s nothing <i>physically</i> constraining you to that so far as I could see on the electromechanical&#x2F;hardware side of things.<p>And on that page the &quot;make sure the compiler didn&#x27;t inject 10,000 lines of boundary checks&quot; bit told me everything I needed to know about what language the project was written in :lol: - here&#x27;s the link to the driver: <a href="https:&#x2F;&#x2F;github.com&#x2F;SharpCoder&#x2F;floppy-driver-rs">https:&#x2F;&#x2F;github.com&#x2F;SharpCoder&#x2F;floppy-driver-rs</a><p>(Side note: I&#x27;m glad to see the Teensy continuing to get love; I adopted it back when it was at v1 and v2 as it was just such a complete no-brainer of a better choice than the Arduino stack everyone was using back then. I think now there&#x27;s even an Arduino-on-Teensy software stack, but I&#x27;ve moved to just using STM32 directly even for just fun home hacks and have greatly enjoyed coding for that target in rust.)</div><br/><div id="38701224" class="c"><input type="checkbox" id="c-38701224" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38699885">parent</a><span>|</span><a href="#38702733">next</a><span>|</span><label class="collapse" for="c-38701224">[-]</label><label class="expand" for="c-38701224">[3 more]</label></div><br/><div class="children"><div class="content">There is also Arduino on Raspberry Pi. The Arduino IDE is a bit annoying but the compatibility between platforms is really nice to see and makes a lot of boards a drop-in replacement for each other if you run out of a particular resource or need some other capability.</div><br/><div id="38705252" class="c"><input type="checkbox" id="c-38705252" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38699885">root</a><span>|</span><a href="#38701224">parent</a><span>|</span><a href="#38702733">next</a><span>|</span><label class="collapse" for="c-38705252">[-]</label><label class="expand" for="c-38705252">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There is also Arduino on Raspberry Pi.<p>I don&#x27;t think it&#x27;d be suitable for this task, though. The Pi may be faster, but accessing GPIOs from userspace is slow.</div><br/><div id="38706188" class="c"><input type="checkbox" id="c-38706188" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38699885">root</a><span>|</span><a href="#38705252">parent</a><span>|</span><a href="#38702733">next</a><span>|</span><label class="collapse" for="c-38706188">[-]</label><label class="expand" for="c-38706188">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run some tests and FastLED works well enough to drive matrix displays.<p>Note that you don&#x27;t <i>have</i> to run Linux, you can just stick to the Arduino eco-system, which is far more limited than what a full Linux environment would offer you, the Pi Pico is cheap for what it does and gives you an option with lots of memory in the footprint of the smaller Arduino&#x27;s.</div><br/></div></div></div></div></div></div></div></div><div id="38702733" class="c"><input type="checkbox" id="c-38702733" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38699885">prev</a><span>|</span><a href="#38700393">next</a><span>|</span><label class="collapse" for="c-38702733">[-]</label><label class="expand" for="c-38702733">[1 more]</label></div><br/><div class="children"><div class="content"><i>Fun fact! While I was developing my driver, I ruined many entire tracks by leaving this open for too long.</i><p>The write gate basically turns on the electromagnet in the head, which will do exactly what you&#x27;d expect that to. Early floppy drives&#x27; documentation actually came with schematics which show this more clearly.<p>Early hard drives based on ST-506 also have a very similar interface.</div><br/></div></div><div id="38700393" class="c"><input type="checkbox" id="c-38700393" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38702733">prev</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38700393">[-]</label><label class="expand" for="c-38700393">[11 more]</label></div><br/><div class="children"><div class="content">Interesting how author switches to assembly language for more precise reading, but keeps the &quot;read_data&quot; method as a separate non-assembly function. That introduces lots of branching in the code which is busy-loop-based and branch prediction is not what I&#x27;d want for consistent timing. It also introduces un-needed dependency: what if the next version of compiler changes the code? All timings (which are based on cycle-counting) will be off.<p>That said, Teensy 4.0 is 600 MHz ARM cpu, so there are 1000 cycles even between the shortest transitions.. some overhead is fine, the project is not exactly cpu-starved.<p>I also wonder if author has considered using a peripherals for precise signal capture? Something like timer in capture mode feeding into DMA buffer would allow hardware signal capture with very high precision and without any dependencies on exact instructions emitted.</div><br/><div id="38701292" class="c"><input type="checkbox" id="c-38701292" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#38700393">parent</a><span>|</span><a href="#38701123">next</a><span>|</span><label class="collapse" for="c-38701292">[-]</label><label class="expand" for="c-38701292">[1 more]</label></div><br/><div class="children"><div class="content">It would be a good match for some kind of input capture peripheral (the MCU does not have input capture per-se but it is an Cortex M7 so you can certainly build that out of interrupt matrix and some clever configuration of DMA engine) or for abusing SPI USRT if it can support such extremely long frames (which it probably can).</div><br/></div></div><div id="38701123" class="c"><input type="checkbox" id="c-38701123" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#38700393">parent</a><span>|</span><a href="#38701292">prev</a><span>|</span><a href="#38701522">next</a><span>|</span><label class="collapse" for="c-38701123">[-]</label><label class="expand" for="c-38701123">[2 more]</label></div><br/><div class="children"><div class="content">I think judging by the title and the mention of bit banging, the aim of this isn&#x27;t to get a robust reliable thing going on. I find hacking things together like this to be really fun and doesn&#x27;t feel like a job. sort of entertainment. but that&#x27;s just me perhaps.</div><br/><div id="38701687" class="c"><input type="checkbox" id="c-38701687" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38701123">parent</a><span>|</span><a href="#38701522">next</a><span>|</span><label class="collapse" for="c-38701687">[-]</label><label class="expand" for="c-38701687">[1 more]</label></div><br/><div class="children"><div class="content">So do I, but that&#x27;s more of the reason to keep things robust, no?<p>In my work projects, I can use the dangerous code like this - because we have compilers and libraries frozen, unit and integration tests, a complex testing process. We can do all the right efforts to ensure the things work, even if solution is intrinsically unreliable.<p>In my personal projects I write some stuff and start using it, the testing is minimal, and toolchain versions is &quot;whatever platformio decided to pull up today&quot;. I&#x27;d hate for my project to break just because I rebuilt it to add the new feature and meanwhile my compiler got upgraded. So I&#x27;d definitely abuse SPI port or something to get things reliable.</div><br/></div></div></div></div><div id="38701522" class="c"><input type="checkbox" id="c-38701522" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38700393">parent</a><span>|</span><a href="#38701123">prev</a><span>|</span><a href="#38701242">next</a><span>|</span><label class="collapse" for="c-38701522">[-]</label><label class="expand" for="c-38701522">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That introduces lots of branching in the code which is busy-loop-based and branch prediction is not what I&#x27;d want for consistent timing.<p>I don&#x27;t see how so basic a call would create conditional branches that would have to be predicted. Calling the function is an unconditional branch-and-link, after which it should just be doing a load and returning. (It&#x27;s LLVM with the equivalent of -O2, it&#x27;s not going to be doing anything weird.) Unless the return address isn&#x27;t cached in these processors?</div><br/></div></div><div id="38701242" class="c"><input type="checkbox" id="c-38701242" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#38700393">parent</a><span>|</span><a href="#38701522">prev</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38701242">[-]</label><label class="expand" for="c-38701242">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Teensy 4.0 is 600 MHz ARM cpu, so there are 1000 cycles even between the shortest transitions.<p>can you explain this a bit more? When you say &quot;transition&quot; are you talking about an individual transistor moving from on to off or vice versa?</div><br/><div id="38701573" class="c"><input type="checkbox" id="c-38701573" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38701242">parent</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38701573">[-]</label><label class="expand" for="c-38701573">[5 more]</label></div><br/><div class="children"><div class="content">&quot;transition&quot; is signal changing, from high to low or from low to high.<p>As described in the page, there are multiple signals changing when operating floppy (&quot;track 0&quot;, &quot;write gate&quot;, &quot;data&quot;, etc..). Of them the fastest one is &quot;data&quot;, so that&#x27;s what I am going to focus on.<p>The 2nd page of writeup [0] says:<p><pre><code>    A short transition (S) will nominally have 2us between bits, and represents 0b10
    A medium transition (M) will nominally have 3us between bits, and represents 0b100
    A long transition (L) will nominally have 4us between bits, and represents 0b1000
</code></pre>
So we are looking at 3, 4 or 5 microseconds between bits. To get this in CPU cycles, you multiply this by clock frequency - google can help you with units, searching for &quot;2 microseconds * 600 megahertz&quot; [1] shows the answer, 1200, right away. I&#x27;ve rounded this down to 1000, as there are two transitions per pulse and it is all very approximate anyway.<p>And then you use your embedded knowledge to assign meaning to the number: the CPU is ARM, so 1 instruction&#x2F;cycle is a good approximation (it could be more due to dual-issue or less due to jumps). So you have like 1000 instructions. Each function call in language like C or C++ might be a 5-20 instructions overhead, and you probably want to read that pin at least 10 times to detect both transitions. The tightest loop is also going to be a dozen instructions or less (read gpio, mask, compare, maybe jump out, increase, compare timeout, loop)<p>So.. you can do it in C&#x2F;C++ easily if your main loop involves no function calls (and you have no interrupts). If you use functions to read, your timing is going to be tight and those functions are better be super-optimized, you will be asking your compiler for a lot. Higher level languages like lua&#x2F;micropython are out of the question (at least for that loop). And as I learned from reading this, rust is also out of the question, although I wonder if there are some unsafe primitives which do not do any checking.<p>(and yes, there are transistors changing in the background all the time throughout the process, but I really don&#x27;t care much about them, they are on too low of the abstraction level)<p>[0] <a href="https:&#x2F;&#x2F;floppy.cafe&#x2F;mfm.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;floppy.cafe&#x2F;mfm.html</a><p>[1] <a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=2+microseconds+*+600+megahertz" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=2+microseconds+*+600+megaher...</a></div><br/><div id="38702045" class="c"><input type="checkbox" id="c-38702045" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38701573">parent</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38702045">[-]</label><label class="expand" for="c-38702045">[4 more]</label></div><br/><div class="children"><div class="content">&gt; And then you use your embedded knowledge to assign meaning to the number: the CPU is ARM, so 1 instruction&#x2F;cycle is a good approximation (it could be more due to dual-issue or less due to jumps). So you have like 1000 instructions. Each function call in language like C or C++ might be a 5-20 instructions overhead, and you probably want to read that pin at least 10 times to detect both transitions. The tightest loop is also going to be a dozen instructions or less (read gpio, mask, compare, maybe jump out, increase, compare timeout, loop)<p>Nit: That&#x27;s definitely the wrong approach though IMO.<p>So you want to accomplish two things:<p>1. Clock recovery -- Figuring out the timing of a signal<p>2. Decoding -- Figuring out what that signal means<p>These are two separate steps and should be done separately, be it in code or hardware. Though advanced protocols combine both into a single step, the older protocols (UART &#x2F; Floppy &#x2F; etc. etc.) had these two concepts separated into two different steps.<p>You won&#x27;t have 2us between bits: but instead 2.01us or 1.99us between bits, etc. etc. Clock-recovery mechanisms means that even in the face of worst-case timing differences, your code remains resilient.<p>Decoding is the step you&#x27;ve done here, but it should be done after clock-recovery.<p>-------------<p>Traditional clock recovery methods are phase-locked-loops (in hardware), or various XOR-loops (in software) to try and figure out the timing of the clock from the 0-1 and 1-0 transitions.<p>----<p>The traditional UART (ex: 9600 baud or 115200 baud) is ~16-ticks per bit. (IE: a 9600 baud UART needs to look at the signal 153600 times per second. A 115200 baud UART needs to look at the signal 1843200 times per second). The 16-times per bit helps you &quot;center your aim&quot; for the transition. You then typically aim at the center-3 timeslots (ex: count number 7, 8, and 9) for when to send and&#x2F;or read the signal.<p>--------<p>That being said, your analysis for &quot;how many instructions you have per timeslice to read the data&quot; is correct. I just feel like adding that the clock-recovery portion needs to be definitely addressed.</div><br/><div id="38702321" class="c"><input type="checkbox" id="c-38702321" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38702045">parent</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38702321">[-]</label><label class="expand" for="c-38702321">[3 more]</label></div><br/><div class="children"><div class="content">The idea there is that if you measure the timing between transitions precisely enough you do not have to do a real clock recovery. The FDD motors seem to be precise and stable enough (after some spin-up time) that this approach works and IIRC even many HW FDCs do something similar internally. But at the same time the low-level format is clearly designed to make some kind of PLL-based clock recovery scheme possible.<p>After all that is what the FM in MFM implies. There is an obvious parallel with the simplest approach to demodulating FSK (or for that matter DTMF) in digital domain, which works by counting&#x2F;timing zero transitions of the signal.<p>The UART receivers are similar in that there is no clock recovery, with the assumption that the clock is stable enough that any kind of frequency error or drift will be insignificant for the relatively short (usually 10bit) frame. The oversampling is there to align the sample point with middle of the symbol and the majority voting from multiple samples serves to average out effects of spiky noise that may be superimposed on the signal.</div><br/><div id="38702536" class="c"><input type="checkbox" id="c-38702536" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38702321">parent</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38702536">[-]</label><label class="expand" for="c-38702536">[2 more]</label></div><br/><div class="children"><div class="content">Pretty much all UART receivers I know of perform either 16x or 8x sampling to figure out where the start and end of bit-transitions are located. This is the clock-recovery mechanism.<p>You need to discover the edges of the clock, and make sure you read _AWAY_ from those edges. The bits are not well defined on the clock edges. Even with a 100% accurate clock, if you&#x27;re reading on the edges you&#x27;ll be very unreliable.<p>UARTs aim to read on the &quot;center&quot; of bits. (If there are 16x reads per bit, then the &quot;center&quot; is on reads 7, 8, and 9). You&#x27;ll want to stay away from reading on timeslot#1 or timeslot#16.</div><br/><div id="38704586" class="c"><input type="checkbox" id="c-38704586" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#38700393">root</a><span>|</span><a href="#38702536">parent</a><span>|</span><a href="#38702898">next</a><span>|</span><label class="collapse" for="c-38704586">[-]</label><label class="expand" for="c-38704586">[1 more]</label></div><br/><div class="children"><div class="content">For UART this is only about sampling away from the edges. The UART waveform does not have any feature that is usable for clock recovery, the only thing in there is that the start bit (ie. Mark) delineates the start of the frame, how many of the same bits there are is part of the payload. And the stop bit is there so that there is always a transition at the leading edge of the frame. You can do baud rate autodetection, but that is different concept than clock recovery and mostly doable in pure software (well, it is doable by Mk. 1 Eyeball, as the wrong baudrate produces somewhat obvious results).<p>Obviously there is a bit of history and the whole system was originally implemented electro-mechanically, which is the reason for things like two or more stopbits (it creates time for the mechanism to settle to the reset state) or even the concept of NUL character.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38702898" class="c"><input type="checkbox" id="c-38702898" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#38700393">prev</a><span>|</span><a href="#38701683">next</a><span>|</span><label class="collapse" for="c-38702898">[-]</label><label class="expand" for="c-38702898">[1 more]</label></div><br/><div class="children"><div class="content">The other side of this coin is emulating a floppy drive in software: <a href="https:&#x2F;&#x2F;github.com&#x2F;keirf&#x2F;flashfloppy">https:&#x2F;&#x2F;github.com&#x2F;keirf&#x2F;flashfloppy</a></div><br/></div></div><div id="38701683" class="c"><input type="checkbox" id="c-38701683" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#38702898">prev</a><span>|</span><a href="#38704298">next</a><span>|</span><label class="collapse" for="c-38701683">[-]</label><label class="expand" for="c-38701683">[4 more]</label></div><br/><div class="children"><div class="content">Would be pretty cool to get this working on a bit-banging monster, like RP2040 (Raspberry Pi Pico).<p>Just a few bucks and sports a 12 Mbit&#x2F;s USB interface (and wifi for pico-w).</div><br/><div id="38701830" class="c"><input type="checkbox" id="c-38701830" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38701683">parent</a><span>|</span><a href="#38704298">next</a><span>|</span><label class="collapse" for="c-38701830">[-]</label><label class="expand" for="c-38701830">[3 more]</label></div><br/><div class="children"><div class="content">Take a look at the Greaseweazle <a href="https:&#x2F;&#x2F;github.com&#x2F;keirf&#x2F;greaseweazle">https:&#x2F;&#x2F;github.com&#x2F;keirf&#x2F;greaseweazle</a> to see what a really high-end solution in this space looks like.  It&#x27;s intended as a from scratch alternative to the better-known KryoFlux.</div><br/><div id="38704383" class="c"><input type="checkbox" id="c-38704383" checked=""/><div class="controls bullet"><span class="by">CompuHacker</span><span>|</span><a href="#38701683">root</a><span>|</span><a href="#38701830">parent</a><span>|</span><a href="#38704298">next</a><span>|</span><label class="collapse" for="c-38704383">[-]</label><label class="expand" for="c-38704383">[2 more]</label></div><br/><div class="children"><div class="content">The Greaseweazle V4, using the FluxEngine GUI, allowed me to capture 1,900 Amiga 880K disks in a row. Each disk took 50 seconds under ideal conditions. I absolutely recommend both for homogeneous collections of disks.<p>Most of the effort was in entering the text of the labels manually or restarting and switching between capture formats when a Mac or IBM disk cropped up. FluxEngine uses the <i>expected</i> format to decide whether the track most recently read contains errors; and if so, re-read the track 3-5 times, quintupling overall read-times.<p>All that&#x27;s needed now is a floppy handling robot, a macro for recording the physical disk and label descriptions, and maybe a container format for all the capture products; thumbnails, cover art, metadata, flux images; that emulators and disk utilities can read, and that the community can re-distribute easily.</div><br/><div id="38706054" class="c"><input type="checkbox" id="c-38706054" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38701683">root</a><span>|</span><a href="#38704383">parent</a><span>|</span><a href="#38704298">next</a><span>|</span><label class="collapse" for="c-38706054">[-]</label><label class="expand" for="c-38706054">[1 more]</label></div><br/><div class="children"><div class="content">Nice, you should consider uploading these dumps to the Internet Archive so that they can be preserved for the foreseeable future.  (Of course, that is unless they&#x27;re strictly private data that was never made available, even unofficially.)</div><br/></div></div></div></div></div></div></div></div><div id="38704298" class="c"><input type="checkbox" id="c-38704298" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#38701683">prev</a><span>|</span><a href="#38701977">next</a><span>|</span><label class="collapse" for="c-38704298">[-]</label><label class="expand" for="c-38704298">[2 more]</label></div><br/><div class="children"><div class="content">Could one generate magnetic flux with software and a coil, so that a physical floppy drive believed it read a floppy disk, but it wasn&#x27;t a real disk, but just a coil (or 80 tiny coils, on for each track)
???</div><br/><div id="38704827" class="c"><input type="checkbox" id="c-38704827" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#38704298">parent</a><span>|</span><a href="#38701977">next</a><span>|</span><label class="collapse" for="c-38704827">[-]</label><label class="expand" for="c-38704827">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this was a thing back in the day to read flash memory cards in a floppy drive (this product used a single head and special drivers since it needed to support disks bigger than 1.4 MB) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FlashPath" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FlashPath</a></div><br/></div></div></div></div><div id="38701977" class="c"><input type="checkbox" id="c-38701977" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#38704298">prev</a><span>|</span><a href="#38701202">next</a><span>|</span><label class="collapse" for="c-38701977">[-]</label><label class="expand" for="c-38701977">[3 more]</label></div><br/><div class="children"><div class="content">&gt; To enable the motor, pull this pin LOW and then wait 500ms.<p>No wonder floppies were sooo daaarn sloooooow.</div><br/><div id="38702309" class="c"><input type="checkbox" id="c-38702309" checked=""/><div class="controls bullet"><span class="by">mras0</span><span>|</span><a href="#38701977">parent</a><span>|</span><a href="#38703415">next</a><span>|</span><label class="collapse" for="c-38702309">[-]</label><label class="expand" for="c-38702309">[1 more]</label></div><br/><div class="children"><div class="content">Once the drive is spinning that doesn&#x27;t matter though. Floppies are slow by modern standards mostly because you only get a new (decoded) bit around every 2nd (or for DD drives 4th) microsecond, and the drive takes some time stepping to the next cylinder (track).</div><br/></div></div><div id="38703415" class="c"><input type="checkbox" id="c-38703415" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38701977">parent</a><span>|</span><a href="#38702309">prev</a><span>|</span><a href="#38701202">next</a><span>|</span><label class="collapse" for="c-38703415">[-]</label><label class="expand" for="c-38703415">[1 more]</label></div><br/><div class="children"><div class="content">They felt so fast (Amiga).<p>Relative to the datasette (C64) I was used to.</div><br/></div></div></div></div><div id="38701202" class="c"><input type="checkbox" id="c-38701202" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38701977">prev</a><span>|</span><a href="#38700505">next</a><span>|</span><label class="collapse" for="c-38701202">[-]</label><label class="expand" for="c-38701202">[1 more]</label></div><br/><div class="children"><div class="content">The Teensy is an incredibly powerful platform for its size. I never cease to be amazed at what people manage to get out of them.</div><br/></div></div><div id="38700505" class="c"><input type="checkbox" id="c-38700505" checked=""/><div class="controls bullet"><span class="by">maaarghk</span><span>|</span><a href="#38701202">prev</a><span>|</span><a href="#38700248">next</a><span>|</span><label class="collapse" for="c-38700505">[-]</label><label class="expand" for="c-38700505">[2 more]</label></div><br/><div class="children"><div class="content">Could be useful &#x2F; fun to make a USB floppy drive which supports non standard layouts like Commodore and AKAI.</div><br/><div id="38701156" class="c"><input type="checkbox" id="c-38701156" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#38700505">parent</a><span>|</span><a href="#38700248">next</a><span>|</span><label class="collapse" for="c-38701156">[-]</label><label class="expand" for="c-38701156">[1 more]</label></div><br/><div class="children"><div class="content">A couple of examples:<p>- <a href="https:&#x2F;&#x2F;decromancer.ca&#x2F;greaseweazle&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;decromancer.ca&#x2F;greaseweazle&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;www.cbmstuff.com&#x2F;index.php?route=product&#x2F;product&amp;product_id=52" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cbmstuff.com&#x2F;index.php?route=product&#x2F;product&amp;pro...</a><p>I think it&#x27;d be interesting to connect a high sensitivity &#x2F; resolution sampling probe directly to the analog output of the drive heads. You could do software-defined signal processing to potentially recover damaged data. These USB-based tools are getting the signal after being amplified in the analog domain and processed by the drive&#x27;s electronics.</div><br/></div></div></div></div><div id="38700248" class="c"><input type="checkbox" id="c-38700248" checked=""/><div class="controls bullet"><span class="by">dusted</span><span>|</span><a href="#38700505">prev</a><span>|</span><a href="#38701896">next</a><span>|</span><label class="collapse" for="c-38700248">[-]</label><label class="expand" for="c-38700248">[6 more]</label></div><br/><div class="children"><div class="content">side select.. so.. that basically flips between upper or lower read&#x2F;write heads..<p>That wire though..<p>It seems they could have gotten twice the speed by having two read and two write pins, one one additional pin.</div><br/><div id="38700752" class="c"><input type="checkbox" id="c-38700752" checked=""/><div class="controls bullet"><span class="by">zaxomi</span><span>|</span><a href="#38700248">parent</a><span>|</span><a href="#38703185">next</a><span>|</span><label class="collapse" for="c-38700752">[-]</label><label class="expand" for="c-38700752">[3 more]</label></div><br/><div class="children"><div class="content">The first floppy from 1967 only had one side. Adding one signal to select side was an easy solution to increase the capacity without to much modification of the controller. Adding the capability to read from both heads at the same time would require much more modifications, and more memory.</div><br/><div id="38702207" class="c"><input type="checkbox" id="c-38702207" checked=""/><div class="controls bullet"><span class="by">FullyFunctional</span><span>|</span><a href="#38700248">root</a><span>|</span><a href="#38700752">parent</a><span>|</span><a href="#38703185">next</a><span>|</span><label class="collapse" for="c-38702207">[-]</label><label class="expand" for="c-38702207">[2 more]</label></div><br/><div class="children"><div class="content">Undeniably true; so much of computing hardware (and software) looks archaic and bizarre because it&#x27;s the process of a long chain of backwards compatible changes (don&#x27;t get me started on ATAPI).<p>But that aside, like dusted I too wonder just _how_ hard it would have been for a company like, say Apple, to demand the extra circuit.  Might not have been worth it for just 2X speedup.<p>Now I want to build a 10X floppy RAID ...</div><br/><div id="38703195" class="c"><input type="checkbox" id="c-38703195" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#38700248">root</a><span>|</span><a href="#38702207">parent</a><span>|</span><a href="#38703185">next</a><span>|</span><label class="collapse" for="c-38703195">[-]</label><label class="expand" for="c-38703195">[1 more]</label></div><br/><div class="children"><div class="content">Everyone had that extra circuit in the floppy controller, it was just somewhere else.<p>Ask for it to be integrated and now you go from being able to buy drive from almost anyone to only one vendor.<p>It is odd it never improved and stayed as simple as it was until the end of floppies. The power of history I guess.</div><br/></div></div></div></div></div></div><div id="38703185" class="c"><input type="checkbox" id="c-38703185" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#38700248">parent</a><span>|</span><a href="#38700752">prev</a><span>|</span><a href="#38701896">next</a><span>|</span><label class="collapse" for="c-38703185">[-]</label><label class="expand" for="c-38703185">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, but then you need twice the CPU cycles to encode&#x2F;decode it. And that may have been the limiting factor when first introduced.<p>After that it’s all backwards compatibility. No one wants a new interface.<p>I remember the first time I saw a floppy pin out, I was dumbfounded. I expected it to be far more complex like IDE. I didn’t realize the term “floppy controller” would be so literal.<p>Of course in retrospect it makes sense. IDE = Integrated Drive Electronics. I assume the hard disks that came before worked more like the floppy and their controllers did more work too.<p>I guess no one cared enough to enhance the poor floppy drive until we got to things like LS-120 that I assume flat out couldn’t use the old interface and never took off anyway.</div><br/><div id="38704996" class="c"><input type="checkbox" id="c-38704996" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#38700248">root</a><span>|</span><a href="#38703185">parent</a><span>|</span><a href="#38701896">next</a><span>|</span><label class="collapse" for="c-38704996">[-]</label><label class="expand" for="c-38704996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I assume the hard disks that came before worked more like the floppy and their controllers did more work too.</i><p>You nailed it. The first hard disk interfaces for IBM PCs were basically identical to the floppy disk controller just faster&#x2F;bigger.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ST506&#x2F;ST412" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ST506&#x2F;ST412</a><p><i>The ST506 interface between the controller and drive was derived from the Shugart Associates SA1000 interface,[5] which was in turn based upon the floppy disk drive interface,[6] thereby making disk controller design relatively easy</i><p>But as they started wanting to make disk reads faster and faster, the drive part had to get smarter and smarter<p><i>The ST412 disk drive, among other improvements, added buffered seek capability to the interface. In this mode, the controller can send STEP pulses to the drive as fast as it can receive them, without having to wait for the mechanism to settle. An onboard microprocessor in the drive then moves the mechanism to the desired track as fast as possible</i><p>At that point the drive is starting to getting smart enough that you might as well integrate the whole controller on there.<p>The original versions of IDE&#x2F;ATA were basically just an extension of ISA, and the first &quot;IDE cards&quot; were just a bridge to the ISA slot they went in.<p>You also had &quot;hard cards&quot; where the hard disk itself was integrated onto the ISA card... <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hardcard" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hardcard</a></div><br/></div></div></div></div></div></div><div id="38701896" class="c"><input type="checkbox" id="c-38701896" checked=""/><div class="controls bullet"><span class="by">quijoteuniv</span><span>|</span><a href="#38700248">prev</a><span>|</span><a href="#38700007">next</a><span>|</span><label class="collapse" for="c-38701896">[-]</label><label class="expand" for="c-38701896">[1 more]</label></div><br/><div class="children"><div class="content">I love fun with flags!</div><br/></div></div><div id="38700010" class="c"><input type="checkbox" id="c-38700010" checked=""/><div class="controls bullet"><span class="by">sked64</span><span>|</span><a href="#38700007">prev</a><span>|</span><label class="collapse" for="c-38700010">[-]</label><label class="expand" for="c-38700010">[1 more]</label></div><br/><div class="children"><div class="content">super cool very retro</div><br/></div></div></div></div></div></div></div></body></html>