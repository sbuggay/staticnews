<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683709263271" as="style"/><link rel="stylesheet" href="styles.css?v=1683709263271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://seclists.org/oss-sec/2023/q2/133">Linux kernel use-after-free in Netfilter, local privilege escalation</a> <span class="domain">(<a href="https://seclists.org">seclists.org</a>)</span></div><div class="subtext"><span>kuizu</span> | <span>76 comments</span></div><br/><div><div id="35880852" class="c"><input type="checkbox" id="c-35880852" checked=""/><div class="controls bullet"><span class="by">l33tman</span><span>|</span><a href="#35882444">next</a><span>|</span><label class="collapse" for="c-35880852">[-]</label><label class="expand" for="c-35880852">[24 more]</label></div><br/><div class="children"><div class="content">&quot;We developed an exploit that allows unprivileged local users to start a
root shell by abusing the above issue. That exploit was shared
privately with &lt;security () kernel org&gt; to assist with fix development.
Somebody from the Linux kernel team then emailed the proposed fix to
&lt;linux-distros () vs openwall org&gt; and that email also included a link to
download our description of exploitation techniques and our exploit
source code.<p>Therefore, according to the linux-distros list policy, the exploit must
be published within 7 days from this advisory. In order to comply with
that policy, I intend to publish both the description of exploitation
techniques and also the exploit source code on Monday 15th by email to
this list.&quot;<p>Interesting.. they didn&#x27;t write what conditions have to be met for it to be exploitable. Also interesting that someone screwed up and accidentally forwarded an email including the exploit to a broad mailing list...<p>Part of the nf modules are active if you have iptables, which you have if you run ufw (for example), so pretty broad exploit if that&#x27;s all that&#x27;s required, but the specific module in question in the patch, nf_tables, is not loaded on my Ubuntu 20.04LTS 5.40 kernel running iptables&#x2F;ufw at least.</div><br/><div id="35881173" class="c"><input type="checkbox" id="c-35881173" checked=""/><div class="controls bullet"><span class="by">pizzalife</span><span>|</span><a href="#35880852">parent</a><span>|</span><a href="#35883156">next</a><span>|</span><label class="collapse" for="c-35881173">[-]</label><label class="expand" for="c-35881173">[9 more]</label></div><br/><div class="children"><div class="content">&gt; but the specific module in question in the patch, nf_tables, is not loaded on my Ubuntu 20.04LTS 5.40 kernel running iptables&#x2F;ufw at least<p>This doesn&#x27;t matter since Linux has autoloading of most network modules, and you can cause the modules to be loaded on Ubuntu since it supports unprivileged user&#x2F;net namespaces.<p><pre><code>  ubuntu:~% grep DISTRIB_DESCRIPTION &#x2F;etc&#x2F;lsb-release
  DISTRIB_DESCRIPTION=&quot;Ubuntu 22.04.2 LTS&quot;
  ubuntu:~% lsmod|grep nf_table
  ubuntu:~% unshare -U -m -n -r
  ubuntu:~% nft add table inet filter
  ubuntu:~% lsmod|grep nf_table
  nf_tables             249856  0</code></pre></div><br/><div id="35881919" class="c"><input type="checkbox" id="c-35881919" checked=""/><div class="controls bullet"><span class="by">veonik</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881173">parent</a><span>|</span><a href="#35883156">next</a><span>|</span><label class="collapse" for="c-35881919">[-]</label><label class="expand" for="c-35881919">[8 more]</label></div><br/><div class="children"><div class="content">Yikes... are other popular distros shipping with unprivileged user namespaces enabled by default?</div><br/><div id="35883552" class="c"><input type="checkbox" id="c-35883552" checked=""/><div class="controls bullet"><span class="by">marcthe12</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881919">parent</a><span>|</span><a href="#35882166">next</a><span>|</span><label class="collapse" for="c-35883552">[-]</label><label class="expand" for="c-35883552">[1 more]</label></div><br/><div class="children"><div class="content">Most, I think Debian has patch to be disabled at runtime via sysctl. The reason is that most containers or sandboxing techniques are root only unless you mix it with user namescapes. So most container or sandbox software use suid(firejail) , root daemon(docker) or user namescapes (podman and flatpak). Looking at the cves, user namespaces is probably the safer option</div><br/></div></div><div id="35882166" class="c"><input type="checkbox" id="c-35882166" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881919">parent</a><span>|</span><a href="#35883552">prev</a><span>|</span><a href="#35884258">next</a><span>|</span><label class="collapse" for="c-35882166">[-]</label><label class="expand" for="c-35882166">[3 more]</label></div><br/><div class="children"><div class="content">That is part of enabling rootless containers on rhel or similar.</div><br/><div id="35882895" class="c"><input type="checkbox" id="c-35882895" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35882166">parent</a><span>|</span><a href="#35884258">next</a><span>|</span><label class="collapse" for="c-35882895">[-]</label><label class="expand" for="c-35882895">[2 more]</label></div><br/><div class="children"><div class="content">should have re-written it in rust.</div><br/><div id="35884008" class="c"><input type="checkbox" id="c-35884008" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35882895">parent</a><span>|</span><a href="#35884258">next</a><span>|</span><label class="collapse" for="c-35884008">[-]</label><label class="expand" for="c-35884008">[1 more]</label></div><br/><div class="children"><div class="content">Rewritten what? The container runtime will need the same access regardless of what it&#x27;s written in, and rewriting all of Linux (the kernel) would be... ambitious, although it is adopting rust incrementally.</div><br/></div></div></div></div></div></div><div id="35884258" class="c"><input type="checkbox" id="c-35884258" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881919">parent</a><span>|</span><a href="#35882166">prev</a><span>|</span><a href="#35883271">next</a><span>|</span><label class="collapse" for="c-35884258">[-]</label><label class="expand" for="c-35884258">[2 more]</label></div><br/><div class="children"><div class="content">Do you need a user namespace? I&#x27;d expect a network namespace to be enough. Am I missing something?<p>Edit: should&#x27;ve read better, this seems to need CLONE_NEWUSER.</div><br/><div id="35884416" class="c"><input type="checkbox" id="c-35884416" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35884258">parent</a><span>|</span><a href="#35883271">next</a><span>|</span><label class="collapse" for="c-35884416">[-]</label><label class="expand" for="c-35884416">[1 more]</label></div><br/><div class="children"><div class="content">You need CAP_SYS_ADMIN to create a new network namespace.</div><br/></div></div></div></div><div id="35883271" class="c"><input type="checkbox" id="c-35883271" checked=""/><div class="controls bullet"><span class="by">failsecure</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881919">parent</a><span>|</span><a href="#35884258">prev</a><span>|</span><a href="#35883156">next</a><span>|</span><label class="collapse" for="c-35883271">[-]</label><label class="expand" for="c-35883271">[1 more]</label></div><br/><div class="children"><div class="content">Yes and this decision haunts distros like Ubuntu over and over again. There&#x27;s no easy win though.</div><br/></div></div></div></div></div></div><div id="35883156" class="c"><input type="checkbox" id="c-35883156" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#35880852">parent</a><span>|</span><a href="#35881173">prev</a><span>|</span><a href="#35881197">next</a><span>|</span><label class="collapse" for="c-35883156">[-]</label><label class="expand" for="c-35883156">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  Somebody from the Linux kernel team then emailed the proposed fix to &lt;linux-distros () vs openwall org&gt; and that email also included a link to download our description of exploitation techniques and our exploit source code.<p>&gt; Therefore, according to the linux-distros list policy, the exploit must be published within 7 days from this advisory. In order to comply with that policy, [...]<p>What? Someone publishes information about your vuln to a random mailing list, and this somehow creates an obligation on you to follow that mailing list&#x27;s policies? I don&#x27;t get it.</div><br/><div id="35883267" class="c"><input type="checkbox" id="c-35883267" checked=""/><div class="controls bullet"><span class="by">batch12</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35883156">parent</a><span>|</span><a href="#35883920">next</a><span>|</span><label class="collapse" for="c-35883267">[-]</label><label class="expand" for="c-35883267">[1 more]</label></div><br/><div class="children"><div class="content">Maybe they consider the exploit is in the wild when sending to a distro that large[0] with recipients that aren&#x27;t provably trustworthy.<p>[0] <a href="https:&#x2F;&#x2F;oss-security.openwall.org&#x2F;wiki&#x2F;mailing-lists&#x2F;distros" rel="nofollow">https:&#x2F;&#x2F;oss-security.openwall.org&#x2F;wiki&#x2F;mailing-lists&#x2F;distros</a></div><br/></div></div><div id="35883920" class="c"><input type="checkbox" id="c-35883920" checked=""/><div class="controls bullet"><span class="by">amatecha</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35883156">parent</a><span>|</span><a href="#35883267">prev</a><span>|</span><a href="#35883264">next</a><span>|</span><label class="collapse" for="c-35883920">[-]</label><label class="expand" for="c-35883920">[1 more]</label></div><br/><div class="children"><div class="content">I believe they are referring to this:<p><a href="https:&#x2F;&#x2F;oss-security.openwall.org&#x2F;wiki&#x2F;mailing-lists&#x2F;distros" rel="nofollow">https:&#x2F;&#x2F;oss-security.openwall.org&#x2F;wiki&#x2F;mailing-lists&#x2F;distros</a><p>&gt; Please note that the maximum acceptable embargo period for issues disclosed to these lists is 14 days. Please do not ask for a longer embargo. In fact, embargo periods shorter than 7 days are preferable.</div><br/></div></div><div id="35883264" class="c"><input type="checkbox" id="c-35883264" checked=""/><div class="controls bullet"><span class="by">failsecure</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35883156">parent</a><span>|</span><a href="#35883920">prev</a><span>|</span><a href="#35881197">next</a><span>|</span><label class="collapse" for="c-35883264">[-]</label><label class="expand" for="c-35883264">[1 more]</label></div><br/><div class="children"><div class="content">Maybe linux-distros has a poc or GTFO rule in place to keep the unchecked &quot;I can get root on your box with this one weird trick but I won&#x27;t tell you how&quot; emails to a minimum. Just a guess though.</div><br/></div></div></div></div><div id="35881197" class="c"><input type="checkbox" id="c-35881197" checked=""/><div class="controls bullet"><span class="by">thelastparadise</span><span>|</span><a href="#35880852">parent</a><span>|</span><a href="#35883156">prev</a><span>|</span><a href="#35881220">next</a><span>|</span><label class="collapse" for="c-35881197">[-]</label><label class="expand" for="c-35881197">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the bug itself is newsworthy. The existence of the exploit code, and the way that it was accidentally published, I think are.</div><br/><div id="35881211" class="c"><input type="checkbox" id="c-35881211" checked=""/><div class="controls bullet"><span class="by">pizzalife</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881197">parent</a><span>|</span><a href="#35881220">next</a><span>|</span><label class="collapse" for="c-35881211">[-]</label><label class="expand" for="c-35881211">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s exploitable by an unprivileged user on the most popular distro out there (Ubuntu). I would say it&#x27;s newsworthy.</div><br/></div></div></div></div><div id="35881220" class="c"><input type="checkbox" id="c-35881220" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#35880852">parent</a><span>|</span><a href="#35881197">prev</a><span>|</span><a href="#35881382">next</a><span>|</span><label class="collapse" for="c-35881220">[-]</label><label class="expand" for="c-35881220">[5 more]</label></div><br/><div class="children"><div class="content">What’s actually reasonable here. I’m all for exploit code becoming public eventually, but I think it’s silly to drop it immediately after a fix has been released, or before, in almost all scenarios (unless there’s been 90+ days or the issue marked as wontfix)</div><br/><div id="35882386" class="c"><input type="checkbox" id="c-35882386" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881220">parent</a><span>|</span><a href="#35881382">next</a><span>|</span><label class="collapse" for="c-35882386">[-]</label><label class="expand" for="c-35882386">[4 more]</label></div><br/><div class="children"><div class="content">Odds are that well-resourced attackers already have the exploit by now. Making it public lets users decide if this is important to them and come up with their own mitigations.</div><br/><div id="35884591" class="c"><input type="checkbox" id="c-35884591" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35882386">parent</a><span>|</span><a href="#35883459">next</a><span>|</span><label class="collapse" for="c-35884591">[-]</label><label class="expand" for="c-35884591">[1 more]</label></div><br/><div class="children"><div class="content">The link to the exploit accidentally went public. Anyone can have it.</div><br/></div></div><div id="35883459" class="c"><input type="checkbox" id="c-35883459" checked=""/><div class="controls bullet"><span class="by">j_walter</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35882386">parent</a><span>|</span><a href="#35884591">prev</a><span>|</span><a href="#35881382">next</a><span>|</span><label class="collapse" for="c-35883459">[-]</label><label class="expand" for="c-35883459">[2 more]</label></div><br/><div class="children"><div class="content">Once they issue the patch...it&#x27;s only a matter of time till a good chunk of reasonably decent coders can develop the exploit.  Once the premise is released...yeah the top exploit coders will have this in a few hours.</div><br/><div id="35883794" class="c"><input type="checkbox" id="c-35883794" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35883459">parent</a><span>|</span><a href="#35881382">next</a><span>|</span><label class="collapse" for="c-35883794">[-]</label><label class="expand" for="c-35883794">[1 more]</label></div><br/><div class="children"><div class="content">So we lower the bar to all adversaries with no benefit?<p>If you can read exploit code to determine if patching is worth it for your use case, you can probably also read diffs for the same outcome.<p>I’m not saying don’t release them, but releasing them with short notice seems irresponsible, without much benefit to defenders.</div><br/></div></div></div></div></div></div></div></div><div id="35881382" class="c"><input type="checkbox" id="c-35881382" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#35880852">parent</a><span>|</span><a href="#35881220">prev</a><span>|</span><a href="#35882444">next</a><span>|</span><label class="collapse" for="c-35881382">[-]</label><label class="expand" for="c-35881382">[3 more]</label></div><br/><div class="children"><div class="content">What a dumb policy.  Why have the disclosure time be so soon?  This thing will be in the wild before folks can upgrade if I&#x27;m understanding this correctly.</div><br/><div id="35881512" class="c"><input type="checkbox" id="c-35881512" checked=""/><div class="controls bullet"><span class="by">krastanov</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881382">parent</a><span>|</span><a href="#35883443">next</a><span>|</span><label class="collapse" for="c-35881512">[-]</label><label class="expand" for="c-35881512">[1 more]</label></div><br/><div class="children"><div class="content">The thing is already in the wild because someone on the private mailing list already accidentally mailed it to the public mailing list.</div><br/></div></div><div id="35883443" class="c"><input type="checkbox" id="c-35883443" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35880852">root</a><span>|</span><a href="#35881382">parent</a><span>|</span><a href="#35881512">prev</a><span>|</span><a href="#35882444">next</a><span>|</span><label class="collapse" for="c-35883443">[-]</label><label class="expand" for="c-35883443">[1 more]</label></div><br/><div class="children"><div class="content">You have a few options for dealing with problems like this.<p>You can &quot;apt update; apt upgrade&quot; then reboot when a new kernel is available.<p>Oracle has also offered Ksplice for free on Ubuntu for many years, and I&#x27;m sure that patch will be available promptly.<p><a href="https:&#x2F;&#x2F;ksplice.oracle.com&#x2F;try&#x2F;desktop" rel="nofollow">https:&#x2F;&#x2F;ksplice.oracle.com&#x2F;try&#x2F;desktop</a><p>Otherwise, Kernelcare is available for a fee. I think Canonical also has paid kernel patches.</div><br/></div></div></div></div></div></div><div id="35882444" class="c"><input type="checkbox" id="c-35882444" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35880852">prev</a><span>|</span><a href="#35882523">next</a><span>|</span><label class="collapse" for="c-35882444">[-]</label><label class="expand" for="c-35882444">[24 more]</label></div><br/><div class="children"><div class="content">There&#x27;s easily thousands of such bugs hidden in the kernel.<p>Reminder the kernel has over ten million LoCs, or megabytes of object code.<p>Perhaps we should start thinking about whether it is a good idea to run something this large in supervisor mode, with full privileges.<p>I wouldn&#x27;t say it is sensible in a world where seL4 exists.</div><br/><div id="35883127" class="c"><input type="checkbox" id="c-35883127" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35882591">next</a><span>|</span><label class="collapse" for="c-35883127">[-]</label><label class="expand" for="c-35883127">[1 more]</label></div><br/><div class="children"><div class="content">It won&#x27;t make that big of a difference. If you exploit the networking layer you could intercept any local traffic, which will mostly be unencrypted, and communicate with outside attackers. You are probably owned by that point unless you treated localhost as untrusted.<p>It&#x27;s like why it doesn&#x27;t matter if you are running as root or not. The user account has access to whats important, like a database or keychain.</div><br/></div></div><div id="35882591" class="c"><input type="checkbox" id="c-35882591" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35883127">prev</a><span>|</span><a href="#35883512">next</a><span>|</span><label class="collapse" for="c-35882591">[-]</label><label class="expand" for="c-35882591">[8 more]</label></div><br/><div class="children"><div class="content">Microkernel does seem the only sensible path forward. Even if the kernel is slowly rustified, going to be playing security whack-a-mole for a long time.</div><br/><div id="35882773" class="c"><input type="checkbox" id="c-35882773" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882591">parent</a><span>|</span><a href="#35883068">next</a><span>|</span><label class="collapse" for="c-35882773">[-]</label><label class="expand" for="c-35882773">[4 more]</label></div><br/><div class="children"><div class="content">Back in the day when the micro-kernel&#x2F;monolith flamewars were raging, the arguments for monolith were about improved performance and lower memory usage.  I haven&#x27;t seen much discussion on this topic for years, but at least those two arguments have not aged well.</div><br/><div id="35884960" class="c"><input type="checkbox" id="c-35884960" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882773">parent</a><span>|</span><a href="#35884642">next</a><span>|</span><label class="collapse" for="c-35884960">[-]</label><label class="expand" for="c-35884960">[1 more]</label></div><br/><div class="children"><div class="content">Mostly because the cloud is based on microkernel like approach regardless of the kernel.<p>Hypervisors, userspace drivers, containers, language runtime sandboxes, bytecode deployments, driver and kernel sandboxes (safe kernel &#x2F; driver guard),container only distributions,...</div><br/></div></div><div id="35884642" class="c"><input type="checkbox" id="c-35884642" checked=""/><div class="controls bullet"><span class="by">aflag</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882773">parent</a><span>|</span><a href="#35884960">prev</a><span>|</span><a href="#35883068">next</a><span>|</span><label class="collapse" for="c-35884642">[-]</label><label class="expand" for="c-35884642">[2 more]</label></div><br/><div class="children"><div class="content">Why not? It isn&#x27;t clear to me why monolithic kernel wouldn&#x27;t still have better performance.</div><br/><div id="35884931" class="c"><input type="checkbox" id="c-35884931" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35884642">parent</a><span>|</span><a href="#35883068">next</a><span>|</span><label class="collapse" for="c-35884931">[-]</label><label class="expand" for="c-35884931">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter with layers hypervisors, virtualization, containers and sandboxes running on top.<p>All mitigations to achieve microkernel like capabilities.</div><br/></div></div></div></div></div></div><div id="35883068" class="c"><input type="checkbox" id="c-35883068" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882591">parent</a><span>|</span><a href="#35882773">prev</a><span>|</span><a href="#35883303">next</a><span>|</span><label class="collapse" for="c-35883068">[-]</label><label class="expand" for="c-35883068">[1 more]</label></div><br/><div class="children"><div class="content">For rack servers you could probably get away with a number of microkernel os today. Desktop has clear options in that regard, but you are giving up op n source.</div><br/></div></div><div id="35883303" class="c"><input type="checkbox" id="c-35883303" checked=""/><div class="controls bullet"><span class="by">CorbetL</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882591">parent</a><span>|</span><a href="#35883068">prev</a><span>|</span><a href="#35883512">next</a><span>|</span><label class="collapse" for="c-35883303">[-]</label><label class="expand" for="c-35883303">[2 more]</label></div><br/><div class="children"><div class="content">Linux may eventually become a microkernel with most IPC done via io_uring, but it may take 20 years to reach this state.</div><br/><div id="35884364" class="c"><input type="checkbox" id="c-35884364" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35883303">parent</a><span>|</span><a href="#35883512">next</a><span>|</span><label class="collapse" for="c-35884364">[-]</label><label class="expand" for="c-35884364">[1 more]</label></div><br/><div class="children"><div class="content">Right now it seems microvms are the way. Build an extremely minimal tailored kernel+userland for network-facing components. If you don&#x27;t have nf_tables built-in (and it&#x27;s not loadable because not present) this vulnerability isn&#x27;t a problem. I mean, right now to use it one would have to chain it with a RCE on your userland app (or on the kernel but just skip the nf_tables step then...). Then one would have to escape the VM, then if you&#x27;re using firecracker or crosvm, you&#x27;ll have to break seccomp. Still imaginable, but by then I guess the next kernel (or userland app) fix release is already available :-) and you&#x27;re already rebooting your microvm.<p>If you can CI&#x2F;CD in minutes a reduced kernel+app and reboot in 100ms your network-facing thing (be it nginx or haproxy) you might just take latest vanilla anyway...</div><br/></div></div></div></div></div></div><div id="35883512" class="c"><input type="checkbox" id="c-35883512" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35882591">prev</a><span>|</span><a href="#35882781">next</a><span>|</span><label class="collapse" for="c-35883512">[-]</label><label class="expand" for="c-35883512">[4 more]</label></div><br/><div class="children"><div class="content">Who&#x27;s going to make seL4 perform comparably to Linux?</div><br/><div id="35884206" class="c"><input type="checkbox" id="c-35884206" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35883512">parent</a><span>|</span><a href="#35882781">next</a><span>|</span><label class="collapse" for="c-35884206">[-]</label><label class="expand" for="c-35884206">[3 more]</label></div><br/><div class="children"><div class="content">Why would we need to slow seL4 down?</div><br/><div id="35884241" class="c"><input type="checkbox" id="c-35884241" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35884206">parent</a><span>|</span><a href="#35882781">next</a><span>|</span><label class="collapse" for="c-35884241">[-]</label><label class="expand" for="c-35884241">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really in the mood for trolling.</div><br/><div id="35884922" class="c"><input type="checkbox" id="c-35884922" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35884241">parent</a><span>|</span><a href="#35882781">next</a><span>|</span><label class="collapse" for="c-35884922">[-]</label><label class="expand" for="c-35884922">[1 more]</label></div><br/><div class="children"><div class="content">The name-calling is uncalled for.<p>To elaborate, seL4 claims to be the fastest kernel around[0], a claim that remains unchallenged.<p>To put it into context, the difference in IPC speed is such that you&#x27;d need an order of magnitude more IPC for a multiserver system based on seL4 to actually be slower than Linux.<p>A multiserver design would imply increased IPC use, but not an order of magnitude.<p>0. <a href="https:&#x2F;&#x2F;trustworthy.systems&#x2F;projects&#x2F;seL4&#x2F;" rel="nofollow">https:&#x2F;&#x2F;trustworthy.systems&#x2F;projects&#x2F;seL4&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="35882781" class="c"><input type="checkbox" id="c-35882781" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35883512">prev</a><span>|</span><a href="#35882793">next</a><span>|</span><label class="collapse" for="c-35882781">[-]</label><label class="expand" for="c-35882781">[1 more]</label></div><br/><div class="children"><div class="content">Actually over 30 million LOC</div><br/></div></div><div id="35882793" class="c"><input type="checkbox" id="c-35882793" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35882781">prev</a><span>|</span><a href="#35882472">next</a><span>|</span><label class="collapse" for="c-35882793">[-]</label><label class="expand" for="c-35882793">[7 more]</label></div><br/><div class="children"><div class="content">Alternatively, perhaps we should start thinking about whether it is a good idea to have multiple users of different privilege sharing the same hardware.</div><br/><div id="35883366" class="c"><input type="checkbox" id="c-35883366" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882793">parent</a><span>|</span><a href="#35882923">next</a><span>|</span><label class="collapse" for="c-35883366">[-]</label><label class="expand" for="c-35883366">[1 more]</label></div><br/><div class="children"><div class="content">&quot;User&quot; in a modern Linux system is just a weird name for &quot;security domain&quot;. Many programs run as their own user to limit their ability to attack the rest of the system if they get compromised; and limit the ability of a different compromised component from attacking them.<p>My desktop, on which I am the only person with an account, has 49 &quot;users&quot;, of which 11 are actively running a process.<p>At work, every daemon we run has a dedicated user.<p>On android, every app runs as its own user.</div><br/></div></div><div id="35883071" class="c"><input type="checkbox" id="c-35883071" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882793">parent</a><span>|</span><a href="#35882923">prev</a><span>|</span><a href="#35883336">next</a><span>|</span><label class="collapse" for="c-35883071">[-]</label><label class="expand" for="c-35883071">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the alternative, just running all code at ring 0?</div><br/><div id="35883452" class="c"><input type="checkbox" id="c-35883452" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35883071">parent</a><span>|</span><a href="#35884639">next</a><span>|</span><label class="collapse" for="c-35883452">[-]</label><label class="expand" for="c-35883452">[1 more]</label></div><br/><div class="children"><div class="content">IMHO rings 0 + 3 with protections against bugs, and not deliberate malice, is probably the sweet spot.</div><br/></div></div><div id="35884639" class="c"><input type="checkbox" id="c-35884639" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35883071">parent</a><span>|</span><a href="#35883452">prev</a><span>|</span><a href="#35883336">next</a><span>|</span><label class="collapse" for="c-35884639">[-]</label><label class="expand" for="c-35884639">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.theseus-os.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theseus-os.com&#x2F;</a></div><br/></div></div></div></div><div id="35883336" class="c"><input type="checkbox" id="c-35883336" checked=""/><div class="controls bullet"><span class="by">travis729</span><span>|</span><a href="#35882444">root</a><span>|</span><a href="#35882793">parent</a><span>|</span><a href="#35883071">prev</a><span>|</span><a href="#35882472">next</a><span>|</span><label class="collapse" for="c-35883336">[-]</label><label class="expand" for="c-35883336">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been thinking this recently as well.</div><br/></div></div></div></div><div id="35882472" class="c"><input type="checkbox" id="c-35882472" checked=""/><div class="controls bullet"><span class="by">unixhero</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35882793">prev</a><span>|</span><a href="#35882530">next</a><span>|</span><label class="collapse" for="c-35882472">[-]</label><label class="expand" for="c-35882472">[1 more]</label></div><br/><div class="children"><div class="content">Well it is the kernel.</div><br/></div></div><div id="35882530" class="c"><input type="checkbox" id="c-35882530" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#35882444">parent</a><span>|</span><a href="#35882472">prev</a><span>|</span><a href="#35882523">next</a><span>|</span><label class="collapse" for="c-35882530">[-]</label><label class="expand" for="c-35882530">[1 more]</label></div><br/><div class="children"><div class="content">We really need to be moving faster on migrating Linux to a safer language which prevents these kinds of issues.</div><br/></div></div></div></div><div id="35882523" class="c"><input type="checkbox" id="c-35882523" checked=""/><div class="controls bullet"><span class="by">explorer83</span><span>|</span><a href="#35882444">prev</a><span>|</span><a href="#35881708">next</a><span>|</span><label class="collapse" for="c-35882523">[-]</label><label class="expand" for="c-35882523">[1 more]</label></div><br/><div class="children"><div class="content">Based on this 11 month old discussion this has been an exploit vector for sometime - <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;linux.debian.bugs.dist&#x2F;c&#x2F;ZF9rWY3DR5w" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;linux.debian.bugs.dist&#x2F;c&#x2F;ZF9rWY3...</a><p>&quot;I vaguely recall at least around 6-7 such holes, and a quick google
search seems to reveal that at least those would have been mitigated
by unprivileged user namespaces being disabled:
CVE-2019-18198
CVE-2020-14386
CVE-2022-0185
CVE-2022-24122
CVE-2022-25636
CVE-2022-1966 resp. CVE-2022-32250&quot;</div><br/></div></div><div id="35881708" class="c"><input type="checkbox" id="c-35881708" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#35882523">prev</a><span>|</span><a href="#35880592">next</a><span>|</span><label class="collapse" for="c-35881708">[-]</label><label class="expand" for="c-35881708">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2023-32233" rel="nofollow">https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2023-32233</a><p>The NIST CVE page points back here. Funny.<p>Nothing I see so far specifically says how far back this goes, but, <a href="https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2023-32233" rel="nofollow">https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2023-32233</a><p>Seems to go back really far.</div><br/></div></div><div id="35880592" class="c"><input type="checkbox" id="c-35880592" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#35881708">prev</a><span>|</span><a href="#35881684">next</a><span>|</span><label class="collapse" for="c-35880592">[-]</label><label class="expand" for="c-35880592">[5 more]</label></div><br/><div class="children"><div class="content">&gt; delete an existing nft rule that uses an nft anonymous set. And an example of the latter operation is an attempt to delete an element from that nft anonymous set after the set gets
deleted<p>I&#x27;d be very interested to hear how this can be done by an unprivileged user.<p>Try to race set add&#x2F;removals, sure, but if it depends on the set itself getting deleted, that seems… harder.</div><br/><div id="35880848" class="c"><input type="checkbox" id="c-35880848" checked=""/><div class="controls bullet"><span class="by">0x006A</span><span>|</span><a href="#35880592">parent</a><span>|</span><a href="#35881684">next</a><span>|</span><label class="collapse" for="c-35880848">[-]</label><label class="expand" for="c-35880848">[4 more]</label></div><br/><div class="children"><div class="content">on <a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2196105" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2196105</a> a comment suggests that it might only be possible if you have &quot;unprivileged user namespaces&quot; enabled</div><br/><div id="35881180" class="c"><input type="checkbox" id="c-35881180" checked=""/><div class="controls bullet"><span class="by">pizzalife</span><span>|</span><a href="#35880592">root</a><span>|</span><a href="#35880848">parent</a><span>|</span><a href="#35881684">next</a><span>|</span><label class="collapse" for="c-35881180">[-]</label><label class="expand" for="c-35881180">[3 more]</label></div><br/><div class="children"><div class="content">&gt;a comment suggests that it might only be possible if you have &quot;unprivileged user namespaces&quot; enabled<p>Which is the default on Ubuntu.</div><br/><div id="35882016" class="c"><input type="checkbox" id="c-35882016" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#35880592">root</a><span>|</span><a href="#35881180">parent</a><span>|</span><a href="#35881684">next</a><span>|</span><label class="collapse" for="c-35882016">[-]</label><label class="expand" for="c-35882016">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the default on pretty much any modern Linux system!</div><br/><div id="35883508" class="c"><input type="checkbox" id="c-35883508" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#35880592">root</a><span>|</span><a href="#35882016">parent</a><span>|</span><a href="#35881684">next</a><span>|</span><label class="collapse" for="c-35883508">[-]</label><label class="expand" for="c-35883508">[1 more]</label></div><br/><div class="children"><div class="content">From 2016- <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;673597&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;673597&#x2F;</a><p>Andy Lutomirski described some concerns of his own:<p>&gt; I consider the ability to use CLONE_NEWUSER to acquire CAP_NET_ADMIN over &#x2F;any&#x2F; network namespace and to thus access the network configuration API to be a huge risk. For example, unprivileged users can program iptables. I&#x27;ll eat my hat if there are no privilege escalations in there.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35880357" class="c"><input type="checkbox" id="c-35880357" checked=""/><div class="controls bullet"><span class="by">alex14fr</span><span>|</span><a href="#35881684">prev</a><span>|</span><a href="#35882208">next</a><span>|</span><label class="collapse" for="c-35880357">[-]</label><label class="expand" for="c-35880357">[7 more]</label></div><br/><div class="children"><div class="content">Glad to have sticked with the good old iptables and left CONFIG_NF_TABLES unset in kernel configuration.</div><br/><div id="35880551" class="c"><input type="checkbox" id="c-35880551" checked=""/><div class="controls bullet"><span class="by">sam_lowry_</span><span>|</span><a href="#35880357">parent</a><span>|</span><a href="#35882208">next</a><span>|</span><label class="collapse" for="c-35880551">[-]</label><label class="expand" for="c-35880551">[6 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t iptables just an emulation layer on top of netfilter?</div><br/><div id="35883304" class="c"><input type="checkbox" id="c-35883304" checked=""/><div class="controls bullet"><span class="by">failsecure</span><span>|</span><a href="#35880357">root</a><span>|</span><a href="#35880551">parent</a><span>|</span><a href="#35880737">next</a><span>|</span><label class="collapse" for="c-35883304">[-]</label><label class="expand" for="c-35883304">[1 more]</label></div><br/><div class="children"><div class="content">For modern distros, the nft package includes an alternative binary that takes the place of &#x2F;sbin&#x2F;iptables and translates the input to an nft compatible format. As far as the kernel is concerned, iptables is still iptables. Old iptables can be accessed by calling the iptables-legacy binary which will auto load the old iptables ko.</div><br/></div></div><div id="35880737" class="c"><input type="checkbox" id="c-35880737" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#35880357">root</a><span>|</span><a href="#35880551">parent</a><span>|</span><a href="#35883304">prev</a><span>|</span><a href="#35880595">next</a><span>|</span><label class="collapse" for="c-35880737">[-]</label><label class="expand" for="c-35880737">[2 more]</label></div><br/><div class="children"><div class="content">Yes, AFAIU (not an expert), iptables and nftables are two command line tools and abstractions (chains vs. tables) for interacting with the same underlying netfilter API.</div><br/><div id="35881118" class="c"><input type="checkbox" id="c-35881118" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#35880357">root</a><span>|</span><a href="#35880737">parent</a><span>|</span><a href="#35880595">next</a><span>|</span><label class="collapse" for="c-35881118">[-]</label><label class="expand" for="c-35881118">[1 more]</label></div><br/><div class="children"><div class="content">I believe at one time they were two separate subsystems, but they got merged in 4.x or 5.x</div><br/></div></div></div></div><div id="35880595" class="c"><input type="checkbox" id="c-35880595" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#35880357">root</a><span>|</span><a href="#35880551">parent</a><span>|</span><a href="#35880737">prev</a><span>|</span><a href="#35882208">next</a><span>|</span><label class="collapse" for="c-35880595">[-]</label><label class="expand" for="c-35880595">[2 more]</label></div><br/><div class="children"><div class="content">Probably depends on the distro. Iptables is a wrapper around nftables in most distros, but probably not all.</div><br/><div id="35882585" class="c"><input type="checkbox" id="c-35882585" checked=""/><div class="controls bullet"><span class="by">smashed</span><span>|</span><a href="#35880357">root</a><span>|</span><a href="#35880595">parent</a><span>|</span><a href="#35882208">next</a><span>|</span><label class="collapse" for="c-35882585">[-]</label><label class="expand" for="c-35882585">[1 more]</label></div><br/><div class="children"><div class="content">You can check with: iptables -V<p>If it says (nf_tables), you are using the compatibility layer from the iptables-nft package.<p>It works quite well. Apps like Docker that inserts rules using the legacy iptables syntax are oblivious to the fact that they are actually inserting nftables rules.<p>It also provides an easy migration path. Insert your old rules using your iptables script then list them in the new syntax using nft list ruleset.<p>The problem is that it works so well that it seems most users just stayed with the iptables syntax and did not bother migrating at all.</div><br/></div></div></div></div></div></div></div></div><div id="35882208" class="c"><input type="checkbox" id="c-35882208" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#35880357">prev</a><span>|</span><a href="#35884472">next</a><span>|</span><label class="collapse" for="c-35882208">[-]</label><label class="expand" for="c-35882208">[10 more]</label></div><br/><div class="children"><div class="content">Rust needs to be more prominent in the kernel, and where not rust ebpf. The days of hand mangling pointer arithmetic need to end.</div><br/><div id="35882241" class="c"><input type="checkbox" id="c-35882241" checked=""/><div class="controls bullet"><span class="by">eklitzke</span><span>|</span><a href="#35882208">parent</a><span>|</span><a href="#35884472">next</a><span>|</span><label class="collapse" for="c-35882241">[-]</label><label class="expand" for="c-35882241">[9 more]</label></div><br/><div class="children"><div class="content">The patch doesn&#x27;t fix anything with pointer arithmetic: <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;patch&#x2F;?id=c1592a89942e9678f7d9c8030efa777c0d57edab" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/><div id="35882292" class="c"><input type="checkbox" id="c-35882292" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35882241">parent</a><span>|</span><a href="#35884472">next</a><span>|</span><label class="collapse" for="c-35882292">[-]</label><label class="expand" for="c-35882292">[8 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t generally expect a use-after-free to result from improper pointer arithmetic; that&#x27;s the recipe for a buffer overflow. But Rust happens to also be well-known for helping manage object lifetimes, which seems to be what went wrong here.</div><br/><div id="35882318" class="c"><input type="checkbox" id="c-35882318" checked=""/><div class="controls bullet"><span class="by">eklitzke</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35882292">parent</a><span>|</span><a href="#35884472">next</a><span>|</span><label class="collapse" for="c-35882318">[-]</label><label class="expand" for="c-35882318">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if your claim here is correct. The patch is to change call sites like<p><pre><code>  priv-&gt;set-&gt;use++;
</code></pre>
To look like:<p><pre><code>  nf_tables_activate_set(ctx, priv-&gt;set);
</code></pre>
Where this function is defined as:<p><pre><code>  void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set) {
    if (nft_set_is_anonymous(set))
      nft_clear(ctx-&gt;net, set);
    set-&gt;use++;
  }
</code></pre>
So to me (someone who is not an expert in this code) it looks like the fix is checking if the set has the anonymous flag before changing the reference count. I&#x27;m not an expert in this code and I could be mistaken, but I think your claim that this would be fixed by Rust object lifetime checking requires better evidence.</div><br/><div id="35882736" class="c"><input type="checkbox" id="c-35882736" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35882318">parent</a><span>|</span><a href="#35882687">next</a><span>|</span><label class="collapse" for="c-35882736">[-]</label><label class="expand" for="c-35882736">[1 more]</label></div><br/><div class="children"><div class="content">I think a Rust-influenced design would have shied away from the manual direct reference count management in the first place and resulted in a fairly different-looking API; but at a minimum I&#x27;d expect that the safe wrapper `nf_tables_activate_set` would probably have existed from the beginning, and may have been designed to transfer ownership of the `nft_set` rather than just capture a reference to it.<p>More generally: doing a line-by-line translation from C to Rust is never going to be the best way to make use of the capabilities Rust has that C lacks.</div><br/></div></div><div id="35882687" class="c"><input type="checkbox" id="c-35882687" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35882318">parent</a><span>|</span><a href="#35882736">prev</a><span>|</span><a href="#35882331">next</a><span>|</span><label class="collapse" for="c-35882687">[-]</label><label class="expand" for="c-35882687">[4 more]</label></div><br/><div class="children"><div class="content">One of the parts of Rust’s safety story is to always use smart pointers for reference counting rather than the type of ad-hoc manual reference count management seen in the code you quoted.  Combined with lifetime checking, it makes it impossible for some random logic error to cause a use-after-free.</div><br/><div id="35883476" class="c"><input type="checkbox" id="c-35883476" checked=""/><div class="controls bullet"><span class="by">max_k</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35882687">parent</a><span>|</span><a href="#35882331">next</a><span>|</span><label class="collapse" for="c-35883476">[-]</label><label class="expand" for="c-35883476">[3 more]</label></div><br/><div class="children"><div class="content">&gt; to always use smart pointers for reference counting<p>Agree - and the Linux kernel is extremely fragile because it is full of ad-hoc manual code like that.<p>Unfortunately, Rust won&#x27;t be the rescue, because (in the foreseeable future) Rust will only be available in leaf code due to the many hard problems of transitioning from fragile C APIs to something better. Writing drivers in Rust is useful, but limits the scope of how Rust helps.<p>Many of Rust&#x27;s advantages at a tiny fraction of the effort could be had easily with a smooth transition path by switching the compiler from C to C++ mode. The fruit hangs so low, it nearly touches the ground, but a silly Linus rejects C++ for the wrong reasons (&quot;to keep the C++ programmers out&quot;, wtf).<p>Every time I work on the Linux kernel source, I&#x27;m horrified by how much pain the kernel developers inflict on themselves. Even with C, it would be possible to install a mandatory coding style that is less fragile.<p>For example, in the aftermath of the Dirty Pipe vulnerability last year, I submitted a patch to make the code less fragile, a coding style that would have prevented the vulnerability: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;20220225185431.2617232-4-max.kellermann@gmail.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;20220225185431.2617232-4-max.ke...</a> - but my patch went nowhere.</div><br/><div id="35883712" class="c"><input type="checkbox" id="c-35883712" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35883476">parent</a><span>|</span><a href="#35882331">next</a><span>|</span><label class="collapse" for="c-35883712">[-]</label><label class="expand" for="c-35883712">[2 more]</label></div><br/><div class="children"><div class="content">We’ll see.  As far as I know, the biggest blocker to using Rust outside of drivers is the fact that LLVM lacks support for some architectures Linux supports.  And rustc_codegen_gcc seems on track to fix that eventually; even if it takes years more, that’s not much time on the scale of Linux’s development history.</div><br/><div id="35883883" class="c"><input type="checkbox" id="c-35883883" checked=""/><div class="controls bullet"><span class="by">max_k</span><span>|</span><a href="#35882208">root</a><span>|</span><a href="#35883712">parent</a><span>|</span><a href="#35882331">next</a><span>|</span><label class="collapse" for="c-35883883">[-]</label><label class="expand" for="c-35883883">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t solve the hard problems I meant. Rust portability is an easy problem - it&#x27;s clear how to port Rust to more architectures, just nobody has done it. But doing interop between Rust and C in both directions, with complicated things like RCU in between - that is a hard and complex problem.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35884472" class="c"><input type="checkbox" id="c-35884472" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#35882208">prev</a><span>|</span><label class="collapse" for="c-35884472">[-]</label><label class="expand" for="c-35884472">[2 more]</label></div><br/><div class="children"><div class="content">Honest question: Why did they build an exploit that uses the bug? I always assumed that use-after-free is equivalent to &quot;game over&quot; (i.e. I assumed that local privilege escalation is a given) and it is clear that such a bug must be fixed.<p>By that I mean, it might be easy or hard to exploit a bug to achieve LPE, but it seems to be redundant to prove that it is possible.</div><br/><div id="35884691" class="c"><input type="checkbox" id="c-35884691" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#35884472">parent</a><span>|</span><label class="collapse" for="c-35884691">[-]</label><label class="expand" for="c-35884691">[1 more]</label></div><br/><div class="children"><div class="content">Making a PoC is a great way to convince both yourself and the maintainers that the bug is actually exploitable in the wild and thus a big fucking deal. Alternatively, you might discover that there are some other things going on which turns out to make the bug unexploitable.</div><br/></div></div></div></div></div></div></div></div></div></body></html>