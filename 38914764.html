<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704790865241" as="style"/><link rel="stylesheet" href="styles.css?v=1704790865241"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.crunchydata.com/blog/an-overview-of-distributed-postgresql-architectures">An overview of distributed Postgres architectures</a> <span class="domain">(<a href="https://www.crunchydata.com">www.crunchydata.com</a>)</span></div><div class="subtext"><span>eatonphil</span> | <span>19 comments</span></div><br/><div><div id="38922471" class="c"><input type="checkbox" id="c-38922471" checked=""/><div class="controls bullet"><span class="by">magden</span><span>|</span><a href="#38920843">next</a><span>|</span><label class="collapse" for="c-38922471">[-]</label><label class="expand" for="c-38922471">[2 more]</label></div><br/><div class="children"><div class="content">First time seeing someone call Spanner, CockroachDB, and YugabyteDB a &quot;distributed key-value store with SQL&quot; :)<p>The cons of the mentioned distributed shared-nothing SQL databases are questionable:<p>- &quot;Key-value store&quot; is in fact an LSM-tree-based document store that supports column-level versioning (Postgres supports row-level versioning only).<p>- &quot;Many internal operations incur high latency.&quot; - I guess this conclusion is based on the referenced Gigaom benchmark that was paid for by Microsoft to compare apples to oranges.<p>- &quot;No local joins in current implementations.&quot; (YugabyteDB certainly has colocated tables that store a whole table on a single node. CockroachDB and Spanner might do this as well.)<p>- &quot;Not actually PostgreSQL...&quot; - There is only one 100% compatible database with Postgres...It&#x27;s Postgres itself. Citus, CockroachDB, Aurora, Alloy, YugabyteDB, and others can be classified as &quot;not actually Postgres.&quot;<p>- &quot;And less mature and optimized.&quot; - Well, both CockroachDB and YugabyteDB are on Gartner&#x27;s Magic Quadrant of the top 20 cloud databases. Toys don&#x27;t get there.<p>It feels like the author joined Crunchy to work on their own distributed version of Postgres. Good move for Crunchy, good luck!</div><br/><div id="38922753" class="c"><input type="checkbox" id="c-38922753" checked=""/><div class="controls bullet"><span class="by">seedless-sensat</span><span>|</span><a href="#38922471">parent</a><span>|</span><a href="#38920843">next</a><span>|</span><label class="collapse" for="c-38922753">[-]</label><label class="expand" for="c-38922753">[1 more]</label></div><br/><div class="children"><div class="content">I think this con is very real:<p>&gt; Related tables and indexes are not necessarily stored together, meaning typical operations such as joins and evaluating foreign keys or even simple index lookups might incur an excessive number of internal network hops. The relatively strong transactional guarantees that involve additional locks and coordination can also become a drag on performance.<p>You handwaved this away saying you can just store an entire table on a single node, but that defeats many of the benefits of these sharded SQL databases.<p>Edit: Also, before attacking the author&#x27;s biases, it seems fair to disclose you appear to work at Yugabyte</div><br/></div></div></div></div><div id="38920843" class="c"><input type="checkbox" id="c-38920843" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#38922471">prev</a><span>|</span><a href="#38922936">next</a><span>|</span><label class="collapse" for="c-38920843">[-]</label><label class="expand" for="c-38920843">[6 more]</label></div><br/><div class="children"><div class="content">This is great.<p>One thing I&#x27;d add is a sense of scale - are these architectures for 100 queries per second or 100,000 or 100,000,000 ?</div><br/><div id="38920998" class="c"><input type="checkbox" id="c-38920998" checked=""/><div class="controls bullet"><span class="by">craigkerstiens</span><span>|</span><a href="#38920843">parent</a><span>|</span><a href="#38922589">next</a><span>|</span><label class="collapse" for="c-38920998">[-]</label><label class="expand" for="c-38920998">[3 more]</label></div><br/><div class="children"><div class="content">Marco (author) is probably asleep at this point and could give a deeper perspective. He sort of hits on this when talking about disk latency... Depending on your setup and well just from some personal experience I know it&#x27;s not crazy for Postgres queries to go at 1ms per query. From there you can start to do some math on how many cores, how many queries per second, etc.<p>Single node Postgres (with a beefy machine) can definitely manage in the 100k transactions per second. When you&#x27;re pushing the high 100k into millions read replicas is a common approach.<p>When we&#x27;re talking transactions, question of is it simply basic queries, bigger aggregations, and is it writes or reads. Writes if you can manage to do any form of multi-line insert or batching with copy you can push basic Postgres really far... From some benchmarks Citus as mentioned can hit millions of records per second safely with those approaches, and even without Citus can get pretty high write throughput.</div><br/><div id="38922976" class="c"><input type="checkbox" id="c-38922976" checked=""/><div class="controls bullet"><span class="by">franckpachot</span><span>|</span><a href="#38920843">root</a><span>|</span><a href="#38920998">parent</a><span>|</span><a href="#38921329">next</a><span>|</span><label class="collapse" for="c-38922976">[-]</label><label class="expand" for="c-38922976">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;disappointing&quot; benchmark mentioned in the article is a shame for GigaOm who published it and for Microsoft who paid for it. They compare Citus with no HA to CockroachDB and YugabyteDB with replication factor 3 Multi-AZ, resilient to data center failure. And they run Citus on 16 cores (=32 vCPU) and the others on 16 vCPU.
But your point about &quot;beefy machine&quot; shows the real advantages of Distributed SQL. PostgreSQL and Citus needs downtime to save cost if you don&#x27;t need that beefy machine all days all year. Scale up and down is downtime, as well as upgrades. Distributed SQL offers elasticity (no downtime to resize the cluster) and high availability (no downtime on failure or maintenance)</div><br/></div></div><div id="38921329" class="c"><input type="checkbox" id="c-38921329" checked=""/><div class="controls bullet"><span class="by">mistrial9</span><span>|</span><a href="#38920843">root</a><span>|</span><a href="#38920998">parent</a><span>|</span><a href="#38922976">prev</a><span>|</span><a href="#38922589">next</a><span>|</span><label class="collapse" for="c-38921329">[-]</label><label class="expand" for="c-38921329">[1 more]</label></div><br/><div class="children"><div class="content">second yes to that - postgresql warm with plenty of RAM can do some fancy things and return an answer sub-millisecond too<p>cache is King</div><br/></div></div></div></div><div id="38922589" class="c"><input type="checkbox" id="c-38922589" checked=""/><div class="controls bullet"><span class="by">magden</span><span>|</span><a href="#38920843">parent</a><span>|</span><a href="#38920998">prev</a><span>|</span><a href="#38922936">next</a><span>|</span><label class="collapse" for="c-38922589">[-]</label><label class="expand" for="c-38922589">[2 more]</label></div><br/><div class="children"><div class="content">Scalability is not the only reason for jumping on a distributed Postgres version.<p>Some apps might do just 1000 ops&#x2F;second but still run on a distributed database for high availability or data locality reasons. For instance, shared-nothing databases usually guarantee RPO=0 (no data loss, recovery point objective) with RTO (recovery time objective) measured in seconds for zone and region-level outages. As for data locality, think automatic data placement&#x2F;pinning to regions&#x2F;data centers for data regulatory and low latency reasons (serve read&#x2F;write requests equally fast for folks living in NYC, London, Tokyo).</div><br/><div id="38923558" class="c"><input type="checkbox" id="c-38923558" checked=""/><div class="controls bullet"><span class="by">never_inline</span><span>|</span><a href="#38920843">root</a><span>|</span><a href="#38922589">parent</a><span>|</span><a href="#38922936">next</a><span>|</span><label class="collapse" for="c-38923558">[-]</label><label class="expand" for="c-38923558">[1 more]</label></div><br/><div class="children"><div class="content">Any reason you can&#x27;t achieve those RPO&#x2F;RTO with straightforward replication?</div><br/></div></div></div></div></div></div><div id="38922936" class="c"><input type="checkbox" id="c-38922936" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#38920843">prev</a><span>|</span><a href="#38922079">next</a><span>|</span><label class="collapse" for="c-38922936">[-]</label><label class="expand" for="c-38922936">[3 more]</label></div><br/><div class="children"><div class="content">In my experience, HA stories of Postgres are always buggy and disappointing for homegrown systems. None of these tools actually gives you a solid HA like proprietary databases do. Managed database services can reduce or eliminate some of the problems, but you can&#x27;t put critical parts of your system on the cloud.</div><br/><div id="38923822" class="c"><input type="checkbox" id="c-38923822" checked=""/><div class="controls bullet"><span class="by">jgimenez</span><span>|</span><a href="#38922936">parent</a><span>|</span><a href="#38923292">next</a><span>|</span><label class="collapse" for="c-38923822">[-]</label><label class="expand" for="c-38923822">[1 more]</label></div><br/><div class="children"><div class="content">What would you recommend instead?</div><br/></div></div><div id="38923292" class="c"><input type="checkbox" id="c-38923292" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#38922936">parent</a><span>|</span><a href="#38923822">prev</a><span>|</span><a href="#38922079">next</a><span>|</span><label class="collapse" for="c-38923292">[-]</label><label class="expand" for="c-38923292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t put critical parts of your system on the cloud<p>This seems highly dependent on how you define “critical”. I think most people’s definition allows for everything to be in the cloud.</div><br/></div></div></div></div><div id="38922079" class="c"><input type="checkbox" id="c-38922079" checked=""/><div class="controls bullet"><span class="by">IntrnlCmplrErr</span><span>|</span><a href="#38922936">prev</a><span>|</span><a href="#38921602">next</a><span>|</span><label class="collapse" for="c-38922079">[-]</label><label class="expand" for="c-38922079">[2 more]</label></div><br/><div class="children"><div class="content">Under the “DBMS-optimized cloud storage” section, won’t replicating the WAL across various different availability zones entail doing an atomic broadcast if you want any isolation?<p>It seems to me that you would need to run some sort of consensus algorithm to ensure the replication is consistent but that’s obviously very expensive in latency. Is it actually done this way?</div><br/><div id="38922184" class="c"><input type="checkbox" id="c-38922184" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#38922079">parent</a><span>|</span><a href="#38921602">next</a><span>|</span><label class="collapse" for="c-38922184">[-]</label><label class="expand" for="c-38922184">[1 more]</label></div><br/><div class="children"><div class="content">They mention paralleling them, so it&#x27;s only as expensive as the slowest write.</div><br/></div></div></div></div><div id="38921602" class="c"><input type="checkbox" id="c-38921602" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38922079">prev</a><span>|</span><a href="#38922882">next</a><span>|</span><label class="collapse" for="c-38921602">[-]</label><label class="expand" for="c-38921602">[1 more]</label></div><br/><div class="children"><div class="content">Funny that it mentions <i>Transparent</i> sharding (with the downsides thereof), but not other kinds of sharding.</div><br/></div></div><div id="38922882" class="c"><input type="checkbox" id="c-38922882" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#38921602">prev</a><span>|</span><a href="#38921756">next</a><span>|</span><label class="collapse" for="c-38922882">[-]</label><label class="expand" for="c-38922882">[1 more]</label></div><br/><div class="children"><div class="content">Why not include redshift in the mix?</div><br/></div></div><div id="38921756" class="c"><input type="checkbox" id="c-38921756" checked=""/><div class="controls bullet"><span class="by">ManBeardPc</span><span>|</span><a href="#38922882">prev</a><span>|</span><label class="collapse" for="c-38921756">[-]</label><label class="expand" for="c-38921756">[3 more]</label></div><br/><div class="children"><div class="content">Very good overview and easy to read. In recent years I‘ve encountered more and more businesses that use or want to use Postgres instead of other proprietary or NoSQL databases, so this post is very useful.</div><br/><div id="38923191" class="c"><input type="checkbox" id="c-38923191" checked=""/><div class="controls bullet"><span class="by">franckpachot</span><span>|</span><a href="#38921756">parent</a><span>|</span><label class="collapse" for="c-38923191">[-]</label><label class="expand" for="c-38923191">[2 more]</label></div><br/><div class="children"><div class="content">The article is a marketing promotion for Citus. They ignore Neon, a major innovation in distributed cloud storage solutions. They reduce Distributed SQL to key-value stores, when it is actually the only distributed architecture that preserves all SQL features (ACID, consistent reads, referential integrity, global indexes).<p>And the only fact about performance is a benchmark comparing elastic and resilient distributed SQL to non-HA Citus running on larger machines.</div><br/><div id="38923866" class="c"><input type="checkbox" id="c-38923866" checked=""/><div class="controls bullet"><span class="by">ManBeardPc</span><span>|</span><a href="#38921756">root</a><span>|</span><a href="#38923191">parent</a><span>|</span><label class="collapse" for="c-38923866">[-]</label><label class="expand" for="c-38923866">[1 more]</label></div><br/><div class="children"><div class="content">Big parts of the article are pretty generic concepts and only mention other products as an example. Haven&#x27;t heard of Neon yet. What does Neon do differently? Is there a good introduction&#x2F;overview?<p>Good, fair and reproducible benchmarks are a rarity. Do you have any (independent) benchmarks that compare different distributed PostgreSQL-based solutions?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>