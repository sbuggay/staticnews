<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703062865710" as="style"/><link rel="stylesheet" href="styles.css?v=1703062865710"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/SubscriberLink/955376/b3fba3bbfabbc411/">The Linux graphics stack in a nutshell</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>zorgmonkey</span> | <span>48 comments</span></div><br/><div><div id="38704283" class="c"><input type="checkbox" id="c-38704283" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38704861">next</a><span>|</span><label class="collapse" for="c-38704283">[-]</label><label class="expand" for="c-38704283">[20 more]</label></div><br/><div class="children"><div class="content">This is about 3D rendering, to be precise; I believe 2D acceleration goes through the same lower layers but the higher ones are very different.<p>Incidentally, one thing I noticed when I was trying to port Linux GPU drivers to Windows some time ago is what appeared to be an excessive amount of indirection; there are so many layers and places where things could be simpler.</div><br/><div id="38704502" class="c"><input type="checkbox" id="c-38704502" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38704283">parent</a><span>|</span><a href="#38704455">next</a><span>|</span><label class="collapse" for="c-38704502">[-]</label><label class="expand" for="c-38704502">[6 more]</label></div><br/><div class="children"><div class="content">2D acceleration is generally done through the same APIs, specifically OpenGL and Vulkan. Classically, the X compositor would use the GLX_EXT_texture_from_pixmap extension to import an X pixmap representing a window surface into OpenGL, where it can be used like any other texture. For the Wayland compositor, I believe you&#x27;d use EGL_WL_bind_wayland_display to bind a Wayland surface to an EGLImage, and then glEGLImageTargetTexture2DOES (can&#x27;t believe I have that function name memorized) to bind that EGLImage to an OpenGL texture, where it can be used in the same way. Vulkan has similar extensions.<p>On the client side, I think most Linux apps still draw their UIs on CPU, usually accelerated with SIMD. Firefox and Chrome (I think SkiaGL is enabled on Linux?) are exceptions; they use OpenGL and&#x2F;or Vulkan to draw their UI. Video playback is a different beast and in theory relies on vendor-specific extensions to decode the video in hardware. However, the last time I looked at Linux video decoding (which was years ago), the drivers were awful and interfacing with each vendor&#x27;s APIs was a huge pain, and so most apps just did video decoding on CPU. (Besides, the Linux ecosystem prefers open codecs, and hardware has only recently gotten support for non-patent-encumbered video formats.)</div><br/><div id="38704632" class="c"><input type="checkbox" id="c-38704632" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704502">parent</a><span>|</span><a href="#38704955">next</a><span>|</span><label class="collapse" for="c-38704632">[-]</label><label class="expand" for="c-38704632">[1 more]</label></div><br/><div class="children"><div class="content">For client side Qt has good GPU support but only for QML. All QML is drawn on GPU by default (expect text I think, which uses Harfbuzz) but all Qt Widgets are drawn on CPU. However things like KDE&#x27;s Wayland uses direct OpenGL calls for faster composition.<p>Firefox has Web Render running on top of ANGLE which is a generic OpenGL layer that converts the OpenGL calls into native platform calls. ANGLE is a Google project and it is the base library for Skia which is used by Chromium to render everything. IIRC Qt &#x2F; QML also uses ANGLE for Windows.</div><br/></div></div><div id="38704955" class="c"><input type="checkbox" id="c-38704955" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704502">parent</a><span>|</span><a href="#38704632">prev</a><span>|</span><a href="#38704455">next</a><span>|</span><label class="collapse" for="c-38704955">[-]</label><label class="expand" for="c-38704955">[4 more]</label></div><br/><div class="children"><div class="content">Why are toolkits still rendered on the CPU?</div><br/><div id="38705203" class="c"><input type="checkbox" id="c-38705203" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704955">parent</a><span>|</span><a href="#38706537">next</a><span>|</span><label class="collapse" for="c-38705203">[-]</label><label class="expand" for="c-38705203">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a ton of effort to write a GPU vector renderer that&#x27;s both compatible with existing apps and faster than the CPU. Switching to SkiaGL would probably be the easiest approach to migrate to GPU rendering, but Skia is notoriously difficult to use outside of Google&#x27;s codebases. (The running joke being &quot;the recommended way to build Skia is to get a job at Google, but there are some workarounds available if for some reason that isn&#x27;t practical.&quot;)</div><br/></div></div><div id="38706537" class="c"><input type="checkbox" id="c-38706537" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704955">parent</a><span>|</span><a href="#38705203">prev</a><span>|</span><a href="#38704455">next</a><span>|</span><label class="collapse" for="c-38706537">[-]</label><label class="expand" for="c-38706537">[2 more]</label></div><br/><div class="children"><div class="content">High-quality text rendering on GPU is surprisingly tricky and inefficient, unless you&#x27;re using something simple like a glyph cache.</div><br/><div id="38706674" class="c"><input type="checkbox" id="c-38706674" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38706537">parent</a><span>|</span><a href="#38704455">next</a><span>|</span><label class="collapse" for="c-38706674">[-]</label><label class="expand" for="c-38706674">[1 more]</label></div><br/><div class="children"><div class="content">Does something like Signed Distance Fields help or is it just be an added value and not a complete different way of doing it?</div><br/></div></div></div></div></div></div></div></div><div id="38704455" class="c"><input type="checkbox" id="c-38704455" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#38704283">parent</a><span>|</span><a href="#38704502">prev</a><span>|</span><a href="#38704861">next</a><span>|</span><label class="collapse" for="c-38704455">[-]</label><label class="expand" for="c-38704455">[13 more]</label></div><br/><div class="children"><div class="content">The most viable approach these days is for 2D is to use the 3D hardware. There&#x27;s no standard, usable API for 2D accelerated drawing the way there is for 3D, nor does it quite make sense for there to be one.<p>(No, OpenVG is not viable. No, Xrender is not viable. cairo and Skia both use the 3D hardware in combination with a CPU render engine.)</div><br/><div id="38704554" class="c"><input type="checkbox" id="c-38704554" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704455">parent</a><span>|</span><a href="#38704594">next</a><span>|</span><label class="collapse" for="c-38704554">[-]</label><label class="expand" for="c-38704554">[9 more]</label></div><br/><div class="children"><div class="content">For the most part that&#x27;s true, but simple 2D compositing is a bit of a different beast, because it can sometimes be done at scanout time, saving a blit. Last I checked, (non-Android) Linux rarely makes use of this except for the mouse cursor. But in general you can save a good bit of energy and memory bandwidth on HiDPI displays if you try to use 2D hardware layers where you can. You can virtually never use them for the UI itself, because they&#x27;re far too limited, but the windowing system can often use them to composite windows together. It&#x27;d be nice if Wayland compositors made more use of this, e.g. to avoid having to blit the foreground window every frame.</div><br/><div id="38704653" class="c"><input type="checkbox" id="c-38704653" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704554">parent</a><span>|</span><a href="#38704697">next</a><span>|</span><label class="collapse" for="c-38704653">[-]</label><label class="expand" for="c-38704653">[3 more]</label></div><br/><div class="children"><div class="content">I used to work on mobile graphics and the android HWC stack.<p>The scanout-time hardware was often less useful that you might think - only in dynamic scenes where the GPU is otherwise idle (like playing video possibly with a static UI overlay was the premier use case).<p>For static scenes it&#x27;s more efficient to render out to a buffer (using the GPU as the scanout overlay pipes often had limited feedback capability) and just output that using overlays disabled. It didn&#x27;t take many frames for that to be worth it.<p>For apps that were animating or otherwise updating it&#x27;s window, most UI toolkits used the GPU for widget rendering. And often the scanout pipes didn&#x27;t hook into the (relatively large) system caches like the GPU did, so there were times it was again faster to composite the screen on the GPU to a single scanout buffer than flush already cached data, the get the scanout hardware to read it back from the memory bus.<p>And there weren&#x27;t as cheap as people thought - one stat I remember was that the total area of the GPU on the omap4 platform was smaller than the display pipes. Though that is now a pretty old chip, and always had a bit of focus on &quot;multimedia&quot;.</div><br/><div id="38705552" class="c"><input type="checkbox" id="c-38705552" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704653">parent</a><span>|</span><a href="#38704688">next</a><span>|</span><label class="collapse" for="c-38705552">[-]</label><label class="expand" for="c-38705552">[1 more]</label></div><br/><div class="children"><div class="content">I think your information is quite outdated. The HWC overlay planes are heavily used, you can see this trivially just doing a &#x27;dumpsys SurfaceFlinger&#x27; or grabbing a systrace&#x2F;perfetto trace. When it falls back to GPU composition it&#x27;s very obvious as there&#x27;s a significant hit to latency and more GPU contention.<p>The overlay capabilities of the modern Snapdragons are also quite absurd. They support like upwards of a dozen overlays now and even have FP16 extended sRGB support. Some HWCs (like the one in the steam deck) even have per plane 3D LUTs for HDR tone mapping (ex <a href="https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;gamescope&#x2F;blob&#x2F;master&#x2F;src&#x2F;docs&#x2F;Steam%20Deck%20Display%20Pipeline.png">https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;gamescope&#x2F;blob&#x2F;master&#x2F;src&#x2F;d...</a> )<p>The composition is bandwidth heavy of course, but for static scenes there&#x27;s a cache <i>after</i> the HWC in the form of panel self refresh.</div><br/></div></div></div></div><div id="38704697" class="c"><input type="checkbox" id="c-38704697" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704554">parent</a><span>|</span><a href="#38704653">prev</a><span>|</span><a href="#38706152">next</a><span>|</span><label class="collapse" for="c-38704697">[-]</label><label class="expand" for="c-38704697">[1 more]</label></div><br/><div class="children"><div class="content">CRTC planes and scanout-time compositing makes sense, and Wayland compositors do use them, even for non-cursor surfaces. It&#x27;s simply not something an application can use general-purpose and guarantee (though see the recent GtkSurfaceOffload stuff for the latest attempt at it).<p>Personally, I don&#x27;t see it as a &quot;2D drawing API&quot;, it doesn&#x27;t accelerate anything special about 2D, only blits and transforms, which a 3D API will eat for breakfast.</div><br/></div></div><div id="38706152" class="c"><input type="checkbox" id="c-38706152" checked=""/><div class="controls bullet"><span class="by">Zardoz84</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704554">parent</a><span>|</span><a href="#38704697">prev</a><span>|</span><a href="#38704594">next</a><span>|</span><label class="collapse" for="c-38706152">[-]</label><label class="expand" for="c-38706152">[4 more]</label></div><br/><div class="children"><div class="content">what happened with these VESA &quot;2d accelerated&quot; API that was on every SVGA card in the middle of the 90s ? They make a  huge difference and was well supported on Windows and X11</div><br/><div id="38706544" class="c"><input type="checkbox" id="c-38706544" checked=""/><div class="controls bullet"><span class="by">soundarana</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38706152">parent</a><span>|</span><a href="#38706182">next</a><span>|</span><label class="collapse" for="c-38706544">[-]</label><label class="expand" for="c-38706544">[1 more]</label></div><br/><div class="children"><div class="content">The basic display interface used by UEFI and low level boot loaders these days it&#x27;s called GOP - Graphics Output Protocol. It replaced VESA.</div><br/></div></div><div id="38706182" class="c"><input type="checkbox" id="c-38706182" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38706152">parent</a><span>|</span><a href="#38706544">prev</a><span>|</span><a href="#38704594">next</a><span>|</span><label class="collapse" for="c-38706182">[-]</label><label class="expand" for="c-38706182">[2 more]</label></div><br/><div class="children"><div class="content">That stuff has been obsolete for quite a while as the general 3D capabilities are more than enough to saturate all the GPU&#x27;s memory bandwidth.</div><br/><div id="38706241" class="c"><input type="checkbox" id="c-38706241" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38706182">parent</a><span>|</span><a href="#38704594">next</a><span>|</span><label class="collapse" for="c-38706241">[-]</label><label class="expand" for="c-38706241">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a VESA standard and still supported it might be useful as a fallback for hardware that doesn&#x27;t have its own driver.<p>Edit: But actually, I couldn&#x27;t find references to anything similar besides VBE&#x2F;AF which even when current got almost no support directly in hardware, so folks had to resort to hardware-specific DOS TSR&#x27;s.  I&#x27;m not sure if there&#x27;s anything newer than that.</div><br/></div></div></div></div></div></div></div></div><div id="38704594" class="c"><input type="checkbox" id="c-38704594" checked=""/><div class="controls bullet"><span class="by">sprash</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704455">parent</a><span>|</span><a href="#38704554">prev</a><span>|</span><a href="#38704861">next</a><span>|</span><label class="collapse" for="c-38704594">[-]</label><label class="expand" for="c-38704594">[3 more]</label></div><br/><div class="children"><div class="content">Xrender is hardware accelerated and cairo uses Xrender as a backend. Why is Xrender not &quot;viable&quot;?</div><br/><div id="38704681" class="c"><input type="checkbox" id="c-38704681" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704594">parent</a><span>|</span><a href="#38704641">next</a><span>|</span><label class="collapse" for="c-38704681">[-]</label><label class="expand" for="c-38704681">[1 more]</label></div><br/><div class="children"><div class="content">Xrender is hardware-accelerated on an increasingly small number of devices, and even SNA, the flagship hardware-accelerated implementation in the Intel driver fell back to software rasterization extremely frequently [0]. In practice it wasn&#x27;t worth it, and it was extremely buggy, hence why it fell into disrepair.<p>The semantics of Xrender simply don&#x27;t match with what modern GPUs give you, even ones with 2D pipelines.<p>[0] <a href="https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;search?search=sna_pixmap_move_to_cpu&amp;nav_source=navbar&amp;project_id=612&amp;group_id=2215&amp;search_code=true&amp;repository_ref=master" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;search?search=sna_pixmap_move...</a></div><br/></div></div><div id="38704641" class="c"><input type="checkbox" id="c-38704641" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38704283">root</a><span>|</span><a href="#38704594">parent</a><span>|</span><a href="#38704681">prev</a><span>|</span><a href="#38704861">next</a><span>|</span><label class="collapse" for="c-38704641">[-]</label><label class="expand" for="c-38704641">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I think XRENDER <i>could</i> be a viable API--the core idea is similar to WebRender, which Firefox uses to great effect--but the existing implementations of it are not well-optimized implementations and issue tons of draw calls using obsolete OpenGL APIs. They are slower than just drawing on CPU. You would essentially need a complete rewrite.<p>The bigger issue is that there&#x27;s little reason to farm vector graphics rendering out to the window server in the first place. The main reason would be to avoid a window blit on HiDPI displays. But the tradeoff is that the XRENDER API is all you get, and usually apps have more sophisticated needs than what it can provide. For instance, browsers can&#x27;t really use XRENDER nowadays because there&#x27;s no way to describe CSS 3D transforms in it. And if you use it you&#x27;re at the mercy of the window server to implement it reasonably, which is not a safe assumption. (A lot of the reason Chrome on Linux was faster than Firefox in the early days is that Firefox used XRENDER, while Chrome rendered on CPU. I remember at least one engineer at Mozilla who was bitter about that, after putting in all the work to make Firefox use it only to have it be a net loss.) In any case, you can avoid the window blit by simply using scanout compositing, as detailed in my other reply, so there is really is no compelling reason to reinvent XRENDER.</div><br/></div></div></div></div></div></div></div></div><div id="38704861" class="c"><input type="checkbox" id="c-38704861" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38704283">prev</a><span>|</span><a href="#38704856">next</a><span>|</span><label class="collapse" for="c-38704861">[-]</label><label class="expand" for="c-38704861">[2 more]</label></div><br/><div class="children"><div class="content">The scene graph isn&#x27;t part of the renderer any more than a player object that contains the player&#x27;s location. The scene graph&#x27;s purpose is to make updating transforms efficient. Just because it references transforms that may need to be sent to the GPU, that doesn&#x27;t mean it is part of the renderer.</div><br/><div id="38705611" class="c"><input type="checkbox" id="c-38705611" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#38704861">parent</a><span>|</span><a href="#38704856">next</a><span>|</span><label class="collapse" for="c-38705611">[-]</label><label class="expand" for="c-38705611">[1 more]</label></div><br/><div class="children"><div class="content">Yes and no. Some type of deferred structure is almost always part of a GPU renderer as it&#x27;s necessary for batching and reordering which help performance tremendously. Sometimes this is entirely an internal system behind an imperitive API, though. Like skia only offers an imperitive API even though it builds a deferred rendering structure from that under the covers.<p>So you end up doing a scene graph to imperitive API to internal renderer scene graph in some UI toolkits. In others they may share the same scene graph structure, applying those optimizations directly from the initial graph.<p>Although all that said a &quot;pure&quot; scene graph is often overkill and slow. They were all the rage in the early 2000s but less so these days. QML&#x27;s QtQuick looks like the primary remaining example?</div><br/></div></div></div></div><div id="38704856" class="c"><input type="checkbox" id="c-38704856" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#38704861">prev</a><span>|</span><a href="#38704239">next</a><span>|</span><label class="collapse" for="c-38704856">[-]</label><label class="expand" for="c-38704856">[21 more]</label></div><br/><div class="children"><div class="content">Before the Wayland complaints take over the thread, I’d like to post a link to a very short thread by Drew DeVault.<p><a href="https:&#x2F;&#x2F;fosstodon.org&#x2F;@drewdevault&#x2F;111607882208898175" rel="nofollow noreferrer">https:&#x2F;&#x2F;fosstodon.org&#x2F;@drewdevault&#x2F;111607882208898175</a><p>Here are the two important posts:<p>———<p>The story of Wayland:<p>1. No one wanted to maintain X11 because it sucked<p>2. We made Wayland and it&#x27;s much better<p>3. A vocal minority of change-averse people complained with little to no factual basis<p>4. They were asked to muster some labor to maintain X11<p>5. None of them did<p>6. All of the people who actually do get work done eventually stopped listening to them and moved on with Wayland<p>——<p>Some of these detractors built a tottering pile of godawful hacks on top of X11 where every piece depends on another critical design flaw of X11 and are upset that by fixing all of these design flaws their pile of hacks fell over when no one wanted to maintain the load bearing side of their hacks</div><br/><div id="38706685" class="c"><input type="checkbox" id="c-38706685" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38704856">parent</a><span>|</span><a href="#38706568">next</a><span>|</span><label class="collapse" for="c-38706685">[-]</label><label class="expand" for="c-38706685">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Before the Wayland complaints take over the thread</i><p>Just BTW, there were no Wayland complaints taking over the thread till you started this with that copypasta. Here&#x27;s why your suggestion for controlling spam won&#x27;t work: ...</div><br/></div></div><div id="38706568" class="c"><input type="checkbox" id="c-38706568" checked=""/><div class="controls bullet"><span class="by">rlkf</span><span>|</span><a href="#38704856">parent</a><span>|</span><a href="#38706685">prev</a><span>|</span><a href="#38706220">next</a><span>|</span><label class="collapse" for="c-38706568">[-]</label><label class="expand" for="c-38706568">[1 more]</label></div><br/><div class="children"><div class="content">In the same spirit as the parent post, we can write the story of opposition to Wayland. If this seems to you as an overly confrontational rendition, please compare this to the original and ruminate on why it seems confrontational to you and if that reason in fact touches on the problem itself.<p>1. A bunch of developers decided to replace the windowing system with something more akin to Desqview.<p>2. People complained that this now broke their previously working remote desktop.<p>3. They got told that their use case was utterly unimportant compared to the very pressing issue of getting rid of screen tearing.<p>4. Upon comments that screen tearing is irrelevant if you don&#x27;t actually have a desktop, they replied that someone could write a remote desktop extension for Wayland.<p>5. None of them did.<p>6. All of the people that actually wanted to get work done stopped listening to them and continued using X11.</div><br/></div></div><div id="38706220" class="c"><input type="checkbox" id="c-38706220" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38704856">parent</a><span>|</span><a href="#38706568">prev</a><span>|</span><a href="#38705539">next</a><span>|</span><label class="collapse" for="c-38706220">[-]</label><label class="expand" for="c-38706220">[3 more]</label></div><br/><div class="children"><div class="content">Wayland achieves its lack of &quot;suck&quot; by being a radically simple design that simply ignores the need for those X11 &quot;godawful hacks&quot; (which provide useful features to a small subset of users). You can already see that people are grafting those features into Wayland compositors in non-standard ways, so soon enough Wayland compositors will have their own collection of ugly hacks. The cycle of life is beautiful, isn&#x27;t it?</div><br/><div id="38706403" class="c"><input type="checkbox" id="c-38706403" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706220">parent</a><span>|</span><a href="#38705539">next</a><span>|</span><label class="collapse" for="c-38706403">[-]</label><label class="expand" for="c-38706403">[2 more]</label></div><br/><div class="children"><div class="content">A variant of the second-system effect: one decides to reimplement something from scratch to incorporate all the lessons learned, avoiding the pile of hacks that accumulated over the years.<p>Then, as the project grows, you find people have been relying on hacks for so long you need to reimplement them. But your new, clean version is not designed to accomodate  such abominations, so you need, very inelegantly, to hack them in.<p>Now you&#x27;re back at square 1. Until the next naive engineer that decides to do the things the right way, once again.</div><br/><div id="38706450" class="c"><input type="checkbox" id="c-38706450" checked=""/><div class="controls bullet"><span class="by">Sankozi</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706403">parent</a><span>|</span><a href="#38705539">next</a><span>|</span><label class="collapse" for="c-38706450">[-]</label><label class="expand" for="c-38706450">[1 more]</label></div><br/><div class="children"><div class="content">But it is not situation in Wayland - it is simple - so you need to implement hacks at a different layer (it is often impossible to implement them on the Wayland layer). No matter how much stuff you throw at the compositor layer the core is unaffected.</div><br/></div></div></div></div></div></div><div id="38705539" class="c"><input type="checkbox" id="c-38705539" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38704856">parent</a><span>|</span><a href="#38706220">prev</a><span>|</span><a href="#38705947">next</a><span>|</span><label class="collapse" for="c-38705539">[-]</label><label class="expand" for="c-38705539">[9 more]</label></div><br/><div class="children"><div class="content">In the thread about Firefox switching defaults to Wayland, there were some complaints about some accessibility software not being supported by Wayland. If the “tottering pile of godawful hacks” is required to not exclude blind people, it doesn’t seem that godawful…<p>Personally I’d prefer to use Sway, but last time I tried Zoom on Sway it gave me a lot of trouble. X11 might not be getting much future development, but it is done and it works, so who cares? It can just stay the same in perpetuity for all I care as long as it keeps working.</div><br/><div id="38705773" class="c"><input type="checkbox" id="c-38705773" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705539">parent</a><span>|</span><a href="#38705664">next</a><span>|</span><label class="collapse" for="c-38705773">[-]</label><label class="expand" for="c-38705773">[1 more]</label></div><br/><div class="children"><div class="content">It is a shame that it takes a seriously long time to properly replace 30+ years of hacks on hacks.<p>But I don’t think the answer is to not try; people use Waylands lack of support for things to justify not using it which then means there no testing or development of those things.<p>I am somewhat in favour of the wayland devs being a lot slower to the punch, because understanding the problem properly and creating a somewhat clean solution takes time by itself, and writing the software to do things the clean way (screen readers for example) also takes time and effort.<p>I am reminded that in the c64 days people would poke random memory addresses and it was normal. Protected mode in Windows was a huge step back for many developers who were used to just writing arbitrary bits to memory.<p>I’m not saying we should abandon everything for progress, it’s good to be critical. But in this case I think the critical eye is only really focused on preventing change, which as many people point out is sorely needed.</div><br/></div></div><div id="38705664" class="c"><input type="checkbox" id="c-38705664" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705539">parent</a><span>|</span><a href="#38705773">prev</a><span>|</span><a href="#38705596">next</a><span>|</span><label class="collapse" for="c-38705664">[-]</label><label class="expand" for="c-38705664">[2 more]</label></div><br/><div class="children"><div class="content">I’m not saying Wayland is perfect as-is or accessibility shouldn’t be fixed. That’s a total straw man.<p>Every post that even touches on Wayland in the smallest way gets flooded with “Wayland sux, just keep developing Xorg” posts.<p>Xorg is not getting useful&#x2F;meaningful&#x2F;future focused development. The fact new commits exist doesn’t mean it’s a healthy alternative.<p>I just happened to see this post yesterday and thought it was a pretty good summary, if pithy, about the state of X vs Wayland. I don’t blame them for being mad about people continuing to beat this horse.<p>It must feel a bit like if people continuing to demand that we give up on electric cars and go back to developing leaded gas.</div><br/><div id="38705759" class="c"><input type="checkbox" id="c-38705759" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705664">parent</a><span>|</span><a href="#38705596">next</a><span>|</span><label class="collapse" for="c-38705759">[-]</label><label class="expand" for="c-38705759">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t say you said it is perfect, so if there is a strawman here it is one of your construction.<p>I think I will not try to defend Xorg, as I don’t really even like it, and as you note the topic is kind of beating a dead horse at this point.</div><br/></div></div></div></div><div id="38705596" class="c"><input type="checkbox" id="c-38705596" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705539">parent</a><span>|</span><a href="#38705664">prev</a><span>|</span><a href="#38705947">next</a><span>|</span><label class="collapse" for="c-38705596">[-]</label><label class="expand" for="c-38705596">[5 more]</label></div><br/><div class="children"><div class="content">Does Zoom even support Wayland or you are running it through XWayland? All these proprietary clients usually have a lot of inertia with implementing Wayland support.</div><br/><div id="38706007" class="c"><input type="checkbox" id="c-38706007" checked=""/><div class="controls bullet"><span class="by">bisby</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705596">parent</a><span>|</span><a href="#38705670">next</a><span>|</span><label class="collapse" for="c-38706007">[-]</label><label class="expand" for="c-38706007">[3 more]</label></div><br/><div class="children"><div class="content">Zoom supports the xdg-desktop-portal for screensharing as of semi recently.<p>Sway&#x27;s screensharing portal (via xdg-desktop-portal-wlr) only lets you share a full monitor at a time. You cant only share a screen region or a single window, so YMMV.<p>Some of the big proprietary clients have their own devs using linux. Devs tend to be that type of person, so them pushing for upgrades to tools they themselves use isn&#x27;t too surprising. Discord just recently released an official flatpak and cited internal dev teams as a reason.</div><br/><div id="38706021" class="c"><input type="checkbox" id="c-38706021" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706007">parent</a><span>|</span><a href="#38705670">next</a><span>|</span><label class="collapse" for="c-38706021">[-]</label><label class="expand" for="c-38706021">[2 more]</label></div><br/><div class="children"><div class="content">KDE should support desktop portal better. It works fine with OBS for example in the Wayland session for screen recording of individual windows.<p>Does Discord support Wayland at all? I&#x27;ve heard a bunch of related complaints from people using its native client.</div><br/><div id="38706454" class="c"><input type="checkbox" id="c-38706454" checked=""/><div class="controls bullet"><span class="by">maxhille</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706021">parent</a><span>|</span><a href="#38705670">next</a><span>|</span><label class="collapse" for="c-38706454">[-]</label><label class="expand" for="c-38706454">[1 more]</label></div><br/><div class="children"><div class="content">I run it as a Wayland client since a year or so now.<p>The only problem I know of is that screen sharing does not allow you to select an audio stream which has already spawned multiple hacks &#x2F; modded clients over the years (and might also apply when running as a X client IDK)</div><br/></div></div></div></div></div></div><div id="38705670" class="c"><input type="checkbox" id="c-38705670" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705596">parent</a><span>|</span><a href="#38706007">prev</a><span>|</span><a href="#38705947">next</a><span>|</span><label class="collapse" for="c-38705670">[-]</label><label class="expand" for="c-38705670">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t the slightest clue, it is a terrible program and I just wanted to do the minimal to get it working. Switching to X11 meant I was able to waste fewer brain-cycles thinking about Zoom.</div><br/></div></div></div></div></div></div><div id="38705947" class="c"><input type="checkbox" id="c-38705947" checked=""/><div class="controls bullet"><span class="by">grandinj</span><span>|</span><a href="#38704856">parent</a><span>|</span><a href="#38705539">prev</a><span>|</span><a href="#38704927">next</a><span>|</span><label class="collapse" for="c-38705947">[-]</label><label class="expand" for="c-38705947">[5 more]</label></div><br/><div class="children"><div class="content">Part of the problem is that Wayland looked at several large chunks of functionality that X11 implemented and said &quot;no thanks, those are security holes, we want nothing to do with them, that is the responsibility of the distro&#x2F;DE&#x2F;etc&quot;<p>Which is rather in conflict with earlier promises about maintaining functionality.<p>This resulted in a whole chunk of work that was either badly done, or not done at all, or needed all sorts of hacks and extra work because it needed to be re-implemented in different ways on different distros.<p>So I&#x27;m really not sympathetic to the Wayland devs, they needlessly created this situation.<p>A more reasonable answer would have been &quot;we don&#x27;t like this, it&#x27;s a security hole, but whatever, just implement a Wayland extension that matches the X11 one, and security conscious people can disable it, and everybody else can move forward productively in the short term&quot;</div><br/><div id="38706203" class="c"><input type="checkbox" id="c-38706203" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38705947">parent</a><span>|</span><a href="#38704927">next</a><span>|</span><label class="collapse" for="c-38706203">[-]</label><label class="expand" for="c-38706203">[4 more]</label></div><br/><div class="children"><div class="content">The Wayland devs don&#x27;t need your sympathy. What&#x27;s needed is a higher s&#x2F;n ratio, and that means aggressive moderation of useless &quot;wayland sux&#x2F;x11 roolz&quot; type comments, which belong in the dustbin of [flagged] [dead] along with e.g. any comment that uses &quot;woke&quot; as a pejorative.<p>The dead horse has been beaten enough and a decision has been made. We&#x27;re a few years out from the major toolkits removing their X code paths altogether. Everybody who knows anything about how the graphics stack actually works is committed to Wayland. Nobody <i>cares</i> at this point if you&#x27;re sticking with X11. One day, you&#x27;ll wake up and find that your entire GUI environment has broken all around you.</div><br/><div id="38706316" class="c"><input type="checkbox" id="c-38706316" checked=""/><div class="controls bullet"><span class="by">grandinj</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706203">parent</a><span>|</span><a href="#38704927">next</a><span>|</span><label class="collapse" for="c-38706316">[-]</label><label class="expand" for="c-38706316">[3 more]</label></div><br/><div class="children"><div class="content">Well, yes, what is needed is a solid understanding of why we are here, and what needs to be done to get to a better place.<p>I like the Wayland devs, and their occasional failures should not overshadow their successes.</div><br/><div id="38706428" class="c"><input type="checkbox" id="c-38706428" checked=""/><div class="controls bullet"><span class="by">nolist_policy</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706316">parent</a><span>|</span><a href="#38704927">next</a><span>|</span><label class="collapse" for="c-38706428">[-]</label><label class="expand" for="c-38706428">[2 more]</label></div><br/><div class="children"><div class="content">No what is needed is that the armchair experts shut up and start contributing to actual Wayland development.<p>The one doing the work decides how its done.</div><br/><div id="38706520" class="c"><input type="checkbox" id="c-38706520" checked=""/><div class="controls bullet"><span class="by">grandinj</span><span>|</span><a href="#38704856">root</a><span>|</span><a href="#38706428">parent</a><span>|</span><a href="#38704927">next</a><span>|</span><label class="collapse" for="c-38706520">[-]</label><label class="expand" for="c-38706520">[1 more]</label></div><br/><div class="children"><div class="content">Well, normally that would be true.<p>But Wayland decided to &quot;boil the ocean&quot; and entirely replace a stack of stuff that was working perfectly well for most people.<p>So perhaps the onus should be on the people who decided to do that, to make sure that things keep working instead of just dumping it?<p>An alternative design would have been to have built Wayland inside X.org and tunnel the new protocol over the existing protocol, and then migrate chunks of functionality one at a time.<p>Which is exactly how X11 replaced X10, and X10 replaced X9, etc.<p>But that would have been careful engineering practice, and not nearly as much fun, so I understand why it did not happen.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38704239" class="c"><input type="checkbox" id="c-38704239" checked=""/><div class="controls bullet"><span class="by">skullone</span><span>|</span><a href="#38704856">prev</a><span>|</span><a href="#38703811">next</a><span>|</span><label class="collapse" for="c-38704239">[-]</label><label class="expand" for="c-38704239">[2 more]</label></div><br/><div class="children"><div class="content">Is systemd going to add it&#x27;s own DRI layer?</div><br/><div id="38704405" class="c"><input type="checkbox" id="c-38704405" checked=""/><div class="controls bullet"><span class="by">feitingen</span><span>|</span><a href="#38704239">parent</a><span>|</span><a href="#38703811">next</a><span>|</span><label class="collapse" for="c-38704405">[-]</label><label class="expand" for="c-38704405">[1 more]</label></div><br/><div class="children"><div class="content">I really hope not.</div><br/></div></div></div></div><div id="38703811" class="c"><input type="checkbox" id="c-38703811" checked=""/><div class="controls bullet"><span class="by">anArbitraryOne</span><span>|</span><a href="#38704239">prev</a><span>|</span><label class="collapse" for="c-38703811">[-]</label><label class="expand" for="c-38703811">[2 more]</label></div><br/><div class="children"><div class="content">There should really be a shell called &#x27;nutshell&#x27; that uses a LLM to explain what&#x27;s going on in a nutshell</div><br/><div id="38703889" class="c"><input type="checkbox" id="c-38703889" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#38703811">parent</a><span>|</span><label class="collapse" for="c-38703889">[-]</label><label class="expand" for="c-38703889">[1 more]</label></div><br/><div class="children"><div class="content">Wanna know about acorns? No? Well, in a nutshell, they&#x27;re an oak tree.</div><br/></div></div></div></div></div></div></div></div></div></body></html>