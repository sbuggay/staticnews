<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704013264123" as="style"/><link rel="stylesheet" href="styles.css?v=1704013264123"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mliezun.github.io/2023/12/25/favourite-advent-of-code-2023.html">Day 20: My favourite problem from Advent of Code 2023</a> <span class="domain">(<a href="https://mliezun.github.io">mliezun.github.io</a>)</span></div><div class="subtext"><span>nickdevx</span> | <span>29 comments</span></div><br/><div><div id="38821767" class="c"><input type="checkbox" id="c-38821767" checked=""/><div class="controls bullet"><span class="by">yoru-sulfur</span><span>|</span><a href="#38820867">next</a><span>|</span><label class="collapse" for="c-38821767">[-]</label><label class="expand" for="c-38821767">[1 more]</label></div><br/><div class="children"><div class="content">My favourite solution to this problem was going all in on analyzing the input. Instead of just assuming the set of modules must have cyclic behaviour and running the simulation until you find the periods, look at the input and _really_ understand what its doing.<p>What you will find is that the modules form a set of binary counters (chains of flip flops), with a number encoded into them via whether they are connected to a &quot;hub&quot; node of the chain (a conjunction).<p>You can parse the module structure and traverse the graph to extract that number. The connections to the hub are the bits of the number (1 if module is connected, 0 if not). Do that for all the counters and LCM (or multiply since they are all coincidentally co-prime) them together to get your answer.<p>No simulation required.</div><br/></div></div><div id="38820867" class="c"><input type="checkbox" id="c-38820867" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#38821767">prev</a><span>|</span><a href="#38820690">next</a><span>|</span><label class="collapse" for="c-38820867">[-]</label><label class="expand" for="c-38820867">[13 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really like problems like these. I love Advent of Code and have got 50&#x2F;50 stars on Christmas day this year -- but this type of problem grinds my gears.<p>The intended solution only works because the input is more constrained than what the problem statement says (the problem in full generality is PSPACE-hard). If you give me a problem to solve, I&#x27;d rather have all the hypotheses, all at once.</div><br/><div id="38821032" class="c"><input type="checkbox" id="c-38821032" checked=""/><div class="controls bullet"><span class="by">noxvilleza</span><span>|</span><a href="#38820867">parent</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821032">[-]</label><label class="expand" for="c-38821032">[9 more]</label></div><br/><div class="children"><div class="content">The same is true with part 2 of problem 8 and problem 21 which both are generally much harder problems which are made easier by carefully constructed test cases. I also find it somewhat annoying, but par for the course with advent given the same test data for part 1 &amp; 2; and the fact that you actually see the only test case -- it&#x27;s not hidden test cases like in other programming competitions.</div><br/><div id="38821130" class="c"><input type="checkbox" id="c-38821130" checked=""/><div class="controls bullet"><span class="by">flurie</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821032">parent</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821130">[-]</label><label class="expand" for="c-38821130">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m behind this year, so I haven&#x27;t looked at any postmortems, but I found an interesting solution to problem 8 part 2[1] after watching the brute force methods stall out. Could you explain what you mean by carefully constructed test cases?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;flurie&#x2F;aoc-rust&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;08.rs#L27">https:&#x2F;&#x2F;github.com&#x2F;flurie&#x2F;aoc-rust&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;08.rs#L...</a></div><br/><div id="38821260" class="c"><input type="checkbox" id="c-38821260" checked=""/><div class="controls bullet"><span class="by">rst</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821130">parent</a><span>|</span><a href="#38821273">next</a><span>|</span><label class="collapse" for="c-38821260">[-]</label><label class="expand" for="c-38821260">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to construct inputs for which the correct solution would <i>not</i> be the LCM of the cycle lengths.  (Just take the input you got, and insert a few extra steps between the &quot;start&quot; point for one of the &quot;ghosts&quot; and the point where it enters its otherwise unaltered cycle.)<p>A more general solution is possible -- but it does require a trick that people may not be aware of unless they&#x27;ve studied a little number theory.</div><br/><div id="38821462" class="c"><input type="checkbox" id="c-38821462" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821260">parent</a><span>|</span><a href="#38821772">next</a><span>|</span><label class="collapse" for="c-38821462">[-]</label><label class="expand" for="c-38821462">[1 more]</label></div><br/><div class="children"><div class="content">It gets even more interesting if you start worrying about ghosts that could finish at multiple points within each cycle. There are potentially too many combinations to try out each one individually.</div><br/></div></div><div id="38821772" class="c"><input type="checkbox" id="c-38821772" checked=""/><div class="controls bullet"><span class="by">noxvilleza</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821260">parent</a><span>|</span><a href="#38821462">prev</a><span>|</span><a href="#38821273">next</a><span>|</span><label class="collapse" for="c-38821772">[-]</label><label class="expand" for="c-38821772">[1 more]</label></div><br/><div class="children"><div class="content">Would you use Chinese remainder theory on all possible configurations of the cycles, or something else completely?</div><br/></div></div></div></div><div id="38821273" class="c"><input type="checkbox" id="c-38821273" checked=""/><div class="controls bullet"><span class="by">noxvilleza</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821130">parent</a><span>|</span><a href="#38821260">prev</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821273">[-]</label><label class="expand" for="c-38821273">[4 more]</label></div><br/><div class="children"><div class="content">So in Question 8 part 2 you had multiple cycles through a graph. You started on all &quot;A&quot; nodes and you had to find the first time at which you were entirely on &quot;Z&quot; nodes.<p>The intended solution was seemingly to calculate the length of the cycle (as in, until you were on a &quot;Z&quot; node) for each starting node separately. Once you&#x27;d done this, you could find the LCM of these cycle lengths to find the overall period of the cycle (~10^13).<p>This solution might not work if your cycles weren&#x27;t constant length -- for example imagine when walking your graph you found your i_th Z-node after {6, 7, 6, 7, 6, 7, 6, 7 ...} steps; or perhaps {6, 7, 7, 7, ...}. In the test data, this didn&#x27;t occur - it was always {n, n, n, n, ...}.<p>I can give another example perhaps - consider you&#x27;re asked to find the last 3 digits of 2^n for n &gt;= 1. You start off calculating: 002, 004, 008, ... eventually you get to 2^103 which ends in 008. This means that the cycle length would be {103, 101, 101, 101, 101, ...} since it&#x27;ll never get back to 002 or 004. Solving this is a bit more difficult than the constant cycle lengths, since it&#x27;s not a simple LCM.</div><br/><div id="38821515" class="c"><input type="checkbox" id="c-38821515" checked=""/><div class="controls bullet"><span class="by">harshreality</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821273">parent</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821515">[-]</label><label class="expand" for="c-38821515">[3 more]</label></div><br/><div class="children"><div class="content">Is there any theorem that puts limits on how irregular the cycles can be in a general case of tape length L with N options corresponding to N outputs from each graph node?<p>What <i>has</i> to be constant is the cycle length for (node, tape instruction #) pairs, because all the state to determine every future step is based on the current node and tape position; if both are the same, the path will be the same as before.  I think, at least without advanced math, the only thing to rely on for &quot;true&quot; loops is identical pairs of (instr #, node), not just instr # or tape steps or node individually.</div><br/><div id="38821732" class="c"><input type="checkbox" id="c-38821732" checked=""/><div class="controls bullet"><span class="by">noxvilleza</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821515">parent</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821732">[-]</label><label class="expand" for="c-38821732">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t spent that much time thinking about it, but my guess is that there may or may not be:<p>* a &quot;tail&quot; -- some initial part of the path before you get into a true cycle (like the 002, 004 in the example above)<p>* an inner repeating cycle before you reach a node you&#x27;ve seen before.<p>In the case given |t| = 0 and |c| = 1, but it&#x27;s easy to construct a more complex example with nodes (A, B, C, D), edges (A-&gt;B, B-&gt;C, C-&gt;D, D-&gt;B), and &#x27;ending nodes&#x27; being B and D. In this case left and right paths go to the same node. This case would have a tail of length 1, and then the inner cycles would be of length {2, 1, 2, 1 ...}.<p>As a result, valid &#x27;ending states&#x27; (Z-nodes) for this graph would be after {1, 3, 4, 6, 7, 9, 10, ...} steps.</div><br/><div id="38821842" class="c"><input type="checkbox" id="c-38821842" checked=""/><div class="controls bullet"><span class="by">harshreality</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38821732">parent</a><span>|</span><a href="#38820989">next</a><span>|</span><label class="collapse" for="c-38821842">[-]</label><label class="expand" for="c-38821842">[1 more]</label></div><br/><div class="children"><div class="content">You can have an inner seemingly-repeating cycle by node, but not by (node, tape instr #) pair.<p>Initial tails are something they should&#x27;ve done, which would&#x27;ve foiled the naive &quot;find the cycle lengths and use lcm&quot; approach.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38820989" class="c"><input type="checkbox" id="c-38820989" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38820867">parent</a><span>|</span><a href="#38821032">prev</a><span>|</span><a href="#38821381">next</a><span>|</span><label class="collapse" for="c-38820989">[-]</label><label class="expand" for="c-38820989">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t necessarily mind these &quot;reverse engineering&quot; type problems, I think you can consider your input part of the problem statement. In earlier years it was common, particularly in early days, for your input to be on the page itself IIRC, like &quot;Your input is 103053439&quot; rather than a link.<p>One thing that bothers me more though is when the example input is nonsense for Part II or can be solved but in a radically different way because it has very different properties than the inputs people are given for real. Contrast day 19, where the example input has a rational answer, which you are told about for the Part II, against day 20 where the example input is completely irrelevant for Part II and good luck.</div><br/><div id="38821186" class="c"><input type="checkbox" id="c-38821186" checked=""/><div class="controls bullet"><span class="by">epiccoleman</span><span>|</span><a href="#38820867">root</a><span>|</span><a href="#38820989">parent</a><span>|</span><a href="#38821381">next</a><span>|</span><label class="collapse" for="c-38821186">[-]</label><label class="expand" for="c-38821186">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s always rough when you write a solution for part 2, and it passes all the samples, but then has issues with the real input.<p>One thing I&#x27;ve tried to do when I run into those kinds of problems is to write a little benchmark to illustrate the difference between approaches.  It&#x27;s always kinda fun to watch your initial brute force solution start chugging while your shiny new solution seems to handle whatever you toss at it - great lesson in choosing effective algorithms.<p>I use Elixir to do the puzzles, so I&#x27;ve used Benchee for this, and it works very well. So easy to set up too.<p>Here&#x27;s an example benchmark, which also has the output. As the input size increases you start getting some pretty crazy ratios between the two algorithms (the &quot;smart&quot; version was 200,000 times faster than the &quot;naive&quot; one on the largest test input!)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;epiccoleman&#x2F;advent_of_code_ex&#x2F;blob&#x2F;master&#x2F;test&#x2F;aoc_2021&#x2F;day06&#x2F;day06_benchmarks.exs">https:&#x2F;&#x2F;github.com&#x2F;epiccoleman&#x2F;advent_of_code_ex&#x2F;blob&#x2F;master...</a></div><br/></div></div></div></div><div id="38821381" class="c"><input type="checkbox" id="c-38821381" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#38820867">parent</a><span>|</span><a href="#38820989">prev</a><span>|</span><a href="#38820690">next</a><span>|</span><label class="collapse" for="c-38821381">[-]</label><label class="expand" for="c-38821381">[1 more]</label></div><br/><div class="children"><div class="content">I like them a lot because they inject a little bit of empirical or heuristic thinking into problems. For this particular problem I immediately reached for graphviz to get an idea of what the circuit looks like and it made it obvious what the solution was.<p>It&#x27;s much closer to how real world engineering problems work where you have to do a little bit of investigation and maybe find some creative way to constrain your problem that nobody explicitly tells you about. Much prefer it to the &#x27;here are the exact five keywords so you know what CS class algorithm you need to use&#x27; kind of thing.</div><br/></div></div></div></div><div id="38820690" class="c"><input type="checkbox" id="c-38820690" checked=""/><div class="controls bullet"><span class="by">ynniv</span><span>|</span><a href="#38820867">prev</a><span>|</span><a href="#38820851">next</a><span>|</span><label class="collapse" for="c-38820690">[-]</label><label class="expand" for="c-38820690">[9 more]</label></div><br/><div class="children"><div class="content"><i>First I started by modelling the devices as objects. Starting with a single base class that has most of the common behaviour.</i><p>Object oriented programming has ruined us</div><br/><div id="38820768" class="c"><input type="checkbox" id="c-38820768" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#38820690">parent</a><span>|</span><a href="#38820755">next</a><span>|</span><label class="collapse" for="c-38820768">[-]</label><label class="expand" for="c-38820768">[4 more]</label></div><br/><div class="children"><div class="content">To expand on this: The issue is that OOP easily leads you to model your <i>problem</i> into your solution. This has the desired effect of solving the problem, but the likely undesired side effect that your solution encodes a specific problem description.<p>Thats why this is an issue</div><br/><div id="38822204" class="c"><input type="checkbox" id="c-38822204" checked=""/><div class="controls bullet"><span class="by">jansimonek</span><span>|</span><a href="#38820690">root</a><span>|</span><a href="#38820768">parent</a><span>|</span><a href="#38821944">next</a><span>|</span><label class="collapse" for="c-38822204">[-]</label><label class="expand" for="c-38822204">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem is not OOP - the author approached the problem bottom-up, they were trying to foresee usage for code they were writing. The resulting code is a bit of a mess, not OOP (there’s even instanceof) Instead we should start with the usage, with the code creating the value and then filling in the details. In this problem, if we choose to simulate the circuit I would start with the simulator code, introducing abstractions for components only if it would help the simulator.<p>I liked the demonstration of this approach in Chapter 6 of Robert C. Martin’s Agile Software Development: Principles, Patterns and Practices. It’s available online here:<p><a href="https:&#x2F;&#x2F;people.scs.carleton.ca&#x2F;~jeanpier&#x2F;&#x2F;Fall2021&#x2F;Topic%201%20-%20TDD&#x2F;3c-%20long%20TDD%20example&#x2F;TDD-BowlingScore.pdf" rel="nofollow">https:&#x2F;&#x2F;people.scs.carleton.ca&#x2F;~jeanpier&#x2F;&#x2F;Fall2021&#x2F;Topic%201...</a></div><br/></div></div><div id="38821944" class="c"><input type="checkbox" id="c-38821944" checked=""/><div class="controls bullet"><span class="by">ynniv</span><span>|</span><a href="#38820690">root</a><span>|</span><a href="#38820768">parent</a><span>|</span><a href="#38822204">prev</a><span>|</span><a href="#38821511">next</a><span>|</span><label class="collapse" for="c-38821944">[-]</label><label class="expand" for="c-38821944">[1 more]</label></div><br/><div class="children"><div class="content">There are a few problems with OOP. The one that bothers me the most is that there is immediately boilerplate complexity. How is this bag of data addressed? What does it behave like? How is each piece of it read and written? Now you need collection generics. There’s complexity everywhere, and it’s expensive. It hampers concurrency, and doesn’t work on GPUs. What do we get for it? Implicit control flow, and it isn’t even clear to me that this is a benefit let alone worth the costs. Any time performance is remotely a concern, object orientation should be the first thing removed.</div><br/></div></div><div id="38821511" class="c"><input type="checkbox" id="c-38821511" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#38820690">root</a><span>|</span><a href="#38820768">parent</a><span>|</span><a href="#38821944">prev</a><span>|</span><a href="#38820755">next</a><span>|</span><label class="collapse" for="c-38821511">[-]</label><label class="expand" for="c-38821511">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Generally the best code in OOP languages tends to favour composition over inheritance. In other words, it uses functional ideas and works around some of the clunkiness of OOP to build generic structures and algorithms. This is what really successful packages in OOP languages look like (such as numpy and friends).</div><br/></div></div></div></div><div id="38820755" class="c"><input type="checkbox" id="c-38820755" checked=""/><div class="controls bullet"><span class="by">rapfaria</span><span>|</span><a href="#38820690">parent</a><span>|</span><a href="#38820768">prev</a><span>|</span><a href="#38820851">next</a><span>|</span><label class="collapse" for="c-38820755">[-]</label><label class="expand" for="c-38820755">[4 more]</label></div><br/><div class="children"><div class="content">What ruins folks these days? Functional?</div><br/><div id="38820759" class="c"><input type="checkbox" id="c-38820759" checked=""/><div class="controls bullet"><span class="by">tekla</span><span>|</span><a href="#38820690">root</a><span>|</span><a href="#38820755">parent</a><span>|</span><a href="#38820930">prev</a><span>|</span><a href="#38820851">next</a><span>|</span><label class="collapse" for="c-38820759">[-]</label><label class="expand" for="c-38820759">[2 more]</label></div><br/><div class="children"><div class="content">Rust</div><br/><div id="38821257" class="c"><input type="checkbox" id="c-38821257" checked=""/><div class="controls bullet"><span class="by">sam1r</span><span>|</span><a href="#38820690">root</a><span>|</span><a href="#38820759">parent</a><span>|</span><a href="#38820851">next</a><span>|</span><label class="collapse" for="c-38821257">[-]</label><label class="expand" for="c-38821257">[1 more]</label></div><br/><div class="children"><div class="content">Everything rusts’ eventually</div><br/></div></div></div></div></div></div></div></div><div id="38820851" class="c"><input type="checkbox" id="c-38820851" checked=""/><div class="controls bullet"><span class="by">noxvilleza</span><span>|</span><a href="#38820690">prev</a><span>|</span><a href="#38820807">next</a><span>|</span><label class="collapse" for="c-38820851">[-]</label><label class="expand" for="c-38820851">[1 more]</label></div><br/><div class="children"><div class="content">One thing to note is that periodicity need not all be prime numbers, so you can&#x27;t always find the product of their periods -- you might need to find their LCM.</div><br/></div></div><div id="38820807" class="c"><input type="checkbox" id="c-38820807" checked=""/><div class="controls bullet"><span class="by">Yajirobe</span><span>|</span><a href="#38820851">prev</a><span>|</span><a href="#38821290">next</a><span>|</span><label class="collapse" for="c-38820807">[-]</label><label class="expand" for="c-38820807">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But if we multiply the numbers together we get a number that is divisible by every number in the table.<p>Wouldn’t LCM be the correct&#x2F;more general approach? The periods could have common factors, right?</div><br/><div id="38820814" class="c"><input type="checkbox" id="c-38820814" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38820807">parent</a><span>|</span><a href="#38821290">next</a><span>|</span><label class="collapse" for="c-38820814">[-]</label><label class="expand" for="c-38820814">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s correct. In practice it appears that the AoC inputs provide numbers which are always co-prime (ie have no common factors other than 1).</div><br/><div id="38822075" class="c"><input type="checkbox" id="c-38822075" checked=""/><div class="controls bullet"><span class="by">dunham</span><span>|</span><a href="#38820807">root</a><span>|</span><a href="#38820814">parent</a><span>|</span><a href="#38821290">next</a><span>|</span><label class="collapse" for="c-38822075">[-]</label><label class="expand" for="c-38822075">[1 more]</label></div><br/><div class="children"><div class="content">Do you know if there were any inputs on this problem that had non-prime numbers? Like others, I used LCM in my code, but mine were all prime numbers.</div><br/></div></div></div></div></div></div><div id="38821290" class="c"><input type="checkbox" id="c-38821290" checked=""/><div class="controls bullet"><span class="by">hfuaiobfa</span><span>|</span><a href="#38820807">prev</a><span>|</span><label class="collapse" for="c-38821290">[-]</label><label class="expand" for="c-38821290">[1 more]</label></div><br/><div class="children"><div class="content">I had a difficult time with both part 1&amp;2 of Day 20. At first I just mentally modeled the circuit as &quot;clock-based&quot; where the Flip-Flops flip only when all previous pulses are processed and a synchronizing clock signal is given,<p>e.g. a flip-flop (default to low) with 2 input ports, on first clock signal (time 1) both ports receives a low pulse; second clock signal (time 2) the flip-flop inspects 2 inputs and decides to give a low (two flips) at the end.<p>Frustratingly, this model passes the 2 examples flawlessly but fails for the real input.</div><br/></div></div></div></div></div></div></div></body></html>