<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707642064564" as="style"/><link rel="stylesheet" href="styles.css?v=1707642064564"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://onlinelibrary.wiley.com/doi/10.1002/spe.3313">On-demand JSON: A better way to parse documents?</a> <span class="domain">(<a href="https://onlinelibrary.wiley.com">onlinelibrary.wiley.com</a>)</span></div><div class="subtext"><span>warpech</span> | <span>33 comments</span></div><br/><div><div id="39321216" class="c"><input type="checkbox" id="c-39321216" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#39331881">next</a><span>|</span><label class="collapse" for="c-39321216">[-]</label><label class="expand" for="c-39321216">[5 more]</label></div><br/><div class="children"><div class="content">So they&#x27;re creating a DOM-like api in front of a sax style parser and getting faster results (barring FPGA and GPU research).  It&#x27;s released as part of SIMDJson.<p>I wonder if that kind of front end was done in the age of SAX parsers?<p>Such a well-written paper.</div><br/><div id="39331807" class="c"><input type="checkbox" id="c-39331807" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#39321216">parent</a><span>|</span><a href="#39329430">next</a><span>|</span><label class="collapse" for="c-39331807">[-]</label><label class="expand" for="c-39331807">[1 more]</label></div><br/><div class="children"><div class="content">SAX is a push parser, presumably this is on top of a pull API like StAX.<p>The Jakarta JSON streaming API sort of gets at this (sort of):<p><a href="https:&#x2F;&#x2F;jakarta.ee&#x2F;specifications&#x2F;platform&#x2F;9&#x2F;apidocs&#x2F;jakarta&#x2F;json&#x2F;stream&#x2F;jsonparser" rel="nofollow">https:&#x2F;&#x2F;jakarta.ee&#x2F;specifications&#x2F;platform&#x2F;9&#x2F;apidocs&#x2F;jakarta...</a><p>The basic interface to a JSON document is something like an iterator, which lets you advance through the document, token by token, and read out values when you encounter them. So if you have an array of objects with x and y fields, you read a start of array, start of object, key &quot;x&quot;, first x value, key &quot;y&quot;, first y value, end of object, start of object, key &quot;x&quot;, second x value, key &quot;y&quot;, second y value, end of object,  etc. Reading tokens, not anything tree&#x2F;DOM-like. But there are also methods getObject() and getArray(), which pull a whole structure out of the document from wherever the iterator has got to. So you could read start of array, read object, read object, etc. That lets you process a document incrementally, without having to materialise the whole thing as a tree, but still having a nice tree-like interface at the leaves.<p>In principle, you could implement getObject() and getArray() in a way which does not eagerly materialise their contents - each node could know a range in a backing buffer, and parse contents on demand. But i don&#x27;t think implementations actually do this.<p>Wrapping a tree-like interface round incremental parsing that doesn&#x27;t require eager parsing or retaining arbitrary amounts of data, and doesn&#x27;t leak implementation details, sounds astoundingly hard, perhaps even impossible. But then i am not Daniel Lemire. And i have not read the paper.</div><br/></div></div><div id="39329430" class="c"><input type="checkbox" id="c-39329430" checked=""/><div class="controls bullet"><span class="by">phh</span><span>|</span><a href="#39321216">parent</a><span>|</span><a href="#39331807">prev</a><span>|</span><a href="#39331881">next</a><span>|</span><label class="collapse" for="c-39329430">[-]</label><label class="expand" for="c-39329430">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder if that kind of front end was done in the age of SAX parsers?<p>I though that XPath over SAX was a thing, and xslt was doing sax-like parsing, but turns out I&#x27;m wrong. Which is logical considering XPath can refer to previous nodes. That being said, it looks like there is streamable xslt in xslt 3.0, but that looks more niche</div><br/><div id="39333320" class="c"><input type="checkbox" id="c-39333320" checked=""/><div class="controls bullet"><span class="by">riedel</span><span>|</span><a href="#39321216">root</a><span>|</span><a href="#39329430">parent</a><span>|</span><a href="#39330713">next</a><span>|</span><label class="collapse" for="c-39333320">[-]</label><label class="expand" for="c-39333320">[1 more]</label></div><br/><div class="children"><div class="content">I did some automata for parsing, transformation and compression in my PhD. I think that XPath is the major failure in XML standardization, with XSLT building on this. If we had a stricter language we could easily compile much of the XML stuff and do binary XML much more extensively.</div><br/></div></div><div id="39330713" class="c"><input type="checkbox" id="c-39330713" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#39321216">root</a><span>|</span><a href="#39329430">parent</a><span>|</span><a href="#39333320">prev</a><span>|</span><a href="#39331881">next</a><span>|</span><label class="collapse" for="c-39330713">[-]</label><label class="expand" for="c-39330713">[1 more]</label></div><br/><div class="children"><div class="content">Often a combination of sax and dom is usefull. You get many GBs of SAX stream, but it usually contains the same kind of documents. Creating a DOM at the end a specific token means fast processing, but still the easy of use of DOM.</div><br/></div></div></div></div></div></div><div id="39331881" class="c"><input type="checkbox" id="c-39331881" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#39321216">prev</a><span>|</span><a href="#39332942">next</a><span>|</span><label class="collapse" for="c-39331881">[-]</label><label class="expand" for="c-39331881">[3 more]</label></div><br/><div class="children"><div class="content">Why not just use msgpack?  The advantage of JSON is that support is already built in to everything and you don&#x27;t have to think about it.<p>If you start having to actually make an effort to fuss with it, then why not consider other formats?<p>This does have nice backwards compatibility with existing JSON stuff though, and sticking to standards is cool.  But msgpack is also pretty nice.</div><br/><div id="39332280" class="c"><input type="checkbox" id="c-39332280" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#39331881">parent</a><span>|</span><a href="#39332704">next</a><span>|</span><label class="collapse" for="c-39332280">[-]</label><label class="expand" for="c-39332280">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be geared towards using a heavily adopted format.<p>Some would want to move to binary, but it&#x27;s hard to find an ideal universal binary format.<p>msgpack doesn&#x27;t support a binary chunk bigger than 4gb, which is unfortunate. Also the JavaScript library doesn&#x27;t handle Map vs plain object.<p>In JSON you could have a 10GB Base64 blob, such as a video, in a string, no problem (from the format side, with a library YMMV).<p>For one that supports up 64 bit lengths, check out CBOR: <a href="https:&#x2F;&#x2F;cbor.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cbor.io&#x2F;</a> With libraries maybe it could be the ideal universal binary format (universal in the same sense JSON is - I&#x27;ve heard it called that). <a href="https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3222851&#x2F;what-is-json-a-better-format-for-data-exchange.html" rel="nofollow">https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3222851&#x2F;what-is-json-a-bet...</a></div><br/></div></div><div id="39332704" class="c"><input type="checkbox" id="c-39332704" checked=""/><div class="controls bullet"><span class="by">serial_dev</span><span>|</span><a href="#39331881">parent</a><span>|</span><a href="#39332280">prev</a><span>|</span><a href="#39332942">next</a><span>|</span><label class="collapse" for="c-39332704">[-]</label><label class="expand" for="c-39332704">[1 more]</label></div><br/><div class="children"><div class="content">Example: you work on the mobile team, the backend team is large and focuses on serving the web app, they send huge JSON payloads that the mobile app only partially need, and asking the backend team to now also serve msgpack is out of the question as things together with the backend and web teams were proven to be a PITA.<p>In this scenario, writing a new, or bundling someone else&#x27;s json library can significantly improve things.</div><br/></div></div></div></div><div id="39332942" class="c"><input type="checkbox" id="c-39332942" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#39331881">prev</a><span>|</span><a href="#39332144">next</a><span>|</span><label class="collapse" for="c-39332942">[-]</label><label class="expand" for="c-39332942">[1 more]</label></div><br/><div class="children"><div class="content">This is a real “why didn’t I think of that” moment for sure. So many systems I’ve written have profiled with most of the cpu and allocations in the JSON parser, when all it needs is a few fields. But rewriting it all in SAX is just not worth all the trouble.</div><br/></div></div><div id="39332144" class="c"><input type="checkbox" id="c-39332144" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39332942">prev</a><span>|</span><a href="#39329712">next</a><span>|</span><label class="collapse" for="c-39332144">[-]</label><label class="expand" for="c-39332144">[2 more]</label></div><br/><div class="children"><div class="content">Is this different from what everyone was doing with XML back in the day?</div><br/><div id="39333566" class="c"><input type="checkbox" id="c-39333566" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#39332144">parent</a><span>|</span><a href="#39329712">next</a><span>|</span><label class="collapse" for="c-39333566">[-]</label><label class="expand" for="c-39333566">[1 more]</label></div><br/><div class="children"><div class="content">JSON has a lot more optimization that XML never got. Which I think says more about general interest in XML more than anything. Even today my experience is that XML processing varies wildly from &quot;perfectly reasonable&quot; to &quot;maybe I can just do this with regex instead&quot; even with widely used parsers.<p>Also XML has a number of features to care about like attributes as well as elements, and also potentially about schema. It&#x27;s also needlessly verbose. Even though elements open and close in a stack there isn&#x27;t a universal &quot;close&quot; tag. That is, if `&lt;Tag1&gt;&lt;Tag2&gt;&lt;&#x2F;Tag1&gt;&lt;&#x2F;Tag2&gt;` is always considered malformed, then why isn&#x27;t the syntax simply `&lt;Tag1&gt;&lt;Tag2&gt;&lt;&#x2F;&gt;&lt;&#x2F;&gt;`?</div><br/></div></div></div></div><div id="39329712" class="c"><input type="checkbox" id="c-39329712" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#39332144">prev</a><span>|</span><a href="#39332968">next</a><span>|</span><label class="collapse" for="c-39329712">[-]</label><label class="expand" for="c-39329712">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really understand what&#x27;s new here compared to what SIMDJSON supported already.<p>Anyways, it&#x27;s the best JSON parser I found (in any language), I implemented fastgron (<a href="https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron">https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron</a>) on top of it because of the on demand library performance.<p>One problem with the library was that it needed extra padding at the end of the JSON, so it didn&#x27;t support streaming &#x2F; memory mapping.</div><br/><div id="39330771" class="c"><input type="checkbox" id="c-39330771" checked=""/><div class="controls bullet"><span class="by">TkTech</span><span>|</span><a href="#39329712">parent</a><span>|</span><a href="#39330674">next</a><span>|</span><label class="collapse" for="c-39330771">[-]</label><label class="expand" for="c-39330771">[1 more]</label></div><br/><div class="children"><div class="content">This on-demand model has been implemented in simdjson for awhile. This is just the release of the paper.<p>Previously, simdjson only had a DOM model, where the entire document was parsed in one shot.</div><br/></div></div><div id="39330674" class="c"><input type="checkbox" id="c-39330674" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39329712">parent</a><span>|</span><a href="#39330771">prev</a><span>|</span><a href="#39332968">next</a><span>|</span><label class="collapse" for="c-39330674">[-]</label><label class="expand" for="c-39330674">[1 more]</label></div><br/><div class="children"><div class="content">Nice work! I will have to check out your implementation and see if I can borrow any of your optimization ideas. I built jindex (<a href="https:&#x2F;&#x2F;github.com&#x2F;ckampfe&#x2F;jindex">https:&#x2F;&#x2F;github.com&#x2F;ckampfe&#x2F;jindex</a>) because I also wanted a faster gron!</div><br/></div></div></div></div><div id="39332968" class="c"><input type="checkbox" id="c-39332968" checked=""/><div class="controls bullet"><span class="by">skibz</span><span>|</span><a href="#39329712">prev</a><span>|</span><a href="#39329909">next</a><span>|</span><label class="collapse" for="c-39332968">[-]</label><label class="expand" for="c-39332968">[1 more]</label></div><br/><div class="children"><div class="content">Pretty cool!<p>This reminds me of oboe.js: <a href="https:&#x2F;&#x2F;github.com&#x2F;jimhigson&#x2F;oboe.js">https:&#x2F;&#x2F;github.com&#x2F;jimhigson&#x2F;oboe.js</a></div><br/></div></div><div id="39329909" class="c"><input type="checkbox" id="c-39329909" checked=""/><div class="controls bullet"><span class="by">hwestiii</span><span>|</span><a href="#39332968">prev</a><span>|</span><a href="#39331792">next</a><span>|</span><label class="collapse" for="c-39329909">[-]</label><label class="expand" for="c-39329909">[1 more]</label></div><br/><div class="children"><div class="content">On face it, this sounds kind of like the XML::Twig perl module.</div><br/></div></div><div id="39331792" class="c"><input type="checkbox" id="c-39331792" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#39329909">prev</a><span>|</span><a href="#39331590">next</a><span>|</span><label class="collapse" for="c-39331792">[-]</label><label class="expand" for="c-39331792">[1 more]</label></div><br/><div class="children"><div class="content">Related submission from yesterday:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39319746">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39319746</a> - JSON Parsing: Intel Sapphire Rapids versus AMD Zen 4 - 40 points and 10 comments</div><br/></div></div><div id="39331590" class="c"><input type="checkbox" id="c-39331590" checked=""/><div class="controls bullet"><span class="by">pshirshov</span><span>|</span><a href="#39331792">prev</a><span>|</span><a href="#39331085">next</a><span>|</span><label class="collapse" for="c-39331590">[-]</label><label class="expand" for="c-39331590">[1 more]</label></div><br/><div class="children"><div class="content">I solved this problem with a custom indexed format: <a href="https:&#x2F;&#x2F;github.com&#x2F;7mind&#x2F;sick">https:&#x2F;&#x2F;github.com&#x2F;7mind&#x2F;sick</a></div><br/></div></div><div id="39331085" class="c"><input type="checkbox" id="c-39331085" checked=""/><div class="controls bullet"><span class="by">basil-rash</span><span>|</span><a href="#39331590">prev</a><span>|</span><a href="#39332233">next</a><span>|</span><label class="collapse" for="c-39331085">[-]</label><label class="expand" for="c-39331085">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The JSON syntax is nearly a strict subset of the popular programming language JavaScript.<p>What JSON isn’t valid JS?</div><br/><div id="39331284" class="c"><input type="checkbox" id="c-39331284" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#39331085">parent</a><span>|</span><a href="#39331334">next</a><span>|</span><label class="collapse" for="c-39331284">[-]</label><label class="expand" for="c-39331284">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Any JSON text is a valid JavaScript expression, but only after the JSON superset revision. Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are allowed in string literals and property keys in JSON; but the same use in JavaScript string literals is a SyntaxError.&quot;<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;JSON" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>&quot;In fact, since JavaScript does not support bare objects, the simple statement {&quot;k&quot;:&quot;v&quot;} will emit an error in JavaScript&quot;<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;@ExplosionPills&#x2F;json-is-not-javascript-5de833fbe49c" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@ExplosionPills&#x2F;json-is-not-javascript-5d...</a></div><br/><div id="39332201" class="c"><input type="checkbox" id="c-39332201" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39331085">root</a><span>|</span><a href="#39331284">parent</a><span>|</span><a href="#39332190">next</a><span>|</span><label class="collapse" for="c-39332201">[-]</label><label class="expand" for="c-39332201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;In fact, since JavaScript does not support bare objects, the simple statement {&quot;k&quot;:&quot;v&quot;} will emit an error in JavaScript&quot;<p>This is kind of a silly, &quot;well technically&quot;. Its a valid expression. Its not a valid statement. It is valid javascript in the sense most people mean when asking the question if something is valid javascript.</div><br/></div></div><div id="39332190" class="c"><input type="checkbox" id="c-39332190" checked=""/><div class="controls bullet"><span class="by">turnsout</span><span>|</span><a href="#39331085">root</a><span>|</span><a href="#39331284">parent</a><span>|</span><a href="#39332201">prev</a><span>|</span><a href="#39331334">next</a><span>|</span><label class="collapse" for="c-39332190">[-]</label><label class="expand" for="c-39332190">[1 more]</label></div><br/><div class="children"><div class="content">Eh, this is slightly dated—{&quot;k&quot;:&quot;v&quot;} does work in the WebKit and Blink consoles, and the superset proposal was approved, so those separators should work fine too.</div><br/></div></div></div></div><div id="39331334" class="c"><input type="checkbox" id="c-39331334" checked=""/><div class="controls bullet"><span class="by">zerocrates</span><span>|</span><a href="#39331085">parent</a><span>|</span><a href="#39331284">prev</a><span>|</span><a href="#39332233">next</a><span>|</span><label class="collapse" for="c-39331334">[-]</label><label class="expand" for="c-39331334">[1 more]</label></div><br/><div class="children"><div class="content">The one thing I&#x27;ve seen mentioned before is the use of &quot;__proto__&quot; as a object property key. Though it&#x27;s valid syntax in both JSON and JS like any other string key, it somewhat uniquely does something different if interpreted as JS (setting the created object&#x27;s prototype) than it does if interpreted as JSON.</div><br/></div></div></div></div><div id="39332233" class="c"><input type="checkbox" id="c-39332233" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#39331085">prev</a><span>|</span><a href="#39332362">next</a><span>|</span><label class="collapse" for="c-39332233">[-]</label><label class="expand" for="c-39332233">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The JSON specification has six structural characters (‘[’, ‘{’, ‘]’, ‘}’, ‘:’, ‘,’) to delimit the location and structure of objects and arrays.<p>Wouldn’t a quote “ also be a structural character? It doesn’t actually represent data, it just delimits the beginning and end of a string.<p>I get why I’m probably wrong: a string isn’t a structure of chars because that’s not a type in json. The above six are the pieces of the two collections in JSON.</div><br/></div></div><div id="39331400" class="c"><input type="checkbox" id="c-39331400" checked=""/><div class="controls bullet"><span class="by">fanseepawnts</span><span>|</span><a href="#39332362">prev</a><span>|</span><label class="collapse" for="c-39331400">[-]</label><label class="expand" for="c-39331400">[7 more]</label></div><br/><div class="children"><div class="content">Sorry, I would never use this.  Before I consume any json from any source or for any purpose I validate it.  Lazy loading serves no purpose if you need validation.<p>Hint: you need validation.</div><br/><div id="39331841" class="c"><input type="checkbox" id="c-39331841" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#39331400">parent</a><span>|</span><a href="#39331752">next</a><span>|</span><label class="collapse" for="c-39331841">[-]</label><label class="expand" for="c-39331841">[2 more]</label></div><br/><div class="children"><div class="content">If you already know it&#x27;s validated and coming from a trusted source there is no reason to validate it again. For example json from a database that only allows inserting valid json. In such cases even the structure might be known and some assumptions can be safely made.</div><br/></div></div><div id="39331752" class="c"><input type="checkbox" id="c-39331752" checked=""/><div class="controls bullet"><span class="by">Seb-C</span><span>|</span><a href="#39331400">parent</a><span>|</span><a href="#39331841">prev</a><span>|</span><a href="#39331583">next</a><span>|</span><label class="collapse" for="c-39331752">[-]</label><label class="expand" for="c-39331752">[2 more]</label></div><br/><div class="children"><div class="content">There are cases where the json does not come from a user input and can be trusted without a validation layer.<p>Also you may want to stream-validate it.</div><br/></div></div><div id="39331583" class="c"><input type="checkbox" id="c-39331583" checked=""/><div class="controls bullet"><span class="by">ysleepy</span><span>|</span><a href="#39331400">parent</a><span>|</span><a href="#39331752">prev</a><span>|</span><label class="collapse" for="c-39331583">[-]</label><label class="expand" for="c-39331583">[2 more]</label></div><br/><div class="children"><div class="content">You need a parser for validation, - preferably a fast, possibly even a streaming one.</div><br/><div id="39332599" class="c"><input type="checkbox" id="c-39332599" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39331400">root</a><span>|</span><a href="#39331583">parent</a><span>|</span><label class="collapse" for="c-39332599">[-]</label><label class="expand" for="c-39332599">[1 more]</label></div><br/><div class="children"><div class="content">Which this is not.<p>A validating parser, that is. The paper clearly indicates that invalid JSON like [1, 1b] will pass, unless your code happens to try and decode the 1b.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>