<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702112456277" as="style"/><link rel="stylesheet" href="styles.css?v=1702112456277"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.florianbellmann.com/blog/never-taught-qa">You are never taught how to build quality software</a> <span class="domain">(<a href="https://www.florianbellmann.com">www.florianbellmann.com</a>)</span></div><div class="subtext"><span>RunOrVeith</span> | <span>327 comments</span></div><br/><div><div id="38574510" class="c"><input type="checkbox" id="c-38574510" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38575638">next</a><span>|</span><label class="collapse" for="c-38574510">[-]</label><label class="expand" for="c-38574510">[83 more]</label></div><br/><div class="children"><div class="content">We do teach these things, they are just not core CS topics, but rather in other areas, relegated to electives like a software engineering course. At CMU we have entire Master&#x27;s program for software engineering and an entire PhD program (in my department). We teach exactly the kinds of things the blog post is about, and more. Software Engineering is a whole field, a whole discipline.<p>I get that this is a blog post and needfully short, but yes, there are courses that teach these skills. There&#x27;s a big disconnect between CS and SE in general, but it&#x27;s not as bad as &quot;no one teaches how to build quality software&quot;. We do work on this.</div><br/><div id="38574989" class="c"><input type="checkbox" id="c-38574989" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38577768">next</a><span>|</span><label class="collapse" for="c-38574989">[-]</label><label class="expand" for="c-38574989">[21 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a massive gap between taught at CMU and taught at most universities. And even if it is taught, it&#x27;s usually outdated or focused on very literal stuff like how to write web applications. I&#x27;d have killed for a class that actually focuses on implementation, on teamwork, on building complicated systems.</div><br/><div id="38576628" class="c"><input type="checkbox" id="c-38576628" checked=""/><div class="controls bullet"><span class="by">heelix</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574989">parent</a><span>|</span><a href="#38579385">next</a><span>|</span><label class="collapse" for="c-38576628">[-]</label><label class="expand" for="c-38576628">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wished that students would be required to hand their semester long project to the person next to them each week.</div><br/><div id="38578110" class="c"><input type="checkbox" id="c-38578110" checked=""/><div class="controls bullet"><span class="by">steveBK123</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576628">parent</a><span>|</span><a href="#38579490">next</a><span>|</span><label class="collapse" for="c-38578110">[-]</label><label class="expand" for="c-38578110">[5 more]</label></div><br/><div class="children"><div class="content">Almost every CS course I took went the other way and had strict cheating policies that essentially made any group work verboten.  There was 1 group project in 1 course I took in 4 years.<p>My spouse on the other hand took an explicitly IT program and they had group projects, engaging with real world users, building real solutions, etc.</div><br/><div id="38579261" class="c"><input type="checkbox" id="c-38579261" checked=""/><div class="controls bullet"><span class="by">WWLink</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578110">parent</a><span>|</span><a href="#38578602">next</a><span>|</span><label class="collapse" for="c-38579261">[-]</label><label class="expand" for="c-38579261">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s crazy! My uni had senior design projects, and labs. Shoot, my community college had those, too. Most of our classes had lab projects, and sometimes the lab projects were group projects. We were encouraged to help each other out. I can&#x27;t imagine a class where collaboration was totally against the rules.<p>And I mean, that went with everything. In my EE classes we did lots of collaboration. We had study groups, homework groups, etc. It was a lot of fun. I&#x27;m sad to hear there are places where they straight up make that against the rules.<p>My uni also had engineering ethics classes - in my major it was mandatory to take 2 of them. I think it makes sense and should be more common for software engineers. A lot of software is used to operate planes, cars, medical equipment, and nowadays also help make decisions that can have life-threatening consequences.</div><br/></div></div><div id="38578602" class="c"><input type="checkbox" id="c-38578602" checked=""/><div class="controls bullet"><span class="by">sdiupIGPWEfh</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578110">parent</a><span>|</span><a href="#38579261">prev</a><span>|</span><a href="#38579490">next</a><span>|</span><label class="collapse" for="c-38578602">[-]</label><label class="expand" for="c-38578602">[3 more]</label></div><br/><div class="children"><div class="content">&gt; strict cheating policies that essentially made any group work verboten<p>If I had to guess, some polytechnic school or another?<p>With some classes even forbidding <i>discussing</i> work with other students, where each assignment required a signed (digitally or otherwise) affidavit listing everyone you consulted, acknowledging that if you actually listed anyone, you were admitting to violating the academic honesty policies and if you didn&#x27;t list anyone yet had spoken with others you were of course also violating the academic honesty policies.<p>Where only consulting the professors or TAs was allowed, the TAs were never around, and the professors refused to help because if they gave you any hints, it would apparently give away the answer, which would be unfair to the other students.</div><br/><div id="38579338" class="c"><input type="checkbox" id="c-38579338" checked=""/><div class="controls bullet"><span class="by">virgilp</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578602">parent</a><span>|</span><a href="#38579490">next</a><span>|</span><label class="collapse" for="c-38579338">[-]</label><label class="expand" for="c-38579338">[2 more]</label></div><br/><div class="children"><div class="content">I taught a course &quot;in a previous life&quot; and while I wasn&#x27;t anything close to as strict as you say here, I can tell you the flip side: students would copy, modify superficially (some, less superficially) and then claim &quot;it&#x27;s my work, we just talked, that&#x27;s why the similarities!&quot; (with some even having the nerve to say, &quot;it&#x27;s not copied, look, plagiarism detection software says similarity is less than x%!)
Perhaps I was wrong but I really wanted the students who took the course to put in the work themselves. Just choose a different course&#x2F;course set, you _knew_ this one was going to be hard!<p>So yeah, the guideline was that we&#x27;ll be eventual judges of what was &quot;too similar&quot; and if you&#x27;re concerned, just don&#x27;t discuss implementation details with anyone. I realize it prevents honest colaboration, and that&#x27;s bad too... but sometimes it&#x27;s a &quot;damned if you do, damned if you don&#x27;t&quot; kind of situation.</div><br/><div id="38579990" class="c"><input type="checkbox" id="c-38579990" checked=""/><div class="controls bullet"><span class="by">toolslive</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38579338">parent</a><span>|</span><a href="#38579490">next</a><span>|</span><label class="collapse" for="c-38579990">[-]</label><label class="expand" for="c-38579990">[1 more]</label></div><br/><div class="children"><div class="content">What we did when correcting the homework is compare the signature of the assembly output (not manually of course). You can move functions around, rename them, change the names of variables, .... but the signature of the instructions remains the same.<p>We caught 2 guys, of course we didn&#x27;t know who copied from whom, but we quickly found out by challenging each of them with a fizz-buzz kind of question.</div><br/></div></div></div></div></div></div></div></div><div id="38579490" class="c"><input type="checkbox" id="c-38579490" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576628">parent</a><span>|</span><a href="#38578110">prev</a><span>|</span><a href="#38578910">next</a><span>|</span><label class="collapse" for="c-38579490">[-]</label><label class="expand" for="c-38579490">[1 more]</label></div><br/><div class="children"><div class="content">Me too. All throughout my education, group projects and speeches were both these scary, uncommon things that you could afford to fuck up, and I skated by on individual talent.<p>Now I&#x27;m an adult, several years into my career, wishing that the schools had done a bigger quantity of low-stakes group projects instead. It&#x27;s a muscle that was never exercised</div><br/></div></div><div id="38578910" class="c"><input type="checkbox" id="c-38578910" checked=""/><div class="controls bullet"><span class="by">accurrent</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576628">parent</a><span>|</span><a href="#38579490">prev</a><span>|</span><a href="#38577579">next</a><span>|</span><label class="collapse" for="c-38578910">[-]</label><label class="expand" for="c-38578910">[1 more]</label></div><br/><div class="children"><div class="content">The university I went to had this. We had to maintain an application that was built by our seniors and then hand that off to the next batch.</div><br/></div></div><div id="38577579" class="c"><input type="checkbox" id="c-38577579" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576628">parent</a><span>|</span><a href="#38578910">prev</a><span>|</span><a href="#38579385">next</a><span>|</span><label class="collapse" for="c-38577579">[-]</label><label class="expand" for="c-38577579">[1 more]</label></div><br/><div class="children"><div class="content">that would be a cool semester long project assignment: everybody has to plan&#x2F;architect their own software project, and then work on implementing them, but you don&#x27;t work on your own project, that you just manage.</div><br/></div></div></div></div><div id="38579385" class="c"><input type="checkbox" id="c-38579385" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574989">parent</a><span>|</span><a href="#38576628">prev</a><span>|</span><a href="#38575459">next</a><span>|</span><label class="collapse" for="c-38579385">[-]</label><label class="expand" for="c-38579385">[1 more]</label></div><br/><div class="children"><div class="content">And then there was &quot;Twenty dirty tricks to train software engineers&quot; which I found even more suitable as preparation for working in the industry.</div><br/></div></div><div id="38575459" class="c"><input type="checkbox" id="c-38575459" checked=""/><div class="controls bullet"><span class="by">sasaf5</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574989">parent</a><span>|</span><a href="#38579385">prev</a><span>|</span><a href="#38576397">next</a><span>|</span><label class="collapse" for="c-38575459">[-]</label><label class="expand" for="c-38575459">[3 more]</label></div><br/><div class="children"><div class="content">+1 for teamwork... I wished there was an established field of study for teamwork in software. If you are impressed with 10x devs, imagine 10x teams!</div><br/><div id="38577276" class="c"><input type="checkbox" id="c-38577276" checked=""/><div class="controls bullet"><span class="by">habnds</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575459">parent</a><span>|</span><a href="#38576397">next</a><span>|</span><label class="collapse" for="c-38577276">[-]</label><label class="expand" for="c-38577276">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe this personally, but I bet that many people with MBA&#x27;s would tell you that this was what their MBA was about.</div><br/><div id="38577461" class="c"><input type="checkbox" id="c-38577461" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577276">parent</a><span>|</span><a href="#38576397">next</a><span>|</span><label class="collapse" for="c-38577461">[-]</label><label class="expand" for="c-38577461">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. A fair bit of this is just “people working in teams” stuff, that people that buy into ‘developer exceptionalism’ will tell you is sacred software developer knowledge. It isn’t.<p>Software engineering isn’t just about teamwork, and not all software development-related teamwork skill is generalisable to other industries, but it’s far from uncommon for there to be some trendy blog post laying out the sorts of things that, yes, an MBA program will teach someone. Which is fine, if not for the fact that these same people will scoff at “clueless MBAs”.</div><br/></div></div></div></div></div></div><div id="38576397" class="c"><input type="checkbox" id="c-38576397" checked=""/><div class="controls bullet"><span class="by">ricw</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574989">parent</a><span>|</span><a href="#38575459">prev</a><span>|</span><a href="#38577085">next</a><span>|</span><label class="collapse" for="c-38576397">[-]</label><label class="expand" for="c-38576397">[6 more]</label></div><br/><div class="children"><div class="content">That was a dedicated software engineering course I took at university. Teams of 5. Had to put the soft eng theory into practice. And if’s not CMU.</div><br/><div id="38577328" class="c"><input type="checkbox" id="c-38577328" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576397">parent</a><span>|</span><a href="#38576884">next</a><span>|</span><label class="collapse" for="c-38577328">[-]</label><label class="expand" for="c-38577328">[1 more]</label></div><br/><div class="children"><div class="content">I had something like this too - it was required for my CS degree.  Our class split up into teams of 5.  But the whole class of 30 was working on a single project.  It was a semester-long project and each team also had to integrate with eachother to build the final solution.</div><br/></div></div><div id="38576884" class="c"><input type="checkbox" id="c-38576884" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576397">parent</a><span>|</span><a href="#38577328">prev</a><span>|</span><a href="#38577085">next</a><span>|</span><label class="collapse" for="c-38576884">[-]</label><label class="expand" for="c-38576884">[4 more]</label></div><br/><div class="children"><div class="content">Do they funnel soon to be grads into stressful zoom calls where product managers handwave an entire legacy stack still somehow running on coldfusion and want a rebrand with &#x27;AI&#x27; starting Jan 1??</div><br/><div id="38577551" class="c"><input type="checkbox" id="c-38577551" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576884">parent</a><span>|</span><a href="#38577085">next</a><span>|</span><label class="collapse" for="c-38577551">[-]</label><label class="expand" for="c-38577551">[3 more]</label></div><br/><div class="children"><div class="content">No, but our professor assigned teams at random, gave us a buggy spec, and then <i>changed</i> the spec with one week to go during finals week. (This last part appears to have planned; they did it every year.)<p>This was a surprisingly effective course, if sadistic.</div><br/><div id="38579383" class="c"><input type="checkbox" id="c-38579383" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577551">parent</a><span>|</span><a href="#38578353">next</a><span>|</span><label class="collapse" for="c-38579383">[-]</label><label class="expand" for="c-38579383">[1 more]</label></div><br/><div class="children"><div class="content">Talk about preparing graduates for the real world!</div><br/></div></div><div id="38578353" class="c"><input type="checkbox" id="c-38578353" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577551">parent</a><span>|</span><a href="#38579383">prev</a><span>|</span><a href="#38577085">next</a><span>|</span><label class="collapse" for="c-38578353">[-]</label><label class="expand" for="c-38578353">[1 more]</label></div><br/><div class="children"><div class="content">It certainly trains the programmer to not box themselves in with assumptions.  What&#x27;s one more for loop?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38577768" class="c"><input type="checkbox" id="c-38577768" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574989">prev</a><span>|</span><a href="#38575024">next</a><span>|</span><label class="collapse" for="c-38577768">[-]</label><label class="expand" for="c-38577768">[11 more]</label></div><br/><div class="children"><div class="content">For years a friend tried to get his department (where he worked as a lecturer) to add a software engineering course where the basic syllabus was to (1) receive a TOI from the last semester and the code base, (2) implement some new features in the code base, (3) deploy and operate the code for awhile, and (4) produce a TOI for the next semester.<p>The code base was for a simple service that basically provided virus&#x2F;malware scanning and included the malware scanner and signatures (this ensured there would never be an end to the work - there&#x27;s always more signatures to add, more features, etc.)<p>I thought this was a fantastic idea and its a pity he never convinced them. That was more than fifteen years ago, and in his plan it would have just run forever.</div><br/><div id="38578337" class="c"><input type="checkbox" id="c-38578337" checked=""/><div class="controls bullet"><span class="by">AlphaWeaver</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577768">parent</a><span>|</span><a href="#38577910">next</a><span>|</span><label class="collapse" for="c-38578337">[-]</label><label class="expand" for="c-38578337">[4 more]</label></div><br/><div class="children"><div class="content">In my university, (US, state school,) we had a software engineering course exactly like this. It was great in theory, but in practice, the experience was rushed, the codebase was poor quality, (layers upon layers of nothing features with varying code quality,) and the background knowledge was completely ignored. The application we had to work on was a Tomcat Java Web application with an Angular frontend, when neither of those technologies were taught in any other classes (including electives.)<p>This approach to education can work, but I think simulating&#x2F;mocking portions of this would have been more helpful (it could&#x27;ve been a teacher&#x2F;TA managed codebase we started with rather than the monstrosity passed between generations of students who were inexperienced.)</div><br/><div id="38578977" class="c"><input type="checkbox" id="c-38578977" checked=""/><div class="controls bullet"><span class="by">Mtinie</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578337">parent</a><span>|</span><a href="#38578481">next</a><span>|</span><label class="collapse" for="c-38578977">[-]</label><label class="expand" for="c-38578977">[1 more]</label></div><br/><div class="children"><div class="content">Am I understanding correctly that your concern was that the course is too close to reality to be useful?</div><br/></div></div><div id="38578481" class="c"><input type="checkbox" id="c-38578481" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578337">parent</a><span>|</span><a href="#38578977">prev</a><span>|</span><a href="#38579684">next</a><span>|</span><label class="collapse" for="c-38578481">[-]</label><label class="expand" for="c-38578481">[1 more]</label></div><br/><div class="children"><div class="content">I think like your example where things go wrong is the most realistic exposure to programming you can give someone.<p>Learning why things are bad, and why it&#x27;s bad to experience them offers a new level of appreciation or better ways to argue why certain things should be done.</div><br/></div></div><div id="38579684" class="c"><input type="checkbox" id="c-38579684" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38578337">parent</a><span>|</span><a href="#38578481">prev</a><span>|</span><a href="#38577910">next</a><span>|</span><label class="collapse" for="c-38579684">[-]</label><label class="expand" for="c-38579684">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like a very realistic classroom experience. I think you missed the point?</div><br/></div></div></div></div><div id="38577910" class="c"><input type="checkbox" id="c-38577910" checked=""/><div class="controls bullet"><span class="by">rjzzleep</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577768">parent</a><span>|</span><a href="#38578337">prev</a><span>|</span><a href="#38577780">next</a><span>|</span><label class="collapse" for="c-38577910">[-]</label><label class="expand" for="c-38577910">[2 more]</label></div><br/><div class="children"><div class="content">The thing is for academics quality software sometimes isn&#x27;t actually quality software.<p>My experience has been that people who&#x27;s first jobs were in companies with quality software or who&#x27;s job included reading through other people&#x27;s quality software learn to write good software, the other ones learn whatever they saw in the environments they worked in.</div><br/></div></div><div id="38577780" class="c"><input type="checkbox" id="c-38577780" checked=""/><div class="controls bullet"><span class="by">maxwelljoslyn</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577768">parent</a><span>|</span><a href="#38577910">prev</a><span>|</span><a href="#38578088">next</a><span>|</span><label class="collapse" for="c-38577780">[-]</label><label class="expand" for="c-38577780">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like an excellent way to do practice that directly mirrors real-world SWE, while still cutting it down to an appropriate size for a pedagogical environment. What a good idea.</div><br/></div></div><div id="38578088" class="c"><input type="checkbox" id="c-38578088" checked=""/><div class="controls bullet"><span class="by">steveBK123</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577768">parent</a><span>|</span><a href="#38577780">prev</a><span>|</span><a href="#38577834">next</a><span>|</span><label class="collapse" for="c-38578088">[-]</label><label class="expand" for="c-38578088">[1 more]</label></div><br/><div class="children"><div class="content">I went to a STEM school and exactly 0 of the professors had been in industry ever or at least in the last 30 years.  The only guy with some experience was an underpaid lecturer.  He was also the only good lecturer.<p>A lot of professors just want to do research and mentor students onto the PHD track to self replicate.  My mandated faculty advisor was basically like &quot;go to the career center&quot; when I asked about, you know, getting a job of some sort with my degree.<p>So yes, it is a real problem.  CMU may stand out by actually having courses in the space, but it is not the norm by any means.</div><br/></div></div><div id="38577834" class="c"><input type="checkbox" id="c-38577834" checked=""/><div class="controls bullet"><span class="by">mwcremer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577768">parent</a><span>|</span><a href="#38578088">prev</a><span>|</span><a href="#38575024">next</a><span>|</span><label class="collapse" for="c-38577834">[-]</label><label class="expand" for="c-38577834">[2 more]</label></div><br/><div class="children"><div class="content">TOI?</div><br/><div id="38577989" class="c"><input type="checkbox" id="c-38577989" checked=""/><div class="controls bullet"><span class="by">dmux</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577834">parent</a><span>|</span><a href="#38575024">next</a><span>|</span><label class="collapse" for="c-38577989">[-]</label><label class="expand" for="c-38577989">[1 more]</label></div><br/><div class="children"><div class="content">I’m guessing Transfer of Information.</div><br/></div></div></div></div></div></div><div id="38575024" class="c"><input type="checkbox" id="c-38575024" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38577768">prev</a><span>|</span><a href="#38574861">next</a><span>|</span><label class="collapse" for="c-38575024">[-]</label><label class="expand" for="c-38575024">[6 more]</label></div><br/><div class="children"><div class="content">If my friends hadn’t had such vividly bad experiences with the compiler class, I might not have taken the distributed computing class that was one of the other options to fulfill that category.<p>It’s not the most defining class of my undergrad years, but it was pretty damned close.<p>The fact that most people designing systems don’t know this material inspires a mix of anger and existential dread.</div><br/><div id="38575062" class="c"><input type="checkbox" id="c-38575062" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575024">parent</a><span>|</span><a href="#38578441">next</a><span>|</span><label class="collapse" for="c-38575062">[-]</label><label class="expand" for="c-38575062">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re specifically referring to CMU&#x27;s compilers course, feel free to follow up with me offline.</div><br/><div id="38579390" class="c"><input type="checkbox" id="c-38579390" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575062">parent</a><span>|</span><a href="#38575075">next</a><span>|</span><label class="collapse" for="c-38579390">[-]</label><label class="expand" for="c-38579390">[2 more]</label></div><br/><div class="children"><div class="content">Why does this feel like the professor trying to either fix the problem or give detention.</div><br/><div id="38579712" class="c"><input type="checkbox" id="c-38579712" checked=""/><div class="controls bullet"><span class="by">mikeyouse</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38579390">parent</a><span>|</span><a href="#38575075">next</a><span>|</span><label class="collapse" for="c-38579712">[-]</label><label class="expand" for="c-38579712">[1 more]</label></div><br/><div class="children"><div class="content">Lol this is who asked whether it was at CMU - <a href="https:&#x2F;&#x2F;s3d.cmu.edu&#x2F;people&#x2F;core-faculty&#x2F;titzer-ben.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;s3d.cmu.edu&#x2F;people&#x2F;core-faculty&#x2F;titzer-ben.html</a>  HN is such a great community.</div><br/></div></div></div></div><div id="38575075" class="c"><input type="checkbox" id="c-38575075" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575062">parent</a><span>|</span><a href="#38579390">prev</a><span>|</span><a href="#38578441">next</a><span>|</span><label class="collapse" for="c-38575075">[-]</label><label class="expand" for="c-38575075">[1 more]</label></div><br/><div class="children"><div class="content">No sorry, I was speaking in the general case not about CMU. This was ages ago and elsewhere. It was clear the prof got caught flat footed.<p>It was practically an elective and these days I hope it’s required.</div><br/></div></div></div></div></div></div><div id="38574861" class="c"><input type="checkbox" id="c-38574861" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38575024">prev</a><span>|</span><a href="#38578475">next</a><span>|</span><label class="collapse" for="c-38574861">[-]</label><label class="expand" for="c-38574861">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I learned these things as a computer science student in an engineering school. It wasn’t perfect but a good introduction.</div><br/></div></div><div id="38578475" class="c"><input type="checkbox" id="c-38578475" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574861">prev</a><span>|</span><a href="#38576643">next</a><span>|</span><label class="collapse" for="c-38578475">[-]</label><label class="expand" for="c-38578475">[1 more]</label></div><br/><div class="children"><div class="content"><i>How many</i> CS or CE grads from CMU are actually exposed to all of these topics?<p>Surely, &quot;it is taught&quot;, but to whom and how widely?</div><br/></div></div><div id="38576643" class="c"><input type="checkbox" id="c-38576643" checked=""/><div class="controls bullet"><span class="by">fudged71</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38578475">prev</a><span>|</span><a href="#38574965">next</a><span>|</span><label class="collapse" for="c-38576643">[-]</label><label class="expand" for="c-38576643">[7 more]</label></div><br/><div class="children"><div class="content">I chose software engineering. 3 years into the program the head of the department made a speech at an event to the effect of &quot;Software hasn&#x27;t changed in the last 10 years&quot;. It instantly devalued the entire program for me.</div><br/><div id="38576706" class="c"><input type="checkbox" id="c-38576706" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576643">parent</a><span>|</span><a href="#38578173">next</a><span>|</span><label class="collapse" for="c-38576706">[-]</label><label class="expand" for="c-38576706">[3 more]</label></div><br/><div class="children"><div class="content">I have news for you... He&#x27;s not wrong. The porcelain is different, but the same methodologies and processes are in place. The biggest change recently is distributed (mostly ignored) version control, that&#x27;s 20 years old, and continuous integration&#x2F;development (probably also around 20 years old, but only catching on in the last 10-15 years).<p>Computer science has changed more, there are lots of developments in the last 5-10 years.</div><br/><div id="38577177" class="c"><input type="checkbox" id="c-38577177" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576706">parent</a><span>|</span><a href="#38577368">next</a><span>|</span><label class="collapse" for="c-38577177">[-]</label><label class="expand" for="c-38577177">[1 more]</label></div><br/><div class="children"><div class="content">The biggest change I’ve seen in 20 years is that things like DVCS and actual good tool chains for languages people actually use are available and in use.</div><br/></div></div><div id="38577368" class="c"><input type="checkbox" id="c-38577368" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576706">parent</a><span>|</span><a href="#38577177">prev</a><span>|</span><a href="#38578173">next</a><span>|</span><label class="collapse" for="c-38577368">[-]</label><label class="expand" for="c-38577368">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there are lots of developments in the last 5-10 years<p>So tell us what these are so I&#x2F;we can learn from you</div><br/></div></div></div></div><div id="38578173" class="c"><input type="checkbox" id="c-38578173" checked=""/><div class="controls bullet"><span class="by">davidgay</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576643">parent</a><span>|</span><a href="#38576706">prev</a><span>|</span><a href="#38577489">next</a><span>|</span><label class="collapse" for="c-38578173">[-]</label><label class="expand" for="c-38578173">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Software hasn&#x27;t changed in the last 10 years&quot;. It instantly devalued the entire program for me.<p>As opposed to maths, physics, philosophy, civil engineering, classical studies which have gone through complete revolutions in their topics, problems and study methods in the last 10 years?</div><br/></div></div><div id="38577489" class="c"><input type="checkbox" id="c-38577489" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576643">parent</a><span>|</span><a href="#38578173">prev</a><span>|</span><a href="#38577974">next</a><span>|</span><label class="collapse" for="c-38577489">[-]</label><label class="expand" for="c-38577489">[1 more]</label></div><br/><div class="children"><div class="content">Hah. This is classic knowitall CS&#x2F;SE student hubris. They were almost certainly right.</div><br/></div></div><div id="38577974" class="c"><input type="checkbox" id="c-38577974" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576643">parent</a><span>|</span><a href="#38577489">prev</a><span>|</span><a href="#38574965">next</a><span>|</span><label class="collapse" for="c-38577974">[-]</label><label class="expand" for="c-38577974">[1 more]</label></div><br/><div class="children"><div class="content">I know where you come from and I know where the people who are responding to you come from too.<p>Software has changed in the last 10 years, but a lot of it has changed superficially. A green software engineer most likely won&#x27;t be able to tell the difference between a superficial change and a fundamental change.<p>It has a lot to do with the topic of this thread. &quot;Quality Software&quot; It&#x27;s a loaded term. There&#x27;s no formal definition, everyone has their own opinion on it and even then these people with &quot;opinions&quot; can&#x27;t even directly pinpoint what it is. So the whole industry just builds abstraction after abstraction without knowing whether the current abstraction is actually close to &quot;quality&quot; then the previous abstraction. It all starts out with someone feeling annoyed, then they decide to make a new thingie or library and then they find out that this new thing has new annoyances and the whole thing moves in a great flat circle.<p>That&#x27;s the story of the entire industry just endless horizontal progress without ever knowing if we&#x27;re getting better. A lot of the times we&#x27;ve gotten worse.<p>That being said there have been fundamental changes. Machine learning. This change is fundamental. But most people aren&#x27;t referring to that here.</div><br/></div></div></div></div><div id="38574965" class="c"><input type="checkbox" id="c-38574965" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38576643">prev</a><span>|</span><a href="#38578354">next</a><span>|</span><label class="collapse" for="c-38574965">[-]</label><label class="expand" for="c-38574965">[6 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the thing, though:  Of a CS graduating class, 90% of them will work as software engineers, not as computer scientists.  (All numbers made up, but I think they&#x27;re about right.)<p>We don&#x27;t need these things to be electives.  We don&#x27;t need them to be a master&#x27;s program.  We need an undergraduate software engineering program, and we need 90% of the people in CS to switch to that program instead.</div><br/><div id="38575018" class="c"><input type="checkbox" id="c-38575018" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574965">parent</a><span>|</span><a href="#38577323">next</a><span>|</span><label class="collapse" for="c-38575018">[-]</label><label class="expand" for="c-38575018">[3 more]</label></div><br/><div class="children"><div class="content">I agree with you! It&#x27;s hard to change curricula because there are so many competing interests. CS is an evolving field and things like machine learning have burst onto the stage, clamoring for attention. There is also an age-old debate about whether CS departments are trade schools, math departments, or science. Personally I think software engineering skills are paramount for 90% of graduates. How do we fit this into a full curriculum? What gets the axe? Unclear.</div><br/><div id="38576225" class="c"><input type="checkbox" id="c-38576225" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575018">parent</a><span>|</span><a href="#38577323">next</a><span>|</span><label class="collapse" for="c-38576225">[-]</label><label class="expand" for="c-38576225">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There is also an age-old debate about whether CS departments are trade schools, math departments, or science. Personally I think software engineering skills are paramount for 90% of graduates.<p>The question as well is: are Chemical Engineering, Mechanical Engineering, Materials Engineering trade schools?<p>I think it&#x27;s a key call out as CS touches on so many things.<p>There are arguments for it being math, science, engineering, a trade school or a combination of the above.<p>And then if you separate them out completely you end up with people doing CS being out of touch with what happens in the real world and vice versa.<p>I think in the end you probably need to have a single overall degree with a specialization in (Programming as Engineering, Programming as Math and Programming as Computer Science,) with lots of overlap in the core.<p>And then you still can have a both a bootcamp style trade school.<p>Now all of that said, that still doesn&#x27;t solve the CS equivalent of &quot;Math for business majors&quot;. Or the equivalent of &quot;Programming for Scientists&quot;, or the like which is already a really important case to offer. Where you major in Bio&#x2F;Chem&#x2F;Other but being able to apply programming to your day job is important.
Although that probably sits closer to the Applied Software category that you might find in business school like using spreadsheets, basic command lines, intro to databases or python.<p>But to your point, how rarely software engineering is being taught is a huge problem. Even if only 30% of degree holders took classes in it, it would be huge in helping spread best practices.</div><br/><div id="38576631" class="c"><input type="checkbox" id="c-38576631" checked=""/><div class="controls bullet"><span class="by">stephendause</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576225">parent</a><span>|</span><a href="#38577323">next</a><span>|</span><label class="collapse" for="c-38576631">[-]</label><label class="expand" for="c-38576631">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think that software engineering is a trade per se. I think it is a much more creative activity that requires a lot more baseline knowledge. I think an automotive engineer is to a mechanic as a software engineer is to an IT administrator. There is still a fair amount of creativity and knowledge required for being a mechanic or IT admin, but I don&#x27;t think it&#x27;s nearly the same amount.<p>Software engineering is interesting, though, because it does not require as much formal education as many other engineering fields to get a job. I think this is in part because it is very economically valuable (in the US at least) and because the only tool you need is a computer with an Internet connection.<p>With all of that said, I think SWE is probably closer to a trade than other engineering disciplines, but not by all that much.</div><br/></div></div></div></div></div></div><div id="38577323" class="c"><input type="checkbox" id="c-38577323" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574965">parent</a><span>|</span><a href="#38575018">prev</a><span>|</span><a href="#38578354">next</a><span>|</span><label class="collapse" for="c-38577323">[-]</label><label class="expand" for="c-38577323">[2 more]</label></div><br/><div class="children"><div class="content">A large number of CS programs are already glorified Java training courses.</div><br/><div id="38578376" class="c"><input type="checkbox" id="c-38578376" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577323">parent</a><span>|</span><a href="#38578354">next</a><span>|</span><label class="collapse" for="c-38578376">[-]</label><label class="expand" for="c-38578376">[1 more]</label></div><br/><div class="children"><div class="content">Exactly what I see. I know a few cases of CTOs influencing the curriculum of CS courses, pushing it to be more “market ready”. Which was effectively turning it into a 4 year bootcamp.<p>Which is a big shame, because it’s very common to see developers who would have benefited from a proper CS curriculum, and have to learn it later in life.</div><br/></div></div></div></div></div></div><div id="38578354" class="c"><input type="checkbox" id="c-38578354" checked=""/><div class="controls bullet"><span class="by">podviaznikov</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574965">prev</a><span>|</span><a href="#38574925">next</a><span>|</span><label class="collapse" for="c-38578354">[-]</label><label class="expand" for="c-38578354">[1 more]</label></div><br/><div class="children"><div class="content">100% this. My master program was for software engineering not CS. 15 years ago in Ukraine.<p>We have that. Maybe not enough. But it&#x27;s definitely not a new thing.</div><br/></div></div><div id="38574925" class="c"><input type="checkbox" id="c-38574925" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38578354">prev</a><span>|</span><a href="#38574892">next</a><span>|</span><label class="collapse" for="c-38574925">[-]</label><label class="expand" for="c-38574925">[1 more]</label></div><br/><div class="children"><div class="content">Worth mentioning that SE isn&#x27;t even a thing for the most part at non STEM-specific schools and&#x2F;or outside very large colleges&#x2F;universities</div><br/></div></div><div id="38574892" class="c"><input type="checkbox" id="c-38574892" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574925">prev</a><span>|</span><a href="#38577148">next</a><span>|</span><label class="collapse" for="c-38574892">[-]</label><label class="expand" for="c-38574892">[9 more]</label></div><br/><div class="children"><div class="content">Do SE classes teach debugging skills? I hope they do. So many times I have seen people try random things rather than follow a systematic approach.</div><br/><div id="38575246" class="c"><input type="checkbox" id="c-38575246" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574892">parent</a><span>|</span><a href="#38577311">next</a><span>|</span><label class="collapse" for="c-38575246">[-]</label><label class="expand" for="c-38575246">[6 more]</label></div><br/><div class="children"><div class="content">I worked with programmers around my junior year and some of them were in classes I was in. I thought they were all playing one-upsmanship when I heard how little time they were spending on homework. 90 minutes, sometimes an hour.<p>I was a lot faster than my roommate, and after I turned in my homework I’d help him debug (not solve) his. Then I was helping other people. They really did not get debugging. Definitely felt like a missing class. But it helped me out with mentoring later on. When giving people the answer can get you expelled, you have to get pretty good  at asking leading questions.<p>Then I got a real job, and within a semester I was down below 2 hours. We just needed more practice, and lots of it.</div><br/><div id="38576836" class="c"><input type="checkbox" id="c-38576836" checked=""/><div class="controls bullet"><span class="by">SamuelAdams</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575246">parent</a><span>|</span><a href="#38578083">next</a><span>|</span><label class="collapse" for="c-38576836">[-]</label><label class="expand" for="c-38576836">[4 more]</label></div><br/><div class="children"><div class="content">This is why internships and real world experience is so important. A course is 3 in class hours a week over 12-14 weeks typically. After homework and assignments it is ultimately maybe 40-80 hours of content.<p>Which means you learn more in one month of being on a normal, 40 hour workweek job than you have in an entire semester of one course.</div><br/><div id="38577515" class="c"><input type="checkbox" id="c-38577515" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576836">parent</a><span>|</span><a href="#38577317">next</a><span>|</span><label class="collapse" for="c-38577515">[-]</label><label class="expand" for="c-38577515">[1 more]</label></div><br/><div class="children"><div class="content">Not all hours are created equal. This is on the verge of saying “I took 1,000 breaths on my run, so if I do that again, it’s like going for a run.”  Just because you’re measuring something, it doesn’t mean that you’re measuring the right thing. You’re just cargo-culting the “formal education is useless” meme.</div><br/></div></div><div id="38577317" class="c"><input type="checkbox" id="c-38577317" checked=""/><div class="controls bullet"><span class="by">astura</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576836">parent</a><span>|</span><a href="#38577515">prev</a><span>|</span><a href="#38578083">next</a><span>|</span><label class="collapse" for="c-38577317">[-]</label><label class="expand" for="c-38577317">[2 more]</label></div><br/><div class="children"><div class="content">&gt;A course is 3 in class hours a week over 12-14 weeks typically. After homework and assignments it is ultimately maybe 40-80 hours of content.<p>Huh? I was spending 20+ hours a week on assignments alone in upper level software engineering classes.<p>Also, internships were required.</div><br/><div id="38577919" class="c"><input type="checkbox" id="c-38577919" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38577317">parent</a><span>|</span><a href="#38578083">next</a><span>|</span><label class="collapse" for="c-38577919">[-]</label><label class="expand" for="c-38577919">[1 more]</label></div><br/><div class="children"><div class="content">Were you the sort of person who responsibly worked a little bit on the assignments over the course of the week&#x2F;two weeks, or did you carve out an evening to try to get the whole thing done in one or two sittings?<p>My group did the latter. I think based on what we know now about interruptions, we were likely getting more done per minute than the responsible kids.<p>Including reading, we might have been doing 15 hours a week sustained, across 2-3 core classes.<p>But these were the sort of people who got their homework done so they could go back to the ACM office to work on their computer game, or work out how to squeeze a program we all wanted to use into our meager disk space quota.<p>Anything more than a B was chasing academia over practical knowledge.  B- to C+ was optimal.</div><br/></div></div></div></div></div></div><div id="38578083" class="c"><input type="checkbox" id="c-38578083" checked=""/><div class="controls bullet"><span class="by">gpcz</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575246">parent</a><span>|</span><a href="#38576836">prev</a><span>|</span><a href="#38577311">next</a><span>|</span><label class="collapse" for="c-38578083">[-]</label><label class="expand" for="c-38578083">[1 more]</label></div><br/><div class="children"><div class="content">I believe that software-related college degrees are mainly there to get the horrible first few tens of thousands of lines of code out of people before they go into industry.</div><br/></div></div></div></div><div id="38577311" class="c"><input type="checkbox" id="c-38577311" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574892">parent</a><span>|</span><a href="#38575246">prev</a><span>|</span><a href="#38575493">next</a><span>|</span><label class="collapse" for="c-38577311">[-]</label><label class="expand" for="c-38577311">[1 more]</label></div><br/><div class="children"><div class="content">Trying random things seems to be how a large number of professional software engineers do their jobs. Stack Overflow and now CodeGPT seem to contribute to this.</div><br/></div></div><div id="38575493" class="c"><input type="checkbox" id="c-38575493" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574892">parent</a><span>|</span><a href="#38577311">prev</a><span>|</span><a href="#38577148">next</a><span>|</span><label class="collapse" for="c-38575493">[-]</label><label class="expand" for="c-38575493">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if software engineering classes in particular do, but at my university, they teach C++ in the second required course, and they teach you about using GDB and Valgrind on Linux there. They don&#x27;t explicitly teach you about systematically debugging, though, beyond knowing how to use those two programs.</div><br/></div></div></div></div><div id="38577148" class="c"><input type="checkbox" id="c-38577148" checked=""/><div class="controls bullet"><span class="by">maxFlow</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574892">prev</a><span>|</span><a href="#38574860">next</a><span>|</span><label class="collapse" for="c-38577148">[-]</label><label class="expand" for="c-38577148">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, I&#x27;m reviewing the curriculum for the program [0] and it looks great.<p>Do you know if any of these courses has been opened sourced? It would be great to have access to part of the material.<p>[0]: <a href="https:&#x2F;&#x2F;www.ece.cmu.edu&#x2F;academics&#x2F;ms-se&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ece.cmu.edu&#x2F;academics&#x2F;ms-se&#x2F;index.html</a>.</div><br/></div></div><div id="38574860" class="c"><input type="checkbox" id="c-38574860" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38577148">prev</a><span>|</span><a href="#38576061">next</a><span>|</span><label class="collapse" for="c-38574860">[-]</label><label class="expand" for="c-38574860">[12 more]</label></div><br/><div class="children"><div class="content">I took one of these kinds of classes in my masters program this year. They were totally obsessed with UML. It would be nice if these classes could move beyond dogma that is decades old.</div><br/><div id="38575553" class="c"><input type="checkbox" id="c-38575553" checked=""/><div class="controls bullet"><span class="by">petsfed</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574860">parent</a><span>|</span><a href="#38575038">next</a><span>|</span><label class="collapse" for="c-38575553">[-]</label><label class="expand" for="c-38575553">[4 more]</label></div><br/><div class="children"><div class="content">What would be better? Change tools every 3-5 years like the industry does, so by the time any given instructor actually has a grasp on a particular tool or paradigm, its already obsolete (or at least fallen out of fashion) too?<p>I&#x27;m no fan of UML, but the exercise is to teach students how to plan, how to express that plan, and how to reason about other people&#x27;s plans. The students will certainly draw a lot of flow diagrams in their careers, and will <i>almost</i> certainly deal with fussy micromanagers who demand their flow diagrams adhere to some arbitrary schema that has only limited impact on the actual quality of their work or documentation.<p>UML is complete, at least.</div><br/><div id="38576109" class="c"><input type="checkbox" id="c-38576109" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575553">parent</a><span>|</span><a href="#38576050">next</a><span>|</span><label class="collapse" for="c-38576109">[-]</label><label class="expand" for="c-38576109">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Change tools every 3-5 years like the industry does, so by the time any given instructor actually has a grasp on a particular tool or paradigm, its already obsolete (or at least fallen out of fashion) too?<p>I mean, yeah. Seeing that wave happen over the course of their college career would probably be better prep for a career than most CS classes.</div><br/></div></div><div id="38576050" class="c"><input type="checkbox" id="c-38576050" checked=""/><div class="controls bullet"><span class="by">failbuffer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575553">parent</a><span>|</span><a href="#38576109">prev</a><span>|</span><a href="#38578255">next</a><span>|</span><label class="collapse" for="c-38576050">[-]</label><label class="expand" for="c-38576050">[1 more]</label></div><br/><div class="children"><div class="content">A whiteboard is complete. Every other way of diagramming software is deficient. Change my mind. ;-)</div><br/></div></div><div id="38578255" class="c"><input type="checkbox" id="c-38578255" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575553">parent</a><span>|</span><a href="#38576050">prev</a><span>|</span><a href="#38575038">next</a><span>|</span><label class="collapse" for="c-38578255">[-]</label><label class="expand" for="c-38578255">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen a UML diagram once in 7 years of working. The approach presented in the book &quot;a philosophy of Software Design&quot; is much better than the outdated bullshit from the 90s.</div><br/></div></div></div></div><div id="38575038" class="c"><input type="checkbox" id="c-38575038" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574860">parent</a><span>|</span><a href="#38575553">prev</a><span>|</span><a href="#38574945">next</a><span>|</span><label class="collapse" for="c-38575038">[-]</label><label class="expand" for="c-38575038">[5 more]</label></div><br/><div class="children"><div class="content">CMU constantly reevaluates its MSE program with input from many different angles. I&#x27;ve participated here and I think we&#x27;re trying hard to balance important foundational knowledge with practical skills of the day. I don&#x27;t think we over-emphasize UML or any one particular silver bullet in our program.</div><br/><div id="38575253" class="c"><input type="checkbox" id="c-38575253" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575038">parent</a><span>|</span><a href="#38574945">next</a><span>|</span><label class="collapse" for="c-38575253">[-]</label><label class="expand" for="c-38575253">[4 more]</label></div><br/><div class="children"><div class="content">To a first approximation, software developers don&#x27;t have masters degrees.  If you are thinking about changing how an industry does its work, focusing on graduate courses seems counterproductive.</div><br/><div id="38575450" class="c"><input type="checkbox" id="c-38575450" checked=""/><div class="controls bullet"><span class="by">HeyLaughingBoy</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575253">parent</a><span>|</span><a href="#38574945">next</a><span>|</span><label class="collapse" for="c-38575450">[-]</label><label class="expand" for="c-38575450">[3 more]</label></div><br/><div class="children"><div class="content">I disagree. I have a Master&#x27;s in Software Engineering and the way to change things is for those with the formal education to try and spread good practices as much as possible in the workplace. Sometimes the main benefit is just <i>knowing</i> that good practices exist so you can seek them out.<p>The biggest impact I&#x27;ve had at the places I&#x27;ve worked have been about procedures and methodology, not how to use UML or draw a dataflow diagram.<p>- Have a process around software releases. Doesn&#x27;t matter what as much as it has to be repeatable.<p>- Review your designs, review your code, don&#x27;t do things in isolation.<p>- Have a known location for documents and project information.<p>- Be consistent, don&#x27;t do every project completely differently.<p>- Get data before you try to fix the problem.<p>- Learn from your mistakes and adjust your processes to that learning.<p>- And many more things that sound like common sense (and they are) but you&#x27;d be amazed at how even in 2023 many companies are developing software in complete chaos, with no discernible process.</div><br/><div id="38575613" class="c"><input type="checkbox" id="c-38575613" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575450">parent</a><span>|</span><a href="#38574945">next</a><span>|</span><label class="collapse" for="c-38575613">[-]</label><label class="expand" for="c-38575613">[2 more]</label></div><br/><div class="children"><div class="content">What I&#x27;m saying is that if your goal is to introduce more engineering rigor and your plan is for for the tiny percentage of graduate school graduates to percolate these ideas through the industry, it&#x27;s probably a bad plan and likely to fail.<p>This was a thread about why software developers don&#x27;t do engineering like other disciplines.  One partial answer is that those other disciplines take it much more seriously at the undergraduate level, at least on average.<p>Probably the more compelling answer is that the industry doesn&#x27;t&#x27; really want them to for the most part.<p>&gt; but you&#x27;d be amazed at how even in 2023<p>I really wouldn&#x27;t.</div><br/><div id="38576508" class="c"><input type="checkbox" id="c-38576508" checked=""/><div class="controls bullet"><span class="by">sheepshear</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38575613">parent</a><span>|</span><a href="#38574945">next</a><span>|</span><label class="collapse" for="c-38576508">[-]</label><label class="expand" for="c-38576508">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Probably the more compelling answer is that the industry doesn&#x27;t&#x27; really want them to for the most part.<p>This is it. Everyone is making money hand over fist despite not doing it. You might want it, but you don&#x27;t need it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38574945" class="c"><input type="checkbox" id="c-38574945" checked=""/><div class="controls bullet"><span class="by">crysin</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574860">parent</a><span>|</span><a href="#38575038">prev</a><span>|</span><a href="#38575288">next</a><span>|</span><label class="collapse" for="c-38574945">[-]</label><label class="expand" for="c-38574945">[1 more]</label></div><br/><div class="children"><div class="content">Got my MS in SE at DePaul University in Chicago. Wrote more UMLs for those classes than I’ve done in 10 years of actual software development.</div><br/></div></div><div id="38575288" class="c"><input type="checkbox" id="c-38575288" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38574860">parent</a><span>|</span><a href="#38574945">prev</a><span>|</span><a href="#38576061">next</a><span>|</span><label class="collapse" for="c-38575288">[-]</label><label class="expand" for="c-38575288">[1 more]</label></div><br/><div class="children"><div class="content">Wait. This year?<p>I haven’t touched UML for ten years.</div><br/></div></div></div></div><div id="38576061" class="c"><input type="checkbox" id="c-38576061" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38574860">prev</a><span>|</span><a href="#38578796">next</a><span>|</span><label class="collapse" for="c-38576061">[-]</label><label class="expand" for="c-38576061">[4 more]</label></div><br/><div class="children"><div class="content">What does research in this field look like?</div><br/><div id="38576925" class="c"><input type="checkbox" id="c-38576925" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576061">parent</a><span>|</span><a href="#38576567">next</a><span>|</span><label class="collapse" for="c-38576925">[-]</label><label class="expand" for="c-38576925">[1 more]</label></div><br/><div class="children"><div class="content">Testing, fuzzing, and verification are all pretty hot SE topics now, at least in my department at CMU. All of those have some element of program analysis, both static and dynamic, so there&#x27;s potentially deep PL stuff, which is core CS. There&#x27;s aspects to SE that are not just that, of course, which are studying social processes, management styles and practices, software architectures, design patterns, API design, etc.</div><br/></div></div><div id="38576567" class="c"><input type="checkbox" id="c-38576567" checked=""/><div class="controls bullet"><span class="by">stephendause</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576061">parent</a><span>|</span><a href="#38576925">prev</a><span>|</span><a href="#38577151">next</a><span>|</span><label class="collapse" for="c-38576567">[-]</label><label class="expand" for="c-38576567">[1 more]</label></div><br/><div class="children"><div class="content">So I have not done research any software engineering field and have not read all that much either. One example that comes to mind from one of my courses that I took in software engineering is research around mutation-based testing. That form of testing is where you generate random variants of your test by doing things like deleting a statement, adding a statement, changing a less than sign to a greater than sign, etc. Then you check to see that at least one of your tests fails for each variant. If it does not, you either add a test or mark that variant as being effectively the same program. I forget what the term is for it. At any rate, I think there is still research being done on this topic, for example how to effectively generate programs that do not generate as many functionally identical programs. Software testing in general is a big part of software engineering, and I think there is still a fair amount of research that could be done about it.<p>In my opinion, the intersection of cognitive psychology and software engineering is also ripe for a lot of research. I feel like we as software engineers have a lot of intuitions about how to be productive, but I would love to see various things that could indicate productivity measured in a controlled lab setting.</div><br/></div></div><div id="38577151" class="c"><input type="checkbox" id="c-38577151" checked=""/><div class="controls bullet"><span class="by">gmadsen</span><span>|</span><a href="#38574510">root</a><span>|</span><a href="#38576061">parent</a><span>|</span><a href="#38576567">prev</a><span>|</span><a href="#38578796">next</a><span>|</span><label class="collapse" for="c-38577151">[-]</label><label class="expand" for="c-38577151">[1 more]</label></div><br/><div class="children"><div class="content">I would assume something like this? <a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;79551" rel="nofollow noreferrer">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;79551</a></div><br/></div></div></div></div><div id="38578796" class="c"><input type="checkbox" id="c-38578796" checked=""/><div class="controls bullet"><span class="by">tdeck</span><span>|</span><a href="#38574510">parent</a><span>|</span><a href="#38576061">prev</a><span>|</span><a href="#38575638">next</a><span>|</span><label class="collapse" for="c-38578796">[-]</label><label class="expand" for="c-38578796">[1 more]</label></div><br/><div class="children"><div class="content">It seems to vary a lot from school to school. At my university (2010-2014) we were writing unit tests from the first CS class. I can&#x27;t say we got much instruction on how to structure more complex applications in order to make them testable, however. Things like dependency injection and non-trivial mocking have to be learned on the job, which is a real shame. Even within the industry skills and approaches to designing code for tests feel very heterogeneous.</div><br/></div></div></div></div><div id="38575638" class="c"><input type="checkbox" id="c-38575638" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#38574510">prev</a><span>|</span><a href="#38572596">next</a><span>|</span><label class="collapse" for="c-38575638">[-]</label><label class="expand" for="c-38575638">[10 more]</label></div><br/><div class="children"><div class="content">The reason I find it easier to work with people who have a degree in Computer Science is that I don&#x27;t have to convince them of the need for good algorithms and not to try to implement parsers or cryptography by hand.<p>When it comes to software engineering I feel there is no qualification where you can feel that the gross naivety about quality and working in teams (and with other teams) has been similarly ironed out.<p>Instead you get people hardened in sin from their repeated experience of writing one horrible bit of untested code quickly and then leaving before the shit truly hit the fan :-)<p>One&#x27;s management is very impressed with those kind of people and very contemptuous of those left behind who have to painstakingly clean up the mess.</div><br/><div id="38579853" class="c"><input type="checkbox" id="c-38579853" checked=""/><div class="controls bullet"><span class="by">CipherThrowaway</span><span>|</span><a href="#38575638">parent</a><span>|</span><a href="#38576089">next</a><span>|</span><label class="collapse" for="c-38579853">[-]</label><label class="expand" for="c-38579853">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The reason I find it easier to work with people who have a degree in Computer Science is that I don&#x27;t have to convince them of the need for good algorithms and not to try to implement parsers or cryptography by hand.<p>Cryptography and parsers simply do not belong in the same sentence. There is never a time when it is a appropriate to write your own cryptography. OTOH, most large compiler and interpreter projects have handwritten parsers, and many of them have handwritten lexers too.<p>Writing a parser can be simple enough to fit into a take-home assignment, and hand-written parser code ends up looking pretty similar to an LL grammar anyway. Parsing is also the easiest part of writing compiler or language tooling, so if a handwritten parser is too high a bar for the team then the entire project might questionable.<p>I&#x27;m not saying never use a parser generator, but I would personally prefer to work on a project with a well tested hand-written parser than a project using a parser generator. Especially if it complicates the build process with extra tooling, or is something really dated like Bison or ANTLR.</div><br/><div id="38579865" class="c"><input type="checkbox" id="c-38579865" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38575638">root</a><span>|</span><a href="#38579853">parent</a><span>|</span><a href="#38576089">next</a><span>|</span><label class="collapse" for="c-38579865">[-]</label><label class="expand" for="c-38579865">[1 more]</label></div><br/><div class="children"><div class="content">What’s dated about ANTLR?</div><br/></div></div></div></div><div id="38576089" class="c"><input type="checkbox" id="c-38576089" checked=""/><div class="controls bullet"><span class="by">ch4s3</span><span>|</span><a href="#38575638">parent</a><span>|</span><a href="#38579853">prev</a><span>|</span><a href="#38577718">next</a><span>|</span><label class="collapse" for="c-38576089">[-]</label><label class="expand" for="c-38576089">[3 more]</label></div><br/><div class="children"><div class="content">Hum, interesting perspective. I did 95% of a masters in CS before leaving to do a startup and while I can see the value of parser generators, there are a LOT of times when it is appropriate, useful, and more performant to write your own simple parser. It&#x27;s often in my opinion the right thing to to first for simple cases. Clearly you should test it and consider functional requirements, but a stringy protocol with clear delimiters is usually dead simple to parse and depending on your use case you can focus on a subset. If you&#x27;re writing a language... my advice might be different.</div><br/><div id="38578801" class="c"><input type="checkbox" id="c-38578801" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38575638">root</a><span>|</span><a href="#38576089">parent</a><span>|</span><a href="#38577671">next</a><span>|</span><label class="collapse" for="c-38578801">[-]</label><label class="expand" for="c-38578801">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never had it once in my career where using a parser generator wasn&#x27;t better. Given that it&#x27;s an in-language parser generator and not some meta-language monstrum like ANTLR.<p>Maybe when writing your own programming language, own complicated data format or low communication protocoll while requiring extreme performance. But that seems to be super rare, at least in my area of profession.</div><br/></div></div><div id="38577671" class="c"><input type="checkbox" id="c-38577671" checked=""/><div class="controls bullet"><span class="by">chiefalchemist</span><span>|</span><a href="#38575638">root</a><span>|</span><a href="#38576089">parent</a><span>|</span><a href="#38578801">prev</a><span>|</span><a href="#38577718">next</a><span>|</span><label class="collapse" for="c-38577671">[-]</label><label class="expand" for="c-38577671">[1 more]</label></div><br/><div class="children"><div class="content">My impression is the gist is: When you think like an engineer, your focus is on problem solving, and using the appropriate tool(s) to do that. On the other hand, typical developers instinct is to code, code, code; at least based on my experience.</div><br/></div></div></div></div><div id="38577718" class="c"><input type="checkbox" id="c-38577718" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#38575638">parent</a><span>|</span><a href="#38576089">prev</a><span>|</span><a href="#38576328">next</a><span>|</span><label class="collapse" for="c-38577718">[-]</label><label class="expand" for="c-38577718">[2 more]</label></div><br/><div class="children"><div class="content">Cryptography yes, but are you sure about parsers? As far as I can tell, there&#x27;s some kind of U-curve there. Beginners code them by hand, intermediate-level programmers and intermediate-scope projects use parser generators, and people maintaining the most sophisticated parsers prefer to code them by hand too. For example, GCC used to have a bison parser, but they switched to a hand-coded recursive descent one because that let them produce more helpful error messages. Clang uses recursive descent too.</div><br/><div id="38577996" class="c"><input type="checkbox" id="c-38577996" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38575638">root</a><span>|</span><a href="#38577718">parent</a><span>|</span><a href="#38576328">next</a><span>|</span><label class="collapse" for="c-38577996">[-]</label><label class="expand" for="c-38577996">[1 more]</label></div><br/><div class="children"><div class="content">I offer, again, my JetBrains GrammarKit counterpoint from the last time that assertion came up &lt;<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38192427">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38192427</a>&gt;<p>&gt;&gt;&gt;<p>I consider the JetBrains parsing system to be world class and they seem to hand-write very few (instead building on this system: <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit#readme">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit#readme</a> )<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;java&#x2F;java-frontback-psi-impl&#x2F;src&#x2F;com&#x2F;intellij&#x2F;lang&#x2F;java&#x2F;lexer&#x2F;_JavaLexer.flex">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;23...</a> (the parser I&#x27;ll concede, as they do seem to be hand-rolling that part)<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;python&#x2F;python-parser&#x2F;src&#x2F;com&#x2F;jetbrains&#x2F;python&#x2F;lexer&#x2F;Python.flex">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;23...</a> (same for its parser)<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;plugins&#x2F;sh&#x2F;core&#x2F;src&#x2F;com&#x2F;intellij&#x2F;sh&#x2F;lexer&#x2F;Sh.flex">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;23...</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;plugins&#x2F;sh&#x2F;core&#x2F;grammar&#x2F;sh.bnf">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-community&#x2F;blob&#x2F;idea&#x2F;23...</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-plugins&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;makefile&#x2F;grammars&#x2F;MakefileLexer.flex">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-plugins&#x2F;blob&#x2F;idea&#x2F;233....</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-plugins&#x2F;blob&#x2F;idea&#x2F;233.11555.11&#x2F;makefile&#x2F;grammars&#x2F;Makefile.bnf">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;intellij-plugins&#x2F;blob&#x2F;idea&#x2F;233....</a></div><br/></div></div></div></div><div id="38576328" class="c"><input type="checkbox" id="c-38576328" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#38575638">parent</a><span>|</span><a href="#38577718">prev</a><span>|</span><a href="#38577115">next</a><span>|</span><label class="collapse" for="c-38576328">[-]</label><label class="expand" for="c-38576328">[1 more]</label></div><br/><div class="children"><div class="content">Pushback on parsers. It&#x27;s very difficult to provide useful diagnostic error messages with yacc&#x2F;bison.  So most languages end up with a hand-written recursive descent parser.<p>The only exception I personally know of is jq (uses bison).  So it&#x27;s difficult to produce helpful syntax error messages in the implementation of jq.</div><br/></div></div><div id="38577115" class="c"><input type="checkbox" id="c-38577115" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38575638">parent</a><span>|</span><a href="#38576328">prev</a><span>|</span><a href="#38572596">next</a><span>|</span><label class="collapse" for="c-38577115">[-]</label><label class="expand" for="c-38577115">[1 more]</label></div><br/><div class="children"><div class="content">It is a culture thing. Try to avoid cowboy shops. The thing is the general standard seems higher than 20 years ago. Source control, unit testing and CI&#x2F;CD are not controversial any more for example.</div><br/></div></div></div></div><div id="38572596" class="c"><input type="checkbox" id="c-38572596" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#38575638">prev</a><span>|</span><a href="#38577399">next</a><span>|</span><label class="collapse" for="c-38572596">[-]</label><label class="expand" for="c-38572596">[113 more]</label></div><br/><div class="children"><div class="content">&gt; It will be necessary to deliver software without bugs in time.<p>Seems like a pretty bad premise to start an article on quality software. If you believe you can ship bug free code, it&#x27;s time to switch careers.</div><br/><div id="38574034" class="c"><input type="checkbox" id="c-38574034" checked=""/><div class="controls bullet"><span class="by">codegeek</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572778">next</a><span>|</span><label class="collapse" for="c-38574034">[-]</label><label class="expand" for="c-38574034">[28 more]</label></div><br/><div class="children"><div class="content">Yep. If you have written production grade software at real companies, you know that the moment you make that new commit (even if 1 liner change), you are now ready to accept that it could break something. yes you can do your unit tests, integration test, User Acceptance Tests and what not. But every code change = new possible bug that you may not be able to catch until it occurs to a customer.<p>Whenever I hear a developer say &quot;I never ship buggy code&quot;, I am always cautious to dig in more and understand what they mean by that.</div><br/><div id="38575415" class="c"><input type="checkbox" id="c-38575415" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574034">parent</a><span>|</span><a href="#38574403">next</a><span>|</span><label class="collapse" for="c-38575415">[-]</label><label class="expand" for="c-38575415">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always amazing when I get a bug report from a product that&#x27;s been running bug free in production for years with minimal changes but some user did some combination of things that had never been done and it blows up.<p>Usually it&#x27;s something extremely simple to fix too.</div><br/><div id="38576201" class="c"><input type="checkbox" id="c-38576201" checked=""/><div class="controls bullet"><span class="by">codegeek</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575415">parent</a><span>|</span><a href="#38574403">next</a><span>|</span><label class="collapse" for="c-38576201">[-]</label><label class="expand" for="c-38576201">[1 more]</label></div><br/><div class="children"><div class="content">This happens a lot more than one may think especially with products that have lot of features. Some features are used sparingly and the moment a customer uses that feature a bit more in depth, boom. Something is broken.</div><br/></div></div></div></div><div id="38574403" class="c"><input type="checkbox" id="c-38574403" checked=""/><div class="controls bullet"><span class="by">Gare</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574034">parent</a><span>|</span><a href="#38575415">prev</a><span>|</span><a href="#38572778">next</a><span>|</span><label class="collapse" for="c-38574403">[-]</label><label class="expand" for="c-38574403">[25 more]</label></div><br/><div class="children"><div class="content">How about a formal proof? :)<p>I jest, but that should be the gold standard for anything life-critical and good to have for mission-critical software. Alas, we&#x27;re not there yet.</div><br/><div id="38574728" class="c"><input type="checkbox" id="c-38574728" checked=""/><div class="controls bullet"><span class="by">cochne</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38579887">next</a><span>|</span><label class="collapse" for="c-38574728">[-]</label><label class="expand" for="c-38574728">[5 more]</label></div><br/><div class="children"><div class="content">I never really got how proofs are supposed to solve this issue.  I think that would just move the bugs from the code into the proof definition.  Your code may do what the proof says, but how do you know what the proof says is what you actually want to happen?</div><br/><div id="38575486" class="c"><input type="checkbox" id="c-38575486" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574728">parent</a><span>|</span><a href="#38575163">next</a><span>|</span><label class="collapse" for="c-38575486">[-]</label><label class="expand" for="c-38575486">[3 more]</label></div><br/><div class="children"><div class="content">A formal spec isn&#x27;t just ordinary source-code by another name, it&#x27;s at a quite different level of abstraction, and (hopefully) it will be proven that its invariants always hold. (This is a separate step from proving that the model corresponds to the ultimate deliverable of the formal development process, be that source-code or binary.)<p>Bugs in the formal spec aren&#x27;t impossible, but use of formal methods doesn&#x27;t prevent you from doing acceptance testing as well. In practice, there&#x27;s a whole methodology at work, not just blind trust in the formal spec.<p>Software developed using formal methods is generally assured to be free of runtime errors at the level of the target language (divide-by-zero, dereferencing NULL, out-of-bounds array access, etc). This is a pretty significant advantage, and applies even if there&#x27;s a bug in the spec.<p>Disclaimer: I&#x27;m very much not an expert.<p>Interesting reading:<p>* An interesting case-study, albeit from a non-impartial source [PDF] <a href="https:&#x2F;&#x2F;www.adacore.com&#x2F;uploads&#x2F;downloads&#x2F;Tokeneer_Report.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.adacore.com&#x2F;uploads&#x2F;downloads&#x2F;Tokeneer_Report.pd...</a><p>* An introduction to the <i>Event-B</i> formal modelling method [PDF] <a href="https:&#x2F;&#x2F;www.southampton.ac.uk&#x2F;~tsh2n14&#x2F;publications&#x2F;chapters&#x2F;eventb-dbook13.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.southampton.ac.uk&#x2F;~tsh2n14&#x2F;publications&#x2F;chapters...</a></div><br/><div id="38575699" class="c"><input type="checkbox" id="c-38575699" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575486">parent</a><span>|</span><a href="#38575163">next</a><span>|</span><label class="collapse" for="c-38575699">[-]</label><label class="expand" for="c-38575699">[2 more]</label></div><br/><div class="children"><div class="content">I think the reason that formal proofs haven&#x27;t really caught on is because it&#x27;s just adding more complexity and stuff to maintain. The list of things that need to be maintained just keeps growing: code, tests, deployment tooling, configs, environments, etc. And now add a formal proof onto that. If the user changes their requirements then the proof needs to change. A lot of code changes will probably necessitate a proof change as well. And it doesn&#x27;t even eliminate bugs because the formal proof could include a bug too. I suppose it could help in trivial cases like sanity checking that a value isn&#x27;t null or that a lock is only held by a single thread but it seems like a lot of those checks are already integrated in build tooling in one way or another.</div><br/><div id="38575979" class="c"><input type="checkbox" id="c-38575979" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575699">parent</a><span>|</span><a href="#38575163">next</a><span>|</span><label class="collapse" for="c-38575979">[-]</label><label class="expand" for="c-38575979">[1 more]</label></div><br/><div class="children"><div class="content">&gt; more complexity and stuff to maintain<p>Yes, with the current state of the art, adopting formal methods means adopting a radically different approach to software development. For &#x27;rapid application development&#x27; work, it isn&#x27;t going to be a good choice. It&#x27;s only a real consideration if you&#x27;re serious about developing ultra-low-defect software (to use a term from the AdaCore folks).<p>&gt; it doesn&#x27;t even eliminate bugs because the formal proof could include a bug too<p>This is rather dismissive. Formal methods have been successfully used in various life-critical software systems, such as medical equipment and avionics.<p>As I said above, formal methods can eliminate all &#x27;runtime errors&#x27; (like out-of-bounds array access), and there&#x27;s a lot of power in formally guaranteeing that the model&#x27;s invariants are never broken.<p>&gt; I suppose it could help in trivial cases like sanity checking that a value isn&#x27;t null or that a lock is only held by a single thread<p>No, this doesn&#x27;t accurately reflect how formal methods work. I suggest taking a look at the PDFs I linked above. For one thing, formal modelling is not done using a programming language.</div><br/></div></div></div></div></div></div><div id="38575163" class="c"><input type="checkbox" id="c-38575163" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574728">parent</a><span>|</span><a href="#38575486">prev</a><span>|</span><a href="#38579887">next</a><span>|</span><label class="collapse" for="c-38575163">[-]</label><label class="expand" for="c-38575163">[1 more]</label></div><br/><div class="children"><div class="content">Not really. Imagine the proof says: &quot;in this protocol, when there are more than 0 participants, exactly one participant holds the lock at any time&quot;<p>It might be wrong, but it&#x27;s pretty easy to inspect and has a much higher chance of being right than your code does.<p>You then use proof refinement to eventually link this very high level statement down to the code implementing it.<p>That&#x27;s the vision, at least, and it&#x27;s sometimes possible to achieve it. See, for example, Ironfleet: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;ironfleet-proving-practical-distributed-systems-correct&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;ironfle...</a></div><br/></div></div></div></div><div id="38579887" class="c"><input type="checkbox" id="c-38579887" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38574728">prev</a><span>|</span><a href="#38574898">next</a><span>|</span><label class="collapse" for="c-38579887">[-]</label><label class="expand" for="c-38579887">[1 more]</label></div><br/><div class="children"><div class="content">Well, if your product is on the hello world complexity, you might make it bug-free by just yourself simply through chance.<p>Formal proving doesn’t really scale much further, definitely not to “enterprise” product scale.</div><br/></div></div><div id="38574898" class="c"><input type="checkbox" id="c-38574898" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38579887">prev</a><span>|</span><a href="#38576130">next</a><span>|</span><label class="collapse" for="c-38574898">[-]</label><label class="expand" for="c-38574898">[1 more]</label></div><br/><div class="children"><div class="content">As always, the branding of formal methods sucks. As other commentators point out, it isn&#x27;t technically possible to provide a formal proof that software is correct. And that is fine, because formal software methods don&#x27;t do that.<p>But right from the outset the approach is doomed to fail because its proponents write like they don&#x27;t know what they are talking about and think they can write bug-free software.<p>It really should be &quot;write software with a formal spec&quot;. Once people start talking about &quot;proof&quot; in practice it sounds dishonest. It isn&#x27;t possible to prove software and the focus really needs to be on the spec.</div><br/></div></div><div id="38576130" class="c"><input type="checkbox" id="c-38576130" checked=""/><div class="controls bullet"><span class="by">radicalcentrist</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38574898">prev</a><span>|</span><a href="#38575126">next</a><span>|</span><label class="collapse" for="c-38576130">[-]</label><label class="expand" for="c-38576130">[1 more]</label></div><br/><div class="children"><div class="content">To quote Donald Knuth, &quot;Beware of bugs in the above code; I have only proved it correct, not tried it.&quot;</div><br/></div></div><div id="38575126" class="c"><input type="checkbox" id="c-38575126" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38576130">prev</a><span>|</span><a href="#38575014">next</a><span>|</span><label class="collapse" for="c-38575126">[-]</label><label class="expand" for="c-38575126">[1 more]</label></div><br/><div class="children"><div class="content">Even formally proved code can have bugs.  If your requirement is wrong is the obvious thing.  I don&#x27;t work with formal proofs (I want to, I just don&#x27;t know how), but I&#x27;m given to understand they have other real world limits that make them sometimes have other bugs.</div><br/></div></div><div id="38575014" class="c"><input type="checkbox" id="c-38575014" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38575126">prev</a><span>|</span><a href="#38574727">next</a><span>|</span><label class="collapse" for="c-38575014">[-]</label><label class="expand" for="c-38575014">[4 more]</label></div><br/><div class="children"><div class="content">Formal proof <i>of what</i>?  That it has no bugs?  Ha!<p>You can formally prove that it doesn&#x27;t have <i>certain kinds</i> of bugs.  And that&#x27;s good!  But it also is an enormous amount of work.  And so, even for life-critical software, the vast majority is not formally proven, because we want more software than we can afford to formally prove.</div><br/><div id="38575107" class="c"><input type="checkbox" id="c-38575107" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575014">parent</a><span>|</span><a href="#38575159">next</a><span>|</span><label class="collapse" for="c-38575107">[-]</label><label class="expand" for="c-38575107">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting point that I think a lot of programming can miss.<p>Proving that the program has no bugs is akin to proving that the program won&#x27;t make you feel sad.  Like ... I&#x27;m not sure we have the math.<p>One of the more important jobs of the software engineer is to look deep into your customer&#x27;s dreams and determine how those dreams will ultimately make your customer sad unless there&#x27;s some sort of intervention before you finish the implementation.</div><br/></div></div><div id="38575159" class="c"><input type="checkbox" id="c-38575159" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575014">parent</a><span>|</span><a href="#38575107">prev</a><span>|</span><a href="#38576363">next</a><span>|</span><label class="collapse" for="c-38575159">[-]</label><label class="expand" for="c-38575159">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, if you can have a formally proven compiler from slides, poorly written user stories and clarification phone calls to x86_64 binary then alright.</div><br/></div></div><div id="38576363" class="c"><input type="checkbox" id="c-38576363" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575014">parent</a><span>|</span><a href="#38575159">prev</a><span>|</span><a href="#38574727">next</a><span>|</span><label class="collapse" for="c-38576363">[-]</label><label class="expand" for="c-38576363">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, it&#x27;s fundamentally impossible. Formal proofs can help with parts of the process, but it can guarantee no bugs in the product. These are the steps of software, and their transitions. It&#x27;s fundamentally a game of telephone with errors at each step along the way.<p>What actually would solve the customer&#x27;s problem -&gt; What the customer thinks they want -&gt; What they communicate that they want -&gt; What the requirements collector hears -&gt; What the requirements collector documents -&gt; How the implementor interprets the requirements -&gt; What the implementor designs&#x2F;plans -&gt; What the implementor implements.<p>Formal proofs can help with the last 3 steps. But again that&#x27;s assuming the implementor can formalize every requirement they interpreted. And that&#x27;s impossible as well, there will always be implicit assumptions about the running environment, performance, scale, the behavior of dependent processes&#x2F;APIs.<p>It helps with a small set of possible problems. If those problems are mission-critical then absolutely tackle them, but there will never be a situation where it can help with the first 5 steps of the problem, or with the implicit items in the 6th step above.</div><br/></div></div></div></div><div id="38574727" class="c"><input type="checkbox" id="c-38574727" checked=""/><div class="controls bullet"><span class="by">akhosravian</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38575014">prev</a><span>|</span><a href="#38574720">next</a><span>|</span><label class="collapse" for="c-38574727">[-]</label><label class="expand" for="c-38574727">[10 more]</label></div><br/><div class="children"><div class="content">I’m not a CS academic or a mathematician, but don’t Godel’s incompleteness theorems preclude a formal proof of correctness?</div><br/><div id="38575055" class="c"><input type="checkbox" id="c-38575055" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574727">parent</a><span>|</span><a href="#38574941">next</a><span>|</span><label class="collapse" for="c-38575055">[-]</label><label class="expand" for="c-38575055">[5 more]</label></div><br/><div class="children"><div class="content">No.<p>Godel means that we can&#x27;t have an algorithmic box that we put a program into and out comes a true&#x2F;false statement of halting.<p>Nothing is stopping you from writing the proof manually for each program that you want to prove properties for.<p>ALSO, you can write sub-turing complete programs.  Those are allowed to have automated halting proofs (see idris et al).</div><br/><div id="38575425" class="c"><input type="checkbox" id="c-38575425" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575055">parent</a><span>|</span><a href="#38574941">next</a><span>|</span><label class="collapse" for="c-38575425">[-]</label><label class="expand" for="c-38575425">[4 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re talking about is actually the Church-Turing thesis and the halting problem.<p>While, yes, computability and provability are very closely related, it&#x27;s important to get attribution correct.<p>More details on what Gödel&#x27;s Incompleteness Theorem really said are in a sibling comment so I won&#x27;t repeat them here.</div><br/><div id="38575973" class="c"><input type="checkbox" id="c-38575973" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575425">parent</a><span>|</span><a href="#38574941">next</a><span>|</span><label class="collapse" for="c-38575973">[-]</label><label class="expand" for="c-38575973">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s important to get attribution correct.<p>Really?  Says who?<p>Or perhaps you&#x27;ll prove it from first principles.  Although if turns out to be difficult, that&#x27;s okay.  Somebody mentioned something about systems being either complete or consistent but never both.  Some things can be true but not proveably so.  Can&#x27;t quite remember who it was though.</div><br/><div id="38576187" class="c"><input type="checkbox" id="c-38576187" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575973">parent</a><span>|</span><a href="#38574941">next</a><span>|</span><label class="collapse" for="c-38576187">[-]</label><label class="expand" for="c-38576187">[2 more]</label></div><br/><div class="children"><div class="content">Fair enough, I was being annoyingly pedantic.<p>[I believe that] it&#x27;s important to get attribution correct.</div><br/><div id="38576451" class="c"><input type="checkbox" id="c-38576451" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38576187">parent</a><span>|</span><a href="#38574941">next</a><span>|</span><label class="collapse" for="c-38576451">[-]</label><label class="expand" for="c-38576451">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, annoyingly pedantic is the best kind of pedantic.<p>- Futurama (kind of)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38574941" class="c"><input type="checkbox" id="c-38574941" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574727">parent</a><span>|</span><a href="#38575055">prev</a><span>|</span><a href="#38574937">next</a><span>|</span><label class="collapse" for="c-38574941">[-]</label><label class="expand" for="c-38574941">[1 more]</label></div><br/><div class="children"><div class="content">No. It merely prevents you from confirming every arbitrarily complex proof. Incompleteness is more like: I give you a convoluted mess of spaghetti code and claim it computes prime numbers and I demand you try to prove me wrong.</div><br/></div></div><div id="38574937" class="c"><input type="checkbox" id="c-38574937" checked=""/><div class="controls bullet"><span class="by">topaz0</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574727">parent</a><span>|</span><a href="#38574941">prev</a><span>|</span><a href="#38574720">next</a><span>|</span><label class="collapse" for="c-38574937">[-]</label><label class="expand" for="c-38574937">[3 more]</label></div><br/><div class="children"><div class="content">No. There are plenty of things that can be proved, it&#x27;s just that there exist true statements that cannot be proved.</div><br/><div id="38575166" class="c"><input type="checkbox" id="c-38575166" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574937">parent</a><span>|</span><a href="#38574720">next</a><span>|</span><label class="collapse" for="c-38575166">[-]</label><label class="expand" for="c-38575166">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s closer, but still not quite right.<p>There are well-formed statements that can be proved but which assert that its godelized value represents a non-provable theorem.<p>Therefore, you must accept that it and its contradiction are both provable (leading to an inconsistent system), or not accept it and now there are provable theorems that cannot be expressed in the system.<p>Furthermore, that this can be constructed from anything with base arithmetic and induction over first-order logic (Gödel&#x27;s original paper included how broadly it could be applied to basically every logical system).</div><br/><div id="38575364" class="c"><input type="checkbox" id="c-38575364" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575166">parent</a><span>|</span><a href="#38574720">next</a><span>|</span><label class="collapse" for="c-38575364">[-]</label><label class="expand" for="c-38575364">[1 more]</label></div><br/><div class="children"><div class="content">The important thing to note is that it doesn&#x27;t have anything to do with truth or truth-values of propositions.  It breaks the fundamental operation of the provability of a statement.<p>And, since many proofs are done by assuming a statement&#x27;s inverse and trying to prove a contradiction, having a known contradiction in the set of provable statements can effectively allow any statement to be proven.  Keeping the contradiction is not actually an option.</div><br/></div></div></div></div></div></div></div></div><div id="38574720" class="c"><input type="checkbox" id="c-38574720" checked=""/><div class="controls bullet"><span class="by">underlipton</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574403">parent</a><span>|</span><a href="#38574727">prev</a><span>|</span><a href="#38572778">next</a><span>|</span><label class="collapse" for="c-38574720">[-]</label><label class="expand" for="c-38574720">[1 more]</label></div><br/><div class="children"><div class="content">Oh, boy, I get to post this again:<p><a href="https:&#x2F;&#x2F;www.fastcompany.com&#x2F;28121&#x2F;they-write-right-stuff" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.fastcompany.com&#x2F;28121&#x2F;they-write-right-stuff</a></div><br/></div></div></div></div></div></div><div id="38572778" class="c"><input type="checkbox" id="c-38572778" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38574034">prev</a><span>|</span><a href="#38572681">next</a><span>|</span><label class="collapse" for="c-38572778">[-]</label><label class="expand" for="c-38572778">[1 more]</label></div><br/><div class="children"><div class="content">This kind of wisdom only comes from experience I think. Either that or higher order think. Like the article says, most of the time testing&#x2F;tdd&#x2F;qa is bolt on after-the-fact. Or a big push at the end with &quot;QA Sprints&quot; (are you sprinting or are you examining? what exactly <i>is</i> a QA sprint? <i>I know what it is</i>).<p>Once you get beyond &quot;I wrote a function&quot; and &quot;I tested a function&quot; and even still &quot;I tested a function that was called by a function over the wire&quot;, you will come to a realization that no matter how edgy your edge cases, no matter how thorough your QA, there will always - <i>ALWAYS</i> be 0-day &quot;undefined behavior&quot; in certain configurations. On certain hardware. On certain kernels. <i>It&#x27;s an assurance that I guarantee that I&#x27;m almost positive it&#x27;s bug free, since it passed tests, it passed human eyes, and it passed review - fingers crossed.</i></div><br/></div></div><div id="38572681" class="c"><input type="checkbox" id="c-38572681" checked=""/><div class="controls bullet"><span class="by">FalconSensei</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572778">prev</a><span>|</span><a href="#38574042">next</a><span>|</span><label class="collapse" for="c-38572681">[-]</label><label class="expand" for="c-38572681">[15 more]</label></div><br/><div class="children"><div class="content">&gt; If you believe you can ship bug free code, it&#x27;s time to switch careers.<p>Unfortunately, you are correct. Shipping in time and bug free are inversely proportional, and in a world were usually it&#x27;s hard to argue with PMs for more time to have better testing, or paying tech debt... it&#x27;s just a reality</div><br/><div id="38572765" class="c"><input type="checkbox" id="c-38572765" checked=""/><div class="controls bullet"><span class="by">colinmorelli</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572681">parent</a><span>|</span><a href="#38572819">next</a><span>|</span><label class="collapse" for="c-38572765">[-]</label><label class="expand" for="c-38572765">[9 more]</label></div><br/><div class="children"><div class="content">An infinite amount of time would not necessarily yield zero bugs.<p>But more importantly, once you&#x27;ve fixed the &quot;show-stopping bugs,&quot; putting the software in front of customers is probably the best next step, as even if it&#x27;s bug-free, that doesn&#x27;t mean it solves the problem well.</div><br/><div id="38577139" class="c"><input type="checkbox" id="c-38577139" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572765">parent</a><span>|</span><a href="#38572795">next</a><span>|</span><label class="collapse" for="c-38577139">[-]</label><label class="expand" for="c-38577139">[1 more]</label></div><br/><div class="children"><div class="content">We need to define bug but if bug is anything a customer (internal or external) is not happy with that passes triage and you can’t throw it back in their face. Then zero bugs would be impossible with even infinite time.</div><br/></div></div><div id="38572795" class="c"><input type="checkbox" id="c-38572795" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572765">parent</a><span>|</span><a href="#38577139">prev</a><span>|</span><a href="#38576699">next</a><span>|</span><label class="collapse" for="c-38572795">[-]</label><label class="expand" for="c-38572795">[6 more]</label></div><br/><div class="children"><div class="content">there is no such thing as zero bugs. There is only a marker in time for a suite of tests that show no bugs. Doesn&#x27;t mean larva aren&#x27;t living under the wood. You can&#x27;t control <i>all</i> the bits (unless you built your own hardware&#x2F;software stack).</div><br/><div id="38572820" class="c"><input type="checkbox" id="c-38572820" checked=""/><div class="controls bullet"><span class="by">colinmorelli</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572795">parent</a><span>|</span><a href="#38574493">next</a><span>|</span><label class="collapse" for="c-38572820">[-]</label><label class="expand" for="c-38572820">[4 more]</label></div><br/><div class="children"><div class="content">I think we&#x27;re saying the same thing? That was my point. You&#x27;re never going to achieve zero bugs no matter how much time you give yourself. Focus on getting the critical path right and creating a good experience, and then get it to customers for feedback on where to go next.<p>[The above does not necessarily apply in highly regulated industries or where lives are on the line]</div><br/><div id="38573216" class="c"><input type="checkbox" id="c-38573216" checked=""/><div class="controls bullet"><span class="by">BobaFloutist</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572820">parent</a><span>|</span><a href="#38573163">next</a><span>|</span><label class="collapse" for="c-38573216">[-]</label><label class="expand" for="c-38573216">[1 more]</label></div><br/><div class="children"><div class="content">I like to think of &quot;zero bugs&quot; as the asymptote. As you spend more time, you discover increasingly fewer (and less significant) bugs per unit of time. POSSIBLY at the limit of infinite time you hit 0 bugs, but even if you could, would it be worth it? Doubtful.<p>I can think of far better ways to spend infinite time.</div><br/></div></div><div id="38573163" class="c"><input type="checkbox" id="c-38573163" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572820">parent</a><span>|</span><a href="#38573216">prev</a><span>|</span><a href="#38573465">next</a><span>|</span><label class="collapse" for="c-38573163">[-]</label><label class="expand" for="c-38573163">[1 more]</label></div><br/><div class="children"><div class="content">I would say that also applies on highly regulated industries or where lives are on the line.<p>On those you&#x27;re of course expected to do safety and testing up to the limit of the &quot;value of a statistical life&quot;s within the expected project impacts, but it still has time and budget limits.</div><br/></div></div><div id="38573465" class="c"><input type="checkbox" id="c-38573465" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572820">parent</a><span>|</span><a href="#38573163">prev</a><span>|</span><a href="#38574493">next</a><span>|</span><label class="collapse" for="c-38573465">[-]</label><label class="expand" for="c-38573465">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I also like how you call out &quot;get it in-front of customers&quot; as a step in the whole chain. Often sorely missed. Sometimes a bug to you, is a feature to them (gasp!)... so either make it a first class thing or train them on the correct path (while you fix the &quot;bug&quot;).</div><br/></div></div></div></div><div id="38574493" class="c"><input type="checkbox" id="c-38574493" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572795">parent</a><span>|</span><a href="#38572820">prev</a><span>|</span><a href="#38576699">next</a><span>|</span><label class="collapse" for="c-38574493">[-]</label><label class="expand" for="c-38574493">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there is no such thing as zero bugs.<p>Ok, I think we’ve gone too far. There absolutely is such thing as 0 bugs and sometimes code changes don’t have bugs. That is not to say it can be garunteed.</div><br/></div></div></div></div><div id="38576699" class="c"><input type="checkbox" id="c-38576699" checked=""/><div class="controls bullet"><span class="by">FalconSensei</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572765">parent</a><span>|</span><a href="#38572795">prev</a><span>|</span><a href="#38572819">next</a><span>|</span><label class="collapse" for="c-38576699">[-]</label><label class="expand" for="c-38576699">[1 more]</label></div><br/><div class="children"><div class="content">&gt; An infinite amount of time would not necessarily yield zero bugs.<p>Never said that, just that quick turnaround for deliveries will usually mean more bugs, and having some extra time usually means less bugs</div><br/></div></div></div></div><div id="38572819" class="c"><input type="checkbox" id="c-38572819" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572681">parent</a><span>|</span><a href="#38572765">prev</a><span>|</span><a href="#38576409">next</a><span>|</span><label class="collapse" for="c-38572819">[-]</label><label class="expand" for="c-38572819">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only true up to a point. There are some quality assurance and control activities that are essentially &quot;free&quot; in that they actually allow for shipping faster by preventing rework. But that requires a high level of team maturity and process discipline, so some teams are simply incapable of doing it. And even in ideal circumstances it&#x27;s impossible to ship defect free software (plus the endless discussions over whether particular issues are bugs or enhancement requests).</div><br/><div id="38574845" class="c"><input type="checkbox" id="c-38574845" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572819">parent</a><span>|</span><a href="#38576718">next</a><span>|</span><label class="collapse" for="c-38574845">[-]</label><label class="expand" for="c-38574845">[1 more]</label></div><br/><div class="children"><div class="content">yeah, it&#x27;s a spectrum. Clearly no one is expecting an app to be truly bug free if the underlying compiler itself has bugs. But how often do users truly run into compiler level bugs?<p>I think when the author says &quot;bug free&quot;, it&#x27;s from the user perspective. where bugs either need to go out of your way to trigger or are so esoteric it&#x27;s impossible to think about hitting without that user themself knowing the code inside out. Games is definitely an industry where the quality of code has always dipped to a point where users can easily hit issues in normal use, and only gets worse as games get more complex. That&#x27;s where it gets truly intolerable</div><br/></div></div><div id="38576718" class="c"><input type="checkbox" id="c-38576718" checked=""/><div class="controls bullet"><span class="by">FalconSensei</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572819">parent</a><span>|</span><a href="#38574845">prev</a><span>|</span><a href="#38576409">next</a><span>|</span><label class="collapse" for="c-38576718">[-]</label><label class="expand" for="c-38576718">[1 more]</label></div><br/><div class="children"><div class="content">There are tools that help, but you still need time to integrate those tools, learn how to use them, etc. If you are doing unit and integration tests, you need time to not only write those, but also actually plan your tests, and learn how to write tests. Which... needs time</div><br/></div></div></div></div><div id="38576409" class="c"><input type="checkbox" id="c-38576409" checked=""/><div class="controls bullet"><span class="by">d0gsg0w00f</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572681">parent</a><span>|</span><a href="#38572819">prev</a><span>|</span><a href="#38574042">next</a><span>|</span><label class="collapse" for="c-38576409">[-]</label><label class="expand" for="c-38576409">[2 more]</label></div><br/><div class="children"><div class="content">Like the age old builder trope.<p>&quot;Cheap. Fast. Good. Pick two.&quot;</div><br/><div id="38576795" class="c"><input type="checkbox" id="c-38576795" checked=""/><div class="controls bullet"><span class="by">NegativeK</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38576409">parent</a><span>|</span><a href="#38574042">next</a><span>|</span><label class="collapse" for="c-38576795">[-]</label><label class="expand" for="c-38576795">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the optimistic viewpoint.<p>The pessimistic viewpoint is that you get to pick up to one.</div><br/></div></div></div></div></div></div><div id="38574042" class="c"><input type="checkbox" id="c-38574042" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572681">prev</a><span>|</span><a href="#38572950">next</a><span>|</span><label class="collapse" for="c-38574042">[-]</label><label class="expand" for="c-38574042">[28 more]</label></div><br/><div class="children"><div class="content">Spicy take on engineering. Why do we accept this for software when do not accept the same in other engineering domains?</div><br/><div id="38579958" class="c"><input type="checkbox" id="c-38579958" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574194">next</a><span>|</span><label class="collapse" for="c-38579958">[-]</label><label class="expand" for="c-38579958">[1 more]</label></div><br/><div class="children"><div class="content">Because complexity is boundless and in software it has no cost.<p>Building a house will have a restrictive initial budget for complexity, you don’t have enough in that budget for rotating floors, or an elevator that is catapulted to the correct floor, etc. These would cost both at engineering time and implementation time a huge amount. Less complexity is easier to analyze.<p>In case of software, complexity has negligible cost, relative to physical systems. You can increase it ad infinity — but proving it (the whole stack - from the hardware-OS-userspace software) correct is likely impossible with even the whole of mathematics, in certain cases.</div><br/></div></div><div id="38574194" class="c"><input type="checkbox" id="c-38574194" checked=""/><div class="controls bullet"><span class="by">benwilson-512</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38579958">prev</a><span>|</span><a href="#38574328">next</a><span>|</span><label class="collapse" for="c-38574194">[-]</label><label class="expand" for="c-38574194">[2 more]</label></div><br/><div class="children"><div class="content">My wife works as an acoustical consultant at a global construction firm. The things you hear about factories, offices, and even hospitals is wild. Don’t get me wrong the construction world works very hard to avoid issues but I think we in software tend to hold other engineering disciplines up on a pedestal that doesn’t quite match the messiness of reality.</div><br/><div id="38574646" class="c"><input type="checkbox" id="c-38574646" checked=""/><div class="controls bullet"><span class="by">jimt1234</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574194">parent</a><span>|</span><a href="#38574328">next</a><span>|</span><label class="collapse" for="c-38574646">[-]</label><label class="expand" for="c-38574646">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for saying this. I think we in software engineering tend to think too binary: either the product is perfect (100% bug-free) or it&#x27;s shit. There&#x27;s always room for improvement, but compared to other engineering, overall, I think we&#x27;re doing pretty good. As an example similar to your wife&#x27;s, my friend used to work for one of the major car manufacturers doing almost the exact same job as Edward Norton&#x27;s character in Fight Club. The cars had &quot;bugs&quot;, they knew about it, but they didn&#x27;t publicly acknowledge it until they were forced to.</div><br/></div></div></div></div><div id="38574328" class="c"><input type="checkbox" id="c-38574328" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574194">prev</a><span>|</span><a href="#38574152">next</a><span>|</span><label class="collapse" for="c-38574328">[-]</label><label class="expand" for="c-38574328">[9 more]</label></div><br/><div class="children"><div class="content">There are a few aspects.  One is that we don&#x27;t understand the fundamentals of software as well as the underpinnings of other engineering disciplines.<p>More importantly though, for the most part we choose not to do engineering.  By which I mean this - we know how to do this better, and we apply those techniques in areas where the consequences of failure are high.  Aerospace, medical devices, etc.<p>It differs a bit industry to industry, but overall the lessons are the same.  On the whole it a) looks  a lot more like &quot;typical&quot; engineering than most software development and b) it is more expensive and slower.<p>Overall, we seem to have collectively decided we are fine with flakier software that delivers new and more complex things faster, except where errors tend to kill people or expensive machines without intending to.<p>The other contributing thing is it&#x27;s typically vastly cheaper to fix software errors after the fact than, say, bridges.</div><br/><div id="38574459" class="c"><input type="checkbox" id="c-38574459" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574328">parent</a><span>|</span><a href="#38575645">next</a><span>|</span><label class="collapse" for="c-38574459">[-]</label><label class="expand" for="c-38574459">[3 more]</label></div><br/><div class="children"><div class="content">The modern car contains within it a perfect example the dichotomy:<p>1. The ECU (&quot;hard&quot; engineering)<p>2. The infotainment system (&quot;soft&quot; engineering)<p>Now, an interesting thing I have noticed is that &quot;soft&quot; software engineering pays more.  Often substantially more.</div><br/><div id="38574504" class="c"><input type="checkbox" id="c-38574504" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574459">parent</a><span>|</span><a href="#38575645">next</a><span>|</span><label class="collapse" for="c-38574504">[-]</label><label class="expand" for="c-38574504">[2 more]</label></div><br/><div class="children"><div class="content">I think your salary observation is more of a firmware vs. hardware, rather then &quot;soft&quot; vs &quot;hard&quot; engineering.<p>Further to that, it&#x27;s often informative to figure out what makes a company money.  The highest paid software development roles tend to be doing things that are closer to revenue, on average.  If you are a software developer at a hardware company (or an insurance company, or whatever), you aren&#x27;t that close.  Even worse if you  are viewed as a cost center.</div><br/><div id="38575037" class="c"><input type="checkbox" id="c-38575037" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574504">parent</a><span>|</span><a href="#38575645">next</a><span>|</span><label class="collapse" for="c-38575037">[-]</label><label class="expand" for="c-38575037">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Further to that, it&#x27;s often informative to figure out what makes a company money. The highest paid software development roles tend to be doing things that are closer to revenue, on average.<p>yeah. Who are those trillion dollar businesses and what do they rely on?<p>- Apple: Probably the better example here since they focus a lot on user-facing value. But I&#x27;m sure they have their own deals, B2B market in certain industries, R&amp;D, and ads to take into account<p>- Microsoft: a dominant software house in nearly every aspect of the industry. But I wager most of their money comes not from users but other businesses. Virtually every other companies uses Windows, Word, and those that don&#x27;t may still use Azure for servers.<p>- Alphabet: ads. Need I say more? Users aren&#x27;t the audience, they are the selling point to other companies.<p>- Amazon: a big user facing market, but again similar to Microsoft. The real money is b2b servers.<p>- Nvidia: Again, user facing products but the real selling point is to companies that need their hardware. In this case, a good 80% of general computing manufacturers.<p>- Meta: Ads ans selling user data once again<p>- Tesla: CEO politics aside, it&#x27;s probably the 2nd best example. Split bewteen a user facing product that disrupted an industry and becoming a standard for fuel in the industry they disrupted. There&#x27;s also some tangential products that shouldn&#x27;t be underestimated, but overall a lot of value seems to come from serving the user.<p>General lesson here is that b2b and ads are the real money makers. if you&#x27;re one level removed that financial value drops immensely (but not necessarily to infeasible levels, far from it).</div><br/></div></div></div></div></div></div><div id="38575645" class="c"><input type="checkbox" id="c-38575645" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574328">parent</a><span>|</span><a href="#38574459">prev</a><span>|</span><a href="#38574152">next</a><span>|</span><label class="collapse" for="c-38575645">[-]</label><label class="expand" for="c-38575645">[5 more]</label></div><br/><div class="children"><div class="content">&gt; One is that we don&#x27;t understand the fundamentals of software as well as the underpinnings of other engineering disciplines.<p>That sounds like an awfully bold claim. I have the feeling we understand software a lot better than we understand mechanical engineering (and by extension material sciences) or fluid dynamics. By a big margin.<p>I worked with finite element software and with CFD solvers, you wouldn&#x27;t believe how hard it is to simulate a proper airflow over a simple airfoil and get the same results as in the wind tunnel.</div><br/><div id="38575888" class="c"><input type="checkbox" id="c-38575888" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575645">parent</a><span>|</span><a href="#38574152">next</a><span>|</span><label class="collapse" for="c-38575888">[-]</label><label class="expand" for="c-38575888">[4 more]</label></div><br/><div class="children"><div class="content">&gt; That sounds like an awfully bold claim.<p>To the contrary, it&#x27;s nearly canonical.  Most of the problems pointed out in the 70s (mythical man month) have still not been resolved, 50 years later.<p>&gt;you wouldn&#x27;t believe how hard it<p>Oh, I&#x27;d believe it (I&#x27;ve designed and built similar things, and had colleagues in CFD).<p>But you are definitely cherry picking here.  The problem with CFD is we don&#x27;t understand the fluid dynamics part very well;  turbulence is a big unsolved problem still, though we have been generating better techniques.  This is so true that in an undergraduate physics degree, there is usually a point where they say something like: &quot;now that you think you know how lots of things work, let&#x27;s introduce turbulence&quot;<p>But a lot of mechanical engineering and the underlying physics and materials science is actually pretty well understood, to the degree that we can be much more predictive about the trade offs than typically is possible in software.  Same goes for electrical, civil, and chem.  Each of them have areas of fuzziness, but also a pretty solid core.</div><br/><div id="38579989" class="c"><input type="checkbox" id="c-38579989" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575888">parent</a><span>|</span><a href="#38576672">next</a><span>|</span><label class="collapse" for="c-38579989">[-]</label><label class="expand" for="c-38579989">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To the contrary, it&#x27;s nearly canonical. Most of the problems pointed out in the 70s (mythical man month) have still not been resolved, 50 years later.<p>Even with all of those applied, we wouldn’t be magically better. Complexity is simply unbounded. It’s almost impossible to reason about parallel code with shared mutable state.</div><br/></div></div><div id="38576672" class="c"><input type="checkbox" id="c-38576672" checked=""/><div class="controls bullet"><span class="by">imetatroll</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575888">parent</a><span>|</span><a href="#38579989">prev</a><span>|</span><a href="#38574152">next</a><span>|</span><label class="collapse" for="c-38576672">[-]</label><label class="expand" for="c-38576672">[2 more]</label></div><br/><div class="children"><div class="content">The article is about delivering a complete, working project &quot;on time&quot;.  I have a neighbor whose home is being renovated and it is already 2x the time the contractor originally quoted.<p>Of course it is easier for a developer to walk away from something incomplete than an architect and the contractors involved in a physical project, but still, I hardly think that there is really much difference in terms of timelines.</div><br/><div id="38576794" class="c"><input type="checkbox" id="c-38576794" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38576672">parent</a><span>|</span><a href="#38574152">next</a><span>|</span><label class="collapse" for="c-38576794">[-]</label><label class="expand" for="c-38576794">[1 more]</label></div><br/><div class="children"><div class="content">FWIW in my experience delays in e.g. home renos (or for that matter larger scale projects) are mostly for reasons unrelated to the engineering.   In software projects, it&#x27;s probably the #1 reason (i.e. we didn&#x27;t know how to do it when we started).<p>Software is still absolutely king for number of large scale projects that just never ship, or ship but never work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38574152" class="c"><input type="checkbox" id="c-38574152" checked=""/><div class="controls bullet"><span class="by">Gud</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574328">prev</a><span>|</span><a href="#38575412">next</a><span>|</span><label class="collapse" for="c-38574152">[-]</label><label class="expand" for="c-38574152">[6 more]</label></div><br/><div class="children"><div class="content">Trust me when I say this: 
even &quot;other&quot; engineering domains have to do patches.<p>The difference is that software can be used before it is fully ready, and it makes sense to do so. No one can really use a 90% finished power plant, but software at 95% capacity is still usually &quot;good enough&quot;</div><br/><div id="38574496" class="c"><input type="checkbox" id="c-38574496" checked=""/><div class="controls bullet"><span class="by">daotoad</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574152">parent</a><span>|</span><a href="#38579071">next</a><span>|</span><label class="collapse" for="c-38574496">[-]</label><label class="expand" for="c-38574496">[2 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re 90% there.  There is also the cost to apply a patch.<p>If you want to patch a bridge, it&#x27;s gonna cost you.  Even if you only need to close down a single lane of traffic for a few hours you are looking at massive expenses for traffic control, coordination with transportation agencies, etc.<p>For most software it&#x27;s pretty inexpensive to ship updates.  If you&#x27;re a SaaS company regular updates are just part of your business model.  So the software is never actually done.  We just keep patching and patching.<p>In some contexts, it is much more expensive to push out updates.  For example, in the 00s, I worked on a project that had weather sensors installed in remote locations in various countries and the only way to get new software to them was via dial-up.  And we were luck that that was even an option.  Making international long distance calls to upload software patches over a 9600 baud connection is expensive.  So we tested our code religiously before even considering an update, and we only pushed out the most direly needed patches.<p>Working on SaaS these days and the approach is &quot;roll forward through bugs&quot;.  It just makes more economic sense with the cost structures in this business.</div><br/><div id="38574635" class="c"><input type="checkbox" id="c-38574635" checked=""/><div class="controls bullet"><span class="by">Gud</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574496">parent</a><span>|</span><a href="#38579071">next</a><span>|</span><label class="collapse" for="c-38574635">[-]</label><label class="expand" for="c-38574635">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. We calculate a $1 dollar fix in the factory costs $100 to fix on site.</div><br/></div></div></div></div><div id="38579071" class="c"><input type="checkbox" id="c-38579071" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574152">parent</a><span>|</span><a href="#38574496">prev</a><span>|</span><a href="#38574464">next</a><span>|</span><label class="collapse" for="c-38579071">[-]</label><label class="expand" for="c-38579071">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this insight! It has pretty strong explanatory power. It also explains why rushed development can stall. It explains &#x27;move fast and break things&#x27;.<p>There&#x27;s even an added factor of learning more about what is really needed by putting a 95% done product into use.<p>Heck, it explains (stretching it here) space-x&#x27;s success with an iterative approach to rocket design.</div><br/></div></div><div id="38574464" class="c"><input type="checkbox" id="c-38574464" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574152">parent</a><span>|</span><a href="#38579071">prev</a><span>|</span><a href="#38575412">next</a><span>|</span><label class="collapse" for="c-38574464">[-]</label><label class="expand" for="c-38574464">[2 more]</label></div><br/><div class="children"><div class="content">e.g. product recalls?</div><br/><div id="38574578" class="c"><input type="checkbox" id="c-38574578" checked=""/><div class="controls bullet"><span class="by">Gud</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574464">parent</a><span>|</span><a href="#38575412">next</a><span>|</span><label class="collapse" for="c-38574578">[-]</label><label class="expand" for="c-38574578">[1 more]</label></div><br/><div class="children"><div class="content">I install high voltage switchgear on site. 
A common problem is all the changes that has been added during the design stage, circuits that have been removed or altered, work that has kind of mostly been done to the schemes by the overworked secondary engineer. Sometimes, the schemes have been changed after all the wiring is completed and shipped to site, making it my pain in the ass when it&#x27;s time to do the commissioning.<p>The end result is never 100% perfect, but somewhere in between &quot;not too bad&quot; and &quot;good enough&quot;.</div><br/></div></div></div></div></div></div><div id="38575412" class="c"><input type="checkbox" id="c-38575412" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574152">prev</a><span>|</span><a href="#38574137">next</a><span>|</span><label class="collapse" for="c-38575412">[-]</label><label class="expand" for="c-38575412">[1 more]</label></div><br/><div class="children"><div class="content">Imagine same approache in other domains:<p>Team are flying the airplane, the se time rebuild it to the zeppelin, testing new engines inflight.<p>Or construction. Let&#x27;s build apartment block, but for few apartments we will test new materials, new layout, etc. Once there are walls of the first apartments we will let people live there. We will build how we can, according to the napkin plan. In the end we will put all tenants in and stress test strength of the structures. Or one day people return home and their apartments have totally different design and layout because someone from the HOA decided so to get a promotion.</div><br/></div></div><div id="38574137" class="c"><input type="checkbox" id="c-38574137" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38575412">prev</a><span>|</span><a href="#38577810">next</a><span>|</span><label class="collapse" for="c-38574137">[-]</label><label class="expand" for="c-38574137">[1 more]</label></div><br/><div class="children"><div class="content">Most engineering domains expect failure; the fail safes, checklists etc prevent it causing real damage.</div><br/></div></div><div id="38574310" class="c"><input type="checkbox" id="c-38574310" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38577810">prev</a><span>|</span><a href="#38575048">next</a><span>|</span><label class="collapse" for="c-38574310">[-]</label><label class="expand" for="c-38574310">[1 more]</label></div><br/><div class="children"><div class="content">&gt;when do not accept the same in other engineering domains?<p>No, you just complain that your taxes are being used to build expensive roads and bridges. Or you think airplanes are far too expensive. Or that new cars are insanely expensive.<p>There are cost trade offs. In general, better quality more expense.<p>Also in software there is not an excessive amount of software engineers in relation to demand for software. So SWEs can get paid a lot to go build crappy software.</div><br/></div></div><div id="38575048" class="c"><input type="checkbox" id="c-38575048" checked=""/><div class="controls bullet"><span class="by">digging</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574310">prev</a><span>|</span><a href="#38574951">next</a><span>|</span><label class="collapse" for="c-38575048">[-]</label><label class="expand" for="c-38575048">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the other answers, there is the perennial and depressing one: Software bugs haven&#x27;t killed enough people in a suitably visible&#x2F;dramatic way to be regulated that heavily.</div><br/></div></div><div id="38574951" class="c"><input type="checkbox" id="c-38574951" checked=""/><div class="controls bullet"><span class="by">rockemsockem</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38575048">prev</a><span>|</span><a href="#38574576">next</a><span>|</span><label class="collapse" for="c-38574951">[-]</label><label class="expand" for="c-38574951">[1 more]</label></div><br/><div class="children"><div class="content">We accept this in all fields of engineering. Everything is &quot;good enough&quot; and the seems to work reasonably well. You should remember this next time you hear about car recalls, maintenance work on bridges, or when some component in your laptop flakes out.</div><br/></div></div><div id="38574576" class="c"><input type="checkbox" id="c-38574576" checked=""/><div class="controls bullet"><span class="by">BeefyMcGhee</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574951">prev</a><span>|</span><a href="#38579035">next</a><span>|</span><label class="collapse" for="c-38574576">[-]</label><label class="expand" for="c-38574576">[1 more]</label></div><br/><div class="children"><div class="content">Because other engineering domains are &quot;actual&quot; engineering domains. They didn&#x27;t just co-opt the word to have fancier sounding job titles.</div><br/></div></div><div id="38579035" class="c"><input type="checkbox" id="c-38579035" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574042">parent</a><span>|</span><a href="#38574576">prev</a><span>|</span><a href="#38574533">next</a><span>|</span><label class="collapse" for="c-38579035">[-]</label><label class="expand" for="c-38579035">[1 more]</label></div><br/><div class="children"><div class="content">I mean, bridges collapse. That hasn&#x27;t meant we gave up on engineering bridges.
Point being, we have some risk tolerance, even for civil engineering.<p>Now we don&#x27;t accept an engineer saying, &quot;this bridge will probably collapse without warning&quot;, which we do accept with software. So there is a difference.</div><br/></div></div></div></div><div id="38572950" class="c"><input type="checkbox" id="c-38572950" checked=""/><div class="controls bullet"><span class="by">jasondigitized</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38574042">prev</a><span>|</span><a href="#38579006">next</a><span>|</span><label class="collapse" for="c-38572950">[-]</label><label class="expand" for="c-38572950">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s perfectly acceptable to let bugs escape into production if those &quot;cost&quot; of fixing that bug higher than the &quot;cost&quot; to the user experience &#x2F; job to be done.  A bug that takes a week to fix that will only be encountered by a small amount of users in a small number of obscure scenarios may not need to be fixed.</div><br/><div id="38574300" class="c"><input type="checkbox" id="c-38574300" checked=""/><div class="controls bullet"><span class="by">billti</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572950">parent</a><span>|</span><a href="#38573091">next</a><span>|</span><label class="collapse" for="c-38574300">[-]</label><label class="expand" for="c-38574300">[3 more]</label></div><br/><div class="children"><div class="content">I think a common error is taking this view in isolation on each bug.<p>Fact is, if you ship enough &#x27;low probability&#x27; bugs in your product, your probabilities still add up to a point where many customers are going to hit several of them.<p>I&#x27;ve used plenty of products that suffer from &#x27;death by a thousands cuts&#x27;. Are the bugs I hit &quot;ship blockers&quot;? No. Do I hit enough of them that the product sucks and I don&#x27;t want to use it? Absolutely.</div><br/><div id="38577431" class="c"><input type="checkbox" id="c-38577431" checked=""/><div class="controls bullet"><span class="by">owlbite</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574300">parent</a><span>|</span><a href="#38574336">next</a><span>|</span><label class="collapse" for="c-38577431">[-]</label><label class="expand" for="c-38577431">[1 more]</label></div><br/><div class="children"><div class="content">Very much this, and low risk bugs compound at scale.<p>If you&#x27;re in a very large FANNG type company, and say you have 1000 components that each ship 1 bug each day that has a 0.1% chance of breaking something critical, that translates to a less than 50% chance you ship a working OS on any given day. And that may mean the entire company&#x27;s productivity is impacted for the day depending on how broken it is.</div><br/></div></div><div id="38574336" class="c"><input type="checkbox" id="c-38574336" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574300">parent</a><span>|</span><a href="#38577431">prev</a><span>|</span><a href="#38573091">next</a><span>|</span><label class="collapse" for="c-38574336">[-]</label><label class="expand" for="c-38574336">[1 more]</label></div><br/><div class="children"><div class="content">Software is commonly built on non-fungible components and monopolies.<p>Right, you don&#x27;t want to use Microsoft Word, or SalesForce, or Apple vs Android, or X Whatever. It&#x27;s highly unlikely you&#x27;ll have a choice if you use it though.</div><br/></div></div></div></div><div id="38573091" class="c"><input type="checkbox" id="c-38573091" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572950">parent</a><span>|</span><a href="#38574300">prev</a><span>|</span><a href="#38579006">next</a><span>|</span><label class="collapse" for="c-38573091">[-]</label><label class="expand" for="c-38573091">[2 more]</label></div><br/><div class="children"><div class="content">This presupposes that you know what&#x2F;where bugs will be found and how they&#x27;ll impact future users. In my experience knowing either of these is very rare at the point where you&#x27;re &quot;building quality&quot;.</div><br/><div id="38573620" class="c"><input type="checkbox" id="c-38573620" checked=""/><div class="controls bullet"><span class="by">xkekjrktllss</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38573091">parent</a><span>|</span><a href="#38579006">next</a><span>|</span><label class="collapse" for="c-38573620">[-]</label><label class="expand" for="c-38573620">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>how they&#x27;ll impact future users</i><p>Most people in this thread understand that users&#x27; interests only matter insofar as they impact business profit.<p>I just think you&#x27;re having a different conversation.</div><br/></div></div></div></div></div></div><div id="38579006" class="c"><input type="checkbox" id="c-38579006" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572950">prev</a><span>|</span><a href="#38574530">next</a><span>|</span><label class="collapse" for="c-38579006">[-]</label><label class="expand" for="c-38579006">[2 more]</label></div><br/><div class="children"><div class="content">I think with formal analysis, whole bug classes can be eliminated. Add to that a rigorous programming style, and &#x27;bug-free&#x27; code is within reach. 
There will remain bugss that make it through, but they will be rare, and will need a chain of mistakes.<p>Currently ways of coding to this kind of standard exist. But they are stupid. It involves things like no dynamic memory allocation, only fixed length for-loops, and other very strict rules. These are used in aerospace, where bugs are rather costly and rare.</div><br/><div id="38579925" class="c"><input type="checkbox" id="c-38579925" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38579006">parent</a><span>|</span><a href="#38574530">next</a><span>|</span><label class="collapse" for="c-38579925">[-]</label><label class="expand" for="c-38579925">[1 more]</label></div><br/><div class="children"><div class="content">What seems to yield much better results is to have the program be built by two separate teams to a standard. Then both programs can be run simultaneously, checking each others output — I believe something like this is actually used in the aerospace industry.</div><br/></div></div></div></div><div id="38574530" class="c"><input type="checkbox" id="c-38574530" checked=""/><div class="controls bullet"><span class="by">fivre</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38579006">prev</a><span>|</span><a href="#38575509">next</a><span>|</span><label class="collapse" for="c-38574530">[-]</label><label class="expand" for="c-38574530">[1 more]</label></div><br/><div class="children"><div class="content">it will be necessary to deliver software without bugs that could have reasonably been avoided in time<p>ive had this sentiment thrown at me too often by peak move fast and break things types. it&#x27;s too often a cudgel to dispense with all QA in favor of more new feature development. shipping shit that has the same pattern of flaws youve encountered in the past when youve been shown ways to catch them early but couldnt be bothered isnt accepting that you cant catch everything, it&#x27;s creating a negative externality.<p>you usually can make it someone else&#x27;s problem and abscond with the profits despite, but that doesn&#x27;t mean you should</div><br/></div></div><div id="38575509" class="c"><input type="checkbox" id="c-38575509" checked=""/><div class="controls bullet"><span class="by">HeyLaughingBoy</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38574530">prev</a><span>|</span><a href="#38572686">next</a><span>|</span><label class="collapse" for="c-38575509">[-]</label><label class="expand" for="c-38575509">[1 more]</label></div><br/><div class="children"><div class="content">Nothing is bug free.<p>Not buildings, not bridges, not cars, not airplanes, not software. There are mistakes in every field of engineering and the best we can hope for is to minimize them as much as possible.<p>Engineering is knowing (among other things) how to categorize the potential mistakes, develop procedures to reduce the chance of them being made and in the case that some slip through (and they will), estimate their impact and decide when you&#x27;re &quot;good enough.&quot;<p>Software engineering is no different.</div><br/></div></div><div id="38572686" class="c"><input type="checkbox" id="c-38572686" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38575509">prev</a><span>|</span><a href="#38572939">next</a><span>|</span><label class="collapse" for="c-38572686">[-]</label><label class="expand" for="c-38572686">[1 more]</label></div><br/><div class="children"><div class="content">Correct. As I like to tell my team, if I’ve typed something I’ve caused a bug. It’s all about risk.<p>I assume I’m not infallible.<p>Writing some unit tests, C++ and mocking in my case, give both the team and myself some confidence I’ve not made things worse.<p>I’m the most experienced dev in the department.</div><br/></div></div><div id="38572939" class="c"><input type="checkbox" id="c-38572939" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572686">prev</a><span>|</span><a href="#38572790">next</a><span>|</span><label class="collapse" for="c-38572939">[-]</label><label class="expand" for="c-38572939">[16 more]</label></div><br/><div class="children"><div class="content">It is sad that people on here would believe this and that for whole platforms it is actually true, however, it absolutely is not universally true and the proof is all around us.</div><br/><div id="38574062" class="c"><input type="checkbox" id="c-38574062" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572939">parent</a><span>|</span><a href="#38572790">next</a><span>|</span><label class="collapse" for="c-38574062">[-]</label><label class="expand" for="c-38574062">[15 more]</label></div><br/><div class="children"><div class="content">What proof is all around us?</div><br/><div id="38574489" class="c"><input type="checkbox" id="c-38574489" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574062">parent</a><span>|</span><a href="#38572790">next</a><span>|</span><label class="collapse" for="c-38574489">[-]</label><label class="expand" for="c-38574489">[14 more]</label></div><br/><div class="children"><div class="content">The amount of software in everyday objects which runs without exhibiting bugs to such a degree we do not notice most of it even exists.</div><br/><div id="38574549" class="c"><input type="checkbox" id="c-38574549" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574489">parent</a><span>|</span><a href="#38575552">next</a><span>|</span><label class="collapse" for="c-38574549">[-]</label><label class="expand" for="c-38574549">[11 more]</label></div><br/><div class="children"><div class="content">Yes, but that software is not bug-free. The claim was not &quot;it&#x27;s impossible to make software that does not exhibit bugs too a casually noticeable degree&quot;.<p>People who know how the sausage is made will always know of a bunch of bugs that haven&#x27;t been fixed exactly because they aren&#x27;t impactful enough to be worth the effort required to fix them.</div><br/><div id="38574778" class="c"><input type="checkbox" id="c-38574778" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574549">parent</a><span>|</span><a href="#38575552">next</a><span>|</span><label class="collapse" for="c-38574778">[-]</label><label class="expand" for="c-38574778">[10 more]</label></div><br/><div class="children"><div class="content">If it works within specs it is bug free. It doesn’t matter how it is made if it works within specs, which is one of the real unfortunate truths of software.<p>The other is working out the correct specification is far harder than coding is.<p>For example it is trivial to write a bug free program that multiplies an integer between 3 and 45 by two.</div><br/><div id="38575231" class="c"><input type="checkbox" id="c-38575231" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574778">parent</a><span>|</span><a href="#38575065">next</a><span>|</span><label class="collapse" for="c-38575231">[-]</label><label class="expand" for="c-38575231">[2 more]</label></div><br/><div class="children"><div class="content">Most devices work within the spec 99.9% of the time, but that last .1% it is outside the  spec.  The exact % is different for different projects of course, but the idea is still there: no software operates according to spec 100% of the time.</div><br/><div id="38575548" class="c"><input type="checkbox" id="c-38575548" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575231">parent</a><span>|</span><a href="#38575065">next</a><span>|</span><label class="collapse" for="c-38575548">[-]</label><label class="expand" for="c-38575548">[1 more]</label></div><br/><div class="children"><div class="content">It does though. My example of adding two ints within a known finite range would operate to spec 100% of the time.<p>You would have to introduce things like tolerance to hardware failure, but that is outside the spec of the software as stated.</div><br/></div></div></div></div><div id="38575065" class="c"><input type="checkbox" id="c-38575065" checked=""/><div class="controls bullet"><span class="by">digging</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574778">parent</a><span>|</span><a href="#38575231">prev</a><span>|</span><a href="#38575623">next</a><span>|</span><label class="collapse" for="c-38575065">[-]</label><label class="expand" for="c-38575065">[6 more]</label></div><br/><div class="children"><div class="content">&gt; If it works within specs it is bug free.<p>No, it&#x27;s functional. If it has bugs, it&#x27;s not bug-free. By definition.</div><br/><div id="38575742" class="c"><input type="checkbox" id="c-38575742" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575065">parent</a><span>|</span><a href="#38575266">next</a><span>|</span><label class="collapse" for="c-38575742">[-]</label><label class="expand" for="c-38575742">[1 more]</label></div><br/><div class="children"><div class="content">Not to get too meta here but… what is your definition of a bug? One plausible definition is “system deviates from its specification”.</div><br/></div></div><div id="38575266" class="c"><input type="checkbox" id="c-38575266" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575065">parent</a><span>|</span><a href="#38575742">prev</a><span>|</span><a href="#38575623">next</a><span>|</span><label class="collapse" for="c-38575266">[-]</label><label class="expand" for="c-38575266">[4 more]</label></div><br/><div class="children"><div class="content">What would it mean to be bug free then?<p>To quote a former marketing guy “it should work out what the user intends to do and do it”?</div><br/><div id="38575651" class="c"><input type="checkbox" id="c-38575651" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575266">parent</a><span>|</span><a href="#38575500">next</a><span>|</span><label class="collapse" for="c-38575651">[-]</label><label class="expand" for="c-38575651">[1 more]</label></div><br/><div class="children"><div class="content">Bug free software means developers would not disclose any information about present bugs in the software they ship to customers.<p>Really bug free commercial software does not exist. And can&#x27;t exist. There are always bugs which are known but would not be fixed.</div><br/></div></div><div id="38575500" class="c"><input type="checkbox" id="c-38575500" checked=""/><div class="controls bullet"><span class="by">digging</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575266">parent</a><span>|</span><a href="#38575651">prev</a><span>|</span><a href="#38575623">next</a><span>|</span><label class="collapse" for="c-38575500">[-]</label><label class="expand" for="c-38575500">[2 more]</label></div><br/><div class="children"><div class="content">To have no bugs, which is extremely unlikely for a program of any real complexity. Having bugs, and being functional, are <i>fairly</i> self-explanatory and independent of each other. No need to try to conflate them.<p>Not sure what your quote is supposed to mean. That&#x27;s a textbook example of someone who doesn&#x27;t understand software at all making laughable requests of their engineers.</div><br/><div id="38575777" class="c"><input type="checkbox" id="c-38575777" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38575500">parent</a><span>|</span><a href="#38575623">next</a><span>|</span><label class="collapse" for="c-38575777">[-]</label><label class="expand" for="c-38575777">[1 more]</label></div><br/><div class="children"><div class="content">To be bug free we must be able to define what a bug is. So, what is a bug?<p>The reason for that quote is from what you have said a bug would be anything you didn&#x27;t expect, even if it is consistent or not with the specification as that merely affects if we classify it as functional or not (a classification I profoundly disagree with, obviously). It is simply a negative rephrasing of what the marketing guy said and laughable in the same way.</div><br/></div></div></div></div></div></div></div></div><div id="38575623" class="c"><input type="checkbox" id="c-38575623" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574778">parent</a><span>|</span><a href="#38575065">prev</a><span>|</span><a href="#38575552">next</a><span>|</span><label class="collapse" for="c-38575623">[-]</label><label class="expand" for="c-38575623">[1 more]</label></div><br/><div class="children"><div class="content">You know, there could be bugs in spec. And you can have a software written with bugs but according to spec.<p>When testing should start? BEFORE the first line of code is written.</div><br/></div></div></div></div></div></div><div id="38575552" class="c"><input type="checkbox" id="c-38575552" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574489">parent</a><span>|</span><a href="#38574549">prev</a><span>|</span><a href="#38575245">next</a><span>|</span><label class="collapse" for="c-38575552">[-]</label><label class="expand" for="c-38575552">[1 more]</label></div><br/><div class="children"><div class="content">I encounter bugs everywhere all time. List goes very long.<p>Microwave has random errors from time to time.<p>Robo vacuum freezes.<p>Parking meter malfunction.<p>Public transport ticket machine don&#x27;t want to give me a ticket.<p>Online banking failing to make a transfer because I use UI with other language.<p>Mobile banking failing to make a transfer because I use not native currency.<p>Car has issues as well, incorrect fuel amount is injected by computer.<p>Online pages have tons of bugs, many are barely usable.</div><br/></div></div><div id="38575245" class="c"><input type="checkbox" id="c-38575245" checked=""/><div class="controls bullet"><span class="by">avgDev</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574489">parent</a><span>|</span><a href="#38575552">prev</a><span>|</span><a href="#38572790">next</a><span>|</span><label class="collapse" for="c-38575245">[-]</label><label class="expand" for="c-38575245">[1 more]</label></div><br/><div class="children"><div class="content">There are people PUTTING out fires nonstop in many apps we all use.<p>I have been writing code for almost a decade now, and still make errors. I don&#x27;t believe anyone is capable of producing bug free software.<p>I have also seen plenty of bugs in apps and games. I don&#x27;t think I have ever witnessed a major game patch that was bug free.</div><br/></div></div></div></div></div></div></div></div><div id="38572790" class="c"><input type="checkbox" id="c-38572790" checked=""/><div class="controls bullet"><span class="by">chopsuey5540</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572939">prev</a><span>|</span><a href="#38573146">next</a><span>|</span><label class="collapse" for="c-38572790">[-]</label><label class="expand" for="c-38572790">[10 more]</label></div><br/><div class="children"><div class="content">You might be correct today but that’s a pretty sad state of affairs, don’t you think we can do better? Most other engineering domains can deliver projects without bugs, with various definitions of “bug” of course</div><br/><div id="38573254" class="c"><input type="checkbox" id="c-38573254" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572790">parent</a><span>|</span><a href="#38572861">next</a><span>|</span><label class="collapse" for="c-38573254">[-]</label><label class="expand" for="c-38573254">[1 more]</label></div><br/><div class="children"><div class="content">To be an engineer is to know the expected system requirements and build a product that is extremely optimized for the system requirements.<p>There&#x27;s a saying that I think fits very well here: &quot;Any idiot can build a bridge that stands, but it takes an engineer to build a bridge that barely stands.&quot;<p>You don&#x27;t want a bridge to cost 50 years and quadrillions of dollars to build, you want a cheap bridge safe for the next 50 years done in 2 years.<p>I would not call the resulting bridge &quot;bug free&quot;, of course.</div><br/></div></div><div id="38572861" class="c"><input type="checkbox" id="c-38572861" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572790">parent</a><span>|</span><a href="#38573254">prev</a><span>|</span><a href="#38575438">next</a><span>|</span><label class="collapse" for="c-38572861">[-]</label><label class="expand" for="c-38572861">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure about that. Which engineering domain do you have in mind?<p>Maybe show-stopping bugs are somewhat unique to software engineering, but all somewhat-complex products are flawed to some extent imho.<p>It might be an unergonomic handle on a frying pan, furniture that visibly warps under the slightest load (looking at ikea shelfing) or the lettering coming off the frequently used buttons on a coffee machine.</div><br/><div id="38574159" class="c"><input type="checkbox" id="c-38574159" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572861">parent</a><span>|</span><a href="#38575757">next</a><span>|</span><label class="collapse" for="c-38574159">[-]</label><label class="expand" for="c-38574159">[2 more]</label></div><br/><div class="children"><div class="content">But there do exist shelves that don’t warp, when used within some reasonable bounds.<p>I’d also quibble about the buttons on the coffee machine. They might be properly designed, just subject to the normal wear-and-tear that is inevitable in the real world. This is not a defect, physical devices have finite lifespans.<p>As far as computers go… if we got to the point where the main thing that killed our programs was the hard drives falling apart and capacitors drying out, that would be quite impressive and I think everyone would be a little bit less critical of the field.</div><br/><div id="38574558" class="c"><input type="checkbox" id="c-38574558" checked=""/><div class="controls bullet"><span class="by">saled</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574159">parent</a><span>|</span><a href="#38575757">next</a><span>|</span><label class="collapse" for="c-38574558">[-]</label><label class="expand" for="c-38574558">[1 more]</label></div><br/><div class="children"><div class="content">Formally verified, bug free software exists. It just costs a LOT to produce, and typically isn&#x27;t worth it, except for things like cryptographic libraries and life or death systems.<p>As the discipline has evolved, the high integrity tools are slowly being incorporated into typical languages and IDEs to generally improve quality cheaper. Compare C++ to rust for example, whole classes of bugs are impossible (or much harder to make) in rust.</div><br/></div></div></div></div><div id="38575757" class="c"><input type="checkbox" id="c-38575757" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572861">parent</a><span>|</span><a href="#38574159">prev</a><span>|</span><a href="#38575438">next</a><span>|</span><label class="collapse" for="c-38575757">[-]</label><label class="expand" for="c-38575757">[1 more]</label></div><br/><div class="children"><div class="content">There are many examples of catastrophic bugs in real life.<p>New bridges collapses, dams overflow s, planes crashes, vaccines kills, food kills, leaning towers and skyscrapers, capsized ships - catastrophic flaws are everywhere.</div><br/></div></div></div></div><div id="38575438" class="c"><input type="checkbox" id="c-38575438" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572790">parent</a><span>|</span><a href="#38572861">prev</a><span>|</span><a href="#38572886">next</a><span>|</span><label class="collapse" for="c-38575438">[-]</label><label class="expand" for="c-38575438">[1 more]</label></div><br/><div class="children"><div class="content">We can certainly do better, but it takes a _lot_ of time, effort, care and discipline; something most teams don&#x27;t have, and most projects can&#x27;t afford.<p>Bugs arise from the inherent complexity introduced by writing code, and our inability to foresee all the logical paths a machine can take. If we&#x27;re disciplined, we write more code to test the scenarios we can think of, which is an extremely arduous process, that even with the most thorough testing practices (e.g. SQLite) still can&#x27;t produce failproof software. This is partly because, while we can control our own software to a certain degree, we have no control over the inputs it receives and all of its combinations, nor over the environment it runs in, which is also built by other humans, and has its own set of bugs. The fact modern computing works at all is nothing short of remarkable.<p>But I&#x27;m optimistic about AI doing much better. Not the general pattern matching models we use today, though these are still helpful with chore tasks, as a reference tool, and will continue to improve in ways that help us write less bugs, with less effort. But eventually, AI will be able to evaluate all possible branches of execution, and arrive at the solution with the least probability of failing. Once it also controls the environment the software runs in and its inputs, it will be able to modify all of these variables to produce the desired outcome. There won&#x27;t be a large demand for human-written software once this happens. We might even ban software by humans from being used in critical environments, just like we&#x27;ll ban humans from driving cars on public roads. We&#x27;ll probably find the lower quality and bugs amusing and charming, so there will be some demand for this type of software, but it will be written by hobbyists and enjoyed by a niche audience.</div><br/></div></div><div id="38574078" class="c"><input type="checkbox" id="c-38574078" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38572790">parent</a><span>|</span><a href="#38572831">prev</a><span>|</span><a href="#38573146">next</a><span>|</span><label class="collapse" for="c-38574078">[-]</label><label class="expand" for="c-38574078">[1 more]</label></div><br/><div class="children"><div class="content">Their stuff has bugs too.</div><br/></div></div></div></div><div id="38573146" class="c"><input type="checkbox" id="c-38573146" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#38572596">parent</a><span>|</span><a href="#38572790">prev</a><span>|</span><a href="#38577399">next</a><span>|</span><label class="collapse" for="c-38573146">[-]</label><label class="expand" for="c-38573146">[3 more]</label></div><br/><div class="children"><div class="content">A saying that I once heard and appreciate goes like this:<p>&quot;A programmer who releases buggy software and fixes them is better than a programmer who always releases perfect software in one shot, because the latter doesn&#x27;t know how to fix bugs.&quot;<p>Perhaps similar to the saying that a good driver will miss a turn, but a bad driver never misses one.</div><br/><div id="38574520" class="c"><input type="checkbox" id="c-38574520" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38573146">parent</a><span>|</span><a href="#38577399">next</a><span>|</span><label class="collapse" for="c-38574520">[-]</label><label class="expand" for="c-38574520">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s backward. A successful software development methodology will tend to catch bugs early in the development pipeline.<p>The <i>doesn&#x27;t know how to fix bugs</i> idea seems pretty silly.</div><br/><div id="38576589" class="c"><input type="checkbox" id="c-38576589" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#38572596">root</a><span>|</span><a href="#38574520">parent</a><span>|</span><a href="#38577399">next</a><span>|</span><label class="collapse" for="c-38576589">[-]</label><label class="expand" for="c-38576589">[1 more]</label></div><br/><div class="children"><div class="content">I think you misunderstand, I&#x27;m talking about a programmer who makes <i>perfect, bug-free code</i> in one shot. There are no bugs to catch and fix, because this &quot;perfect&quot; programmer never writes buggy code.<p>The moral of the sayings is, that &quot;perfect&quot; programmer is actually a bad programmer because he wouldn&#x27;t know how to fix bugs by virtue of never needing to deal with them.<p>To reuse the driver analogy, the driver who never misses a turn is a bad driver because he doesn&#x27;t know what to do when he does miss a turn.</div><br/></div></div></div></div></div></div></div></div><div id="38577399" class="c"><input type="checkbox" id="c-38577399" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#38572596">prev</a><span>|</span><a href="#38572570">next</a><span>|</span><label class="collapse" for="c-38577399">[-]</label><label class="expand" for="c-38577399">[14 more]</label></div><br/><div class="children"><div class="content">You learn this at quality shops. 10-15 years ago roughly FAANG.<p>Today? TailScale and stuff like that.<p>You can just noT have a bunch of pointless micro services and docker in your runc and layer on layer of json de&#x2F;re, and unit test to get coverage but ignore quickcheck and hypothesis and fuzzing.<p>You can use stacked diffs and run oncall loops out of the team authoring the code and all of it.<p>You can minimize dynamic linking and all the other forms of unforced dependency error.<p>You can understand and play towards the runtimes of all the managed languages in your stack. You can insist that a halfway decent verbal grammar for the languages is “readability”.<p>It gets shouted down over and over but it’s public knowledge how to ship quality software.</div><br/><div id="38577416" class="c"><input type="checkbox" id="c-38577416" checked=""/><div class="controls bullet"><span class="by">ttymck</span><span>|</span><a href="#38577399">parent</a><span>|</span><a href="#38577496">next</a><span>|</span><label class="collapse" for="c-38577416">[-]</label><label class="expand" for="c-38577416">[5 more]</label></div><br/><div class="children"><div class="content">I think the prevailing problem is that quality software often doesn&#x27;t outperform shit software in terms of revenue, right?</div><br/><div id="38577730" class="c"><input type="checkbox" id="c-38577730" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577416">parent</a><span>|</span><a href="#38577453">next</a><span>|</span><label class="collapse" for="c-38577730">[-]</label><label class="expand" for="c-38577730">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that, it&#x27;s that quality doesn&#x27;t matter and mostly neither does technology.<p>If you are doing network switches or GPUs or server CPUs or whatever, yeah, technology matters. If you are building pretty much any SaaS, MCCA, etc. the tech is literally irrelevant and mostly the more &quot;new&quot; tech you use the worse off you are.<p>Quality also only matters in some contexts and those are even rarer than the above.<p>Timing and solving a problem is all that matters in terms of revenue. As long as you aren&#x27;t too bad, it&#x27;s fine. The only real five-nines requirement for SaaS is that 99.999% of them would be fine with one or two nines.</div><br/><div id="38579889" class="c"><input type="checkbox" id="c-38579889" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577730">parent</a><span>|</span><a href="#38577453">next</a><span>|</span><label class="collapse" for="c-38579889">[-]</label><label class="expand" for="c-38579889">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true at all. Very often I&#x27;ve seen features being delayed or completely disregarded due to technology decisions.<p>It then looks like it was a &quot;business reason&quot; in the end, but it&#x27;s not so easy to just distinguish what the root cause really was.</div><br/></div></div></div></div><div id="38577453" class="c"><input type="checkbox" id="c-38577453" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577416">parent</a><span>|</span><a href="#38577730">prev</a><span>|</span><a href="#38577496">next</a><span>|</span><label class="collapse" for="c-38577453">[-]</label><label class="expand" for="c-38577453">[2 more]</label></div><br/><div class="children"><div class="content">CloudFlare and TailScale and that crowd don’t seem to be chancing it?</div><br/><div id="38578995" class="c"><input type="checkbox" id="c-38578995" checked=""/><div class="controls bullet"><span class="by">bottled_poe</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577453">parent</a><span>|</span><a href="#38577496">next</a><span>|</span><label class="collapse" for="c-38578995">[-]</label><label class="expand" for="c-38578995">[1 more]</label></div><br/><div class="children"><div class="content">They are outliers. Most startups focus on feature velocity and sales first, quality is an afterthought, regardless of what they might say. Also, if your project is open source, quality has a lot more weight towards uptake.</div><br/></div></div></div></div></div></div><div id="38577496" class="c"><input type="checkbox" id="c-38577496" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38577399">parent</a><span>|</span><a href="#38577416">prev</a><span>|</span><a href="#38577596">next</a><span>|</span><label class="collapse" for="c-38577496">[-]</label><label class="expand" for="c-38577496">[5 more]</label></div><br/><div class="children"><div class="content"><i>roughly FAANG</i><p>What does roughly FAANG mean?<p><i>Today? TailScale and stuff like that.</i><p>The VPN?<p>You might have some ideas about quality software, but this comment is incomprehensible.</div><br/><div id="38578282" class="c"><input type="checkbox" id="c-38578282" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577496">parent</a><span>|</span><a href="#38578241">next</a><span>|</span><label class="collapse" for="c-38578282">[-]</label><label class="expand" for="c-38578282">[1 more]</label></div><br/><div class="children"><div class="content">OP is saying that 10-15 years ago FAANG companies (and a few more) were the only ones writing quality software. Now, FAANG doesn&#x27;t care anymore but there are new unicorns in the making that do care - TailScale being one of them (debatable)</div><br/></div></div><div id="38578241" class="c"><input type="checkbox" id="c-38578241" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38577496">parent</a><span>|</span><a href="#38578282">prev</a><span>|</span><a href="#38577596">next</a><span>|</span><label class="collapse" for="c-38578241">[-]</label><label class="expand" for="c-38578241">[3 more]</label></div><br/><div class="children"><div class="content">Someone&#x27;s butthurt about never working for a company with a recognisable name?</div><br/><div id="38578273" class="c"><input type="checkbox" id="c-38578273" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38578241">parent</a><span>|</span><a href="#38577596">next</a><span>|</span><label class="collapse" for="c-38578273">[-]</label><label class="expand" for="c-38578273">[2 more]</label></div><br/><div class="children"><div class="content">How did you get to that? I can&#x27;t even figure out what the comment I replied to is talking about. It isn&#x27;t made up of full sentences and real words.</div><br/><div id="38579714" class="c"><input type="checkbox" id="c-38579714" checked=""/><div class="controls bullet"><span class="by">slvng</span><span>|</span><a href="#38577399">root</a><span>|</span><a href="#38578273">parent</a><span>|</span><a href="#38577596">next</a><span>|</span><label class="collapse" for="c-38579714">[-]</label><label class="expand" for="c-38579714">[1 more]</label></div><br/><div class="children"><div class="content">Not well written but understood the same.</div><br/></div></div></div></div></div></div></div></div><div id="38577596" class="c"><input type="checkbox" id="c-38577596" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#38577399">parent</a><span>|</span><a href="#38577496">prev</a><span>|</span><a href="#38577686">next</a><span>|</span><label class="collapse" for="c-38577596">[-]</label><label class="expand" for="c-38577596">[1 more]</label></div><br/><div class="children"><div class="content">Any advice on how to find these quality shops and this quality knowledge? Any particular things to look for, or particular books&#x2F;courses you recommend?</div><br/></div></div></div></div><div id="38572570" class="c"><input type="checkbox" id="c-38572570" checked=""/><div class="controls bullet"><span class="by">johngossman</span><span>|</span><a href="#38577399">prev</a><span>|</span><a href="#38573361">next</a><span>|</span><label class="collapse" for="c-38572570">[-]</label><label class="expand" for="c-38572570">[22 more]</label></div><br/><div class="children"><div class="content">There are Computer Engineering programs and a few universities that really emphasize internships and hands on practice. But at many universities, the CS department came out of the Math department and is focused on theory. Chemistry isn&#x27;t Chemical Engineering either. I think that&#x27;s okay. University isn&#x27;t just a trade school--the idea behind almost any degree is to train the mind and demonstrate an ability to master complex material.</div><br/><div id="38572701" class="c"><input type="checkbox" id="c-38572701" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">parent</a><span>|</span><a href="#38572635">next</a><span>|</span><label class="collapse" for="c-38572701">[-]</label><label class="expand" for="c-38572701">[19 more]</label></div><br/><div class="children"><div class="content">What society needs is a mix of trade school a traditional university. If a university is not providing both they are failing everyone. (except the straw-man rich kid who will inherit a lot of money but not be expected to either also inherit&#x2F;run a company or pass the money onto their kids - this is something that happens in story books but doesn&#x27;t seem to be real world where the rich give their kids lots of advantages but eventually expect them to take over and run the family business)<p>A pure university education without considering is this degree useful in the real world is a disservice to education.  However a pure trade school education that teaches how to do something without understanding is not useful (I don&#x27;t think any trade school is that pure: they tell you to ignore hard stuff but generally give you deep understanding of some important things)</div><br/><div id="38573708" class="c"><input type="checkbox" id="c-38573708" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38572701">parent</a><span>|</span><a href="#38572635">next</a><span>|</span><label class="collapse" for="c-38573708">[-]</label><label class="expand" for="c-38573708">[18 more]</label></div><br/><div class="children"><div class="content">&gt; If a university is not providing both they are failing everyone.<p>Why?<p>&gt; A pure university education without considering is this degree useful in the real world is a disservice to education.<p>I think this line of thinking is a much bigger disservice to higher education. It was very tiresome as an undergraduate to be surrounded by people that thought this way - and detrimental to everyone&#x27;s education.<p>&quot;I&#x27;ll never use this knowledge&quot; is the single worst thing you can say as a student, and it needs to be beaten out of undergrads&#x27; heads. Not encouraged.</div><br/><div id="38574505" class="c"><input type="checkbox" id="c-38574505" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573708">parent</a><span>|</span><a href="#38575130">next</a><span>|</span><label class="collapse" for="c-38574505">[-]</label><label class="expand" for="c-38574505">[7 more]</label></div><br/><div class="children"><div class="content">Because like it or not most people are going to university to get a better jobs.  Companies like university educated people because they learn deep thinking. However they often come out lacking important skills that are needed.<p>Sure there are a few going to university just for the fun of it.  However most are expecting a job. Thus universities should train and emphasize thinking in more specific areas.<p>&gt; &quot;I&#x27;ll never use this knowledge&quot; is the single worst thing you can say as a student, and it needs to be beaten out of undergrads&#x27; heads. Not encouraged.<p>This is tricky. I agree undergrads say this all the time when they are wrong but they don&#x27;t know it. They have no clue what they will use and what they won&#x27;t. This is something universities should figure out so they push people to avoid things they won&#x27;t use. OTOH, a lot of what they are really teaching isn&#x27;t the specific skill, but how to research and analyze data to find complex answers - it doesn&#x27;t matter if you look at data from art or from science, what you are really learning is how to think and the specific knowledge gained is isn&#x27;t important or the point (I think this is the point you were trying to make?).</div><br/><div id="38574655" class="c"><input type="checkbox" id="c-38574655" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574505">parent</a><span>|</span><a href="#38574689">next</a><span>|</span><label class="collapse" for="c-38574655">[-]</label><label class="expand" for="c-38574655">[3 more]</label></div><br/><div class="children"><div class="content">&gt; However they often come out lacking important skills that are needed.<p>Companies that offer the jobs are the ones that need to offer the job training.<p>&gt; (I think this is the point you were trying to make?)<p>Not really, it&#x27;s that university education is kind of meta&#x2F;self serving (the goal is not to train X number of students to do Y jobs, it&#x27;s to give every student at the institution what that institution defines to be an education).<p>But like you said, the fact this produces better workers is a second-order effect. It&#x27;s not the goal of most institutions. But not all institutions; some define &quot;well educated&quot; to have lots of industry practicum, and if you want that, go study at those institutions.<p>My main point is that it&#x27;s not a &quot;disservice&quot; to eschew practicum or industry training as an educational institution.</div><br/><div id="38575354" class="c"><input type="checkbox" id="c-38575354" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574655">parent</a><span>|</span><a href="#38574689">next</a><span>|</span><label class="collapse" for="c-38575354">[-]</label><label class="expand" for="c-38575354">[2 more]</label></div><br/><div class="children"><div class="content">What society needs is the second order effect though.  I don&#x27;t care about education for the sake of education, I can for what education can do for me&#x2F;society.  Now some of what most institutions define as a good education is good for society (the ability to think is very useful), but I don&#x27;t value&#x2F;support education because of arbitrary definitions that an institution might come up with.  I value&#x2F;support education because people who have education tend to show specific abilities in society that I want more people to have.  The more universities are in line with that and try to produce that the more I value&#x2F;support them. (note that I didn&#x27;t not formally define what those things are - this is a tricky topic that I&#x27;m sure to get wrong if I tried!)<p>When institutions allow student to take degrees that society finds less valuable (art,music...) they are doing society a disservice by not producing what society needs.  Now if the student is wealthy (not rich) enough to afford that the price then I don&#x27;t care: I don&#x27;t need to impose my values on anyone else.  However most people in a university are not that wealthy (most are young) and so if the degree granted isn&#x27;t valuable to society the university robbed that student.</div><br/><div id="38576383" class="c"><input type="checkbox" id="c-38576383" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38575354">parent</a><span>|</span><a href="#38574689">next</a><span>|</span><label class="collapse" for="c-38576383">[-]</label><label class="expand" for="c-38576383">[1 more]</label></div><br/><div class="children"><div class="content">&gt;When institutions allow student to take degrees that society finds less valuable (art,music...) they are doing society a disservice by not producing what society needs.<p>1. what&#x27;s wrong with a student pursuing their own personal goals? A person doesn&#x27;t need to produce for society&#x27;s sake.<p>2. despite that sentiment you hold, it&#x27;s clear many people do value art and music. Maybe not in its pure form, but those artists do in fact fuel industries worth billions. Clearly &quot;society&quot; values something that requires such skills and thinking.</div><br/></div></div></div></div></div></div><div id="38574689" class="c"><input type="checkbox" id="c-38574689" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574505">parent</a><span>|</span><a href="#38574655">prev</a><span>|</span><a href="#38575130">next</a><span>|</span><label class="collapse" for="c-38574689">[-]</label><label class="expand" for="c-38574689">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Companies like university educated people because they learn deep thinking.<p>No. Companies love hiring higher-ed graduates because it removes <i>a lot</i> of cost and risk for them:<p>- hiring only people with degrees weeds out everyone unable to cope with a high-stress environment, for whatever reason - crucially, also including people who would normally be protected by ADA or its equivalent provisions in Europe.<p>- it weeds out people in relationships or with (young) children, which makes them easier to exploit and reduces the amount of unexpected time-off due to whatever bug is currently sweeping through kindergarten&#x2F;school&#x2F;whatever. Sure, eventually they will get into relationships and have children as they age, but looking at the age people start to have kids these days [0], that&#x27;s a solid 5-10 years you can squeeze them for overtime.<p>- it saves companies a ridiculous amount of training. The old &quot;tradespeople apprenticeship&quot; way is very cost-intensive as you have to train them on virtually <i>anything</i>, not just stuff relevant to the job, e.g. using computers and common office software. Instead, the cost is picked up either by the taxpayer (in Europe) or by the students <i>themselves</i> in the form of college debt. The latter used to be reserved for high-paying jobs such as pilots who have to &quot;work off&quot; their training cost but got compensated really well, nowadays it&#x27;s standard practice.<p>- it keeps the employee diversity relatively homogenous. There is a <i>clear</i> bias towards white and asian ethnicity in the US for higher ed [1], and among top-earning job, males still <i>utterly</i> dominate [2].<p>- related to the above, it also weeds out people from lower economic classes, although at least that trend has been seriously diminishing over the last decades [3].<p>[0] <a href="https:&#x2F;&#x2F;www.nytimes.com&#x2F;interactive&#x2F;2018&#x2F;08&#x2F;04&#x2F;upshot&#x2F;up-birth-age-gap.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nytimes.com&#x2F;interactive&#x2F;2018&#x2F;08&#x2F;04&#x2F;upshot&#x2F;up-bir...</a><p>[1] <a href="https:&#x2F;&#x2F;hechingerreport.org&#x2F;proof-points-new-higher-ed-data-by-race-and-ethnicity&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hechingerreport.org&#x2F;proof-points-new-higher-ed-data-...</a><p>[2] <a href="https:&#x2F;&#x2F;www.bankrate.com&#x2F;loans&#x2F;student-loans&#x2F;top-paying-college-majors-gender-gap&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.bankrate.com&#x2F;loans&#x2F;student-loans&#x2F;top-paying-coll...</a><p>[3] <a href="https:&#x2F;&#x2F;www.pewresearch.org&#x2F;social-trends&#x2F;2019&#x2F;05&#x2F;22&#x2F;a-rising-share-of-undergraduates-are-from-poor-families-especially-at-less-selective-colleges&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pewresearch.org&#x2F;social-trends&#x2F;2019&#x2F;05&#x2F;22&#x2F;a-risin...</a></div><br/><div id="38575374" class="c"><input type="checkbox" id="c-38575374" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574689">parent</a><span>|</span><a href="#38575130">next</a><span>|</span><label class="collapse" for="c-38575374">[-]</label><label class="expand" for="c-38575374">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and among top-earning job, males still utterly dominate<p>And thus you destroyed you whole point: females dominate universities these days.</div><br/><div id="38576937" class="c"><input type="checkbox" id="c-38576937" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38575374">parent</a><span>|</span><a href="#38575130">next</a><span>|</span><label class="collapse" for="c-38576937">[-]</label><label class="expand" for="c-38576937">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the degree program. In STEM, women are still the minority by far [1], especially in IT.<p>[1] <a href="https:&#x2F;&#x2F;www.stemwomen.com&#x2F;women-in-stem-percentages-of-women-in-stem-statistics" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.stemwomen.com&#x2F;women-in-stem-percentages-of-women...</a></div><br/></div></div></div></div></div></div></div></div><div id="38575130" class="c"><input type="checkbox" id="c-38575130" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573708">parent</a><span>|</span><a href="#38574505">prev</a><span>|</span><a href="#38573785">next</a><span>|</span><label class="collapse" for="c-38575130">[-]</label><label class="expand" for="c-38575130">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;I&#x27;ll never use this knowledge&quot; is the single worst thing you can say as a student, and it needs to be beaten out of undergrads&#x27; heads.<p>Everyone will think differently. I&#x27;ve never truly be research-minded and there&#x27;s very much a bunch of odd classes that felt like a waste of my money (something to consider as education gets more expensive). But I do agree that there should be a space to foster researchers and especially one to overall round out a student, even if that space is more niche. I just don&#x27;t think that everyone needs to go far into debt for that experience if they just want job training.<p>So I too desire a more explicit divide than &quot;research university vs. industry university&quot; and wish there were some better trade schools focused on software (not 6 month boot-camps. Think of a condensed university program without requirements of electives and maybe less supporting classes). But no one seems to be protesting this much.</div><br/></div></div><div id="38573785" class="c"><input type="checkbox" id="c-38573785" checked=""/><div class="controls bullet"><span class="by">sneed_chucker</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573708">parent</a><span>|</span><a href="#38575130">prev</a><span>|</span><a href="#38574773">next</a><span>|</span><label class="collapse" for="c-38573785">[-]</label><label class="expand" for="c-38573785">[8 more]</label></div><br/><div class="children"><div class="content">I agree with you in principle, but it&#x27;s very easy to have this attitude when the education isn&#x27;t obscenely expensive.<p>Which is why the &quot;I&#x27;m never going to use this, what a waste of time&quot; feeling among American undergrad students is so common.
If you fix the affordability problem and bring it back to where is was in the mid 70s (inflation adjusted) I think things would be a lot better.</div><br/><div id="38574051" class="c"><input type="checkbox" id="c-38574051" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573785">parent</a><span>|</span><a href="#38574546">next</a><span>|</span><label class="collapse" for="c-38574051">[-]</label><label class="expand" for="c-38574051">[6 more]</label></div><br/><div class="children"><div class="content">My point is that higher education isn&#x27;t job training and doesn&#x27;t pretend to be, and people who think it is or should are the ones that need education the most because they don&#x27;t seem to get it.</div><br/><div id="38574323" class="c"><input type="checkbox" id="c-38574323" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574051">parent</a><span>|</span><a href="#38574298">next</a><span>|</span><label class="collapse" for="c-38574323">[-]</label><label class="expand" for="c-38574323">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>and doesn&#x27;t pretend to be</i><p>I&#x27;m not sure about this part... A very common pattern in my conversations with working class friends and family from my parents&#x27; generation is: &quot;we were told that if we sent our kids to college, they&#x27;d have better lives than we did, but instead we all just ended up with more debt than we could handle&quot;.<p>It&#x27;s tricky! If you tell teenagers and their parents the truth - this purely academic program will not train you for any job besides pure academia, which, while it <i>can</i> be a fantastic career, is a super risky hits business in which only a few will truly succeed - then that&#x27;s only going to sound like a reasonable risk to take for wealthy families. But then you&#x27;ve badly limited your pool of academic researchers to this extremely small and honestly often not as promising set of rich kids.<p>Maybe one solution (which is not workable in the real world) would be: any academic program that does not have a viable &quot;job training&quot; component should <i>only</i> accept students on academic scholarship, regardless of their own means. If some neutral party thinks they are promising enough in that field to pay their way, they get to go for free, otherwise they don&#x27;t get to go at all. The programs that do graduate people with directly marketable job skills could keep working the current mercenary way.<p>The reason this wouldn&#x27;t work in reality is that the wealthy would still just game the scholarships in some way. Alas.</div><br/><div id="38574575" class="c"><input type="checkbox" id="c-38574575" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574323">parent</a><span>|</span><a href="#38574738">next</a><span>|</span><label class="collapse" for="c-38574575">[-]</label><label class="expand" for="c-38574575">[1 more]</label></div><br/><div class="children"><div class="content">There is a big difference in value between different degrees in the real world. Yet the costs are similar. What someone studies is very important and universities do not do a good job of telling people that.<p>There is nothing wrong with art&#x2F;music&#x2F;history. If you are interested by all means take a lot of courses in them. You can learn a lot of valuable skills which is why good universities required a diverse background of &quot;generals&quot; that these (and many more) fit into.  However they give far more degrees in these things than are needed. (even physics gets more degrees than the world needs - but most getting a physics degree can better pivot to something else well paying).</div><br/></div></div><div id="38574738" class="c"><input type="checkbox" id="c-38574738" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574323">parent</a><span>|</span><a href="#38574575">prev</a><span>|</span><a href="#38574298">next</a><span>|</span><label class="collapse" for="c-38574738">[-]</label><label class="expand" for="c-38574738">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure about this part...<p>If you want to know what a university will teach your kids, ask them. They&#x27;ll even tell you without asking them - it was pretty obvious to me as a dumb high school kid on campus visits what the emphasis of one program or another was going to be.</div><br/><div id="38576001" class="c"><input type="checkbox" id="c-38576001" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574738">parent</a><span>|</span><a href="#38574298">next</a><span>|</span><label class="collapse" for="c-38576001">[-]</label><label class="expand" for="c-38576001">[1 more]</label></div><br/><div class="children"><div class="content">What I&#x27;m saying is: universities are incentivized to mislead people (including themselves!) about this.<p>If you are a working class family with a kid who is very talented at math, and you go sit down with the counselors and ask them: If my child studies pure theoretical math, will that open them up to a life full of possibilities? they will say &quot;yes, it absolutely will&quot;. But that&#x27;s not true. It <i>might</i> be true, but it&#x27;s a big risk. It&#x27;s a risk a wealthy family can very easily absorb. But if this child from this working class family takes on this risk using student debt, it might go poorly. They might very well be good at pure math but not be good enough to go into academia. Then they might be unsure what else they can do with that degree, unable to get their foot in the door at the kinds of employers where just a general proof-of-being-smart degree is enough. And now they have debt and uncertainty about what to do.<p>It also might work out great! But it&#x27;s a risk. And I know a number of people who feel they ended up on the wrong side of that risk.</div><br/></div></div></div></div></div></div><div id="38574298" class="c"><input type="checkbox" id="c-38574298" checked=""/><div class="controls bullet"><span class="by">Clubber</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38574051">parent</a><span>|</span><a href="#38574323">prev</a><span>|</span><a href="#38574546">next</a><span>|</span><label class="collapse" for="c-38574298">[-]</label><label class="expand" for="c-38574298">[1 more]</label></div><br/><div class="children"><div class="content">&gt;My point is that higher education isn&#x27;t job training and doesn&#x27;t pretend to be, and people who think it is or should are the ones that need education the most because they don&#x27;t seem to get it.<p>That was true 50 years ago, but employers turned it into job training. My father in law retired a well off businessman with a History degree from Yale he got in the 50s. You know what a History degree from Yale qualifies you for today? Teaching History and maybe writing some books. The degree didn&#x27;t change and Yale didn&#x27;t change.</div><br/></div></div></div></div><div id="38574546" class="c"><input type="checkbox" id="c-38574546" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573785">parent</a><span>|</span><a href="#38574051">prev</a><span>|</span><a href="#38574773">next</a><span>|</span><label class="collapse" for="c-38574546">[-]</label><label class="expand" for="c-38574546">[1 more]</label></div><br/><div class="children"><div class="content">No, I don&#x27;t think that&#x27;s it. I think it is simply that you have to put an awful lot of people through the explore part of the learning loop, to get a handful who will reach the exploit part of the loop, for any given subject.<p>99% of what we all learn in college is a waste of time <i>for us</i>. But we all have a unique 1% that is vital to who we become. Over time I expect that 1% to become 0.1%, then 0.01%, and for that vitality to become ever more concentrated in that sliver.</div><br/></div></div></div></div><div id="38574773" class="c"><input type="checkbox" id="c-38574773" checked=""/><div class="controls bullet"><span class="by">iamthepieman</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38573708">parent</a><span>|</span><a href="#38573785">prev</a><span>|</span><a href="#38572635">next</a><span>|</span><label class="collapse" for="c-38574773">[-]</label><label class="expand" for="c-38574773">[1 more]</label></div><br/><div class="children"><div class="content">Strongly disagree with this. If a class (at any level) is strictly teaching &quot;the subject&quot; then that is a very good issue to raise by a student or anyone else. Great teachers don&#x27;t just teach the subject though, they teach the skills necessary to engage with the subject and then apply them to said subject.<p>Unfortunately many programs are not designed this way and learning the appropriate skills is left as an exercise to the student usually in a sink or swim approach. So some students come out with the meta skills that a university education is touted for and others do not.<p>I do agree that &quot;I&#x27;ll never use this knowledge&quot; can be a miserable attitude to have or engage with - especially when it&#x27;s just a proxy for &quot;I&#x27;m not interested in learning, just in getting good grades&quot; but the idea itself is valid.</div><br/></div></div></div></div></div></div><div id="38572635" class="c"><input type="checkbox" id="c-38572635" checked=""/><div class="controls bullet"><span class="by">timeagain</span><span>|</span><a href="#38572570">parent</a><span>|</span><a href="#38572701">prev</a><span>|</span><a href="#38573361">next</a><span>|</span><label class="collapse" for="c-38572635">[-]</label><label class="expand" for="c-38572635">[2 more]</label></div><br/><div class="children"><div class="content">Yeah but at those internships you aren’t taught how to build quality software, just how to ship a SPA that connects to an API in 15 weeks (or you’re not hired).<p>It is a good peek into the professional software world though!</div><br/><div id="38575423" class="c"><input type="checkbox" id="c-38575423" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572570">root</a><span>|</span><a href="#38572635">parent</a><span>|</span><a href="#38573361">next</a><span>|</span><label class="collapse" for="c-38575423">[-]</label><label class="expand" for="c-38575423">[1 more]</label></div><br/><div class="children"><div class="content">Before you can write quality software you need to be able to write large software.  Most interns I see are learning how to work on non-trivial programs as this is their first chance to see something non-trivial. Then they get a &quot;real job&quot; and are shoved into extremely large programs.<p>Writing a thousand lines of bug free code isn&#x27;t that hard, so the need for QA practices won&#x27;t be apparent. Then you get the ten thousand line intern project and discover things are not always that easy.  Then we throw you into a multi-million line project and good luck: you need a lot of that QA stuff to make it work.</div><br/></div></div></div></div></div></div><div id="38573361" class="c"><input type="checkbox" id="c-38573361" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38572570">prev</a><span>|</span><a href="#38575574">next</a><span>|</span><label class="collapse" for="c-38573361">[-]</label><label class="expand" for="c-38573361">[6 more]</label></div><br/><div class="children"><div class="content">1. The premise that college teaches you how to build software in industry is a pretty wild claim.<p>2. Is this article from the 90s where we ship software on CDs or floppy disks? In today&#x27;s world where the concept of a &quot;release&quot; is often blurred by continuous delivery pipelines (and this is considered a good practice), having a quality insurance department manually assuring that no bugs are in that release seems downright archaic.</div><br/><div id="38575445" class="c"><input type="checkbox" id="c-38575445" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38573361">parent</a><span>|</span><a href="#38575799">next</a><span>|</span><label class="collapse" for="c-38575445">[-]</label><label class="expand" for="c-38575445">[3 more]</label></div><br/><div class="children"><div class="content">Not everyone is writing a webapp where you can roll out upgrades anytime CI passes, or a phone app that you can upgrade every week.  some of us work on code that will be shipped in a device that is not easy to upgrade.</div><br/><div id="38578274" class="c"><input type="checkbox" id="c-38578274" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38573361">root</a><span>|</span><a href="#38575445">parent</a><span>|</span><a href="#38575799">next</a><span>|</span><label class="collapse" for="c-38578274">[-]</label><label class="expand" for="c-38578274">[2 more]</label></div><br/><div class="children"><div class="content">Not all software that is frequently updated is a web app. Ask Tesla, Apple, Sonos, Garmin, ...<p>Anything connected to a network could be released frequently if people wanted to. Not everything is connected to a network though.</div><br/></div></div></div></div><div id="38575799" class="c"><input type="checkbox" id="c-38575799" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38573361">parent</a><span>|</span><a href="#38575445">prev</a><span>|</span><a href="#38575574">next</a><span>|</span><label class="collapse" for="c-38575799">[-]</label><label class="expand" for="c-38575799">[2 more]</label></div><br/><div class="children"><div class="content">And then you remember stories like that about Boeing. How their 737 Max has been tested by cheap contractor from India.<p>There are tons of software without continuous delivery.</div><br/><div id="38578249" class="c"><input type="checkbox" id="c-38578249" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38573361">root</a><span>|</span><a href="#38575799">parent</a><span>|</span><a href="#38575574">next</a><span>|</span><label class="collapse" for="c-38578249">[-]</label><label class="expand" for="c-38578249">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely, and industries like medical devices and aviation have extremely strict regulation and procedures regarding the testing of software. The article not mentioning any of those made me conclude that author is referring to regular software.</div><br/></div></div></div></div></div></div><div id="38575574" class="c"><input type="checkbox" id="c-38575574" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#38573361">prev</a><span>|</span><a href="#38573126">next</a><span>|</span><label class="collapse" for="c-38575574">[-]</label><label class="expand" for="c-38575574">[2 more]</label></div><br/><div class="children"><div class="content">From the article -- <i>At some point, I realized that I wasn&#x27;t using the right arguments either. Explaining that the software will be &#x27;more stable&#x27; or &#x27;make maintenance much easier&#x27; is not palpable for someone who doesn&#x27;t work in the codebase themselves. We need to speak about money. As developers, we need to speak about the cost of not doing QA. This is the language of business and managers in general.</i><p>The more general way of saying this is, &quot;If you need someone&#x27;s approval to do something, explain it as a good idea for <i>them</i>.&quot; Took me a bit to learn this in engineering, you would think &quot;but it will be correct!&quot; would be an unassailable argument but as the author notes, the person who has to sign off on it may not care if it is correct, even if you passionately <i>do</i> care. This works for everything at the job, not just fixing software correctly.</div><br/><div id="38576633" class="c"><input type="checkbox" id="c-38576633" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#38575574">parent</a><span>|</span><a href="#38573126">next</a><span>|</span><label class="collapse" for="c-38576633">[-]</label><label class="expand" for="c-38576633">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found the only true way out of this hellish situation is to work at a place mature enough for the leadership to already understand all this.<p>If you have to explain why quality matters, they&#x27;re at least as ignorant as you if not more. They deserve their fate. The upshot is you&#x27;ll probably also get paid way better and more quickly develop a better sense of how business is supposed to be done at a mature company.<p>Of course you also have to deliver on your promises that all the time you&#x27;re spending will improve things and isn&#x27;t just some amateur quixotic itch.</div><br/></div></div></div></div><div id="38573126" class="c"><input type="checkbox" id="c-38573126" checked=""/><div class="controls bullet"><span class="by">eftychis</span><span>|</span><a href="#38575574">prev</a><span>|</span><a href="#38572232">next</a><span>|</span><label class="collapse" for="c-38573126">[-]</label><label class="expand" for="c-38573126">[2 more]</label></div><br/><div class="children"><div class="content">As sibling comment `@wellpast` commented, but to extend it with my point of view.<p>We can roughly say we can have three out of: (high) quality, (low) time, (low) communication complexity, and (low) money. (time is a dependent here.)<p>People are trying to apply factory processes and structures to a team sport, an engineering discipline. You do not teach or build a basketball team by breaking down each attack phase into steps and checkmarks.<p>You try to minimize communication and make the team work as one. It is a team and individual building, not a process building exercise. You make a plan, and follow the Moltke&#x27;s the Elder conclusion:<p>&quot;no plan of operations extends with any certainty beyond the first contact with the main hostile force.&quot;<p>(Or paraphrased as you have heard: No plan survives contact with the enemy.)<p>All (types of) Engineers know this. But software engineering is &quot;special.&quot;
And it is not a &quot;move fast and break things issue.&quot;
That is part of all engineering or team playing too.<p>It is the type of business mentality, that because a plan did not go exactly as expected we need to add more process. Whatever that process may be. Because if &quot;I as a manager add a process, then the next failed plan, I am covered, and I will blame the individuals.&quot;<p>Process has a place to ensure things happen in a legal and moral framework. And minimize adverse circumstances -- e.g. we bet all the hedge fund money accidentally when running tests.<p>Process is used differently in most startups and corporations with not the team in mind.</div><br/><div id="38573206" class="c"><input type="checkbox" id="c-38573206" checked=""/><div class="controls bullet"><span class="by">swader999</span><span>|</span><a href="#38573126">parent</a><span>|</span><a href="#38572232">next</a><span>|</span><label class="collapse" for="c-38573206">[-]</label><label class="expand" for="c-38573206">[1 more]</label></div><br/><div class="children"><div class="content">The construction metaphor is a bad analogy. The compiler does the construction, dev teams do iterative design, ideally with frequent feedback and adjustment.<p>Do you ever yell at a traditional architect and ask them when it&#x27;s going to be done? It&#x27;s always when the client is happy or makes their mind up about it. A lot of dev is like this.</div><br/></div></div></div></div><div id="38572232" class="c"><input type="checkbox" id="c-38572232" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38573126">prev</a><span>|</span><a href="#38575781">next</a><span>|</span><label class="collapse" for="c-38572232">[-]</label><label class="expand" for="c-38572232">[19 more]</label></div><br/><div class="children"><div class="content">Is there any human activity where quality is an attribute successfully taught? In my experience, being able to produce something of quality is gained only through practice, practice, practice.</div><br/><div id="38572429" class="c"><input type="checkbox" id="c-38572429" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38572232">parent</a><span>|</span><a href="#38572366">next</a><span>|</span><label class="collapse" for="c-38572429">[-]</label><label class="expand" for="c-38572429">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any human activity where quality is an attribute successfully taught?<p>Every industrial practice.<p>On the other hand, the title just means that programming is not an industrial practice. What should be obvious to anybody that looked, but some people insist on not seeing it.</div><br/><div id="38572520" class="c"><input type="checkbox" id="c-38572520" checked=""/><div class="controls bullet"><span class="by">addicted</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572429">parent</a><span>|</span><a href="#38575012">next</a><span>|</span><label class="collapse" for="c-38572520">[-]</label><label class="expand" for="c-38572520">[9 more]</label></div><br/><div class="children"><div class="content">Yeah and you can see other disciplines like Aviation where there are so many incredible processes to ensure learning and constant improvement.</div><br/><div id="38572859" class="c"><input type="checkbox" id="c-38572859" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572520">parent</a><span>|</span><a href="#38572698">next</a><span>|</span><label class="collapse" for="c-38572859">[-]</label><label class="expand" for="c-38572859">[1 more]</label></div><br/><div class="children"><div class="content">For pilots, there are many filters to ensure people that failed to learn can&#x27;t take many responsibilities. They ensure the pilots study and train, but there isn&#x27;t any theory making sure the pilots learn and get the best safety practices. (In fact, if you are comparing with CS teaching, pilot teaching will give you a heart attack.)<p>For engineers, the situation is very similar to software. There are many tools for enforcing quality, but there&#x27;s no structure for teaching the engineers, and no, there isn&#x27;t a widely accepted theory for how to teach design quality either.<p>The one place where people are consistently taught how to build quality is on manufacturing.</div><br/></div></div><div id="38572698" class="c"><input type="checkbox" id="c-38572698" checked=""/><div class="controls bullet"><span class="by">piloto_ciego</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572520">parent</a><span>|</span><a href="#38572859">prev</a><span>|</span><a href="#38573737">next</a><span>|</span><label class="collapse" for="c-38572698">[-]</label><label class="expand" for="c-38572698">[1 more]</label></div><br/><div class="children"><div class="content">How I just said this, as I transition to being a dev&#x2F;engineer person… I find the lack frustrating at times.</div><br/></div></div><div id="38573737" class="c"><input type="checkbox" id="c-38573737" checked=""/><div class="controls bullet"><span class="by">Syntonicles</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572520">parent</a><span>|</span><a href="#38572698">prev</a><span>|</span><a href="#38575012">next</a><span>|</span><label class="collapse" for="c-38573737">[-]</label><label class="expand" for="c-38573737">[6 more]</label></div><br/><div class="children"><div class="content">Will you please elaborate?</div><br/><div id="38575161" class="c"><input type="checkbox" id="c-38575161" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38573737">parent</a><span>|</span><a href="#38575012">next</a><span>|</span><label class="collapse" for="c-38575161">[-]</label><label class="expand" for="c-38575161">[5 more]</label></div><br/><div class="children"><div class="content">Aviation in particular has a very strong culture around (government mandated) checklists and post-crash investigations. This has both pros and cons. The pros is that every airline learns from the mistakes made by every other airline and over time the system becomes really quite safe indeed. The cons are that it is quite expensive and time consuming.<p>Imagine if every software company was obliged by law to:<p>- Every single release has to have been signed off by someone who got their &quot;software release engineer&quot; certification at the software equivalent of the FAA.<p>- This engineer is required by law to not sign off unless every box on a 534 item checklist has been manually verified.<p>- Any time an unplanned downtime happens at any company, a government team comes in to investigate the root cause and add points nr 535 through 567 to the checklist to make sure it never happens again.<p>If such a system was mandated for software companies, most of the common bugs would very rapidly become a thing of the past. Development velocity would also fall through the floor though, and most startups would probably die overnight. Only companies that could support the overhead of such a heavyweight process would be viable, and the barrier to entry would massively increase.</div><br/><div id="38575601" class="c"><input type="checkbox" id="c-38575601" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38575161">parent</a><span>|</span><a href="#38576209">next</a><span>|</span><label class="collapse" for="c-38575601">[-]</label><label class="expand" for="c-38575601">[3 more]</label></div><br/><div class="children"><div class="content">I wish someone would create that 500 line checklist.  I&#x27;ve seem attempts, but they tend to be either not actionable (is the software high quality - meaningless), or of metrics that are just gamed (is test code coverage &gt; 80%?)</div><br/><div id="38578210" class="c"><input type="checkbox" id="c-38578210" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38575601">parent</a><span>|</span><a href="#38575819">next</a><span>|</span><label class="collapse" for="c-38578210">[-]</label><label class="expand" for="c-38578210">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or of metrics that are just gamed (is test code coverage &gt; 80%?)<p>The rebuttal to your implied Goodhart&#x27;s Law &lt;<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Goodhart%27s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Goodhart%27s_law</a>&gt; that was offered by my manager was &quot;tension metrics&quot; &lt;<a href="https:&#x2F;&#x2F;en.wikiversity.org&#x2F;wiki&#x2F;IT_Service_Management&#x2F;Continual_Service_Improvement#:~:text=tension%20metrics" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikiversity.org&#x2F;wiki&#x2F;IT_Service_Management&#x2F;Contin...</a>&gt;<p>If I understand his theory correctly, in your case there would be a competing metric to the &quot;test coverage&quot; one that said for any changeset, a test cannot itself change by more than 20% in the same changeset as non-test code. So you can change the code such that it still passes the existing tests, or you can change the test to adapt to new requirements, but you cannot rewrite the tests to match your newly changed code<p>I&#x27;m acutely aware this is a terrible example, the devil&#x27;s in the details, and (in my experience) each company&#x27;s metrics are designed to drive down their own organizational risk &lt;<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conway%27s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conway%27s_law</a>&gt;, combined with &quot;you&#x27;re always fighting the <i>last</i> war&quot; :-D</div><br/></div></div><div id="38575819" class="c"><input type="checkbox" id="c-38575819" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38575601">parent</a><span>|</span><a href="#38578210">prev</a><span>|</span><a href="#38576209">next</a><span>|</span><label class="collapse" for="c-38575819">[-]</label><label class="expand" for="c-38575819">[1 more]</label></div><br/><div class="children"><div class="content">Not quite what you&#x27;re asking for, but the <i>Joint Strike Fighter C++ Coding Standards</i> document is freely available. [0] It&#x27;s 141 pages.<p>It&#x27;s specific to the complex and unsafe C++ language though, rather than addressing broader software development methodology.<p>[0] [PDF] <a href="https:&#x2F;&#x2F;www.stroustrup.com&#x2F;JSF-AV-rules.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.stroustrup.com&#x2F;JSF-AV-rules.pdf</a></div><br/></div></div></div></div><div id="38576209" class="c"><input type="checkbox" id="c-38576209" checked=""/><div class="controls bullet"><span class="by">JumpinJack_Cash</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38575161">parent</a><span>|</span><a href="#38575601">prev</a><span>|</span><a href="#38575012">next</a><span>|</span><label class="collapse" for="c-38576209">[-]</label><label class="expand" for="c-38576209">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; Aviation in particular has a very strong culture around (government mandated) checklists and post-crash investigations<p>That&#x27;s the reason why aviation can only shine when it becomes a private means of transportation, and I don&#x27;t mean 70mm private jets but, 150k light helicopters.<p>When a critical mass is hit then accidents will become no more traumatic to the collective psyche than car accidents, the lighter the aircraft the better because it would seem exactly like  a car crash as opposed to leaving a huge burning hole into the ground</div><br/></div></div></div></div></div></div></div></div><div id="38575012" class="c"><input type="checkbox" id="c-38575012" checked=""/><div class="controls bullet"><span class="by">rockemsockem</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572429">parent</a><span>|</span><a href="#38572520">prev</a><span>|</span><a href="#38572366">next</a><span>|</span><label class="collapse" for="c-38575012">[-]</label><label class="expand" for="c-38575012">[1 more]</label></div><br/><div class="children"><div class="content">Citation needed. The key to the industrial revolution was trivializing the human work so as to take as many human errors out as possible and to systematize everything. I wouldn&#x27;t call that type of process &quot;teaching quality&quot;.</div><br/></div></div></div></div><div id="38572366" class="c"><input type="checkbox" id="c-38572366" checked=""/><div class="controls bullet"><span class="by">ordersofmag</span><span>|</span><a href="#38572232">parent</a><span>|</span><a href="#38572429">prev</a><span>|</span><a href="#38572683">next</a><span>|</span><label class="collapse" for="c-38572366">[-]</label><label class="expand" for="c-38572366">[1 more]</label></div><br/><div class="children"><div class="content">Good teaching largely consists of setting the learner up in situations where they can practice effectively. To pick just one example many people are taught to improve the quality of their writing. This largely consists of giving guidance on what writing to attempt and (more importantly) guidance how to reflect on the quality of the writing you&#x27;ve just done so you can improve.</div><br/></div></div><div id="38572683" class="c"><input type="checkbox" id="c-38572683" checked=""/><div class="controls bullet"><span class="by">piloto_ciego</span><span>|</span><a href="#38572232">parent</a><span>|</span><a href="#38572366">prev</a><span>|</span><a href="#38572541">next</a><span>|</span><label class="collapse" for="c-38572683">[-]</label><label class="expand" for="c-38572683">[4 more]</label></div><br/><div class="children"><div class="content">Absolutely.<p>I cannot fly professionally anymore due to health, but this is something we are taught in aviation and something I too find lacking from tech so far.<p>Like, you’re taught the standards as part of learning to fly, but as time goes on, you’re told to narrow your tolerance of what is acceptable.  So if you are learning how to do steep turns, for instance, the altitude standard is +- 100’. You’re taught, “that’s the minimum, you should be trying for 50’” and then 20’, then the absolute best performance would be where you do your turn, the needle doesn’t move, and as you roll out on a calm day you fly through your wake.  But the goal is “better, always better, what can I do better?”  And flying is not graded on the overall performance, if you don’t do satisfactory everywhere you fail.  Culturally satisfactory, isn’t, it’s the starting point.<p>That encourages a much more collaborative model I feel like. I’ve only worked one or two flying jobs that were not collaborative.  In the outside world it sometimes feels the opposite.  In flying, you truly want everyone to succeed and do well, and the company does.  Even the guys I hated that I flew with, I didn’t want them to fail.  If they failed, I was partially responsible for that.<p>It wasn’t always perfect, and I worked with some legendary assholes while I was flying, but truly, they supported me and I supported them, and if I screwed up (or they screwed up) the culture required that we found a way to minimize the future potential screwups.<p>You’re actually trained on what quality means in a wide variety of contexts too, and flight operations quality assurance (FOQA) is a big part of many airlines.  In smaller bush operations where I worked, it is significantly more informal, but we truly had a “no fault” culture in nearly all the places I worked.  It’s not perfect, but that’s the point, “ok how can we make this better?”<p>If someone had an idea for how to do something better, there may have been friction, but that was rare if it actually was better, and as soon as you could show how adoption was fast even at the less standardized operations I worked at.<p>Not saying it’s all unicorns and rainbows, but I feel like quality, and decision making, and “doing the right thing” were an integral part of the culture of aviation.  “The weather is too bad and I cannot do this safely” grounds the flight, you don’t blast off into the shit (at reputable operators) to get the job done anymore (it’s not 1995), and it feels like this new industry is the opposite.<p>The entire concept of a “minimum viable product” is somewhat illustrative of the problem.  It shouldn’t be the “minimum viable” it should be the “minimum quality product we’re willing to accept as a starting point.”  But that doesn’t roll off the tongue in the same way.<p>We shouldn’t be striving for anything that’s the “minimum.”  The minimum is only the beginning.</div><br/><div id="38572875" class="c"><input type="checkbox" id="c-38572875" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572683">parent</a><span>|</span><a href="#38572541">next</a><span>|</span><label class="collapse" for="c-38572875">[-]</label><label class="expand" for="c-38572875">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; But the goal is “better, always better, what can I do better?”</i><p>Is that not the case in software? The incentive to improve may not be quite as strong as in aviation (crashing software isn&#x27;t quite the same as crashing airplanes), but it is still pretty strong. Life is <i>very</i> miserable in software when quality isn&#x27;t present.</div><br/><div id="38573360" class="c"><input type="checkbox" id="c-38573360" checked=""/><div class="controls bullet"><span class="by">zerkten</span><span>|</span><a href="#38572232">root</a><span>|</span><a href="#38572875">parent</a><span>|</span><a href="#38572541">next</a><span>|</span><label class="collapse" for="c-38573360">[-]</label><label class="expand" for="c-38573360">[2 more]</label></div><br/><div class="children"><div class="content">What happens when you work under a group of people who are satisfied at stage one of project X? You know you can iterate to get two stages further, but they want you to work on projects Y and Z. This is a very common situation where you, or even the whole development team has very little control.<p>Of course, management should be supportive of quality improvements, but their reality is either one where they are under genuine pressure to deliver projects X and Y to stage of quality through to not understanding or caring about quality.<p>My own experience is that individual programmers have vastly different ideas of quality is based on their experience and education. You can be struggling to get a team to improve and then you hire a somewhat normal individual with a very different background who makes a sizeable impact on quality and the culture of this in the team. I&#x27;m thinking specifically of someone who joined from aerospace, but I&#x27;ve seen it with finance backgrounds. I think the background matters less than the perspective and ability to hold people accountable (including yourself.)</div><br/></div></div></div></div></div></div><div id="38572524" class="c"><input type="checkbox" id="c-38572524" checked=""/><div class="controls bullet"><span class="by">randomdrake</span><span>|</span><a href="#38572232">parent</a><span>|</span><a href="#38572541">prev</a><span>|</span><a href="#38575781">next</a><span>|</span><label class="collapse" for="c-38572524">[-]</label><label class="expand" for="c-38572524">[1 more]</label></div><br/><div class="children"><div class="content">The arts. The further and further you go in instruction, the more it becomes about the little differences and quality. Practice always helps, but quality definitely taught and learned by many as well.</div><br/></div></div></div></div><div id="38575781" class="c"><input type="checkbox" id="c-38575781" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#38572232">prev</a><span>|</span><a href="#38572235">next</a><span>|</span><label class="collapse" for="c-38575781">[-]</label><label class="expand" for="c-38575781">[1 more]</label></div><br/><div class="children"><div class="content">Like with all things quality is proven through practice and measures, which means quality can only be guessed at before a product is built.<p>Like in all things here is how you do it:<p>1. Build a first version that works and accomplishes all initial business requirements.<p>2. Build test automation or inspection criteria.<p>3. Reflect upon what you built and watch how it’s actually used in production.<p>4. Measure it. Measure performance. Count user steps. Count development steps. Determine real cost of ownership.<p>5. Take stuff out without breaking business requirements.<p>6. Repeat steps 2-6.<p>That is how you build quality whether it’s software, manufacturing, labor, management, whatever.<p>In my own software I devised a new model to solve for this that I call <i>Single Source of Truth</i>. It’s like DRY but hyper aggressive and based upon empathy instead of micro-artifacts.</div><br/></div></div><div id="38572235" class="c"><input type="checkbox" id="c-38572235" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38575781">prev</a><span>|</span><a href="#38573294">next</a><span>|</span><label class="collapse" for="c-38572235">[-]</label><label class="expand" for="c-38572235">[17 more]</label></div><br/><div class="children"><div class="content">you cannot be taught what nobody knows how to do<p>or maybe, them who know how to do this are just unable to spread this knowledge... something about how they think their private secret codes are the source of their wealth<p>when in fact, it&#x27;s merely the scheme by which they mantain an advantageous capacity to extract energy from them seeking to learn how to build quality software</div><br/><div id="38572313" class="c"><input type="checkbox" id="c-38572313" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572235">parent</a><span>|</span><a href="#38575203">next</a><span>|</span><label class="collapse" for="c-38572313">[-]</label><label class="expand" for="c-38572313">[15 more]</label></div><br/><div class="children"><div class="content">This is what I came here for.<p>There&#x27;s an obvious comprehensibility complexity to code to anyone who has spent almost any time what so ever trying to make something happen in software.  However, we&#x27;ve got zero academics or theory around it.<p>Just &#x27;best practices&#x27; (ie a thing other people are known to do so if things go wrong we can deflect blame).<p>And code smells (ie the code makes your tummy feel bad.  yay objective measures).<p>And dogma (ie &quot;only ONE return point per function&quot; or &quot;TDD or criminal neglect charges&quot;).<p>Sure, please do <i>something</i> for QA because it&#x27;ll be better than nothing.  But we&#x27;re probably a few decades of waiting for actual theoretical underpinnings that will actually allow us to make objective tradeoffs and measurements.</div><br/><div id="38572422" class="c"><input type="checkbox" id="c-38572422" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572313">parent</a><span>|</span><a href="#38575923">next</a><span>|</span><label class="collapse" for="c-38572422">[-]</label><label class="expand" for="c-38572422">[7 more]</label></div><br/><div class="children"><div class="content">There is plenty of academics on it, as real engineers, those that studied Software Engineering or Informatics Engineering, instead of fake engineering titles from bootcamps, should be aware.<p>Usually available as optional lectures during the degree, or later as Msc and PhD subjects.</div><br/><div id="38572773" class="c"><input type="checkbox" id="c-38572773" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572422">parent</a><span>|</span><a href="#38572637">next</a><span>|</span><label class="collapse" for="c-38572773">[-]</label><label class="expand" for="c-38572773">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m all ears.<p>Although, so far I&#x27;ve only bumped into cyclomatic complexity (with some studies showing that it has worse predicting power than lines of code) and lines of code.</div><br/><div id="38573076" class="c"><input type="checkbox" id="c-38573076" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572773">parent</a><span>|</span><a href="#38572637">next</a><span>|</span><label class="collapse" for="c-38573076">[-]</label><label class="expand" for="c-38573076">[4 more]</label></div><br/><div class="children"><div class="content">Here is one, <a href="https:&#x2F;&#x2F;swc.rwth-aachen.de&#x2F;teaching&#x2F;courses&#x2F;2022-summer-semester&#x2F;software-quality-assurance&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;swc.rwth-aachen.de&#x2F;teaching&#x2F;courses&#x2F;2022-summer-seme...</a></div><br/><div id="38573332" class="c"><input type="checkbox" id="c-38573332" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38573076">parent</a><span>|</span><a href="#38572637">next</a><span>|</span><label class="collapse" for="c-38573332">[-]</label><label class="expand" for="c-38573332">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know.  I was hoping for something like:  &quot;We know inheritance is bad because when we convert the typical example over to this special graph it forms a non-compact metric space&quot;  Or something like that.<p>Even though I find cyclomatic complexity uncompelling, it at the very least can slurp up code and return a value.  Nicely objective, just not particularly useful or insightful to whether or not things are easy to understand.<p>The provided link looks suspiciously like they&#x27;re going to talk about the difference between system, integration, and unit tests.  The importance of bug trackers.  And linters &#x2F; theorem provers maybe.<p>I don&#x27;t think these are bad things, but it&#x27;s kind of a statistical approach to software quality.  The software is bad because the bug chart looks bad.  Okay, maybe, but maybe you just have really inexperienced people working on the project.  Technically, the business doesn&#x27;t need to know the difference, but I would like to.</div><br/><div id="38573676" class="c"><input type="checkbox" id="c-38573676" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38573332">parent</a><span>|</span><a href="#38572637">next</a><span>|</span><label class="collapse" for="c-38573676">[-]</label><label class="expand" for="c-38573676">[2 more]</label></div><br/><div class="children"><div class="content">If you want numbers and research like content, that is available as well.<p>&quot;Measuring Complexity of Object Oriented Programs&quot;<p><a href="https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-540-69848-7_53" rel="nofollow noreferrer">https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-540-69848-7_...</a></div><br/><div id="38573952" class="c"><input type="checkbox" id="c-38573952" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38573676">parent</a><span>|</span><a href="#38572637">next</a><span>|</span><label class="collapse" for="c-38573952">[-]</label><label class="expand" for="c-38573952">[1 more]</label></div><br/><div class="children"><div class="content">This is much more interesting.<p>I don&#x27;t suppose you know where I can get their list of references without hitting a paywall?  Specifically [16] and [24].<p>EDIT:  [For anyone following along]<p>The linked paper is Measuring Complexity of Object Oriented Programs.  Although, the paper isn&#x27;t free.  They reference several other papers which they assert talk about OO complexity metrics as well as procedural cognitive complexity, but unfortunately the references aren&#x27;t included in the preview.<p>Apparently, there&#x27;s also a list of Weyuker&#x27;s 9 Properties which look easier to find information on.  But these look like meta properties about what properties a complexity measurement system would need to have [interesting, but they don&#x27;t really seem to comment on whether or not such measurement is even possible].<p>It looks like a lot of this research is coming out of Turkey, and has been maybe floating around since the early 2000s.<p>EDIT EDIT:  References are included at the bottom of the preview.<p>EDIT EDIT EDIT:  Kind of interesting, but I&#x27;m not sure this is going to yield anything different than cyclomatic complexity.  Like, is this still an area of active research or did it all go by the wayside back in the early 2000s when it showed up?  The fact that all the papers are showing up from Turkey makes me concerned it was a momentary fad and the reason it didn&#x27;t spread to other countries was because it doesn&#x27;t accomplish anything.  Although, I suppose it could be a best kept secret of Turkey.<p>Renamed programs are defined to have identical complexity, which is pretty intuitively untrue, so I&#x27;ve got my concerns.<p>EDIT ^ 4:  Doesn&#x27;t seem to be able to take data complexity into account.  So if you&#x27;re dividing by input, some inputs are going to cause division by zero, etc.  You might be able to jury rig it to handle the complexity of exceptions, but it looks like it can mostly handle static code.  I&#x27;m not sure if it&#x27;s really going to handle dynamically calling code that throws very well.  I also don&#x27;t think it handles complexity from mutable shared references.<p>Nice try, but unless there&#x27;s a bunch of compelling research that no actually this is useful, I&#x27;m not sure this is going to cut it.  And at the moment the only research I&#x27;m finding is more or less just defining functions that qualify as a cognitive measure under the Weyuker principles.  I&#x27;m not seeing anyone even pointing it at existing code to see if it matches intuition or experience.  Happy to be found wrong here, though.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38572637" class="c"><input type="checkbox" id="c-38572637" checked=""/><div class="controls bullet"><span class="by">lainga</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572422">parent</a><span>|</span><a href="#38572773">prev</a><span>|</span><a href="#38575923">next</a><span>|</span><label class="collapse" for="c-38572637">[-]</label><label class="expand" for="c-38572637">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I&#x27;ve run into a couple. Here&#x27;s a chart of Defects per KLOC. Great.</div><br/></div></div></div></div><div id="38575923" class="c"><input type="checkbox" id="c-38575923" checked=""/><div class="controls bullet"><span class="by">aschearer</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572313">parent</a><span>|</span><a href="#38572422">prev</a><span>|</span><a href="#38572450">next</a><span>|</span><label class="collapse" for="c-38575923">[-]</label><label class="expand" for="c-38575923">[1 more]</label></div><br/><div class="children"><div class="content">I found these thought provoking:<p>The Power of 10: Rules for Developing Safety-Critical Code[1]<p>Assessing the Relationship between Software Assertions and 
Code Quality: An Empirical Investigation[2]<p>Cyclomatic Complexity and Basis Path Testing Study[3]<p>[1]: <a href="https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~imarkov&#x2F;10rules.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~imarkov&#x2F;10rules.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;02&#x2F;tr-2006-54.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a><p>[3]: <a href="https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;api&#x2F;citations&#x2F;20205011566&#x2F;downloads&#x2F;20205011566.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;api&#x2F;citations&#x2F;20205011566&#x2F;downloads&#x2F;20...</a></div><br/></div></div><div id="38572450" class="c"><input type="checkbox" id="c-38572450" checked=""/><div class="controls bullet"><span class="by">RandyRanderson</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572313">parent</a><span>|</span><a href="#38575923">prev</a><span>|</span><a href="#38572404">next</a><span>|</span><label class="collapse" for="c-38572450">[-]</label><label class="expand" for="c-38572450">[2 more]</label></div><br/><div class="children"><div class="content">I wish more ppl felt this way. What a compliment it is to oneself when I hear ppl saying &quot;write clean code&quot; as if they know its address and had dinner with clean code just last night.<p>I was thinking there should be some metric around d(code)&#x2F;dt . That is, as the software is used, &#x27;bad&#x27; code will tend to change a lot but add no functionality. &#x27;Good&#x27; code will change little even when it&#x27;s used mode.</div><br/><div id="38572957" class="c"><input type="checkbox" id="c-38572957" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572450">parent</a><span>|</span><a href="#38572404">next</a><span>|</span><label class="collapse" for="c-38572957">[-]</label><label class="expand" for="c-38572957">[1 more]</label></div><br/><div class="children"><div class="content">d(code)&#x2F;dt isn&#x27;t a very good metric though. Think of the Linux kernel. Drivers get some of the least maintenance work and are broadly the lowest quality part of the kernel. arch&#x2F; is busier than drivers&#x2F;, but anything you find in the parts being touched are also significantly higher quality.</div><br/></div></div></div></div><div id="38572404" class="c"><input type="checkbox" id="c-38572404" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572313">parent</a><span>|</span><a href="#38572450">prev</a><span>|</span><a href="#38575834">next</a><span>|</span><label class="collapse" for="c-38572404">[-]</label><label class="expand" for="c-38572404">[3 more]</label></div><br/><div class="children"><div class="content">You forgot the dogma of only one entry point per function, back from the day when you could do both.<p>(One exit point is a pet peeve of mine since it often makes the code a lot harder to read and think about vs exit asap)</div><br/><div id="38572485" class="c"><input type="checkbox" id="c-38572485" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572404">parent</a><span>|</span><a href="#38575834">next</a><span>|</span><label class="collapse" for="c-38572485">[-]</label><label class="expand" for="c-38572485">[2 more]</label></div><br/><div class="children"><div class="content">You may still not buy into it, but note that single exit was established for languages like C where an early exit can make it difficult to ensure that all resources are freed. It isn&#x27;t meant for every language – and, indeed, languages that are not bound by such constraints usually promote multiple exit because of the reasons you bring up.</div><br/><div id="38574040" class="c"><input type="checkbox" id="c-38574040" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572485">parent</a><span>|</span><a href="#38575834">next</a><span>|</span><label class="collapse" for="c-38574040">[-]</label><label class="expand" for="c-38574040">[1 more]</label></div><br/><div class="children"><div class="content">And even that is wrong, single entrance&#x2F;exit was originally because you had subroutines designed to be goto&#x27;d into at different points for
different behavior and would goto different points outside the subroutine as the exit.<p>There are pretty much no languages left today where it&#x27;s even possible to violate this principle without really trying, it&#x27;s not about having single a return it&#x27;s about all the functions starting at the top and  return statements always taking you back to the same place in the code.</div><br/></div></div></div></div></div></div><div id="38575834" class="c"><input type="checkbox" id="c-38575834" checked=""/><div class="controls bullet"><span class="by">satisfice</span><span>|</span><a href="#38572235">root</a><span>|</span><a href="#38572313">parent</a><span>|</span><a href="#38572404">prev</a><span>|</span><a href="#38575203">next</a><span>|</span><label class="collapse" for="c-38575834">[-]</label><label class="expand" for="c-38575834">[1 more]</label></div><br/><div class="children"><div class="content">The scientific groundwork for excellent testing, anyway, has already been done-- but not in the realm of computer science. This is because computer scientists are singularly ill equipped to study what computer scientists do. In other words, if you want to understand testing, you have to watch testers at work, and that is social science research. CS does not take social science seriously.<p>An example of such research done well can be found in Exploring Science, by Klahr. The author and his colleagues look very closely at how people interact with a system and experiment with it, leading to wonderful insights about testing processes. I&#x27;ve incorporated those lessons into my classes on software testing, for instance.</div><br/></div></div></div></div><div id="38575203" class="c"><input type="checkbox" id="c-38575203" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#38572235">parent</a><span>|</span><a href="#38572313">prev</a><span>|</span><a href="#38573294">next</a><span>|</span><label class="collapse" for="c-38575203">[-]</label><label class="expand" for="c-38575203">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you cannot be taught what nobody knows how to do<p>It&#x27;s worse than that. No one can agree what &quot;quality&quot; means.<p>Mostly, the word is used as a weapon.<p>The pointy end of the weapon is what management pokes you with whenever anything unexpected happens. Typically they do this instead of making sure that problems do not happen (a.k.a. &quot;management&quot;).<p>The weapon&#x27;s handle is sometimes flourished by process gatekeepers who insist on slowing everything down and asserting their self-worth. This is not good for throughput, anyone else&#x27;s mood, or eventually even for the gatekeepers.<p>People usually refuse to talk about quality in terms of actual business metrics because if anything unexpected happens that&#x27;s not covered by the metrics, there will be fault-finding. And the fingers pointed for wrong metrics are typically pointed at middle management.</div><br/></div></div></div></div><div id="38573294" class="c"><input type="checkbox" id="c-38573294" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38572235">prev</a><span>|</span><a href="#38575709">next</a><span>|</span><label class="collapse" for="c-38573294">[-]</label><label class="expand" for="c-38573294">[4 more]</label></div><br/><div class="children"><div class="content">I wonder how much of the lack of QA is rational.  That is to say, for most projects does shipping with lots of somewhat hard-to-find bugs actually hurt the bottom line?<p>For some classes of bugs it can (e.g. if the software is so bad as to open you to a class-action lawsuit; in b2b software bugs that put you in breech of contract), but for many classes of consumer software, it&#x27;s not clear to me that shipping software that works better is rewarded.  Picking not-too-buggy software ahead of time is hard, people are slow to switch (even when the people encountering the bugs are the people selecting the software, which is often not the case), and people are good at subconsciously avoiding triggering bugs.</div><br/><div id="38573398" class="c"><input type="checkbox" id="c-38573398" checked=""/><div class="controls bullet"><span class="by">nikhil896</span><span>|</span><a href="#38573294">parent</a><span>|</span><a href="#38575709">next</a><span>|</span><label class="collapse" for="c-38573398">[-]</label><label class="expand" for="c-38573398">[3 more]</label></div><br/><div class="children"><div class="content">It starts mattering more for consumer software when you reach mass scale. Somewhat hard-to-find bugs at the scale of hundreds of millions of users (like a social media company), turn into bugs faced by hundreds of thousands of users.<p>But at that scale (in my experience), QA is up front and center and is typically a core pillar of engineering orgs.</div><br/><div id="38575701" class="c"><input type="checkbox" id="c-38575701" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38573294">root</a><span>|</span><a href="#38573398">parent</a><span>|</span><a href="#38575709">next</a><span>|</span><label class="collapse" for="c-38575701">[-]</label><label class="expand" for="c-38575701">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It starts mattering more for consumer software when you reach mass scale. Somewhat hard-to-find bugs at the scale of hundreds of millions of users (like a social media company), turn into bugs faced by hundreds of thousands of users.<p>From a cynical point of view, if those hundreds of thousands of users will use your product despite the bugs, does it matter?</div><br/><div id="38578267" class="c"><input type="checkbox" id="c-38578267" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#38573294">root</a><span>|</span><a href="#38575701">parent</a><span>|</span><a href="#38575709">next</a><span>|</span><label class="collapse" for="c-38578267">[-]</label><label class="expand" for="c-38578267">[1 more]</label></div><br/><div class="children"><div class="content">People are only as loyal as their opportunities; if the competition is mostly the same as your product but has either fewer bugs or bugs in a less painful flow, buh-bye<p>I&#x27;m super cognizant that the cited example of &quot;social media company&quot; is its own special ball of wax, due to the network effect, and I wish to holy hell I knew how to fix <i>that</i> bug :-)</div><br/></div></div></div></div></div></div></div></div><div id="38575709" class="c"><input type="checkbox" id="c-38575709" checked=""/><div class="controls bullet"><span class="by">Communitivity</span><span>|</span><a href="#38573294">prev</a><span>|</span><a href="#38576738">next</a><span>|</span><label class="collapse" for="c-38575709">[-]</label><label class="expand" for="c-38575709">[2 more]</label></div><br/><div class="children"><div class="content">There is a corollary. You need to learn how to build quality software. You also need to know what level of quality vs completeness tradeoff you need to make.<p>Imagine I have a deadline of Jan 15th to demo features x, y, and z to senior leadership (who then will make funding decisions that could impact my project), and I get to Jan 15th with x, y, and not z - or worse, none of them working fully. But the code quality is high, there are no TODOs hanging around, no extra development focused logging, no duplication of code, no leaky abstractions.<p>That is a 100% fail in leadership&#x27;s eyes, unless you have a really good story on why z didn&#x27;t get shipped (and code quality is NOT that).<p>All those things I listed will have to be addressed at some point, and the longer they go without being addressed the harder they will be to address. But if you need to do that to meet deadlines, then you do it.<p>Of course, if you are in a place where leadership allows you to work from a backlog and demonstrations and features to demo are scheduled not arbitrarily based on leadership&#x27;s schedule&#x2F;interest, but on the features that are newly shipped since the last demo, then you are in luck.<p>At the end of the day the important thing to remember is that you are not being paid to build software. You are being paid to provide a solution to your customer&#x27;s problem. Other than CTOs and some forward thinking leaders, they don&#x27;t care about the software. They care about whether the problem is solved, did it cost me more or less than expected in labor and materiel, and is it compliant with necessary laws&#x2F;regulations.</div><br/><div id="38575739" class="c"><input type="checkbox" id="c-38575739" checked=""/><div class="controls bullet"><span class="by">beebmam</span><span>|</span><a href="#38575709">parent</a><span>|</span><a href="#38576738">next</a><span>|</span><label class="collapse" for="c-38575739">[-]</label><label class="expand" for="c-38575739">[1 more]</label></div><br/><div class="children"><div class="content">I think that &quot;quality software&quot; is not well defined, so until it&#x27;s well defined, we&#x27;re not talking about the same thing.</div><br/></div></div></div></div><div id="38576738" class="c"><input type="checkbox" id="c-38576738" checked=""/><div class="controls bullet"><span class="by">readyplayernull</span><span>|</span><a href="#38575709">prev</a><span>|</span><a href="#38575737">next</a><span>|</span><label class="collapse" for="c-38576738">[-]</label><label class="expand" for="c-38576738">[1 more]</label></div><br/><div class="children"><div class="content">I work in QA automation and also develop my own projects. There is more to quality assurance than QA. When you spend days creating something and then throw it away to make it better, that IS quality assurance! That deleted code, that deleted architecture, that deleted design is the cost of quality. A totally unappreciated aspect of QA.</div><br/></div></div><div id="38575737" class="c"><input type="checkbox" id="c-38575737" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#38576738">prev</a><span>|</span><a href="#38574883">next</a><span>|</span><label class="collapse" for="c-38575737">[-]</label><label class="expand" for="c-38575737">[2 more]</label></div><br/><div class="children"><div class="content">I completely understand university teaching algorithms over real dev stuff.<p>Algorithms are hard, and take serious work, they&#x27;re basically math.  University seems like the idea place to learn A* search or quicksort, I can&#x27;t imagine figuring that out without a lot of effort and time spent just focusing on that.<p>What I don&#x27;t understand is why programmers themselves focus on algorithms over stuff like &quot;Vague heuristics to guess if this JS framework you tear your hair out in a month&quot;.<p>That kind of this isn&#x27;t really hard and doesn&#x27;t require any heavy discipline and focus, it&#x27;s just something you pick up when you&#x27;ve tried a few different systems and notice stuff like &quot;Oh look, that linter caught this bug for me&quot; and &quot;Hey look, there&#x27;s not much autoformat support for Mako, maybe I&#x27;ll just use Jinja2 like everyone else&quot;.<p>Instead they tell us to do stuff like code katas and endlessly polish our coding and algorithm skills rather than practice working on big stuff and managing complexity.<p>Maybe it&#x27;s because algorithms are the hard part, and being really good at that is needed to work on the real cutting edge stuff.</div><br/><div id="38577010" class="c"><input type="checkbox" id="c-38577010" checked=""/><div class="controls bullet"><span class="by">ivix</span><span>|</span><a href="#38575737">parent</a><span>|</span><a href="#38574883">next</a><span>|</span><label class="collapse" for="c-38577010">[-]</label><label class="expand" for="c-38577010">[1 more]</label></div><br/><div class="children"><div class="content">I suspect as with most things in education, they focus on small self contained problems because it&#x27;s easier to teach and easier to grade.  These toy problems end up being all students know and therefore are what employers select on.</div><br/></div></div></div></div><div id="38574883" class="c"><input type="checkbox" id="c-38574883" checked=""/><div class="controls bullet"><span class="by">darth_aardvark</span><span>|</span><a href="#38575737">prev</a><span>|</span><a href="#38579764">next</a><span>|</span><label class="collapse" for="c-38574883">[-]</label><label class="expand" for="c-38574883">[3 more]</label></div><br/><div class="children"><div class="content">Unrelated to the article, I could immediately identify the image used as definitely AI-generated. But I can&#x27;t identify any reason <i>why</i>. It&#x27;s a normal picture of a stone brick wall. Yet I&#x27;m 100% sure it&#x27;s AI.<p>No shame to the author for their choice; replacing stock images with generated ones is a great use case. It&#x27;s spooky to me that we&#x27;ve been so quickly trained to identify this subconsciously.</div><br/><div id="38575307" class="c"><input type="checkbox" id="c-38575307" checked=""/><div class="controls bullet"><span class="by">realprimoh</span><span>|</span><a href="#38574883">parent</a><span>|</span><a href="#38575040">next</a><span>|</span><label class="collapse" for="c-38575307">[-]</label><label class="expand" for="c-38575307">[1 more]</label></div><br/><div class="children"><div class="content">AI-generated images have an unnatural &quot;smoothness&quot; to them whereas reality is more imperfect. At least that&#x27;s my hypothesis.</div><br/></div></div><div id="38575040" class="c"><input type="checkbox" id="c-38575040" checked=""/><div class="controls bullet"><span class="by">dvfjsdhgfv</span><span>|</span><a href="#38574883">parent</a><span>|</span><a href="#38575307">prev</a><span>|</span><a href="#38579764">next</a><span>|</span><label class="collapse" for="c-38575040">[-]</label><label class="expand" for="c-38575040">[1 more]</label></div><br/><div class="children"><div class="content">True. I think in this case it&#x27;s because of the texture of the bricks. It looks like they were wrapped in cloth or something. This seems a common texture in many AI-generated images.</div><br/></div></div></div></div><div id="38579764" class="c"><input type="checkbox" id="c-38579764" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#38574883">prev</a><span>|</span><a href="#38575401">next</a><span>|</span><label class="collapse" for="c-38579764">[-]</label><label class="expand" for="c-38579764">[1 more]</label></div><br/><div class="children"><div class="content">This is a bit more abstract than the article but in my experience the best software comes from people with taste, rigour, reasoning, a good vocabulary, strong principles, and the ability to write clear and concise English (or whatever human language is used in their team.)<p>When you truly understand the software you are writing then, and only then, can you communicate it logically in code for the computer to execute and, much more importantly, code for a person to read.  Well written and well understood code means it’s very obvious what you are doing.  Later, when the code has a bug or needs to be rewritten, then it will at least be clear what you were trying to do so that it can be fixed or extended in some way.<p>So then the question is how do we train people to have these skills?  In school, science experiments are a good way to teach logical reasoning and communication — here is what I thought would happen, here is what I did, here is what happened, and here is what it means.  Math teaches you how to reason abstractly and, again, prove your point with logic.  It’s a slightly different beast in that it’s harder for a math experiment to go wrong.  It’s also harder to come up with and overcome novel scenarios in the lab with math, so in all it complements science well.  And of course reading and writing English build your ability to express your thoughts with words and sentences.  Many other high school subjects combine these in various measures — history for example is data gathering, fuzzy logical deduction, and reasoning in written language.<p>The bottom line is that quality software starts by working with well educated people and conversely all the most abhorrent heaps of over coupled illegible nonsense I’ve seen has come from people who, to be blunt, just ain’t that smart or well rounded, intellectually.<p>It’s a principle I carry over to hiring: smart and well educated wins out over pure-smarts.</div><br/></div></div><div id="38575401" class="c"><input type="checkbox" id="c-38575401" checked=""/><div class="controls bullet"><span class="by">tanepiper</span><span>|</span><a href="#38579764">prev</a><span>|</span><a href="#38574590">next</a><span>|</span><label class="collapse" for="c-38575401">[-]</label><label class="expand" for="c-38575401">[4 more]</label></div><br/><div class="children"><div class="content">Maybe a spicy take (FWIW I&#x27;m also self-taught)<p>Software engineering quality isn&#x27;t something you teach, it&#x27;s something you learn.</div><br/><div id="38575533" class="c"><input type="checkbox" id="c-38575533" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#38575401">parent</a><span>|</span><a href="#38575815">next</a><span>|</span><label class="collapse" for="c-38575533">[-]</label><label class="expand" for="c-38575533">[1 more]</label></div><br/><div class="children"><div class="content">Usually, the hard way.<p>I&#x27;ve worked on so many poor-quality projects. I&#x27;ve had so many heated conversations trying to teach people that there are no such things as rules in SE and it&#x27;s important to _know when to bend&#x2F;break the rules_. Rigorously following rules doesn&#x27;t mean high quality, automatically. Some things simply don&#x27;t exist in the little world you&#x27;re building.<p>Translations, for example, usually live outside of any layered cake you are making. If you write a string that will be shown to a user deep down in your code, it needs to be marked for translation and translated. If you try to layer it ... gods help anyone who comes along to change that switch statement.<p>There are lots of other cross-cutting concerns that people try to put into a box because of &quot;rules&quot; that don&#x27;t belong in a box. That&#x27;s usually where your quality starts to plummet.</div><br/></div></div><div id="38575815" class="c"><input type="checkbox" id="c-38575815" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38575401">parent</a><span>|</span><a href="#38575533">prev</a><span>|</span><a href="#38575827">next</a><span>|</span><label class="collapse" for="c-38575815">[-]</label><label class="expand" for="c-38575815">[1 more]</label></div><br/><div class="children"><div class="content">I think developing high quality software is more art than engineering.<p>The most useful pieces of code typically have to deal with some of the most ridiculous constraints. Determining a way to integrate these such that the UX doesn&#x27;t suffer is the real talent.<p>The only pedagogical model that makes sense for me anymore is the apprenticeship. You can definitely learn it on your own, but it&#x27;s a hell of a lot faster to observe someone with 20k+ hours XP and skip some of the initial lava pits. Perhaps some of those lessons are important, but learning and knowledge are not linear things.</div><br/></div></div><div id="38575827" class="c"><input type="checkbox" id="c-38575827" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38575401">parent</a><span>|</span><a href="#38575815">prev</a><span>|</span><a href="#38574590">next</a><span>|</span><label class="collapse" for="c-38575827">[-]</label><label class="expand" for="c-38575827">[1 more]</label></div><br/><div class="children"><div class="content">It is the same as you learn about backup and restore process. And then you learn hard way that you should have been testing your backups, if they can be used to restore data.</div><br/></div></div></div></div><div id="38574590" class="c"><input type="checkbox" id="c-38574590" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38575401">prev</a><span>|</span><a href="#38574803">next</a><span>|</span><label class="collapse" for="c-38574590">[-]</label><label class="expand" for="c-38574590">[4 more]</label></div><br/><div class="children"><div class="content">I have been, at various points in time, taught how to build quality software. I think the large majority of people I work with have been taught about this as well. So I&#x27;m not sure who the &quot;you are never taught ...&quot; is referring to here. Should it perhaps instead be &quot;I was never taught ...&quot;?</div><br/><div id="38575567" class="c"><input type="checkbox" id="c-38575567" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38574590">parent</a><span>|</span><a href="#38574803">next</a><span>|</span><label class="collapse" for="c-38575567">[-]</label><label class="expand" for="c-38575567">[3 more]</label></div><br/><div class="children"><div class="content">Were you really taught that, or were you taught cargo-cult things that don&#x27;t make for quality software. I&#x27;ve had some of each in my past.<p>This is a big area that I wish researchers would focus on.  What really does make for long term high quality software.  What are the actual trade offs. How do we mitigate them. What are the limits to TDD - is it good?  Detroit or London mocks - when to use each? When is formal verification worth the time and effort? There is a lot places where we as an industry have ideas but are in heated debates without knowing how  to find a truth.</div><br/><div id="38575926" class="c"><input type="checkbox" id="c-38575926" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38574590">root</a><span>|</span><a href="#38575567">parent</a><span>|</span><a href="#38575889">next</a><span>|</span><label class="collapse" for="c-38575926">[-]</label><label class="expand" for="c-38575926">[1 more]</label></div><br/><div class="children"><div class="content">No, I have been, at various times, taught about a number of different techniques that are used in the endeavor to build quality software, along with lots of discussion about the tradeoffs between them and when they may be more or less appropriate.<p>It certainly is not something with a single easy answer, and I certainly agree that it remains a fruitful thing to continue researching, but that doesn&#x27;t mean that there is nothing to be taught about it. There is lots to be taught about this, and lots that is taught about it, to lots of people.</div><br/></div></div><div id="38575889" class="c"><input type="checkbox" id="c-38575889" checked=""/><div class="controls bullet"><span class="by">ponector</span><span>|</span><a href="#38574590">root</a><span>|</span><a href="#38575567">parent</a><span>|</span><a href="#38575926">prev</a><span>|</span><a href="#38574803">next</a><span>|</span><label class="collapse" for="c-38575889">[-]</label><label class="expand" for="c-38575889">[1 more]</label></div><br/><div class="children"><div class="content">My colleague, a senior full stack developer with CS masters degree has been asking: &quot;why should I write tests if I can write new features?&quot; And that is what managers often think. Because you can present new features to business but can&#x27;t do the same with tests. They have no immediate value.</div><br/></div></div></div></div></div></div><div id="38574803" class="c"><input type="checkbox" id="c-38574803" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#38574590">prev</a><span>|</span><a href="#38578862">next</a><span>|</span><label class="collapse" for="c-38574803">[-]</label><label class="expand" for="c-38574803">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Neglecting QA is a shame because 90%+ of all students work in a company context after they finish their degrees. It will be necessary to deliver software without bugs in time.<p>once again bringing up the hot debate of &quot;are colleges job prep or research institutions&quot;? Many students these days will proceed to grab a job, but is that something a university should strive to be?<p>I wish at the bare minimum there were more proper apprenticeships for companies that want some specific type of software engineer instead of 3 month vibe checks as it is right now. Or bootcamps made more or less to study to the test instead of what actually brings value. But I guess no one is really chomping at the bit to change the status quo</div><br/><div id="38575504" class="c"><input type="checkbox" id="c-38575504" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38574803">parent</a><span>|</span><a href="#38578862">next</a><span>|</span><label class="collapse" for="c-38575504">[-]</label><label class="expand" for="c-38575504">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  is that something a university should strive to be?<p>Universities taking public money (including students government grants&#x2F;loans) should strive to make society better.  Part of that is getting kids into good jobs that society needs done.<p>There are a few &quot;retired&quot; people taking classes that they are paying for on their own just for fun.  If those people think they are getting value despite taking subjects society doesn&#x27;t value I&#x27;m fine with that.  The majority of students though are young people that society is trying to invest in to make a better future, and so the more universities prepare those kids to make a better future the better.</div><br/></div></div></div></div><div id="38578862" class="c"><input type="checkbox" id="c-38578862" checked=""/><div class="controls bullet"><span class="by">pushedx</span><span>|</span><a href="#38574803">prev</a><span>|</span><a href="#38575880">next</a><span>|</span><label class="collapse" for="c-38578862">[-]</label><label class="expand" for="c-38578862">[1 more]</label></div><br/><div class="children"><div class="content">I went to a University with required Co-Op experience in industry. There was a great feedback cycle of students coming back to classes and writing tests and design documents for assignments that didn&#x27;t even require them. Reading articles like this make me really grateful for that.</div><br/></div></div><div id="38575880" class="c"><input type="checkbox" id="c-38575880" checked=""/><div class="controls bullet"><span class="by">rcbdev</span><span>|</span><a href="#38578862">prev</a><span>|</span><a href="#38572647">next</a><span>|</span><label class="collapse" for="c-38575880">[-]</label><label class="expand" for="c-38575880">[1 more]</label></div><br/><div class="children"><div class="content">In the Austria these topics are usually researched at universities of applied sciences (Fachhochschule) rather than universities (Universität). Some technical universities here attempt to combine these disciplines, to moderate success.<p>For example, the largest technical UAS in Austria offers Computer Science as an undergrad degree but only does research on Software Engineering at a graduate level.</div><br/></div></div><div id="38572647" class="c"><input type="checkbox" id="c-38572647" checked=""/><div class="controls bullet"><span class="by">throwaway_08932</span><span>|</span><a href="#38575880">prev</a><span>|</span><a href="#38572662">next</a><span>|</span><label class="collapse" for="c-38572647">[-]</label><label class="expand" for="c-38572647">[2 more]</label></div><br/><div class="children"><div class="content">You may not be taught to build it, but everyone sure seems to know how to argue it.</div><br/><div id="38572738" class="c"><input type="checkbox" id="c-38572738" checked=""/><div class="controls bullet"><span class="by">0xdeadbeefbabe</span><span>|</span><a href="#38572647">parent</a><span>|</span><a href="#38572662">next</a><span>|</span><label class="collapse" for="c-38572738">[-]</label><label class="expand" for="c-38572738">[1 more]</label></div><br/><div class="children"><div class="content">Even if this teaching quality thing existed, everyone would still argue about it.</div><br/></div></div></div></div><div id="38572662" class="c"><input type="checkbox" id="c-38572662" checked=""/><div class="controls bullet"><span class="by">teknopaul</span><span>|</span><a href="#38572647">prev</a><span>|</span><a href="#38578919">next</a><span>|</span><label class="collapse" for="c-38572662">[-]</label><label class="expand" for="c-38572662">[3 more]</label></div><br/><div class="children"><div class="content">Author needs to change shop<p>Where I work is 50% qa effort at least, 50% by budgets, and devs do much &gt;50% automated testing as part of what we call development.<p>Anything less and projects take longer, because bugs found later cost so much more to fix.</div><br/><div id="38572750" class="c"><input type="checkbox" id="c-38572750" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38572662">parent</a><span>|</span><a href="#38577476">next</a><span>|</span><label class="collapse" for="c-38572750">[-]</label><label class="expand" for="c-38572750">[1 more]</label></div><br/><div class="children"><div class="content">When I first started in the 1990s I was told testing was 60% of the product budget and traditional writing code 20%.  The remaining 20% was architecture and other design work.  We didn&#x27;t have unit test frameworks, but we did spend a lot of time writing throw away test fixtures (which was already generalizing into test frameworks by great developers and kicking off the unit test revolution)</div><br/></div></div></div></div><div id="38578919" class="c"><input type="checkbox" id="c-38578919" checked=""/><div class="controls bullet"><span class="by">sharts</span><span>|</span><a href="#38572662">prev</a><span>|</span><a href="#38578348">next</a><span>|</span><label class="collapse" for="c-38578919">[-]</label><label class="expand" for="c-38578919">[1 more]</label></div><br/><div class="children"><div class="content">The easiest way to tell if you&#x27;re about to join a bad team or company is to look at their QA process.<p>If it&#x27;s slim to non-existent, you&#x27;ll be working more hours with more on-call &quot;incidents&quot; and no life.</div><br/></div></div><div id="38578348" class="c"><input type="checkbox" id="c-38578348" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38578919">prev</a><span>|</span><a href="#38572969">next</a><span>|</span><label class="collapse" for="c-38578348">[-]</label><label class="expand" for="c-38578348">[1 more]</label></div><br/><div class="children"><div class="content">Excuse me, <i>I</i> was taught how to build quality software, but I can&#x27;t do it because the MBAs who run the company haven&#x27;t been taught how to build quality software, and the board of directors who hired upper management were not taught how to write quality software. Most places I have worked the opinions of software developers were thoroughly ignored at best.</div><br/></div></div><div id="38572969" class="c"><input type="checkbox" id="c-38572969" checked=""/><div class="controls bullet"><span class="by">drivers99</span><span>|</span><a href="#38578348">prev</a><span>|</span><a href="#38574476">next</a><span>|</span><label class="collapse" for="c-38572969">[-]</label><label class="expand" for="c-38572969">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In addition, at least in my studies, there was a semester about project management approaches and scrum. All of which is great, but QA is missing completely.<p>Just an anecdote, but, we had a &quot;Software Development&quot; class like this in CS (I took it in the &#x27;90s) and even though it followed a waterfall development model[0] and we used Gantt charts, QA (testing) was a big part of it and 1 of our 4 team members (or maybe 2 of 4 worked on it together) was primarily responsible for it. (I wrote the parser and the made diagrams&#x2F;documentation for the parser.)<p>The description (in an old catalog[1]) is:<p>Software specification, design, testing, maintenance, documentation; informal proof methods; team implementation of a large project.<p>Turns out I didn&#x27;t need to look up the old catalog because the description is exactly the same still! Except it&#x27;s CS 371 now, and the longer &quot;Learning Outcomes&quot; for the course has some newer stuff (agile and version control) but otherwise is all the same things I learned at the time.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Waterfall_model" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Waterfall_model</a><p>[1] <a href="https:&#x2F;&#x2F;nmsu.contentdm.oclc.org&#x2F;digital&#x2F;collection&#x2F;catalogs&#x2F;id&#x2F;22778&#x2F;rec&#x2F;25" rel="nofollow noreferrer">https:&#x2F;&#x2F;nmsu.contentdm.oclc.org&#x2F;digital&#x2F;collection&#x2F;catalogs&#x2F;...</a> (C S 372 in the lower right corner)</div><br/></div></div><div id="38574476" class="c"><input type="checkbox" id="c-38574476" checked=""/><div class="controls bullet"><span class="by">natbennett</span><span>|</span><a href="#38572969">prev</a><span>|</span><a href="#38576632">next</a><span>|</span><label class="collapse" for="c-38574476">[-]</label><label class="expand" for="c-38574476">[1 more]</label></div><br/><div class="children"><div class="content">Berkeley has a class that teaches TDD and other XP practices. (Or at least used to.) Pivotal used to recruit a lot of new grads from Berkeley for that reason.<p>IME, “QA” doesn’t really correlate with quality software, nor is there really a time vs. quality trade off. Bad software is often also delivered poorly, and high quality software can be delivered quickly.</div><br/></div></div><div id="38576632" class="c"><input type="checkbox" id="c-38576632" checked=""/><div class="controls bullet"><span class="by">sinoue</span><span>|</span><a href="#38574476">prev</a><span>|</span><a href="#38576472">next</a><span>|</span><label class="collapse" for="c-38576632">[-]</label><label class="expand" for="c-38576632">[1 more]</label></div><br/><div class="children"><div class="content">The competitive CS schools where many of the students needed good sample code projects have an innate sense of building quality software. Usually because they know it&#x27;ll be showcased, but also because they haven&#x27;t gotten lazy with shortcuts or been overly managed to spend time developing instead of fixing. I thought it was funny the article referenced the famous umbrella monster. Here is the longer clip: <a href="https:&#x2F;&#x2F;coub.com&#x2F;view&#x2F;284lib" rel="nofollow noreferrer">https:&#x2F;&#x2F;coub.com&#x2F;view&#x2F;284lib</a></div><br/></div></div><div id="38576472" class="c"><input type="checkbox" id="c-38576472" checked=""/><div class="controls bullet"><span class="by">makach</span><span>|</span><a href="#38576632">prev</a><span>|</span><label class="collapse" for="c-38576472">[-]</label><label class="expand" for="c-38576472">[2 more]</label></div><br/><div class="children"><div class="content">What the hell? Yes it is taught. How it is interpreted afterwards is very dependant on the team or community you surround yourself with. You get all the tools from schooling, how we use them is entirely up to us.</div><br/><div id="38576501" class="c"><input type="checkbox" id="c-38576501" checked=""/><div class="controls bullet"><span class="by">makach</span><span>|</span><a href="#38576472">parent</a><span>|</span><label class="collapse" for="c-38576501">[-]</label><label class="expand" for="c-38576501">[1 more]</label></div><br/><div class="children"><div class="content">Obviously the entire article is an opinion piece and flame bait and I fell for it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>