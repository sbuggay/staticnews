<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688720460405" as="style"/><link rel="stylesheet" href="styles.css?v=1688720460405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://words.filippo.io/dispatches/xaes-256-gcm-11/">I want XAES-256-GCM/11</a> <span class="domain">(<a href="https://words.filippo.io">words.filippo.io</a>)</span></div><div class="subtext"><span>harporoeder</span> | <span>84 comments</span></div><br/><div><div id="36629039" class="c"><input type="checkbox" id="c-36629039" checked=""/><div class="controls bullet"><span class="by">jedisct1</span><span>|</span><a href="#36623082">next</a><span>|</span><label class="collapse" for="c-36629039">[-]</label><label class="expand" for="c-36629039">[1 more]</label></div><br/><div class="children"><div class="content">AEGIS is being standardized, and solves many of the AES-GCM issues while being significantly faster.<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-irtf-cfrg-aegis-aead&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-irtf-cfrg-aegis-aead&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;jedisct1&#x2F;aegis-128X">https:&#x2F;&#x2F;github.com&#x2F;jedisct1&#x2F;aegis-128X</a></div><br/></div></div><div id="36623082" class="c"><input type="checkbox" id="c-36623082" checked=""/><div class="controls bullet"><span class="by">sdrapkin</span><span>|</span><a href="#36629039">prev</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36623082">[-]</label><label class="expand" for="c-36623082">[23 more]</label></div><br/><div class="children"><div class="content">GCM (ie. AES-GCM) has the following problems, which extended variants - those that deterministically randomize (key,nonce) pair - do not solve:<p>Inability to encrypt more than 64Gb with the same (key,nonce) pair.<p>Lack of commitment (whether key-commitment, or key+nonce+ad commitment).<p>If one is seriously considering breaking away from existing GCM standards to create yet-another-standard, such proposal would need to offer improvements in all areas (ex. a proposed standard for converting any AEAD into streaming chunk-based AEAD with practically unlimited message sizes under the same (key,nonce) and unlimited message counts.<p>GCM-256 is ubiquitous and is often the preferred choice for all the reasons mentioned by the author, but that very argument is what makes non-standard GCM with 11 AES-rounds silly.<p>In 2023 we should be working on new standards that &quot;wrap&quot; existing crypto-primitives (which are already implemented&#x2F;available in countless hardware-accelerated libraries&#x2F;APIs) to get additional features&#x2F;benefits&#x2F;capabilities - not musing about AES with 10+1 rounds or SHA-512-really-fast with 80-1 rounds..</div><br/><div id="36625172" class="c"><input type="checkbox" id="c-36625172" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36623082">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36625172">[-]</label><label class="expand" for="c-36625172">[14 more]</label></div><br/><div class="children"><div class="content">&gt; Inability to encrypt more than 64Gb with the same (key,nonce) pair.<p>I think a better way is to derive the content per file part and then use a ratcheting nonce to encrypt the subparts. That also gives you random access into the entire file in ~O(1) (i.e. no need to decrypt the entire file) and the ability to interrupt and resume decryption. Unfortunately, there&#x27;s no standard that describes how the output should be serialized, so tool interop becomes a problem. Although, to be fair, there&#x27;s no serialization standard for AES either (i.e. what do you do with the nonce?) so it&#x27;s probably not a big deal.</div><br/><div id="36625514" class="c"><input type="checkbox" id="c-36625514" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36625172">parent</a><span>|</span><a href="#36625680">next</a><span>|</span><label class="collapse" for="c-36625514">[-]</label><label class="expand" for="c-36625514">[1 more]</label></div><br/><div class="children"><div class="content">The issue with 64GB is one thing. Not many people encrypt single 64GB files. But people do use aes-gcm for tunnels and encrypting billions of messages and you can only use the key so many times before you have to rotate. Many people screw this part up.</div><br/></div></div><div id="36625680" class="c"><input type="checkbox" id="c-36625680" checked=""/><div class="controls bullet"><span class="by">fargle</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36625172">parent</a><span>|</span><a href="#36625514">prev</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36625680">[-]</label><label class="expand" for="c-36625680">[12 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s easier than that. When using the IV using a 96 bit fixed field and 32 bit counter, FIPS SP800-38d says you are limited to 2**32 &quot;invocations of the authenticated encryption function with any given fixed field and key&quot;. What they call the fixed field is the common 96 bit IV or nonce.<p>So you can do 512Gb or 64GB under one nonce. Then simply increment the fixed field and run the next 64GB under the same key and new nonce (nonce+1) and so on. In essence, it&#x27;s the same thing is just making the fixed field smaller and the counter bigger, but meets the letter and intent of the law. The &quot;fixed field&quot; can be anything the user wants, including being &quot;constructed from two or more smaller fields&quot;. And it is not constrained to remain the same under multiple invocations. Still compatible with FIPS and common implementations. It doesn&#x27;t have to be some fancy ratcheting scheme.<p>The initial &quot;fixed field&quot; or nonce could even always just be all zeros [1]. It doesn&#x27;t matter, it&#x27;s not secret.<p>If for some reason you want to encrypt that much under one key, which I think you really don&#x27;t.<p>1: well, in most cases especially AES-256: <a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;68774&#x2F;can-a-zero-nonce-be-safely-used-with-aes-gcm-if-the-key-is-random-and-never-used" rel="nofollow noreferrer">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;68774&#x2F;can-a-zero-...</a></div><br/><div id="36625847" class="c"><input type="checkbox" id="c-36625847" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36625680">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36625847">[-]</label><label class="expand" for="c-36625847">[11 more]</label></div><br/><div class="children"><div class="content">The problem with this is that if the nonce ever collides under the same key, GCM&#x27;s security falls to pieces, and so if you&#x27;re using the nonce as an extended counter --- a thing people do, in part because they&#x27;re worried 96 bits is too short to safely choose randomly --- you have to design a system that can&#x27;t use the nonce &quot;0&quot; (or &quot;1&quot; or &quot;2&quot;) twice.<p>If all your keys are ephemeral this isn&#x27;t a big worry, but if they aren&#x27;t, you can end up talking about reliably keeping state between invocations of your whole program.<p>(Apologies if this is obvious!)</div><br/><div id="36626036" class="c"><input type="checkbox" id="c-36626036" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36625847">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36626036">[-]</label><label class="expand" for="c-36626036">[10 more]</label></div><br/><div class="children"><div class="content">&gt; GCM&#x27;s security falls to pieces<p>That&#x27;s an exaggeration. Reusing the nonce in GCM allows decryption of messages with the same nonce. It does NOT compromise the key.</div><br/><div id="36626158" class="c"><input type="checkbox" id="c-36626158" checked=""/><div class="controls bullet"><span class="by">idorosen</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626036">parent</a><span>|</span><a href="#36626180">next</a><span>|</span><label class="collapse" for="c-36626158">[-]</label><label class="expand" for="c-36626158">[2 more]</label></div><br/><div class="children"><div class="content">Allowing decryption of the messages sounds like falling to pieces to me...</div><br/><div id="36626847" class="c"><input type="checkbox" id="c-36626847" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626158">parent</a><span>|</span><a href="#36626180">next</a><span>|</span><label class="collapse" for="c-36626847">[-]</label><label class="expand" for="c-36626847">[1 more]</label></div><br/><div class="children"><div class="content">Messages with duplicate nonces. Recovery of the authentication key may also allow message forgery (although it won&#x27;t allow decryption).</div><br/></div></div></div></div><div id="36626180" class="c"><input type="checkbox" id="c-36626180" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626036">parent</a><span>|</span><a href="#36626158">prev</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36626180">[-]</label><label class="expand" for="c-36626180">[7 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;cryptopals.com&#x2F;sets&#x2F;8&#x2F;challenges&#x2F;63.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;cryptopals.com&#x2F;sets&#x2F;8&#x2F;challenges&#x2F;63.txt</a></div><br/><div id="36626809" class="c"><input type="checkbox" id="c-36626809" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626180">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36626809">[-]</label><label class="expand" for="c-36626809">[6 more]</label></div><br/><div class="children"><div class="content">Yes, and? It allows recovery of the authentication key, but not the source AES key.<p>The authentication key is _derived_ from the AES key, but they&#x27;re not the same.</div><br/><div id="36626846" class="c"><input type="checkbox" id="c-36626846" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626809">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36626846">[-]</label><label class="expand" for="c-36626846">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can walk back your previous comment, which was pretty categorical. Either way, we&#x27;re clear about the brittleness of GCM at this point, and there&#x27;s little else for us to talk about.</div><br/><div id="36627620" class="c"><input type="checkbox" id="c-36627620" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626846">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36627620">[-]</label><label class="expand" for="c-36627620">[4 more]</label></div><br/><div class="children"><div class="content">Brittleness? Not really. It&#x27;s not completely future-proof, and it would be easier if a larger nonce is standardized, but all realistic attacks require rather unlikely sets of circumstances.<p>And no, you can&#x27;t recover the encryption key (i.e. the thing that allows you to decrypt messages) from any weakness in the nonce choice.</div><br/><div id="36627668" class="c"><input type="checkbox" id="c-36627668" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36627620">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36627668">[-]</label><label class="expand" for="c-36627668">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;woot16&#x2F;workshop-program&#x2F;presentation&#x2F;bock" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;woot16&#x2F;workshop-program&#x2F;pr...</a><p>I think you should stop digging. Sean and Hanno gave a Black Hat talk whose slides were unwillingly hosted on a GCHQ website because of this problem.</div><br/><div id="36627838" class="c"><input type="checkbox" id="c-36627838" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36627668">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36627838">[-]</label><label class="expand" for="c-36627838">[2 more]</label></div><br/><div class="children"><div class="content">Well, perhaps it&#x27;s YOU who should study it and stop digging yourself in deeper?<p>The paper you cited does NOT allow compromise of the encryption key. None of the GCM-based constructions are vulnerable to any nonce-based weaknesses, because the authentication key is _derived_ from the encryption key using secure encryption.<p>Moreover, observing the encoded stream for reused nonces would also allow decryption of only these messages. Not great, but also not too bad as the collision risks are small. You need truly strange circumstances for it to matter: an attacker-chosen giant well-formatted plaintext, a nonce collision (that&#x27;s why the plaintext has to be giant), and the future ciphertext has to be important to the attacker.<p>Even straightforward nonce reuse (and extended nonces do NOT protect against it)  still does not allow arbitrary decryption, although it makes the cipherstream malleable.</div><br/><div id="36627944" class="c"><input type="checkbox" id="c-36627944" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36627838">parent</a><span>|</span><a href="#36623159">next</a><span>|</span><label class="collapse" for="c-36627944">[-]</label><label class="expand" for="c-36627944">[1 more]</label></div><br/><div class="children"><div class="content">K.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36623159" class="c"><input type="checkbox" id="c-36623159" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">parent</a><span>|</span><a href="#36625172">prev</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36623159">[-]</label><label class="expand" for="c-36623159">[8 more]</label></div><br/><div class="children"><div class="content">Presumably, if you&#x27;re going to do an extended-nonce GCM, you could reformat the counter block (since the nonce is encoded in the key anyways) to get rid of the 64Gb limit --- but that complicates the FIPS story, I guess?</div><br/><div id="36623362" class="c"><input type="checkbox" id="c-36623362" checked=""/><div class="controls bullet"><span class="by">sdrapkin</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36623159">parent</a><span>|</span><a href="#36624887">next</a><span>|</span><label class="collapse" for="c-36623362">[-]</label><label class="expand" for="c-36623362">[3 more]</label></div><br/><div class="children"><div class="content">Indeed. But FIPS is not the only problem. Both the McGrew&#x2F;Viega spec and subsequent NIST spec of GCM mandate a 4-byte counter - any departure from that would be &quot;no longer GCM&quot;.</div><br/><div id="36625894" class="c"><input type="checkbox" id="c-36625894" checked=""/><div class="controls bullet"><span class="by">motohagiography</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36623362">parent</a><span>|</span><a href="#36623611">next</a><span>|</span><label class="collapse" for="c-36625894">[-]</label><label class="expand" for="c-36625894">[1 more]</label></div><br/><div class="children"><div class="content">Is the argument for a small counter that nobody serious will treat it as a significant diversification component or reliable source of entropy, especially in a streaming mode? It&#x27;s a counter whose function is necesesarily finite and predictable (and reversible?), if not explicitly linear. Intuitively, any substitutions or convolutions derived from it would weaken subsequent operations, no?</div><br/></div></div><div id="36623611" class="c"><input type="checkbox" id="c-36623611" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36623362">parent</a><span>|</span><a href="#36625894">prev</a><span>|</span><a href="#36624887">next</a><span>|</span><label class="collapse" for="c-36623611">[-]</label><label class="expand" for="c-36623611">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Gross.</div><br/></div></div></div></div><div id="36624887" class="c"><input type="checkbox" id="c-36624887" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36623159">parent</a><span>|</span><a href="#36623362">prev</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36624887">[-]</label><label class="expand" for="c-36624887">[4 more]</label></div><br/><div class="children"><div class="content">I think the message size limit is a bit of a red herring. Anyone using AES-GCM with messages that large is probably doing sketchy things with unauthenticated plaintext on the decryption side. A non-hazmat&#x2F;not-just-for-experts cipher really needs to be chunked.</div><br/><div id="36625752" class="c"><input type="checkbox" id="c-36625752" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36624887">parent</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36625752">[-]</label><label class="expand" for="c-36625752">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen operating on unauthenticated plaintext enough times to list it as my own pet peeve with AES-GCM. But it&#x27;s a problem for chunked messages too. A few years ago we released a SCRAM mode that makes very minimal changes to AES-GCM so that it mathematically can&#x27;t operate on unauthenticated plaintext. <a href="https:&#x2F;&#x2F;github.com&#x2F;aws&#x2F;s2n-tls&#x2F;tree&#x2F;main&#x2F;scram">https:&#x2F;&#x2F;github.com&#x2F;aws&#x2F;s2n-tls&#x2F;tree&#x2F;main&#x2F;scram</a></div><br/><div id="36626004" class="c"><input type="checkbox" id="c-36626004" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36625752">parent</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36626004">[-]</label><label class="expand" for="c-36626004">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But it&#x27;s a problem for chunked messages too.<p>I&#x27;m curious to hear more about what you&#x27;ve seen. My naive hope was that a proper streaming decrypt API would be enough of a pit of success that developers wouldn&#x27;t be tempted to sabotage themselves.</div><br/><div id="36626599" class="c"><input type="checkbox" id="c-36626599" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#36623082">root</a><span>|</span><a href="#36626004">parent</a><span>|</span><a href="#36625025">next</a><span>|</span><label class="collapse" for="c-36626599">[-]</label><label class="expand" for="c-36626599">[1 more]</label></div><br/><div class="children"><div class="content">A great amount of modern systems is copying data from A to B to C. The construct of frontends and backends implies it, or middleware, or proxies, or distributed storage, or blockchains. Even in the most complex systems, latency is one of the easiest core metrics to measure, and is always a priority. It is always lower latency to prefetch the inter-system pipelines, or to use optimistic concurrency and to preprocess data before it has been authenticated.<p>Chunked streaming can make the difference smaller, but even that &quot;small&quot; difference is beyond what is relevant to say ... filling an L1 cache, or waiting a round-trip. Some of the cases of &quot;read before auth&quot; I&#x27;ve seen have been on very small messages, but in contexts where the incentives are even further driven up, like trading or bidding protocols. It just left me thinking that we should enforce AEAD mathematically. Many practitioners often assume it already is enforced!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36625025" class="c"><input type="checkbox" id="c-36625025" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36623082">prev</a><span>|</span><a href="#36622490">next</a><span>|</span><label class="collapse" for="c-36625025">[-]</label><label class="expand" for="c-36625025">[2 more]</label></div><br/><div class="children"><div class="content">&gt; we might wish OCB hadn’t been patented<p>Rogaway says he has released all his OCB patents into the public domain[1], so it sounds like OCB might be an option for greenfield projects? OTOH, I don’t see why you’d use any kind of AES in a greenfield project outside the surreal FIPS world, given how absolutely miserable constant-time software for it is. (ChaCha is kind of miserable when you don’t have at least a 32-bit ALU with a barrel shifter—that is on exactly the kind of platforms where table-based AES might actually be constant-time—but I’m not sure that’s a good enough reason.)<p>[1] <a href="https:&#x2F;&#x2F;mailarchive.ietf.org&#x2F;arch&#x2F;msg&#x2F;cfrg&#x2F;qLTveWOdTJcLn4HP3ev-vrj05Vg&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mailarchive.ietf.org&#x2F;arch&#x2F;msg&#x2F;cfrg&#x2F;qLTveWOdTJcLn4HP3...</a></div><br/><div id="36625879" class="c"><input type="checkbox" id="c-36625879" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36625025">parent</a><span>|</span><a href="#36622490">next</a><span>|</span><label class="collapse" for="c-36625879">[-]</label><label class="expand" for="c-36625879">[1 more]</label></div><br/><div class="children"><div class="content">It is now, but when all this stuff was getting nailed down and all the standards were being written and all the AEAD libraries were being implemented it was off the table, so a lot of people feel like rehabilitating OCB isn&#x27;t a great hill to die on.</div><br/></div></div></div></div><div id="36622490" class="c"><input type="checkbox" id="c-36622490" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#36625025">prev</a><span>|</span><a href="#36621620">next</a><span>|</span><label class="collapse" for="c-36622490">[-]</label><label class="expand" for="c-36622490">[9 more]</label></div><br/><div class="children"><div class="content">Has there been any situation in which 10 rounds would be utterly broken but 14 would give you &quot;enough&quot; of a security margin? My impression is that once you&#x27;ve managed to break a cipher enough to get that many rounds, you&#x27;ve also discovered a linear-time attack on that cipher[0]. Adding a mere 28% slowdown on that attack won&#x27;t help.<p>[0] &quot;Linear time&quot; means O(n), which is computer science speak for &quot;f(n) = an, but we ignore the a because we&#x27;re only interested in the fastest growing component of the function&quot;. In some cases the a is so large as to make the algorithm in question not feasible for ANY size. Let&#x27;s just pretend the attacker doesn&#x27;t have that problem.</div><br/><div id="36622629" class="c"><input type="checkbox" id="c-36622629" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#36622490">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36622629">[-]</label><label class="expand" for="c-36622629">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;d probably be interested in the &quot;Too Much Crypto&quot; paper linked in the post: <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2019&#x2F;1492" rel="nofollow noreferrer">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2019&#x2F;1492</a></div><br/><div id="36623036" class="c"><input type="checkbox" id="c-36623036" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36622490">root</a><span>|</span><a href="#36622629">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36623036">[-]</label><label class="expand" for="c-36623036">[5 more]</label></div><br/><div class="children"><div class="content">&gt; To support this claim, we review the cryptanalysis progress in the last 20 years,<p>...and rationally and scientifically assuming that the rate of the progress won&#x27;t increase and that there will be no major breakthroughs in the future, we propose revised number of rounds for AES, BLAKE2, ChaCha, and SHA-3.<p>The crypto is already fast enough, thank you very much; many attacks work only precisely it&#x27;s quite fast to brute force huge subspaces of key material.</div><br/><div id="36623179" class="c"><input type="checkbox" id="c-36623179" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36622490">root</a><span>|</span><a href="#36623036">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36623179">[-]</label><label class="expand" for="c-36623179">[4 more]</label></div><br/><div class="children"><div class="content">Which attacks would those be? Are you thinking about password cracking? What are the other ones?</div><br/><div id="36625489" class="c"><input type="checkbox" id="c-36625489" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36622490">root</a><span>|</span><a href="#36623179">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36625489">[-]</label><label class="expand" for="c-36625489">[3 more]</label></div><br/><div class="children"><div class="content">SHA-1 collisions are (almost) as much brute force as anything.</div><br/><div id="36625674" class="c"><input type="checkbox" id="c-36625674" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36622490">root</a><span>|</span><a href="#36625489">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36625674">[-]</label><label class="expand" for="c-36625674">[2 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s not because SHA-1 doesn&#x27;t have enough rounds; there&#x27;s a more fundamental flaw in SHA-1.</div><br/><div id="36625764" class="c"><input type="checkbox" id="c-36625764" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36622490">root</a><span>|</span><a href="#36625674">parent</a><span>|</span><a href="#36626113">next</a><span>|</span><label class="collapse" for="c-36625764">[-]</label><label class="expand" for="c-36625764">[1 more]</label></div><br/><div class="children"><div class="content">Okay, fair, I hallucinated bits into the statement.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36626113" class="c"><input type="checkbox" id="c-36626113" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36622490">parent</a><span>|</span><a href="#36622629">prev</a><span>|</span><a href="#36625557">next</a><span>|</span><label class="collapse" for="c-36626113">[-]</label><label class="expand" for="c-36626113">[1 more]</label></div><br/><div class="children"><div class="content">Skipjack is notable for having 32 rounds and being broken for 31 rounds.</div><br/></div></div><div id="36625557" class="c"><input type="checkbox" id="c-36625557" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#36622490">parent</a><span>|</span><a href="#36626113">prev</a><span>|</span><a href="#36621620">next</a><span>|</span><label class="collapse" for="c-36625557">[-]</label><label class="expand" for="c-36625557">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t AES completely broken under 5 rounds and currently is considered completely safe at like 8 rounds?</div><br/></div></div></div></div><div id="36621620" class="c"><input type="checkbox" id="c-36621620" checked=""/><div class="controls bullet"><span class="by">zahllos</span><span>|</span><a href="#36622490">prev</a><span>|</span><a href="#36621539">next</a><span>|</span><label class="collapse" for="c-36621620">[-]</label><label class="expand" for="c-36621620">[9 more]</label></div><br/><div class="children"><div class="content">From the NIST doc for GCM: <a href="https:&#x2F;&#x2F;nvlpubs.nist.gov&#x2F;nistpubs&#x2F;Legacy&#x2F;SP&#x2F;nistspecialpublication800-38d.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;nvlpubs.nist.gov&#x2F;nistpubs&#x2F;Legacy&#x2F;SP&#x2F;nistspecialpubli...</a><p>The IV can be any length up to 2^64-1. The reason for picking 96-bit IVs is that other values require an extra invocation of GHASH (page 15). The document recommends 96-bit for interoperability but that&#x27;s by no means a requirement.<p>The X part is thus in theory already allowed.</div><br/><div id="36621787" class="c"><input type="checkbox" id="c-36621787" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#36621620">parent</a><span>|</span><a href="#36622405">next</a><span>|</span><label class="collapse" for="c-36621787">[-]</label><label class="expand" for="c-36621787">[6 more]</label></div><br/><div class="children"><div class="content">I may be misunderstanding, but this <i>might</i> be the thing already discussed in footnote 2 of the article: &quot;Technically, GCM accepts longer nonces. However, nonces longer than 96 bits are hashed into a starting 128-bit counter value, leaving no dedicated counter space. (96-bit nonces are instead concatenated with a 32-bit counter.)&quot;</div><br/><div id="36622361" class="c"><input type="checkbox" id="c-36622361" checked=""/><div class="controls bullet"><span class="by">zahllos</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36621787">parent</a><span>|</span><a href="#36627822">next</a><span>|</span><label class="collapse" for="c-36622361">[-]</label><label class="expand" for="c-36622361">[4 more]</label></div><br/><div class="children"><div class="content">I missed that, good catch.<p>That said, I find the wording of dedicated counter space a bit bizarre. There are only 128 bits per block in AES - in fact I&#x27;m not aware of a widely deployed cipher which a larger block size. Whatever goes through ghash becomes the initial plaintext passed to aes under the key (this is the counter) part and then you just increment. This is just a limitation of counter mode in general: the whole IV is technically counter space and is treated as whole when evaluating the birthday bound issue.<p>The critical part mentioned in the post is that XChaCha &quot;hashes the key+nonce into a fresh key&quot;. A very similar technique is used un: AES-GCM-SIV (<a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8452#section-9" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8452#section-9</a>). The improved security here comes not from any &quot;counter space&quot; or nonce extension per se but the fact that changing the IV changes the effective key used in the block primitive (i.e. the raw aes-encrypt function) as well as the first block of plaintext fed to AES by deriving these from nonce+key.<p>So I guess this is asking for a somewhat different construction. Personally aside from the fact it is already widely deployed I&#x27;m not sure I&#x27;d keep GHASH.</div><br/><div id="36622583" class="c"><input type="checkbox" id="c-36622583" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36622361">parent</a><span>|</span><a href="#36627822">next</a><span>|</span><label class="collapse" for="c-36622583">[-]</label><label class="expand" for="c-36622583">[3 more]</label></div><br/><div class="children"><div class="content">The SIVs have somewhat different security properties than straight AEAD; they&#x27;re usually a win, but not always. Moreover: the whole point of doing an extended-nonce AEAD is to avoid the extra mechanism of a nonce-misuse-resistant AEAD by giving yourself enough headroom to just pick huge random nonces.</div><br/><div id="36622750" class="c"><input type="checkbox" id="c-36622750" checked=""/><div class="controls bullet"><span class="by">zahllos</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36622583">parent</a><span>|</span><a href="#36627822">next</a><span>|</span><label class="collapse" for="c-36622750">[-]</label><label class="expand" for="c-36622750">[2 more]</label></div><br/><div class="children"><div class="content">Note that I&#x27;m not saying use SIV. I&#x27;m just saying that SIV already does the extended nonce part:<p>&gt; The AEADs defined in this document calculate fresh AES keys for each nonce.<p>I guess write an RFC for extended nonce only?</div><br/><div id="36623240" class="c"><input type="checkbox" id="c-36623240" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36622750">parent</a><span>|</span><a href="#36627822">next</a><span>|</span><label class="collapse" for="c-36623240">[-]</label><label class="expand" for="c-36623240">[1 more]</label></div><br/><div class="children"><div class="content">Gotcha, thanks!</div><br/></div></div></div></div></div></div></div></div><div id="36627822" class="c"><input type="checkbox" id="c-36627822" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36621787">parent</a><span>|</span><a href="#36622361">prev</a><span>|</span><a href="#36622405">next</a><span>|</span><label class="collapse" for="c-36627822">[-]</label><label class="expand" for="c-36627822">[1 more]</label></div><br/><div class="children"><div class="content">If you are using random nonces, segregating the nonce space to have a dedicated 32-bit block counter yields worse security bounds anyway. The whole point of that segregation is to avoid collisions when using a deterministic nonce like a counter. Unless your messages approach the size limit then randomizing the whole 128-bit nonce provides <i>much</i> better bounds than current GCM - effectively the same as randomized CTR mode. (ie nearer to 2^48 messages limit).<p>So yes, using GCM with a 128-bit random nonce is already good enough for most of these cases.<p><i>However</i> IMO all of this is a distraction anyway. One of the most devastating real-world attacks involving nonce reuse was the KRACK attacks, and that involved a protocol error allowing the attacker to <i>force</i> nonce reuse. No amount of extra large random nonces would have saved from that. (And using random nonces in such a protocol significantly bloats the wire format).<p>What we really need to do is move away from hugely fragile polynomial MACs. For 90%+ of usecases a more robust PRF is perfectly performant enough - eg note that the impact of KRACK was less severe against CCM than GCM. Heck, even CTR&#x2F;CBC+HMAC is perfectly fast enough for many use-cases. Stop with the premature optimisation already.</div><br/></div></div></div></div><div id="36622405" class="c"><input type="checkbox" id="c-36622405" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36621620">parent</a><span>|</span><a href="#36621787">prev</a><span>|</span><a href="#36621539">next</a><span>|</span><label class="collapse" for="c-36622405">[-]</label><label class="expand" for="c-36622405">[2 more]</label></div><br/><div class="children"><div class="content">As I understand it, the limitation people are concerned about is that of the IV&#x2F;counter block. It&#x27;s not that you can&#x27;t hash an arbitrarily large nonce down to 96 bits; you obviously can. It&#x27;s that ultimately you&#x27;ve only got 96 bits on the wire to express your nonce, and if they collide GCM falls apart. That&#x27;s the X trick in XSalsa: the wider nonce gets laundered into the key.</div><br/><div id="36627670" class="c"><input type="checkbox" id="c-36627670" checked=""/><div class="controls bullet"><span class="by">amadvance</span><span>|</span><a href="#36621620">root</a><span>|</span><a href="#36622405">parent</a><span>|</span><a href="#36621539">next</a><span>|</span><label class="collapse" for="c-36627670">[-]</label><label class="expand" for="c-36627670">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the implementation, the longer nonce is hashed to 128 bits, with the last 32 used as a starting counter. So, if you don&#x27;t use the whole 32 bits space of the counter, you are effectively using more than 96 bits nonce.<p>Sure, no more than 128 bits, but indeed better than 96.</div><br/></div></div></div></div></div></div><div id="36621539" class="c"><input type="checkbox" id="c-36621539" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#36621620">prev</a><span>|</span><a href="#36621868">next</a><span>|</span><label class="collapse" for="c-36621539">[-]</label><label class="expand" for="c-36621539">[6 more]</label></div><br/><div class="children"><div class="content">How does it compare to XChachaPoly? I guess it&#x27;s only useful when you are sure to have CPU support for AES and not having to deal with the annoyance of non constant time software implementations. I feel like XChachaPoly has the benefit of being annoyance free (constant time by design even in software implementation), fairly fast even without hardware support and to exists, so it&#x27;s probably a good choice for most use cases.<p>EDIT: my question is probably more clearly asked as: what&#x27;s wrong with XChachaPoly that is solved by this new construct?</div><br/><div id="36621816" class="c"><input type="checkbox" id="c-36621816" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#36621539">parent</a><span>|</span><a href="#36622172">next</a><span>|</span><label class="collapse" for="c-36621816">[-]</label><label class="expand" for="c-36621816">[2 more]</label></div><br/><div class="children"><div class="content">Because AESNI and CLMUL, AES-GCM is faster than a SIMD implementation of ChaCha20Poly1305. In theory, ChaCha20 is overkill, 8 rounds would have been enough and people do use 12 rounds for disk encryption.</div><br/><div id="36621918" class="c"><input type="checkbox" id="c-36621918" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#36621539">root</a><span>|</span><a href="#36621816">parent</a><span>|</span><a href="#36622172">next</a><span>|</span><label class="collapse" for="c-36621918">[-]</label><label class="expand" for="c-36621918">[1 more]</label></div><br/><div class="children"><div class="content">Yes that was my thoughts as well, if you are concerned about speed and dropping AES rounds, you might as well do the same with Chacha and use Chacha20&#x2F;8 (which I don&#x27;t know if it &quot;exists&quot; but Salsa20&#x2F;8 is a thing, used in scrypt and available in libsodium for example). At least it&#x27;s also fast when you don&#x27;t have AESNI.</div><br/></div></div></div></div><div id="36622172" class="c"><input type="checkbox" id="c-36622172" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#36621539">parent</a><span>|</span><a href="#36621816">prev</a><span>|</span><a href="#36621868">next</a><span>|</span><label class="collapse" for="c-36622172">[-]</label><label class="expand" for="c-36622172">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve unfortunately seen many situations where only NIST approved constructions are allowed. ChaCha is not an approved NIST algorithm but AES-256-GCM is</div><br/><div id="36622562" class="c"><input type="checkbox" id="c-36622562" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#36621539">root</a><span>|</span><a href="#36622172">parent</a><span>|</span><a href="#36621868">next</a><span>|</span><label class="collapse" for="c-36622562">[-]</label><label class="expand" for="c-36622562">[2 more]</label></div><br/><div class="children"><div class="content">I totally get that, but XAES-256-GCM&#x2F;11 is in an even worse situation than XChachaPoly since none are NIST but XChachaPoly has at least a RFC ^^<p>EDIT: I&#x27;m wrong, ChachaPoly has an rfc, but not the X variant</div><br/><div id="36624153" class="c"><input type="checkbox" id="c-36624153" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#36621539">root</a><span>|</span><a href="#36622562">parent</a><span>|</span><a href="#36621868">next</a><span>|</span><label class="collapse" for="c-36624153">[-]</label><label class="expand" for="c-36624153">[1 more]</label></div><br/><div class="children"><div class="content">XChaCha20Poly1305 does have an RFC authored by Scott Arciszewski: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-arciszewski-xchacha-03" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-arciszewski-xcha...</a></div><br/></div></div></div></div></div></div></div></div><div id="36621868" class="c"><input type="checkbox" id="c-36621868" checked=""/><div class="controls bullet"><span class="by">purple_elephant</span><span>|</span><a href="#36621539">prev</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36621868">[-]</label><label class="expand" for="c-36621868">[11 more]</label></div><br/><div class="children"><div class="content">&gt;In 2023, the way to use AES is AES-GCM. Anything else is very unlikely to make sense.<p>Encrypt-then-MAC remains the most conservative and theoretically secure option.<p>Leaving aside the (very serious) nonce reuse issue, the cracks on non-committing AEADs in general (such as AES-GCM) are already showing. Partitioning oracle attacks affect all of them: <a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;88716&#x2F;understanding-the-impact-of-partitioning-oracle-attacks-on-stream-ciphers" rel="nofollow noreferrer">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;88716&#x2F;understandi...</a><p>There are also other minor GCM-specific issues (weak keys etc.). None of the issues are cypher-breaking, but I wouldn&#x27;t say that AES-GCM is automatically the best choice for everything.</div><br/><div id="36622296" class="c"><input type="checkbox" id="c-36622296" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36621868">parent</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36622296">[-]</label><label class="expand" for="c-36622296">[10 more]</label></div><br/><div class="children"><div class="content">GCM is an encrypt-then-MAC mode.</div><br/><div id="36622392" class="c"><input type="checkbox" id="c-36622392" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622296">parent</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36622392">[-]</label><label class="expand" for="c-36622392">[9 more]</label></div><br/><div class="children"><div class="content">And AES-GCM-SIV is MAC-then-Encrypt but is still secure (albeit not committing), so people cry foul when it&#x27;s pointed out.<p>AEADs are obviously better than EtM, because EtM doesn&#x27;t allow for authenticating the unencrypted context.<p>I wrote about turning CTR+HMAC into a committing AEAD and promptly screwing it up badly: <a href="https:&#x2F;&#x2F;soatok.blog&#x2F;2021&#x2F;07&#x2F;30&#x2F;canonicalization-attacks-against-macs-and-signatures&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;soatok.blog&#x2F;2021&#x2F;07&#x2F;30&#x2F;canonicalization-attacks-agai...</a></div><br/><div id="36622743" class="c"><input type="checkbox" id="c-36622743" checked=""/><div class="controls bullet"><span class="by">fdupress</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622392">parent</a><span>|</span><a href="#36622809">next</a><span>|</span><label class="collapse" for="c-36622743">[-]</label><label class="expand" for="c-36622743">[4 more]</label></div><br/><div class="children"><div class="content">Etam absolutely allows you to authenticate an unencrypted context. In fact, you <i>must</i> ensure that the nonce, a piece of unencrypted context, is authenticated. Nothing stops you from throwing more stuff in there.<p>The only thing you can do with an integrated AEAD that you can&#x27;t do with a constructed one (with standard interface and security) is include authenticated and unencrypted context halfway through an encryption.</div><br/><div id="36622799" class="c"><input type="checkbox" id="c-36622799" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622743">parent</a><span>|</span><a href="#36622809">next</a><span>|</span><label class="collapse" for="c-36622799">[-]</label><label class="expand" for="c-36622799">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Etam absolutely allows you to authenticate an unencrypted context.<p>You can specify an EtM construction that accepts additional authenticated data. However, you can also do it insecurely (as the post I linked above describes) without realizing you did it insecurely. This is why most people prefer to use cryptographer-approved AEAD modes.<p>&gt; In fact, you must ensure that the nonce, a piece of unencrypted context, is authenticated.<p>For CBC mode, sure. For CTR mode? Not really.<p>&gt; Nothing stops you from throwing more stuff in there.<p>What prevents an attacker from shifting bits from the ciphertext field into the AAD field in the decrypt path and yield the same HMAC tag? Unless you have an answer to this question, vanilla &quot;encrypt then MAC&quot; is not sufficient. You need a better-engineered construction than that.<p>I&#x27;m pretty sure the linked post covered all of this nuance. Please let me know if something wasn&#x27;t clear, or you feel it was missing.</div><br/><div id="36627909" class="c"><input type="checkbox" id="c-36627909" checked=""/><div class="controls bullet"><span class="by">fdupress</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622799">parent</a><span>|</span><a href="#36622809">next</a><span>|</span><label class="collapse" for="c-36627909">[-]</label><label class="expand" for="c-36627909">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can specify an EtM construction that accepts additional authenticated data. However, you can also do it insecurely (as the post I linked above describes) without realizing you did it insecurely. This is why most people prefer to use cryptographer-approved AEAD modes.<p>Sure, I agree with this. But then the advantage of AEAD over a bespoke EtM is not that AEAD allows the authentication of unencrypted context.<p>&gt;&gt; In fact, you must ensure that the nonce, a piece of unencrypted context, is authenticated.<p>&gt; For CBC mode, sure. For CTR mode? Not really.<p>If you don&#x27;t, you do not get ciphertext integrity: decryption will succeed, but mostly yield gibberish, if the adversary changes the nonce in a decryption query. This may expose a padding oracle, with all the nice attacks those things allow, depending on details of the application.<p>&gt;&gt; Nothing stops you from throwing more stuff in there.<p>&gt; What prevents an attacker from shifting bits from the ciphertext field into the AAD field in the decrypt path and yield the same HMAC tag? Unless you have an answer to this question, vanilla &quot;encrypt then MAC&quot; is not sufficient. You need a better-engineered construction than that.<p>Yes, you need a well-engineered construction.<p>&gt; Please let me know if something wasn&#x27;t clear, or you feel it was missing.<p>And yes, your linked post covers all this, but that is not the point: your summary of the linked post just claims superiority of AEAD (which I took as integrated AEAD modes) over EtM because of a functionality you claim is missing from the latter. But in the same way you need a well-engineered integrated AEAD to get any kind of security, you will need a well-engineered Encrypt-then-MAC-with-AD construction to get a secure construction. And here &quot;well-engineered&quot; means &quot;ensure unambiguous parsing of decryption inputs,&quot; we&#x27;re not talking about high-flying stuff that doesn&#x27;t have standard solutions.<p>In short: I accept the point of your linked post, and I agree with it. But I reject the claim that a functionality mismatch is what makes integrated AEAD better than a constructed EtM.</div><br/><div id="36628512" class="c"><input type="checkbox" id="c-36628512" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36627909">parent</a><span>|</span><a href="#36622809">next</a><span>|</span><label class="collapse" for="c-36628512">[-]</label><label class="expand" for="c-36628512">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This may expose a padding oracle, with all the nice attacks those things allow, depending on details of the application.<p>Please describe the padding oracle attack against AES-CTR you&#x27;re envisioning.<p>&gt; In short: I accept the point of your linked post, and I agree with it. But I reject the claim that a functionality mismatch is what makes integrated AEAD better than a constructed EtM.<p>Okay, I don&#x27;t think we disagree then. We&#x27;re just debating semantics at this point. :)</div><br/></div></div></div></div></div></div></div></div><div id="36622809" class="c"><input type="checkbox" id="c-36622809" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622392">parent</a><span>|</span><a href="#36622743">prev</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36622809">[-]</label><label class="expand" for="c-36622809">[4 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m missing something here or I&#x27;m just being dense but what exactly is the problem with EtM and AAD? Just use a suitable encoding like MAC(len(aad) || aad || E(plain))</div><br/><div id="36622863" class="c"><input type="checkbox" id="c-36622863" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622809">parent</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36622863">[-]</label><label class="expand" for="c-36622863">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to say &quot;just use a suitable encoding&quot;.<p>But when people say &quot;use AES-CBC + HMAC&quot; and cite Signal as an example, and Signal&#x27;s implementation does this: <a href="https:&#x2F;&#x2F;github.com&#x2F;signalapp&#x2F;Signal-Android&#x2F;blob&#x2F;main&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;thoughtcrime&#x2F;securesms&#x2F;crypto&#x2F;MasterCipher.java#L159-L176">https:&#x2F;&#x2F;github.com&#x2F;signalapp&#x2F;Signal-Android&#x2F;blob&#x2F;main&#x2F;app&#x2F;sr...</a><p>Well, when that happens, I feel the need to pipe in :)<p>If you&#x27;re careful enough to not implement a naive protocol that stitches AES+CBC and HMAC-SHA2 together (or, as tptacek put it in a podcast episode, throw some crypto potions into a cauldron and <i>see what happens</i>), you&#x27;re probably the minority of crypto-savvy people.</div><br/><div id="36623544" class="c"><input type="checkbox" id="c-36623544" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36622863">parent</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36623544">[-]</label><label class="expand" for="c-36623544">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But when people say &quot;use AES-CBC + HMAC&quot; and cite Signal as an example, and Signal&#x27;s implementation does this: <a href="https:&#x2F;&#x2F;github.com&#x2F;signalapp&#x2F;Signal-Android&#x2F;blob&#x2F;main&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;thoughtcrime&#x2F;securesms&#x2F;crypto&#x2F;MasterCipher.java#L159-L176">https:&#x2F;&#x2F;github.com&#x2F;signalapp&#x2F;Signal-Android&#x2F;blob&#x2F;main&#x2F;app&#x2F;sr...</a><p>That&#x27;s very vague and therefore not very helpful. Could you say what exactly is wrong with the code you linked?</div><br/><div id="36623588" class="c"><input type="checkbox" id="c-36623588" checked=""/><div class="controls bullet"><span class="by">soatok</span><span>|</span><a href="#36621868">root</a><span>|</span><a href="#36623544">parent</a><span>|</span><a href="#36627770">next</a><span>|</span><label class="collapse" for="c-36623588">[-]</label><label class="expand" for="c-36623588">[1 more]</label></div><br/><div class="children"><div class="content">It does exactly what I&#x27;ve been describing!<p>They provide AE, not AEAD.<p>They feed an IV and ciphertext into HMAC. They don&#x27;t feed additional authenticated data.<p>If someone followed Signal&#x27;s example, they either wouldn&#x27;t have AEAD, or they&#x27;re likely to make the exact mistake described in the post I linked above.<p>I don&#x27;t know how to be more helpful here. I&#x27;ve been only repeating myself.<p>AEAD modes let you bind a ciphertext to a context without increasing bandwidth. This is super important for database cryptography. Read more: <a href="https:&#x2F;&#x2F;soatok.blog&#x2F;2023&#x2F;03&#x2F;01&#x2F;database-cryptography-fur-the-rest-of-us&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;soatok.blog&#x2F;2023&#x2F;03&#x2F;01&#x2F;database-cryptography-fur-the...</a><p>Whether &quot;it&#x27;s not AEAD&quot; matters for an application depends on many factors. Signal doesn&#x27;t need it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36627770" class="c"><input type="checkbox" id="c-36627770" checked=""/><div class="controls bullet"><span class="by">cosmojg</span><span>|</span><a href="#36621868">prev</a><span>|</span><a href="#36626798">next</a><span>|</span><label class="collapse" for="c-36627770">[-]</label><label class="expand" for="c-36627770">[2 more]</label></div><br/><div class="children"><div class="content">If FIPS compliance is one of your primary motivations for using AES, why not use Ed25519 or Ed448 instead?</div><br/><div id="36627851" class="c"><input type="checkbox" id="c-36627851" checked=""/><div class="controls bullet"><span class="by">pingiun</span><span>|</span><a href="#36627770">parent</a><span>|</span><a href="#36626798">next</a><span>|</span><label class="collapse" for="c-36627851">[-]</label><label class="expand" for="c-36627851">[1 more]</label></div><br/><div class="children"><div class="content">those are signature algorithms. aes&#x2F;chacha are symmetric ciphers</div><br/></div></div></div></div><div id="36626798" class="c"><input type="checkbox" id="c-36626798" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#36627770">prev</a><span>|</span><a href="#36621873">next</a><span>|</span><label class="collapse" for="c-36626798">[-]</label><label class="expand" for="c-36626798">[5 more]</label></div><br/><div class="children"><div class="content">Do you _really_ need AES256 though? Just a large computation overhead while AES128 is extraordinarily secure already.<p>The conversation about nonce  sizes is 100% on point however. Why isn’t it at least the size of the key?</div><br/><div id="36628369" class="c"><input type="checkbox" id="c-36628369" checked=""/><div class="controls bullet"><span class="by">NohatCoder</span><span>|</span><a href="#36626798">parent</a><span>|</span><a href="#36626855">next</a><span>|</span><label class="collapse" for="c-36628369">[-]</label><label class="expand" for="c-36628369">[1 more]</label></div><br/><div class="children"><div class="content">AES has a key length and a round count. The speed of the cipher depend only on the round count. This suggestion takes a large key, but a moderate round count, making it only slightly slower than AES128-GCM.</div><br/></div></div><div id="36626855" class="c"><input type="checkbox" id="c-36626855" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36626798">parent</a><span>|</span><a href="#36628369">prev</a><span>|</span><a href="#36626970">next</a><span>|</span><label class="collapse" for="c-36626855">[-]</label><label class="expand" for="c-36626855">[1 more]</label></div><br/><div class="children"><div class="content">Because it predates awareness of how nonce-based AEADs are misused by developers. Which, in fairness, is true of most of the first generation of AEADs, including Chapoly --- XSalsa was a clever hack, not the original design.</div><br/></div></div><div id="36626970" class="c"><input type="checkbox" id="c-36626970" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36626798">parent</a><span>|</span><a href="#36626855">prev</a><span>|</span><a href="#36621873">next</a><span>|</span><label class="collapse" for="c-36626970">[-]</label><label class="expand" for="c-36626970">[2 more]</label></div><br/><div class="children"><div class="content">Is AES256 meaningfully slower than AES128 when you have AES-NI extensions?</div><br/><div id="36629089" class="c"><input type="checkbox" id="c-36629089" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36626798">root</a><span>|</span><a href="#36626970">parent</a><span>|</span><a href="#36621873">next</a><span>|</span><label class="collapse" for="c-36629089">[-]</label><label class="expand" for="c-36629089">[1 more]</label></div><br/><div class="children"><div class="content">Nah<p>Specifically, &quot;nah with OpenSSL on AMD or Intel boxes from the last decade&quot;:<p><pre><code>    AES-128 (ctr mode)  9.7 GB&#x2F;s
    AES-256 (ctr mode)  8.6 GB&#x2F;s (90 % as fast,
       not ~70 % as 10-vs-14 rounds would naively suggest)

    AES-128 (gcm mode)  12.4 GB&#x2F;s
    AES-256 (gcm mode)  10.8 GB&#x2F;s
</code></pre>
(plain CTR is slower than GCM because the GCM implementation in OpenSSL has received more attention than the counter mode implementation, simply because standalone counter mode is used a lot less)</div><br/></div></div></div></div></div></div><div id="36621873" class="c"><input type="checkbox" id="c-36621873" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36626798">prev</a><span>|</span><a href="#36624410">next</a><span>|</span><label class="collapse" for="c-36621873">[-]</label><label class="expand" for="c-36621873">[1 more]</label></div><br/><div class="children"><div class="content">AES-256-GCM runs at well above 10 GB&#x2F;s per core on semi-modern desktop&#x2F;server CPUs and the 128 variant isn’t actually 40% faster iirc. I think it was like 11 vs 13 GB&#x2F;s on the same hardware, not what 10-vs-14 rounds would seem to imply. Even chapoly is only around 3-4x slower.<p>(That’s gigabytes per second, not gigabits)</div><br/></div></div><div id="36624410" class="c"><input type="checkbox" id="c-36624410" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#36621873">prev</a><span>|</span><a href="#36623121">next</a><span>|</span><label class="collapse" for="c-36624410">[-]</label><label class="expand" for="c-36624410">[4 more]</label></div><br/><div class="children"><div class="content">Why are we even hashing the nonce in the first place? Don’t we have enough entropy these days to just pull what we need?</div><br/><div id="36625889" class="c"><input type="checkbox" id="c-36625889" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36624410">parent</a><span>|</span><a href="#36623121">next</a><span>|</span><label class="collapse" for="c-36625889">[-]</label><label class="expand" for="c-36625889">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an AES-based mode, so it only has the AES message block (and, implicitly, the key) to work with, and some of the bits in the message block need to hold the CTR counter. The problem is that leaves an uncomfortably low margin of random bits.</div><br/><div id="36625978" class="c"><input type="checkbox" id="c-36625978" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#36624410">root</a><span>|</span><a href="#36625889">parent</a><span>|</span><a href="#36623121">next</a><span>|</span><label class="collapse" for="c-36625978">[-]</label><label class="expand" for="c-36625978">[2 more]</label></div><br/><div class="children"><div class="content">I guess I never conceptually got onboard with the idea that hashing down more entropy is better than pulling the exact amount of good entropy. But I lack the formal qualifications to argue as much (or knowledge of a proof to the contrary). I know we like to be paranoid when things make us uncomfortable.</div><br/><div id="36626012" class="c"><input type="checkbox" id="c-36626012" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36624410">root</a><span>|</span><a href="#36625978">parent</a><span>|</span><a href="#36623121">next</a><span>|</span><label class="collapse" for="c-36626012">[-]</label><label class="expand" for="c-36626012">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an entropy question at all; it&#x27;s that the algorithm only gives you a fixed amount of bits (the key size plus the AES message block) to divide up, and if you only use the message block itself (as NIST GCM does) that&#x27;s not enough space to feel comfortable picking nonces at random due to e.g. the birthday problem.</div><br/></div></div></div></div></div></div></div></div><div id="36623121" class="c"><input type="checkbox" id="c-36623121" checked=""/><div class="controls bullet"><span class="by">barbegal</span><span>|</span><a href="#36624410">prev</a><span>|</span><a href="#36621980">next</a><span>|</span><label class="collapse" for="c-36623121">[-]</label><label class="expand" for="c-36623121">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If for example an application encrypts 2^48 messages under different 128-bit keys, and all messages start with the same few bytes, an attacker can build a lookup table, try and lookup the ciphertext of 2^64 keys, and have a 2^-16 chance to decrypt one message. Not good.<p>This is satire right? The computational and storage requirements to preform such an attack to just get a small probability of decrypting one message seem ludicrous.</div><br/><div id="36623305" class="c"><input type="checkbox" id="c-36623305" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36623121">parent</a><span>|</span><a href="#36623311">next</a><span>|</span><label class="collapse" for="c-36623305">[-]</label><label class="expand" for="c-36623305">[2 more]</label></div><br/><div class="children"><div class="content">Millions of terabyte disks of storage. Then repeat the attack a couple thousand times.<p>In cryptography, you don&#x27;t want &quot;ludicrously&quot; infeasible, as in the NSA can just about afford the hardware and do it, you want astronomically infeasible.</div><br/><div id="36624342" class="c"><input type="checkbox" id="c-36624342" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#36623121">root</a><span>|</span><a href="#36623305">parent</a><span>|</span><a href="#36623311">next</a><span>|</span><label class="collapse" for="c-36624342">[-]</label><label class="expand" for="c-36624342">[1 more]</label></div><br/><div class="children"><div class="content">And you want it to be so infeasible that even attacking a single message with perfect knowledge of all non-secrets is &quot;astronomically infeasible&quot;.<p>Its not enough to just make it astronomically infeasible to attack everyone.</div><br/></div></div></div></div></div></div><div id="36621980" class="c"><input type="checkbox" id="c-36621980" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36623121">prev</a><span>|</span><a href="#36622357">next</a><span>|</span><label class="collapse" for="c-36621980">[-]</label><label class="expand" for="c-36621980">[1 more]</label></div><br/><div class="children"><div class="content">I sketched out an extended nonce construction using AES-GCM with CBC-MAC last year (both of which are permitted by FIPS).<p><a href="https:&#x2F;&#x2F;soatok.blog&#x2F;2022&#x2F;12&#x2F;21&#x2F;extending-the-aes-gcm-nonce-without-nightmare-fuel" rel="nofollow noreferrer">https:&#x2F;&#x2F;soatok.blog&#x2F;2022&#x2F;12&#x2F;21&#x2F;extending-the-aes-gcm-nonce-w...</a><p>I never considered only using 11 rounds, though. That&#x27;d have a significant performance impact if we could.</div><br/></div></div><div id="36622357" class="c"><input type="checkbox" id="c-36622357" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#36621980">prev</a><span>|</span><a href="#36622425">next</a><span>|</span><label class="collapse" for="c-36622357">[-]</label><label class="expand" for="c-36622357">[3 more]</label></div><br/><div class="children"><div class="content">What does 11 mean?</div><br/><div id="36622450" class="c"><input type="checkbox" id="c-36622450" checked=""/><div class="controls bullet"><span class="by">zahllos</span><span>|</span><a href="#36622357">parent</a><span>|</span><a href="#36622416">next</a><span>|</span><label class="collapse" for="c-36622450">[-]</label><label class="expand" for="c-36622450">[1 more]</label></div><br/><div class="children"><div class="content">Number of rounds. AES128 uses 10 rounds, 192 uses 12 and 256 14. The proposal being to drop AES256 from 14 to 11 rounds.</div><br/></div></div><div id="36622416" class="c"><input type="checkbox" id="c-36622416" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#36622357">parent</a><span>|</span><a href="#36622450">prev</a><span>|</span><a href="#36622425">next</a><span>|</span><label class="collapse" for="c-36622416">[-]</label><label class="expand" for="c-36622416">[1 more]</label></div><br/><div class="children"><div class="content">11 rounds instead of 14 rounds.</div><br/></div></div></div></div></div></div></div></div></div></body></html>