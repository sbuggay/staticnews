<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fosstodon.org/@gabrielesvelto/110592904713090347">A large crash spike affecting Firefox users on Linux</a> <span class="domain">(<a href="https://fosstodon.org">fosstodon.org</a>)</span></div><div class="subtext"><span>sohkamyung</span> | <span>35 comments</span></div><br/><div><div id="36456058" class="c"><input type="checkbox" id="c-36456058" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#36456248">next</a><span>|</span><label class="collapse" for="c-36456058">[-]</label><label class="expand" for="c-36456058">[2 more]</label></div><br/><div class="children"><div class="content">~64 KiB of stack ought to be enough for anybody.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;84df9525b0c27f3ebc2ebb1864fa62a97fdedb7d&#x2F;arch&#x2F;x86&#x2F;mm&#x2F;fault.c#L1359">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;84df9525b0c27f3ebc2eb...</a></div><br/><div id="36456790" class="c"><input type="checkbox" id="c-36456790" checked=""/><div class="controls bullet"><span class="by">bibanez</span><span>|</span><a href="#36456058">parent</a><span>|</span><a href="#36456248">next</a><span>|</span><label class="collapse" for="c-36456790">[-]</label><label class="expand" for="c-36456790">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions this was fixed in Kernel 4.20</div><br/></div></div></div></div><div id="36456248" class="c"><input type="checkbox" id="c-36456248" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#36456058">prev</a><span>|</span><a href="#36456077">next</a><span>|</span><label class="collapse" for="c-36456248">[-]</label><label class="expand" for="c-36456248">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It is interesting though that we find ourselves working around a bug we did not introduce triggered by code we do not control.<p>I used to be part of a team developing a popular browser WYSIWYG editor. Every release of any of the supported browsers was a coin toss regarding introducing new bugs.<p>From this perspective developing for the still supported back then IE8 was easier, because there was no chance for it to ever change.</div><br/><div id="36456578" class="c"><input type="checkbox" id="c-36456578" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#36456248">parent</a><span>|</span><a href="#36456077">next</a><span>|</span><label class="collapse" for="c-36456578">[-]</label><label class="expand" for="c-36456578">[1 more]</label></div><br/><div class="children"><div class="content">Yes. But. We. Need. New. Features. Every. F...ing. Week.</div><br/></div></div></div></div><div id="36456077" class="c"><input type="checkbox" id="c-36456077" checked=""/><div class="controls bullet"><span class="by">kramerger</span><span>|</span><a href="#36456248">prev</a><span>|</span><a href="#36456559">next</a><span>|</span><label class="collapse" for="c-36456077">[-]</label><label class="expand" for="c-36456077">[3 more]</label></div><br/><div class="children"><div class="content">Kind of off topic:<p>How can we get Mastodon links like this to open in the Mastodon app?<p>On android this is decided by the url (apps can request certain urls to be forwarded to them) but since there are many different servers in fediverse that becomes impractical</div><br/><div id="36456441" class="c"><input type="checkbox" id="c-36456441" checked=""/><div class="controls bullet"><span class="by">shrx</span><span>|</span><a href="#36456077">parent</a><span>|</span><a href="#36456187">next</a><span>|</span><label class="collapse" for="c-36456441">[-]</label><label class="expand" for="c-36456441">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using Link Eye [1] which lets you open any url in the application of your choice. It&#x27;s fantastic, also enabling you to open youtube links in NewPipe.<p>[1] <a href="https:&#x2F;&#x2F;f-droid.org&#x2F;packages&#x2F;kuesji.link_eye.fdroid&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;f-droid.org&#x2F;packages&#x2F;kuesji.link_eye.fdroid&#x2F;</a></div><br/></div></div><div id="36456187" class="c"><input type="checkbox" id="c-36456187" checked=""/><div class="controls bullet"><span class="by">2Gkashmiri</span><span>|</span><a href="#36456077">parent</a><span>|</span><a href="#36456441">prev</a><span>|</span><a href="#36456559">next</a><span>|</span><label class="collapse" for="c-36456187">[-]</label><label class="expand" for="c-36456187">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ibb.co&#x2F;v4pw6rw" rel="nofollow noreferrer">https:&#x2F;&#x2F;ibb.co&#x2F;v4pw6rw</a>
This URL actually resolves in my android fedilab app so don&#x27;t know if this has hardcodrd instances or uses regex. It shouldn&#x27;t be difficult to build a regrx, I know of an app that did for peertube</div><br/></div></div></div></div><div id="36456559" class="c"><input type="checkbox" id="c-36456559" checked=""/><div class="controls bullet"><span class="by">arun-mani-j</span><span>|</span><a href="#36456077">prev</a><span>|</span><a href="#36456676">next</a><span>|</span><label class="collapse" for="c-36456559">[-]</label><label class="expand" for="c-36456559">[1 more]</label></div><br/><div class="children"><div class="content">I use Firefox downloaded from the official website as well as the Flatpak version on my Debian laptop. It crashes frequently, as in every 2 hours or so. I don&#x27;t do anything heavy on the browser except using it to read documentation. This has been an issue in the last two months and I don&#x27;t know what&#x27;s wrong...<p>Also, does anybody known why Firefox still depends on the deprecated libdbus-glib-1-2 [1] in Debian and based distros?<p>For example, try to uninstall the package. Then download the latest Firefox from their website [2]. Extract the archive, launch the executable inside it from a terminal. You will see an error message that it is unable to load the DBus library.<p>1 - <a href="https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;libdbus-glib-1-2" rel="nofollow noreferrer">https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;libdbus-glib-1-2</a><p>2 - <a href="https:&#x2F;&#x2F;www.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;new&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;new&#x2F;</a></div><br/></div></div><div id="36456676" class="c"><input type="checkbox" id="c-36456676" checked=""/><div class="controls bullet"><span class="by">pb82</span><span>|</span><a href="#36456559">prev</a><span>|</span><a href="#36455852">next</a><span>|</span><label class="collapse" for="c-36456676">[-]</label><label class="expand" for="c-36456676">[1 more]</label></div><br/><div class="children"><div class="content">Using Google Maps causes Firefox (114.0.2) and the whole OS to completely freeze within minutes on my Laptop. This started happening after I upgraded to Fedora 38. Not sure if this is caused by the same bug. Could be Gnome, Wayland, who knows. Has anyone had a similar experience?</div><br/></div></div><div id="36455852" class="c"><input type="checkbox" id="c-36455852" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36456676">prev</a><span>|</span><a href="#36456648">next</a><span>|</span><label class="collapse" for="c-36455852">[-]</label><label class="expand" for="c-36455852">[4 more]</label></div><br/><div class="children"><div class="content">20000 variables in a function? Even for machine generated code that sounds like an exaggeration. Anybody here who knows the reason?</div><br/><div id="36456149" class="c"><input type="checkbox" id="c-36456149" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36455852">parent</a><span>|</span><a href="#36455974">next</a><span>|</span><label class="collapse" for="c-36456149">[-]</label><label class="expand" for="c-36456149">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exactly variables. The Bugzilla entry is more specific: &quot;... entails copying all the values that are currently on the interpreter&#x27;s stack (arguments, local variables, intermediate results) from the heap onto the native stack.&quot; <a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1839139#c8" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1839139#c8</a><p>So it may be a large function with lots of temporary values visible in scope. If I understand correctly, local lambdas would also count and they have their own captured context. I&#x27;m sure it&#x27;s possible to find a pathological-but-not-unreasonable way to reproduce it.</div><br/><div id="36456396" class="c"><input type="checkbox" id="c-36456396" checked=""/><div class="controls bullet"><span class="by">IainIreland</span><span>|</span><a href="#36455852">root</a><span>|</span><a href="#36456149">parent</a><span>|</span><a href="#36455974">next</a><span>|</span><label class="collapse" for="c-36456396">[-]</label><label class="expand" for="c-36456396">[1 more]</label></div><br/><div class="children"><div class="content">I wrote that comment. One other possibility: if you use spread syntax to call a function with a large array (eg `foo(...Array(20000))`), then all those arguments will be pushed on the stack.<p>(I didn&#x27;t dig into the specifics of the Google code because, as weird as it is to have 20000 stack values, we really <i>should</i> be able to handle it. This was, at the end of the day, a bug in our stack probing code.)</div><br/></div></div></div></div><div id="36455974" class="c"><input type="checkbox" id="c-36455974" checked=""/><div class="controls bullet"><span class="by">idle_zealot</span><span>|</span><a href="#36455852">parent</a><span>|</span><a href="#36456149">prev</a><span>|</span><a href="#36456648">next</a><span>|</span><label class="collapse" for="c-36455974">[-]</label><label class="expand" for="c-36455974">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know for sure, but it sounds like the result of a JS obfuscater. I know Google Docs ships obfuscated code so I wouldn&#x27;t be surprised if Google Image Search does too.</div><br/></div></div></div></div><div id="36456648" class="c"><input type="checkbox" id="c-36456648" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#36455852">prev</a><span>|</span><a href="#36456618">next</a><span>|</span><label class="collapse" for="c-36456648">[-]</label><label class="expand" for="c-36456648">[1 more]</label></div><br/><div class="children"><div class="content">I think I had one crash with Firefox on Linux during the past 6 years and that was a weird edge case where I tried to do something during an update process.</div><br/></div></div><div id="36456618" class="c"><input type="checkbox" id="c-36456618" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#36456648">prev</a><span>|</span><a href="#36455977">next</a><span>|</span><label class="collapse" for="c-36456618">[-]</label><label class="expand" for="c-36456618">[1 more]</label></div><br/><div class="children"><div class="content">I use the Firefox from the Ubuntu Mozilla Team&#x27;s PPA and I haven&#x27;t seen any crashes at all.<p><a href="https:&#x2F;&#x2F;launchpad.net&#x2F;~mozillateam&#x2F;+archive&#x2F;ubuntu&#x2F;ppa" rel="nofollow noreferrer">https:&#x2F;&#x2F;launchpad.net&#x2F;~mozillateam&#x2F;+archive&#x2F;ubuntu&#x2F;ppa</a></div><br/></div></div><div id="36455977" class="c"><input type="checkbox" id="c-36455977" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#36456618">prev</a><span>|</span><a href="#36456379">next</a><span>|</span><label class="collapse" for="c-36455977">[-]</label><label class="expand" for="c-36455977">[13 more]</label></div><br/><div class="children"><div class="content">This sounds like blameshifting to me. Javascript is untrusted code, so it&#x27;s on Firefox to make sure to handle any craziness gracefully.<p>Stack probing is kind of a weird thing though. I&#x27;m kind of surprised C++ compiler isn&#x27;t doing that properly. Are they using inline assembly for speed?</div><br/><div id="36456107" class="c"><input type="checkbox" id="c-36456107" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36455977">parent</a><span>|</span><a href="#36456073">next</a><span>|</span><label class="collapse" for="c-36456107">[-]</label><label class="expand" for="c-36456107">[2 more]</label></div><br/><div class="children"><div class="content">It would only be shifting the blame if they weren’t going to work around the problem in Firefox itself.<p>The C++ compiler may or may not implement stack probing correctly, but this bug is in the Javascript JIT compiler. The fix is to make the JIT compiler update the stack pointer register each time through the loop so that if a page fault happens the kernel won’t see a huge amount of stack get allocated all in one go. Instead it’ll see several page faults each asking for a smaller amount which it is happy to grant.<p>See <a href="https:&#x2F;&#x2F;phabricator.services.mozilla.com&#x2F;rMOZILLACENTRAL304d01f5488b384023a1c647e8c5c2f5cee32a5b" rel="nofollow noreferrer">https:&#x2F;&#x2F;phabricator.services.mozilla.com&#x2F;rMOZILLACENTRAL304d...</a></div><br/></div></div><div id="36456073" class="c"><input type="checkbox" id="c-36456073" checked=""/><div class="controls bullet"><span class="by">fathyb</span><span>|</span><a href="#36455977">parent</a><span>|</span><a href="#36456107">prev</a><span>|</span><a href="#36456100">next</a><span>|</span><label class="collapse" for="c-36456073">[-]</label><label class="expand" for="c-36456073">[9 more]</label></div><br/><div class="children"><div class="content">Agreed that the problem here is Firefox, untrusted JS code should not cause a crash.<p>For the probing, according to the code:<p><pre><code>    &#x2F;&#x2F; Can&#x27;t push large frames blindly on windows, so we must touch frame memory
    &#x2F;&#x2F; incrementally, with no more than 4096 - 1 bytes between touches.
    &#x2F;&#x2F;
    &#x2F;&#x2F; This is used across all platforms for simplicity.
</code></pre>
<a href="https:&#x2F;&#x2F;searchfox.org&#x2F;mozilla-central&#x2F;rev&#x2F;c936f47f3a629ae49a4d528d3366bf29f2d4e4a7&#x2F;js&#x2F;src&#x2F;jit&#x2F;MacroAssembler.cpp#6585-6612" rel="nofollow noreferrer">https:&#x2F;&#x2F;searchfox.org&#x2F;mozilla-central&#x2F;rev&#x2F;c936f47f3a629ae49a...</a></div><br/><div id="36456239" class="c"><input type="checkbox" id="c-36456239" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456073">parent</a><span>|</span><a href="#36456161">next</a><span>|</span><label class="collapse" for="c-36456239">[-]</label><label class="expand" for="c-36456239">[5 more]</label></div><br/><div class="children"><div class="content">Technically of course Firefox failed to live with an old kernel and insane JS code.<p>Morally it&#x27;s Google. Google is like Bitcoin. A huge  natural ressource hog for a questionable benefit. Here the benefit is tracking users to make advertising billions. For that goal a billion of smart phones need several extra GB of memory an significantly larger batteries. What is the ecological footprint of that?<p>Typing on a seven year old smart phone with 2 GB (SailfishOS, so yes it is maintained. Maybe not perfectly, but better than many Androids half as old). It works quite well on reasonable pages even without add blocking. Of course super heavy pages won&#x27;t work and for  Google search I haven&#x27;t even consented. Occasionally 
I get reminded of that when some site embeds it. Well, a good reminder for me not to use them.</div><br/><div id="36456471" class="c"><input type="checkbox" id="c-36456471" checked=""/><div class="controls bullet"><span class="by">fathyb</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456239">parent</a><span>|</span><a href="#36456161">next</a><span>|</span><label class="collapse" for="c-36456471">[-]</label><label class="expand" for="c-36456471">[4 more]</label></div><br/><div class="children"><div class="content">This does not appear that crazy to me. In fact, today it&#x27;s almost a recommended practice for large web applications and it&#x27;s called &quot;tree shaking&quot;. ECMAScript modules are inlined into the same scope. It makes the JIT work easier because it now works with symbols instead of `require(foo).bar` calls to speculate on. It makes most web apps run better, both in bandwidth and compute.<p>It&#x27;s very likely to have affected users on other websites, but Google is a common denominator for debugging.<p>My uneducated guess: they&#x27;re using the Google Closure Compiler to make smaller JavaScript bundles. It saves some bandwidth and allows for better optimizations. It seems like a reasonable engineering decision to ensure product decisions don&#x27;t affect the user experience too negatively, something a lot of us are familiar with..</div><br/><div id="36456663" class="c"><input type="checkbox" id="c-36456663" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456471">parent</a><span>|</span><a href="#36456540">next</a><span>|</span><label class="collapse" for="c-36456663">[-]</label><label class="expand" for="c-36456663">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, today it&#x27;s almost a recommended practice for large web applications and it&#x27;s called &quot;tree shaking&quot;. ECMAScript modules are inlined into the same scope. It makes the JIT work easier because it now works with symbols instead of `require(foo).bar` calls to speculate on. It makes most web apps run better, both in bandwidth and compute.<p>That&#x27;s bundling, not tree shaking.  Tree shaking is an optional additional process during bundling where unreachable code is automatically removed.</div><br/><div id="36456732" class="c"><input type="checkbox" id="c-36456732" checked=""/><div class="controls bullet"><span class="by">fathyb</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456663">parent</a><span>|</span><a href="#36456540">next</a><span>|</span><label class="collapse" for="c-36456732">[-]</label><label class="expand" for="c-36456732">[1 more]</label></div><br/><div class="children"><div class="content">Bundling does not inline all symbols into a single scope, tree shaking does. I was one of the people implementing tree shaking in the first Parcel bundler. <a href="https:&#x2F;&#x2F;github.com&#x2F;parcel-bundler&#x2F;parcel&#x2F;pull&#x2F;1135">https:&#x2F;&#x2F;github.com&#x2F;parcel-bundler&#x2F;parcel&#x2F;pull&#x2F;1135</a></div><br/></div></div></div></div><div id="36456540" class="c"><input type="checkbox" id="c-36456540" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456471">parent</a><span>|</span><a href="#36456663">prev</a><span>|</span><a href="#36456161">next</a><span>|</span><label class="collapse" for="c-36456540">[-]</label><label class="expand" for="c-36456540">[1 more]</label></div><br/><div class="children"><div class="content">Right, optimization is good.<p>But first building insanely heavy functionality and then optimizing it is not sustainable approach.<p>The background is of course that increasingly heavy function is moved into the client. Technically and especially economically this makes sense for Google. But the environmental footprint is outsourced to client devices. Greenwashing in a way. Avoidance of computing is a better solution than all types of optimizations. Not everything that is technically feasible is good for the planet and mankind.</div><br/></div></div></div></div></div></div><div id="36456161" class="c"><input type="checkbox" id="c-36456161" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456073">parent</a><span>|</span><a href="#36456239">prev</a><span>|</span><a href="#36456100">next</a><span>|</span><label class="collapse" for="c-36456161">[-]</label><label class="expand" for="c-36456161">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I got that far but then I wasn&#x27;t sure what exactly that was doing. Normal C++ doesn&#x27;t directly move stack pointers around and do manual probing, so I was idly wondering whether those calls hid some inline assembly or how they worked.<p>Edit: Or perhaps that is not the stack of the C++ program but rather than stack of the Javascript program.</div><br/><div id="36456421" class="c"><input type="checkbox" id="c-36456421" checked=""/><div class="controls bullet"><span class="by">IainIreland</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456161">parent</a><span>|</span><a href="#36456328">next</a><span>|</span><label class="collapse" for="c-36456421">[-]</label><label class="expand" for="c-36456421">[1 more]</label></div><br/><div class="children"><div class="content">In general, there&#x27;s no difference between the stack of the C++ program and the stack of the JS program. When SpiderMonkey just-in-time compiles a JS function, the result is native code that creates a stack frame on the same stack as the C++ code that implements SpiderMonkey. JS code and C++ code can be semi-arbitrarily interleaved on the stack: JS calls C++ calls JS calls C++...<p>The one exception about sharing the same stack is that the first few iterations of a function run in an interpreter implemented in C++, and that interpreter has its own stack that we heap-allocate. This particular bug occurred during the transition from the C++ interpreter to JIT code.</div><br/></div></div><div id="36456328" class="c"><input type="checkbox" id="c-36456328" checked=""/><div class="controls bullet"><span class="by">fathyb</span><span>|</span><a href="#36455977">root</a><span>|</span><a href="#36456161">parent</a><span>|</span><a href="#36456421">prev</a><span>|</span><a href="#36456100">next</a><span>|</span><label class="collapse" for="c-36456328">[-]</label><label class="expand" for="c-36456328">[1 more]</label></div><br/><div class="children"><div class="content">It does hide some assembly. Those calls are calling an assembler to generate native code at runtime for JIT compilation. The C++ compiler compiles an assembler, but this assembler runs at runtime. `MacroAssembler` itself is architecture independent, and calls into functions implemented in back-ends such as `MacroAssemblerARM` and `MacroAssemblerX64`.<p>So the code in this function is not performing the stack-probing, it generates code to perform it instead.</div><br/></div></div></div></div></div></div><div id="36456100" class="c"><input type="checkbox" id="c-36456100" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36455977">parent</a><span>|</span><a href="#36456073">prev</a><span>|</span><a href="#36456379">next</a><span>|</span><label class="collapse" for="c-36456100">[-]</label><label class="expand" for="c-36456100">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what Firefox could have done in this case beyond just killing off the tab.  The issue was a check in old kernels that was being triggered by some insane code.<p>This example had me remembering the discussion from earlier today about why modern code is so slow even though the machines are so fast.  I doubt there were many Win32 programs that attempted to pass in 20,000 parameters to a function.</div><br/></div></div></div></div><div id="36456388" class="c"><input type="checkbox" id="c-36456388" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#36456379">prev</a><span>|</span><a href="#36456247">next</a><span>|</span><label class="collapse" for="c-36456388">[-]</label><label class="expand" for="c-36456388">[2 more]</label></div><br/><div class="children"><div class="content">Compilers generating stack probes for large stack allocations has been a thing for decades. It was required in Windows 95 for 32-bit applications, and you&#x27;d do that on a page (4k) granularity.<p>I am still in the dark as to what the bug was here. Did Firefox stop doing probes for JIT code? Not do them at all, because most JS stack frames are small?</div><br/><div id="36456729" class="c"><input type="checkbox" id="c-36456729" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36456388">parent</a><span>|</span><a href="#36456247">next</a><span>|</span><label class="collapse" for="c-36456729">[-]</label><label class="expand" for="c-36456729">[1 more]</label></div><br/><div class="children"><div class="content">Firefox was probing ahead in increments of 2048 bytes in order to ensure that the stack was allocated, but it left the stack pointer at the end of the stack for that whole time. This usually worked ok, but certain versions of Linux will bail if the stack probe is greater than 64kb+256b away from the stack pointer. The new code moves the stack pointer incrementally so that the probe is never more than a single page from the stack pointer.<p><a href="https:&#x2F;&#x2F;phabricator.services.mozilla.com&#x2F;rMOZILLACENTRAL304d01f5488b384023a1c647e8c5c2f5cee32a5b" rel="nofollow noreferrer">https:&#x2F;&#x2F;phabricator.services.mozilla.com&#x2F;rMOZILLACENTRAL304d...</a></div><br/></div></div></div></div><div id="36456247" class="c"><input type="checkbox" id="c-36456247" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#36456388">prev</a><span>|</span><label class="collapse" for="c-36456247">[-]</label><label class="expand" for="c-36456247">[3 more]</label></div><br/><div class="children"><div class="content">Come on now! &quot;a peculiar interpreted code&quot; crashes your interpreter and you blame those that (allegedly) auto generated it? I realise there is a bit of tongue in cheek in there and Firefox is an amazing product, but although it&#x27;s certainly not normal for a function to declare 20k variables it is not outside the realm of the language. Furthermore, 20k is not that much if you take the amounts of RAM current devices have.<p>Don&#x27;t get me wrong. I don&#x27;t think assigning blame is the most important thing to do when troubleshooting. I&#x27;d rather not, but when that process starts it should be factual.<p>So, sorry, its not Google&#x27;s fault... Then we also throw Linux under the bus. &quot;it&#x27;s not our code, it&#x27;s Linus&quot; here is the code. But, that Linux kernel code that kills a process if it accesses too far from it&#x27;s stack pointer has the following comment:<p>&quot;Accessing the stack below %sp is always a bug (...)&quot;<p>I haven&#x27;t got time to look at the history how it was changed and why in the Linux kernel and it became &quot;not a bug&quot;. If someone knows more, please do explain.<p>So is it a &quot;bug in Firefox&quot; Or &quot;bug in old Linux&quot;? I can&#x27;t say with absolute certainty without researching how exactly the stack allocation in old Linux kernel works, how is it documented etc.<p>So if anything I&#x27;d thank Google for exposing the bug ;-)<p>On a side note, I&#x27;ve recently experienced a similar JS&#x2F;firefox&#x2F;web site bug. There is this open-source ecommerce software called shopware. They use symfony (yes, PHP i know...) and the most recent major version simply freezes Firefox when one goes to the admin interface and looses connectivity. Not just freezing one tab, no, freezes entire Firefox, multiple open windows. This is on up to date Arch with a new Linux kernel so it&#x27;s definitely not this issue,but it does happen in Firefox and not in Chrome.<p>JavaScript bugs like this are hard to find. I think AI may be one tool that will help us find them faster (intentionally or not).</div><br/><div id="36456306" class="c"><input type="checkbox" id="c-36456306" checked=""/><div class="controls bullet"><span class="by">outwit</span><span>|</span><a href="#36456247">parent</a><span>|</span><label class="collapse" for="c-36456306">[-]</label><label class="expand" for="c-36456306">[2 more]</label></div><br/><div class="children"><div class="content">It does seem to me that Google is intentionally refusing to test their websites in anything other than Chrome. Even without AI... It can afford to pay a handful of people to test in Firefox and Safari. But will it?</div><br/><div id="36456319" class="c"><input type="checkbox" id="c-36456319" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36456247">root</a><span>|</span><a href="#36456306">parent</a><span>|</span><label class="collapse" for="c-36456319">[-]</label><label class="expand" for="c-36456319">[1 more]</label></div><br/><div class="children"><div class="content">To be fair this crash is only happening with older kernels. I wouldn’t expect them to test their website in every version of Firefox running on every version of the Linux kernel. Not even Mozilla does that.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>