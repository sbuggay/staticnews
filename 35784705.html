<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683104453332" as="style"/><link rel="stylesheet" href="styles.css?v=1683104453332"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.sulami.xyz/posts/type-level-programming/">What Is Type-Level Programming?</a> <span class="domain">(<a href="https://blog.sulami.xyz">blog.sulami.xyz</a>)</span></div><div class="subtext"><span>bo0tzz</span> | <span>19 comments</span></div><br/><div><div id="35799273" class="c"><input type="checkbox" id="c-35799273" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#35799119">next</a><span>|</span><label class="collapse" for="c-35799273">[-]</label><label class="expand" for="c-35799273">[1 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong, but I see nothing in the Rust example that couldn&#x27;t just as well be implemented in C++.<p>A comparison to C would have made more sense.</div><br/></div></div><div id="35799119" class="c"><input type="checkbox" id="c-35799119" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#35799273">prev</a><span>|</span><a href="#35799132">next</a><span>|</span><label class="collapse" for="c-35799119">[-]</label><label class="expand" for="c-35799119">[2 more]</label></div><br/><div class="children"><div class="content">This is very interesting and could lead to some futuristic programming technology.<p>I kind of want to plot the state space of a program to see all available states.<p>In my exploration of distributed systems, microservices and multithreaded systems, it is extremely helpful to try and see what potential states the system can be in. Global and local reasoning of these kinds of software is rather difficult.<p>I&#x27;ve written about value tracing but I&#x27;ve not heard of treating values as types. I would love to be able to see the trajectory of a value through different states - such as membership to different collections. For example, if you have different collections or sets and items are removed from one collection and added to the other.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas4#571-value-calculus-variable-value-tracing">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas4#571-value-calculus-varia...</a><p>I&#x27;ve never written a TLA+ specification and I&#x27;m a complete beginner to this space but I&#x27;ve been trying to understand the dining philosophers one. TLA+ Toolbox is aware of discrete states in the state space, which is absolutely awesome. Types can inform us about future possible valid states.<p>I began writing a visualisation of memory and animated the movement of memory around to try reveal patterns. If you think of memory as state space, you can see movements of memory as picking things up and putting them down.<p><a href="https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;ProgrammingRTS#index.html">https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;ProgrammingRTS#index.html</a><p>If we see types or values as positions, we can create animations of the state space unfolding in front of us. This is the dream.<p>(My plan is to write a programming simulation that is controlled similar to a real time strategy game as an alternative form of programming)</div><br/></div></div><div id="35799132" class="c"><input type="checkbox" id="c-35799132" checked=""/><div class="controls bullet"><span class="by">lemper</span><span>|</span><a href="#35799119">prev</a><span>|</span><a href="#35799346">next</a><span>|</span><label class="collapse" for="c-35799132">[-]</label><label class="expand" for="c-35799132">[1 more]</label></div><br/><div class="children"><div class="content">is the article not finished already? it feels abruptly ended.</div><br/></div></div><div id="35799346" class="c"><input type="checkbox" id="c-35799346" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#35799132">prev</a><span>|</span><a href="#35799140">next</a><span>|</span><label class="collapse" for="c-35799346">[-]</label><label class="expand" for="c-35799346">[1 more]</label></div><br/><div class="children"><div class="content">This sort of thing is something we abused about Rust quite some time ago to make safer interfaces to low-level hardware.<p><a href="https:&#x2F;&#x2F;blog.auxon.io&#x2F;2019&#x2F;10&#x2F;25&#x2F;type-level-registers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.auxon.io&#x2F;2019&#x2F;10&#x2F;25&#x2F;type-level-registers&#x2F;</a></div><br/></div></div><div id="35799140" class="c"><input type="checkbox" id="c-35799140" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#35799346">prev</a><span>|</span><a href="#35799138">next</a><span>|</span><label class="collapse" for="c-35799140">[-]</label><label class="expand" for="c-35799140">[1 more]</label></div><br/><div class="children"><div class="content">I am really thinking about going all Rust with embedded and it is becoming more and more viable as time moves foreward.<p>It can still at times be a little convoluted to get a random MCU to the point where the code runs and for &quot;I just want it to do $X&quot;-style projects there is too much you need to implement yourself.<p>But it already has gotten better since I started observing it and I can only assume this trend will continue.</div><br/></div></div><div id="35799138" class="c"><input type="checkbox" id="c-35799138" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#35799140">prev</a><span>|</span><label class="collapse" for="c-35799138">[-]</label><label class="expand" for="c-35799138">[12 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;This looks fine, but what happens if you do not get the pin mode right, for any of many possible reasons?&quot;<p>This is such a contrived and pathetic example. None of it has anything to do with C++ or Rust. It was a decision of whomever wrote pin access libraries. In either of the languages mentioned there is absolutely no problem creating an interface that would return particular pin in &quot;right&quot; state ready to be operated on. Neither of the languages also prohibit fuck up by defining poor access interface.<p>I think author would do much better off not writing articles like this one.</div><br/><div id="35799159" class="c"><input type="checkbox" id="c-35799159" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#35799138">parent</a><span>|</span><a href="#35799157">next</a><span>|</span><label class="collapse" for="c-35799159">[-]</label><label class="expand" for="c-35799159">[4 more]</label></div><br/><div class="children"><div class="content">Ok, that was harsh, but I was excited and wanted to get to the meat of the article but then it just ended.<p>I was thinking, &quot;that&#x27;s not how I would design a C++ interface&quot;. I still don&#x27;t understand what these Rust types are good for, but I want to know.<p>I miss how in Ada you can define which values an int can have. Can you do that in Rust?</div><br/><div id="35799640" class="c"><input type="checkbox" id="c-35799640" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799159">parent</a><span>|</span><a href="#35799428">next</a><span>|</span><label class="collapse" for="c-35799640">[-]</label><label class="expand" for="c-35799640">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re looking for dependent types and while Rust has a limited form, it doesn&#x27;t have them fully. Idris does, on the other hand.</div><br/></div></div><div id="35799428" class="c"><input type="checkbox" id="c-35799428" checked=""/><div class="controls bullet"><span class="by">proto_lambda</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799159">parent</a><span>|</span><a href="#35799640">prev</a><span>|</span><a href="#35799372">next</a><span>|</span><label class="collapse" for="c-35799428">[-]</label><label class="expand" for="c-35799428">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I miss how in Ada you can define which values an int can have. Can you do that in Rust?<p>yes, kind of: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;deranged" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;deranged</a><p>It&#x27;ll take another while until const generics on stable are advanced enough to make this properly usable, such that e.g. `RangedU32&lt;3, 10&gt; + RangedU32&lt;5, 6&gt; = RangedU32&lt;8, 16&gt;`.</div><br/></div></div></div></div><div id="35799157" class="c"><input type="checkbox" id="c-35799157" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#35799138">parent</a><span>|</span><a href="#35799159">prev</a><span>|</span><a href="#35799510">next</a><span>|</span><label class="collapse" for="c-35799157">[-]</label><label class="expand" for="c-35799157">[3 more]</label></div><br/><div class="children"><div class="content">But a strongly typed language allows you to check for that error in <i>compile time</i>. As someone who programs embedded I can assure you that you <i>constantly</i> run into that type of error and I could really live without it.<p>So if people could also do that in C&#x2F;C++ they are apparently not doing it.</div><br/><div id="35799344" class="c"><input type="checkbox" id="c-35799344" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799157">parent</a><span>|</span><a href="#35799510">next</a><span>|</span><label class="collapse" for="c-35799344">[-]</label><label class="expand" for="c-35799344">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;So if people could also do that in C&#x2F;C++ they are apparently not doing it.&quot;<p>Maybe because they do not feel that it is worth doing. It maybe poor decision on their side but it has nothing to do with the implementation language. From a practical standpoint - I programmed enough microcontrollers and frankly initializing pin for particular mode before using it is hardwired into my brain. I do not remember ever having this type of error in my code. In the end if you do not like it you can always roll out your very own &quot;safe&quot; version. Just make sure your &quot;safe&quot; version does not have bugs either.</div><br/><div id="35799627" class="c"><input type="checkbox" id="c-35799627" checked=""/><div class="controls bullet"><span class="by">throwbadubadu</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799344">parent</a><span>|</span><a href="#35799510">next</a><span>|</span><label class="collapse" for="c-35799627">[-]</label><label class="expand" for="c-35799627">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, this is a lot for something rarely going wrong,.and if going wrong pretty apparent what&#x27;s wrong..<p>Also, that approach would need quite some extension for modern capabilities of pins and conflicting options across multiple registers (pin dir, pin mux and what else driver options)..
Also what about those pins you really need to be use in both directions (e.g. one wire protocol, or pins where you have your own mux behind), how to do that? The current approach does not look like supporting switching at runtime.. another complexity level added..</div><br/></div></div></div></div></div></div><div id="35799510" class="c"><input type="checkbox" id="c-35799510" checked=""/><div class="controls bullet"><span class="by">laci37</span><span>|</span><a href="#35799138">parent</a><span>|</span><a href="#35799157">prev</a><span>|</span><a href="#35799293">next</a><span>|</span><label class="collapse" for="c-35799510">[-]</label><label class="expand" for="c-35799510">[2 more]</label></div><br/><div class="children"><div class="content">I think the author has left out a big piece why Rust enables better interface here: ownership. In C++ could the compile time checks prevent me from creating both an input and output type working on the same pin?</div><br/><div id="35799532" class="c"><input type="checkbox" id="c-35799532" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799510">parent</a><span>|</span><a href="#35799293">next</a><span>|</span><label class="collapse" for="c-35799532">[-]</label><label class="expand" for="c-35799532">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Hell we did such things in C and a little custom build tool support.</div><br/></div></div></div></div><div id="35799293" class="c"><input type="checkbox" id="c-35799293" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#35799138">parent</a><span>|</span><a href="#35799510">prev</a><span>|</span><label class="collapse" for="c-35799293">[-]</label><label class="expand" for="c-35799293">[2 more]</label></div><br/><div class="children"><div class="content">It’s not a contrived example. It’s the canonical embedded hello world, written against two different libraries.<p>At any rate, the C++&#x2F;Rust part can be a distraction, because the interesting point here is the technique of encoding program state in the type system.</div><br/><div id="35799371" class="c"><input type="checkbox" id="c-35799371" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#35799138">root</a><span>|</span><a href="#35799293">parent</a><span>|</span><label class="collapse" for="c-35799371">[-]</label><label class="expand" for="c-35799371">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;At any rate, the C++&#x2F;Rust part can be a distraction&quot;<p>that was exactly my point.<p>&gt;&quot;interesting point here is the technique of encoding program state in the type system.&quot;<p>It is &quot;interesting&quot; but there is nothing new about it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>