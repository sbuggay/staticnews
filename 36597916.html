<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688634067077" as="style"/><link rel="stylesheet" href="styles.css?v=1688634067077"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://langdev.stackexchange.com/questions/2015/how-can-we-compare-expressive-power-between-two-turing-complete-languages">How can we compare expressive power between two Turing-complete languages?</a> <span class="domain">(<a href="https://langdev.stackexchange.com">langdev.stackexchange.com</a>)</span></div><div class="subtext"><span>joebiden2</span> | <span>44 comments</span></div><br/><div><div id="36613149" class="c"><input type="checkbox" id="c-36613149" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36613082">next</a><span>|</span><label class="collapse" for="c-36613149">[-]</label><label class="expand" for="c-36613149">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div><div id="36613082" class="c"><input type="checkbox" id="c-36613082" checked=""/><div class="controls bullet"><span class="by">paldepind2</span><span>|</span><a href="#36613149">prev</a><span>|</span><a href="#36611990">next</a><span>|</span><label class="collapse" for="c-36613082">[-]</label><label class="expand" for="c-36613082">[1 more]</label></div><br/><div class="children"><div class="content">In my humble opinion the SO question and some of the comments here conflate &quot;expressive&quot; as it&#x27;s used when talking about the theory of computation and &quot;expressive&quot; as it&#x27;s used when comparing various high-level programming languages. The former has a very precise (but also quite narrow) formal meaning and the later is just the normal English work &quot;expressive&quot;. They mean very different things so I think it&#x27;s a bit unfortunate that we use the same word for both because some people get the idea that they&#x27;re somehow related when they&#x27;re really not. I mean, in a way regular expressions are more expressive than turing machines but turing machine are more expressive than regular expressions.</div><br/></div></div><div id="36611990" class="c"><input type="checkbox" id="c-36611990" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#36613082">prev</a><span>|</span><a href="#36612705">next</a><span>|</span><label class="collapse" for="c-36611990">[-]</label><label class="expand" for="c-36611990">[5 more]</label></div><br/><div class="children"><div class="content">The answer given is thorough, but somewhat abstract. As a more concrete response, go to projecteuler.net, solve a problem, and go to the discussion board for it.<p>For most problems:<p>There will be a ~80 line C solution.<p>There will be a ~120 line Java solution.<p>There will be a ~50 line Javascript solution.<p>There will be a ~40 line Visual Basic solution.<p>There will be a ~30 line PHP solution.<p>There will be a ~25 line raw Python solution.<p>There will be a ~20 line typical Lisp solution.<p>There will be a ~15 line Python solution using some obscure library.<p>There will be a ~10 line Lisp solution using some clever hack.<p>There will be a 1 line J solution.<p>(other languages omitted, and line estimates are pulled out of my ass)<p>Whether due to unfamiliarity or genuine opacity, some of the shorter solutions will be incomprehensible to some (most?) people. So while <i>technically</i> more expressive, what good is that if you can&#x27;t read the solution, let alone write it?<p>But yeah -- typical line count proxies (inversely) for expressiveness.</div><br/><div id="36612554" class="c"><input type="checkbox" id="c-36612554" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#36611990">parent</a><span>|</span><a href="#36612082">next</a><span>|</span><label class="collapse" for="c-36612554">[-]</label><label class="expand" for="c-36612554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Whether due to unfamiliarity or genuine opacity, some of the shorter solutions will be incomprehensible to some (most?) people. So while technically more expressive, what good is that if you can&#x27;t read the solution, let alone write it?<p>How many people can read advanced math formulas? Mostly none. So what good is it that they are used?<p>The answer is, it doesn&#x27;t really matter if outsiders can&#x27;t read it. Yes, it increases the hurdle to enter the field, but the benefits drastically outweight the initial learning in the long term.<p>Same is true (even more so, I would say) for programming languages.</div><br/></div></div><div id="36612082" class="c"><input type="checkbox" id="c-36612082" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36611990">parent</a><span>|</span><a href="#36612554">prev</a><span>|</span><a href="#36612633">next</a><span>|</span><label class="collapse" for="c-36612082">[-]</label><label class="expand" for="c-36612082">[2 more]</label></div><br/><div class="children"><div class="content">IMO, the line count is more a function of the &quot;base&#x2F;standard&quot; libraries as opposed to expressiveness</div><br/><div id="36612103" class="c"><input type="checkbox" id="c-36612103" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#36611990">root</a><span>|</span><a href="#36612082">parent</a><span>|</span><a href="#36612633">next</a><span>|</span><label class="collapse" for="c-36612103">[-]</label><label class="expand" for="c-36612103">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, the expressiveness of base Python is less than Python + whatever libraries you like.<p>But the difference in line count between Java + a bunch of libraries and Python + a bunch of libraries is a lot. And the J one-liners rarely involve libraries.</div><br/></div></div></div></div><div id="36612633" class="c"><input type="checkbox" id="c-36612633" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#36611990">parent</a><span>|</span><a href="#36612082">prev</a><span>|</span><a href="#36612705">next</a><span>|</span><label class="collapse" for="c-36612633">[-]</label><label class="expand" for="c-36612633">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true. After all, in my E-lang I can solve every Project Euler program in under 6 bytes.</div><br/></div></div></div></div><div id="36612705" class="c"><input type="checkbox" id="c-36612705" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#36611990">prev</a><span>|</span><a href="#36612631">next</a><span>|</span><label class="collapse" for="c-36612705">[-]</label><label class="expand" for="c-36612705">[3 more]</label></div><br/><div class="children"><div class="content">The answer is great, but I&#x27;m questioning its underlying assumption of what &quot;expressiveness&quot; really means, upon which the remainder of the explanation rests.<p>&gt;&gt; We can get closer to a formal statement by saying: a feature does not &quot;add expressive power&quot; if we can implement it as a macro that turns it into something in the original language<p>If adding features that could be implemented as macros doesn&#x27;t make the language more &quot;expressive&quot;, then the inverse should be true: Removing features that could be implemented as macros would not make a language less &quot;expressive&quot;.<p>This seems to favor c++, in which basically anything imaginable can be done with macros, and any other language can be implemented. There&#x27;s no global-level total <i>thing</i> that&#x27;s missing which can&#x27;t be cleverly built at an inline level. Yet all of c++&#x27;s granularity in memory management requires a huge amount of verbosity, which is to say it <i>isn&#x27;t</i> as expressive (to me) as something that just runs garbage collection out of the box and makes assumptions about weak vs. strong references and lets you tinker with them if or when you like.<p>&quot;Expressive&quot; to me implies being able to get a lot of meaning across in a few choice words, whilst having a broad vocabulary to choose from.<p>Does adding .reduce() add no expressiveness to Javascript, just because it&#x27;s easily implemented with a macro? I&#x27;d argue it adds a lot, because it adds a new color to the palette; it gives rise to styles of programming that allow one to distinguish intentionally between normal loops and functional recursion, and choose, i.e. <i>express</i>, the music according to their own intent.</div><br/><div id="36612885" class="c"><input type="checkbox" id="c-36612885" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36612705">parent</a><span>|</span><a href="#36613018">prev</a><span>|</span><a href="#36612631">next</a><span>|</span><label class="collapse" for="c-36612885">[-]</label><label class="expand" for="c-36612885">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This seems to favor c++, in which basically anything imaginable can be done with macros, and any other language can be implemented.<p>Pfft. C++ macros can&#x27;t even run a different compiler:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&#x2F;nightly-crimes&#x2F;blob&#x2F;main&#x2F;yolo-rustc-bootstrap&#x2F;src&#x2F;lib.rs">https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&#x2F;nightly-crimes&#x2F;blob&#x2F;main&#x2F;yolo-rus...</a></div><br/></div></div></div></div><div id="36612631" class="c"><input type="checkbox" id="c-36612631" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36612705">prev</a><span>|</span><a href="#36610863">next</a><span>|</span><label class="collapse" for="c-36612631">[-]</label><label class="expand" for="c-36612631">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this formalization does a great job of what we intuitively mean by expressive power.<p>For one thing, there is no real way to use this definition to compare different languages, only the same language with one extra feature.<p>For another, even for individual features, it is too coarse. The very fact that it doesn&#x27;t consider syntactic sugar expressive is wrong - most people would agree that a language with more syntax sugar is more expressive, since it allows you to avoid writing boilerplate. By this definition, list comprehensions and switch expressions for example don&#x27;t add expressive power to a language.<p>Even if we ignore syntax sugar, the comments point out another counterintuitive property of this definiton: any language which includes a facility to convert expressions to ASTs is maximally expressive, since that facility can be used to distinguish any two expressions. This includes things like Lisp&#x27;s `quote&#x27; special form or C&#x27;s # macro, but also built-in code parsers. So, C++ for example added no expressive power to C by this definition, since C was already maximally expressive:<p><pre><code>  #define quote(x) #x

  if (strcmp(&quot;3 + 3&quot;, quote(3 + 3)) {return 1;}</code></pre></div><br/></div></div><div id="36610863" class="c"><input type="checkbox" id="c-36610863" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#36612631">prev</a><span>|</span><a href="#36611062">next</a><span>|</span><label class="collapse" for="c-36610863">[-]</label><label class="expand" for="c-36610863">[3 more]</label></div><br/><div class="children"><div class="content">Glad to see Matthias Felleisen&#x27;s paper &quot;On the Expressive Power of Programming Languages” mentioned right off the bat.<p>Shriram’s talk on the same is mentioned too—Shriram is a great guy and I’ve enjoyed all my interactions with him. He’s working on improving CS education. There’s a neat program called “Bootstrap” that he’s helped found that aims at teaching algebra with programming. The idea is that functional programming helps students grok important algebraic concepts. (Sorry if I slaughter the description.)<p>Anyway, I appreciate these people and their work. Cool stuff.<p>(Disclaimer: my advisor has had both Shriram and Matthias as advisors. I thought they were cool before starting my PhD though, so it’s genuine. :)</div><br/><div id="36611284" class="c"><input type="checkbox" id="c-36611284" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#36610863">parent</a><span>|</span><a href="#36612225">next</a><span>|</span><label class="collapse" for="c-36611284">[-]</label><label class="expand" for="c-36611284">[1 more]</label></div><br/><div class="children"><div class="content">I think it also bears mentioning that Felleisen and Krishnamurthi are two of the authors of the eminent <i>How to Design Programs</i> [1]. For anyone looking to begin their journey into the world of software development, it’s really hard to beat HtDP! It will teach you a systematic approach to software design and development, without letting the messy details of programming languages get in the way.<p>[1] <a href="https:&#x2F;&#x2F;htdp.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;htdp.org&#x2F;</a></div><br/></div></div><div id="36612225" class="c"><input type="checkbox" id="c-36612225" checked=""/><div class="controls bullet"><span class="by">mrslave</span><span>|</span><a href="#36610863">parent</a><span>|</span><a href="#36611284">prev</a><span>|</span><a href="#36611062">next</a><span>|</span><label class="collapse" for="c-36612225">[-]</label><label class="expand" for="c-36612225">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.bootstrapworld.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.bootstrapworld.org&#x2F;</a> for the curious</div><br/></div></div></div></div><div id="36611062" class="c"><input type="checkbox" id="c-36611062" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36610863">prev</a><span>|</span><a href="#36610586">next</a><span>|</span><label class="collapse" for="c-36611062">[-]</label><label class="expand" for="c-36611062">[3 more]</label></div><br/><div class="children"><div class="content">What are some practical examples of expressive features that distinguish popular languages?<p>The link mentions exceptions and operator overloading.<p>I won’t embarrass myself by speculating here :)</div><br/><div id="36611582" class="c"><input type="checkbox" id="c-36611582" checked=""/><div class="controls bullet"><span class="by">zogrodea</span><span>|</span><a href="#36611062">parent</a><span>|</span><a href="#36611420">next</a><span>|</span><label class="collapse" for="c-36611582">[-]</label><label class="expand" for="c-36611582">[1 more]</label></div><br/><div class="children"><div class="content">I think &quot;sum types&quot; and &quot;pattern matching&quot; in functional languages are great and expressive.<p>A sum type is basically an enum type you can associate arbitrary (but still strongly typed) data with (like associating two strings and an integer for one case, and nothing at all for the second case).<p>Pattern matching is basically like a switch statement on these sum types, destructuring the data and branching on the different cases. It comes with compile-time checking making sure you&#x27;ve covered all the cases if your business requirements change which is helpful too.<p>They are useful for implementing state machines which go from one discrete state to another. They&#x27;ve also been used to implement data structures like balanced binary trees, but I think that&#x27;s a less &quot;everyday&quot; use for them.<p>I hope I explained them at least sort-of clearly. I think their functionality  can be replicated in other ways (like defining an abstract Animal class and implementing Cat and Dog classes, instead of defining an Animal &quot;enum&quot; and a function that branches on each case), but this feels more natural and expressive to me personally.</div><br/></div></div><div id="36611420" class="c"><input type="checkbox" id="c-36611420" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#36611062">parent</a><span>|</span><a href="#36611582">prev</a><span>|</span><a href="#36610586">next</a><span>|</span><label class="collapse" for="c-36611420">[-]</label><label class="expand" for="c-36611420">[1 more]</label></div><br/><div class="children"><div class="content">Functions. Goto. Return. Destructors. Dynamic dispatch. Macros. Templates. System calls. Async. Generators.</div><br/></div></div></div></div><div id="36610586" class="c"><input type="checkbox" id="c-36610586" checked=""/><div class="controls bullet"><span class="by">lukeasrodgers</span><span>|</span><a href="#36611062">prev</a><span>|</span><a href="#36612224">next</a><span>|</span><label class="collapse" for="c-36610586">[-]</label><label class="expand" for="c-36610586">[1 more]</label></div><br/><div class="children"><div class="content">Strongly recommend the talk on which this answer is based: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=43XaZEn2aLc">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=43XaZEn2aLc</a></div><br/></div></div><div id="36612224" class="c"><input type="checkbox" id="c-36612224" checked=""/><div class="controls bullet"><span class="by">Legend2440</span><span>|</span><a href="#36610586">prev</a><span>|</span><a href="#36612308">next</a><span>|</span><label class="collapse" for="c-36612224">[-]</label><label class="expand" for="c-36612224">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in the more general problem; how can you compare expressive power between completely different models of computation?<p>Are neural networks more or less expressive than other forms of computation like register machines? What makes them so? And what can we do to make them more expressive while still being trainable?</div><br/></div></div><div id="36612308" class="c"><input type="checkbox" id="c-36612308" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#36612224">prev</a><span>|</span><a href="#36610714">next</a><span>|</span><label class="collapse" for="c-36612308">[-]</label><label class="expand" for="c-36612308">[3 more]</label></div><br/><div class="children"><div class="content">Even though that&#x27;s a reaction on the title rather than the (interesting) content, I would like to add that Turing-completeness isn&#x27;t the gold-standard of languages. Some very interesting languages like Agda or Idris focus on the benefits of abandoning it.</div><br/><div id="36612596" class="c"><input type="checkbox" id="c-36612596" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#36612308">parent</a><span>|</span><a href="#36610714">next</a><span>|</span><label class="collapse" for="c-36612596">[-]</label><label class="expand" for="c-36612596">[2 more]</label></div><br/><div class="children"><div class="content">Can you say more about the benefits?</div><br/><div id="36612664" class="c"><input type="checkbox" id="c-36612664" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36612308">root</a><span>|</span><a href="#36612596">parent</a><span>|</span><a href="#36610714">next</a><span>|</span><label class="collapse" for="c-36612664">[-]</label><label class="expand" for="c-36612664">[1 more]</label></div><br/><div class="children"><div class="content">In a Turing complete language, the halting problem prevents you from proving formally that any program has certain properties (say, that it doesn&#x27;t leak memory).<p>In a language where any program halts by construction, the compiler can actually check such properties.</div><br/></div></div></div></div></div></div><div id="36610714" class="c"><input type="checkbox" id="c-36610714" checked=""/><div class="controls bullet"><span class="by">tetromino_</span><span>|</span><a href="#36612308">prev</a><span>|</span><a href="#36611522">next</a><span>|</span><label class="collapse" for="c-36610714">[-]</label><label class="expand" for="c-36610714">[1 more]</label></div><br/><div class="children"><div class="content">David Young&#x27;s answer seems to give a precise mathematical criterion for deciding whether a language feature is mere syntactic sugar or more fundamental. Neat!</div><br/></div></div><div id="36611522" class="c"><input type="checkbox" id="c-36611522" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36610714">prev</a><span>|</span><a href="#36612339">next</a><span>|</span><label class="collapse" for="c-36611522">[-]</label><label class="expand" for="c-36611522">[3 more]</label></div><br/><div class="children"><div class="content">Regarding the definition of “observational equivalence”: I would love to see an example of two non-trivial statements that aren’t equal but are observationally equivalent. It seems impossible in almost any programming language.</div><br/><div id="36612610" class="c"><input type="checkbox" id="c-36612610" checked=""/><div class="controls bullet"><span class="by">nitnelave</span><span>|</span><a href="#36611522">parent</a><span>|</span><a href="#36611811">next</a><span>|</span><label class="collapse" for="c-36612610">[-]</label><label class="expand" for="c-36612610">[1 more]</label></div><br/><div class="children"><div class="content">You could argue that an implementation of a function to which you added asserts to make sure that logical invariants are maintained is different from the implementation without. The asserts will never trigger because they enforce properties that are always true for this function.</div><br/></div></div><div id="36611811" class="c"><input type="checkbox" id="c-36611811" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#36611522">parent</a><span>|</span><a href="#36612610">prev</a><span>|</span><a href="#36612339">next</a><span>|</span><label class="collapse" for="c-36611811">[-]</label><label class="expand" for="c-36611811">[1 more]</label></div><br/><div class="children"><div class="content">2 pure functions that calculate n digits of pi using different algorithms.<p>I guess you could exploit memory layout, different number of variables or timing attacks to distinguish them, but that&#x27;s cheating IMHO. By that same method you could distinguish anything that compiles to different machine code.</div><br/></div></div></div></div><div id="36612339" class="c"><input type="checkbox" id="c-36612339" checked=""/><div class="controls bullet"><span class="by">calf</span><span>|</span><a href="#36611522">prev</a><span>|</span><a href="#36611787">next</a><span>|</span><label class="collapse" for="c-36612339">[-]</label><label class="expand" for="c-36612339">[1 more]</label></div><br/><div class="children"><div class="content">In CS 61A we weren&#x27;t taught about Turing complete, we simply learned that expressive power is the ability to represent the abstractions you use to solve or model a computational problem correctly and efficiently.</div><br/></div></div><div id="36611787" class="c"><input type="checkbox" id="c-36611787" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#36612339">prev</a><span>|</span><a href="#36610408">next</a><span>|</span><label class="collapse" for="c-36611787">[-]</label><label class="expand" for="c-36611787">[3 more]</label></div><br/><div class="children"><div class="content">Understand curry howard and you&#x27;re on your way to answering this question<p>Every person i&#x27;ve met who uses turing equivalence as a real argument about PLs has been a deficiency clown</div><br/><div id="36612246" class="c"><input type="checkbox" id="c-36612246" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#36611787">parent</a><span>|</span><a href="#36612015">prev</a><span>|</span><a href="#36610408">next</a><span>|</span><label class="collapse" for="c-36612246">[-]</label><label class="expand" for="c-36612246">[1 more]</label></div><br/><div class="children"><div class="content">&gt;deficiency clown<p>What is that?</div><br/></div></div></div></div><div id="36610408" class="c"><input type="checkbox" id="c-36610408" checked=""/><div class="controls bullet"><span class="by">scj</span><span>|</span><a href="#36611787">prev</a><span>|</span><a href="#36610495">next</a><span>|</span><label class="collapse" for="c-36610408">[-]</label><label class="expand" for="c-36610408">[10 more]</label></div><br/><div class="children"><div class="content">Have language X implement language Y and vice-versa?</div><br/><div id="36611259" class="c"><input type="checkbox" id="c-36611259" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#36610408">parent</a><span>|</span><a href="#36610495">next</a><span>|</span><label class="collapse" for="c-36611259">[-]</label><label class="expand" for="c-36611259">[9 more]</label></div><br/><div class="children"><div class="content">See, that&#x27;s the problem: it doesn&#x27;t work!<p>If <i>both</i> languages are Turing-complete, you can <i>always</i> implement language X in Y, and Y in X. That&#x27;s basically the definition of Turing-completeness.<p>Any feature can be implemented in the destination language, even if it is by something as silly as running the source language compiler and executing the resulting bytecode in a x86 VM in your destination language.</div><br/><div id="36613023" class="c"><input type="checkbox" id="c-36613023" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611259">parent</a><span>|</span><a href="#36611600">next</a><span>|</span><label class="collapse" for="c-36613023">[-]</label><label class="expand" for="c-36613023">[1 more]</label></div><br/><div class="children"><div class="content">You can even prove that languages that can do IO are equally fast. For example for every Java program there is a C program with the same performance: just put the binary of the JVM in a .c file, and write out a JVM on the disk at compile time, and start it from C at runtime. Then you have a C program for every Java program, which has the same performance.</div><br/></div></div><div id="36611600" class="c"><input type="checkbox" id="c-36611600" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611259">parent</a><span>|</span><a href="#36613023">prev</a><span>|</span><a href="#36612379">next</a><span>|</span><label class="collapse" for="c-36611600">[-]</label><label class="expand" for="c-36611600">[5 more]</label></div><br/><div class="children"><div class="content">Giving the GP a more generous interpretation: let L(X, Y) be the shortest possible size of an interpreter of language X written in language Y.  If L(X, Y) &gt; L(Y, X), then implementing X in Y requires more than implementing Y in X, and X could be considered &quot;more expressive&quot; than Y.  That said, the answer in OP is much more insightful and thought-provoking.</div><br/><div id="36612742" class="c"><input type="checkbox" id="c-36612742" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611600">parent</a><span>|</span><a href="#36612719">next</a><span>|</span><label class="collapse" for="c-36612742">[-]</label><label class="expand" for="c-36612742">[1 more]</label></div><br/><div class="children"><div class="content">A very large L(X, Y) need not indicate that Y lacks expressiveness, but instead could indicate that X is a hugely complicated language. E.g. X might have a primitive that greps from all of Wikipedia snapshotted at some fixed time. Or X could have a huge standard library (think Mathematica).<p>I think a better way to compare languages is to take some collection of tasks, e.g. the first so many Euler problems, and see how concise the best known solutions in language X compare to those in other languages.<p>It would be best to express the length of all programs in bits, so that languages with alphabets significantly smaller than ASCII like Brainfuck or Binary Lambda Calculus are not unfairly penalized. The latter would seem to be particularly expressive [1].<p>[1] <a href="https:&#x2F;&#x2F;tromp.github.io&#x2F;cl&#x2F;cl.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;tromp.github.io&#x2F;cl&#x2F;cl.html</a></div><br/></div></div><div id="36612719" class="c"><input type="checkbox" id="c-36612719" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611600">parent</a><span>|</span><a href="#36612742">prev</a><span>|</span><a href="#36611659">next</a><span>|</span><label class="collapse" for="c-36612719">[-]</label><label class="expand" for="c-36612719">[1 more]</label></div><br/><div class="children"><div class="content">A very large L(X, Y) need not indicate that Y lacks expressiveness, but instead could indicate that X is a hugely complicated language. E.g. X might have a primitive that greps from all of Wikipedia snapshotted at some fixed time.<p>I think a better way to compare languages is to take some collection of tasks, e.g. the first so many Euler problems, and see how concise the best known solutions in language X compare to those in other languages.<p>It would be best to express the length of all programs in bits, so that languages with alphabets significantly smaller than ASCII (like Brainfuck or Binary Lambda Calculus) are not unfairly penalized.</div><br/></div></div><div id="36611659" class="c"><input type="checkbox" id="c-36611659" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611600">parent</a><span>|</span><a href="#36612719">prev</a><span>|</span><a href="#36611712">next</a><span>|</span><label class="collapse" for="c-36611659">[-]</label><label class="expand" for="c-36611659">[1 more]</label></div><br/><div class="children"><div class="content">So if you add &quot;EVAL_AS_Y{ ... }&quot; core primitive into X, it becomes strictly more expressive as Y until you add &quot;EVAL_AS_X { ... }&quot; to Y: then they become exactly as exressive as each other.</div><br/></div></div><div id="36611712" class="c"><input type="checkbox" id="c-36611712" checked=""/><div class="controls bullet"><span class="by">scj</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611600">parent</a><span>|</span><a href="#36611659">prev</a><span>|</span><a href="#36612379">next</a><span>|</span><label class="collapse" for="c-36611712">[-]</label><label class="expand" for="c-36611712">[1 more]</label></div><br/><div class="children"><div class="content">This would be in line with my thoughts.<p>Of course, my off-hand comment is just an exercise rather than an objective measurement.  It&#x27;d only suffice for trivial examples (say, where X is a strict subset of Y).</div><br/></div></div></div></div><div id="36612379" class="c"><input type="checkbox" id="c-36612379" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36611259">parent</a><span>|</span><a href="#36611600">prev</a><span>|</span><a href="#36610495">next</a><span>|</span><label class="collapse" for="c-36612379">[-]</label><label class="expand" for="c-36612379">[2 more]</label></div><br/><div class="children"><div class="content">How do you implement sleep() in lambda calculus?</div><br/><div id="36613066" class="c"><input type="checkbox" id="c-36613066" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36610408">root</a><span>|</span><a href="#36612379">parent</a><span>|</span><a href="#36610495">next</a><span>|</span><label class="collapse" for="c-36613066">[-]</label><label class="expand" for="c-36613066">[1 more]</label></div><br/><div class="children"><div class="content">Or `read` or `write` or invocation of any syscall. There is more to computer system than pure computation.</div><br/></div></div></div></div></div></div></div></div><div id="36611613" class="c"><input type="checkbox" id="c-36611613" checked=""/><div class="controls bullet"><span class="by">ftxbro</span><span>|</span><a href="#36610495">prev</a><span>|</span><label class="collapse" for="c-36611613">[-]</label><label class="expand" for="c-36611613">[2 more]</label></div><br/><div class="children"><div class="content">I feel like these kind of questions will be explored more in the future when LLMs are more powerful. You could get some equivalent corpuses of different languages and train an LLM on each one and then see how capable is the resulting LLM of the respective language. Presumably if everything else is equal the language with more capable resulting LLM would be better in some sense, maybe this sense would be called &#x27;expressive power&#x27; or maybe called another thing.</div><br/></div></div></div></div></div></div></div></body></html>