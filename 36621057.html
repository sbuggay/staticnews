<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688720460405" as="style"/><link rel="stylesheet" href="styles.css?v=1688720460405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.imaginationtech.com/imagination-gpus-now-support-opengl-4.6">Imagination GPUs now support OpenGL 4.6</a> <span class="domain">(<a href="https://blog.imaginationtech.com">blog.imaginationtech.com</a>)</span></div><div class="subtext"><span>mfilion</span> | <span>75 comments</span></div><br/><div><div id="36621470" class="c"><input type="checkbox" id="c-36621470" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621749">next</a><span>|</span><label class="collapse" for="c-36621470">[-]</label><label class="expand" for="c-36621470">[46 more]</label></div><br/><div class="children"><div class="content">Glad to see more support for OpenGL, but I really hope we&#x27;ll soon move to a compute-only way of handling graphics. The overhead of vulkan is absolutely insane (and not warranted, in my opinion), and OpenGL is on its last legs.<p>Things like Nanite spark a little hope, since they&#x27;ve shown that software-rasterization via compute can be faster than the standard graphics pipeline with the hardware rasterizer for small, dense triangles. Seems like a matter of time until everything goes compute, even large triangles. Maybe the recent addition of work-graphs in DirectX is one step in that direction?</div><br/><div id="36621993" class="c"><input type="checkbox" id="c-36621993" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#36621470">parent</a><span>|</span><a href="#36621608">next</a><span>|</span><label class="collapse" for="c-36621993">[-]</label><label class="expand" for="c-36621993">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The overhead of vulkan is absolutely insane<p>Overstatement of the year award candidate.<p>Vulkan and OpenGL both already support mesh shaders, which is a compute-oriented alternative to the traditional rasterization pipeline.</div><br/><div id="36622125" class="c"><input type="checkbox" id="c-36622125" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621993">parent</a><span>|</span><a href="#36622110">next</a><span>|</span><label class="collapse" for="c-36622125">[-]</label><label class="expand" for="c-36622125">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Vulkan and OpenGL both already support mesh shaders, which is a compute-oriented alternative to the traditional rasterization pipeline.<p>Mesh shaders are a step in the right direction, but they are still embedded in all that unnecessary Vulkan fluff. I would want these things in CUDA because it does the opposite approach of Vulkan - it makes the common things easy, and the hard&#x2F;powerful things optional. Just let me draw things directly in CUDA, and maybe give access to the hardware rasterizer via a CUDA call.</div><br/></div></div><div id="36622110" class="c"><input type="checkbox" id="c-36622110" checked=""/><div class="controls bullet"><span class="by">rsp1984</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621993">parent</a><span>|</span><a href="#36622125">prev</a><span>|</span><a href="#36628458">next</a><span>|</span><label class="collapse" for="c-36622110">[-]</label><label class="expand" for="c-36622110">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Overstatement of the year award candidate.<p>I think he meant development overhead, not performance overhead.</div><br/><div id="36622186" class="c"><input type="checkbox" id="c-36622186" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622110">parent</a><span>|</span><a href="#36628458">next</a><span>|</span><label class="collapse" for="c-36622186">[-]</label><label class="expand" for="c-36622186">[6 more]</label></div><br/><div class="children"><div class="content">Yes, sorry for the confusion. I&#x27;d just rather have an API where the common things are easy, and the super powerful low-level optimizations are optional.</div><br/><div id="36624440" class="c"><input type="checkbox" id="c-36624440" checked=""/><div class="controls bullet"><span class="by">sounds</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622186">parent</a><span>|</span><a href="#36627161">next</a><span>|</span><label class="collapse" for="c-36624440">[-]</label><label class="expand" for="c-36624440">[1 more]</label></div><br/><div class="children"><div class="content">There were several pushes to produce a &quot;sane defaults&quot; library that made vulkan a lot less verbose.<p>OpenGL is exactly what you said, &quot;an API where the common things are easy, and the super powerful low-level optimizations are optional.&quot;</div><br/></div></div><div id="36627161" class="c"><input type="checkbox" id="c-36627161" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622186">parent</a><span>|</span><a href="#36624440">prev</a><span>|</span><a href="#36628068">next</a><span>|</span><label class="collapse" for="c-36627161">[-]</label><label class="expand" for="c-36627161">[1 more]</label></div><br/><div class="children"><div class="content">You could always just use a library that simplifies Vulkan or keep some skeleton apps around. When you&#x27;re past all of the verbose set up, the actual meat of it isn&#x27;t too bad.</div><br/></div></div><div id="36628068" class="c"><input type="checkbox" id="c-36628068" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622186">parent</a><span>|</span><a href="#36627161">prev</a><span>|</span><a href="#36628458">next</a><span>|</span><label class="collapse" for="c-36628068">[-]</label><label class="expand" for="c-36628068">[3 more]</label></div><br/><div class="children"><div class="content">What happened is that Khronos Group banked on third parties writing OpenGL-esque &quot;middleware libraries&quot; that bridged the gap between the hopelessly complex Vulkan API and people who want to write simple 3D graphics. Unfortunately, Khronos learnt the hard way that you can&#x27;t just expect people to do work for you without a sufficient incentive, since after all, OpenGL still exists for anyone who wishes to have an easy API for graphics programming, and anyone who doesn&#x27;t want to do that just uses an engine or high-level graphics API.<p>Of course I&#x27;m not saying that these libraries don&#x27;t exist, but they haven&#x27;t taken off in the way they expected</div><br/><div id="36628194" class="c"><input type="checkbox" id="c-36628194" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36628068">parent</a><span>|</span><a href="#36628458">next</a><span>|</span><label class="collapse" for="c-36628194">[-]</label><label class="expand" for="c-36628194">[2 more]</label></div><br/><div class="children"><div class="content">&gt; who wishes to have an easy API for graphics programming, and anyone who doesn&#x27;t want to do that just uses an engine or high-level graphics API.<p>I&#x27;m guessing this niche is just pretty small in commercial sense; most people probable end up just using UE&#x2F;Unity&#x2F;... as their graphics API.</div><br/><div id="36628297" class="c"><input type="checkbox" id="c-36628297" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36628194">parent</a><span>|</span><a href="#36628458">next</a><span>|</span><label class="collapse" for="c-36628297">[-]</label><label class="expand" for="c-36628297">[1 more]</label></div><br/><div class="children"><div class="content">I agree, so I think Khronos expected the open source community to fill in the gaps</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36628458" class="c"><input type="checkbox" id="c-36628458" checked=""/><div class="controls bullet"><span class="by">unconed</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621993">parent</a><span>|</span><a href="#36622110">prev</a><span>|</span><a href="#36621608">next</a><span>|</span><label class="collapse" for="c-36628458">[-]</label><label class="expand" for="c-36628458">[1 more]</label></div><br/><div class="children"><div class="content">* ... a compute-oriented continuation of the practice where they take the average of Nvidia and AMD&#x27;s implementations, and then force the developer to deal with the overhead of harmonizing the details without going insane.<p>GPU compute is awful, almost as bad as GPU rendering.</div><br/></div></div></div></div><div id="36621608" class="c"><input type="checkbox" id="c-36621608" checked=""/><div class="controls bullet"><span class="by">verall</span><span>|</span><a href="#36621470">parent</a><span>|</span><a href="#36621993">prev</a><span>|</span><a href="#36623450">next</a><span>|</span><label class="collapse" for="c-36621608">[-]</label><label class="expand" for="c-36621608">[12 more]</label></div><br/><div class="children"><div class="content">&gt; I really hope we&#x27;ll soon move to a compute-only way of handling graphics<p>Not happening anytime soon. The industry has lined up pretty solidly behind Khronos&#x2F;Vulkan.</div><br/><div id="36621701" class="c"><input type="checkbox" id="c-36621701" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621608">parent</a><span>|</span><a href="#36627521">next</a><span>|</span><label class="collapse" for="c-36621701">[-]</label><label class="expand" for="c-36621701">[3 more]</label></div><br/><div class="children"><div class="content">I know it won&#x27;t happen overnight, but since it&#x27;s already possible to do software rasterization for small triangles faster than hardware, having a graphics API framework starts losing its purpose. After all, we want to have the detail of small triangles anyway. Just let us draw to the screen in CUDA without the need for OpenGL&#x2F;Vulkan interop, and I believe we&#x27;ll soon see a shift to serious compute-based real-time rendering.<p>Basically, instead of graphics being a framework, I want graphics to be a straightforward library you include and use in your CUDA&#x2F;HIP&#x2F;SYCL&#x2F;OpenCL code.</div><br/><div id="36624041" class="c"><input type="checkbox" id="c-36624041" checked=""/><div class="controls bullet"><span class="by">vitaminka</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621701">parent</a><span>|</span><a href="#36627521">next</a><span>|</span><label class="collapse" for="c-36624041">[-]</label><label class="expand" for="c-36624041">[2 more]</label></div><br/><div class="children"><div class="content">&gt; let us draw to the screen in CUDA without the need for OpenGL&#x2F;Vulkan interop<p>how would that work? like GPU frameworks would just be compute (like cuda) and some small component of it would just allow to write the end result to a buffer which would be displayed or smth?</div><br/><div id="36627417" class="c"><input type="checkbox" id="c-36627417" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36624041">parent</a><span>|</span><a href="#36627521">next</a><span>|</span><label class="collapse" for="c-36627417">[-]</label><label class="expand" for="c-36627417">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Things like that already work with a workaround: You can use Cuda-OpenGL interop to expose an OpenGL framebuffer in CUDA, then you can simply write into that framebuffer from your CUDA kernel, and afterwards you get back to OpenGL to display it on screen. Just directly integrate that functionality in CUDA by providing a CUDA native framebuffer and a present(buffer) or buffer swap functionality.</div><br/></div></div></div></div></div></div><div id="36627521" class="c"><input type="checkbox" id="c-36627521" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621608">parent</a><span>|</span><a href="#36621701">prev</a><span>|</span><a href="#36622390">next</a><span>|</span><label class="collapse" for="c-36627521">[-]</label><label class="expand" for="c-36627521">[1 more]</label></div><br/><div class="children"><div class="content">What percentage of applications *natively* target Vulkan?<p>Imho Vulkan is the least used of all the APIs if you disregard it as a compatibility layer</div><br/></div></div><div id="36622390" class="c"><input type="checkbox" id="c-36622390" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621608">parent</a><span>|</span><a href="#36627521">prev</a><span>|</span><a href="#36621999">next</a><span>|</span><label class="collapse" for="c-36622390">[-]</label><label class="expand" for="c-36622390">[6 more]</label></div><br/><div class="children"><div class="content">&gt;. The industry has lined up pretty solidly behind Khronos&#x2F;Vulkan.<p>What industry? Gaming industry is mostly using DirectX or Gnm&#x2F;PSSL.</div><br/><div id="36625277" class="c"><input type="checkbox" id="c-36625277" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622390">parent</a><span>|</span><a href="#36621999">next</a><span>|</span><label class="collapse" for="c-36625277">[-]</label><label class="expand" for="c-36625277">[5 more]</label></div><br/><div class="children"><div class="content">Only if you take a very narrow view of the gaming industry that only includes high end consoles and PCs.<p>The Nintendo Switch and PCs support OpenGL and Vulkan. But those are both dwarfed by mobile gaming which I think makes up more than half of the entire gaming market, and both iPhone and Android support OpenGL. Although I don&#x27;t know if the majority of mobile games use it or not.</div><br/><div id="36626442" class="c"><input type="checkbox" id="c-36626442" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36625277">parent</a><span>|</span><a href="#36621999">next</a><span>|</span><label class="collapse" for="c-36626442">[-]</label><label class="expand" for="c-36626442">[4 more]</label></div><br/><div class="children"><div class="content">While switch supports OpenGL and Vulkan, in practice very little games use it. The native API on Switch is a proprietary API called NVN.<p>OpenGL on Apple is on life support to support existing software, Apple platforms are all in on Metal now.<p>The only platforms where OpenGL and Vulkan are first class citizens is Linux, Android and Windows (barely). And Vulkan is still second fiddle to DirectX on Windows.</div><br/><div id="36626606" class="c"><input type="checkbox" id="c-36626606" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36626442">parent</a><span>|</span><a href="#36626600">next</a><span>|</span><label class="collapse" for="c-36626606">[-]</label><label class="expand" for="c-36626606">[1 more]</label></div><br/><div class="children"><div class="content">All fair points. However, I was taking issue specifically with the claim that the &quot;Gaming industry is mostly using DirectX or Gnm&#x2F;PSSL&quot;.<p>It would be hard to quantify exactly how much of it is using OpenGL, as a percentage.<p>However, for a very rough upper bound I quickly looked up these:<p>* Mobile gaming apparently makes 52% of the entire gaming market in 2023<p>* Android is 78% of mobile gaming<p>That could mean OpenGL makes up to 40% of the entire gaming market just from Android.<p>Although I have no idea what percentage of Android games use OpenGL and wouldn&#x27;t know how to look that up. I also don&#x27;t know how accurate those percentages are. I got them from brief Google queries and got both the 52% and 78% figures from the featured snippet.<p>But even if that 40% is much too high, we still need to add switch and PC games and I would find a figure of 30% of the gaming industry using openGL to be believable. That would put OpenGL as the largest API which I didn&#x27;t expect, even as a possibility.</div><br/></div></div><div id="36626600" class="c"><input type="checkbox" id="c-36626600" checked=""/><div class="controls bullet"><span class="by">rand_flip_bit</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36626442">parent</a><span>|</span><a href="#36626606">prev</a><span>|</span><a href="#36627486">next</a><span>|</span><label class="collapse" for="c-36626600">[-]</label><label class="expand" for="c-36626600">[1 more]</label></div><br/><div class="children"><div class="content">Just to reiterate on this point: Pretty much every Vulkan game on Windows forgoes using Vulkan Swapchains in favor of presenting from compute and using native DXGI Swapchains. If you are shipping a production quality game or application, you really want to use the platforms native APIs to get the full capabilities.</div><br/></div></div></div></div></div></div></div></div><div id="36621999" class="c"><input type="checkbox" id="c-36621999" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621608">parent</a><span>|</span><a href="#36622390">prev</a><span>|</span><a href="#36623450">next</a><span>|</span><label class="collapse" for="c-36621999">[-]</label><label class="expand" for="c-36621999">[1 more]</label></div><br/><div class="children"><div class="content">The industry targeting Android and GNU&#x2F;Linux devices, that is.</div><br/></div></div></div></div><div id="36623450" class="c"><input type="checkbox" id="c-36623450" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#36621470">parent</a><span>|</span><a href="#36621608">prev</a><span>|</span><a href="#36624000">next</a><span>|</span><label class="collapse" for="c-36623450">[-]</label><label class="expand" for="c-36623450">[5 more]</label></div><br/><div class="children"><div class="content">&gt;but I really hope we&#x27;ll soon move to a compute-only way of handling graphics.<p>Would you have the time to expand on this thought a bit?  I am curious.  Thanks!!</div><br/><div id="36624666" class="c"><input type="checkbox" id="c-36624666" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36623450">parent</a><span>|</span><a href="#36624000">next</a><span>|</span><label class="collapse" for="c-36624666">[-]</label><label class="expand" for="c-36624666">[4 more]</label></div><br/><div class="children"><div class="content">Software rendering. In parallel on the GPU.</div><br/><div id="36628280" class="c"><input type="checkbox" id="c-36628280" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36624666">parent</a><span>|</span><a href="#36626132">next</a><span>|</span><label class="collapse" for="c-36628280">[-]</label><label class="expand" for="c-36628280">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get what that means. You mean configuring a shader to render pixels?<p>How do you think OpenGL&#x2F;Vulkan works under the hood? It&#x27;s been a very long time since fixed function pipelines.</div><br/></div></div><div id="36626132" class="c"><input type="checkbox" id="c-36626132" checked=""/><div class="controls bullet"><span class="by">NovaDudely</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36624666">parent</a><span>|</span><a href="#36628280">prev</a><span>|</span><a href="#36624000">next</a><span>|</span><label class="collapse" for="c-36626132">[-]</label><label class="expand" for="c-36626132">[2 more]</label></div><br/><div class="children"><div class="content">I mean, about 5 years ago there were many folks that were trying to do raytracing using GPU compute rather than the current methods, it was essentially treating the CPU as a giant parallel software rendered. The results were pretty good even then.</div><br/><div id="36628042" class="c"><input type="checkbox" id="c-36628042" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36626132">parent</a><span>|</span><a href="#36624000">next</a><span>|</span><label class="collapse" for="c-36628042">[-]</label><label class="expand" for="c-36628042">[1 more]</label></div><br/><div class="children"><div class="content">Raytracing using GPU compute is pretty much the norm for offline rendering, for example Blenders Cycles renderer has support for all major GPUs: <a href="https:&#x2F;&#x2F;docs.blender.org&#x2F;manual&#x2F;en&#x2F;latest&#x2F;render&#x2F;cycles&#x2F;gpu_rendering.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.blender.org&#x2F;manual&#x2F;en&#x2F;latest&#x2F;render&#x2F;cycles&#x2F;gpu_...</a><p>It is telling of the GPU compute landscape that there is separate implementation for each vendor</div><br/></div></div></div></div></div></div></div></div><div id="36621981" class="c"><input type="checkbox" id="c-36621981" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#36621470">parent</a><span>|</span><a href="#36624000">prev</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36621981">[-]</label><label class="expand" for="c-36621981">[11 more]</label></div><br/><div class="children"><div class="content">&gt; The overhead of vulkan is absolutely insane (and not warranted, in my opinion)<p>Would you mind expanding on this?</div><br/><div id="36622372" class="c"><input type="checkbox" id="c-36622372" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621981">parent</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36622372">[-]</label><label class="expand" for="c-36622372">[10 more]</label></div><br/><div class="children"><div class="content">I meant the development&#x2F;learning overhead. With Vulkan you can do incredible low-level optimizations to squeeze every last bit of performance out of your 3D application, but because you are basically mandated to do it that way, you have a very harsh learning curve and need lots of code for the simplest tasks. I&#x27;d rather prefer approaches that make the common things that everyone wants to do easy (draw your first simple scenes), and then optionally gives you all the features to sqeeze out performance where you really need to. Because at least for me, I don&#x27;t work with massive scenes with millions of instances of thousands of different objects. I do real-time graphics research, mostly with compute, and I&#x27;d just like to present the triangles I&#x27;ve created or the framebuffers I created via compute (like shadertoy).<p>I&#x27;ll readily admit, I&#x27;m neither smart nor patient enough for Vulkan so I quickly gave up and learned CUDA instead, because it was way easier to write a naive software-rasterizer for triangles in CUDA, than it was to combine a compute shader and a vertex+fragment shader in Vulkan. I&#x27;m just rendering a single buffer with ~100k compute-generated triangles, and learning Vulkan for that just wasn&#x27;t worth it.</div><br/><div id="36622470" class="c"><input type="checkbox" id="c-36622470" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622372">parent</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36622470">[-]</label><label class="expand" for="c-36622470">[9 more]</label></div><br/><div class="children"><div class="content">Well, then there&#x27;s OpenGL and DirectX.</div><br/><div id="36628633" class="c"><input type="checkbox" id="c-36628633" checked=""/><div class="controls bullet"><span class="by">dosshell</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622470">parent</a><span>|</span><a href="#36622560">next</a><span>|</span><label class="collapse" for="c-36628633">[-]</label><label class="expand" for="c-36628633">[1 more]</label></div><br/><div class="children"><div class="content">And webgpu.<p>Sure, the implementations today are thin layers over D3D12, Vulkan and Mantel. But it is a proper API, cross platform and without the implementation overhead.<p>Next time I need to draw some graphics I will definitely use WebGPU instead of OpenGL or Vulkan.<p>PS. Don&#x27;t let the name fool you. It is a proper render API, Mozilla has written their implementation in rust and Google in C++.<p>Would not be surprised if WebGPU do get native support by the drivers in the future.</div><br/></div></div><div id="36622560" class="c"><input type="checkbox" id="c-36622560" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622470">parent</a><span>|</span><a href="#36628633">prev</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36622560">[-]</label><label class="expand" for="c-36622560">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, but OpenGL doesn&#x27;t get updates anymore. My timeline goes like: I needed pointers(and pointer casting) for my compute shaders so I checked the corresponding GLSL extension, which was only available in Vulkan so I tried switching from OpenGL to Vulkan. After a week I gave up - the pointer&#x2F;Buffer reference extension did not look promising anyway - and I tried out CUDA instead. That&#x27;s when I found out that CUDA is the greatest shit ever. That&#x27;s what I want graphics programming to be like. Since then I just render all the triangles and lines in CUDA, because it easily handles hundreds of thousands of them in real-time with a naive, unoptimized software-rasterizer, and that&#x27;s all I need. In addition to the billion points you can also render in real-time in CUDA with atomics.</div><br/><div id="36623942" class="c"><input type="checkbox" id="c-36623942" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622560">parent</a><span>|</span><a href="#36628301">next</a><span>|</span><label class="collapse" for="c-36623942">[-]</label><label class="expand" for="c-36623942">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s when I found out that CUDA is the greatest shit ever. That&#x27;s what I want graphics programming to be like.<p>Something which requires you to buy new hardware from a specific brand, and load an out-of-tree binary-only module on your kernel? That&#x27;s not what I want graphics programming to be like.<p>The Vulkan API might be clunkier (I don&#x27;t know, I haven&#x27;t looked at the CUDA API, since I don&#x27;t have the required hardware), but at least it can work everywhere.</div><br/><div id="36627451" class="c"><input type="checkbox" id="c-36627451" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36623942">parent</a><span>|</span><a href="#36627859">next</a><span>|</span><label class="collapse" for="c-36627451">[-]</label><label class="expand" for="c-36627451">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the exact reason why I&#x27;ve avoided CUDA for years, but I hit a dead end with OpenGL and Vulkan, and CUDA happened to be a fantastic, easy and fast solution. Of course I don&#x27;t want graphics programming to be NVIDIA-only, but I want it to be like CUDA, just for all platforms.</div><br/></div></div><div id="36627859" class="c"><input type="checkbox" id="c-36627859" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36623942">parent</a><span>|</span><a href="#36627451">prev</a><span>|</span><a href="#36628301">next</a><span>|</span><label class="collapse" for="c-36627859">[-]</label><label class="expand" for="c-36627859">[1 more]</label></div><br/><div class="children"><div class="content">Except it doesn&#x27;t work everywhere, far from it.</div><br/></div></div></div></div><div id="36628301" class="c"><input type="checkbox" id="c-36628301" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622560">parent</a><span>|</span><a href="#36623942">prev</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36628301">[-]</label><label class="expand" for="c-36628301">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused by what you mean here by &quot;software-rasterizer&quot; when you are compiling it to run on the GPU. What do you think the graphics driver is doing when you program it with OpenGL? It&#x27;s doing more or less the same thing under the hood.<p>I guess you can technically call that software rasterization now that GPUs are very programmable. But it&#x27;s not how the word is usually used.</div><br/><div id="36628528" class="c"><input type="checkbox" id="c-36628528" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36628301">parent</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36628528">[-]</label><label class="expand" for="c-36628528">[2 more]</label></div><br/><div class="children"><div class="content">GPUs have dedicated hardware for rasterisation. Using compute shaders to do it would be wasteful.</div><br/><div id="36628580" class="c"><input type="checkbox" id="c-36628580" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36628528">parent</a><span>|</span><a href="#36621505">next</a><span>|</span><label class="collapse" for="c-36628580">[-]</label><label class="expand" for="c-36628580">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. I&#x27;m working on an application that does exactly that, as we are rendering spheres. It ends up being much more efficient to rasterize the sphere in a combination of vertex and fragment shaders than to instantiate triangles.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36621505" class="c"><input type="checkbox" id="c-36621505" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#36621470">parent</a><span>|</span><a href="#36621981">prev</a><span>|</span><a href="#36621749">next</a><span>|</span><label class="collapse" for="c-36621505">[-]</label><label class="expand" for="c-36621505">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t nanite hardware rasterization with software shading? Like using the GPU to draw triangle&#x2F;cluster ID #s into the FB and then shading those?</div><br/><div id="36621585" class="c"><input type="checkbox" id="c-36621585" checked=""/><div class="controls bullet"><span class="by">zbendefy</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621505">parent</a><span>|</span><a href="#36621540">next</a><span>|</span><label class="collapse" for="c-36621585">[-]</label><label class="expand" for="c-36621585">[3 more]</label></div><br/><div class="children"><div class="content">It uses the rasterization HW for large triangles and uses a software rasterizer in compute for small triangles.<p>The HW rasterizer is not that efficient if the triangles are tiny, which is the case for nanite.</div><br/><div id="36622068" class="c"><input type="checkbox" id="c-36622068" checked=""/><div class="controls bullet"><span class="by">baybal2</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621585">parent</a><span>|</span><a href="#36621540">next</a><span>|</span><label class="collapse" for="c-36622068">[-]</label><label class="expand" for="c-36622068">[2 more]</label></div><br/><div class="children"><div class="content">But that is one generation of GPUs away when they will make some computational shortcut for small triangles, which to me seems to be rather trivial to implement.</div><br/><div id="36627894" class="c"><input type="checkbox" id="c-36627894" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36622068">parent</a><span>|</span><a href="#36621540">next</a><span>|</span><label class="collapse" for="c-36627894">[-]</label><label class="expand" for="c-36627894">[1 more]</label></div><br/><div class="children"><div class="content">Not really trivial if you have to support any input set of triangles and don&#x27;t know much about them. Software rasterizion exploits things like localized chunks of triangles, but the hardware rasterizer does not know about that in advance. Also, these kinds of software rasterization algorithms add limitations, which aren&#x27;t much of an issue with your own rendering pipeline that specifically knows how to deal with these limitations and works with them.</div><br/></div></div></div></div></div></div><div id="36621540" class="c"><input type="checkbox" id="c-36621540" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621505">parent</a><span>|</span><a href="#36621585">prev</a><span>|</span><a href="#36621547">next</a><span>|</span><label class="collapse" for="c-36621540">[-]</label><label class="expand" for="c-36621540">[1 more]</label></div><br/><div class="children"><div class="content">For small triangles, they use a software rasterizer into the V-buffer. Obviously for 1px triangles since they don&#x27;t want to waste quad overdraw, but I think they found it&#x27;s faster up to 12px&#x2F;tri or so on AMD.</div><br/></div></div><div id="36621547" class="c"><input type="checkbox" id="c-36621547" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#36621470">root</a><span>|</span><a href="#36621505">parent</a><span>|</span><a href="#36621540">prev</a><span>|</span><a href="#36621749">next</a><span>|</span><label class="collapse" for="c-36621547">[-]</label><label class="expand" for="c-36621547">[1 more]</label></div><br/><div class="children"><div class="content">Part of Nanite is software rasterization by rendering triangles with 64 bit atomics. You can simply draw the closest fragment of a triangle to screen via atomicMin(framebuffer[pixelID], (depth &lt;&lt; 32) | triangleData).</div><br/></div></div></div></div></div></div><div id="36621749" class="c"><input type="checkbox" id="c-36621749" checked=""/><div class="controls bullet"><span class="by">bangonkeyboard</span><span>|</span><a href="#36621470">prev</a><span>|</span><a href="#36624629">next</a><span>|</span><label class="collapse" for="c-36621749">[-]</label><label class="expand" for="c-36621749">[3 more]</label></div><br/><div class="children"><div class="content">I had to double check that OpenGL 4.6 (released in 2017) really still is the latest version.</div><br/><div id="36621986" class="c"><input type="checkbox" id="c-36621986" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36621749">parent</a><span>|</span><a href="#36622012">next</a><span>|</span><label class="collapse" for="c-36621986">[-]</label><label class="expand" for="c-36621986">[1 more]</label></div><br/><div class="children"><div class="content">It is, and there is no red book edition covering it.</div><br/></div></div><div id="36622012" class="c"><input type="checkbox" id="c-36622012" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#36621749">parent</a><span>|</span><a href="#36621986">prev</a><span>|</span><a href="#36624629">next</a><span>|</span><label class="collapse" for="c-36622012">[-]</label><label class="expand" for="c-36622012">[1 more]</label></div><br/><div class="children"><div class="content">Vulkan was initially called OpenGL-next.</div><br/></div></div></div></div><div id="36624629" class="c"><input type="checkbox" id="c-36624629" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36621749">prev</a><span>|</span><a href="#36621546">next</a><span>|</span><label class="collapse" for="c-36624629">[-]</label><label class="expand" for="c-36624629">[5 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know any other companies made GPUs.<p>You&#x27;d think some hardware player would buy them to get a foot in the GPU&#x2F;AI game.<p>Are these GPUs fully open source?</div><br/><div id="36624725" class="c"><input type="checkbox" id="c-36624725" checked=""/><div class="controls bullet"><span class="by">scq</span><span>|</span><a href="#36624629">parent</a><span>|</span><a href="#36624693">next</a><span>|</span><label class="collapse" for="c-36624725">[-]</label><label class="expand" for="c-36624725">[1 more]</label></div><br/><div class="children"><div class="content">No, they&#x27;re not open source at all.<p>Their business model is to license the GPU IP block to other companies to integrate into their own chips.<p>It&#x27;s worth noting that Imagination designed the GPUs used in iPhones up until the iPhone 8 when Apple switched to their own design.</div><br/></div></div><div id="36624693" class="c"><input type="checkbox" id="c-36624693" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#36624629">parent</a><span>|</span><a href="#36624725">prev</a><span>|</span><a href="#36621546">next</a><span>|</span><label class="collapse" for="c-36624693">[-]</label><label class="expand" for="c-36624693">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re closed source.   Just parts of the driver are opensource.<p>Note that these GPU&#x27;s are widely used in (mostly low end) phones, and I think power the UI in some other household items with screens.    They provided iPhone GPU&#x27;s till 2017   (and there is debate if Apples new GPU might contain some imagination tech)</div><br/><div id="36624749" class="c"><input type="checkbox" id="c-36624749" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36624629">root</a><span>|</span><a href="#36624693">parent</a><span>|</span><a href="#36621546">next</a><span>|</span><label class="collapse" for="c-36624749">[-]</label><label class="expand" for="c-36624749">[2 more]</label></div><br/><div class="children"><div class="content">Closed source.<p>That’s just crazy. If there’s anything a minor GPU player needs its community support.</div><br/><div id="36627022" class="c"><input type="checkbox" id="c-36627022" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36624629">root</a><span>|</span><a href="#36624749">parent</a><span>|</span><a href="#36621546">next</a><span>|</span><label class="collapse" for="c-36627022">[-]</label><label class="expand" for="c-36627022">[1 more]</label></div><br/><div class="children"><div class="content">Crazy is that they were aggressively anti-foss even with their drivers not too long ago. Intel graphics usually has good Linux support, except for GMA500 which was based on Imagination tech. N900 was the Linux darling phone, and the graphics drivers where god-awful buggy blob from Imagination. And so on..</div><br/></div></div></div></div></div></div></div></div><div id="36621546" class="c"><input type="checkbox" id="c-36621546" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#36624629">prev</a><span>|</span><a href="#36622149">next</a><span>|</span><label class="collapse" for="c-36621546">[-]</label><label class="expand" for="c-36621546">[4 more]</label></div><br/><div class="children"><div class="content">Good to see Zink now provides OpenGL over Vulkan for smaller GPU makers. I wonder if big ones will also eventually use it for it.</div><br/><div id="36623755" class="c"><input type="checkbox" id="c-36623755" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36621546">parent</a><span>|</span><a href="#36623784">next</a><span>|</span><label class="collapse" for="c-36623755">[-]</label><label class="expand" for="c-36623755">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that, by now, the only reason the other mesa3d opengl drivers exist is historical.<p>If these vendors came up with different enough hardware to need a new driver from scratch, they&#x27;d just focus on Vulkan and use Zink for opengl.<p>After all, opengl is a relatively high level API. It is sensible to implement it in a hardware-independent manner on top of Vulkan.</div><br/><div id="36628668" class="c"><input type="checkbox" id="c-36628668" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#36621546">root</a><span>|</span><a href="#36623755">parent</a><span>|</span><a href="#36623784">next</a><span>|</span><label class="collapse" for="c-36628668">[-]</label><label class="expand" for="c-36628668">[1 more]</label></div><br/><div class="children"><div class="content">No, not even close. On Intel in some chipset(s) Vulkan is not as performant as OpenGL 4.6.
Gallium3D with Iris it&#x27;s the future against the old pipeline, tho. For instance, I get OpenGL 2.1 in my netbook with the new drivers, 1.4 with the old ones instead.</div><br/></div></div></div></div><div id="36623784" class="c"><input type="checkbox" id="c-36623784" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#36621546">parent</a><span>|</span><a href="#36623755">prev</a><span>|</span><a href="#36622149">next</a><span>|</span><label class="collapse" for="c-36623784">[-]</label><label class="expand" for="c-36623784">[1 more]</label></div><br/><div class="children"><div class="content">The big players will probably switch once we get to the point that nothing still running on OpenGL needs optimally efficient usage of the GPU (either because it&#x27;s old or because it was never performance-critical to start with, such as a student project).</div><br/></div></div></div></div><div id="36622149" class="c"><input type="checkbox" id="c-36622149" checked=""/><div class="controls bullet"><span class="by">loufe</span><span>|</span><a href="#36621546">prev</a><span>|</span><a href="#36623600">next</a><span>|</span><label class="collapse" for="c-36622149">[-]</label><label class="expand" for="c-36622149">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean to detract from the technical merits of this at all, but for those not aware you might be interested to know that ImaginationTech is a Chinese-owned firm.</div><br/><div id="36622304" class="c"><input type="checkbox" id="c-36622304" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#36622149">parent</a><span>|</span><a href="#36624085">next</a><span>|</span><label class="collapse" for="c-36622304">[-]</label><label class="expand" for="c-36622304">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice to see Chinese tech embrace existing standards.<p>There are a lot of chips that are very poorly documented and supported by abysmal proprietary SDK. The software part of hardware is so often an afterthought yet it is also what makes or breaks the product.</div><br/><div id="36623618" class="c"><input type="checkbox" id="c-36623618" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36622149">root</a><span>|</span><a href="#36622304">parent</a><span>|</span><a href="#36624085">next</a><span>|</span><label class="collapse" for="c-36623618">[-]</label><label class="expand" for="c-36623618">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re a British tech company, simply owned by a Chinese private equity fund.<p>And they&#x27;re sort of known for historically being very anti open source and their SDK difficult to continuously integrate into a larger product.</div><br/></div></div></div></div><div id="36624085" class="c"><input type="checkbox" id="c-36624085" checked=""/><div class="controls bullet"><span class="by">vitaminka</span><span>|</span><a href="#36622149">parent</a><span>|</span><a href="#36622304">prev</a><span>|</span><a href="#36623600">next</a><span>|</span><label class="collapse" for="c-36624085">[-]</label><label class="expand" for="c-36624085">[2 more]</label></div><br/><div class="children"><div class="content">really no better than a us tech firm, unless you for some reason have a preference for nationality characteristics of your hardware backdoors lol</div><br/></div></div></div></div><div id="36623600" class="c"><input type="checkbox" id="c-36623600" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36622149">prev</a><span>|</span><a href="#36621832">next</a><span>|</span><label class="collapse" for="c-36623600">[-]</label><label class="expand" for="c-36623600">[3 more]</label></div><br/><div class="children"><div class="content">I am hopeful this will help mesa3d support with RISC-V SoCs such as JH7110 (and thus VisionFive2 and Star64) be excellent.</div><br/><div id="36623714" class="c"><input type="checkbox" id="c-36623714" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#36623600">parent</a><span>|</span><a href="#36621832">next</a><span>|</span><label class="collapse" for="c-36623714">[-]</label><label class="expand" for="c-36623714">[2 more]</label></div><br/><div class="children"><div class="content">There are links from the blog post to the Mesa sources and to a Linux tree containing their DRM kernel driver.</div><br/><div id="36623887" class="c"><input type="checkbox" id="c-36623887" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36623600">root</a><span>|</span><a href="#36623714">parent</a><span>|</span><a href="#36621832">next</a><span>|</span><label class="collapse" for="c-36623887">[-]</label><label class="expand" for="c-36623887">[1 more]</label></div><br/><div class="children"><div class="content">I am aware.<p>Currently they do not support the specific variant used in JH7110, but they seem to both be variants of the same architecture.<p>JH7110 has the BXE-4-32MC1[0], whereas the driver currently supports the BXS-4-64-MC1[1].<p>0. <a href="https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxe-4-32-mc1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxe-4-32-mc1&#x2F;</a><p>1. <a href="https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxs-4-64-mc1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxs-4-64-mc1&#x2F;</a></div><br/></div></div></div></div></div></div><div id="36621832" class="c"><input type="checkbox" id="c-36621832" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36623600">prev</a><span>|</span><label class="collapse" for="c-36621832">[-]</label><label class="expand" for="c-36621832">[8 more]</label></div><br/><div class="children"><div class="content">What is this?<p>This company makes GPUs?</div><br/><div id="36623643" class="c"><input type="checkbox" id="c-36623643" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36621832">parent</a><span>|</span><a href="#36623929">next</a><span>|</span><label class="collapse" for="c-36623643">[-]</label><label class="expand" for="c-36623643">[4 more]</label></div><br/><div class="children"><div class="content">&gt;This company makes GPUs?<p>Yes, and they&#x27;ve been around for a while. If you&#x27;re old enough, you might remember the name &quot;PowerVR&quot;.<p>Today, they mostly license GPU designs to SoC vendors. You&#x27;ll find their designs in e.g. Android phones.<p>Notably, JH7110 (RISC-V SoC used in VisionFive2 and Star64) uses one of their recent GPUs.</div><br/><div id="36624118" class="c"><input type="checkbox" id="c-36624118" checked=""/><div class="controls bullet"><span class="by">vitaminka</span><span>|</span><a href="#36621832">root</a><span>|</span><a href="#36623643">parent</a><span>|</span><a href="#36623929">next</a><span>|</span><label class="collapse" for="c-36624118">[-]</label><label class="expand" for="c-36624118">[3 more]</label></div><br/><div class="children"><div class="content">does this mean you can run, say, modern openCL code on smth like a VisionFive2?</div><br/><div id="36624185" class="c"><input type="checkbox" id="c-36624185" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36621832">root</a><span>|</span><a href="#36624118">parent</a><span>|</span><a href="#36623929">next</a><span>|</span><label class="collapse" for="c-36624185">[-]</label><label class="expand" for="c-36624185">[2 more]</label></div><br/><div class="children"><div class="content">Oomph-wise, they claim a good 4x over what the Raspberry Pi 4&#x2F;400 have. Note that rPi&#x27;s is known to be anemic due to serious memory bandwidth bottlenecks, barely able to keep up with filling a 1080p screen.<p>Currently they do not support the specific variant used in JH7110, but they seem to both be variants of the same architecture.<p>JH7110 has the BXE-4-32MC1[0], whereas the driver currently supports the BXS-4-64-MC1[1].<p>No idea about compute, and AIUI openCL suport in mesa3d is still a disaster for all drivers.<p>0. <a href="https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxe-4-32-mc1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxe-4-32-mc1&#x2F;</a><p>1. <a href="https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxs-4-64-mc1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.imaginationtech.com&#x2F;product&#x2F;img-bxs-4-64-mc1&#x2F;</a></div><br/><div id="36625341" class="c"><input type="checkbox" id="c-36625341" checked=""/><div class="controls bullet"><span class="by">FullyFunctional</span><span>|</span><a href="#36621832">root</a><span>|</span><a href="#36624185">parent</a><span>|</span><a href="#36623929">next</a><span>|</span><label class="collapse" for="c-36625341">[-]</label><label class="expand" for="c-36625341">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how you can tell that it was BXS-4-64-MC1 that was supported.  I looked and couldn&#x27;t find that.<p>Besides the JH7110 there&#x27;s TH1520 and it&#x27;s using the BXM-4-64-MC1, also not supported, but 2X the speed of BXE-4-64-MC1 if I understand it correctly.</div><br/></div></div></div></div></div></div></div></div><div id="36623929" class="c"><input type="checkbox" id="c-36623929" checked=""/><div class="controls bullet"><span class="by">vetinari</span><span>|</span><a href="#36621832">parent</a><span>|</span><a href="#36623643">prev</a><span>|</span><label class="collapse" for="c-36623929">[-]</label><label class="expand" for="c-36623929">[3 more]</label></div><br/><div class="children"><div class="content">Yes; and if you used an iPhone before 2017, you used GPU made by them.</div><br/><div id="36624657" class="c"><input type="checkbox" id="c-36624657" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#36621832">root</a><span>|</span><a href="#36623929">parent</a><span>|</span><a href="#36626274">next</a><span>|</span><label class="collapse" for="c-36624657">[-]</label><label class="expand" for="c-36624657">[1 more]</label></div><br/><div class="children"><div class="content">Technically, their new GPUs are also directly descended from them. Though, deviating more and more each generation.</div><br/></div></div><div id="36626274" class="c"><input type="checkbox" id="c-36626274" checked=""/><div class="controls bullet"><span class="by">Grum9</span><span>|</span><a href="#36621832">root</a><span>|</span><a href="#36623929">parent</a><span>|</span><a href="#36624657">prev</a><span>|</span><label class="collapse" for="c-36626274">[-]</label><label class="expand" for="c-36626274">[1 more]</label></div><br/><div class="children"><div class="content">They made the Sega Dreamcast hardware 25 years ago<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dreamcast#Hardware" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dreamcast#Hardware</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>