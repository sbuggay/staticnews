<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706605256471" as="style"/><link rel="stylesheet" href="styles.css?v=1706605256471"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.fosskers.ca/en/blog/rounds-of-lisp">A Tour of the Lisps</a> <span class="domain">(<a href="https://www.fosskers.ca">www.fosskers.ca</a>)</span></div><div class="subtext"><span>medo-bear</span> | <span>181 comments</span></div><br/><div><div id="39183357" class="c"><input type="checkbox" id="c-39183357" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39185798">next</a><span>|</span><label class="collapse" for="c-39183357">[-]</label><label class="expand" for="c-39183357">[8 more]</label></div><br/><div class="children"><div class="content">I feel like I say this a lot, but if you like Guile you should really check out Gauche. It has more &quot;batteries&quot; included than Python, several of the &quot;alien technology&quot; features that people expect from Common Lisp, and good documentation to help you navigate it all.<p>Scheme itself has a reputation for being very &quot;minimal&quot;, and R7RS itself is great, but it also shines as a base for bigger languages like Guile and Gauche.<p>Clojure is pretty cool too though. I love that it really has a life of its own as a &quot;third&quot; dialect to complement Common Lisp and Scheme.<p>Can&#x27;t speak for Elisp, not enough room in my brain to learn Emacs after years of Vim.<p>If you like Python, I&#x27;d also like to shout out Hy (<a href="https:&#x2F;&#x2F;hylang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hylang.org&#x2F;</a>), which compiles to Python, and like Fennel is to Lua, it does a reasonably good job of bolting on s-expressions while preserving the semantics of the underlying language. It&#x27;s definitely a &quot;bigger&quot; language than Fennel, but Python is similarly &quot;bigger&quot; than Lua. Hy has also developed its own distinct feel, especially when you take into account the first-party Hyrule utility library (<a href="https:&#x2F;&#x2F;hyrule.readthedocs.io&#x2F;en&#x2F;master&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;hyrule.readthedocs.io&#x2F;en&#x2F;master&#x2F;index.html</a>) which provides a lot of very interesting macros, deriving lots of useful ideas from both Common Lisp and Clojure.</div><br/><div id="39184501" class="c"><input type="checkbox" id="c-39184501" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#39183357">parent</a><span>|</span><a href="#39183532">next</a><span>|</span><label class="collapse" for="c-39184501">[-]</label><label class="expand" for="c-39184501">[3 more]</label></div><br/><div class="children"><div class="content">I tried Hy for 2023 AoC and loved it, but it broke after day 8 because the solution I wrote crashed after 40mins. but re writing the same logic in python took 2 mins to complete.<p>Hy is nice, but &quot;compiling to python&quot; isn&#x27;t</div><br/><div id="39185177" class="c"><input type="checkbox" id="c-39185177" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183357">root</a><span>|</span><a href="#39184501">parent</a><span>|</span><a href="#39183532">next</a><span>|</span><label class="collapse" for="c-39185177">[-]</label><label class="expand" for="c-39185177">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a new one to me, I&#x27;ve never had a Hy program perform substantially worse than the equivalent Python. I&#x27;m curious what the offending code was!</div><br/><div id="39185483" class="c"><input type="checkbox" id="c-39185483" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#39183357">root</a><span>|</span><a href="#39185177">parent</a><span>|</span><a href="#39183532">next</a><span>|</span><label class="collapse" for="c-39185483">[-]</label><label class="expand" for="c-39185483">[1 more]</label></div><br/><div class="children"><div class="content">I <i>think</i> from memory it was to do with recursion (ie: stack overflow error) from having a few too many nested `lfor`s<p>I&#x27;ll try and find it</div><br/></div></div></div></div></div></div><div id="39183532" class="c"><input type="checkbox" id="c-39183532" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#39183357">parent</a><span>|</span><a href="#39184501">prev</a><span>|</span><a href="#39187110">next</a><span>|</span><label class="collapse" for="c-39183532">[-]</label><label class="expand" for="c-39183532">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Hy on and off. Off because it broke &quot;let&quot; at one point and I had a few critical things (like my entire site engine) written in it, and on because I like it a lot. But it&#x27;s not a great LISP for performance (Fennel can run rings around it when using luajit), and I wish they shipped a 1.0 (I cringe every time I read the changelog for a release and check the &quot;breaking changes&quot; part, which is always... beefy).</div><br/><div id="39186229" class="c"><input type="checkbox" id="c-39186229" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39183357">root</a><span>|</span><a href="#39183532">parent</a><span>|</span><a href="#39187110">next</a><span>|</span><label class="collapse" for="c-39186229">[-]</label><label class="expand" for="c-39186229">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Off because it broke &quot;let&quot; at one point<p>It wouldn&#x27;t be very difficult to provide an implementation of `let` that behaves how you would like though, so there is that at least.</div><br/></div></div></div></div><div id="39187110" class="c"><input type="checkbox" id="c-39187110" checked=""/><div class="controls bullet"><span class="by">lioeters</span><span>|</span><a href="#39183357">parent</a><span>|</span><a href="#39183532">prev</a><span>|</span><a href="#39187105">next</a><span>|</span><label class="collapse" for="c-39187110">[-]</label><label class="expand" for="c-39187110">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;shirok&#x2F;Gauche">https:&#x2F;&#x2F;github.com&#x2F;shirok&#x2F;Gauche</a><p><a href="http:&#x2F;&#x2F;www.practical-scheme.net&#x2F;gauche&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;www.practical-scheme.net&#x2F;gauche&#x2F;index.html</a></div><br/></div></div><div id="39187105" class="c"><input type="checkbox" id="c-39187105" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#39183357">parent</a><span>|</span><a href="#39187110">prev</a><span>|</span><a href="#39185798">next</a><span>|</span><label class="collapse" for="c-39187105">[-]</label><label class="expand" for="c-39187105">[1 more]</label></div><br/><div class="children"><div class="content">Your description of Gauche makes me think of Racket, which I really like. How would you compare the two?</div><br/></div></div></div></div><div id="39185798" class="c"><input type="checkbox" id="c-39185798" checked=""/><div class="controls bullet"><span class="by">dannyobrien</span><span>|</span><a href="#39183357">prev</a><span>|</span><a href="#39183316">next</a><span>|</span><label class="collapse" for="c-39185798">[-]</label><label class="expand" for="c-39185798">[1 more]</label></div><br/><div class="children"><div class="content">As an amateur coder, this really matches my journey, though with a slightly different ordering: after the usual BASIC&#x2F;Perl&#x2F;Python homebase, a few years really expanding my mind in Haskell-land, followed by a &quot;well, I&#x27;ve bounced off Lisp in the past, let&#x27;s see what I make of it now&quot;, then having real joy in writing Clojure, exploring Guile and Scheme, and then coming finally to appreciate Common Lisp, warts and all.<p>I still &quot;see the parentheses&quot;, and I wish there was a way (outside Coalton) to integrate the security that a strong typechecker can provide, but I really do enjoy working in the Lisp ecosystems now, and feel like I understand Lispers excitement at what they have.</div><br/></div></div><div id="39183316" class="c"><input type="checkbox" id="c-39183316" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#39185798">prev</a><span>|</span><a href="#39186417">next</a><span>|</span><label class="collapse" for="c-39183316">[-]</label><label class="expand" for="c-39183316">[24 more]</label></div><br/><div class="children"><div class="content">Regarding Guile, and, mind, I&#x27;m on macOS, but I found it not easy to get started with.<p>I&#x27;m looking for a compiled Scheme or Lisp. By that I mean, I want &quot;prog.ext&quot; to create the executable &quot;prog&quot;.<p>I want this because I want to make some command line utilities, and I would like the actual code compiled (vs some p-code bundled with an interpreter).<p>I had tried to get started with Guile, as all of its packages looked attractive, but was stymied. It&#x27;s been awhile, so I can&#x27;t express details. It had to do with a combination of things like packages, modules, and I know I ran into a version issue (I think I wasn&#x27;t running the latest version from my package manager, so it didn&#x27;t have something in the documentation).<p>Anyway, for such an extensive system, I found it surprisingly frustrating.<p>I&#x27;ve been trying Gambit, which seems like it would be a really nice fit, but it&#x27;s fighting with my Mac, because macOS doesn&#x27;t put stuff in &#x2F;usr&#x2F;include (wchar.h in this case), and all of my efforts to fix that have failed (save I have not tried upgrading to whatever the latest macOS is).<p>Maybe I can try ECL, maybe that will work.<p>But, anyway, Guile, while attractive, just surprised me at how I wasn&#x27;t really able to make it work for me enough to make me look elsewhere.</div><br/><div id="39184508" class="c"><input type="checkbox" id="c-39184508" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183391">next</a><span>|</span><label class="collapse" for="c-39184508">[-]</label><label class="expand" for="c-39184508">[1 more]</label></div><br/><div class="children"><div class="content">Try Racket. It’s easy to setup (from experience on macOS), easy to learn, batteries included, and a compiled Scheme (create binaries via `raco`, <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;raco&#x2F;exe.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;raco&#x2F;exe.html</a>).<p>It’s real highlights are very powerful macros and the ability to override the reader, so you can effectively create arbitrary languages (examples include reimplementations of Java, Lua, and Datalog, and a documentation generator with embedded Racket called Scribble). IMO it’s a research language first and foremost. But it has unusually good production support and online resources (I mean it when I say it’s easy to setup and learn), so I think it fits everything you asked for.</div><br/></div></div><div id="39183391" class="c"><input type="checkbox" id="c-39183391" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39184508">prev</a><span>|</span><a href="#39183949">next</a><span>|</span><label class="collapse" for="c-39183391">[-]</label><label class="expand" for="c-39183391">[3 more]</label></div><br/><div class="children"><div class="content">I suggest Gauche as an easier-to-use Guile alternative. I had similar annoyances with actually getting Guile to just do what it says it&#x27;s supposed to be able to do.<p>I&#x27;ve advertised Gauche frequently here on HN (including in another comment in this thread). I have no affiliation with the project, but I like it a lot and I think it&#x27;s under-appreciated. Its author hosts its documentation under the domain name &quot;practical-scheme.net&quot; (<a href="https:&#x2F;&#x2F;practical-scheme.net&#x2F;gauche&#x2F;man&#x2F;gauche-refe&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;practical-scheme.net&#x2F;gauche&#x2F;man&#x2F;gauche-refe&#x2F;index.ht...</a>) and I think the name is very well deserved.</div><br/><div id="39186422" class="c"><input type="checkbox" id="c-39186422" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183391">parent</a><span>|</span><a href="#39186857">next</a><span>|</span><label class="collapse" for="c-39186422">[-]</label><label class="expand" for="c-39186422">[1 more]</label></div><br/><div class="children"><div class="content">Guile is really designed with embedding into a program in mind. Gauche is definitely more geared towards their use case, but I think their issues with Gambit can probably be resolved with a few environment variables or command line options</div><br/></div></div><div id="39186857" class="c"><input type="checkbox" id="c-39186857" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183391">parent</a><span>|</span><a href="#39186422">prev</a><span>|</span><a href="#39183949">next</a><span>|</span><label class="collapse" for="c-39186857">[-]</label><label class="expand" for="c-39186857">[1 more]</label></div><br/><div class="children"><div class="content">Easier to use in what sense?</div><br/></div></div></div></div><div id="39183949" class="c"><input type="checkbox" id="c-39183949" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183391">prev</a><span>|</span><a href="#39183394">next</a><span>|</span><label class="collapse" for="c-39183949">[-]</label><label class="expand" for="c-39183949">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m looking for a compiled Scheme or Lisp. By that I mean, I want &quot;prog.ext&quot; to create the executable &quot;prog&quot;.<p>sbcl compiles and generates an executable quite nicely.</div><br/></div></div><div id="39183394" class="c"><input type="checkbox" id="c-39183394" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183949">prev</a><span>|</span><a href="#39185720">next</a><span>|</span><label class="collapse" for="c-39183394">[-]</label><label class="expand" for="c-39183394">[4 more]</label></div><br/><div class="children"><div class="content">Janet is the perfect lisp for cli tools. <a href="https:&#x2F;&#x2F;janet.guide" rel="nofollow">https:&#x2F;&#x2F;janet.guide</a>. It is my favorite.</div><br/><div id="39183897" class="c"><input type="checkbox" id="c-39183897" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183394">parent</a><span>|</span><a href="#39183633">next</a><span>|</span><label class="collapse" for="c-39183897">[-]</label><label class="expand" for="c-39183897">[1 more]</label></div><br/><div class="children"><div class="content">, should be (unquote) and ,@ should be (unquote-splicing) while ; is for comments, yet Janet completely disregards this convention. It&#x27;s stupid, but I dislike Janet because of this.</div><br/></div></div><div id="39183633" class="c"><input type="checkbox" id="c-39183633" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183394">parent</a><span>|</span><a href="#39183897">prev</a><span>|</span><a href="#39185720">next</a><span>|</span><label class="collapse" for="c-39183633">[-]</label><label class="expand" for="c-39183633">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still not sure of what the Janet value proposition is compared to an R7RS Scheme. Not that it shouldn&#x27;t exist! I just don&#x27;t quite get the use case either.</div><br/><div id="39185122" class="c"><input type="checkbox" id="c-39185122" checked=""/><div class="controls bullet"><span class="by">ianthehenry</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183633">parent</a><span>|</span><a href="#39185720">next</a><span>|</span><label class="collapse" for="c-39185122">[-]</label><label class="expand" for="c-39185122">[1 more]</label></div><br/><div class="children"><div class="content">Janet’s value proposition is pretty similar to Lua — easy embedding, simple C API, minimalist runtime. But Janet improves on some weird Lua warts (block-scoped variables by default, 0-indexed collections, separate types for sequential and associative arrays). Plus it bundles a pretty nice standard library.<p>I’ve seen this comparison before, so clearly Janet isn’t doing a good job of explaining itself, but I think the only thing Janet and Scheme have in common are a few parentheses. Different core data structures, different feelings about mutability, completely different macro system…<p>Guile and Janet share PEGs (sorta) and embeddability but I didn’t think those were standardized at all. (I don’t really know any schemes.)</div><br/></div></div></div></div></div></div><div id="39185720" class="c"><input type="checkbox" id="c-39185720" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183394">prev</a><span>|</span><a href="#39186131">next</a><span>|</span><label class="collapse" for="c-39185720">[-]</label><label class="expand" for="c-39185720">[2 more]</label></div><br/><div class="children"><div class="content">Guile always surprised me not because of anything LISPy, but because of its relationship with TCL<p><a href="https:&#x2F;&#x2F;vanderburg.org&#x2F;old_pages&#x2F;Tcl&#x2F;war&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vanderburg.org&#x2F;old_pages&#x2F;Tcl&#x2F;war&#x2F;</a></div><br/><div id="39187299" class="c"><input type="checkbox" id="c-39187299" checked=""/><div class="controls bullet"><span class="by">Pinus</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39185720">parent</a><span>|</span><a href="#39186131">next</a><span>|</span><label class="collapse" for="c-39187299">[-]</label><label class="expand" for="c-39187299">[1 more]</label></div><br/><div class="children"><div class="content">In RMS’ message that started that discussion, he stated that the GNU project intended to provide <i>two</i> languages — one Lisp-like (which I assume eventually became Guile), and one with a more algebra-like syntax. Did anything ever come out of the latter?</div><br/></div></div></div></div><div id="39186131" class="c"><input type="checkbox" id="c-39186131" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39185720">prev</a><span>|</span><a href="#39183510">next</a><span>|</span><label class="collapse" for="c-39186131">[-]</label><label class="expand" for="c-39186131">[1 more]</label></div><br/><div class="children"><div class="content">The creator of Programming Language Benchmarks 2 is on Apple Silicon, and apparently SBCL compilation works out of the box: &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;plb2">https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;plb2</a>&gt;.</div><br/></div></div><div id="39183510" class="c"><input type="checkbox" id="c-39183510" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39186131">prev</a><span>|</span><a href="#39183576">next</a><span>|</span><label class="collapse" for="c-39183510">[-]</label><label class="expand" for="c-39183510">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a mac user but I got someone who had never used guile before setup using homebrew to get guile and emacs, and then the guile homebrew tap (<a href="https:&#x2F;&#x2F;github.comad&#x2F;aconchillo&#x2F;homebrew-guile" rel="nofollow">https:&#x2F;&#x2F;github.comad&#x2F;aconchillo&#x2F;homebrew-guile</a>) for guile libraries.</div><br/></div></div><div id="39183576" class="c"><input type="checkbox" id="c-39183576" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183510">prev</a><span>|</span><a href="#39183346">next</a><span>|</span><label class="collapse" for="c-39183576">[-]</label><label class="expand" for="c-39183576">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that guile is an extension language. Create a prog.c and link to guile, that&#x27;s how I think you can create an executable.</div><br/><div id="39183928" class="c"><input type="checkbox" id="c-39183928" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183576">parent</a><span>|</span><a href="#39183346">next</a><span>|</span><label class="collapse" for="c-39183928">[-]</label><label class="expand" for="c-39183928">[1 more]</label></div><br/><div class="children"><div class="content">Creating a C program that links to libguile is kind of a legacy use-case at this point. It was the original purpose of Guile back when it was but a simple interpreter. The trajectory for the past decade or so has been to build up Guile as a platform for writing your entire application.  Rather than embedding an interpreter in a C program, the recommended approach is to write a Scheme program that uses the C FFI if and when necessary. The interpreter was once written in C but is now written in Scheme (a minimal C interpreter is kept around for bootstrapping purposes.) There&#x27;s a sophisticated optimizing compiler that emits bytecode for the Guile VM as well as a JIT compiler. A new garbage collector and a Wasm compiler backend are currently being developed.  The big missing piece is ahead-of-time native compilation, but the work on the Wasm backend will help that along as it needs to solve a lot of the same problems.</div><br/></div></div></div></div><div id="39183346" class="c"><input type="checkbox" id="c-39183346" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183576">prev</a><span>|</span><a href="#39184907">next</a><span>|</span><label class="collapse" for="c-39183346">[-]</label><label class="expand" for="c-39183346">[7 more]</label></div><br/><div class="children"><div class="content">What about chicken scheme or chez scheme?</div><br/><div id="39183475" class="c"><input type="checkbox" id="c-39183475" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183346">parent</a><span>|</span><a href="#39183409">next</a><span>|</span><label class="collapse" for="c-39183475">[-]</label><label class="expand" for="c-39183475">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got similar interests to the OP and the parent comment. I had some fun with both Chicken and Chez, but building standalone&#x2F;static binaries was a bit of a pain.<p>The interesting thing for me (a while back) was realizing that even doing something as simple as an HTTPS request would be a bit of a challenge: <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2019&#x2F;06&#x2F;20&#x2F;2310" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2019&#x2F;06&#x2F;20&#x2F;2310</a></div><br/></div></div><div id="39183409" class="c"><input type="checkbox" id="c-39183409" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183346">parent</a><span>|</span><a href="#39183475">prev</a><span>|</span><a href="#39184298">next</a><span>|</span><label class="collapse" for="c-39183409">[-]</label><label class="expand" for="c-39183409">[4 more]</label></div><br/><div class="children"><div class="content">Chicken kind of felt like a dying ecosystem when I tried it, and it&#x27;s also not very fast. The standard library itself is kind of limited, so if I couldn&#x27;t find an egg for something I wanted to do, I felt very stuck.<p>Chez is good because it&#x27;s supported by Akku, but I&#x27;m not sure if it will ever support R7RS. It does have a really nice FFI though, and the docs are very good.</div><br/><div id="39184296" class="c"><input type="checkbox" id="c-39184296" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183409">parent</a><span>|</span><a href="#39184298">next</a><span>|</span><label class="collapse" for="c-39184296">[-]</label><label class="expand" for="c-39184296">[3 more]</label></div><br/><div class="children"><div class="content">R7RS isn&#x27;t worth supporting right now.<p>R5RS is too small for real work unless you add tons of SRFIs, so they created R6RS for people who want to get stuff done. But the the R5RS people got ticked off because &quot;its too big&quot;.<p>R7RS was supposed to be a compromise with a tiny R7RS-small, but later adding most of the R6RS features with R7RS-large. It&#x27;s now been a decade and R7RS-large seems to be completely dead.</div><br/><div id="39184918" class="c"><input type="checkbox" id="c-39184918" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39184296">parent</a><span>|</span><a href="#39184298">next</a><span>|</span><label class="collapse" for="c-39184918">[-]</label><label class="expand" for="c-39184918">[2 more]</label></div><br/><div class="children"><div class="content">R7RS is very much worth supporting; there&#x27;ll shortly be a Chicken Scheme 6 with full support for R7RS-Small.<p>R7RS-Large development is slow, but not at all dead.</div><br/><div id="39185568" class="c"><input type="checkbox" id="c-39185568" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39184918">parent</a><span>|</span><a href="#39184298">next</a><span>|</span><label class="collapse" for="c-39185568">[-]</label><label class="expand" for="c-39185568">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been 10 years since R7RS launched and I believe around 15 years since R7RS-large began work. That goes a bit beyond &quot;slow&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="39184298" class="c"><input type="checkbox" id="c-39184298" checked=""/><div class="controls bullet"><span class="by">timbit42</span><span>|</span><a href="#39183316">root</a><span>|</span><a href="#39183346">parent</a><span>|</span><a href="#39183409">prev</a><span>|</span><a href="#39184907">next</a><span>|</span><label class="collapse" for="c-39184298">[-]</label><label class="expand" for="c-39184298">[1 more]</label></div><br/><div class="children"><div class="content">Also, Larceny (R7RS, UTF-8, compiles to x86, x64, ARM, C).</div><br/></div></div></div></div><div id="39184907" class="c"><input type="checkbox" id="c-39184907" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39183316">parent</a><span>|</span><a href="#39183346">prev</a><span>|</span><a href="#39186417">next</a><span>|</span><label class="collapse" for="c-39184907">[-]</label><label class="expand" for="c-39184907">[1 more]</label></div><br/><div class="children"><div class="content">I can highly recommend Chicken Scheme, it does exactly what you want :) It has also a nice friendly community, and a couple hundred extensions.</div><br/></div></div></div></div><div id="39186417" class="c"><input type="checkbox" id="c-39186417" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#39183316">prev</a><span>|</span><a href="#39184050">next</a><span>|</span><label class="collapse" for="c-39186417">[-]</label><label class="expand" for="c-39186417">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate the shout out to jank, the native Clojure dialect on LLVM with C++ interop. :) Lisp has such a colorful history and Clojure, in my opinion, made it even more accessible and practical. People complain about Clojure&#x27;s error messages, but, coming from C++, anything that doesn&#x27;t corrupt memory and segfault is golden.</div><br/></div></div><div id="39184050" class="c"><input type="checkbox" id="c-39184050" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39186417">prev</a><span>|</span><a href="#39183214">next</a><span>|</span><label class="collapse" for="c-39184050">[-]</label><label class="expand" for="c-39184050">[1 more]</label></div><br/><div class="children"><div class="content">Includes this great comment by Simon Peyton-Jones in support of incremental typing:<p>&quot;I think to try to specify all that a program should do, you get specifications that are themselves so complicated that you&#x27;re not longer confident that they say what you intended.&quot;</div><br/></div></div><div id="39183214" class="c"><input type="checkbox" id="c-39183214" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#39184050">prev</a><span>|</span><a href="#39187417">next</a><span>|</span><label class="collapse" for="c-39183214">[-]</label><label class="expand" for="c-39183214">[27 more]</label></div><br/><div class="children"><div class="content">after decades of programming, lisp has always been that thing that intrigues me endlessly, but I haven&#x27;t had a chance to actually wield it myself. but so many people whose opinions I respect love lisps, and not just for a little while. Clojure especially. Other ideas like datomic and xtdb are also high on my list of things I need to experience. I think im going to have to make an intentional effort to find a lisp job next time.</div><br/><div id="39183259" class="c"><input type="checkbox" id="c-39183259" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#39183214">parent</a><span>|</span><a href="#39185263">next</a><span>|</span><label class="collapse" for="c-39183259">[-]</label><label class="expand" for="c-39183259">[18 more]</label></div><br/><div class="children"><div class="content">Doing Clojure at CircleCI, a few years ago, redefined who I was as an engineer… FWIW. It’s an incredible language.<p>Today I work with python (sigh) and every day I long for Clojure.</div><br/><div id="39183878" class="c"><input type="checkbox" id="c-39183878" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183259">parent</a><span>|</span><a href="#39185263">next</a><span>|</span><label class="collapse" for="c-39183878">[-]</label><label class="expand" for="c-39183878">[17 more]</label></div><br/><div class="children"><div class="content">I keep hearing sentiments like this but then I wonder, if Clojure or &lt;another awesome Lisp&gt; is so much better than Python &lt;or some other mainstream language&gt;, then why are we still writing in those languages? If it&#x27;s because of libraries, then the question is: Why do people write libraries for these languages and not the Lisp ones?</div><br/><div id="39187763" class="c"><input type="checkbox" id="c-39187763" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39186209">next</a><span>|</span><label class="collapse" for="c-39187763">[-]</label><label class="expand" for="c-39187763">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>If it&#x27;s because of libraries, then the question is: Why do people write libraries for these languages and not the Lisp ones?</i><p>Because libraries already exist for those languages, as well as support, vendors, and a big ecosystem, familiar syntax, and jobs. So they write libraries for languages that are already popular.<p>If you meant, &quot;but why wasn&#x27;t some Lisp the one that gain popularity back in the day, when C, C++, Python, and Java didn&#x27;t exist or where still fresh?&quot;<p>I think because:<p>1) it was too advanced for the procedural mindset at the time,<p>2) it was not sufficiently efficient in those primitive 16 bit machines<p>3) fragmentation<p>and most importantly, no killer app and major vendor backing or OS first-class support (like C had for UNIX, C++ for Windows, and Java got from SUN).</div><br/></div></div><div id="39186209" class="c"><input type="checkbox" id="c-39186209" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39187763">prev</a><span>|</span><a href="#39185719">next</a><span>|</span><label class="collapse" for="c-39186209">[-]</label><label class="expand" for="c-39186209">[2 more]</label></div><br/><div class="children"><div class="content">Lisps are &quot;wizard&quot; languages: the runtime semantic is kept close to the syntax, which also means that you can rapidly extend the syntax to solve a problem. This quality is true of Forth as well, and shares some energy with APL and its &quot;one symbol for one behavior&quot; flavor. With respect to their metaprogramming, the syntactical approach hands you a great foot-gun in that you can design syntax that is very confusing and specific to your project, which nobody else will be able to ramp up on.<p>But Algols, including Python, are &quot;bureaucrat&quot; languages: rather than condensing the syntax to be the exact specification of the program, they define a right way to form the expression, and then the little man inside the compiler rubber stamps it when you press the run button. In other words, they favor defining a semantics and then adding a syntax around that, which means that they need more syntax, it&#x27;s harder to explain the behavior of a syntactical construction, and it&#x27;s harder to extend to have new syntax. But by being consistent in a certain form-filling way, they enable a team to collaborate and hand off relatively more code.<p>IMHO, a perfectly reasonable approach I&#x27;m exploring now for personal work is to have a Lisp(or something that comes close enough in size, dynamic behavior, and convenience, like Lua) targeting a Forth. The Forth is there to be a stack machine with a REPL. You can extend the Forth upwards a little bit because it can metaprogram, or downwards to access the machine. It is better for development than a generic bytecode VM because it ships in a bootstrappable form, with everything you need for debugging and extension - it is there to be the layer that talks to the machine, as directly as possible, so nothing is hidden behind a specialized protocol. And you can use the Lisp to be the compiler, to add the rubber-stamping semantics, work through resource tracking issues, do garbage collection and complicated string parsing, and generate &quot;dumb&quot; Forth code where it&#x27;s called for. That creates a nice mixture of legibility and configurability, where you can address the software in a nuts-and-bolts way or with &quot;I want an algorithm generating this functionality&quot;.</div><br/><div id="39187599" class="c"><input type="checkbox" id="c-39187599" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39186209">parent</a><span>|</span><a href="#39185719">next</a><span>|</span><label class="collapse" for="c-39187599">[-]</label><label class="expand" for="c-39187599">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IMHO, a perfectly reasonable approach I&#x27;m exploring now for personal work is to have a Lisp(or something that comes close enough in size, dynamic behavior, and convenience, like Lua) targeting a Forth.<p>I&#x27;ve had this idea for a while now but never got around to actually executing it. I&#x27;d love to follow your progress if you&#x27;re doing it publicly.</div><br/></div></div></div></div><div id="39185719" class="c"><input type="checkbox" id="c-39185719" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39186209">prev</a><span>|</span><a href="#39185303">next</a><span>|</span><label class="collapse" for="c-39185719">[-]</label><label class="expand" for="c-39185719">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Why do people write libraries for these languages and not the Lisp ones?</i><p>1. They want their names to be widely recognized, so they find a popular bandwagon to hop onto.<p>2. Raw numbers? More people using Python means more people trying to make libraries for Python, means more libraries remaining in the race after you eliminate the crap from people who don&#x27;t know how to write libraries.<p>Note that Python is, by now, an old language. It wasn&#x27;t instantly popular, and you wouldn&#x27;t have predicted it. In, say, 1999, you had to be some GNU&#x2F;Linux person to even know what Python is. It was far from obvious that, of all things, it would get so popular. That Eric Raymond article in the Linux Journal around that time probably gave it a bit of a boost.<p>Python definitely rode on the coattails of increasing GNU&#x2F;Linux popularity, too. More people using Linux started asking questions how to script this and that, and going &quot;gack!&quot; at shell or perl programming. It seems Python might appeal to survivors of VisualBasic shifting gears into GNU&#x2F;Linux stuff.</div><br/></div></div><div id="39185303" class="c"><input type="checkbox" id="c-39185303" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39185719">prev</a><span>|</span><a href="#39184367">next</a><span>|</span><label class="collapse" for="c-39185303">[-]</label><label class="expand" for="c-39185303">[2 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s weird enough to be off-putting, and it doesn&#x27;t solve a real-world problem.<p>If you look at the arguments in favor of Lisp, they&#x27;ll often boil down to it being &quot;beautiful&quot;, &quot;elegant&quot;, &quot;flexible&quot;, or even &quot;magical&quot;. It&#x27;s a very minimal language which allows you to do absolutely <i>anything</i> - a lot of which would be an absolute nightmare in most other languages. You could implement just about any programming paradigm in Lisp if you want to. I believe this makes it very appealing to computer <i>scientists</i>, or other people with a more mathematical background. However, this flexibility is also a massive footgun: if you&#x27;re not careful your junior developer might end up reinventing the wheel a dozen times, and writing completely unmaintainable code in the process.<p>On the other hand, most other programming languages look kind-of the same. They are all quite opinionated about how stuff is supposed to work, with a lot of hardware details leaking into the language. However, they are <i>very</i> easy to learn: most of it is just &quot;do a bunch of operations in succession&quot; taken to the extreme. Anyone who knows C# will be able to pick up a basic understanding of C, Python, or JavaScript well within a day, and a lot of people new to programming will be able to write not-completely-terrible code within a month or two when given the right guidance. They don&#x27;t need to know about all the abstractions and technical details to be a functioning member of your team.<p>When you&#x27;re running a business, you don&#x27;t care about any of that beauty or flexibility. You want code which is quick and easy to write, trivial to read, and understandable by even the worst programmer in your company. In practice that means in your comparison you&#x27;ll be choosing Python over Lisp. Heck, Go was developed entirely around this principle, cutting out as many language features as possible. And because <i>all the other companies</i> are making the same choice there will also be way more libraries for Python, making the gap even larger.<p>So yeah, in a stroke of irony Lisp isn&#x27;t more popular <i>because</i> it is better.</div><br/><div id="39185795" class="c"><input type="checkbox" id="c-39185795" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39185303">parent</a><span>|</span><a href="#39184367">next</a><span>|</span><label class="collapse" for="c-39185795">[-]</label><label class="expand" for="c-39185795">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because it&#x27;s weird enough to be off-putting, and it doesn&#x27;t solve a real-world problem.<p>Nonsense. Quoth Wikipedia, &quot;Lisp pioneered many ideas in computer science, including tree data structures, automatic storage management, dynamic typing, conditionals, higher-order functions, recursion, the self-hosting compiler, and the read–eval–print loop.&quot; These are all solutions to real world problems.<p>So many languages borrow features that were originally developed in Lisp.<p>&gt; However, this flexibility is also a massive footgun: if you&#x27;re not careful your junior developer might end up reinventing the wheel a dozen times, and writing completely unmaintainable code in the process.<p>Plenty of code written in Lisp looks just like your Python, Ruby, JavaScript, Java, et al programs where you&#x27;re defining structures or classes, writing and calling functions, importing useful libraries, etc. Plenty of this Lisp code is just as maintainable as the non-S-expression code.<p>&gt; Anyone who knows C# will be able to pick up a basic understanding of C, Python, or JavaScript well within a day<p>Same with Lisp. It&#x27;s just:<p>(function arg1 arg2)<p>Instead of<p>function(arg1, arg2)<p>&gt; You want code which is quick and easy to write, trivial to read, and understandable by even the worst programmer in your company.<p>There is plenty of &quot;lowest common denominator&quot; code like this written in Lisp. Much Lisp code is not buried under inscrutable macros, just like not all Java code is buried under layers of inscrutable classes.</div><br/></div></div></div></div><div id="39184367" class="c"><input type="checkbox" id="c-39184367" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39185303">prev</a><span>|</span><a href="#39184203">next</a><span>|</span><label class="collapse" for="c-39184367">[-]</label><label class="expand" for="c-39184367">[1 more]</label></div><br/><div class="children"><div class="content">For the same reason people can&#x27;t change their well-established habits and opinions, particularly those that have network effects.<p>Language popularity has little to do with how well languages are designed or how simple they actually are. Most popular languages are popular for historical reasons.</div><br/></div></div><div id="39184203" class="c"><input type="checkbox" id="c-39184203" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39184367">prev</a><span>|</span><a href="#39185637">next</a><span>|</span><label class="collapse" for="c-39184203">[-]</label><label class="expand" for="c-39184203">[2 more]</label></div><br/><div class="children"><div class="content">Because of habit.  There is always a cost in trying to learn something new, to the level you are on with some other language and it&#x27;s tooling and libraries.<p>Programmers who program in some language for a few years realize they are still learning more about it, all the time. Therefore they know if they switched to another language it would also take them a few years to attain the same level of mastery.<p>And then there is similar inertia with an organization that has lots of code in some specific language already.</div><br/><div id="39184313" class="c"><input type="checkbox" id="c-39184313" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39184203">parent</a><span>|</span><a href="#39185637">next</a><span>|</span><label class="collapse" for="c-39184313">[-]</label><label class="expand" for="c-39184313">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s more than just about the language itself, as I describe here: <a href="https:&#x2F;&#x2F;www.fosskers.ca&#x2F;en&#x2F;blog&#x2F;software-dev-langs" rel="nofollow">https:&#x2F;&#x2F;www.fosskers.ca&#x2F;en&#x2F;blog&#x2F;software-dev-langs</a><p>For some people, community signals are very important. Massive conferences or raw number of libraries, etc.,  indicate some inner quality of that language&#x27;s ecosystem that they value.</div><br/></div></div></div></div><div id="39185637" class="c"><input type="checkbox" id="c-39185637" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39184203">prev</a><span>|</span><a href="#39184302">next</a><span>|</span><label class="collapse" for="c-39185637">[-]</label><label class="expand" for="c-39185637">[2 more]</label></div><br/><div class="children"><div class="content">Most Python users aren&#x27;t software engineers.  They&#x27;re students, scientists, business analysts... We&#x27;re lucky that we were able to drag them away from Excel.  Asking them to learn yet another programming language might be a bit much.  And if they did, it wouldn&#x27;t probably be a lisp (it would probably be among: C, Javascript, Julia, Go, Nim).<p>I want to move on from Python, but there are so many more people that I can help if I stay.</div><br/><div id="39187823" class="c"><input type="checkbox" id="c-39187823" checked=""/><div class="controls bullet"><span class="by">tugberkk</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39185637">parent</a><span>|</span><a href="#39184302">next</a><span>|</span><label class="collapse" for="c-39187823">[-]</label><label class="expand" for="c-39187823">[1 more]</label></div><br/><div class="children"><div class="content">I have the same problem. It is a good language to teach to non-cs majors. If you want to build something out of the box, use Python. However, GPT is coming and maybe we won&#x27;t even use Python anymore for simpler tasks.</div><br/></div></div></div></div><div id="39184302" class="c"><input type="checkbox" id="c-39184302" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39185637">prev</a><span>|</span><a href="#39185941">next</a><span>|</span><label class="collapse" for="c-39184302">[-]</label><label class="expand" for="c-39184302">[1 more]</label></div><br/><div class="children"><div class="content">Social forces and economics. Lisps were winning in academia for a while. Unix started winning in the engineering world before Lisp systems really got their feet under them. Engineers made a lot of money, and academia shifted focus to the systems that were making money. Now everyone programs for Unix instead of Lisp.</div><br/></div></div><div id="39185941" class="c"><input type="checkbox" id="c-39185941" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39184302">prev</a><span>|</span><a href="#39184370">next</a><span>|</span><label class="collapse" for="c-39185941">[-]</label><label class="expand" for="c-39185941">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone is saying Clojure is better than Python in the abstract. Clojure has a different style from Python and that style can be more fun and is better for some specific tasks like application programming and anything that wants to use multiple CPU cores. Tends to have better long term prospects too, old Python code doesn&#x27;t work in my experience but things on the JVM have cockroach powers.<p>As for why things are and aren&#x27;t popular, who knows? It is quite possible that people just don&#x27;t like the look of the parenthesis, or there are a couple of key libraries that aren&#x27;t good but nobody vocal has put there finger on which ones. The error messaging isn&#x27;t quite up to a standard that people want to deal with. Or maybe popularity is really just about pure random chance, at most 4 languages get to have &gt;20% market share, by definition.</div><br/></div></div><div id="39184370" class="c"><input type="checkbox" id="c-39184370" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39185941">prev</a><span>|</span><a href="#39184975">next</a><span>|</span><label class="collapse" for="c-39184370">[-]</label><label class="expand" for="c-39184370">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day, things get popular through social processes, so it&#x27;s far more a matter of social factors—some of which are practically random—than any intrinsic qualities of the thing itself.</div><br/></div></div><div id="39185135" class="c"><input type="checkbox" id="c-39185135" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183878">parent</a><span>|</span><a href="#39184975">prev</a><span>|</span><a href="#39185263">next</a><span>|</span><label class="collapse" for="c-39185135">[-]</label><label class="expand" for="c-39185135">[1 more]</label></div><br/><div class="children"><div class="content">I can say at least that Haskell is this way for me.</div><br/></div></div></div></div></div></div><div id="39185263" class="c"><input type="checkbox" id="c-39185263" checked=""/><div class="controls bullet"><span class="by">horeszko</span><span>|</span><a href="#39183214">parent</a><span>|</span><a href="#39183259">prev</a><span>|</span><a href="#39183401">next</a><span>|</span><label class="collapse" for="c-39185263">[-]</label><label class="expand" for="c-39185263">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think im going to have to make an intentional effort to find a lisp job next time.<p>Does anyone have any tips on where to find a lisp job?</div><br/><div id="39185628" class="c"><input type="checkbox" id="c-39185628" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39185263">parent</a><span>|</span><a href="#39186549">next</a><span>|</span><label class="collapse" for="c-39185628">[-]</label><label class="expand" for="c-39185628">[1 more]</label></div><br/><div class="children"><div class="content">Lisp jobs are sometimes advertised in Who&#x27;s Hiring threads, Reddit&#x27;s r&#x2F;lisp, etc. There&#x27;s a Lisp job advertised on Reddit [1,2] right now even. Another good source is to check out the companies in [3] and see if they have any openings on their website (or cold-emailing).<p>[1] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;s&#x2F;AZmouaoARl" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;s&#x2F;AZmouaoARl</a><p>[2] <a href="https:&#x2F;&#x2F;jobs.lever.co&#x2F;dodmg&#x2F;af802f7f-4e44-4457-9e49-14bc47bd8b31" rel="nofollow">https:&#x2F;&#x2F;jobs.lever.co&#x2F;dodmg&#x2F;af802f7f-4e44-4457-9e49-14bc47bd...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies">https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies</a></div><br/></div></div><div id="39186549" class="c"><input type="checkbox" id="c-39186549" checked=""/><div class="controls bullet"><span class="by">john-shaffer</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39185263">parent</a><span>|</span><a href="#39185628">prev</a><span>|</span><a href="#39183401">next</a><span>|</span><label class="collapse" for="c-39186549">[-]</label><label class="expand" for="c-39186549">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;jobs.braveclojure.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jobs.braveclojure.com&#x2F;</a></div><br/></div></div></div></div><div id="39183401" class="c"><input type="checkbox" id="c-39183401" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#39183214">parent</a><span>|</span><a href="#39185263">prev</a><span>|</span><a href="#39187417">next</a><span>|</span><label class="collapse" for="c-39183401">[-]</label><label class="expand" for="c-39183401">[5 more]</label></div><br/><div class="children"><div class="content">My take on Lisp after going (partway) through SICP, is that it&#x27;s a syntax and not so much a language. The language is what you build up for the particular kinds of things you need to do. This is both the strength and weakness of Lisp, with a tight-knit competent team, everything is elegantly achievable. However on a small&#x2F;understaffed team or one with high turnover, each member has to onboard onto that team&#x27;s language built using Lisp.<p>Imagine the best and worst DSLs that you&#x27;ve had to use. Joining a Lisp team would be somewhere on that spectrum though I hope their homegrown&#x2F;app language is far better than the average&#x2F;bad DSL.<p>Clojure is much better in that it has many &#x27;batteries included&#x27; and opinions on things to make different codebases less different than with other Lisps.</div><br/><div id="39183627" class="c"><input type="checkbox" id="c-39183627" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183401">parent</a><span>|</span><a href="#39183544">next</a><span>|</span><label class="collapse" for="c-39183627">[-]</label><label class="expand" for="c-39183627">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s any help, SICP is the wrong place to start for actually learning Scheme as a practical language. It&#x27;s for learning about &quot;the structure and interpretation of computer programs&quot;, which is not the same thing as &quot;writing useful computer programs&quot;.</div><br/></div></div><div id="39183544" class="c"><input type="checkbox" id="c-39183544" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183401">parent</a><span>|</span><a href="#39183627">prev</a><span>|</span><a href="#39187417">next</a><span>|</span><label class="collapse" for="c-39183544">[-]</label><label class="expand" for="c-39183544">[3 more]</label></div><br/><div class="children"><div class="content">My take on Lisps is that people overblow the DSL aspect of it.  I just write functions that call other functions, as opposed to methods that call other methods.</div><br/><div id="39183675" class="c"><input type="checkbox" id="c-39183675" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39183214">root</a><span>|</span><a href="#39183544">parent</a><span>|</span><a href="#39187417">next</a><span>|</span><label class="collapse" for="c-39183675">[-]</label><label class="expand" for="c-39183675">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a fine thing to do in Common Lisp.  If you ever change your mind, it&#x27;s very easy to change a function into a generic function and split off the body into one or more methods.</div><br/></div></div></div></div></div></div></div></div><div id="39187417" class="c"><input type="checkbox" id="c-39187417" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39183214">prev</a><span>|</span><a href="#39183666">next</a><span>|</span><label class="collapse" for="c-39187417">[-]</label><label class="expand" for="c-39187417">[2 more]</label></div><br/><div class="children"><div class="content">Scheme has a special place in my heart after working through SICP as a late high schooler.<p>I probably haven&#x27;t actively written anything in Scheme in a decade, but it later inspired me to learn Haskell to a decent level of depth, just to see what the &quot;other&quot; functional languages feel like. So much the same, yet so much different.</div><br/><div id="39187461" class="c"><input type="checkbox" id="c-39187461" checked=""/><div class="controls bullet"><span class="by">eggdaft</span><span>|</span><a href="#39187417">parent</a><span>|</span><a href="#39183666">next</a><span>|</span><label class="collapse" for="c-39187461">[-]</label><label class="expand" for="c-39187461">[1 more]</label></div><br/><div class="children"><div class="content">Scheme was taught in my first year of CS.<p>One thing I noticed is that those who hadn’t coded through their teenage years found scheme much easier to learn than other languages we were being taught in the first year. I think that was because scheme felt more like mathematics and everyone had done A Level maths (in the UK), many to an advanced level.<p>Immutability and functions make a lot more sense than weird variables that keep changing and - what the heck are classes? We just unlearn this mathematical thinking when we start hacking Python etc.</div><br/></div></div></div></div><div id="39183666" class="c"><input type="checkbox" id="c-39183666" checked=""/><div class="controls bullet"><span class="by">charlotte-fyi</span><span>|</span><a href="#39187417">prev</a><span>|</span><a href="#39185395">next</a><span>|</span><label class="collapse" for="c-39183666">[-]</label><label class="expand" for="c-39183666">[26 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t really get the criticism of Clojure for being hosted on the JVM, particularly relative to its status as a &quot;productive&quot; Lisp. Like oh, you get access to one of the biggest and most mature library ecosystems out there as well as best in class operational tooling? Obviously there are use cases where the JVM doesn&#x27;t fit and all things being equal I prefer shipping statically linked binaries too, but the JVM still feels like an obvious &quot;pro&quot; here.</div><br/><div id="39185041" class="c"><input type="checkbox" id="c-39185041" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39184684">next</a><span>|</span><label class="collapse" for="c-39185041">[-]</label><label class="expand" for="c-39185041">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t really get the criticism of Clojure for being hosted on the JVM, particularly relative to its status as a &quot;productive&quot; Lisp.<p>If you are doing long running server side apps, it is a better fit. Even better if you are already a Java shop.<p>Otherwise, its either detrimental or, at the very least, a source of very &#x27;alien&#x27; behavior, not the least of which being the stack traces. That gets pretty obvious when you compare with the likes of Common Lisp with its incredibly elegant system that&#x27;s essentially Lisp _almost_ all the way down.<p>The JVM has its own advantages of course. Billions of dollars of optimization work being one of them. Being able to use java libraries to fill the gaps (at the expense of the less elegant stack traces and some<p>It can be a complete show stopper in many applications. Say, you want to interface with C libraries. Or embed some form of Lisp in your app. Browser-based apps (emscripten doesn&#x27;t help you), which is why Clojurescript exists.<p>Or you are building something like an iOS application. I have successfully embedded (although not shipped to the App store) Chicken Scheme in a couple of different ways. The first, as a library with all the cross compilation nonsense. And the second, by simply telling the compiler to stop at C code generation, adding the C blob in the app, and compiling everything together with the rest of the app. That gave me a remote REPL which was amazing for debugging.</div><br/><div id="39185709" class="c"><input type="checkbox" id="c-39185709" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39185041">parent</a><span>|</span><a href="#39184684">next</a><span>|</span><label class="collapse" for="c-39185709">[-]</label><label class="expand" for="c-39185709">[1 more]</label></div><br/><div class="children"><div class="content">Fair points, I say. But interfacing with C isn&#x27;t a show stopper is it? Clojure can bridge to C by exposing the C library though the JNI&#x2F;JNA framework.<p>It isn&#x27;t much fun and there are certainly situations where I&#x27;d say Clojure was a poor choice for calling C&#x2F;C++ libraries, but if you need to do it then it can be done.</div><br/></div></div></div></div><div id="39184684" class="c"><input type="checkbox" id="c-39184684" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39185041">prev</a><span>|</span><a href="#39185426">next</a><span>|</span><label class="collapse" for="c-39184684">[-]</label><label class="expand" for="c-39184684">[6 more]</label></div><br/><div class="children"><div class="content">I hardly wrote any Clojure, but the only thing that bugged me was the startup time of the repl. It&#x27;s been talked about enough. Yes, that problem goes away if I use a proper setup with a language server or whatever, and yes it doesn&#x27;t matter for &quot;situated&quot; production applications, but it still peeved me.<p>What do I care if it&#x27;s in the JVM? Sure, a JVM instance uses a lot of memory to help the garbage collector, but that doesn&#x27;t bother me. JVM is just an old, mature ecosystem. Every runtime we work with (browser, nodejs, CPython, your decades of hand-written C++, the Go standard library) shares design tradeoffs with the JVM. Nothing inherently off-putting about it.</div><br/><div id="39184763" class="c"><input type="checkbox" id="c-39184763" checked=""/><div class="controls bullet"><span class="by">coffeemug</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184684">parent</a><span>|</span><a href="#39185426">next</a><span>|</span><label class="collapse" for="c-39184763">[-]</label><label class="expand" for="c-39184763">[5 more]</label></div><br/><div class="children"><div class="content">I haven’t touched JVM in ages, but there are two things off putting about it.<p>First it’s viscerally slow. They have a state of the art GC, amazing benchmarks, tons of work going into performance, but it still <i>feels</i> slow and laggy when you develop on it. None of the other ecosystems you mentioned have that problem (including Python).<p>Second, they have a bad sense of design. The class library comes from a culture of needing three classes to open a file, and that culture permeated through the entire ecosystem. Almost all the software in it feels bloated and over engineered. The modal JVM experience is spending 95% of your time dealing with “enterprise-y” boilerplate that turns out to have nothing to do with the enterprise and everything to do with bad design decisions and the culture downstream from those. C++ has its own flavor of this problem, but certainly not Python or Go.</div><br/><div id="39187607" class="c"><input type="checkbox" id="c-39187607" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184763">parent</a><span>|</span><a href="#39185696">next</a><span>|</span><label class="collapse" for="c-39187607">[-]</label><label class="expand" for="c-39187607">[1 more]</label></div><br/><div class="children"><div class="content">&gt; First it’s viscerally slow. They have a state of the art GC, amazing benchmarks, tons of work going into performance, but it still feels slow and laggy when you develop on it. None of the other ecosystems you mentioned have that problem (including Python).<p>I really can&#x27;t relate to this. What part of the process is noticeably slower than Python? I have a lot of Python projects and couldn&#x27;t say any of them are slower than JVM apps.</div><br/></div></div><div id="39185696" class="c"><input type="checkbox" id="c-39185696" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184763">parent</a><span>|</span><a href="#39187607">prev</a><span>|</span><a href="#39185426">next</a><span>|</span><label class="collapse" for="c-39185696">[-]</label><label class="expand" for="c-39185696">[3 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t agree more. I&#x27;m not very knowledgeable on Java, but was blown away every time I looked to see the crazy amount of boilerplate to do anything. There are all these design patterns that seem to only exist because the language is so terrible. Thousands of people who aren&#x27;t professional developers write millions of lines of Python each year (just a guess, but sounds right) and the vast majority just write code and don&#x27;t need 50 classes in their application to do something.</div><br/><div id="39185728" class="c"><input type="checkbox" id="c-39185728" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39185696">parent</a><span>|</span><a href="#39185426">next</a><span>|</span><label class="collapse" for="c-39185728">[-]</label><label class="expand" for="c-39185728">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about something different - Java the language is a bit ugly, but this is about JVM performance (ie, the runtime virtual machine that is installed to execute Java programs) with Clojure, where there is not much boilerplate to speak of.<p>Although the JVM is one of the sleekest environments around though and I&#x27;m confused by the fellow saying it is &quot;viscerally slow&quot;. Clojure loads slowly, but after that everything happens at speed.</div><br/><div id="39186534" class="c"><input type="checkbox" id="c-39186534" checked=""/><div class="controls bullet"><span class="by">john-shaffer</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39185728">parent</a><span>|</span><a href="#39185426">next</a><span>|</span><label class="collapse" for="c-39186534">[-]</label><label class="expand" for="c-39186534">[1 more]</label></div><br/><div class="children"><div class="content">Clojure itself actually loads pretty quickly, but almost every project has enough libraries to make loading the project take a few seconds.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39185426" class="c"><input type="checkbox" id="c-39185426" checked=""/><div class="controls bullet"><span class="by">truculent</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39184684">prev</a><span>|</span><a href="#39183811">next</a><span>|</span><label class="collapse" for="c-39185426">[-]</label><label class="expand" for="c-39185426">[1 more]</label></div><br/><div class="children"><div class="content">It also gives you access to Babashka if you want Clojure for other use-cases where start-up time is an issue<p><a href="https:&#x2F;&#x2F;babashka.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;babashka.org&#x2F;</a></div><br/></div></div><div id="39183811" class="c"><input type="checkbox" id="c-39183811" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39185426">prev</a><span>|</span><a href="#39183744">next</a><span>|</span><label class="collapse" for="c-39183811">[-]</label><label class="expand" for="c-39183811">[11 more]</label></div><br/><div class="children"><div class="content">The JVM precludes general tail-call elimination though.</div><br/><div id="39184351" class="c"><input type="checkbox" id="c-39184351" checked=""/><div class="controls bullet"><span class="by">jordibc</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39183811">parent</a><span>|</span><a href="#39184290">next</a><span>|</span><label class="collapse" for="c-39184351">[-]</label><label class="expand" for="c-39184351">[8 more]</label></div><br/><div class="children"><div class="content">It does preclude it, but clojure found an arguably elegant solution to it, using recur[1] instead. As a plus, in addition to achieving the same result as tail-call elimination, it does check that the call is indeed in tail position, and also works together with loop[2].<p>For me, it made me not miss tail-call elimination at all.<p>[1] <a href="https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;recur" rel="nofollow">https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;recur</a><p>[2] <a href="https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;loop" rel="nofollow">https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;loop</a></div><br/><div id="39187421" class="c"><input type="checkbox" id="c-39187421" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184351">parent</a><span>|</span><a href="#39184711">next</a><span>|</span><label class="collapse" for="c-39187421">[-]</label><label class="expand" for="c-39187421">[1 more]</label></div><br/><div class="children"><div class="content">In Scheme:<p><pre><code>    (define (foo)
      (bar))
</code></pre>
the call to bar is a tail call. How does recur optimize this? Well, it doesn&#x27;t, since &quot;general TCO&quot; &#x2F; &quot;full TCO&quot; means that any tail call gets optimized, such that the stack does not grow. Clojure recur&#x2F;loop is just a loop notation.<p>Looping construct in most languages provides a simple conversion of <i>self recursion</i> (a function calls itself recursively) to a loop: update the loop variables and then do the next loop iteration.<p>But the general case of tail calls is not covered by a simple local loop, like what is provided by Clojure.</div><br/></div></div><div id="39184711" class="c"><input type="checkbox" id="c-39184711" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184351">parent</a><span>|</span><a href="#39187421">prev</a><span>|</span><a href="#39184376">next</a><span>|</span><label class="collapse" for="c-39184711">[-]</label><label class="expand" for="c-39184711">[1 more]</label></div><br/><div class="children"><div class="content">The issue arises when you program really heavily with closures and function composition. You sadly cannot do functional programming as in &quot;programming with functions&quot; without care on the JVM.</div><br/></div></div><div id="39184376" class="c"><input type="checkbox" id="c-39184376" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184351">parent</a><span>|</span><a href="#39184711">prev</a><span>|</span><a href="#39184290">next</a><span>|</span><label class="collapse" for="c-39184376">[-]</label><label class="expand" for="c-39184376">[5 more]</label></div><br/><div class="children"><div class="content">It is, IMO, a missed opportunity to use a hard-coded identifier for `recur`ing instead of the `(let sym ((...)) ...)` form that would let you nest loops.<p>Aside from that, I agree. Tail-call optimization&#x27;s benefits are wildly overblown.</div><br/><div id="39184722" class="c"><input type="checkbox" id="c-39184722" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184376">parent</a><span>|</span><a href="#39184290">next</a><span>|</span><label class="collapse" for="c-39184722">[-]</label><label class="expand" for="c-39184722">[4 more]</label></div><br/><div class="children"><div class="content">The benefits aren&#x27;t overblown if you are someone who learned Lisp with a functional approach. As in, using higher-order functions etc. You have to be careful whenever you approach a problem that way on the JVM.</div><br/><div id="39185944" class="c"><input type="checkbox" id="c-39185944" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184722">parent</a><span>|</span><a href="#39184832">next</a><span>|</span><label class="collapse" for="c-39185944">[-]</label><label class="expand" for="c-39185944">[2 more]</label></div><br/><div class="children"><div class="content">what does tail-call optimization have to do with higher-order functions? I thought the former pertains to iterative procedures written with recursive syntax, where the recursive call is at the very end of the function and called by itself, so stack size is O(1). Higher-order functions means passing functions to things like map, filter, etc.</div><br/><div id="39186103" class="c"><input type="checkbox" id="c-39186103" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39185944">parent</a><span>|</span><a href="#39184832">next</a><span>|</span><label class="collapse" for="c-39186103">[-]</label><label class="expand" for="c-39186103">[1 more]</label></div><br/><div class="children"><div class="content">In the context of higher order functions, tail call elimination allows for the avoidance of building up intermediate stack frames and the associated calling costs of functions when doing things like composing functions, particularly when calling large chains of nested function calls. The benefits of TCO for something like mapping a function can also be pretty large because the recursive map can be turned into a while loop as you describe at the beginning of your comment.<p>The optimization of stack frame elision is pretty large for function calls on the JVM and the stack limits are not very amenable to ‘typical’ higher order function ‘functional programming’ style.</div><br/></div></div></div></div><div id="39184832" class="c"><input type="checkbox" id="c-39184832" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184722">parent</a><span>|</span><a href="#39185944">prev</a><span>|</span><a href="#39184290">next</a><span>|</span><label class="collapse" for="c-39184832">[-]</label><label class="expand" for="c-39184832">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide an example?</div><br/></div></div></div></div></div></div></div></div><div id="39184290" class="c"><input type="checkbox" id="c-39184290" checked=""/><div class="controls bullet"><span class="by">thmorriss</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39183811">parent</a><span>|</span><a href="#39184351">prev</a><span>|</span><a href="#39183744">next</a><span>|</span><label class="collapse" for="c-39184290">[-]</label><label class="expand" for="c-39184290">[2 more]</label></div><br/><div class="children"><div class="content">the clojure loop construct is often cleaner than code written to be tail recursive</div><br/><div id="39184712" class="c"><input type="checkbox" id="c-39184712" checked=""/><div class="controls bullet"><span class="by">uyrifo</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184290">parent</a><span>|</span><a href="#39183744">next</a><span>|</span><label class="collapse" for="c-39184712">[-]</label><label class="expand" for="c-39184712">[1 more]</label></div><br/><div class="children"><div class="content">And often faster: <a href="https:&#x2F;&#x2F;medium.com&#x2F;hackernoon&#x2F;faster-clojure-reduce-57a104448ea4" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;hackernoon&#x2F;faster-clojure-reduce-57a10444...</a><p>Yet it’s always noted as code smell associated with “inexperienced candidates” in interviews.<p>For that matter, first and last too: <a href="https:&#x2F;&#x2F;medium.com&#x2F;hackernoon&#x2F;faster-clojure-reduce-57a104448ea4" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;hackernoon&#x2F;faster-clojure-reduce-57a10444...</a><p>The amount of paired programmers suggesting changing nths to firsts and lasts is demoralizing.</div><br/></div></div></div></div></div></div><div id="39183744" class="c"><input type="checkbox" id="c-39183744" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39183811">prev</a><span>|</span><a href="#39184473">next</a><span>|</span><label class="collapse" for="c-39183744">[-]</label><label class="expand" for="c-39183744">[1 more]</label></div><br/><div class="children"><div class="content">I think hosted is almost tautologically a mixed bag - you get access to the host (both +ves and -ves) but you also introduce a layer and some invariable friction.</div><br/></div></div><div id="39184473" class="c"><input type="checkbox" id="c-39184473" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39183744">prev</a><span>|</span><a href="#39183698">next</a><span>|</span><label class="collapse" for="c-39184473">[-]</label><label class="expand" for="c-39184473">[2 more]</label></div><br/><div class="children"><div class="content">I know of one company that dumped its clojure code base because lambda costs were too high. They even experimented with graal as a fix.</div><br/><div id="39184724" class="c"><input type="checkbox" id="c-39184724" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39184473">parent</a><span>|</span><a href="#39183698">next</a><span>|</span><label class="collapse" for="c-39184724">[-]</label><label class="expand" for="c-39184724">[1 more]</label></div><br/><div class="children"><div class="content">I would have dumped lambda as a runtime before dumping the codebase. Obviously we don&#x27;t know the full story but that sounds a lil silly to me.<p>Plus lambda&#x27;s will stay alive for quite a while if they are in use. So startup time is felt once, but then would be identical to any other language or runtime.</div><br/></div></div></div></div><div id="39183698" class="c"><input type="checkbox" id="c-39183698" checked=""/><div class="controls bullet"><span class="by">askonomm</span><span>|</span><a href="#39183666">parent</a><span>|</span><a href="#39184473">prev</a><span>|</span><a href="#39185395">next</a><span>|</span><label class="collapse" for="c-39183698">[-]</label><label class="expand" for="c-39183698">[2 more]</label></div><br/><div class="children"><div class="content">And quite a lot of people actually do ship statically linked binaries with Clojure, using GraalVM. Clojure LSP server for example is distributed as a static binary.</div><br/><div id="39184282" class="c"><input type="checkbox" id="c-39184282" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39183666">root</a><span>|</span><a href="#39183698">parent</a><span>|</span><a href="#39185395">next</a><span>|</span><label class="collapse" for="c-39184282">[-]</label><label class="expand" for="c-39184282">[1 more]</label></div><br/><div class="children"><div class="content">Yes, although that solution can&#x27;t yet be said to be &quot;push button&quot;. My impression is that there are a decent amount of people who want non-JVM, native Clojure. Hence efforts like Janet and Jank.</div><br/></div></div></div></div></div></div><div id="39185395" class="c"><input type="checkbox" id="c-39185395" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39183666">prev</a><span>|</span><a href="#39185829">next</a><span>|</span><label class="collapse" for="c-39185395">[-]</label><label class="expand" for="c-39185395">[1 more]</label></div><br/><div class="children"><div class="content">I really like Kernel. John Shutt&#x27;s thesis language. It throws away a bunch of incidental complexity from scheme, most notably the minor disaster of hygienic macros. It follows a minor tangent on cyclic data which I&#x27;m not convinced matters very much.<p>Implementations are a bit DIY.<p>An interesting play would be to implement rsr7 scheme in kernel, semi-metacircular fashion.</div><br/></div></div><div id="39185829" class="c"><input type="checkbox" id="c-39185829" checked=""/><div class="controls bullet"><span class="by">thetwentyone</span><span>|</span><a href="#39185395">prev</a><span>|</span><a href="#39183913">next</a><span>|</span><label class="collapse" for="c-39185829">[-]</label><label class="expand" for="c-39185829">[2 more]</label></div><br/><div class="children"><div class="content">Also an interesting Lisp for it’s size is femtolisp from one of the co-creators of Julia:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;JeffBezanson&#x2F;femtolisp">https:&#x2F;&#x2F;github.com&#x2F;JeffBezanson&#x2F;femtolisp</a></div><br/><div id="39187524" class="c"><input type="checkbox" id="c-39187524" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#39185829">parent</a><span>|</span><a href="#39183913">next</a><span>|</span><label class="collapse" for="c-39187524">[-]</label><label class="expand" for="c-39187524">[1 more]</label></div><br/><div class="children"><div class="content">I have a femtolisp quote at the top of my LISP resources page:<p><a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;dev&#x2F;lisp" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;dev&#x2F;lisp</a></div><br/></div></div></div></div><div id="39183913" class="c"><input type="checkbox" id="c-39183913" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#39185829">prev</a><span>|</span><a href="#39183324">next</a><span>|</span><label class="collapse" for="c-39183913">[-]</label><label class="expand" for="c-39183913">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Why do print-line-debugging to find out what&#x27;s happening at a location in code when you can just be inside your program and inspect everything live as it&#x27;s running?<p>Yes, that&#x27;s because print-effing one&#x27;s way to understanding is also among the most crude methods of debugging. An excellent alternative to doing that is to use an actual debugger. That will also allow you to be &quot;inside your program&quot;.</div><br/><div id="39185069" class="c"><input type="checkbox" id="c-39185069" checked=""/><div class="controls bullet"><span class="by">ctrw</span><span>|</span><a href="#39183913">parent</a><span>|</span><a href="#39183976">next</a><span>|</span><label class="collapse" for="c-39185069">[-]</label><label class="expand" for="c-39185069">[1 more]</label></div><br/><div class="children"><div class="content">The difference with lisps is that the debugger is always part of the runtime and you have full access to all the languages capabilities while inside.<p>I&#x27;ve yet to see a C debugger which does more than a fancy version of printf. Imagine being able to compile functions on the go while still running your main program with all the state saved.</div><br/></div></div><div id="39183976" class="c"><input type="checkbox" id="c-39183976" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#39183913">parent</a><span>|</span><a href="#39185069">prev</a><span>|</span><a href="#39183324">next</a><span>|</span><label class="collapse" for="c-39183976">[-]</label><label class="expand" for="c-39183976">[2 more]</label></div><br/><div class="children"><div class="content">How do you &quot;get inside your program&quot; on a locked down production box?  Watched by SOX auditors like hawks?  Any answer offered needs to be comparably easy to checking in an extra printf and letting ci&#x2F;cd deploy it.</div><br/><div id="39184125" class="c"><input type="checkbox" id="c-39184125" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#39183913">root</a><span>|</span><a href="#39183976">parent</a><span>|</span><a href="#39183324">next</a><span>|</span><label class="collapse" for="c-39184125">[-]</label><label class="expand" for="c-39184125">[1 more]</label></div><br/><div class="children"><div class="content">I used to be an Erlang engineer, and you would have needed very explicit security controls around being able to attach to an Erlang cluster to get the &quot;insider your program&quot; experience. This was in FinTech, so I&#x27;m familiar with the constraint.<p>I would imagine you&#x27;d need the same thing for accessing the runtime of any production deployed application(s) in such an unfettered manner. Erlang, Lisp, C, or other?</div><br/></div></div></div></div></div></div><div id="39183324" class="c"><input type="checkbox" id="c-39183324" checked=""/><div class="controls bullet"><span class="by">huqedato</span><span>|</span><a href="#39183913">prev</a><span>|</span><a href="#39186819">next</a><span>|</span><label class="collapse" for="c-39183324">[-]</label><label class="expand" for="c-39183324">[11 more]</label></div><br/><div class="children"><div class="content">After reading the article (BTW a good one), one thing intrigues me: why the author left Haskell for Lisp(s) ?</div><br/><div id="39185400" class="c"><input type="checkbox" id="c-39185400" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39183324">parent</a><span>|</span><a href="#39183966">next</a><span>|</span><label class="collapse" for="c-39185400">[-]</label><label class="expand" for="c-39185400">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for the author, but I do know the reason I personally left it: Haskell-the-language is amazing, Haskell-the-ecosystem is awful.<p>Like the other commenter I completely agree that knowing Haskell makes you a better programmer, and when I code in other languages I really miss certain parts of it. On the other hand, the entire Haskell ecosystem feels like a half-finished PhD thesis, and often-promoted libraries suffer from fundamental flaws which are &quot;open research questions&quot;. There&#x27;s a constant drive in many Haskellers to make their code as abstract, type-safe, and generic as possible, but unfortunately practicality and ease of use are often forgotten along the way.<p>It&#x27;s a great language, but if you&#x27;re trying to write production code which builds upon the wider ecosystem you&#x27;re in for a world of pain. In 2024 Rust has probably rifled enough through Haskell&#x27;s pockets to make it mostly irrelevant as anything but a testbed for programming language researchers.</div><br/></div></div><div id="39183966" class="c"><input type="checkbox" id="c-39183966" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39183324">parent</a><span>|</span><a href="#39185400">prev</a><span>|</span><a href="#39184390">next</a><span>|</span><label class="collapse" for="c-39183966">[-]</label><label class="expand" for="c-39183966">[2 more]</label></div><br/><div class="children"><div class="content">I did the same and I treat Haskell as a rite of passage. At this point it&#x27;s cliche to say that Haskell makes you a better programmer in other languages, but it&#x27;s true. You really immerse yourself in Haskell for a few years, and you become a better programmer even when you aren&#x27;t writing Haskell. I&#x27;m referring to universal things like &quot;making invalid states unrepresentable&quot; or &quot;preferring to parse than to validate&quot; or &quot;functional core imperative shell&quot; that can work well and lead to cleaner code in any language.<p>(The actual reason I left Haskell was because I switched my employer. Choosing an employer is IMO a bit more important than choosing the language to code in.)</div><br/><div id="39185165" class="c"><input type="checkbox" id="c-39185165" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39183324">root</a><span>|</span><a href="#39183966">parent</a><span>|</span><a href="#39184390">next</a><span>|</span><label class="collapse" for="c-39185165">[-]</label><label class="expand" for="c-39185165">[1 more]</label></div><br/><div class="children"><div class="content">Non-mainstream languages can be a very positive signal for employers I&#x27;ve found.</div><br/></div></div></div></div><div id="39184390" class="c"><input type="checkbox" id="c-39184390" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39183324">parent</a><span>|</span><a href="#39183966">prev</a><span>|</span><a href="#39183905">next</a><span>|</span><label class="collapse" for="c-39184390">[-]</label><label class="expand" for="c-39184390">[3 more]</label></div><br/><div class="children"><div class="content">Hi. I actually left Haskell for Rust. And when I say &quot;left&quot;, I mean I don&#x27;t start new projects in it. I still maintain my libraries.<p>I wrote Haskell for 10 years or so, both FOSS and professionally. I&#x27;ve &quot;been around the block&quot; so to speak and consider myself to have a decent view of the landscape. Overall, Rust lets me code in the style I want while being very resource efficient. I write Rust professionally.</div><br/><div id="39185929" class="c"><input type="checkbox" id="c-39185929" checked=""/><div class="controls bullet"><span class="by">Hizonner</span><span>|</span><a href="#39183324">root</a><span>|</span><a href="#39184390">parent</a><span>|</span><a href="#39183905">next</a><span>|</span><label class="collapse" for="c-39185929">[-]</label><label class="expand" for="c-39185929">[2 more]</label></div><br/><div class="children"><div class="content">The part that confused <i>me</i> was your leaving Haskell for Rust and then leaving Rust for Lisp. Were both of those transitions aimed at some common goal?<p>I mean, if I left Haskell, I think the main reason would be to to shed the load of thinking simultaneously about laziness and how it interacts with optimization. OK, almost any non-Haskell language gets you out of that. But choosing to leave Haskell specifically for <i>Rust</i> would be about efficiency first and foremost, especially improving on the size and complexity of the RTS (and its limited platform support). I could also see wanting the concurrent programming benefits of Rust&#x27;s ownership system. And it&#x27;s nice to be able to write embedded or kernel code. And there&#x27;s a bandwagon to jump on.<p>Lisp, on the other hand, doesn&#x27;t really seem like an improvement over Haskell in any of those ways. It solves different problems. Lisp feels like it&#x27;s on the &quot;opposite side&quot; of Haskell from Rust. So why did you &quot;reverse&quot; and try Lisp to begin with?<p>I agree that Rust is ugly, by the way. Honestly I think it started with keeping the C syntax and went from there.</div><br/><div id="39187514" class="c"><input type="checkbox" id="c-39187514" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39183324">root</a><span>|</span><a href="#39185929">parent</a><span>|</span><a href="#39183905">next</a><span>|</span><label class="collapse" for="c-39187514">[-]</label><label class="expand" for="c-39187514">[1 more]</label></div><br/><div class="children"><div class="content">I should make it clear that I haven&#x27;t left Rust; I write it every day professionally.<p>I transitioned from Haskell to Rust to capture efficiency and small binaries. Since I&#x27;m in the game of shipping CLI tools, this was important for me.<p>You&#x27;re right though that Lisp is on the other end of that; we&#x27;re back to bigger runtimes with no tree-shaking, since that would hinder debugging. For now I&#x27;m experimenting with the Interactive Programming paradigm because the debugging story is just too good. For long-lived programs, this may be the way to go.<p>Rust code can be made nice to look at it, but it isn&#x27;t the default nor the trend.</div><br/></div></div></div></div></div></div><div id="39183905" class="c"><input type="checkbox" id="c-39183905" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#39183324">parent</a><span>|</span><a href="#39184390">prev</a><span>|</span><a href="#39183337">next</a><span>|</span><label class="collapse" for="c-39183905">[-]</label><label class="expand" for="c-39183905">[3 more]</label></div><br/><div class="children"><div class="content">At some point you realize Haskell and&#x2F;or its ecosystem keeps breaking things too much and you move on.</div><br/><div id="39185174" class="c"><input type="checkbox" id="c-39185174" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39183324">root</a><span>|</span><a href="#39183905">parent</a><span>|</span><a href="#39183337">next</a><span>|</span><label class="collapse" for="c-39185174">[-]</label><label class="expand" for="c-39185174">[2 more]</label></div><br/><div class="children"><div class="content">I love Haskell and know there are efforts to fix this, but I find it hard to disagree.</div><br/><div id="39187655" class="c"><input type="checkbox" id="c-39187655" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#39183324">root</a><span>|</span><a href="#39185174">parent</a><span>|</span><a href="#39183337">next</a><span>|</span><label class="collapse" for="c-39187655">[-]</label><label class="expand" for="c-39187655">[1 more]</label></div><br/><div class="children"><div class="content">Not just efforts, but both GHC HQ and the Core Libraries Committee making stability a top priority.  Expect casual breaking changes in the Haskell world to become a thing of the past, in very short order (in fact the most recent release of GHC (9.8) had very few breaking changes).</div><br/></div></div></div></div></div></div></div></div><div id="39186819" class="c"><input type="checkbox" id="c-39186819" checked=""/><div class="controls bullet"><span class="by">dartharva</span><span>|</span><a href="#39183324">prev</a><span>|</span><a href="#39184807">next</a><span>|</span><label class="collapse" for="c-39186819">[-]</label><label class="expand" for="c-39186819">[2 more]</label></div><br/><div class="children"><div class="content">Article topic notwithstanding, I am curious in the design choice of moving the &quot;Table of Contents&quot; to the right side of the text and links for other blog entries to the left. Aren&#x27;t the sides conventionally swapped as with default Blogspot&#x2F;Wordpress blog templates?<p>Also, what was the objective behind shaping the text as a Q&amp;A-style interview when it&#x27;s only a personal blog?</div><br/><div id="39187314" class="c"><input type="checkbox" id="c-39187314" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39186819">parent</a><span>|</span><a href="#39184807">next</a><span>|</span><label class="collapse" for="c-39187314">[-]</label><label class="expand" for="c-39187314">[1 more]</label></div><br/><div class="children"><div class="content">The questions were originally posed by a Doom Emacs community member, so I answered them as-is.<p>The site is designs as it is because I&#x27;m not a frontend guy xD</div><br/></div></div></div></div><div id="39184807" class="c"><input type="checkbox" id="c-39184807" checked=""/><div class="controls bullet"><span class="by">dogprez</span><span>|</span><a href="#39186819">prev</a><span>|</span><a href="#39183258">next</a><span>|</span><label class="collapse" for="c-39184807">[-]</label><label class="expand" for="c-39184807">[7 more]</label></div><br/><div class="children"><div class="content">&gt; [Fennel] also lacks Common Lisp&#x27;s debuggability, given that it sits entirely within Lua&#x27;s runtime.<p>I&#x27;m not sure exactly what feature the OP was referring to.  It sounds like they don&#x27;t think you can get a REPL for an executing Fennel process?  You can.  If you are only using it for AOT Fennel-&gt;Lua you can&#x27;t, you have to include its runtime.</div><br/><div id="39185100" class="c"><input type="checkbox" id="c-39185100" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39184807">parent</a><span>|</span><a href="#39183258">next</a><span>|</span><label class="collapse" for="c-39185100">[-]</label><label class="expand" for="c-39185100">[6 more]</label></div><br/><div class="children"><div class="content">Last I checked, Lua was “bring your own debugger”. Assuming that hasn’t changed, a REPL is nice, but you can’t pause and inspect anything by default.</div><br/><div id="39185663" class="c"><input type="checkbox" id="c-39185663" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39184807">root</a><span>|</span><a href="#39185100">parent</a><span>|</span><a href="#39185644">next</a><span>|</span><label class="collapse" for="c-39185663">[-]</label><label class="expand" for="c-39185663">[2 more]</label></div><br/><div class="children"><div class="content">To be the most fair, Fennel 1.4 recently released with an `assert-repl` form that opens a repl when some assertion fails, in which you can inspect local variables, etc. That&#x27;s getting closer to CL.<p><a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~technomancy&#x2F;fennel&#x2F;tree&#x2F;1.4.0&#x2F;item&#x2F;changelog.md#new-forms" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~technomancy&#x2F;fennel&#x2F;tree&#x2F;1.4.0&#x2F;item&#x2F;change...</a></div><br/><div id="39185784" class="c"><input type="checkbox" id="c-39185784" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39184807">root</a><span>|</span><a href="#39185663">parent</a><span>|</span><a href="#39185644">next</a><span>|</span><label class="collapse" for="c-39185784">[-]</label><label class="expand" for="c-39185784">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the correction! I had only used Lua, and thought Fennel had no runtime, so I assumed this was not possible.</div><br/></div></div></div></div><div id="39185644" class="c"><input type="checkbox" id="c-39185644" checked=""/><div class="controls bullet"><span class="by">dogprez</span><span>|</span><a href="#39184807">root</a><span>|</span><a href="#39185100">parent</a><span>|</span><a href="#39185663">prev</a><span>|</span><a href="#39185343">next</a><span>|</span><label class="collapse" for="c-39185644">[-]</label><label class="expand" for="c-39185644">[1 more]</label></div><br/><div class="children"><div class="content">Fennel has a form `assert-repl` which will drop into the REPL wherever, if the condition fails.  For writing games you can launch the REPL in the game loop if a keyboard button is pressed.  But what you can&#x27;t do, that I know of, is interrupt arbitrary execution and get a Fennel REPL.  You&#x27;d probably need a lua debugger of some sort for that.  I&#x27;m not that familiar with that though.</div><br/></div></div><div id="39185343" class="c"><input type="checkbox" id="c-39185343" checked=""/><div class="controls bullet"><span class="by">emidln</span><span>|</span><a href="#39184807">root</a><span>|</span><a href="#39185100">parent</a><span>|</span><a href="#39185644">prev</a><span>|</span><a href="#39183258">next</a><span>|</span><label class="collapse" for="c-39185343">[-]</label><label class="expand" for="c-39185343">[2 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t you just put the equivalent of `(repl)` wherever you want to debug and drop into your REPL?</div><br/><div id="39185587" class="c"><input type="checkbox" id="c-39185587" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39184807">root</a><span>|</span><a href="#39185343">parent</a><span>|</span><a href="#39183258">next</a><span>|</span><label class="collapse" for="c-39185587">[-]</label><label class="expand" for="c-39185587">[1 more]</label></div><br/><div class="children"><div class="content">Short answer: I don’t know. That sounds like a good idea, but how would that access local variables in the caller (to inspect state)?<p>I remember the Lua C API exposes a lot of information, but I didn’t think it was accessible from scripts. Of course, it was a long time ago and I could have easily missed something at the time. Happy to be corrected!<p>Edit: you might also run into difficulties trying to redefine non-global functions to add the call to “repl”.</div><br/></div></div></div></div></div></div></div></div><div id="39183258" class="c"><input type="checkbox" id="c-39183258" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#39184807">prev</a><span>|</span><a href="#39187282">next</a><span>|</span><label class="collapse" for="c-39183258">[-]</label><label class="expand" for="c-39183258">[19 more]</label></div><br/><div class="children"><div class="content">While I agree with the author that there&#x27;s something about Rust (my day-job lang &amp; goto personal lang these days) that just lacks... elegance... I&#x27;ve also never found the Lisp (and many other FPs) emphasis on recursion all that compelling. Aesthetically or computationally. I find the programs written this way hard to reason about and read. Personally.<p>For me, the underutilized gold mine feels like logic languages (Prolog et al.) Though I know recursion is used there a lot, too.</div><br/><div id="39183525" class="c"><input type="checkbox" id="c-39183525" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39183258">parent</a><span>|</span><a href="#39183890">next</a><span>|</span><label class="collapse" for="c-39183525">[-]</label><label class="expand" for="c-39183525">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Common Lisp has an emphasis on recursion.  As evidence, consider that it doesn&#x27;t in the standard require any kind of tail recursion optimization and has multiple ways of doing iteration.  Scheme is the language with the fetish about doing things with recursion.</div><br/><div id="39185113" class="c"><input type="checkbox" id="c-39185113" checked=""/><div class="controls bullet"><span class="by">ctrw</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183525">parent</a><span>|</span><a href="#39184663">next</a><span>|</span><label class="collapse" for="c-39185113">[-]</label><label class="expand" for="c-39185113">[2 more]</label></div><br/><div class="children"><div class="content">Common lisp let&#x27;s you do recursion when you need it and not when you don&#x27;t. Using recursion for iterating through a list is stupid because you bury the lead in the middle of a function and you do the same thing until you stop. Using recursion for a tree or more connected graphs isn&#x27;t because they are fundamentally recursive.</div><br/><div id="39185961" class="c"><input type="checkbox" id="c-39185961" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39185113">parent</a><span>|</span><a href="#39184663">next</a><span>|</span><label class="collapse" for="c-39185961">[-]</label><label class="expand" for="c-39185961">[1 more]</label></div><br/><div class="children"><div class="content">you can argue that lists are fundamentally recursive too: they are a car and and cdr, where the cdr itself is another list.</div><br/></div></div></div></div><div id="39184663" class="c"><input type="checkbox" id="c-39184663" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183525">parent</a><span>|</span><a href="#39185113">prev</a><span>|</span><a href="#39183890">next</a><span>|</span><label class="collapse" for="c-39184663">[-]</label><label class="expand" for="c-39184663">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair. Any time I&#x27;ve decided to spend time in the sexpr-world, I&#x27;ve gone straight to the hard stuff, into Scheme. Apart from Elisp, anyways.<p>I&#x27;ve never worked in the source tree of a large Common Lisp program. Though I&#x27;ve bought the books and read the tutorials etc.</div><br/></div></div></div></div><div id="39183890" class="c"><input type="checkbox" id="c-39183890" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39183258">parent</a><span>|</span><a href="#39183525">prev</a><span>|</span><a href="#39183350">next</a><span>|</span><label class="collapse" for="c-39183890">[-]</label><label class="expand" for="c-39183890">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve also never found the Lisp (and many other FPs) emphasis on recursion all that compelling.<p>Recursion appeals to me because of immutability:<p>I do not want to do a summation by writing the wrong answer to memory, and then updating it in-place until it&#x27;s the right answer.  It makes me have to think not only about what the right answer is, but when it is.<p>But can&#x27;t I just use stack variables?  Well, I don&#x27;t think summation of primitive ints using stack variables is too taxing, but what about computing a word-count instead of a summation?  Then your &#x27;stack variables&#x27; are pointers into Strings and mutable HashMaps.  When you return the result, do you make a defensive copy?  How deeply do you copy? Your clone of a HashMap can still reference mutable data in your original HashMap.<p>Do you name your variable &#x27;result&#x27; when it does not yet contain the result?<p>You might have to think about the primitive&#x2F;object split - when is it pass-by-value and when is it pass-by-pointer?  Do you have in-values and out-values?  With immutability, you only have values, and you only pass-by-value.<p>If you&#x27;re sharing objects across threads, and you decide to lock - is that sufficient?  What if the caller takes the lock, does a get(), releases the lock, and then starts mutating the gotten value, bypassing the protection of the lock.  Now you&#x27;re thinking about defensive copies and maybe deadlocks too.  Just share an immutable value without a lock.<p>Sometimes recursion is aesthetically better, but usually it&#x27;s just what you&#x27;re left with after you take a big hammer to mutability and its surrounding issues.<p>And most of the time (in Haskell but I&#x27;m guessing in Lisps too) you don&#x27;t write out direct recursions, but instead use maps and folds which have recursion under the hood.</div><br/><div id="39184274" class="c"><input type="checkbox" id="c-39184274" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183890">parent</a><span>|</span><a href="#39183350">next</a><span>|</span><label class="collapse" for="c-39184274">[-]</label><label class="expand" for="c-39184274">[1 more]</label></div><br/><div class="children"><div class="content">I think mutable variables (inside functions) are just fine, as long as the function itself always returns the same result for the same arguments.  That is the essence of &quot;pure&quot; I think.<p>A function should be a &quot;black box&quot;. I don&#x27;t care what happens inside it as long its externally observable behavior is pure.</div><br/></div></div></div></div><div id="39183350" class="c"><input type="checkbox" id="c-39183350" checked=""/><div class="controls bullet"><span class="by">thuuuomas</span><span>|</span><a href="#39183258">parent</a><span>|</span><a href="#39183890">prev</a><span>|</span><a href="#39184400">next</a><span>|</span><label class="collapse" for="c-39183350">[-]</label><label class="expand" for="c-39183350">[5 more]</label></div><br/><div class="children"><div class="content">Have you checked out any of the minikanren logic programming environments people have implemented in scheme?<p>The Reasoned Schemer is an accessible introduction to that space if you’re not put off by the socratic-themed dialogue.<p>&amp; the Barliman demo is still pretty exciting even after LLM codegen.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;er_lLvkklsk" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;er_lLvkklsk</a></div><br/><div id="39183705" class="c"><input type="checkbox" id="c-39183705" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183350">parent</a><span>|</span><a href="#39185877">next</a><span>|</span><label class="collapse" for="c-39183705">[-]</label><label class="expand" for="c-39183705">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to see a practical use case for Minikanren other than quines. It&#x27;s fun and interesting, but I&#x27;m not smart enough to go from &quot;a tiny set of primitives&quot; to &quot;solving practical problems&quot;. I had trouble even implementing the basic &quot;moses is a man&quot; examples you see in Prolog tutorials.</div><br/><div id="39186217" class="c"><input type="checkbox" id="c-39186217" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183705">parent</a><span>|</span><a href="#39184647">next</a><span>|</span><label class="collapse" for="c-39186217">[-]</label><label class="expand" for="c-39186217">[1 more]</label></div><br/><div class="children"><div class="content">MiniKanren has been used in the medical world: <a href="https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC9562701&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC9562701&#x2F;</a></div><br/></div></div><div id="39184647" class="c"><input type="checkbox" id="c-39184647" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183705">parent</a><span>|</span><a href="#39186217">prev</a><span>|</span><a href="#39185877">next</a><span>|</span><label class="collapse" for="c-39184647">[-]</label><label class="expand" for="c-39184647">[1 more]</label></div><br/><div class="children"><div class="content">Yeah me too I was just looking at an Elisp port (!) of minikanren the other day, and, yeah, all the examples were algorithmic puzzles, rather than solutions to problems.</div><br/></div></div></div></div><div id="39185877" class="c"><input type="checkbox" id="c-39185877" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183350">parent</a><span>|</span><a href="#39183705">prev</a><span>|</span><a href="#39184400">next</a><span>|</span><label class="collapse" for="c-39185877">[-]</label><label class="expand" for="c-39185877">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also available in Clojure: <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.logic">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.logic</a><p>If you want to write one yourself, it&#x27;s pretty easy: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y1bVJOAfhKY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y1bVJOAfhKY</a></div><br/></div></div></div></div><div id="39184400" class="c"><input type="checkbox" id="c-39184400" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39183258">parent</a><span>|</span><a href="#39183350">prev</a><span>|</span><a href="#39183269">next</a><span>|</span><label class="collapse" for="c-39184400">[-]</label><label class="expand" for="c-39184400">[1 more]</label></div><br/><div class="children"><div class="content">Manual recursion often isn&#x27;t needed. You can get basically all of what you want from Transducers: <a href="https:&#x2F;&#x2F;github.com&#x2F;fosskers&#x2F;cl-transducers">https:&#x2F;&#x2F;github.com&#x2F;fosskers&#x2F;cl-transducers</a></div><br/></div></div><div id="39183269" class="c"><input type="checkbox" id="c-39183269" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#39183258">parent</a><span>|</span><a href="#39184400">prev</a><span>|</span><a href="#39187282">next</a><span>|</span><label class="collapse" for="c-39183269">[-]</label><label class="expand" for="c-39183269">[6 more]</label></div><br/><div class="children"><div class="content">It’s like anything else, you get used to it just as easily.</div><br/><div id="39183355" class="c"><input type="checkbox" id="c-39183355" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183269">parent</a><span>|</span><a href="#39183291">next</a><span>|</span><label class="collapse" for="c-39183355">[-]</label><label class="expand" for="c-39183355">[3 more]</label></div><br/><div class="children"><div class="content">...or don&#x27;t use it.<p>Scheme likes to tout it because of tail call optimization. Common Lisp can do it, but doesn&#x27;t really shove it as a first principle of &quot;Common Lisping&quot; (and CL does not dictate tail call optimization).<p>I don&#x27;t use it (save when it&#x27;s necessary). I just iterate using the supplied iterators (do, dolist, loop, whatever).<p>I can&#x27;t speak to other functional languages.</div><br/><div id="39183927" class="c"><input type="checkbox" id="c-39183927" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183355">parent</a><span>|</span><a href="#39183291">next</a><span>|</span><label class="collapse" for="c-39183927">[-]</label><label class="expand" for="c-39183927">[2 more]</label></div><br/><div class="children"><div class="content">CL&#x27;s iteration primitives are more capable that those  provided by most languages, which often makes for a very clean approach.<p>Recursion is sometimes the easiest way to reason about a problem though, so it&#x27;s nice to have decent support and TCO.</div><br/><div id="39184420" class="c"><input type="checkbox" id="c-39184420" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183927">parent</a><span>|</span><a href="#39183291">next</a><span>|</span><label class="collapse" for="c-39184420">[-]</label><label class="expand" for="c-39184420">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Recursion is sometimes the easiest way to reason about a problem though<p>Yes, it&#x27;s one of the things that allow FP algorithms to be more declarative. It&#x27;s difficult to seriously argue that recursion is fundamentally more complex-- the contrary argument is more obvious to me.<p>Everything that&#x27;s left is the fact that it requires people to unlearn things, which is uncomfortable and requires effort, but unfamiliarity is not an indicator of complexity.</div><br/></div></div></div></div></div></div><div id="39183291" class="c"><input type="checkbox" id="c-39183291" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183269">parent</a><span>|</span><a href="#39183355">prev</a><span>|</span><a href="#39187282">next</a><span>|</span><label class="collapse" for="c-39183291">[-]</label><label class="expand" for="c-39183291">[2 more]</label></div><br/><div class="children"><div class="content">I take it as: mathematicians like recursion, so they put some recursion in your recursion...</div><br/><div id="39184394" class="c"><input type="checkbox" id="c-39184394" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#39183258">root</a><span>|</span><a href="#39183291">parent</a><span>|</span><a href="#39187282">next</a><span>|</span><label class="collapse" for="c-39184394">[-]</label><label class="expand" for="c-39184394">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a strong argument to be made that mathematicians tend to build the simplest abstractions conceptually, especially in comparison to computer scientists. Personally, when I stumble upon some maths, I pay close attention. It has paid off.</div><br/></div></div></div></div></div></div></div></div><div id="39187282" class="c"><input type="checkbox" id="c-39187282" checked=""/><div class="controls bullet"><span class="by">agambrahma</span><span>|</span><a href="#39183258">prev</a><span>|</span><a href="#39184371">next</a><span>|</span><label class="collapse" for="c-39187282">[-]</label><label class="expand" for="c-39187282">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like he&#x27;d like Coalton</div><br/><div id="39187307" class="c"><input type="checkbox" id="c-39187307" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39187282">parent</a><span>|</span><a href="#39184371">next</a><span>|</span><label class="collapse" for="c-39187307">[-]</label><label class="expand" for="c-39187307">[1 more]</label></div><br/><div class="children"><div class="content">CL-embedded langs like Coalton and April are mentioned in the article.</div><br/></div></div></div></div><div id="39184371" class="c"><input type="checkbox" id="c-39184371" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#39187282">prev</a><span>|</span><a href="#39184426">next</a><span>|</span><label class="collapse" for="c-39184371">[-]</label><label class="expand" for="c-39184371">[3 more]</label></div><br/><div class="children"><div class="content">The big thing I took away from LISP is that having everything be prefix solves a lot of problems. Seriously, the arguments people have in languages like Zig about whether to have &quot;operator overloading&quot; just seem a bit silly. Operators are just functions, it&#x27;s very silly to make them syntastically different.<p>But I never got much into REPL driven development. Probably because I just couldn&#x27;t wrap my head around emacs.</div><br/><div id="39184580" class="c"><input type="checkbox" id="c-39184580" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#39184371">parent</a><span>|</span><a href="#39184426">next</a><span>|</span><label class="collapse" for="c-39184580">[-]</label><label class="expand" for="c-39184580">[2 more]</label></div><br/><div class="children"><div class="content">Smalltalk solves that by having everything be infix.  With fewer parentheses.<p>¯\_(ツ)_&#x2F;¯</div><br/><div id="39184649" class="c"><input type="checkbox" id="c-39184649" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#39184371">root</a><span>|</span><a href="#39184580">parent</a><span>|</span><a href="#39184426">next</a><span>|</span><label class="collapse" for="c-39184649">[-]</label><label class="expand" for="c-39184649">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s another approach to it, one I think could definitely be borrowed (though I wouldn&#x27;t do it exactly how smalltalk did). And then of course there&#x27;s the &quot;concatenative&quot; family where everything is postfix.</div><br/></div></div></div></div></div></div><div id="39184426" class="c"><input type="checkbox" id="c-39184426" checked=""/><div class="controls bullet"><span class="by">beepbooptheory</span><span>|</span><a href="#39184371">prev</a><span>|</span><a href="#39183328">next</a><span>|</span><label class="collapse" for="c-39184426">[-]</label><label class="expand" for="c-39184426">[7 more]</label></div><br/><div class="children"><div class="content">Does anyone know how to get a lisp job? Or have any experiences to share? Its been a dream for a while for me, and I think I am possibly ready (at least with common lisp, have started doing more clojure recently though). It just seems so impenetrable to me, I don&#x27;t even know how to begin to search for it.</div><br/><div id="39184608" class="c"><input type="checkbox" id="c-39184608" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#39184426">parent</a><span>|</span><a href="#39185600">next</a><span>|</span><label class="collapse" for="c-39184608">[-]</label><label class="expand" for="c-39184608">[3 more]</label></div><br/><div class="children"><div class="content">I got mine by contributing to some niche communities, and developing open source packages.<p>A great foot in the door is when someone is using and likes some software that you have written.  If they know it came from you, and can easily find out you&#x27;re available when they&#x27;re ready to hire.<p>Of course, that&#x27;s not an option for everyone -- some people simply haven&#x27;t yet had the free time or paid opportunity to make open source -- and we should try not penalize people for that.  But it&#x27;s much better positive signal than a job-seeker approach of &quot;I spent person-months memorizing Leetcode medium-difficulty answers, and rehearsing whiteboard interview stage presence like a rockstar.&quot;<p>Beware that good Lisp-family jobs are rare, and don&#x27;t tend to be highest-paying.  Outside of relative pay within categories like enterprise Java-shop programmer.<p>(Aside: From a hiring perspective, using some beloved niche language with few jobs available is also a great way to pick up mythical &quot;10x&quot; hires, and retain them for a long time. :)  But, more seriously, it&#x27;s ethical to make sure that prospective hires for unpopular niche keywords realize what they&#x27;re getting into, in the current software job environment that often assumes fad-following &amp; job-hopping strategy, and is skeptical&#x2F;derisive of people whose resumes don&#x27;t look like that.)</div><br/><div id="39185679" class="c"><input type="checkbox" id="c-39185679" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39184426">root</a><span>|</span><a href="#39184608">parent</a><span>|</span><a href="#39185600">next</a><span>|</span><label class="collapse" for="c-39185679">[-]</label><label class="expand" for="c-39185679">[2 more]</label></div><br/><div class="children"><div class="content">If the Stackoverflow Dev Survey is to be believed, CL and Clojure devs actually make decent money.</div><br/><div id="39186200" class="c"><input type="checkbox" id="c-39186200" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#39184426">root</a><span>|</span><a href="#39185679">parent</a><span>|</span><a href="#39185600">next</a><span>|</span><label class="collapse" for="c-39186200">[-]</label><label class="expand" for="c-39186200">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2023&#x2F;#work-salary" rel="nofollow">https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2023&#x2F;#work-salary</a><p>This chart I&#x27;m looking at might be broken, because mouseover is showing median salary of exactly $96,381 for all of Scala, Elixir, Clojure, &quot;Lisp&quot;, and F#.  (But somehow OCaml and Haskell didn&#x27;t get jumbled in with those.)<p>BTW, I&#x27;m keeping in mind that people into the fringe power-user tech might be more capable than your average bear.  For example, your typical person who, somehow, got years of experience with CL, IME, is a lot more capable overall than your typical person with the same number of years using Python.  So, someone taking home $150K doing a Lisp at a company that lets them might have comparable skills to someone making $500K at a FAANG.  (Excluding the blip when Google acquired ITA Software, which I guess brought a bunch of CL people there.)</div><br/></div></div></div></div></div></div><div id="39185600" class="c"><input type="checkbox" id="c-39185600" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#39184426">parent</a><span>|</span><a href="#39184608">prev</a><span>|</span><a href="#39184445">next</a><span>|</span><label class="collapse" for="c-39185600">[-]</label><label class="expand" for="c-39185600">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been in Who&#x27;s Hiring threads, r&#x2F;lisp, etc. There&#x27;s a Lisp job advertised on Reddit [1,2] right now even. Another good source is [3].<p>[1] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;s&#x2F;AZmouaoARl" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;s&#x2F;AZmouaoARl</a><p>[2] <a href="https:&#x2F;&#x2F;jobs.lever.co&#x2F;dodmg&#x2F;af802f7f-4e44-4457-9e49-14bc47bd8b31" rel="nofollow">https:&#x2F;&#x2F;jobs.lever.co&#x2F;dodmg&#x2F;af802f7f-4e44-4457-9e49-14bc47bd...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies">https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies</a></div><br/></div></div><div id="39184445" class="c"><input type="checkbox" id="c-39184445" checked=""/><div class="controls bullet"><span class="by">colingw</span><span>|</span><a href="#39184426">parent</a><span>|</span><a href="#39185600">prev</a><span>|</span><a href="#39184972">next</a><span>|</span><label class="collapse" for="c-39184445">[-]</label><label class="expand" for="c-39184445">[1 more]</label></div><br/><div class="children"><div class="content">The Clojure Slack has active channels for both job posters and job seekers.</div><br/></div></div><div id="39184972" class="c"><input type="checkbox" id="c-39184972" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#39184426">parent</a><span>|</span><a href="#39184445">prev</a><span>|</span><a href="#39183328">next</a><span>|</span><label class="collapse" for="c-39184972">[-]</label><label class="expand" for="c-39184972">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t had an exclusively lisp job, so maybe I shouldn&#x27;t comment, but... I did use CL and Clojure on the job for a few smaller things at my last two places. It&#x27;s easier to find Clojure companies (and them to find you) than Common Lisp ones. You might want to peruse <a href="https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies">https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies</a> from time to time and see if any have openings. There&#x27;s other resources linked too and of course there&#x27;s the reddit and discord community (such as there is) hubs. You can also see if there are any meetups in your area, that&#x27;s how I almost ended up at a Clojure startup some years back.<p>I should have taken strategy notes after talking to a guy at my last job who got management buy-in to rewrite a lot of Java code (for android) to Kotlin and have all new code for android be in Kotlin (before that was considered the sensible default). I think that&#x27;s in general a better approach for a lot of would-be paid lispers: don&#x27;t wait for or look for the lisp job, make the lisp job. Whether that&#x27;s doing work where the customer doesn&#x27;t care what language the thing is made in, or introducing it (some have even snuck it in -- the original clojure.jar got a lot of early success that way) to an existing work place. What I somewhat remember from my conversation was that if you can make a good technical case and have at least one other person supporting you (ideally your entire dev team as was his case), it&#x27;s a lot easier to sell. No one raised bogus concerns about increasing the hiring difficulty or effort learning the new system. (I say bogus because engineers are learning all the time, and huge swathes of the industry have already had to do things like migrate from ObjC to Swift, or the various versions of JavaScript and later TypeScript + all the framework churn, switching IDEs; learning and change are quite common and a non-issue.) From other Lisp company reports, getting a new hire up to speed to be productive with the team using Common Lisp is a matter of a week or two, a small portion of the overall onboarding time a lot of new jobs have. Mastery takes longer, of course, but that&#x27;s different.<p>If I had stayed longer at my last job I would have continued to flesh out a better demo for interactive selenium webdriver tests for our main Java application after injecting ABCL into it, it seemed like the easiest vector to get more interest from my team and other teams. It kind of sucks when you&#x27;re debugging a broken test and finally hit an exception but now you have to start over again (especially if you stepped too far in the debugger), especially with heavy webdriver tests that can take a long time. The Lisp debugging experience is so much better... And when writing the test from scratch, it&#x27;s very interactive, you type code and execute it and verify the browser did what you intended. When you&#x27;re done you run it again from scratch to verify.</div><br/></div></div></div></div><div id="39183328" class="c"><input type="checkbox" id="c-39183328" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#39184426">prev</a><span>|</span><a href="#39183568">next</a><span>|</span><label class="collapse" for="c-39183328">[-]</label><label class="expand" for="c-39183328">[30 more]</label></div><br/><div class="children"><div class="content">I believe this article is selling Guile short. I think it is the most pragmatic Lisp around.<p>I love Lisp&#x27;s ideas but I find all modern implementations terrible. I would go so far as to say Lisp aren&#x27;t popular because what we have today is not good enough. Common Lisp is the most advanced one, but it is like C++: it does everything and the kitchen sink. Design by committee. You want functional programming AND imperative? You want documentation that reads like an IBM mainframe manual? You want a standard library with names as cryptic as ANSI C? We got all that.  But frankly, it is the one to build serious production software with.<p>Racket is the best for a beginner, but it keeps having that academic, &quot;we made it for the kids&quot; feel of being easy to understand but not very pragmatic for a seasoned programmer. And it is one of a kind, so a good Racket developer might never know Lisp itself.<p>Schemes are fun, but the only standard everyone agrees to relegates to small embeddable languages almost like Lua. They are not made to live on their own almost. Since the standard is very simple, there are half a million implementations that are not very practical. But of these, there is Guile, which has a pretty decent documentation AND standard library (even a built in PEG parser!), actively developed and it is my opinion that is it very underrated and the only Lisp worth my time these days.<p>To be honest, the most popular Lisp in the world is Emacs Lisp bar none. How&#x27;s that Guile port coming along anyway?</div><br/><div id="39187702" class="c"><input type="checkbox" id="c-39187702" checked=""/><div class="controls bullet"><span class="by">natrys</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39183613">next</a><span>|</span><label class="collapse" for="c-39187702">[-]</label><label class="expand" for="c-39187702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How&#x27;s that Guile port coming along anyway?<p>It&#x27;s just not. It was someone&#x27;s GSoC project, and they basically stopped working on it in 2015 and nobody picked up the slack since: <a href="https:&#x2F;&#x2F;git.hcoop.net&#x2F;?p=bpt&#x2F;emacs.git" rel="nofollow">https:&#x2F;&#x2F;git.hcoop.net&#x2F;?p=bpt&#x2F;emacs.git</a><p>We only got Nativecomp in elisp because a very talented and persistent compiler engineer from ARM saw through it. With the basics done, I think they want to tackle doing more aggressive optimisations with libgccjit. But best not to take things for granted when bus factor is 1.</div><br/></div></div><div id="39183613" class="c"><input type="checkbox" id="c-39183613" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39187702">prev</a><span>|</span><a href="#39183517">next</a><span>|</span><label class="collapse" for="c-39183613">[-]</label><label class="expand" for="c-39183613">[9 more]</label></div><br/><div class="children"><div class="content">The problem with CL is not that it does everything, but that it does everything with a mish-mash of inconsistent idioms, thick layers of jargon, and implementation-specific behavior in places where you wouldn&#x27;t really expect, leading to a combination of implementation lock-in and dependence on 3rd-party libraries that is stronger than one might expect at first.<p>My (least) favorite example:<p><pre><code>  (nth needle haystack)
  (aref haystack needle)
</code></pre>
Ugh! But then again, what other language provides both AREF and ROW-MAJOR-AREF?<p>And of course CL tooling is just weird if you aren&#x27;t used to it.<p>Quicklisp is amazing! But it has no CLI and doesn&#x27;t use HTTPS for package downloads.<p>Swank and Slynk is amazing! But clients other than Slime and Sly are second-class citizens.<p>SBCL can generate a compiled binary, cool! But the routine is called &quot;save-lisp-and-die&quot;.<p>ASDF expects you to either put all of your Common Lisp projects in a single directory, or hard-code project locations in a config file. Does Go still do that too?<p>Ancient alien technology for sure, but at least moderately damaged upon crash-landing. Ironically, the only piece of CL tooling that feels mostly not-weird is called Roswell.<p>Of course all of this stuff is completely free-as-in-beer and developed almost entirely by volunteers in their spare time. Hard to criticize: they built it, and I didn&#x27;t. But there is definitely a cumulative oddball feeling to it.</div><br/><div id="39183902" class="c"><input type="checkbox" id="c-39183902" checked=""/><div class="controls bullet"><span class="by">floren</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39184070">next</a><span>|</span><label class="collapse" for="c-39183902">[-]</label><label class="expand" for="c-39183902">[2 more]</label></div><br/><div class="children"><div class="content">Some day I&#x27;ll do something useful with the debugger in SLIME but so far it&#x27;s mostly &quot;look at the error message, find the one frame in the stack that tells me something useful, hit either continue or abort&quot;</div><br/><div id="39184016" class="c"><input type="checkbox" id="c-39184016" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183902">parent</a><span>|</span><a href="#39184070">next</a><span>|</span><label class="collapse" for="c-39184016">[-]</label><label class="expand" for="c-39184016">[1 more]</label></div><br/><div class="children"><div class="content">Quick help: look at Emacs&#x2F;your editor menu for commands, in Emacs type &quot;v&quot; to go to the buggy line, fix your bug, compile the function (C-c C-c), type &quot;r&quot; on the buggy frame to restart it from where it failed, and voilà. If you were processing something costly, you didn&#x27;t have to restart it from zero.</div><br/></div></div></div></div><div id="39184070" class="c"><input type="checkbox" id="c-39184070" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39183902">prev</a><span>|</span><a href="#39183806">next</a><span>|</span><label class="collapse" for="c-39184070">[-]</label><label class="expand" for="c-39184070">[1 more]</label></div><br/><div class="children"><div class="content">Qlot works well for project-local dependencies. <a href="https:&#x2F;&#x2F;qlot.tech&#x2F;" rel="nofollow">https:&#x2F;&#x2F;qlot.tech&#x2F;</a><p>https for QL: <a href="https:&#x2F;&#x2F;github.com&#x2F;rudolfochrist&#x2F;ql-https">https:&#x2F;&#x2F;github.com&#x2F;rudolfochrist&#x2F;ql-https</a><p>another package manager: <a href="https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl">https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl</a> (&quot;built on the world of containers&quot;)<p>Can&#x27;t really refute the weird feeling. But there&#x27;s often a reason! (like, it makes totally more sense to install a library from within the Lisp REPL and not from the terminal, we can use it right away)</div><br/></div></div><div id="39183806" class="c"><input type="checkbox" id="c-39183806" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39184070">prev</a><span>|</span><a href="#39185057">next</a><span>|</span><label class="collapse" for="c-39183806">[-]</label><label class="expand" for="c-39183806">[2 more]</label></div><br/><div class="children"><div class="content">You hit the nail on the head. And I like the comparison with alien technology: in some ways it feels centuries ahead than our mainstream languages, but in other it feels they have never developed stuff we take for granted in 2024, like first-class hashmaps, Unicode and decent date&#x2F;time functions.</div><br/><div id="39186381" class="c"><input type="checkbox" id="c-39186381" checked=""/><div class="controls bullet"><span class="by">gmfawcett</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183806">parent</a><span>|</span><a href="#39185057">next</a><span>|</span><label class="collapse" for="c-39186381">[-]</label><label class="expand" for="c-39186381">[1 more]</label></div><br/><div class="children"><div class="content">SBCL has excellent Unicode support, for one, and hash tables are first class objects in all CL implementations. Won&#x27;t disagree about date and times.</div><br/></div></div></div></div><div id="39185057" class="c"><input type="checkbox" id="c-39185057" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39183806">prev</a><span>|</span><a href="#39184250">next</a><span>|</span><label class="collapse" for="c-39185057">[-]</label><label class="expand" for="c-39185057">[1 more]</label></div><br/><div class="children"><div class="content">Good list! I, too, have many complaints about Common Lisp.<p>But for a language whose standard hasn’t been updated in roughly 30 years, it holds up impressively well!</div><br/></div></div><div id="39184250" class="c"><input type="checkbox" id="c-39184250" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39185057">prev</a><span>|</span><a href="#39183848">next</a><span>|</span><label class="collapse" for="c-39184250">[-]</label><label class="expand" for="c-39184250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SBCL can generate a compiled binary, cool! But the routine is called &quot;save-lisp-and-die&quot;<p>...And?</div><br/></div></div><div id="39183848" class="c"><input type="checkbox" id="c-39183848" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183613">parent</a><span>|</span><a href="#39184250">prev</a><span>|</span><a href="#39183517">next</a><span>|</span><label class="collapse" for="c-39183848">[-]</label><label class="expand" for="c-39183848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>what other language provides both AREF and ROW-MAJOR-AREF</i><p>C? :)</div><br/></div></div></div></div><div id="39183517" class="c"><input type="checkbox" id="c-39183517" checked=""/><div class="controls bullet"><span class="by">velcrovan</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39183613">prev</a><span>|</span><a href="#39185629">next</a><span>|</span><label class="collapse" for="c-39183517">[-]</label><label class="expand" for="c-39183517">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Racket is the best for a beginner, but it keeps having that academic, &quot;we made it for the kids&quot; feel of being easy to understand but not very pragmatic for a seasoned programmer. And it is one of a kind, so a good Racket developer might never know Lisp itself.<p>As someone trying to write definitively about cold hard reasons Racket remains in relative obscurity, I would be interested to know specifics you can provide for this view. Is it just academia vibes? Or are there specific aspects of Racket that in your view repel “seasoned programmers”?<p>I notice you praise Guile for having decent documentation and standard library. How do you believe Racket’s documentation and standard library compare to Guile’s?</div><br/><div id="39183733" class="c"><input type="checkbox" id="c-39183733" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183517">parent</a><span>|</span><a href="#39184316">next</a><span>|</span><label class="collapse" for="c-39183733">[-]</label><label class="expand" for="c-39183733">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I don&#x27;t have anything more concrete than &quot;general vibes.&quot;<p>Like, there&#x27;s thousands of libraries and modules in Racket, sometimes competing with each other, that feel like they have been developed for a school project and kept around. And it is no secret that Matthew Flatt, one of the lead developers, is actually a professor at Utah University.<p>In my experience, it is pretty easy to tell when a language and ecosystem is developed in academia, or developed by software engineers by trade. They have two very different goals and approaches to the same problem. The former might focus on educational purpose for newbies, the latter on shipping production-ready software for professionals.<p>(In my humble opinion, this is one of the reasons Smalltalk never went very far in the real world. Too much focus on the educational aspect of it.)</div><br/></div></div><div id="39184316" class="c"><input type="checkbox" id="c-39184316" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39183517">parent</a><span>|</span><a href="#39183733">prev</a><span>|</span><a href="#39185629">next</a><span>|</span><label class="collapse" for="c-39184316">[-]</label><label class="expand" for="c-39184316">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Or are there specific aspects of Racket that in your view repel [competent programmers]?<p>This is anecdotal and over a decade ago, but quite specific: my first exposure to Racket was with a version of the language (I think it was some pragma-type thing like `#lang`, but it&#x27;s been a while) allegedly intended for CS classes, and included something along the lines of [exact spelling and phrasing almost certainly differ]:<p><pre><code>  &gt; (cons &#x27;foo &#x27;bar)
  error: cons: &#x27;bar is not a list
</code></pre>
I immediately deleted the Racket installation and added it to the same set of blacklists as the Java Virtual Machine (and hypothetically any COBOL implementations I ever encounter). That <i>any</i> version of the language would behave that way, much less one purportedly intended for people who are only just learning LISP in the first place, is a insult to everyone who ever bothered to actually learn LISP in the first place.<p>This is the sort of &quot;Dangling by a Trivial Feature&quot;[0] thing that there&#x27;s just no excuse for, like trying out a new text editor and discoving that pressing backspace inserts the text &quot;^H&quot;, except it was clearly deliberately <i>aimed</i> at people who didn&#x27;t know any better and would &#x27;hopefully&#x27; not realise there was a problem, rather than just being a local idiosyncracy[1], because cons <i>did</i> work correctly under other dialect settings.<p><i>Actively trying</i> to fuck over newcomers who are only just learning LISP (or programming in general) deeply offends me.<p>0: <a href="https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;160.html" rel="nofollow">https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;160.html</a><p>1: In which case I still wouldn&#x27;t use Racket myself, but I wouldn&#x27;t be actively opposed to anyone else doing so.</div><br/><div id="39185686" class="c"><input type="checkbox" id="c-39185686" checked=""/><div class="controls bullet"><span class="by">samth</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39184316">parent</a><span>|</span><a href="#39184656">next</a><span>|</span><label class="collapse" for="c-39185686">[-]</label><label class="expand" for="c-39185686">[1 more]</label></div><br/><div class="children"><div class="content">It is indeed the case that the student languages in Racket use cons only for lists. Improper lists are an extra complexity that people just learning to program don&#x27;t need.</div><br/></div></div><div id="39184656" class="c"><input type="checkbox" id="c-39184656" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39184316">parent</a><span>|</span><a href="#39185686">prev</a><span>|</span><a href="#39185629">next</a><span>|</span><label class="collapse" for="c-39184656">[-]</label><label class="expand" for="c-39184656">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve dabbled in a few lisps and definitely a noobie but I have absolutely no idea what you&#x27;re talking about</div><br/><div id="39186116" class="c"><input type="checkbox" id="c-39186116" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39184656">parent</a><span>|</span><a href="#39186444">next</a><span>|</span><label class="collapse" for="c-39186116">[-]</label><label class="expand" for="c-39186116">[3 more]</label></div><br/><div class="children"><div class="content">That language behavior fundamentally misrepresents how a proper cons should actually work. It&#x27;s a link between any two values, represented as essentially two joined pointers, one to each value. It represents a linked list when cons cells are nested, but that&#x27;s just something that falls out of the far more beautiful and fundamental core axiom of the cons cell, not all of what cons cells are. Thus claiming cons cells <i>must</i> be nested (which is what requiring the second argument of cons to be a list (I.e. more nested cons cells or nil) implies) is actually bastardizing what a cons cell is, reducing it to a menial operation for producing lists that means the same thing as &quot;prepend&quot; instead of an elegant core abstraction you can derive further things from. Bastardizing it like this, honestly <i>especially</i> in a language for teaching CS, in the name of talking down to students, is unforgivable. I learned Common Lisp at 12 partially from Land of Lisp and partially from a Lisp 1.5 manual and experimentation. Properly learning the core abstractions was vital.</div><br/><div id="39186136" class="c"><input type="checkbox" id="c-39186136" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39186116">parent</a><span>|</span><a href="#39186444">next</a><span>|</span><label class="collapse" for="c-39186136">[-]</label><label class="expand" for="c-39186136">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>requiring the second argument of cons to be a list</i><p>A language called ISLisp (ISO Standard Lisp) also does this nasty thing.</div><br/><div id="39186719" class="c"><input type="checkbox" id="c-39186719" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39186136">parent</a><span>|</span><a href="#39186444">next</a><span>|</span><label class="collapse" for="c-39186719">[-]</label><label class="expand" for="c-39186719">[1 more]</label></div><br/><div class="children"><div class="content">To be scrupulously fair, that seems to fall under<p>&gt; just being a local idiosyncracy<p>albeit a stupid one; whereas Racket actively targets beginners in particular.<p>Also, this is ISO we&#x27;re talking about here; we probably shouldn&#x27;t expect anything technically competent from them that isn&#x27;t just a rubber-stamped version of someone else&#x27;s specification, and they didn&#x27;t call it &quot;ISO Standard Common Lisp&quot; or &quot;ISO Standard Scheme&quot;, presumably for good reason.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39185629" class="c"><input type="checkbox" id="c-39185629" checked=""/><div class="controls bullet"><span class="by">nsm</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39183517">prev</a><span>|</span><a href="#39184261">next</a><span>|</span><label class="collapse" for="c-39185629">[-]</label><label class="expand" for="c-39185629">[1 more]</label></div><br/><div class="children"><div class="content">I would like to disagree with this view of Racket.<p>I&#x27;m a fairly experienced professional programmer with a lot of systems experience, and I find Racket an extremely well thought out, competently implemented and high performance (particularly with the switch to Chez Scheme) language.<p>I wrote a bit about it at <a href="https:&#x2F;&#x2F;nikhilism.com&#x2F;post&#x2F;2023&#x2F;racket-beyond-languages&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nikhilism.com&#x2F;post&#x2F;2023&#x2F;racket-beyond-languages&#x2F;</a> and Bogdan Popa and Alex Hirsanyi have done amazing stuff with the language 
<a href="https:&#x2F;&#x2F;defn.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;defn.io&#x2F;</a>
<a href="https:&#x2F;&#x2F;alex-hhh.github.io&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;alex-hhh.github.io&#x2F;index.html</a>
including a sophisticated web framework, a Kafka GUI client and so on.<p>I think the only deficiency for a &quot;pragmatic for a seasoned programmer&quot; (beyond the standard &quot;no FAANG is sponsoring it&quot; related lack of resources and presence in popular discussion) is the lack of good editor integration beyond emacs. That said, I&#x27;ve found DrRacket perfectly reasonable for my uses, although clunky.
I&#x27;m not saying it can replace something like Python, but that is more because of the smaller ecosystem and contributor base than anything wrong with the language itself.</div><br/></div></div><div id="39184261" class="c"><input type="checkbox" id="c-39184261" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39185629">prev</a><span>|</span><a href="#39185891">next</a><span>|</span><label class="collapse" for="c-39184261">[-]</label><label class="expand" for="c-39184261">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s here that I&#x27;ll again get on my soapbox about Scheme.<p>SRFIs suck really badly. The language isn&#x27;t useful without them, but every implementation uses a different subset. You have to find out which SRFI does what you want (there may be more than one) then find out what number it is then look up the SRFI itself because the spec is pretty much the only documentation you&#x27;re going to get.<p>This entire situation sucks for experienced devs and simply kills most beginners before they even do anything.<p>Things were supposed to get better with R7RS. It was supposed to have a tiny core language to keep the R5RS crowd happy, but add the R6RS features in the large edition that are needed to get real work done.<p>R7RS-small released in 2013. That&#x27;s TEN YEARS ago and it STILL doesn&#x27;t have a standardized library because apparently nobody wants to work on R7RS-large.<p>The whole thing is an unusable mess for no good reason and it&#x27;s killing the language.</div><br/><div id="39184977" class="c"><input type="checkbox" id="c-39184977" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39184261">parent</a><span>|</span><a href="#39185891">next</a><span>|</span><label class="collapse" for="c-39184977">[-]</label><label class="expand" for="c-39184977">[1 more]</label></div><br/><div class="children"><div class="content">People are working on R7RS-Large, a lot of the standard is decided upon by now. I suspect, though, it&#x27;ll take another five years...<p><a href="https:&#x2F;&#x2F;github.com&#x2F;johnwcowan&#x2F;r7rs-work&#x2F;blob&#x2F;master&#x2F;WG2Dockets.md">https:&#x2F;&#x2F;github.com&#x2F;johnwcowan&#x2F;r7rs-work&#x2F;blob&#x2F;master&#x2F;WG2Docke...</a></div><br/></div></div></div></div><div id="39185891" class="c"><input type="checkbox" id="c-39185891" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39184261">prev</a><span>|</span><a href="#39183566">next</a><span>|</span><label class="collapse" for="c-39185891">[-]</label><label class="expand" for="c-39185891">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Racket is the best for a beginner, but it keeps having that academic, &quot;we made it for the kids&quot; feel of being easy to understand but not very pragmatic for a seasoned programmer. And it is one of a kind, so a good Racket developer might never know Lisp itself.<p>I find Racket to be more pragmatic than Java, Python, and JavaScript. So much so that I trade options with it. Edit: &quot;pragmatic&quot; not for all things, but for many things, including GUIs and charts. Second edit: whoops. I see I&#x27;ve already pointed out this Racket program to you.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;evdubs&#x2F;renegade-way">https:&#x2F;&#x2F;github.com&#x2F;evdubs&#x2F;renegade-way</a></div><br/><div id="39186310" class="c"><input type="checkbox" id="c-39186310" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39185891">parent</a><span>|</span><a href="#39183566">next</a><span>|</span><label class="collapse" for="c-39186310">[-]</label><label class="expand" for="c-39186310">[2 more]</label></div><br/><div class="children"><div class="content">This is a very cool project!<p>Have you considered using Typed Racket for it? If yes, then how do you see the tradeoffs?</div><br/><div id="39187246" class="c"><input type="checkbox" id="c-39187246" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#39183328">root</a><span>|</span><a href="#39186310">parent</a><span>|</span><a href="#39183566">next</a><span>|</span><label class="collapse" for="c-39187246">[-]</label><label class="expand" for="c-39187246">[1 more]</label></div><br/><div class="children"><div class="content">I sort of evaluated Typed Racket before I started writing lots of Racket code, and my experience was that &quot;Contract&quot; Racket (regular non-Typed Racket) was more ergonomic and idiomatic. I think the contract system is great and I use it, for example, when sending messages to Interactive Brokers:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;evdubs&#x2F;interactive-brokers-api&#x2F;blob&#x2F;master&#x2F;request-messages.rkt">https:&#x2F;&#x2F;github.com&#x2F;evdubs&#x2F;interactive-brokers-api&#x2F;blob&#x2F;maste...</a><p>This file just includes request message definitions and to-string (-&gt;string) implementations.<p>The overall program&#x27;s performance is adequate for me, so if the contract system is causing overhead, I don&#x27;t particularly care about it. Maybe that&#x27;s a scalability concern for more performance-demanding programs which could benefit from Typed Racket.</div><br/></div></div></div></div></div></div><div id="39183566" class="c"><input type="checkbox" id="c-39183566" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39185891">prev</a><span>|</span><a href="#39183637">next</a><span>|</span><label class="collapse" for="c-39183566">[-]</label><label class="expand" for="c-39183566">[1 more]</label></div><br/><div class="children"><div class="content">Yeah Guile should get more love! Very practical lisp that punches above its weight. I&#x27;ve had the fortune of writing Guile as my full-time job for the past year and I&#x27;ve been a user for a lot longer so I can attest that you can get stuff done with it.</div><br/></div></div><div id="39183637" class="c"><input type="checkbox" id="c-39183637" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39183566">prev</a><span>|</span><a href="#39183898">next</a><span>|</span><label class="collapse" for="c-39183637">[-]</label><label class="expand" for="c-39183637">[1 more]</label></div><br/><div class="children"><div class="content">Lol, a bit scathing but mostly fair from my experience. I haven&#x27;t used Lisps a lot but I&#x27;m a pretty big Emacs user and I&#x27;ve played around with the languages your mentioned and I feel somewhat the same.<p>I&#x27;ll just add that the ideas and many libraries around Racket are super cool. There&#x27;s really a bunch of documentation and tutorials for a lot of things, it&#x27;s fun.</div><br/></div></div><div id="39183898" class="c"><input type="checkbox" id="c-39183898" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#39183328">parent</a><span>|</span><a href="#39183637">prev</a><span>|</span><a href="#39184194">next</a><span>|</span><label class="collapse" for="c-39183898">[-]</label><label class="expand" for="c-39183898">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Racket is the best for a beginner, but it keeps having that academic, &quot;we made it for the kids&quot; feel of being easy to understand but not very pragmatic for a seasoned programmer. And it is one of a kind, so a good Racket developer might never know Lisp itself.</i><p>I know why you got that reasonable impression, but there&#x27;s more to it, which can make it much more interesting to practitioners...<p>The gang-of-professors reasons for Racket are for research platform and education platform.<p>However, at the same time, Racket (then called PLT Scheme) attracted a disproportionate share of a user community of high-powered programmers and software engineers, like you also see with Common Lisp and some other languages.  And one of the professors, Matthew Flatt, happens to be a great systems programmer, with good software engineering sensibility.<p>There&#x27;s some really solid stuff in Racket, and I&#x27;ve used it on important systems with hyper-productive teams (you&#x27;d think they had a hundred engineers, when it was only a few).<p>The impression you get might be for two reasons:<p>1. The gang-of-professors decides most of the customer-facing <i>image</i> for Racket, in various ways, such as writing some introductory books, promoting their zero-prior-experience-student-oriented IDE as the Racket IDE, odd language on the Web site, etc.<p>2. At times they&#x27;ve also made <i>direction</i> decisions that suit either their education&amp;research goals or, secondarily, their idea of what professional practice wants.  On the latter, of course, people who&#x27;ve been professors for decades aren&#x27;t going to have all the insights of the best people who&#x27;ve been practicing in industry that same period.<p>If you want to approach Racket as a serious and skilled practitioner, one way is to focus on the Guide and Reference books (I wish these were consolidated), and expect that you&#x27;ll have to creatively build much of the ecosystem bits you need from scratch.  That can actually be a great situation to be in, if you&#x27;re up for it.<p>The governance model, last I checked, is a benevolent dictatorship by the gang-of-professors, and the industry practitioner user community is currently small, so just be aware of that going in.  But, there&#x27;s an open ecosystem for packages, more empowering than most languages, due to all the language-extension mechanisms of Racket, so you can &quot;build out&quot; Racket in a decentralized way, to some extent.  If you do that, you&#x27;ll want to keep on top of what the gang-of-professors are doing, and give them a heads-up on things you&#x27;re doing, to minimize unpleasant conflicts.<p>I&#x27;m not going to make a sales pitch for it; just wanted to add some info for serious practitioners who&#x27;re already interested, on what to expect, and how to approach it.</div><br/></div></div></div></div><div id="39183568" class="c"><input type="checkbox" id="c-39183568" checked=""/><div class="controls bullet"><span class="by">FrustratedMonky</span><span>|</span><a href="#39183328">prev</a><span>|</span><label class="collapse" for="c-39183568">[-]</label><label class="expand" for="c-39183568">[2 more]</label></div><br/><div class="children"><div class="content">Not even an honorable mention for F#? Why does Haskell get a mention, since it is also just another ML based language.<p>Seems like F# is trying to solve the same problems as LISP. Lot of same features.<p>Edit: 
Did like article. 
Is serious question<p>LISP-&gt; Clojure-&gt; F#.<p>There are similarities.<p>Edit2:<p>Guess it is a stretch. But not insultingly so.<p>Have seen articles comparing Lisp macros to F# Type Providers.</div><br/><div id="39183665" class="c"><input type="checkbox" id="c-39183665" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39183568">parent</a><span>|</span><label class="collapse" for="c-39183665">[-]</label><label class="expand" for="c-39183665">[1 more]</label></div><br/><div class="children"><div class="content">F# isn&#x27;t a Lisp, so I think it&#x27;s fair to consider it out of scope. I think the only reason Haskell got mentioned is because the author has experience with it and was using it as a personal point of reference.</div><br/></div></div></div></div></div></div></div></div></div></body></html>