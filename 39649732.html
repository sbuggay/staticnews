<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710061251457" as="style"/><link rel="stylesheet" href="styles.css?v=1710061251457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://questdb.io/blog/1brc-merykittys-magic-swar/">1brc merykitty&#x27;s magic SWAR: 8 lines of code explained in 3k words</a> <span class="domain">(<a href="https://questdb.io">questdb.io</a>)</span></div><div class="subtext"><span>signa11</span> | <span>60 comments</span></div><br/><div><div id="39654168" class="c"><input type="checkbox" id="c-39654168" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#39654236">next</a><span>|</span><label class="collapse" for="c-39654168">[-]</label><label class="expand" for="c-39654168">[3 more]</label></div><br/><div class="children"><div class="content">If people like stuff like this, the simdjson paper uses similar techniques, is extremely well-written and has great examples.<p>Paper: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1902.08318" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1902.08318</a><p>Github: <a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson</a></div><br/><div id="39654842" class="c"><input type="checkbox" id="c-39654842" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#39654168">parent</a><span>|</span><a href="#39655024">prev</a><span>|</span><a href="#39654236">next</a><span>|</span><label class="collapse" for="c-39654842">[-]</label><label class="expand" for="c-39654842">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t SWAR though but I get how it might appeal.</div><br/></div></div></div></div><div id="39654236" class="c"><input type="checkbox" id="c-39654236" checked=""/><div class="controls bullet"><span class="by">teucris</span><span>|</span><a href="#39654168">prev</a><span>|</span><a href="#39655775">next</a><span>|</span><label class="collapse" for="c-39654236">[-]</label><label class="expand" for="c-39654236">[2 more]</label></div><br/><div class="children"><div class="content">Great article and given the context of the code this is a brilliant solution, but note that this assumes that the data is well-formed. Much of the value in an effective, battled-worn parser is efficient error checking and recovery.</div><br/><div id="39654980" class="c"><input type="checkbox" id="c-39654980" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39654236">parent</a><span>|</span><a href="#39655775">next</a><span>|</span><label class="collapse" for="c-39654980">[-]</label><label class="expand" for="c-39654980">[1 more]</label></div><br/><div class="children"><div class="content">It would be interesting to see a breakdown of the ways in which ill-formed inputs could affect the output. And how much work it would be to detect such inputs and return some kind of sentinel error value - in the same style as the current code.<p>(Not quite interesting enough for me to do it myself though ;-)</div><br/></div></div></div></div><div id="39655775" class="c"><input type="checkbox" id="c-39655775" checked=""/><div class="controls bullet"><span class="by">kwillets</span><span>|</span><a href="#39654236">prev</a><span>|</span><a href="#39653931">next</a><span>|</span><label class="collapse" for="c-39655775">[-]</label><label class="expand" for="c-39655775">[1 more]</label></div><br/><div class="children"><div class="content">Multiplying digit bitfields by their respective powers of 10 and shift&#x2F;adding via MUL is a (well?) known technique, see Lemire <a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;11&#x2F;28&#x2F;parsing-8-bit-integers-quickly&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;11&#x2F;28&#x2F;parsing-8-bit-integers-qui...</a> .</div><br/></div></div><div id="39653931" class="c"><input type="checkbox" id="c-39653931" checked=""/><div class="controls bullet"><span class="by">quercusa</span><span>|</span><a href="#39655775">prev</a><span>|</span><a href="#39657668">next</a><span>|</span><label class="collapse" for="c-39653931">[-]</label><label class="expand" for="c-39653931">[1 more]</label></div><br/><div class="children"><div class="content">As per the article: SWAR is &quot;SIMD Within A Register&quot;</div><br/></div></div><div id="39657668" class="c"><input type="checkbox" id="c-39657668" checked=""/><div class="controls bullet"><span class="by">MrYellowP</span><span>|</span><a href="#39653931">prev</a><span>|</span><a href="#39655684">next</a><span>|</span><label class="collapse" for="c-39657668">[-]</label><label class="expand" for="c-39657668">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the real mystery is how a single guy working alone could come up with all this in just a few days of casually doing an online challenge with a T-shirt and a coffee mug as a reward.<p>Why is that a mystery? There&#x27;s still people out there who actually know how to program a CPU and actually understand what they&#x27;re doing. The <i>real</i> mystery is the lack of deeper understanding of most people who call themselves programmers, combined with the fact that they don&#x27;t appear to be knowing that they&#x27;re seriously lacking.</div><br/></div></div><div id="39655684" class="c"><input type="checkbox" id="c-39655684" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#39657668">prev</a><span>|</span><a href="#39654874">next</a><span>|</span><label class="collapse" for="c-39655684">[-]</label><label class="expand" for="c-39655684">[10 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me how the BRC isn&#x27;t bottlenecked on I&#x2F;O? I don&#x27;t understand how the CPU is the bottleneck.</div><br/><div id="39657613" class="c"><input type="checkbox" id="c-39657613" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39655684">parent</a><span>|</span><a href="#39655985">next</a><span>|</span><label class="collapse" for="c-39657613">[-]</label><label class="expand" for="c-39657613">[1 more]</label></div><br/><div class="children"><div class="content">Since the dataset is small enough so that it fits into the Linux kernel page cache, and since the benchmark is repeated for 5 consecutive times, first iteration of the benchmark will be bottlenecked by the disk I&#x2F;O but the remaining 4 will not - e.g. all data will be in RAM (page-cache).</div><br/></div></div><div id="39655985" class="c"><input type="checkbox" id="c-39655985" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#39655684">parent</a><span>|</span><a href="#39657613">prev</a><span>|</span><a href="#39656039">next</a><span>|</span><label class="collapse" for="c-39655985">[-]</label><label class="expand" for="c-39655985">[5 more]</label></div><br/><div class="children"><div class="content">Local disk I&#x2F;O is no longer the bottleneck on modern systems: <a href="https:&#x2F;&#x2F;benhoyt.com&#x2F;writings&#x2F;io-is-no-longer-the-bottleneck&#x2F;" rel="nofollow">https:&#x2F;&#x2F;benhoyt.com&#x2F;writings&#x2F;io-is-no-longer-the-bottleneck&#x2F;</a><p>In addition, the official 1BRC explicitly evaluated results on a RAM disk to avoid I&#x2F;O speed entirely: <a href="https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc?tab=readme-ov-file#evaluating-results">https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc?tab=readme-ov-file#eva...</a> &quot;Programs are run from a RAM disk (i.o. the IO overhead for loading the file from disk is not relevant)&quot;</div><br/><div id="39656033" class="c"><input type="checkbox" id="c-39656033" checked=""/><div class="controls bullet"><span class="by">davidmurdoch</span><span>|</span><a href="#39655684">root</a><span>|</span><a href="#39655985">parent</a><span>|</span><a href="#39657332">next</a><span>|</span><label class="collapse" for="c-39656033">[-]</label><label class="expand" for="c-39656033">[2 more]</label></div><br/><div class="children"><div class="content">I was surprised by this recently when optimizing a build process that uses an intermediate write-to-disk step. I replaced the intermediate filesystem API with an in-memory one and it was not measurably faster. Not even by a single millisecond.</div><br/><div id="39656512" class="c"><input type="checkbox" id="c-39656512" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#39655684">root</a><span>|</span><a href="#39656033">parent</a><span>|</span><a href="#39657332">next</a><span>|</span><label class="collapse" for="c-39656512">[-]</label><label class="expand" for="c-39656512">[1 more]</label></div><br/><div class="children"><div class="content">How much data were you writing? If you don&#x27;t fill the OS&#x27;s page cache and the SSD controller&#x27;s DRAM cache, and you&#x27;re not blocking on fsync() or O_DIRECT or some other explicit flushing mechanism, then you&#x27;re not going to see much of a difference in throughput.</div><br/></div></div></div></div><div id="39657332" class="c"><input type="checkbox" id="c-39657332" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#39655684">root</a><span>|</span><a href="#39655985">parent</a><span>|</span><a href="#39656033">prev</a><span>|</span><a href="#39656650">next</a><span>|</span><label class="collapse" for="c-39657332">[-]</label><label class="expand" for="c-39657332">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, thanks, I didn&#x27;t know about the ramdisk. Very interesting about I&#x2F;O not being the bottleneck, though.</div><br/></div></div></div></div><div id="39656039" class="c"><input type="checkbox" id="c-39656039" checked=""/><div class="controls bullet"><span class="by">nkurz</span><span>|</span><a href="#39655684">parent</a><span>|</span><a href="#39655985">prev</a><span>|</span><a href="#39656135">next</a><span>|</span><label class="collapse" for="c-39656039">[-]</label><label class="expand" for="c-39656039">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t looked at the problem closely enough to answer, but could we start from the other direction:  what makes you think that memory I&#x2F;O would be the bottleneck?<p>From my limited understanding, we sequentially bring a large text file into L1 and then do a single read for each value.  On most processors we can do two of these per cycle.  The slow part will be bringing it into L1 from RAM, but sequential reads are pretty fast.<p>We then do some processing on each read.  At a glance, maybe 4 cycles worth in this optimized version? Then we need to write the result somewhere, presumably with a random read (or two?) first.  Is this the part you are thinking is going to be the I&#x2F;O bottleneck?<p>I&#x27;m not saying it&#x27;s obviously CPU limited, but it doesn&#x27;t seem obvious that it wouldn&#x27;t be.<p>Edit:  I hadn&#x27;t considered that you might have meant &quot;disk I&#x2F;O&quot;.  As others have said, that&#x27;s not really a factor here.</div><br/><div id="39657296" class="c"><input type="checkbox" id="c-39657296" checked=""/><div class="controls bullet"><span class="by">haxen</span><span>|</span><a href="#39655684">root</a><span>|</span><a href="#39656039">parent</a><span>|</span><a href="#39656135">next</a><span>|</span><label class="collapse" for="c-39657296">[-]</label><label class="expand" for="c-39657296">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe 4 cycles worth in this optimized version?<p>It&#x27;s quite a bit more than that, just the code discussed in the post is around 20 instructions, and there&#x27;s a bunch more concerns like finding the delimiter between the name and the temperature, and hashtable operations. All put together, it comes to around 80 cycles per row.<p>When explaining the timing of 1.5 seconds, one must take into account that it&#x27;s parallelized across 8 CPU cores.</div><br/></div></div></div></div><div id="39656135" class="c"><input type="checkbox" id="c-39656135" checked=""/><div class="controls bullet"><span class="by">codegladiator</span><span>|</span><a href="#39655684">parent</a><span>|</span><a href="#39656039">prev</a><span>|</span><a href="#39654874">next</a><span>|</span><label class="collapse" for="c-39656135">[-]</label><label class="expand" for="c-39656135">[1 more]</label></div><br/><div class="children"><div class="content">The test is executed with memfs. The file and everything is in ram at startup.</div><br/></div></div></div></div><div id="39654874" class="c"><input type="checkbox" id="c-39654874" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#39655684">prev</a><span>|</span><a href="#39653530">next</a><span>|</span><label class="collapse" for="c-39654874">[-]</label><label class="expand" for="c-39654874">[1 more]</label></div><br/><div class="children"><div class="content">Used to do SWAR on the 68000 to good effect. 4 bytes operated on in parallel in a single instruction. Tricky to handle the overflow IIRC. I really like this article!</div><br/></div></div><div id="39653530" class="c"><input type="checkbox" id="c-39653530" checked=""/><div class="controls bullet"><span class="by">plokhotnyuk</span><span>|</span><a href="#39654874">prev</a><span>|</span><a href="#39655275">next</a><span>|</span><label class="collapse" for="c-39653530">[-]</label><label class="expand" for="c-39653530">[1 more]</label></div><br/><div class="children"><div class="content">What an amazing step by step explanation!<p>More than 2 years ago I found that byte array view var handles are quite suitable to cook efficient SWAR routines with Java&#x2F;Scala.<p>See a lot of other examples of SWAR usage, like parsing Base16&#x2F;64 strings, java.time.* and number values directly from byte arrays:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;plokhotnyuk&#x2F;jsoniter-scala&#x2F;blob&#x2F;master&#x2F;jsoniter-scala-core&#x2F;jvm&#x2F;src&#x2F;main&#x2F;scala&#x2F;com&#x2F;github&#x2F;plokhotnyuk&#x2F;jsoniter_scala&#x2F;core&#x2F;JsonReader.scala">https:&#x2F;&#x2F;github.com&#x2F;plokhotnyuk&#x2F;jsoniter-scala&#x2F;blob&#x2F;master&#x2F;js...</a></div><br/></div></div><div id="39655275" class="c"><input type="checkbox" id="c-39655275" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#39653530">prev</a><span>|</span><a href="#39654096">next</a><span>|</span><label class="collapse" for="c-39655275">[-]</label><label class="expand" for="c-39655275">[1 more]</label></div><br/><div class="children"><div class="content">This article helped me understand bit fiddling better than any before it. Thanks to the author and the author of the really novel Java solution to the 1BRC challenge.</div><br/></div></div><div id="39654096" class="c"><input type="checkbox" id="c-39654096" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#39655275">prev</a><span>|</span><a href="#39652908">next</a><span>|</span><label class="collapse" for="c-39654096">[-]</label><label class="expand" for="c-39654096">[3 more]</label></div><br/><div class="children"><div class="content">I remember the first time I read about this technique used by the Linux kernel to find the \0 at the end of the string. If course XORing with another char will detect that char instead.<p>But before you run to implement it as a drop-in replacement for strlen() all over your code, please note that in real-world cases the string length is not guaranteed to be a multiple of 8. When you read the last long, you might overrun your memory buffer and trigger a page fault.</div><br/><div id="39655037" class="c"><input type="checkbox" id="c-39655037" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39654096">parent</a><span>|</span><a href="#39652908">next</a><span>|</span><label class="collapse" for="c-39655037">[-]</label><label class="expand" for="c-39655037">[2 more]</label></div><br/><div class="children"><div class="content">&gt; When you read the last long, you might overrun your memory buffer and trigger a page fault.<p>You know that page boundaries are always on a `PAGE_SIZE` alignment, which you can get with `getpagesize()` or `sysconf(_SC_PAGESIZE)`.<p>...but overrunning the declared size of a memory allocation is still UB, even if you don&#x27;t trigger a page fault, so YMMV ;-)</div><br/><div id="39655882" class="c"><input type="checkbox" id="c-39655882" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39654096">root</a><span>|</span><a href="#39655037">parent</a><span>|</span><a href="#39652908">next</a><span>|</span><label class="collapse" for="c-39655882">[-]</label><label class="expand" for="c-39655882">[1 more]</label></div><br/><div class="children"><div class="content">Also, as I learned recently: UB minor faults are allowed to change under you. You&#x27;re not guaranteed to get the same value next time you access them, even if nothing else in your process is touching that memory.</div><br/></div></div></div></div></div></div><div id="39652908" class="c"><input type="checkbox" id="c-39652908" checked=""/><div class="controls bullet"><span class="by">majke</span><span>|</span><a href="#39654096">prev</a><span>|</span><a href="#39653172">next</a><span>|</span><label class="collapse" for="c-39652908">[-]</label><label class="expand" for="c-39652908">[10 more]</label></div><br/><div class="children"><div class="content">Can you vectorize this with SSE. Most of the magic could be done with vector of four 32 bit integers.<p>The question is if the cost of setting up the initial vector and extracting the result isnt prohibitive.</div><br/><div id="39653832" class="c"><input type="checkbox" id="c-39653832" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#39652908">parent</a><span>|</span><a href="#39654025">next</a><span>|</span><label class="collapse" for="c-39653832">[-]</label><label class="expand" for="c-39653832">[2 more]</label></div><br/><div class="children"><div class="content">It can, and various other 1BRC implementations have (though I doubt hotspot would manage to do it itself, never mind that most 1BRC submissions were run with Graal for the lower startup overhead). The 32×32→64-bit multiplication poses an issue on the default SSE2 as it has no 32-bit or 64-bit multiplication, but SSE4.1 adds exactly the needed thing, pmuldq (although, as that returns a 64-bit result, you&#x27;d need two of such to process a full vector of 32-bit ints).</div><br/><div id="39656316" class="c"><input type="checkbox" id="c-39656316" checked=""/><div class="controls bullet"><span class="by">RaisingSpear</span><span>|</span><a href="#39652908">root</a><span>|</span><a href="#39653832">parent</a><span>|</span><a href="#39654025">next</a><span>|</span><label class="collapse" for="c-39656316">[-]</label><label class="expand" for="c-39656316">[1 more]</label></div><br/><div class="children"><div class="content">Did the challenge limit submissions to only using SSE2?  Seems odd, given the prevalence of SSE4.2 support.<p>PMULUDQ is in SSE2, though I haven&#x27;t checked if that&#x27;s usable for the problem here.  There&#x27;s also PMULLD in SSE4.1 if you only need a 32-bit result.  But for summing digits, perhaps SSE2&#x27;s PMADDWD could be sufficient?</div><br/></div></div></div></div><div id="39654025" class="c"><input type="checkbox" id="c-39654025" checked=""/><div class="controls bullet"><span class="by">haxen</span><span>|</span><a href="#39652908">parent</a><span>|</span><a href="#39653832">prev</a><span>|</span><a href="#39654071">next</a><span>|</span><label class="collapse" for="c-39654025">[-]</label><label class="expand" for="c-39654025">[2 more]</label></div><br/><div class="children"><div class="content">The temperature fields are interleaved with name fields, so I don&#x27;t think you&#x27;d get any extra benefit from SSE. Also, since the temperature field is variable-sized, it would probably not pay off even if it was stored by column.<p>SSE was successfully applied to finding the delimiter between the name and the temperature, though.</div><br/><div id="39654366" class="c"><input type="checkbox" id="c-39654366" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#39652908">root</a><span>|</span><a href="#39654025">parent</a><span>|</span><a href="#39654071">next</a><span>|</span><label class="collapse" for="c-39654366">[-]</label><label class="expand" for="c-39654366">[1 more]</label></div><br/><div class="children"><div class="content">It can still be beneficial - yes you need to load the temperatures individually, but there&#x27;s enough operations afterward to make it worth it.</div><br/></div></div></div></div><div id="39653654" class="c"><input type="checkbox" id="c-39653654" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#39652908">parent</a><span>|</span><a href="#39654071">prev</a><span>|</span><a href="#39653172">next</a><span>|</span><label class="collapse" for="c-39653654">[-]</label><label class="expand" for="c-39653654">[4 more]</label></div><br/><div class="children"><div class="content">I imagine code like this gets auto-vectorized either right from the start or after Hotspot detects a hotspot</div><br/><div id="39654066" class="c"><input type="checkbox" id="c-39654066" checked=""/><div class="controls bullet"><span class="by">haxen</span><span>|</span><a href="#39652908">root</a><span>|</span><a href="#39653654">parent</a><span>|</span><a href="#39653172">next</a><span>|</span><label class="collapse" for="c-39654066">[-]</label><label class="expand" for="c-39654066">[3 more]</label></div><br/><div class="children"><div class="content">I wonder what you mean here. What code exactly would get auto-vectorized? Parsing the temperature surely not, since it&#x27;s not in an array of fixed-size fields.</div><br/><div id="39655095" class="c"><input type="checkbox" id="c-39655095" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#39652908">root</a><span>|</span><a href="#39654066">parent</a><span>|</span><a href="#39653172">next</a><span>|</span><label class="collapse" for="c-39655095">[-]</label><label class="expand" for="c-39655095">[2 more]</label></div><br/><div class="children"><div class="content">once you&#x27;ve done the work to implement parsing as branchless bitwise operations on integers I think that code can be extended automatically to operate on larger registers</div><br/><div id="39657346" class="c"><input type="checkbox" id="c-39657346" checked=""/><div class="controls bullet"><span class="by">haxen</span><span>|</span><a href="#39652908">root</a><span>|</span><a href="#39655095">parent</a><span>|</span><a href="#39653172">next</a><span>|</span><label class="collapse" for="c-39657346">[-]</label><label class="expand" for="c-39657346">[1 more]</label></div><br/><div class="children"><div class="content">I think it would work if that was the only code in the loop. But the loop spans several more nontrivial operations, including hashtable insertion.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39653172" class="c"><input type="checkbox" id="c-39653172" checked=""/><div class="controls bullet"><span class="by">pacaro</span><span>|</span><a href="#39652908">prev</a><span>|</span><a href="#39654662">next</a><span>|</span><label class="collapse" for="c-39653172">[-]</label><label class="expand" for="c-39653172">[5 more]</label></div><br/><div class="children"><div class="content">We used to use the BCD opcodes for this kind of thing. Masking off the 0x30, shift digits (if you want packed BCD)<p>I can&#x27;t imagine that has been efficient for decades tho</div><br/><div id="39653201" class="c"><input type="checkbox" id="c-39653201" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39653172">parent</a><span>|</span><a href="#39655170">next</a><span>|</span><label class="collapse" for="c-39653201">[-]</label><label class="expand" for="c-39653201">[3 more]</label></div><br/><div class="children"><div class="content">The BCD instructions are one of the few things that was dropped in the x86-64 transition, so it wouldn&#x27;t work at all anymore.</div><br/><div id="39653738" class="c"><input type="checkbox" id="c-39653738" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39653172">root</a><span>|</span><a href="#39653201">parent</a><span>|</span><a href="#39655170">next</a><span>|</span><label class="collapse" for="c-39653738">[-]</label><label class="expand" for="c-39653738">[2 more]</label></div><br/><div class="children"><div class="content">they&#x27;d never been extended to work on more than 8 bits, even in the 8086; they only really existed for 8080 compatibility, and arguably the 8080 primarily had them to ease the path from earlier intel processors designed for, if i&#x27;m not mistaken, literal pocket calculators<p>in pocket calculators you have to display the result in decimal after performing a single arithmetic operation, so it&#x27;s much more efficient to do the arithmetic in bcd than to convert from decimal to binary, perform the arithmetic operation, and then convert back</div><br/><div id="39653897" class="c"><input type="checkbox" id="c-39653897" checked=""/><div class="controls bullet"><span class="by">pacaro</span><span>|</span><a href="#39653172">root</a><span>|</span><a href="#39653738">parent</a><span>|</span><a href="#39655170">next</a><span>|</span><label class="collapse" for="c-39653897">[-]</label><label class="expand" for="c-39653897">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, if you wanted numbers greater than 99 you had to use them in the x87 (if you had one)</div><br/></div></div></div></div></div></div><div id="39655170" class="c"><input type="checkbox" id="c-39655170" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#39653172">parent</a><span>|</span><a href="#39653201">prev</a><span>|</span><a href="#39654662">next</a><span>|</span><label class="collapse" for="c-39655170">[-]</label><label class="expand" for="c-39655170">[1 more]</label></div><br/><div class="children"><div class="content">Agner says that AAA has latency 5 on Cannon Lake, so using that instruction is a bit faster than doing the operations manually. But if you vectorize (or use SWAR) I imagine you can start to beat the legacy instructions with larger numbers.</div><br/></div></div></div></div><div id="39654662" class="c"><input type="checkbox" id="c-39654662" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#39653172">prev</a><span>|</span><a href="#39652947">next</a><span>|</span><label class="collapse" for="c-39654662">[-]</label><label class="expand" for="c-39654662">[3 more]</label></div><br/><div class="children"><div class="content">Pretty cool. I&#x27;ll have to come back to this<p>But can&#x27;t someone just ask merry kitty where they got the idea from?</div><br/><div id="39655820" class="c"><input type="checkbox" id="c-39655820" checked=""/><div class="controls bullet"><span class="by">Terretta</span><span>|</span><a href="#39654662">parent</a><span>|</span><a href="#39652947">next</a><span>|</span><label class="collapse" for="c-39655820">[-]</label><label class="expand" for="c-39655820">[2 more]</label></div><br/><div class="children"><div class="content">Not saying the idea came from this, but if you were coding in late 70s to mid 80s, you may well have written lots of code using these techniques because 6502 assembly was fun and manageable enough to just write your software in it, especially if you had a Beagle Bros book at hand.</div><br/><div id="39656298" class="c"><input type="checkbox" id="c-39656298" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#39654662">root</a><span>|</span><a href="#39655820">parent</a><span>|</span><a href="#39652947">next</a><span>|</span><label class="collapse" for="c-39656298">[-]</label><label class="expand" for="c-39656298">[1 more]</label></div><br/><div class="children"><div class="content">Anyone who coded in the demoscene too was writing oodles of weird bit-twiddling guff like this, from experience...</div><br/></div></div></div></div></div></div><div id="39652947" class="c"><input type="checkbox" id="c-39652947" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#39654662">prev</a><span>|</span><a href="#39653363">next</a><span>|</span><label class="collapse" for="c-39652947">[-]</label><label class="expand" for="c-39652947">[4 more]</label></div><br/><div class="children"><div class="content">Why does they compute and throw away nextLineStart?<p>long nextLineStart = ...</div><br/><div id="39653082" class="c"><input type="checkbox" id="c-39653082" checked=""/><div class="controls bullet"><span class="by">robin_reala</span><span>|</span><a href="#39652947">parent</a><span>|</span><a href="#39653363">next</a><span>|</span><label class="collapse" for="c-39653082">[-]</label><label class="expand" for="c-39653082">[3 more]</label></div><br/><div class="children"><div class="content">That’s explained at the end of the post: in the real code, that’s the most efficient place to calculate it, and it was passed back out as well.</div><br/><div id="39654011" class="c"><input type="checkbox" id="c-39654011" checked=""/><div class="controls bullet"><span class="by">__float</span><span>|</span><a href="#39652947">root</a><span>|</span><a href="#39653082">parent</a><span>|</span><a href="#39653363">next</a><span>|</span><label class="collapse" for="c-39654011">[-]</label><label class="expand" for="c-39654011">[2 more]</label></div><br/><div class="children"><div class="content">That was some key context lost in the simplification of the original code[1] for this blog post, though. The blog post&#x27;s code <i>returns</i> the temperature (throwing away the next line), whereas the original adds it to a map and returns the next line.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;blob&#x2F;dfec2cdbe6a0334cff054f333ec4b4d9e4d775cf&#x2F;src&#x2F;main&#x2F;java&#x2F;dev&#x2F;morling&#x2F;onebrc&#x2F;CalculateAverage_merykitty.java#L165-L195">https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;blob&#x2F;dfec2cdbe6a0334cf...</a></div><br/><div id="39654043" class="c"><input type="checkbox" id="c-39654043" checked=""/><div class="controls bullet"><span class="by">haxen</span><span>|</span><a href="#39652947">root</a><span>|</span><a href="#39654011">parent</a><span>|</span><a href="#39653363">next</a><span>|</span><label class="collapse" for="c-39654043">[-]</label><label class="expand" for="c-39654043">[1 more]</label></div><br/><div class="children"><div class="content">There are many variations of the original code used in different solutions. Many of them return the temperature like the variant used in the post, but they split out the part that finds the decimal dot into a separate function. Then you can reuse that twice: to finish parsing the temperature, and to advance the cursor to the next row.</div><br/></div></div></div></div></div></div></div></div><div id="39653363" class="c"><input type="checkbox" id="c-39653363" checked=""/><div class="controls bullet"><span class="by">WoodenChair</span><span>|</span><a href="#39652947">prev</a><span>|</span><a href="#39653282">next</a><span>|</span><label class="collapse" for="c-39653363">[-]</label><label class="expand" for="c-39653363">[3 more]</label></div><br/><div class="children"><div class="content">For context on why you should read this: this is a well written article that explains in detail how some bitwise operations work to parse a temperature (think -10.3, or 3.4) with no conditionals (no if-statements or switches). This results in very fast parsing. The language used is Java but it could just as easily be C or Swift.</div><br/><div id="39654529" class="c"><input type="checkbox" id="c-39654529" checked=""/><div class="controls bullet"><span class="by">mnau</span><span>|</span><a href="#39653363">parent</a><span>|</span><a href="#39654587">next</a><span>|</span><label class="collapse" for="c-39654529">[-]</label><label class="expand" for="c-39654529">[1 more]</label></div><br/><div class="children"><div class="content">Result is fast parsing with no error checking.<p>If the input wasn&#x27;t in expected format (e.g. different decimal separator), the result would be incorrect.<p>Fun ss an exercise, but hard to understand, maintain.</div><br/></div></div></div></div><div id="39653282" class="c"><input type="checkbox" id="c-39653282" checked=""/><div class="controls bullet"><span class="by">jdright</span><span>|</span><a href="#39653363">prev</a><span>|</span><label class="collapse" for="c-39653282">[-]</label><label class="expand" for="c-39653282">[10 more]</label></div><br/><div class="children"><div class="content">&gt; the real mystery is how a single guy working alone could come up with all this in just a few days<p>Really not a mystery. This is not that complex for people with low level programming experience (embedded, (older) games, demoscene, performance systems, etc.).<p>Knowing these tricks and knowing how to apply them is basically a requirement on these areas.</div><br/><div id="39653834" class="c"><input type="checkbox" id="c-39653834" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#39653282">parent</a><span>|</span><a href="#39653987">next</a><span>|</span><label class="collapse" for="c-39653834">[-]</label><label class="expand" for="c-39653834">[4 more]</label></div><br/><div class="children"><div class="content">Bit twiddling hacks are increasingly becoming a lost art even in the embedded&#x2F;low level space. There&#x27;s relatively few people around with any day-to-day need for them and I&#x27;ve found myself deleting a lot of the legacy ones I find because the compiler situation has changed so much from when they were originally written.<p>I think this is an excellent skills showcase, even if I don&#x27;t think it&#x27;s magical.</div><br/><div id="39654074" class="c"><input type="checkbox" id="c-39654074" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#39653282">root</a><span>|</span><a href="#39653834">parent</a><span>|</span><a href="#39653987">next</a><span>|</span><label class="collapse" for="c-39654074">[-]</label><label class="expand" for="c-39654074">[3 more]</label></div><br/><div class="children"><div class="content">Back when the word &quot;nanotechnology&quot; used to mean itty-bitty robots* rather than some extremely fine chemical processes done in sequence, or extremely small particle size, I had wondered if we could <i>get</i> to the point of said itty-bity robots before all of the brilliant people who made playable games for restricted consoles like the Atari had retired.<p>* More specifically, miniaturized robots consisting of one or more robot arms with multiple degrees of freedom, a CPU, some kind of storage (perhaps something like wound-up DNA serving as tape on reels), executing programs written by humans.</div><br/><div id="39654191" class="c"><input type="checkbox" id="c-39654191" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#39653282">root</a><span>|</span><a href="#39654074">parent</a><span>|</span><a href="#39653987">next</a><span>|</span><label class="collapse" for="c-39654191">[-]</label><label class="expand" for="c-39654191">[2 more]</label></div><br/><div class="children"><div class="content">That concepts sounds like fantasy, cells are shaped like cells because &#x27;itty-bitty robots&#x27;, and most other configurations, don&#x27;t work thermodynamically or physically or chemically at such small scales.</div><br/><div id="39654269" class="c"><input type="checkbox" id="c-39654269" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#39653282">root</a><span>|</span><a href="#39654191">parent</a><span>|</span><a href="#39653987">next</a><span>|</span><label class="collapse" for="c-39654269">[-]</label><label class="expand" for="c-39654269">[1 more]</label></div><br/><div class="children"><div class="content">Cells are shaped like cells (which is to say <i>ugly bags of mostly water</i>) because they are self-perpetuating chemical reactions in solution.  We usually conduct our chemical reactions in vessels that are round along at least one axis, maybe almost two for our round-bottomed flasks.  This is natural because we&#x27;re enclosing a maximum volume of our solution with a minimal surface (cell membrane or borosilicate glass).<p>On a macro scale, life tends to be bilaterally or radially symmetrical, but our robots are not necessarily like that, just considering even factory robots which are often an arm and little else.  So, at the micro scale, I don&#x27;t think they have to resemble &quot;life&quot; there, either.  I&#x27;m hardly suggesting some kind of tinkertoy with one atom here and another atom there and the strut being, instead of wood, a covalent bond.  No, I think we would need more atoms than that.<p>Frankly, we haven&#x27;t much tried to scale down our robotics.  Oh, you&#x27;ll find someone who will produce the flagellar motor (a mere forty-five nanometers, compared to the ten thousand nanometers of a human cell) but not much else.  I wouldn&#x27;t worry about the thermodynamics and quantum effects until we&#x27;re down to that motor level.</div><br/></div></div></div></div></div></div></div></div><div id="39653987" class="c"><input type="checkbox" id="c-39653987" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39653282">parent</a><span>|</span><a href="#39653834">prev</a><span>|</span><a href="#39653457">next</a><span>|</span><label class="collapse" for="c-39653987">[-]</label><label class="expand" for="c-39653987">[3 more]</label></div><br/><div class="children"><div class="content">Yes. These are standard idioms in low-level performance engineering. This is the kind of thing that would be a fun puzzle for someone with this skill set, something you could come up with in an hour. This particular example does demonstrate a relatively complete understanding of the toolset.<p>I feel like this kind of knowledge is becoming a lost art these days despite having lost no relevance.</div><br/><div id="39654338" class="c"><input type="checkbox" id="c-39654338" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#39653282">root</a><span>|</span><a href="#39653987">parent</a><span>|</span><a href="#39653457">next</a><span>|</span><label class="collapse" for="c-39654338">[-]</label><label class="expand" for="c-39654338">[2 more]</label></div><br/><div class="children"><div class="content">&quot;a sufficient smart compiler....&quot; (&#x2F;s)<p>I had a question recently: would an extra 65th bit in some registers have a good use case with stuff with SWAR?</div><br/><div id="39656005" class="c"><input type="checkbox" id="c-39656005" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#39653282">root</a><span>|</span><a href="#39654338">parent</a><span>|</span><a href="#39653457">next</a><span>|</span><label class="collapse" for="c-39656005">[-]</label><label class="expand" for="c-39656005">[1 more]</label></div><br/><div class="children"><div class="content">Not directly, but I think it could be an alternative to the carry flag present on most CPU architectures (today that means x86 and ARM, and also historically pretty much anything else that was at all significant).<p>The much-hyped RISC-V is one of the few that doesn&#x27;t have a flag register, because it&#x27;s been claimed to be a performance bottleneck - in my somewhat heretical opinion, the actual reason is that its designers are deluded into thinking that C and UNIX are as fundamental to software as transistors are to hardware, and thus anything beyond what&#x27;s needed to support that environment is not worth implementing.<p>But an extra bit per register would be like having a separate carry flag for each, potentially solving some problems with parallelization and also allowing checks for integer overflow at the point a value is stored into memory or used in a subsequent operation.<p>Having some kind of carry flag enables various programming tricks that can also be useful for SWAR, for example subtract-with-carry of a register with itself will either set or clear all bits.</div><br/></div></div></div></div></div></div><div id="39653457" class="c"><input type="checkbox" id="c-39653457" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39653282">parent</a><span>|</span><a href="#39653987">prev</a><span>|</span><a href="#39654593">next</a><span>|</span><label class="collapse" for="c-39653457">[-]</label><label class="expand" for="c-39653457">[1 more]</label></div><br/><div class="children"><div class="content">Imo the most important class in comp sci is computer architecture, specifically one that takes you from gates to a rudimentary alu, registers, to microcode, to some form of assembly coding.<p>There is nothing magical in computers once you can do that deconstruction in your head.</div><br/></div></div></div></div></div></div></div></div></div></body></html>