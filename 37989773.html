<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698138085960" as="style"/><link rel="stylesheet" href="styles.css?v=1698138085960"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://comsec.ethz.ch/research/hardware-design-security/cascade-cpu-fuzzing-via-intricate-program-generation/">Cascade: CPU fuzzing via intricate program generation</a> <span class="domain">(<a href="https://comsec.ethz.ch">comsec.ethz.ch</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>19 comments</span></div><br/><div><div id="37990876" class="c"><input type="checkbox" id="c-37990876" checked=""/><div class="controls bullet"><span class="by">timhh</span><span>|</span><a href="#37993959">next</a><span>|</span><label class="collapse" for="c-37990876">[-]</label><label class="expand" for="c-37990876">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Difficult to tell how complex the bugs are though. Some of them seem to be just triggered by accessing non-existent CSRs which suggests those chips haven&#x27;t been very well verified already?<p>Also:<p>&gt; Cascade discovered
3 inaccurate performance counter bugs (Perfcnts) in Kronos,
VexRiscv and BOOM (K4, V13, B2). They incur an offset in
the retired instruction counters when written by software.<p>Funnily enough the Sail model had this bug too! <a href="https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;sail-riscv&#x2F;issues&#x2F;256">https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;sail-riscv&#x2F;issues&#x2F;256</a></div><br/></div></div><div id="37993959" class="c"><input type="checkbox" id="c-37993959" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37990876">prev</a><span>|</span><a href="#37991344">next</a><span>|</span><label class="collapse" for="c-37993959">[-]</label><label class="expand" for="c-37993959">[4 more]</label></div><br/><div class="children"><div class="content"><i>Note that more than 1000 errata were released in Intel Core and AMD CPUs in recent years</i><p>That was predicted: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16058920">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16058920</a><p>They used to be a bit better than that. IMHO the models released shortly after FDIV bug was discovered would probably have the least errata. Of course, x86 also has a relatively large existing body of software that can exercise obscure instruction sequences --- demoscene productions. I don&#x27;t know whether they&#x27;re still using those for testing, however.<p>As for RISC-V, wasn&#x27;t one of the biggest selling points of RISC that it would avoid bugs like these due to its reduced complexity in comparison to other architectures? Then again, given that almost all of the bugs found seem to be in the FPU, maybe that&#x27;s just an inherently complex piece of a CPU.<p>...and that&#x27;s before even getting into things like marginal signal integrity&#x2F;timing, which was the cause of the early 386&#x27;s 32-bit multiply bug.</div><br/><div id="37995309" class="c"><input type="checkbox" id="c-37995309" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#37993959">parent</a><span>|</span><a href="#37994521">next</a><span>|</span><label class="collapse" for="c-37995309">[-]</label><label class="expand" for="c-37995309">[1 more]</label></div><br/><div class="children"><div class="content">&gt;As for RISC-V, wasn&#x27;t one of the biggest selling points of RISC that it would avoid bugs like these due to its reduced complexity in comparison to other architectures?<p>Not really, RISC is about doing what&#x27;s convenient for HW in HW and leaving other things to SW. It has nothing to do with ease of verification.<p>As the other person mentioned, these are all open source cores, many of which have seen fairly limited DV effort put into them beyond simple lockstep verifiers. The findings here are unfortunately quite shallow and easy to detect issues and so it doesn&#x27;t give a good sense of the maximum capability of the tool.<p>That being said, it&#x27;s cool research and better stimulus is always wonderful. Finding deep CPU bugs is extremely hard and verification typically eats up a huge amount of the engineering budget for real chips.</div><br/></div></div><div id="37994521" class="c"><input type="checkbox" id="c-37994521" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#37993959">parent</a><span>|</span><a href="#37995309">prev</a><span>|</span><a href="#37991344">next</a><span>|</span><label class="collapse" for="c-37994521">[-]</label><label class="expand" for="c-37994521">[2 more]</label></div><br/><div class="children"><div class="content">&gt;As for RISC-V,<p>AIUI they only looked at open source implementations.<p>They might not be anywhere as validated as the commercial counterparts.<p>&gt;...and that&#x27;s before even getting into things like marginal signal integrity&#x2F;timing, which was the cause of the early 386&#x27;s 32-bit multiply bug.<p>I&#x27;d hope modern fab libraries have checks to prevent these.</div><br/><div id="37994975" class="c"><input type="checkbox" id="c-37994975" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#37993959">root</a><span>|</span><a href="#37994521">parent</a><span>|</span><a href="#37991344">next</a><span>|</span><label class="collapse" for="c-37994975">[-]</label><label class="expand" for="c-37994975">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;...and that&#x27;s before even getting into things like marginal signal integrity&#x2F;timing, which was the cause of the early 386&#x27;s 32-bit multiply bug.<p>&gt;I&#x27;d hope modern fab libraries have checks to prevent these.<p>They do - but the end user overclocks the f*ck out of them anyway claiming that it&#x27;s &quot;stable&quot; because it happens to run one workload OK, then complains about software being unstable.</div><br/></div></div></div></div></div></div><div id="37991344" class="c"><input type="checkbox" id="c-37991344" checked=""/><div class="controls bullet"><span class="by">gone35</span><span>|</span><a href="#37993959">prev</a><span>|</span><a href="#37990177">next</a><span>|</span><label class="collapse" for="c-37991344">[-]</label><label class="expand" for="c-37991344">[1 more]</label></div><br/><div class="children"><div class="content">Unrelated but see also &#x27;stress&#x27; by Amos Waterland, an excellent workload generator to impose CPU, memory, I&#x2F;O or disk stress on POSIX systems and report any errors that come up [1,2]. The tool unfortunately hasn&#x27;t been maintained for some time, but it&#x27;s being resurrected [2].<p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190307133628&#x2F;http:&#x2F;&#x2F;people.seas.harvard.edu&#x2F;~apw&#x2F;stress&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190307133628&#x2F;http:&#x2F;&#x2F;people.sea...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;resurrecting-open-source-projects&#x2F;stress">https:&#x2F;&#x2F;github.com&#x2F;resurrecting-open-source-projects&#x2F;stress</a></div><br/></div></div><div id="37990177" class="c"><input type="checkbox" id="c-37990177" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#37991344">prev</a><span>|</span><a href="#37992984">next</a><span>|</span><label class="collapse" for="c-37990177">[-]</label><label class="expand" for="c-37990177">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of interesting that BOOM had the second-lowest number of found bugs, considering that it&#x27;s the only out-of-order core out of the six CPUs.<p>I suppose BOOM got more scrutiny, but CVA6 is quite comparable in popularity.</div><br/></div></div><div id="37992984" class="c"><input type="checkbox" id="c-37992984" checked=""/><div class="controls bullet"><span class="by">debatem1</span><span>|</span><a href="#37990177">prev</a><span>|</span><a href="#37990491">next</a><span>|</span><label class="collapse" for="c-37992984">[-]</label><label class="expand" for="c-37992984">[1 more]</label></div><br/><div class="children"><div class="content">Pretty cool stuff. I built a dumber version of this a few years ago that just did differential fuzzing between actual cores from different vendors, but without feedback on microarchitectural state it didn&#x27;t get very far. Good to see people demonstrating how public descriptions of your parts yield concrete security benefits.</div><br/></div></div><div id="37990491" class="c"><input type="checkbox" id="c-37990491" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#37992984">prev</a><span>|</span><a href="#37990356">next</a><span>|</span><label class="collapse" for="c-37990491">[-]</label><label class="expand" for="c-37990491">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool but sandsifter[1] has a cooler UI.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;sandsifter">https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;sandsifter</a></div><br/><div id="37993533" class="c"><input type="checkbox" id="c-37993533" checked=""/><div class="controls bullet"><span class="by">readyplayernull</span><span>|</span><a href="#37990491">parent</a><span>|</span><a href="#37991393">next</a><span>|</span><label class="collapse" for="c-37993533">[-]</label><label class="expand" for="c-37993533">[1 more]</label></div><br/><div class="children"><div class="content">This is how hacker UIs in movies should look like: <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;xoreaxeaxeax&#x2F;sandsifter&#x2F;master&#x2F;references&#x2F;sandsifter.gif" rel="nofollow noreferrer">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;xoreaxeaxeax&#x2F;sandsifter&#x2F;ma...</a></div><br/></div></div><div id="37991393" class="c"><input type="checkbox" id="c-37991393" checked=""/><div class="controls bullet"><span class="by">flaviens</span><span>|</span><a href="#37990491">parent</a><span>|</span><a href="#37993533">prev</a><span>|</span><a href="#37990356">next</a><span>|</span><label class="collapse" for="c-37991393">[-]</label><label class="expand" for="c-37991393">[2 more]</label></div><br/><div class="children"><div class="content">Guys if somebody makes a cool UI like this for Cascade (both fuzzing and program reduction) I&#x27;ll merge your PR with greatest pleasure &lt;3</div><br/><div id="37991929" class="c"><input type="checkbox" id="c-37991929" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#37990491">root</a><span>|</span><a href="#37991393">parent</a><span>|</span><a href="#37990356">next</a><span>|</span><label class="collapse" for="c-37991929">[-]</label><label class="expand" for="c-37991929">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad you like it. Congratulations on your work!</div><br/></div></div></div></div></div></div><div id="37990356" class="c"><input type="checkbox" id="c-37990356" checked=""/><div class="controls bullet"><span class="by">alain94040</span><span>|</span><a href="#37990491">prev</a><span>|</span><label class="collapse" for="c-37990356">[-]</label><label class="expand" for="c-37990356">[6 more]</label></div><br/><div class="children"><div class="content">The key results:<p>&gt; Cascade discovered 12 bugs that produce wrong computations under certain microarchitectural conditions (Uarchvals) in Kronos and VexRiscv<p>&gt; Cascade discovered 3 bugs that cause hangs in Kro- nos, PicoRV32 and VexRiscv<p>These are the hard bugs to find in the implementation of the CPU<p>&gt; Cascade discovered 4 bugs in BOOM and CVA6 that produce wrong output val- ues regardless of the microarchitectural state<p>These are unacceptable bugs, showing a lack of architectural tests. It means no one ever ran those instructions and checked the result. The community should be able to fix this.</div><br/><div id="37991237" class="c"><input type="checkbox" id="c-37991237" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37990356">parent</a><span>|</span><a href="#37990527">next</a><span>|</span><label class="collapse" for="c-37991237">[-]</label><label class="expand" for="c-37991237">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It means no one ever ran those instructions and checked the result.<p>That&#x27;s not really true. It means they produced wrong values with some input. They may have tested but not hit the pathological input case. No one is going to sweep the entirety of the domain. You really need a formal proof to avoid these bugs.</div><br/><div id="37991367" class="c"><input type="checkbox" id="c-37991367" checked=""/><div class="controls bullet"><span class="by">flaviens</span><span>|</span><a href="#37990356">root</a><span>|</span><a href="#37991237">parent</a><span>|</span><a href="#37992815">next</a><span>|</span><label class="collapse" for="c-37991367">[-]</label><label class="expand" for="c-37991367">[1 more]</label></div><br/><div class="children"><div class="content">Correct. One beneficial thing with Cascade&#x27;s long programs with dependencies is that it will tendentially produce problematic values (values around NaNs, around zero, etc.).
Formal methods won&#x27;t be replaced by Cascade :) but it&#x27;s another amount of work</div><br/></div></div><div id="37992815" class="c"><input type="checkbox" id="c-37992815" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#37990356">root</a><span>|</span><a href="#37991237">parent</a><span>|</span><a href="#37991367">prev</a><span>|</span><a href="#37990527">next</a><span>|</span><label class="collapse" for="c-37992815">[-]</label><label class="expand" for="c-37992815">[2 more]</label></div><br/><div class="children"><div class="content">If doing the formal route, then Centaur&#x27;s reports are worth looking at for using ACL2:<p><a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;267809758_Use_of_Formal_Verification_at_Centaur_Technology" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;267809758_Use_of_Fo...</a><p><a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;hunt&#x2F;talks&#x2F;2021-11-Centaur.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;hunt&#x2F;talks&#x2F;2021-11-Centaur.p...</a><p>(Note: That one is kind of a marketing piece, too.)<p>In high-assurance systems, both formal methods and exhaustive testing are supposed to be used. I&#x27;d be curious to see the results of the submitted tech on designs such as the VAMP processor and Rockwell Collins AAMP7G.<p><a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;220643416_Putting_it_all_together_-_Formal_Verification_of_the_VAMP" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;220643416_Putting_i...</a><p><a href="https:&#x2F;&#x2F;www.khoury.northeastern.edu&#x2F;home&#x2F;pete&#x2F;acl206&#x2F;slides&#x2F;hardin.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.khoury.northeastern.edu&#x2F;home&#x2F;pete&#x2F;acl206&#x2F;slides&#x2F;...</a></div><br/><div id="37994254" class="c"><input type="checkbox" id="c-37994254" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37990356">root</a><span>|</span><a href="#37992815">parent</a><span>|</span><a href="#37990527">next</a><span>|</span><label class="collapse" for="c-37994254">[-]</label><label class="expand" for="c-37994254">[1 more]</label></div><br/><div class="children"><div class="content">Exhaustive testing is used? Only in some very special cases that can be done... Take the PMULLD instruction. It takes two 128-bit inputs. If you assume you can verify one input in 1ns. An exhaustive test will take 3.67 × 10^60 years. Orders of magnitude longer then the age of the universe.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>