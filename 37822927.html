<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696928467233" as="style"/><link rel="stylesheet" href="styles.css?v=1696928467233"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.linuxatemyram.com/">Linux ate my RAM (2009)</a> <span class="domain">(<a href="https://www.linuxatemyram.com">www.linuxatemyram.com</a>)</span></div><div class="subtext"><span>StrauXX</span> | <span>170 comments</span></div><br/><div><div id="37825660" class="c"><input type="checkbox" id="c-37825660" checked=""/><div class="controls bullet"><span class="by">gslin</span><span>|</span><a href="#37823517">next</a><span>|</span><label class="collapse" for="c-37825660">[-]</label><label class="expand" for="c-37825660">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.ph&#x2F;WmJHf" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.ph&#x2F;WmJHf</a></div><br/><div id="37826320" class="c"><input type="checkbox" id="c-37826320" checked=""/><div class="controls bullet"><span class="by">neonate</span><span>|</span><a href="#37825660">parent</a><span>|</span><a href="#37823517">next</a><span>|</span><label class="collapse" for="c-37826320">[-]</label><label class="expand" for="c-37826320">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230928045611&#x2F;https:&#x2F;&#x2F;www.linuxatemyram.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230928045611&#x2F;https:&#x2F;&#x2F;www.linux...</a></div><br/></div></div></div></div><div id="37823517" class="c"><input type="checkbox" id="c-37823517" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37825660">prev</a><span>|</span><a href="#37823417">next</a><span>|</span><label class="collapse" for="c-37823517">[-]</label><label class="expand" for="c-37823517">[9 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some really interesting little details here.<p>Linux, by default, is making the very reasonable assumption that the marginal cost of converting empty physical memory into caches and buffers is very near zero. This is fundamentally reasonable, because the cost of converting empty memory into used memory isn&#x27;t really any cheaper than converting a clean cached page into used memory. It&#x27;s a little more subtle when you take accounting into account, or when you think about dirty pages (which need to be written back to clear memory), or think about caches, but the core assumption is a very reasonable one.<p>Except for on some multi-tenant infrastructure. Here, &quot;empty&quot; pages don&#x27;t really exist. There&#x27;s mostly not an empty page of memory kicking around waiting (like there is on client devices). Instead, nearly all the memory on the box is allocated, but each individual guest kernel doesn&#x27;t know the full allocation. In this world, the assumption that the marginal cost of converting empty to full is zero is no longer true. There&#x27;s some real cost.<p>Projects like DAMON <a href="https:&#x2F;&#x2F;sjp38.github.io&#x2F;post&#x2F;damon&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;sjp38.github.io&#x2F;post&#x2F;damon&#x2F;</a> exist to handle this case, and similar cases where keeping empty memory rather than low-value cache is worse for the overall system. These kinds of systems aren&#x27;t super common, especially on the client side, but aren&#x27;t unusual in large-scale cloud services.</div><br/><div id="37823724" class="c"><input type="checkbox" id="c-37823724" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37823517">parent</a><span>|</span><a href="#37824073">next</a><span>|</span><label class="collapse" for="c-37823724">[-]</label><label class="expand" for="c-37823724">[6 more]</label></div><br/><div class="children"><div class="content">The other interesting detail here is the memory sizing problem. If I can consume all my RAM with caches and buffers, how much RAM do I need? The answer (as always) depends on what you&#x27;re optimizing for. For performance, bigger is better. For cost, energy, etc you&#x27;re going to want some way to calculate whether adding more RAM (and so having bigger caches) is worth the cost, heat, power, etc.<p>Gray and Putzolu&#x27;s classic &quot;The 5 minute rule for trading memory for disc accesses&quot; (<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;38713.38755" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;38713.38755</a>) from 1987 is probably one of the most important CS systems papers of all time. In it, they lay out a way of thinking about memory and cache sizing by comparing the cost of holding cache to the cost of access (this isn&#x27;t the first use of that line of thinking, but is a very influential statement of it). Back then, they found that storing 4kB in RAM for 5 minutes costs about the same as reading it back from storage. So if you&#x27;re going to access something again within 5 minutes you should keep it around. The constants have change a lot (RAM is way cheaper, IOs are way cheaper, block sizes are typically bigger) since then, but the logic and way of thinking are largely timeless.<p>The 5 minute rule is a quantitative way of thinking about the size of the working set, an idea that dates back at least to 1968 and Denning&#x27;s &quot;The working set model for program behavior&quot; (<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;363095.363141" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;363095.363141</a>).<p>Back to marginal costs - the marginal cost of converting empty RAM to cache is zero in the minute, but only because the full cost has been borne up front when the machine is purchased. It&#x27;s not zero, just pre-paid.</div><br/><div id="37825249" class="c"><input type="checkbox" id="c-37825249" checked=""/><div class="controls bullet"><span class="by">LeifCarrotson</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37823724">parent</a><span>|</span><a href="#37824082">next</a><span>|</span><label class="collapse" for="c-37825249">[-]</label><label class="expand" for="c-37825249">[2 more]</label></div><br/><div class="children"><div class="content">Huh, never heard of that before. An interesting paper!<p>Running the numbers - assuming 4k record size instead of 1k, ignoring data size changes, ignoring cache, ignoring electricity and rack costs, selecting a $60 Samsung 980 with 4xPCIe and a $95 set of 2x16GB DDR5-6400 DIMMs...I get $0.003&#x2F;disk access&#x2F;second&#x2F;year and $0.0000113 for 4k of RAM, a ratio of 264.<p>That is remarkably close to the original paper&#x27;s ratio of 400, even though their disks only got 15 random reads per second, not 20,000, and cost $15,000, and their memory cost $1000&#x2F;MB not $0.002&#x2F;MB.<p>I&#x27;m not sure the &quot;Spend 10 bytes of memory to save 1 instruction per second&quot; works equally well, especially given that processors are now multi-core pipelined complex beasts, but working naively, you could multiply price, frequency, and core count to calculate ~$0.01&#x2F;MIP (instead of $50k). $0.01 is about the cost of 3 MB of RAM. Dividing both by a million you should spend 3 bytes, not 10 bytes, to save 1 instruction per second.</div><br/><div id="37827034" class="c"><input type="checkbox" id="c-37827034" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37825249">parent</a><span>|</span><a href="#37824082">next</a><span>|</span><label class="collapse" for="c-37827034">[-]</label><label class="expand" for="c-37827034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; $60 Samsung 980<p>If this is a Hetzner machine then yes, but enterprise SSDs costs more, especially from <i>enterprise vendors</i>. But this only drives the storage cost up.<p>More so, if you tend to send some big amount of data every 5 minutes and you are somewhat constrained by memory (32 &#x2F; 1000 x 100 = 3.2%) then it would be easier to just read it from the storage again. If you are not constrained by storage bandwidth, of course.<p>And by the way, the latest gaming consoles (at least PlayStation?) is designed around this concept - they trade having big amount of RAM (which in case of PS5 is shared between GPU and the OS) to just loading assets from the storage extremely fast &#x27;just in time&#x27;. Which works fine for games.</div><br/></div></div></div></div><div id="37824082" class="c"><input type="checkbox" id="c-37824082" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37823724">parent</a><span>|</span><a href="#37825249">prev</a><span>|</span><a href="#37824073">next</a><span>|</span><label class="collapse" for="c-37824082">[-]</label><label class="expand" for="c-37824082">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Back to marginal costs - the marginal cost of converting empty RAM to cache is zero in the minute, but only because the full cost has been borne up front when the machine is purchased. It&#x27;s not zero, just pre-paid. .<p>Or, in other words, you get to fully use what you paid for.</div><br/><div id="37824477" class="c"><input type="checkbox" id="c-37824477" checked=""/><div class="controls bullet"><span class="by">teruakohatu</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37824082">parent</a><span>|</span><a href="#37824073">next</a><span>|</span><label class="collapse" for="c-37824477">[-]</label><label class="expand" for="c-37824477">[2 more]</label></div><br/><div class="children"><div class="content">I think the OPs point was that people tend to buy more RAM than they actually need because they have no idea how much RAM they actually need, because it&#x27;s always used, and so err on the side of caution</div><br/><div id="37826995" class="c"><input type="checkbox" id="c-37826995" checked=""/><div class="controls bullet"><span class="by">Arrath</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37824477">parent</a><span>|</span><a href="#37824073">next</a><span>|</span><label class="collapse" for="c-37826995">[-]</label><label class="expand" for="c-37826995">[1 more]</label></div><br/><div class="children"><div class="content">Well you don&#x27;t have to call me out for running 64gb of ram in my home desktop like that.</div><br/></div></div></div></div></div></div></div></div><div id="37824073" class="c"><input type="checkbox" id="c-37824073" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#37823517">parent</a><span>|</span><a href="#37823724">prev</a><span>|</span><a href="#37823417">next</a><span>|</span><label class="collapse" for="c-37824073">[-]</label><label class="expand" for="c-37824073">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but each individual guest kernel doesn&#x27;t know the full allocation<p>I was under the impression that at least in some virtual machine types the guest kernel is collaborating with the host kernel through vm drivers to avoid this problem.</div><br/><div id="37824291" class="c"><input type="checkbox" id="c-37824291" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37823517">root</a><span>|</span><a href="#37824073">parent</a><span>|</span><a href="#37823417">next</a><span>|</span><label class="collapse" for="c-37824291">[-]</label><label class="expand" for="c-37824291">[1 more]</label></div><br/><div class="children"><div class="content">Well, yeah. But (DAMON and friends aside), Linux doesn&#x27;t handle that non-zero marginal memory cost well today.</div><br/></div></div></div></div></div></div><div id="37823417" class="c"><input type="checkbox" id="c-37823417" checked=""/><div class="controls bullet"><span class="by">jsight</span><span>|</span><a href="#37823517">prev</a><span>|</span><a href="#37823624">next</a><span>|</span><label class="collapse" for="c-37823417">[-]</label><label class="expand" for="c-37823417">[4 more]</label></div><br/><div class="children"><div class="content">I once worked at a government job and took my computer into the IT department for an issue. I can&#x27;t remember anything about the original issue.<p>But I do vividly remember the help desk trying to figure out one last issue. Some process was consuming all my resources.<p>They never could figure out why &quot;System Idle Process&quot; kept doing that.</div><br/><div id="37824643" class="c"><input type="checkbox" id="c-37824643" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#37823417">parent</a><span>|</span><a href="#37827340">next</a><span>|</span><label class="collapse" for="c-37824643">[-]</label><label class="expand" for="c-37824643">[1 more]</label></div><br/><div class="children"><div class="content">A few years ago a similar issue cropped up on macOS where when the device was extremely hot (at least on intel), you&#x27;ll see kernel_task seemingly using a ton of CPU time. What was actually happening is that the kernel was scheduling an idle thread which just put the CPU to sleep in an effort to lower the temperature beyond what it could achieve with fans and DVFS.</div><br/></div></div><div id="37827340" class="c"><input type="checkbox" id="c-37827340" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#37823417">parent</a><span>|</span><a href="#37824643">prev</a><span>|</span><a href="#37823624">next</a><span>|</span><label class="collapse" for="c-37827340">[-]</label><label class="expand" for="c-37827340">[2 more]</label></div><br/><div class="children"><div class="content">Back in the day I was asked why it consumes 2 seconds of CPU Time each second.<p>I couldn&#x27;t answer that at time. Took a bit more years and understanding until I remembered that situation and it was obvious for me.</div><br/><div id="37829673" class="c"><input type="checkbox" id="c-37829673" checked=""/><div class="controls bullet"><span class="by">lynguist</span><span>|</span><a href="#37823417">root</a><span>|</span><a href="#37827340">parent</a><span>|</span><a href="#37823624">next</a><span>|</span><label class="collapse" for="c-37829673">[-]</label><label class="expand" for="c-37829673">[1 more]</label></div><br/><div class="children"><div class="content">What’s the answer? One second user time and one second kernel time? Or something completely different?</div><br/></div></div></div></div></div></div><div id="37823624" class="c"><input type="checkbox" id="c-37823624" checked=""/><div class="controls bullet"><span class="by">kevin_nisbet</span><span>|</span><a href="#37823417">prev</a><span>|</span><a href="#37823887">next</a><span>|</span><label class="collapse" for="c-37823624">[-]</label><label class="expand" for="c-37823624">[1 more]</label></div><br/><div class="children"><div class="content">When I worked in telco we used to run into this a lot.<p>We&#x27;d demand standard alarms for things like memory leaks &#x2F; out of memory conditions &#x2F; high than normal memory usage, as to get 99.999% uptime we want to be paged when problems like this would occur. Except a bunch of platform did the extremely naive implementation and included recoverable memory in their alarm conditions. So inevitably someone would log in and grep the logs or copy some files to the system, and hit the alarm conditions.<p>And there were some vendors who really didn&#x27;t want to fix it, they would argue that recoverable memory is in use, so it should really be part of that alarm condition.</div><br/></div></div><div id="37823887" class="c"><input type="checkbox" id="c-37823887" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#37823624">prev</a><span>|</span><a href="#37824847">next</a><span>|</span><label class="collapse" for="c-37823887">[-]</label><label class="expand" for="c-37823887">[4 more]</label></div><br/><div class="children"><div class="content">I used to run a Linux workstation in the late 00&#x27;s (sorry FreeBSD folks, I know, the shame...), and I ran a closed source PVR application on it.<p>The memory access pattern was pretty much pessimal for my use of the box as a workstation.  I&#x27;d use it from 7am -&gt; 8&#x2F;9pm every day, then when I&#x27;d walk away from the keyboard, I&#x27;d watch HD recordings (which could be 7GB or more per hour).  Those would get cached in memory, and eventually my workstation stuff (emacs, xterms, firefox, thunderbird) would start to get paged out.  In the mornings, it was painful to start using each application, as it waited forever to page in from a spinning disk.<p>I eventually wrote an LD_PRELOAD for the DVR software that overloaded open, and added O_DIRECT (to tell the kernel not to cache the data).  This totally solved my problem, and didn&#x27;t impact my DVR usage at all.</div><br/><div id="37826289" class="c"><input type="checkbox" id="c-37826289" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#37823887">parent</a><span>|</span><a href="#37824847">next</a><span>|</span><label class="collapse" for="c-37826289">[-]</label><label class="expand" for="c-37826289">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I used to run a Linux workstation in the late 00&#x27;s (sorry FreeBSD folks, I know, the shame...), and I ran a closed source PVR application on it.<p>It&#x27;s ok, no shame. But as I understand it, FreeBSD would prefer to throw out (clean) disk cache pages under memory pressure until somewhere around FreeBSD 11 +&#x2F;- 1, where there were a few changes that combined to make things like you described likely to happen. Heavy I&#x2F;O overnight might still have been enough, and I&#x27;m not going to test run an old OS version to check ;)<p>I can&#x27;t find the changes quickly, but IIRC, older FreeBSD didn&#x27;t mark anonymous pages as inactive unless there was heavy memory pressure; when there was mild memory pressure, it would go through the page queue(s) and free clean disk pages and skip other page; only taking action on a second pass if the first pass didn&#x27;t clean enough. This usually meant your program pages would stay in memory, but when you hit memory pressure, there would be a big pause to mark a lot of pages inactive, often too many pages, which would then get faulted back to active...<p>Current FreeBSD marks pages inactive on a more consistent basis, which is nice because when there is memory pressure, chancws are there&#x27;s already classified pages. But it can lead to anonymous pages getting swapped out in favor of disk pages as you described; it&#x27;s all tunable, of course, but it was a kind of weird transition for me. After upgrading the OS, some of my heavy i&#x2F;o machines saw rising swap usage running the same software as before; took a while to figure that out.</div><br/><div id="37828217" class="c"><input type="checkbox" id="c-37828217" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#37823887">root</a><span>|</span><a href="#37826289">parent</a><span>|</span><a href="#37824847">next</a><span>|</span><label class="collapse" for="c-37828217">[-]</label><label class="expand" for="c-37828217">[2 more]</label></div><br/><div class="children"><div class="content">Ran into an issue like this on relatively modern embedded Linux platform. It was a driver bug and it’s been fixed, but here’s the scenario:<p>- heavy disk access because we were writing real-time images to an SSD at about 500MB&#x2F;s<p>- our application was steady-state about 4GB of RAM and we had 32GB available on the platform<p>- the serial port that we received data from was, under the hood, using DMA<p>In certain cases, Linux would completely run out of free pages (28GB of it being used for cache on files we were never going to read again). These were all available pages but just occupied at the exact moment. The serial driver would request a page for DMA when it received an interrupt and being inside an interrupt context would request that page with NOBLOCK. That meant that kmalloc would return NULL instead of giving a page, since it would need to evict one of the cache pages before one was available. The serial driver would then blow up and never retry the DMA transaction.<p>Fun to debug that one!</div><br/><div id="37828553" class="c"><input type="checkbox" id="c-37828553" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#37823887">root</a><span>|</span><a href="#37828217">parent</a><span>|</span><a href="#37824847">next</a><span>|</span><label class="collapse" for="c-37828553">[-]</label><label class="expand" for="c-37828553">[1 more]</label></div><br/><div class="children"><div class="content">DMA pages are fun. Some devices have special needs for DMA buffers, so maybe you&#x27;ve got something ancient that can only use memory under 32-bit, or maybe you have something really ancient that can only use memory under 16 MB; or maybe the disk controller is fine for regular disk access, but administrative commands need to use a limited range. I didn&#x27;t really finish debugging that one, I got close enough and said well --- we can just measure SMART status a lot less frequently on boxes with that controller and called it a day. :)</div><br/></div></div></div></div></div></div></div></div><div id="37824847" class="c"><input type="checkbox" id="c-37824847" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#37823887">prev</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37824847">[-]</label><label class="expand" for="c-37824847">[25 more]</label></div><br/><div class="children"><div class="content">Trust me. If Linux really eats your RAM to the point of reaching an OOM state <i>you will know</i>.<p>(This was of course because of having too many apps relative to my RAM. Not because of disk caching.)<p>The OOM behavior is not pleasant for a desktop system.</div><br/><div id="37826924" class="c"><input type="checkbox" id="c-37826924" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37826063">next</a><span>|</span><label class="collapse" for="c-37826924">[-]</label><label class="expand" for="c-37826924">[2 more]</label></div><br/><div class="children"><div class="content">And this (the OOM behaviour instead of the paging behaviour on linux) is something that can (and should) be criticised. Every time I encountered a situation where I was running out of memory (usually due to some out of control process) the system would become completely unusable. All interactivity is gone, so it was impossible to kill the out of control process (which was typically misconfigured program i started). If the OOM killer started to take action it would almost never kill the process that was gobling up memory like crazy but instead any of the other apps that are necessary to intervene (like e.g. the terminal or the WM). It always seemed incredibly stupid to me.<p>I remember some time back there was discussion about improving the OOM killer, but I don&#x27;t know what came out of it.</div><br/><div id="37828419" class="c"><input type="checkbox" id="c-37828419" checked=""/><div class="controls bullet"><span class="by">Timber-6539</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826924">parent</a><span>|</span><a href="#37826063">next</a><span>|</span><label class="collapse" for="c-37828419">[-]</label><label class="expand" for="c-37828419">[1 more]</label></div><br/><div class="children"><div class="content">This may or may not preserve your desktop and other important applications in an OOM situation. <a href="https:&#x2F;&#x2F;github.com&#x2F;hakavlad&#x2F;prelockd">https:&#x2F;&#x2F;github.com&#x2F;hakavlad&#x2F;prelockd</a><p>I&#x27;ve heard some good results with it and the applications locked in memory is configurable.</div><br/></div></div></div></div><div id="37826063" class="c"><input type="checkbox" id="c-37826063" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37826924">prev</a><span>|</span><a href="#37825918">next</a><span>|</span><label class="collapse" for="c-37826063">[-]</label><label class="expand" for="c-37826063">[5 more]</label></div><br/><div class="children"><div class="content">How does the NT kernel handle OOM situations, compared to Linux? I know it feels a lot smoother and almost like a non problem (it will slow down for a few seconds and get back to normal), but I wonder what goes on behind the scenes and why (if?) Linux has a different approach</div><br/><div id="37826527" class="c"><input type="checkbox" id="c-37826527" checked=""/><div class="controls bullet"><span class="by">hifromwork</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826063">parent</a><span>|</span><a href="#37828552">next</a><span>|</span><label class="collapse" for="c-37826527">[-]</label><label class="expand" for="c-37826527">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the full answer, but on Windows the problem is less significant because of the core memory management decisions that were made.<p>In Linux you get a ton of copy-on-write memory - every fork() (the most basic way of multiprocessing) creates a new process that shares all of its memory with parent. Only when something is written the child process actually gets &quot;its&quot; memory pages.<p>To put that into perspective, imaging you have only one process in your system, and it has a big 4GB buffer of rw memory allocated. So far so good. Then you fork() three times - your overall system memory usage is still roughly 4 GB. And now all four processes (parent and 3 children) overwrite that 4GB buffer to random values. Only at this point your system RAM usage spikes to 16GB.<p>This means, that the thing that actually OOMS may be just &quot;buffer[i] = 1&quot;. It&#x27;s very hard to recover from this situation gracefully, because this is an exceptional situation, and exceptional situations may require more allocations which are already impossible. Now compare that to Windows, where most memory allocations are in predictable moments, like when malloc() is called, and failures can be safely handled at that point.<p>So, in the ideal situation, Windows running out of memory will just stop giving new memory to processes and every malloc will fail. In Linux it&#x27;s not an option, since every write to a memory location can suddenly cause allocation due to copy on write.</div><br/><div id="37826859" class="c"><input type="checkbox" id="c-37826859" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826527">parent</a><span>|</span><a href="#37828552">next</a><span>|</span><label class="collapse" for="c-37826859">[-]</label><label class="expand" for="c-37826859">[2 more]</label></div><br/><div class="children"><div class="content">Which can lead to dozens of unrelated applications dying on windows when they assume infallible allocators while linux keeps going (sluggishly) until it has to kill just the biggest one.</div><br/><div id="37829545" class="c"><input type="checkbox" id="c-37829545" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826859">parent</a><span>|</span><a href="#37828552">next</a><span>|</span><label class="collapse" for="c-37829545">[-]</label><label class="expand" for="c-37829545">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on memory constrained Windows VMs. The problem shows up as the application you&#x27;re on dying, because guess what, you&#x27;re trying to allocate memory that isn&#x27;t there.<p>The rest of the system is still usable.<p>It&#x27;s fine.<p>For the longest time I also ran with no swap on Windows (and just an excessive amount of memory). I&#x27;d notice when I&#x27;d run out of memory when a particularly hungry application like Affinity Photo died and I had a zillion browser tabs open, but again, the system is perfectly responsive and fine.<p>The Windows behavior seems much closer to deterministic and much more sane than the OOM killer of Linux.</div><br/></div></div></div></div></div></div><div id="37828552" class="c"><input type="checkbox" id="c-37828552" checked=""/><div class="controls bullet"><span class="by">ValdikSS</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826063">parent</a><span>|</span><a href="#37826527">prev</a><span>|</span><a href="#37825918">next</a><span>|</span><label class="collapse" for="c-37828552">[-]</label><label class="expand" for="c-37828552">[1 more]</label></div><br/><div class="children"><div class="content">Linux swapper used to be very aggressive on file cache, evicting it to the point that for the next second you&#x27;ll need all of these libraries again. That is the main reason of the slowdowns.<p>Fortunately now we have MGLRU patchset, which &quot;freezes&quot; the active file cache for a desired amount of milliseconds, and in general is much smarter algo.</div><br/></div></div></div></div><div id="37825918" class="c"><input type="checkbox" id="c-37825918" checked=""/><div class="controls bullet"><span class="by">mnd999</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37826063">prev</a><span>|</span><a href="#37826645">next</a><span>|</span><label class="collapse" for="c-37825918">[-]</label><label class="expand" for="c-37825918">[4 more]</label></div><br/><div class="children"><div class="content">Really broken and stupid would be how I would describe it. Typically is just hangs hard with the disk at 100% and if you’re really patient you might be able to get a shell and kill some things over the course of the next 10 minutes.</div><br/><div id="37828535" class="c"><input type="checkbox" id="c-37828535" checked=""/><div class="controls bullet"><span class="by">ValdikSS</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825918">parent</a><span>|</span><a href="#37826163">next</a><span>|</span><label class="collapse" for="c-37828535">[-]</label><label class="expand" for="c-37828535">[1 more]</label></div><br/><div class="children"><div class="content">It has been fixed by MGLRU patchset since kernel 6.1.
Do:<p><pre><code>    cat &gt; &#x2F;etc&#x2F;tmpfiles.d&#x2F;mglru-min-ttl.conf &lt;&lt;EOF
    w-      &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;lru_gen&#x2F;enabled          -       -       -       -       y
    w-      &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;lru_gen&#x2F;min_ttl_ms       -       -       -       -       1000
    EOF
</code></pre>
and reboot.
I&#x27;ve been struggling with this issue, as many others, for years. Now I can run two VMs with 8 GB physical RAM and 5+ GB swapped, and it barely noticeable.<p>More information, although a bit outdated (pre-MGLRU): <a href="https:&#x2F;&#x2F;notes.valdikss.org.ru&#x2F;linux-for-old-pc-from-2007&#x2F;en&#x2F;#Long-standing" rel="nofollow noreferrer">https:&#x2F;&#x2F;notes.valdikss.org.ru&#x2F;linux-for-old-pc-from-2007&#x2F;en&#x2F;...</a> Linux issue%3A poor performance under RAM shortage conditions</div><br/></div></div><div id="37826163" class="c"><input type="checkbox" id="c-37826163" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825918">parent</a><span>|</span><a href="#37828535">prev</a><span>|</span><a href="#37826645">next</a><span>|</span><label class="collapse" for="c-37826163">[-]</label><label class="expand" for="c-37826163">[2 more]</label></div><br/><div class="children"><div class="content">This is why I stopped having swap on my desktop. I prefer a clean death than prolonged agony.</div><br/><div id="37826659" class="c"><input type="checkbox" id="c-37826659" checked=""/><div class="controls bullet"><span class="by">mnw21cam</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826163">parent</a><span>|</span><a href="#37826645">next</a><span>|</span><label class="collapse" for="c-37826659">[-]</label><label class="expand" for="c-37826659">[1 more]</label></div><br/><div class="children"><div class="content">Having no swap was no panacea, because all of the code sections of your running programs that are memory-mapped in effectively count as &quot;available&quot; clean pages that can be evicted when memory is tight, and they&#x27;ll cause thrashing just as much as swap would. The solution is to OOM-kill processes before that happens.</div><br/></div></div></div></div></div></div><div id="37826645" class="c"><input type="checkbox" id="c-37826645" checked=""/><div class="controls bullet"><span class="by">mnw21cam</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37825918">prev</a><span>|</span><a href="#37826757">next</a><span>|</span><label class="collapse" for="c-37826645">[-]</label><label class="expand" for="c-37826645">[1 more]</label></div><br/><div class="children"><div class="content">The main problem with Linux OOM behaviour is exactly because of what counts as &quot;available&quot; memory. In essence, when the system is really low on memory, it will evict all the pages that are &quot;available&quot;, which includes all those pages that are clean and can be loaded in from disc, which of course includes all the memory-mapped code segments in all of your running software. Because of that, this makes the system really run at a crawl because every little bit of progress involves loading in a page of code before running it. Recent versions are a lot better, but certainly ten years ago on systems with a very large amount of memory this could cause the system to become basically completely unresponsive. The solution was to get the OOM killer to start taking action a lot earlier, so that it never reached the point of being so low on memory that it would thrash like that. There is a program called early_oom that helped with that.</div><br/></div></div><div id="37826757" class="c"><input type="checkbox" id="c-37826757" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37826645">prev</a><span>|</span><a href="#37825694">next</a><span>|</span><label class="collapse" for="c-37826757">[-]</label><label class="expand" for="c-37826757">[2 more]</label></div><br/><div class="children"><div class="content">Over the last few years there has been ongoing work to improve this. Including improved pressure detection, multi-generational LRU, large huge page swap and a bunch of other things. Some aren&#x27;t enabled by default, some need userspace daemons to make use of them.<p>So out-of-the-box experience of some random distro is not necessarily the best you can get, especially on older kernels.</div><br/><div id="37828317" class="c"><input type="checkbox" id="c-37828317" checked=""/><div class="controls bullet"><span class="by">foresto</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826757">parent</a><span>|</span><a href="#37825694">next</a><span>|</span><label class="collapse" for="c-37828317">[-]</label><label class="expand" for="c-37828317">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there has been ongoing work to improve this. Including improved pressure detection,<p>Are you referring to the &#x2F;proc&#x2F;pressure interface?<p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;Documentation&#x2F;accounting&#x2F;psi.rst" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div></div></div><div id="37825694" class="c"><input type="checkbox" id="c-37825694" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37826757">prev</a><span>|</span><a href="#37825411">next</a><span>|</span><label class="collapse" for="c-37825694">[-]</label><label class="expand" for="c-37825694">[2 more]</label></div><br/><div class="children"><div class="content">Its interesting how much <i>stuff</i> we have in Linux now to make OOM decisions (even userland daemons) yet on every modern distribution it still ends up killing your desktop environment instead of the fricking C++ compiler jobs that caused the problem in the first place.</div><br/><div id="37827411" class="c"><input type="checkbox" id="c-37827411" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825694">parent</a><span>|</span><a href="#37825411">next</a><span>|</span><label class="collapse" for="c-37827411">[-]</label><label class="expand" for="c-37827411">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Out of memory: kill process 12345
    Killed process 12345 (sshd)
</code></pre>
is the funniest and ugliest message to see on the iLO&#x2F;VM console.</div><br/></div></div></div></div><div id="37825411" class="c"><input type="checkbox" id="c-37825411" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#37824847">parent</a><span>|</span><a href="#37825694">prev</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37825411">[-]</label><label class="expand" for="c-37825411">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never encountered this with &quot;many apps&quot; starting to OOM, but many times with one process OOMing. That one will simply crash and everything else continues to run unharmed.</div><br/><div id="37825883" class="c"><input type="checkbox" id="c-37825883" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825411">parent</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37825883">[-]</label><label class="expand" for="c-37825883">[7 more]</label></div><br/><div class="children"><div class="content">What distribution are you using?<p>IME, if a process grows out of control, Linux won&#x27;t notice until the whole system is thrashing, at which point it&#x27;s too late and it tries killing random things like browser tabs way before the offending process.<p>In rare cases Linux might recover, but only because I  hammered C-c the right place 30 minutes ago. In most cases a hard reboot is required (I left it overnight once, fans spinning at max, hoping the kernel would eventually accept my plea for help, but she had other priorities).</div><br/><div id="37829557" class="c"><input type="checkbox" id="c-37829557" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825883">parent</a><span>|</span><a href="#37826273">next</a><span>|</span><label class="collapse" for="c-37829557">[-]</label><label class="expand" for="c-37829557">[1 more]</label></div><br/><div class="children"><div class="content">Ubuntu.<p>I&#x27;m guessing you are referring to &quot;swapping&quot;, though?<p>If it&#x27;s just one user process, it&#x27;ll be killed by the OOM killer¹. That application will just be gone: poof. And for the rest you&#x27;ll probably not notice anything, not even a hiccup in your Bluetooth headphones.<p>If it&#x27;s many services, or services that are excempt from that killer, your system might start swapping. Which, indeed, leads to the case you describe.<p>¹<a href="https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;153585&#x2F;how-does-the-oom-killer-decide-which-process-to-kill-first" rel="nofollow noreferrer">https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;153585&#x2F;how-does-the...</a></div><br/></div></div><div id="37826273" class="c"><input type="checkbox" id="c-37826273" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37825883">parent</a><span>|</span><a href="#37829557">prev</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37826273">[-]</label><label class="expand" for="c-37826273">[5 more]</label></div><br/><div class="children"><div class="content">I guess OOM is more problematic on low-memory systems or when you have more than a nominal amount of swap.<p>If you have enough memory that the desktop environment, browsers, and other processes that should keep running only use a small fraction of it, the OOM killer can pick a reasonable target reliably. A process that tries to allocate too much memory gets killed, and everything is robust and deterministic. I sometimes trigger OOM several times in an hour, for example when trying to find reasonable computational parameters for something.</div><br/><div id="37826683" class="c"><input type="checkbox" id="c-37826683" checked=""/><div class="controls bullet"><span class="by">mnw21cam</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826273">parent</a><span>|</span><a href="#37826431">next</a><span>|</span><label class="collapse" for="c-37826683">[-]</label><label class="expand" for="c-37826683">[2 more]</label></div><br/><div class="children"><div class="content">On the contrary, it&#x27;s worse on systems with lots of memory, because those are the systems that are trying to do more.<p>About 8 years ago I got a work machine with 384GB of RAM, and I installed early_oom on it to make the OOM killer work a whole load earlier, otherwise the system would just become completely unresponsive for hours if one of my students&#x2F;colleagues accidentally ran something that would make it run out of RAM.</div><br/><div id="37826942" class="c"><input type="checkbox" id="c-37826942" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826683">parent</a><span>|</span><a href="#37826431">next</a><span>|</span><label class="collapse" for="c-37826942">[-]</label><label class="expand" for="c-37826942">[1 more]</label></div><br/><div class="children"><div class="content">Linux provably got better because i&#x27;ve got a 200GB multi user machine where oom kills (on a stock debian 12) are largely uneventful.</div><br/></div></div></div></div><div id="37826431" class="c"><input type="checkbox" id="c-37826431" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826273">parent</a><span>|</span><a href="#37826683">prev</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37826431">[-]</label><label class="expand" for="c-37826431">[2 more]</label></div><br/><div class="children"><div class="content">How much memory do you think is reasonable? I&#x27;ve had it happen to me with 16GB and even 32GB, where I never ever have this issue on Windows (unless for some reason I&#x27;m on a 2GB RAM system for God knows why). I wish people would stop defending pathological behavior that&#x27;s broken for standard desktop use. What&#x27;s wrong with wanting things to improve?</div><br/><div id="37826688" class="c"><input type="checkbox" id="c-37826688" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#37824847">root</a><span>|</span><a href="#37826431">parent</a><span>|</span><a href="#37823328">next</a><span>|</span><label class="collapse" for="c-37826688">[-]</label><label class="expand" for="c-37826688">[1 more]</label></div><br/><div class="children"><div class="content">Nobody was defending anything. I just told that I don&#x27;t remember having any issues with the Linux OOM killer, and guessed a potential reason.<p>I haven&#x27;t really used any Windows version later than 2000 for anything except gaming, so I don&#x27;t know how things work there these days. I mostly use macOS and Linux, and I&#x27;ve had far more trouble with pathological memory management behavior in macOS. Basically, macOS lets individual processes allocate and use far more memory than is physically available. When I&#x27;m running something with unpredictable memory requirements, I have to babysit the computer and kill the process manually if necessary, or the system may become slow and poorly responsive.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37823328" class="c"><input type="checkbox" id="c-37823328" checked=""/><div class="controls bullet"><span class="by">julienpalard</span><span>|</span><a href="#37824847">prev</a><span>|</span><a href="#37823420">next</a><span>|</span><label class="collapse" for="c-37823328">[-]</label><label class="expand" for="c-37823328">[13 more]</label></div><br/><div class="children"><div class="content">My advice in the situation when someone wants to &quot;free RAM&quot;: &quot;You bought it, better use it.&quot;<p>It always felt strange that people buy lots of RAM but want it to be kept unused...</div><br/><div id="37823859" class="c"><input type="checkbox" id="c-37823859" checked=""/><div class="controls bullet"><span class="by">jabroni_salad</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37823932">next</a><span>|</span><label class="collapse" for="c-37823859">[-]</label><label class="expand" for="c-37823859">[2 more]</label></div><br/><div class="children"><div class="content">Back when I played WoW I would occasionally run into issues with windows trying to put the game into memory compression, as opposed to basically any other process. It turned the game into a powerpoint.<p>You could either get freaky with process explorer, or just keep some overhead so the system wouldn&#x27;t try to do that. When I asked my guildies, they told me the &#x27;default&#x27; for gaming is 16GB now, I was on 8 at the time.<p>Pretty much every gamer will at some point tab out to process manager to see wtf the computer is trying to do and exactly zero of them will think to themselves &quot;I&#x27;m so glad there is no wasted memory!&quot;</div><br/><div id="37825065" class="c"><input type="checkbox" id="c-37825065" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#37823328">root</a><span>|</span><a href="#37823859">parent</a><span>|</span><a href="#37823932">next</a><span>|</span><label class="collapse" for="c-37825065">[-]</label><label class="expand" for="c-37825065">[1 more]</label></div><br/><div class="children"><div class="content">For the 3rd paragraph, specifically: That&#x27;s a fault with Windows not being clear enough with what is actually being in use, and what may be used and already there for a myriad of reasons.<p>(edit: specified my intent on the reply)</div><br/></div></div></div></div><div id="37823932" class="c"><input type="checkbox" id="c-37823932" checked=""/><div class="controls bullet"><span class="by">jstarfish</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37823859">prev</a><span>|</span><a href="#37829522">next</a><span>|</span><label class="collapse" for="c-37823932">[-]</label><label class="expand" for="c-37823932">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s there for when you need to do something requiring that much memory.<p>Your approach is like buying a giant house, becoming a hoarder, and trying to throw a party.</div><br/><div id="37829376" class="c"><input type="checkbox" id="c-37829376" checked=""/><div class="controls bullet"><span class="by">OrderlyTiamat</span><span>|</span><a href="#37823328">root</a><span>|</span><a href="#37823932">parent</a><span>|</span><a href="#37824153">next</a><span>|</span><label class="collapse" for="c-37829376">[-]</label><label class="expand" for="c-37829376">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 
Your approach is like buying a giant house, becoming a hoarder, and trying to throw a party.<p>exactly, excepting that the items they&#x27;re hoarding are occasionally very useful for making their day to day activities go faster. <i>And</i> the hoarder has the superpower that in the blink of an eye they can discard everything that&#x27;s hoarded to make room for the party.<p>Wait it isn&#x27;t quite like a normal hoarder at all come to think of it!</div><br/></div></div></div></div><div id="37829522" class="c"><input type="checkbox" id="c-37829522" checked=""/><div class="controls bullet"><span class="by">sznio</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37823932">prev</a><span>|</span><a href="#37823426">next</a><span>|</span><label class="collapse" for="c-37829522">[-]</label><label class="expand" for="c-37829522">[1 more]</label></div><br/><div class="children"><div class="content">I just got a 64GB machine. It rarely sees much use, but I did go over 32GB a few times.<p>Could&#x27;ve done away with less but I still have PTSD from all my applications crashing after I started Teams on my 16GB machine. On another note: Upgrading from i5-2500k to R7-5800X doesn&#x27;t make Teams faster in any way.</div><br/></div></div><div id="37823426" class="c"><input type="checkbox" id="c-37823426" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37829522">prev</a><span>|</span><a href="#37823411">next</a><span>|</span><label class="collapse" for="c-37823426">[-]</label><label class="expand" for="c-37823426">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that they think they are reaching their system&#x27;s capacity.</div><br/></div></div><div id="37823411" class="c"><input type="checkbox" id="c-37823411" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37823426">prev</a><span>|</span><a href="#37826691">next</a><span>|</span><label class="collapse" for="c-37823411">[-]</label><label class="expand" for="c-37823411">[4 more]</label></div><br/><div class="children"><div class="content">Well, usually you want to free it so you can use it for something else without hitting swap. At least that&#x27;s my use case</div><br/><div id="37824001" class="c"><input type="checkbox" id="c-37824001" checked=""/><div class="controls bullet"><span class="by">lstodd</span><span>|</span><a href="#37823328">root</a><span>|</span><a href="#37823411">parent</a><span>|</span><a href="#37826691">next</a><span>|</span><label class="collapse" for="c-37824001">[-]</label><label class="expand" for="c-37824001">[3 more]</label></div><br/><div class="children"><div class="content">The whole point is that pagecache does not cause any swap hits.<p>Oh my god, it&#x27;s 2023 and we&#x27;re still discussing this idea from 1970s.<p>Is that so hard to grasp? No, stuff gets evicted from the cache long before you hit the swap, which is by the way measured by page swap-out&#x2F;in rate and not by how much swap space is used, which is by itself a totally useless metric.</div><br/><div id="37825463" class="c"><input type="checkbox" id="c-37825463" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37823328">root</a><span>|</span><a href="#37824001">parent</a><span>|</span><a href="#37826691">next</a><span>|</span><label class="collapse" for="c-37825463">[-]</label><label class="expand" for="c-37825463">[2 more]</label></div><br/><div class="children"><div class="content">&gt; stuff gets evicted from the cache long before you hit the swap<p>No...?<p>I&#x27;m looking at a machine right now that has 3.7GB not swapped out and 1.2GB swapped out.  Meanwhile the page cache has 26GB in it.<p>Swapping can happen regardless of how big your page cache is.  And how much you want swap to be used depends on use case.  Sometimes you want to tune it up or down.  In general the system will be good about dropping cache first, but it&#x27;s not a guarantee.<p>&gt; measured by page swap-out&#x2F;in rate and not by how much swap space is used<p>Eh?  I mean, the data got there somewhere.  The rate was nonzero at some point despite a huge page cache.<p>And usually when you want to specifically talk about the swap-out&#x2F;in rate being too high, the term is &quot;thrashing&quot;.</div><br/><div id="37827422" class="c"><input type="checkbox" id="c-37827422" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37823328">root</a><span>|</span><a href="#37825463">parent</a><span>|</span><a href="#37826691">next</a><span>|</span><label class="collapse" for="c-37827422">[-]</label><label class="expand" for="c-37827422">[1 more]</label></div><br/><div class="children"><div class="content">cached disk pages are not going to be swapped out, they&#x27;re just freed (because these pages are already &quot;out&quot; in the same place swapland is)<p>if your cached disk pages keep getting hit and are &quot;recent&quot;, they&#x27;re going to stay in, and your old untouched working pages are going to be swapped out, to make room either for new working pages because you&#x27;ve just loaded new programs or data, or to make room for more disk pages to be cached because your page cache accesses are &quot;busier&quot; than some of your working pages.<p>you will swap out pages to make room for disk cache, but your cached disk pages will never be swapped out, they are just tossed (of course, after any dirty pages are written)</div><br/></div></div></div></div></div></div></div></div><div id="37826691" class="c"><input type="checkbox" id="c-37826691" checked=""/><div class="controls bullet"><span class="by">throwaway092323</span><span>|</span><a href="#37823328">parent</a><span>|</span><a href="#37823411">prev</a><span>|</span><a href="#37823420">next</a><span>|</span><label class="collapse" for="c-37826691">[-]</label><label class="expand" for="c-37826691">[1 more]</label></div><br/><div class="children"><div class="content">Just because it&#x27;s there, doesn&#x27;t mean I want the same programs to use more.</div><br/></div></div></div></div><div id="37823420" class="c"><input type="checkbox" id="c-37823420" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823328">prev</a><span>|</span><a href="#37823810">next</a><span>|</span><label class="collapse" for="c-37823420">[-]</label><label class="expand" for="c-37823420">[33 more]</label></div><br/><div class="children"><div class="content">RAM isn&#x27;t user friendly in Linux. Ubuntu Desktop is the most popular distro by far by Google Trends, but it doesn&#x27;t even come with RAM compression set up out of the box, so as soon as you run out of memory the UI totally locks up until the task killer kills a process, which always takes minutes in my experience. Pop OS does come with RAM compression set up, which is Ubuntu based, but then you&#x27;re stuck on xorg instead of Wayland right now, because they decided to make their own DE from scratch in Rust for some strange reason, which isn&#x27;t available yet. You can set up RAM compression yourself, but when macOS and Windows both have it standard, coming to Linux as a newbie so you install Ubuntu Desktop and your whole system locks up as soon as you run out of physical RAM, it&#x27;s really odd and unexpected. I&#x27;m not even sure who would want to run a desktop distro without RAM compression.</div><br/><div id="37823644" class="c"><input type="checkbox" id="c-37823644" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#37823420">parent</a><span>|</span><a href="#37823505">next</a><span>|</span><label class="collapse" for="c-37823644">[-]</label><label class="expand" for="c-37823644">[9 more]</label></div><br/><div class="children"><div class="content">RAM compression is not magic.<p>It does allow you to save RAM and might prevent you from hitting swap for a while longer, but it won&#x27;t save you if your working set is just too large and&#x2F;or difficult to compress. Apps like web browsers with multiple tabs open might be easier to compress, a game with multiple different assets that are already in a variety of compressed formats, less so.<p>The Linux Kernel also has a bunch of optimizations (Kernel same-page merging, for example, among others) that do not require compression(although you could argue that same-page merging _is_ a form of compression).<p>The system is not supposed to &#x27;lock up&#x27; when you run out of physical RAM. If it does, something is wrong. It might become slower as pages are flushed to disk but it shouldn&#x27;t be terrible unless you are really constrained and thrashing. If the Kernel still can&#x27;t allocate memory, you should expect the OOMKiller to start removing processes. It should not just &#x27;lock up&#x27;. Something is wrong.<p>&gt; which always takes minutes in my experience<p>It should not take minutes. Should happen really quickly once thresholds are reached and allocations are attempted. What is probably happening is that the system has not run out of memory just yet but it is very close and is busy thrashing the swap. If this is happening frequently you may need to adjust your settings (vm.overcommit, vm.admin_reserve_kbytes, etc). Or even deploy something like EarlyOOM (<a href="https:&#x2F;&#x2F;github.com&#x2F;rfjakob&#x2F;earlyoom">https:&#x2F;&#x2F;github.com&#x2F;rfjakob&#x2F;earlyoom</a>). Or you might just need more RAM, honestly.<p>I have always found Linux to behave far more gracefully than Windows (OSX is debatable) in low memory conditions, and relatively easy to tune. Windows is a swapping psycho and there&#x27;s little you can do. OSX mostly does the right thing, until it doesn&#x27;t.</div><br/><div id="37829566" class="c"><input type="checkbox" id="c-37829566" checked=""/><div class="controls bullet"><span class="by">sznio</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37824793">next</a><span>|</span><label class="collapse" for="c-37829566">[-]</label><label class="expand" for="c-37829566">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The system is not supposed to &#x27;lock up&#x27; when you run out of physical RAM. If it does, something is wrong.<p>I&#x27;ve never seen a Linux system not lock up on OOM. At work or at home the instant it starts swapping you might as well restart. Of course it has to kill the SSH daemon rather than the process using 98% of the memory.<p>&gt;I have always found Linux to behave far more gracefully than Windows<p>Windows just gets sluggish for a few seconds. You can even still move the cursor when that happens!</div><br/></div></div><div id="37824793" class="c"><input type="checkbox" id="c-37824793" checked=""/><div class="controls bullet"><span class="by">jowea</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37829566">prev</a><span>|</span><a href="#37823834">next</a><span>|</span><label class="collapse" for="c-37824793">[-]</label><label class="expand" for="c-37824793">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The system is not supposed to &#x27;lock up&#x27; when you run out of physical RAM. If it does, something is wrong. It might become slower as pages are flushed to disk but it shouldn&#x27;t be terrible unless you are really constrained and thrashing. If the Kernel still can&#x27;t allocate memory, you should expect the OOMKiller to start removing processes. It should not just &#x27;lock up&#x27;. Something is wrong.<p>I don&#x27;t why but locking up is my usual experience for Desktop Linux for many years and distros, and I remember seeing at least one article explaining why. The only real solution is calling the OOMKiller early either with a daemon or SysRq.<p>&gt; It should not take minutes. Should happen really quickly once thresholds are reached and allocations are attempted. What is probably happening is that the system has not run out of memory just yet but it is very close and is busy thrashing the swap. If this is happening frequently you may need to adjust your settings (vm.overcommit, vm.admin_reserve_kbytes, etc). Or even deploy something like EarlyOOM (<a href="https:&#x2F;&#x2F;github.com&#x2F;rfjakob&#x2F;earlyoom">https:&#x2F;&#x2F;github.com&#x2F;rfjakob&#x2F;earlyoom</a>). Or you might just need more RAM, honestly.<p>Yeah. Exactly. But as the thread says, why aren&#x27;t those things set up automatically?</div><br/><div id="37825210" class="c"><input type="checkbox" id="c-37825210" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37824793">parent</a><span>|</span><a href="#37823834">next</a><span>|</span><label class="collapse" for="c-37825210">[-]</label><label class="expand" for="c-37825210">[2 more]</label></div><br/><div class="children"><div class="content">As an additional data point, my usual OOM experience on Linux is also a completely frozen system until I get frustrated enough to power cycle the machine.<p>Has anyone transitioned from this being their observed behavior to something more tolerable? What did you change to avoid this problem?</div><br/><div id="37826949" class="c"><input type="checkbox" id="c-37826949" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37825210">parent</a><span>|</span><a href="#37823834">next</a><span>|</span><label class="collapse" for="c-37826949">[-]</label><label class="expand" for="c-37826949">[1 more]</label></div><br/><div class="children"><div class="content">Same here, for me this has been the most annoying issue when running Linux (much less now as I have much more RAM so I don&#x27;t encounter the issue).</div><br/></div></div></div></div></div></div><div id="37823834" class="c"><input type="checkbox" id="c-37823834" checked=""/><div class="controls bullet"><span class="by">MrDrMcCoy</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37824793">prev</a><span>|</span><a href="#37825497">next</a><span>|</span><label class="collapse" for="c-37823834">[-]</label><label class="expand" for="c-37823834">[1 more]</label></div><br/><div class="children"><div class="content">Same page merging only works for KVM, as that&#x27;s the only case that enables it without intervention that nothing else supports. It&#x27;s MADVISE for everything non-KVM, and no applications are compiled with support for telling the kernel &quot;hey, it&#x27;s OK to dedupe me&quot;. The only way to get KSM to work with userspace applications is to use LD_PRELOAD to inject the necessary bits (<a href="https:&#x2F;&#x2F;github.com&#x2F;unbrice&#x2F;ksm_preload">https:&#x2F;&#x2F;github.com&#x2F;unbrice&#x2F;ksm_preload</a>) or to use a custom kernel that has a patch and extra daemon to globally enable KSM for everything (<a href="https:&#x2F;&#x2F;codeberg.org&#x2F;pf-kernel&#x2F;uksmd" rel="nofollow noreferrer">https:&#x2F;&#x2F;codeberg.org&#x2F;pf-kernel&#x2F;uksmd</a>).<p>I really wish this was a standard, configurable sysctl. There are many container environments (and heck, even browsers) that would benefit from this, and I cannot see any real downside.</div><br/></div></div><div id="37825497" class="c"><input type="checkbox" id="c-37825497" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37823834">prev</a><span>|</span><a href="#37823684">next</a><span>|</span><label class="collapse" for="c-37825497">[-]</label><label class="expand" for="c-37825497">[1 more]</label></div><br/><div class="children"><div class="content">OOMKiller jumps into action pretty late. I&#x27;m on Fedora, thus running the systemd-oomd service, but even with this new service the system will lock up for a minute or two before the greedy process is killed.<p>I think with modern browsers, on memory constrained systems (think 4GB of RAM) this is easier to encounter than in the past. As someone who programs in Haskell from time to time I think I&#x27;m more familiar with Linux OOM behavior than most.<p>If someone wants to experience this easily with Haskell just run the following in ghci<p><pre><code>    foldl (+) 1 [1..]</code></pre></div><br/></div></div><div id="37823684" class="c"><input type="checkbox" id="c-37823684" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37825497">prev</a><span>|</span><a href="#37827871">next</a><span>|</span><label class="collapse" for="c-37823684">[-]</label><label class="expand" for="c-37823684">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t say it was magic. System slows down more as you use more RAM compression, so you have time to respond and close some apps. Without it I find I often am working at a thousand miles an hour, not noticing anything amiss, and then suddenly, brick wall, out of memory and I can&#x27;t do anything at all.</div><br/></div></div><div id="37827871" class="c"><input type="checkbox" id="c-37827871" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823644">parent</a><span>|</span><a href="#37823684">prev</a><span>|</span><a href="#37823505">next</a><span>|</span><label class="collapse" for="c-37827871">[-]</label><label class="expand" for="c-37827871">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Apps like web browsers with multiple tabs open might be easier to compress<p>Unfortunately harder than it looks; if you compress the JS heap the garbage collector may decompress it again when scanning for references.</div><br/></div></div></div></div><div id="37823505" class="c"><input type="checkbox" id="c-37823505" checked=""/><div class="controls bullet"><span class="by">ihattendorf</span><span>|</span><a href="#37823420">parent</a><span>|</span><a href="#37823644">prev</a><span>|</span><a href="#37823501">next</a><span>|</span><label class="collapse" for="c-37823505">[-]</label><label class="expand" for="c-37823505">[12 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how RAM compression helps address the machine locking up when it&#x27;ll still lock up when the compressed RAM is used up. It just buys you a little more time.<p>Also, Fedora has had zram enabled by default for a few years now along with systemd-oomd (which can sometimes be too aggressive at killing processes in its default configuration, but is configurable).</div><br/><div id="37823639" class="c"><input type="checkbox" id="c-37823639" checked=""/><div class="controls bullet"><span class="by">mxmlnkn</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823505">parent</a><span>|</span><a href="#37823654">next</a><span>|</span><label class="collapse" for="c-37823639">[-]</label><label class="expand" for="c-37823639">[5 more]</label></div><br/><div class="children"><div class="content">systemd-oomd is also default since Ubuntu 22.04. I remember it vividly because it effectively kept killing X when RAM filled up instead of sanely killing the process that last filled up the RAM, which is either gcc or firefox in my case. Absolutely user-unfriendly default configuration. I removed it and reinstalled earlyoom, which I have been using for years with a suitable configuration. I can only concur, RAM behavior isn&#x27;t user-friendly on Ubuntu.</div><br/><div id="37824787" class="c"><input type="checkbox" id="c-37824787" checked=""/><div class="controls bullet"><span class="by">pxtail</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823639">parent</a><span>|</span><a href="#37825522">next</a><span>|</span><label class="collapse" for="c-37824787">[-]</label><label class="expand" for="c-37824787">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for mentioning earlyoom - I&#x27;ll install and try it because current behavior of total, complete lockup without ability to do anything besides reset with the hardware button infuriates me unbelievably.
I really don&#x27;t comprehend how something like this is possible 
and default behavior in 2023 in OS marketed as &#x27;desktop&#x27; and &#x27;casual&#x2F;user friendly&#x27;</div><br/></div></div><div id="37825522" class="c"><input type="checkbox" id="c-37825522" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823639">parent</a><span>|</span><a href="#37824787">prev</a><span>|</span><a href="#37823998">next</a><span>|</span><label class="collapse" for="c-37825522">[-]</label><label class="expand" for="c-37825522">[1 more]</label></div><br/><div class="children"><div class="content">Had the same experience in the past with systemd-oomd, nowadays it does a better job at killing greedy processes than the entire user slice&#x2F;scope.</div><br/></div></div><div id="37823998" class="c"><input type="checkbox" id="c-37823998" checked=""/><div class="controls bullet"><span class="by">konstantinua00</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823639">parent</a><span>|</span><a href="#37825522">prev</a><span>|</span><a href="#37823654">next</a><span>|</span><label class="collapse" for="c-37823998">[-]</label><label class="expand" for="c-37823998">[2 more]</label></div><br/><div class="children"><div class="content">I second the earlyoom recomendation<p>it&#x27;s a lifesaver</div><br/><div id="37824467" class="c"><input type="checkbox" id="c-37824467" checked=""/><div class="controls bullet"><span class="by">khimaros</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823998">parent</a><span>|</span><a href="#37823654">next</a><span>|</span><label class="collapse" for="c-37824467">[-]</label><label class="expand" for="c-37824467">[1 more]</label></div><br/><div class="children"><div class="content">personally, i run my systems without swap, and kernel OOM behavior has been adequate.</div><br/></div></div></div></div></div></div><div id="37823654" class="c"><input type="checkbox" id="c-37823654" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823505">parent</a><span>|</span><a href="#37823639">prev</a><span>|</span><a href="#37823559">next</a><span>|</span><label class="collapse" for="c-37823654">[-]</label><label class="expand" for="c-37823654">[5 more]</label></div><br/><div class="children"><div class="content">Because it slows down as you use more RAM compression, so you have time to respond and close some apps. Without it you are working at a thousand miles an hour and then suddenly, brick wall.</div><br/><div id="37824436" class="c"><input type="checkbox" id="c-37824436" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823654">parent</a><span>|</span><a href="#37823777">next</a><span>|</span><label class="collapse" for="c-37824436">[-]</label><label class="expand" for="c-37824436">[2 more]</label></div><br/><div class="children"><div class="content">Ah yes, the old, &quot;you should enable swap so that when your RAM fills up, you know about it when the disk starts thrashing and all I&#x2F;O grinds to a near-halt.&quot;<p>I mean, swap is useful, but that&#x27;s not what it&#x27;s for. Same is true for compressed RAM. If you want an alert for low available RAM, it seems like it would be better to write a script for that.</div><br/><div id="37825941" class="c"><input type="checkbox" id="c-37825941" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37824436">parent</a><span>|</span><a href="#37823777">next</a><span>|</span><label class="collapse" for="c-37825941">[-]</label><label class="expand" for="c-37825941">[1 more]</label></div><br/><div class="children"><div class="content">&gt; disk starts thrashing and all I&#x2F;O grinds to a near-halt<p>Nope, neither of those things happen when zram starts compressing ram. Nothing grinds to a near halt until the compressed RAM space is used up, it just slows down a little bit. Btw, compressed RAM via zram isnt swap, it&#x27;s available as actual ram. It also increases the total amount of ram available. I don&#x27;t think I need to make arguments in favor of ram compression since Windows and macOS both have ram compression by default.</div><br/></div></div></div></div><div id="37823777" class="c"><input type="checkbox" id="c-37823777" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823654">parent</a><span>|</span><a href="#37824436">prev</a><span>|</span><a href="#37823559">next</a><span>|</span><label class="collapse" for="c-37823777">[-]</label><label class="expand" for="c-37823777">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Because it slows down as you use more RAM compression,<p>Wait, are you claiming RAM compression uses an adaptive compression factor that compresses more as memory pressure grows?<p>Are you sure that&#x27;s how it works?</div><br/><div id="37823934" class="c"><input type="checkbox" id="c-37823934" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823777">parent</a><span>|</span><a href="#37823559">next</a><span>|</span><label class="collapse" for="c-37823934">[-]</label><label class="expand" for="c-37823934">[1 more]</label></div><br/><div class="children"><div class="content">In the case of zram, it reserves a portion of the physical RAM, and when the remaining physical RAM portion runs out, it begins compressing ram into the reserved portion. So the system slows down a bit as this compression starts happening. Nothing really adaptive about it to my knowledge but the result to the user is a noticeable slow down when there is high ram usage, which is a heads-up to me to close some stuff. Without it the system just locks up as soon as physical RAM is exhausted, without any warning, since it&#x27;s fast up until that moment. Hope this makes sense. I&#x27;m not an expert on zram or other Linux RAM compression packages, so can&#x27;t really answer questions about it beyond that.</div><br/></div></div></div></div></div></div><div id="37823559" class="c"><input type="checkbox" id="c-37823559" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823505">parent</a><span>|</span><a href="#37823654">prev</a><span>|</span><a href="#37823501">next</a><span>|</span><label class="collapse" for="c-37823559">[-]</label><label class="expand" for="c-37823559">[1 more]</label></div><br/><div class="children"><div class="content">Yeah you&#x27;d think it would make no difference but in my experience it does help a little. Don&#x27;t ask me why.<p>But yeah even with zram my laptop still hard reboots 80% of the time when it runs out of RAM. No idea how people expect the Linux Desktop to ever be popular when it can&#x27;t even get a basic thing like <i>not randomly rebooting your computer</i> right.</div><br/></div></div></div></div><div id="37823501" class="c"><input type="checkbox" id="c-37823501" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37823420">parent</a><span>|</span><a href="#37823505">prev</a><span>|</span><a href="#37823552">next</a><span>|</span><label class="collapse" for="c-37823501">[-]</label><label class="expand" for="c-37823501">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure what you&#x27;re calling RAM compression is swapping to zram, in which case the answer is that Some people prefer to not swap at all because that will still make things janky in comparison to just killing things when you&#x27;re out of memory. (I would endorse earlyoom for that)</div><br/><div id="37823530" class="c"><input type="checkbox" id="c-37823530" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823501">parent</a><span>|</span><a href="#37823869">next</a><span>|</span><label class="collapse" for="c-37823530">[-]</label><label class="expand" for="c-37823530">[4 more]</label></div><br/><div class="children"><div class="content">I’ve heard this position multiple times, and yet every single benchmark I’ve seen repeated by teams of engineers in multiple contexts fails to replicate this fear. Zswap really is something that should just always be enabled.</div><br/><div id="37825079" class="c"><input type="checkbox" id="c-37825079" checked=""/><div class="controls bullet"><span class="by">dmacvicar</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823530">parent</a><span>|</span><a href="#37823548">next</a><span>|</span><label class="collapse" for="c-37825079">[-]</label><label class="expand" for="c-37825079">[1 more]</label></div><br/><div class="children"><div class="content">For me it solved most of these lockups when using heavy ram apps (Electron, Firefox + Teams, etc) and keeps the system responsive. I am happy with it and plan to keep it enabled. I have no data to validate except that I don&#x27;t remember having to SysRq key + F some app for a long time.</div><br/></div></div><div id="37823548" class="c"><input type="checkbox" id="c-37823548" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823530">parent</a><span>|</span><a href="#37825079">prev</a><span>|</span><a href="#37823869">next</a><span>|</span><label class="collapse" for="c-37823548">[-]</label><label class="expand" for="c-37823548">[2 more]</label></div><br/><div class="children"><div class="content">How would you benchmark that?</div><br/><div id="37824530" class="c"><input type="checkbox" id="c-37824530" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823548">parent</a><span>|</span><a href="#37823869">next</a><span>|</span><label class="collapse" for="c-37824530">[-]</label><label class="expand" for="c-37824530">[1 more]</label></div><br/><div class="children"><div class="content">For example, at Oculus they ran both performance benchmarks in a lab and collected feedback data from field telemetry. Now of course, it’s always possible some performance counter was overlooked &#x2F; the degradation requires a specific workload to show, but the lack of ability to show any evidence of a difference implies that you probably are unlikely to see it given that the detractors were very vocal and engineering at big corps tends to be more stasis driven.<p>I saw this also repeated at Apple (not Zswap since not Linux, but similar idea of compressing pages) and Android.</div><br/></div></div></div></div></div></div><div id="37823869" class="c"><input type="checkbox" id="c-37823869" checked=""/><div class="controls bullet"><span class="by">MrDrMcCoy</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823501">parent</a><span>|</span><a href="#37823530">prev</a><span>|</span><a href="#37823708">next</a><span>|</span><label class="collapse" for="c-37823869">[-]</label><label class="expand" for="c-37823869">[1 more]</label></div><br/><div class="children"><div class="content">In addition to swap on zram, there&#x27;s also zswap. zswap is not quite as good as swap on zram, but almost certainly is better suited to systems that you want to have be able to hibernate.</div><br/></div></div><div id="37823708" class="c"><input type="checkbox" id="c-37823708" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823501">parent</a><span>|</span><a href="#37823869">prev</a><span>|</span><a href="#37823552">next</a><span>|</span><label class="collapse" for="c-37823708">[-]</label><label class="expand" for="c-37823708">[4 more]</label></div><br/><div class="children"><div class="content">My point was that as a new user the default experience is unfriendly and saying that I have to understand the nuance between different ram related packages in order to talk about it is just proving my point.</div><br/><div id="37824825" class="c"><input type="checkbox" id="c-37824825" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37823708">parent</a><span>|</span><a href="#37823552">next</a><span>|</span><label class="collapse" for="c-37824825">[-]</label><label class="expand" for="c-37824825">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying that a new user should need to understand the nuance, I&#x27;m questioning whether your understanding of the underlying problem is accurate. I do agree that it&#x27;s a poor experience for the system to freeze up under excess memory pressure, I just think the correct fix is <i>less</i> swap combined with earlyoom.</div><br/><div id="37828227" class="c"><input type="checkbox" id="c-37828227" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#37823420">root</a><span>|</span><a href="#37824825">parent</a><span>|</span><a href="#37828193">next</a><span>|</span><label class="collapse" for="c-37828227">[-]</label><label class="expand" for="c-37828227">[1 more]</label></div><br/><div class="children"><div class="content">Gah I am <i>so</i> tired of explaining this in this thread: As the system begins running out of memory, it starts using more of the zram. The zram is <i>compressed</i> which uses <i>CPU</i> and slows the system down enough to notice it during which time I notice and begin closing apps. The alternative, without zram, is it&#x27;s super fast right until I run out of memory then bam my whole system locks up. Zram also effectively makes the total available ram larger because zram swap is actually useable whereas swap to disk is so slow the system basically locks up when you start depending on it as if it were ram. Just try it dammit! It takes a few mins to set up and open enough stuff to see the effects.</div><br/></div></div></div></div></div></div></div></div><div id="37823552" class="c"><input type="checkbox" id="c-37823552" checked=""/><div class="controls bullet"><span class="by">olddustytrail</span><span>|</span><a href="#37823420">parent</a><span>|</span><a href="#37823501">prev</a><span>|</span><a href="#37823810">next</a><span>|</span><label class="collapse" for="c-37823552">[-]</label><label class="expand" for="c-37823552">[1 more]</label></div><br/><div class="children"><div class="content">As the other comment says (but kind of hides) install earlyoom and point the config at whatever you reckon is the main culprit. It only needs done once and you can forget about it.<p>Edit: I should add, this is advice for desktops. If it&#x27;s a server either resize or fix your service.</div><br/></div></div></div></div><div id="37823810" class="c"><input type="checkbox" id="c-37823810" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#37823420">prev</a><span>|</span><a href="#37823896">next</a><span>|</span><label class="collapse" for="c-37823810">[-]</label><label class="expand" for="c-37823810">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Disk cache can always be given back to applications immediately<p>This is not true, there is a cost to freeing the cache pages and allocating them to the other program. I have seen some very regressive performance patterns around pages getting thrashed back and forth between programs and the page cache, especially in containers which are memory limited. You throw memory maps into the mix and things can get really bad really fast.</div><br/><div id="37826706" class="c"><input type="checkbox" id="c-37826706" checked=""/><div class="controls bullet"><span class="by">mnw21cam</span><span>|</span><a href="#37823810">parent</a><span>|</span><a href="#37824703">next</a><span>|</span><label class="collapse" for="c-37826706">[-]</label><label class="expand" for="c-37826706">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why Linux does keep a certain amount of RAM actually-free, so that it can hand over some pages immediately. If the amount of actually-free RAM goes below a certain amount, then it will pre-emptively evict a load of cache pages.</div><br/></div></div><div id="37824703" class="c"><input type="checkbox" id="c-37824703" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#37823810">parent</a><span>|</span><a href="#37826706">prev</a><span>|</span><a href="#37823896">next</a><span>|</span><label class="collapse" for="c-37824703">[-]</label><label class="expand" for="c-37824703">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate further?</div><br/></div></div></div></div><div id="37823896" class="c"><input type="checkbox" id="c-37823896" checked=""/><div class="controls bullet"><span class="by">loktarogar</span><span>|</span><a href="#37823810">prev</a><span>|</span><a href="#37823591">next</a><span>|</span><label class="collapse" for="c-37823896">[-]</label><label class="expand" for="c-37823896">[7 more]</label></div><br/><div class="children"><div class="content">This feels like a UX problem. If this is a normal and expected part of linux operation, it should be called out in the {T,G}UI.</div><br/><div id="37824253" class="c"><input type="checkbox" id="c-37824253" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#37823896">parent</a><span>|</span><a href="#37824144">next</a><span>|</span><label class="collapse" for="c-37824253">[-]</label><label class="expand" for="c-37824253">[2 more]</label></div><br/><div class="children"><div class="content">1. You can&#x27;t change `free` output, you&#x27;ll break SO many scripts.<p>2. Most things which report memory usage in a user-friendly way _already_ do this in an obvious way. (Htop shows disk cache in a bar graph, but doesn&#x27;t add it to the &quot;used&quot; counter.)<p>3. Should UX always compensate for some fraction of users&#x27; misunderstanding of how their OS kernel works? Or would it be better for them to ask the question and then be educated by the answer?</div><br/><div id="37824546" class="c"><input type="checkbox" id="c-37824546" checked=""/><div class="controls bullet"><span class="by">loktarogar</span><span>|</span><a href="#37823896">root</a><span>|</span><a href="#37824253">parent</a><span>|</span><a href="#37824144">next</a><span>|</span><label class="collapse" for="c-37824546">[-]</label><label class="expand" for="c-37824546">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Or would it be better for them to ask the question and then be educated by the answer?<p>Good UX makes the question &quot;why is linux using my unused RAM for disk caching&quot; (a non pressing question) instead of &quot;why is linux eating up all my RAM&quot; (panic, stressful question)</div><br/></div></div></div></div><div id="37824144" class="c"><input type="checkbox" id="c-37824144" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#37823896">parent</a><span>|</span><a href="#37824253">prev</a><span>|</span><a href="#37824820">next</a><span>|</span><label class="collapse" for="c-37824144">[-]</label><label class="expand" for="c-37824144">[1 more]</label></div><br/><div class="children"><div class="content">It is. Windows does the same thing, but it&#x27;s a non-issue because task manager makes it look like cached memory is free memory.</div><br/></div></div><div id="37824820" class="c"><input type="checkbox" id="c-37824820" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37823896">parent</a><span>|</span><a href="#37824144">prev</a><span>|</span><a href="#37824117">next</a><span>|</span><label class="collapse" for="c-37824820">[-]</label><label class="expand" for="c-37824820">[2 more]</label></div><br/><div class="children"><div class="content">But it does. <a href="https:&#x2F;&#x2F;files.catbox.moe&#x2F;l9je82.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;files.catbox.moe&#x2F;l9je82.png</a>
orange is the part used by caches</div><br/><div id="37826571" class="c"><input type="checkbox" id="c-37826571" checked=""/><div class="controls bullet"><span class="by">loktarogar</span><span>|</span><a href="#37823896">root</a><span>|</span><a href="#37824820">parent</a><span>|</span><a href="#37824117">next</a><span>|</span><label class="collapse" for="c-37826571">[-]</label><label class="expand" for="c-37826571">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a linux user, so not an observation of experience. Just the existence of this website suggests to me that however it is being done right now could be made clearer somehow.</div><br/></div></div></div></div><div id="37824117" class="c"><input type="checkbox" id="c-37824117" checked=""/><div class="controls bullet"><span class="by">nightfly</span><span>|</span><a href="#37823896">parent</a><span>|</span><a href="#37824820">prev</a><span>|</span><a href="#37823591">next</a><span>|</span><label class="collapse" for="c-37824117">[-]</label><label class="expand" for="c-37824117">[1 more]</label></div><br/><div class="children"><div class="content">htop shows this</div><br/></div></div></div></div><div id="37823591" class="c"><input type="checkbox" id="c-37823591" checked=""/><div class="controls bullet"><span class="by">therealmarv</span><span>|</span><a href="#37823896">prev</a><span>|</span><a href="#37823318">next</a><span>|</span><label class="collapse" for="c-37823591">[-]</label><label class="expand" for="c-37823591">[15 more]</label></div><br/><div class="children"><div class="content">Windows and Mac use compressed RAM for many many years as standard.<p>Yet on many Linux desktop you have to activate it (namely ZRAM). It solves the problem that a e.g. browser eats all your memory. It&#x27;s much quicker than Swap and yet mostly unknown by many people who are running a Linux desktop. As mentioned by another user it&#x27;s still not standard on Ubuntu desktop and I don&#x27;t understand why.</div><br/><div id="37825035" class="c"><input type="checkbox" id="c-37825035" checked=""/><div class="controls bullet"><span class="by">dmacvicar</span><span>|</span><a href="#37823591">parent</a><span>|</span><a href="#37823762">next</a><span>|</span><label class="collapse" for="c-37825035">[-]</label><label class="expand" for="c-37825035">[2 more]</label></div><br/><div class="children"><div class="content">One can also use zswap:
<a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;zswap.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;mm&#x2F;zswap.html</a>
<a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Zswap" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Zswap</a><p>which I find easier to setup. Just enable it and it manages itself. You can still keep swap on disk, but it will act as a buffer in between, trading CPU cycles for potentially reduced swap I&#x2F;O.<p>I think Arch has it enabled by default, but I am not sure about that. I had to enable it manually on Tumbleweed because my rolling install is years old.</div><br/><div id="37826582" class="c"><input type="checkbox" id="c-37826582" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37825035">parent</a><span>|</span><a href="#37823762">next</a><span>|</span><label class="collapse" for="c-37826582">[-]</label><label class="expand" for="c-37826582">[1 more]</label></div><br/><div class="children"><div class="content">Fedora does that on some (but not all) disk&#x2F;ram size combos. IIRC the installer won&#x27;t put swap on nvme unless you tell it to explicitly, and will always set up the smaller of 4g or half of physical memory as zram.</div><br/></div></div></div></div><div id="37823762" class="c"><input type="checkbox" id="c-37823762" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37823591">parent</a><span>|</span><a href="#37825035">prev</a><span>|</span><a href="#37823833">next</a><span>|</span><label class="collapse" for="c-37823762">[-]</label><label class="expand" for="c-37823762">[7 more]</label></div><br/><div class="children"><div class="content">&gt; It solves the problem that a e.g. browser eats all your memory.<p>It doesn&#x27;t solve that. You get a little bit more headroom, but that&#x27;s it. Not much ram is considered compressible anyway. On my Mac I&#x27;m barely reaching 10% of compressed memory anyway, so it doesn&#x27;t make that much difference.</div><br/><div id="37823872" class="c"><input type="checkbox" id="c-37823872" checked=""/><div class="controls bullet"><span class="by">noisem4ker</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37823762">parent</a><span>|</span><a href="#37824771">next</a><span>|</span><label class="collapse" for="c-37823872">[-]</label><label class="expand" for="c-37823872">[1 more]</label></div><br/><div class="children"><div class="content">Current RAM usage from my Windows 10 dev machine, as reported by Task Manager:<p>&gt; In use: 18028 MB<p>&gt; In use, compressed: 2718 MB<p>&gt; Compressed memory stores an estimated 9013 MB of data, saving the system 6294 MB of memory.<p>That&#x27;s not a small amount.</div><br/></div></div><div id="37824771" class="c"><input type="checkbox" id="c-37824771" checked=""/><div class="controls bullet"><span class="by">jowea</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37823762">parent</a><span>|</span><a href="#37823872">prev</a><span>|</span><a href="#37825597">next</a><span>|</span><label class="collapse" for="c-37824771">[-]</label><label class="expand" for="c-37824771">[2 more]</label></div><br/><div class="children"><div class="content">My experience is that zram saves quite a bit. I have another old laptop with 4GB where it&#x27;s essential. Maybe it differs by program type?<p><pre><code>  NAME       ALGORITHM DISKSIZE  DATA  COMPR TOTAL STREAMS MOUNTPOINT
  &#x2F;dev&#x2F;zram0 lzo-rle      15,6G  1,9G 248,6M  418M      16 [SWAP]</code></pre></div><br/><div id="37825288" class="c"><input type="checkbox" id="c-37825288" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37824771">parent</a><span>|</span><a href="#37825597">next</a><span>|</span><label class="collapse" for="c-37825288">[-]</label><label class="expand" for="c-37825288">[1 more]</label></div><br/><div class="children"><div class="content">Yup, it will depend on your workload a lot. Worth testing of course!</div><br/></div></div></div></div><div id="37825597" class="c"><input type="checkbox" id="c-37825597" checked=""/><div class="controls bullet"><span class="by">ltbarcly3</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37823762">parent</a><span>|</span><a href="#37824771">prev</a><span>|</span><a href="#37823833">next</a><span>|</span><label class="collapse" for="c-37825597">[-]</label><label class="expand" for="c-37825597">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Not much ram is considered compressible anyway.<p>What are you basing this on?  Things in RAM are often very very compressible, usually between 3:1 and 4:1.</div><br/><div id="37826437" class="c"><input type="checkbox" id="c-37826437" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37825597">parent</a><span>|</span><a href="#37823833">next</a><span>|</span><label class="collapse" for="c-37826437">[-]</label><label class="expand" for="c-37826437">[2 more]</label></div><br/><div class="children"><div class="content">Depends on what things are in your ram. Code&#x2F;configuration&#x2F;simple data structures compress nicely. Images&#x2F;videos&#x2F;ML-models don&#x27;t.</div><br/><div id="37826957" class="c"><input type="checkbox" id="c-37826957" checked=""/><div class="controls bullet"><span class="by">ltbarcly3</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37826437">parent</a><span>|</span><a href="#37823833">next</a><span>|</span><label class="collapse" for="c-37826957">[-]</label><label class="expand" for="c-37826957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Depends on what things are in your ram.<p>No offense, but you are being a very precise in defense but very broad in your (in general incorrect) claim.<p>The representation of an image sitting in memory will be a bitmap array, and for sure that will compress quite well.  Video data as well but any decompressed frames are so transient I agree they won&#x27;t benefit.  ML-models don&#x27;t compress well, but training data certainly does.<p>If you put aside mapping already compressed or non-compressable data into memory, all the rest of the things ram is used for can be compressed.  Day to day you will have a lot of memory allocated that can be compressed.  Most memory in use right now on most computers is compressible.</div><br/></div></div></div></div></div></div></div></div><div id="37823833" class="c"><input type="checkbox" id="c-37823833" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37823591">parent</a><span>|</span><a href="#37823762">prev</a><span>|</span><a href="#37823646">next</a><span>|</span><label class="collapse" for="c-37823833">[-]</label><label class="expand" for="c-37823833">[4 more]</label></div><br/><div class="children"><div class="content">Compressing data has a cost, right? Modern systems have a ridiculous amount of memory, if you are bumping into that limitation, it seems like something odd is happening.<p>If your web browser is using all your ram, it is probably misconfigured, maybe the ad-blocker has accidentally been turned off or something?</div><br/><div id="37825273" class="c"><input type="checkbox" id="c-37825273" checked=""/><div class="controls bullet"><span class="by">undersuit</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37823833">parent</a><span>|</span><a href="#37825328">next</a><span>|</span><label class="collapse" for="c-37825273">[-]</label><label class="expand" for="c-37825273">[1 more]</label></div><br/><div class="children"><div class="content">I run a Linux system with 2GB of RAM... and Intel integrated graphics, it&#x27;s storage is not exceptionally fast flash. The more pages I can keep compressed in RAM, the less the CPU has to spend waiting on the storage, especially if we&#x27;re talking about the swap partition. After letting that computer run a long time I can tell whats been swapped to disk versus just compressed to zswap.</div><br/></div></div><div id="37825328" class="c"><input type="checkbox" id="c-37825328" checked=""/><div class="controls bullet"><span class="by">colinsane</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37823833">parent</a><span>|</span><a href="#37825273">prev</a><span>|</span><a href="#37823646">next</a><span>|</span><label class="collapse" for="c-37825328">[-]</label><label class="expand" for="c-37825328">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Modern systems have a ridiculous amount of memory<p>well it depends on your definition of modern, i suppose. i run Linux on a smartphone, which is about the most modern use of Linux i can think of, and hitting that 3-4 GB RAM limit is all too easy with anything touching the web, adblocker or not.<p>zram isn&#x27;t exactly a trump card in that kind of environment, but it certainly makes the experience of saturating the RAM a lot nicer (&quot;hm, this application&#x27;s about half as responsive as it usually is. <i>checks ram</i>. oh, better close some apps&#x2F;tabs i don&#x27;t need.&quot; -- versus the default of the system locking for a full minute until the OOMkiller finishes reaping everything under the sun).</div><br/><div id="37828188" class="c"><input type="checkbox" id="c-37828188" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37823591">root</a><span>|</span><a href="#37825328">parent</a><span>|</span><a href="#37823646">next</a><span>|</span><label class="collapse" for="c-37828188">[-]</label><label class="expand" for="c-37828188">[1 more]</label></div><br/><div class="children"><div class="content">How strange, I guess we must use different websites or something.</div><br/></div></div></div></div></div></div><div id="37823646" class="c"><input type="checkbox" id="c-37823646" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#37823591">parent</a><span>|</span><a href="#37823833">prev</a><span>|</span><a href="#37823318">next</a><span>|</span><label class="collapse" for="c-37823646">[-]</label><label class="expand" for="c-37823646">[1 more]</label></div><br/><div class="children"><div class="content">There are distributions that enable it by default, Fedora comes to mind.</div><br/></div></div></div></div><div id="37823318" class="c"><input type="checkbox" id="c-37823318" checked=""/><div class="controls bullet"><span class="by">skazazes</span><span>|</span><a href="#37823591">prev</a><span>|</span><a href="#37827436">next</a><span>|</span><label class="collapse" for="c-37823318">[-]</label><label class="expand" for="c-37823318">[7 more]</label></div><br/><div class="children"><div class="content">Is this the reason Windows Task Manager seems to show Vmmem (WSL2) as gobbling up well more RAM then WSL seems to indicate is in use?<p>I have more then enough RAM on my office workstation to just accept this, but on my personal gaming computer that moonlights as a dev machine, I run into issues and have to kill WSL from time to time.</div><br/><div id="37823444" class="c"><input type="checkbox" id="c-37823444" checked=""/><div class="controls bullet"><span class="by">praash</span><span>|</span><a href="#37823318">parent</a><span>|</span><a href="#37823399">next</a><span>|</span><label class="collapse" for="c-37823444">[-]</label><label class="expand" for="c-37823444">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just one part of the issue - even after forcefully dropping Linux&#x27;s caches, WSL has been unable to reclaim the memory back reliably. There has been a recent update that claims to finally fix this.<p>You might find this package helpful: <a href="https:&#x2F;&#x2F;github.com&#x2F;arkane-systems&#x2F;wsl-drop-cache">https:&#x2F;&#x2F;github.com&#x2F;arkane-systems&#x2F;wsl-drop-cache</a></div><br/><div id="37825393" class="c"><input type="checkbox" id="c-37825393" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37823318">root</a><span>|</span><a href="#37823444">parent</a><span>|</span><a href="#37823399">next</a><span>|</span><label class="collapse" for="c-37825393">[-]</label><label class="expand" for="c-37825393">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also really annoying that &quot;drop caches&quot; seems to be the only interface here.  No way to simply limit it.</div><br/></div></div></div></div><div id="37823399" class="c"><input type="checkbox" id="c-37823399" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#37823318">parent</a><span>|</span><a href="#37823444">prev</a><span>|</span><a href="#37823398">next</a><span>|</span><label class="collapse" for="c-37823399">[-]</label><label class="expand" for="c-37823399">[1 more]</label></div><br/><div class="children"><div class="content">I think there is some conflict between the disk cache running inside WSL and the memory management outside. I tried turning up memory pressure in WSL but it didn&#x27;t help. This does work but I have to run it manually from time to time:<p><pre><code>  # sync; echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</code></pre></div><br/></div></div><div id="37823398" class="c"><input type="checkbox" id="c-37823398" checked=""/><div class="controls bullet"><span class="by">chabad360</span><span>|</span><a href="#37823318">parent</a><span>|</span><a href="#37823399">prev</a><span>|</span><a href="#37823621">next</a><span>|</span><label class="collapse" for="c-37823398">[-]</label><label class="expand" for="c-37823398">[1 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s because WSL (until v2&#x2F;very recently) didn&#x27;t properly release memory back to windows. This actually would cause docker to effectively leak memory really quickly.</div><br/></div></div><div id="37823621" class="c"><input type="checkbox" id="c-37823621" checked=""/><div class="controls bullet"><span class="by">Zetobal</span><span>|</span><a href="#37823318">parent</a><span>|</span><a href="#37823398">prev</a><span>|</span><a href="#37823446">next</a><span>|</span><label class="collapse" for="c-37823621">[-]</label><label class="expand" for="c-37823621">[1 more]</label></div><br/><div class="children"><div class="content">The worst offense of wsl2 is writing files to ram before copying it to the native filesystem unusable with lots of data.</div><br/></div></div></div></div><div id="37827436" class="c"><input type="checkbox" id="c-37827436" checked=""/><div class="controls bullet"><span class="by">lnyng</span><span>|</span><a href="#37823318">prev</a><span>|</span><a href="#37823563">next</a><span>|</span><label class="collapse" for="c-37827436">[-]</label><label class="expand" for="c-37827436">[1 more]</label></div><br/><div class="children"><div class="content">We published this paper &quot;TMO: Transparent Memory Offloading in Datacenters&quot; last year which covers some Linux memory management mechanisms that may be quite useful for providing reasonable estimations to application memory usage.<p>We observed that the real memory footprint for applications depends on many factors: file access pattern, disk IO speed (especially if swap is enabled), ssd vs hdd, application latency sensitivity, etc. Instead of coming up with some overly complicated heuristic, we use the Linux kernel provided memory.pressure [0] metric via cgroup v2. It measures the amount of time spent waiting for memory (page fault etc). Then by slowly reclaiming memory from the application until its memory pressure hits some target (say 0.1%), we can claim that the steady state usage is the actual memory footprint.<p>This may not be useful for PC but could be very useful for data center to track memory regression, and also to harvest disk swap without concerning too much about the cliff effect when the host runs out of memory and suddenly kernel pushes everything to swap space.<p>[0] <a href="https:&#x2F;&#x2F;facebookmicrosites.github.io&#x2F;cgroup2&#x2F;docs&#x2F;pressure-metrics.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;facebookmicrosites.github.io&#x2F;cgroup2&#x2F;docs&#x2F;pressure-m...</a></div><br/></div></div><div id="37823563" class="c"><input type="checkbox" id="c-37823563" checked=""/><div class="controls bullet"><span class="by">bminor13</span><span>|</span><a href="#37827436">prev</a><span>|</span><a href="#37825510">next</a><span>|</span><label class="collapse" for="c-37823563">[-]</label><label class="expand" for="c-37823563">[6 more]</label></div><br/><div class="children"><div class="content">Does anyone happen to have expertise&#x2F;pointers on how ZFS&#x27; ARC interacts with Linux disk caching currently when using ZFS-on-Linux? It seems like the ARC space shows up as &quot;used&quot; despite being in a similar category of &quot;made available if needed&quot; - is that correct?<p>Is data in the ARC double-cached by Linux&#x27;s disk caching mentioned in the post? If so, is it possible to disable this double-caching somehow?</div><br/><div id="37823925" class="c"><input type="checkbox" id="c-37823925" checked=""/><div class="controls bullet"><span class="by">MrDrMcCoy</span><span>|</span><a href="#37823563">parent</a><span>|</span><a href="#37829283">next</a><span>|</span><label class="collapse" for="c-37823925">[-]</label><label class="expand" for="c-37823925">[4 more]</label></div><br/><div class="children"><div class="content">ZFS ARC unfortunately does not integrate with the kernel file cache, so they step on each other a lot. ZFS does watch available system RAM and try to dynamically reduce its usage as memory pressure increases, but I&#x27;ve found its responsiveness for this to be far too slow. This combined with how ARC appears to just be an opaque block of RAM that cannot be reclaimed, I usually just set a hard limit on how big the ARC is allowed to get in the module load arguments and be done with it (at least for systems that are doing more than just storage).</div><br/><div id="37824764" class="c"><input type="checkbox" id="c-37824764" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#37823563">root</a><span>|</span><a href="#37823925">parent</a><span>|</span><a href="#37829283">next</a><span>|</span><label class="collapse" for="c-37824764">[-]</label><label class="expand" for="c-37824764">[3 more]</label></div><br/><div class="children"><div class="content">Is ARC really non-reclaimable on Linux?<p>At least on FreeBSD, there is a kmem_cache_reap() that is called from the core kernel VM system&#x27;s low memory handlers.<p>Looking at the linux code in openzfs, it looks like there is an &quot;spl_kmem_cache_reap_now()&quot; function.  Maybe the problem is the kernel dev&#x27;s anti-ZFS stance, and it can&#x27;t be hooked into the right place (eg, the kernel&#x27;s VM low memory handling code)?</div><br/><div id="37829294" class="c"><input type="checkbox" id="c-37829294" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#37823563">root</a><span>|</span><a href="#37824764">parent</a><span>|</span><a href="#37825905">next</a><span>|</span><label class="collapse" for="c-37829294">[-]</label><label class="expand" for="c-37829294">[1 more]</label></div><br/><div class="children"><div class="content">echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches<p>(Bear in mind that 3 is the most aggressive but other than exporting the pool, it&#x27;s the only way to dump the cache, especially if you boot off ZFS)</div><br/></div></div><div id="37825905" class="c"><input type="checkbox" id="c-37825905" checked=""/><div class="controls bullet"><span class="by">MrDrMcCoy</span><span>|</span><a href="#37823563">root</a><span>|</span><a href="#37824764">parent</a><span>|</span><a href="#37829294">prev</a><span>|</span><a href="#37829283">next</a><span>|</span><label class="collapse" for="c-37825905">[-]</label><label class="expand" for="c-37825905">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s reclaimable, but opaque. The ARC just looks like used RAM rather than file cache, which throws off various means of accounting.</div><br/></div></div></div></div></div></div><div id="37829283" class="c"><input type="checkbox" id="c-37829283" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#37823563">parent</a><span>|</span><a href="#37823925">prev</a><span>|</span><a href="#37825510">next</a><span>|</span><label class="collapse" for="c-37829283">[-]</label><label class="expand" for="c-37829283">[1 more]</label></div><br/><div class="children"><div class="content">ARC is completely separate from FS caches...  if the kernel needs memory, it will tell ZFS to prune the ARC, however it&#x27;s not exactly instantaneous.<p>Newer versions of htop also now have counters for ARC usage (compressed or uncompressed)... but it still shows up as used rather than cache.</div><br/></div></div></div></div><div id="37825510" class="c"><input type="checkbox" id="c-37825510" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#37823563">prev</a><span>|</span><a href="#37824187">next</a><span>|</span><label class="collapse" for="c-37825510">[-]</label><label class="expand" for="c-37825510">[1 more]</label></div><br/><div class="children"><div class="content">I think the information there is valuable because questions about memory usage in Linux keep coming up. The answer: &quot;don&#x27;t worry about it,&quot; is probably a good starting point. The page claims things that are just really misleading, though.<p>&gt; There are no downsides, except for confusing newbies.<p>False. Populating the page cache involves lots of memory copies. It pays off if what&#x27;s written is read back many times; otherwise, it&#x27;s a net loss. It also costs cycles and memory to keep track of all these pages and maintain usage statistics so we know what page should be kept and which can be discarded. Unfortunately, Linux makes quantifying that cost hard, so it is not well understood.<p>&gt; You can&#x27;t disable disk caching. The only reason anyone ever wants to disable disk caching is because they think it takes memory away from their applications, which it doesn&#x27;t!<p>People do want that, and they do turn it off. It&#x27;s probably the number one thing database people do because they want domain-specific caching in userland and use O_DIRECT to bypass the kernel caches altogether. If you don&#x27;t, you end up caching things twice, which is efficient&#x2F;redundant.</div><br/></div></div><div id="37824187" class="c"><input type="checkbox" id="c-37824187" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#37825510">prev</a><span>|</span><a href="#37825517">next</a><span>|</span><label class="collapse" for="c-37824187">[-]</label><label class="expand" for="c-37824187">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If your applications want more memory, they just take back a chunk that the disk cache borrowed. Disk cache can always be given back to applications immediately! You are not low on ram!<p>I&#x27;m running RKE2 on my desktop and it&#x27;ll start killing pods due to low memory pressure, even though the memory was only used for disk caching. I wonder if there is any way to make it stop doing that and instead only start killing pods if it&#x27;s due to &quot;real&quot; low memory pressure.</div><br/><div id="37824736" class="c"><input type="checkbox" id="c-37824736" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#37824187">parent</a><span>|</span><a href="#37824842">next</a><span>|</span><label class="collapse" for="c-37824736">[-]</label><label class="expand" for="c-37824736">[2 more]</label></div><br/><div class="children"><div class="content">Think about it: A processes executable code comes from a file. You will need the size of the executable available as disk cache or the program execution will cause heavy thrashing and I&#x2F;O. So some part of it is &quot;real&quot; memory pressure.</div><br/><div id="37826019" class="c"><input type="checkbox" id="c-37826019" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#37824187">root</a><span>|</span><a href="#37824736">parent</a><span>|</span><a href="#37824842">next</a><span>|</span><label class="collapse" for="c-37826019">[-]</label><label class="expand" for="c-37826019">[1 more]</label></div><br/><div class="children"><div class="content">I also run an nfs server in the same machine, so after a period of heavy nfs use, most of the ram were eaten by the disk cache and rke2&#x2F;kubernetes start having memory pressure taint. After a fresh restart with all pods running, the memory usage is below 10%, so I doubt the disk cache was full with executable files cache.</div><br/></div></div></div></div><div id="37824842" class="c"><input type="checkbox" id="c-37824842" checked=""/><div class="controls bullet"><span class="by">okwhateverdude</span><span>|</span><a href="#37824187">parent</a><span>|</span><a href="#37824736">prev</a><span>|</span><a href="#37825517">next</a><span>|</span><label class="collapse" for="c-37824842">[-]</label><label class="expand" for="c-37824842">[2 more]</label></div><br/><div class="children"><div class="content">Assuming Linux, oddly enough I came across this exact behavior[0] while researching resource management for an on-prem k8s cluster. Take a look at that thread for more info, but TL;DR, you need to actually finesse page cache constraints if you want avoid the behavior. You actually can have really fine grained control over page cache via cgroups v2[1][2] and systemd[3].<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;issues&#x2F;43916">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;issues&#x2F;43916</a><p>[1]: <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;cgroup-v2.html#memory-interface-files" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;cgroup-v2.html#memory-in...</a><p>[2]: <a href="https:&#x2F;&#x2F;biriukov.dev&#x2F;docs&#x2F;page-cache&#x2F;6-cgroup-v2-and-page-cache&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;biriukov.dev&#x2F;docs&#x2F;page-cache&#x2F;6-cgroup-v2-and-page-ca...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.resource-control.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.res...</a></div><br/><div id="37826278" class="c"><input type="checkbox" id="c-37826278" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#37824187">root</a><span>|</span><a href="#37824842">parent</a><span>|</span><a href="#37825517">next</a><span>|</span><label class="collapse" for="c-37826278">[-]</label><label class="expand" for="c-37826278">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the pointers. That&#x27;s a lot of things to learn since I never look into cgroup before. I&#x27;ll see if there is something better there than my current &quot;fix&quot; (periodically run `echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches`).</div><br/></div></div></div></div></div></div><div id="37825517" class="c"><input type="checkbox" id="c-37825517" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#37824187">prev</a><span>|</span><a href="#37824220">next</a><span>|</span><label class="collapse" for="c-37825517">[-]</label><label class="expand" for="c-37825517">[1 more]</label></div><br/><div class="children"><div class="content">I remember that being the case for early versions of Android, people were surprised all their RAM was used, and of course, we could find apps that &quot;freed&quot; the RAM, generally making things worse.<p>And the response was similar: all that &quot;used&quot; RAM can be reclaimed at any time should an app need some, but in the meantime, the system (which is Linux) might as well use it.<p>I think they &quot;fixed&quot; it in later versions. I don&#x27;t know how, but I suspect they just changed the UI to stop people from complaining and downloading counterproductive apps.<p>As usual in these situations, unless you really know what you are doing, let the system do its job, some of the best engineers with good knowledge of the internals have worked on it, you won&#x27;t do better by looking at a single number and downloading random apps. For RAM in particular, because of the way virtual memory works, it is hard to get an idea of what is happening. There are caches, shared memory, mapped files, in-app allocators, etc...</div><br/></div></div><div id="37824220" class="c"><input type="checkbox" id="c-37824220" checked=""/><div class="controls bullet"><span class="by">burnte</span><span>|</span><a href="#37825517">prev</a><span>|</span><a href="#37823886">next</a><span>|</span><label class="collapse" for="c-37824220">[-]</label><label class="expand" for="c-37824220">[2 more]</label></div><br/><div class="children"><div class="content">Unused RAM is wasted RAM. Why people want to see GOBS of empty RAM boggles my mind.</div><br/><div id="37825128" class="c"><input type="checkbox" id="c-37825128" checked=""/><div class="controls bullet"><span class="by">filchermcurr</span><span>|</span><a href="#37824220">parent</a><span>|</span><a href="#37823886">next</a><span>|</span><label class="collapse" for="c-37825128">[-]</label><label class="expand" for="c-37825128">[1 more]</label></div><br/><div class="children"><div class="content">I think the disconnect is not understanding how the RAM is used. If the average user looks and sees all of their RAM in use, they&#x27;re going to think that there&#x27;s no more room for the applications that they want to launch. They don&#x27;t understand that what&#x27;s cached will just get out of the way when the memory is actually needed. So they want to see free RAM, because that means it&#x27;s free for their game or millions of tabs.</div><br/></div></div></div></div><div id="37823886" class="c"><input type="checkbox" id="c-37823886" checked=""/><div class="controls bullet"><span class="by">lxe</span><span>|</span><a href="#37824220">prev</a><span>|</span><a href="#37828430">next</a><span>|</span><label class="collapse" for="c-37823886">[-]</label><label class="expand" for="c-37823886">[2 more]</label></div><br/><div class="children"><div class="content">This made me chase red herrings when debugging oom issues in production. Wish free would just remove the &#x27;free&#x27; column and replaced it with &#x27;available&#x27;.</div><br/><div id="37824683" class="c"><input type="checkbox" id="c-37824683" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#37823886">parent</a><span>|</span><a href="#37828430">next</a><span>|</span><label class="collapse" for="c-37824683">[-]</label><label class="expand" for="c-37824683">[1 more]</label></div><br/><div class="children"><div class="content">This is what we did in pretty much all of our monitoring some time ago. We ripped out most memory graphs except for &quot;Total Memory&quot; and &quot;Available Memory&quot; as well as memory pressure from the PSI metrics. And we placed alerts on available memory growing low, as well as pages being swapped in. Newer kernel opportunistically swap-out idle pages, but that&#x27;s fine as long as you never see the path from disk to memory (swap-in).<p>This has increased the quality of our memory monitoring by a lot.</div><br/></div></div></div></div><div id="37823400" class="c"><input type="checkbox" id="c-37823400" checked=""/><div class="controls bullet"><span class="by">mkhnews</span><span>|</span><a href="#37828430">prev</a><span>|</span><a href="#37824918">next</a><span>|</span><label class="collapse" for="c-37823400">[-]</label><label class="expand" for="c-37823400">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; If applications want more memory, they just take it back from the disk cache.
Q: If there is no swap configured, will a malloc() then take away clean page-cache pages ?  Or does that happen only on page-in ?</div><br/><div id="37823935" class="c"><input type="checkbox" id="c-37823935" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#37823400">parent</a><span>|</span><a href="#37823879">next</a><span>|</span><label class="collapse" for="c-37823935">[-]</label><label class="expand" for="c-37823935">[1 more]</label></div><br/><div class="children"><div class="content">In general, no and it will happen when there is something actually written to the page (which will cause a page fault and the kernel will have to somehow materialize the page). This works the same way regardless of how &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory is configured, the setting only affects how kernel tracks how much memory it is going to need in the future. (Obviously if we talk about malloc() this is a slight over-simplification as most malloc() implementations will write some kind of book-keeping structure and thus dirty some of the allocated pages)<p>Whether swap is available is more or less irrelevant for this behavior. The only thing that swap changes is that kernel is then able to “clean” dirty anonymous pages by writing them out to swap.</div><br/></div></div><div id="37823879" class="c"><input type="checkbox" id="c-37823879" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#37823400">parent</a><span>|</span><a href="#37823935">prev</a><span>|</span><a href="#37824918">next</a><span>|</span><label class="collapse" for="c-37823879">[-]</label><label class="expand" for="c-37823879">[3 more]</label></div><br/><div class="children"><div class="content">malloc will take away from the disk cache.<p>Fwiw without swap there isn&#x27;t really any paging in or out (yes mmapped files technically still can but they are basically a special cased type of swap) so your question is hard to parse in this context. The disk cache is all about using unallocated memory and an allocation will reduce it. Paging is irrelevant here.<p>Btw you should always enable swap. Without it you force all unused but allocated memory to live on physical RAM. Why would you want to do this? There&#x27;s absolutely no benchmarks that show better performance with no swap. In fact it&#x27;s almost always the opposite. Add some swap. Enjoy the performance boost!<p><a href="https:&#x2F;&#x2F;haydenjames.io&#x2F;linux-performance-almost-always-add-swap-space&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;haydenjames.io&#x2F;linux-performance-almost-always-add-s...</a></div><br/><div id="37824067" class="c"><input type="checkbox" id="c-37824067" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#37823400">root</a><span>|</span><a href="#37823879">parent</a><span>|</span><a href="#37824918">next</a><span>|</span><label class="collapse" for="c-37824067">[-]</label><label class="expand" for="c-37824067">[2 more]</label></div><br/><div class="children"><div class="content">I would say that for any modern unix implementation mmaped pages are quite significant, as all the read-only copies of libc code, other shared libraries and various mmaped data files (iconv tables, locales, terminfo, gettext catalogs…) are not exactly small.</div><br/><div id="37824750" class="c"><input type="checkbox" id="c-37824750" checked=""/><div class="controls bullet"><span class="by">robinsonb5</span><span>|</span><a href="#37823400">root</a><span>|</span><a href="#37824067">parent</a><span>|</span><a href="#37824918">next</a><span>|</span><label class="collapse" for="c-37824750">[-]</label><label class="expand" for="c-37824750">[1 more]</label></div><br/><div class="children"><div class="content">Which is why disabling swap in the hopes of preventing the system grinding to a halt on out-of-memory doesn&#x27;t work, and actually makes things worse.</div><br/></div></div></div></div></div></div></div></div><div id="37824918" class="c"><input type="checkbox" id="c-37824918" checked=""/><div class="controls bullet"><span class="by">mkhnews</span><span>|</span><a href="#37823400">prev</a><span>|</span><a href="#37824207">next</a><span>|</span><label class="collapse" for="c-37824918">[-]</label><label class="expand" for="c-37824918">[5 more]</label></div><br/><div class="children"><div class="content">Another question is about containers and memory limits.
Does the page-cache count against my container memory limit ?
And if so, then when I hit that limit from doing many reads, does the page-cache start taking from itself without OOM killer getting involved ?</div><br/><div id="37825078" class="c"><input type="checkbox" id="c-37825078" checked=""/><div class="controls bullet"><span class="by">defer</span><span>|</span><a href="#37824918">parent</a><span>|</span><a href="#37825236">next</a><span>|</span><label class="collapse" for="c-37825078">[-]</label><label class="expand" for="c-37825078">[2 more]</label></div><br/><div class="children"><div class="content">I also want to know this, but in reverse.<p>I build older android (the OS) versions inside docker containers because they have dependencies on older glibc versions.<p>This is a memory-heavy multi-threaded process and the OOM killer will kill build threads, making my build fail. However, there is plenty of available (but not free) memory in the docker host, but apparently not available in the container. If I drop caches on the host periodically, the build generally succeeds.</div><br/><div id="37825269" class="c"><input type="checkbox" id="c-37825269" checked=""/><div class="controls bullet"><span class="by">mkhnews</span><span>|</span><a href="#37824918">root</a><span>|</span><a href="#37825078">parent</a><span>|</span><a href="#37825236">next</a><span>|</span><label class="collapse" for="c-37825269">[-]</label><label class="expand" for="c-37825269">[1 more]</label></div><br/><div class="children"><div class="content">And perhaps k8s is a specific category to consider here.
I&#x27;ve read and thought I&#x27;ve experienced where &#x27;active&#x27; (as opposed to in-active) page-cache does count towards k8s mem limit.</div><br/></div></div></div></div><div id="37825236" class="c"><input type="checkbox" id="c-37825236" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#37824918">parent</a><span>|</span><a href="#37825078">prev</a><span>|</span><a href="#37824993">next</a><span>|</span><label class="collapse" for="c-37825236">[-]</label><label class="expand" for="c-37825236">[1 more]</label></div><br/><div class="children"><div class="content">1. Pages cached by applications are charged to its container for the purpose of memory resource limits.<p>2. IME the kernel takes the container&#x27;s memory limit into account when determining whether to allocate a page for cache. Caching, by itself, won&#x27;t cause the container to exceed a memory limit.</div><br/></div></div></div></div><div id="37824207" class="c"><input type="checkbox" id="c-37824207" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#37824918">prev</a><span>|</span><a href="#37823497">next</a><span>|</span><label class="collapse" for="c-37824207">[-]</label><label class="expand" for="c-37824207">[3 more]</label></div><br/><div class="children"><div class="content">How old is this website? It&#x27;s from a time when a typical computer only had 1.5 G of ram.</div><br/><div id="37824329" class="c"><input type="checkbox" id="c-37824329" checked=""/><div class="controls bullet"><span class="by">I_Am_Nous</span><span>|</span><a href="#37824207">parent</a><span>|</span><a href="#37824862">next</a><span>|</span><label class="collapse" for="c-37824329">[-]</label><label class="expand" for="c-37824329">[1 more]</label></div><br/><div class="children"><div class="content">The domain appears to have been registered 25 Apr 2009, and I remember seeing this quite a while ago. That would make sense for 1.5 G of RAM being typical. Glad it&#x27;s still around :)</div><br/></div></div><div id="37824862" class="c"><input type="checkbox" id="c-37824862" checked=""/><div class="controls bullet"><span class="by">Pathogen-David</span><span>|</span><a href="#37824207">parent</a><span>|</span><a href="#37824329">prev</a><span>|</span><a href="#37823497">next</a><span>|</span><label class="collapse" for="c-37824862">[-]</label><label class="expand" for="c-37824862">[1 more]</label></div><br/><div class="children"><div class="content">Oldest copy on the Wayback Machine is from May 2009 <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090513043445&#x2F;https:&#x2F;&#x2F;www.linuxatemyram.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090513043445&#x2F;https:&#x2F;&#x2F;www.linux...</a></div><br/></div></div></div></div><div id="37823497" class="c"><input type="checkbox" id="c-37823497" checked=""/><div class="controls bullet"><span class="by">Tao3300</span><span>|</span><a href="#37824207">prev</a><span>|</span><a href="#37826752">next</a><span>|</span><label class="collapse" for="c-37823497">[-]</label><label class="expand" for="c-37823497">[3 more]</label></div><br/><div class="children"><div class="content">I pity the fool who don&#x27;t eat RAM.</div><br/><div id="37824268" class="c"><input type="checkbox" id="c-37824268" checked=""/><div class="controls bullet"><span class="by">meepmorp</span><span>|</span><a href="#37823497">parent</a><span>|</span><a href="#37823686">next</a><span>|</span><label class="collapse" for="c-37824268">[-]</label><label class="expand" for="c-37824268">[1 more]</label></div><br/><div class="children"><div class="content">It’s the first thing that popped into my head.</div><br/></div></div><div id="37823686" class="c"><input type="checkbox" id="c-37823686" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#37823497">parent</a><span>|</span><a href="#37824268">prev</a><span>|</span><a href="#37826752">next</a><span>|</span><label class="collapse" for="c-37823686">[-]</label><label class="expand" for="c-37823686">[1 more]</label></div><br/><div class="children"><div class="content">I guess people around here are Too Young.<p>This is a reference to a legitimate piece of Internet history:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ate_my_balls" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ate_my_balls</a><p>&gt; &quot;Ate my balls&quot; is one of the earliest examples of an internet meme. It was widely shared in the late 1990s when adherents created web pages to depict a particular celebrity, fictional character, or other subject&#x27;s zeal for eating testicles. Often, the site would consist of a humorous fictitious story or comic featuring edited photos about the titular individual; the photo editing was often crude and featured the character next to comic-book style speech in a thought balloon.<p>&gt; The fad was started in 1996 by Nehal Patel, a student at University of Illinois at Urbana-Champaign with a &quot;Mr. T Ate My Balls&quot; web page.</div><br/></div></div></div></div><div id="37826752" class="c"><input type="checkbox" id="c-37826752" checked=""/><div class="controls bullet"><span class="by">simonblack</span><span>|</span><a href="#37823497">prev</a><span>|</span><a href="#37827728">next</a><span>|</span><label class="collapse" for="c-37826752">[-]</label><label class="expand" for="c-37826752">[1 more]</label></div><br/><div class="children"><div class="content">Why all the fuss??<p>When you can download as much RAM as you want, any time you want.<p><a href="https:&#x2F;&#x2F;downloadmoreram.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;downloadmoreram.com&#x2F;</a></div><br/></div></div><div id="37827728" class="c"><input type="checkbox" id="c-37827728" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#37826752">prev</a><span>|</span><a href="#37826489">next</a><span>|</span><label class="collapse" for="c-37827728">[-]</label><label class="expand" for="c-37827728">[1 more]</label></div><br/><div class="children"><div class="content">Windows ate my hard disk (every year).</div><br/></div></div><div id="37826489" class="c"><input type="checkbox" id="c-37826489" checked=""/><div class="controls bullet"><span class="by">404mm</span><span>|</span><a href="#37827728">prev</a><span>|</span><a href="#37824814">next</a><span>|</span><label class="collapse" for="c-37826489">[-]</label><label class="expand" for="c-37826489">[1 more]</label></div><br/><div class="children"><div class="content">You can always just download more RAM. <a href="https:&#x2F;&#x2F;www.downloadmoreram.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.downloadmoreram.com</a></div><br/></div></div><div id="37824814" class="c"><input type="checkbox" id="c-37824814" checked=""/><div class="controls bullet"><span class="by">wingworks</span><span>|</span><a href="#37826489">prev</a><span>|</span><a href="#37824999">next</a><span>|</span><label class="collapse" for="c-37824814">[-]</label><label class="expand" for="c-37824814">[3 more]</label></div><br/><div class="children"><div class="content">htop shows this (it&#x27;s the orange&#x2F;yellow bar in RAM)</div><br/><div id="37826983" class="c"><input type="checkbox" id="c-37826983" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37824814">parent</a><span>|</span><a href="#37824999">next</a><span>|</span><label class="collapse" for="c-37826983">[-]</label><label class="expand" for="c-37826983">[2 more]</label></div><br/><div class="children"><div class="content">I recommend btop these days (<a href="https:&#x2F;&#x2F;github.com&#x2F;aristocratos&#x2F;btop">https:&#x2F;&#x2F;github.com&#x2F;aristocratos&#x2F;btop</a>)</div><br/><div id="37827707" class="c"><input type="checkbox" id="c-37827707" checked=""/><div class="controls bullet"><span class="by">wingworks</span><span>|</span><a href="#37824814">root</a><span>|</span><a href="#37826983">parent</a><span>|</span><a href="#37824999">next</a><span>|</span><label class="collapse" for="c-37827707">[-]</label><label class="expand" for="c-37827707">[1 more]</label></div><br/><div class="children"><div class="content">I just tried btop, it has crazy colours (nothing like screenshots) on my Mac Terminal app (Misterioso theme).</div><br/></div></div></div></div></div></div><div id="37824999" class="c"><input type="checkbox" id="c-37824999" checked=""/><div class="controls bullet"><span class="by">Karunamon</span><span>|</span><a href="#37824814">prev</a><span>|</span><a href="#37824921">next</a><span>|</span><label class="collapse" for="c-37824999">[-]</label><label class="expand" for="c-37824999">[4 more]</label></div><br/><div class="children"><div class="content">Okay, if unused memory is wasted and there are truly no consequences for the &quot;free&quot; column reading zero, then why on a busy system do I get UI chugging and otherwise poor (bordering on unusable) performance under this condition that is immediately resolved by forcing the caches to drop and freeing multiple gigabytes?<p>Whatever conceivable speedup there is from 12 GB of file cache as opposed to 11 is obliterated multiple times over from the time lost by having to do this dance, or worse, recovering after the oom killer wipes out my X session or browser.</div><br/><div id="37825175" class="c"><input type="checkbox" id="c-37825175" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#37824999">parent</a><span>|</span><a href="#37825766">next</a><span>|</span><label class="collapse" for="c-37825175">[-]</label><label class="expand" for="c-37825175">[2 more]</label></div><br/><div class="children"><div class="content">&gt;recovering after the oom killer wipes out my X session or browser.<p>Perhaps you can share more details of what you&#x27;re doing to force the cache to drop and what the side effects are exactly because an OOM can&#x27;t be caused by the file cache since the total free memory available to applications remains the same. The whole point of the file cache is to use otherwise unallocated memory and give it up the moment it&#x27;s needed. There should not be an OOM from this short of an OS bug or an over allocated virtualized system.</div><br/><div id="37825722" class="c"><input type="checkbox" id="c-37825722" checked=""/><div class="controls bullet"><span class="by">Karunamon</span><span>|</span><a href="#37824999">root</a><span>|</span><a href="#37825175">parent</a><span>|</span><a href="#37825766">next</a><span>|</span><label class="collapse" for="c-37825722">[-]</label><label class="expand" for="c-37825722">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches
</code></pre>
Last time I ran into this was a couple of years ago on a stock Arch system. (Disabilities forced me back to Windows). Every time, the largest memory consumer was the web browser. Also every time, the system became nearly unresponsive due to swap thrashing (kswapd at the top of the CPU usage list, most of which was I&#x2F;O wait).<p>Last time I complained about this problem, someone suggested installing zram which did stop it from happening. However, this does not change the fact that there is some pathological failure case that contradicts the central thesis (not to mention, smug tone) of this website and makes searching for solutions to the problem infuriating.</div><br/></div></div></div></div><div id="37825766" class="c"><input type="checkbox" id="c-37825766" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#37824999">parent</a><span>|</span><a href="#37825175">prev</a><span>|</span><a href="#37824921">next</a><span>|</span><label class="collapse" for="c-37825766">[-]</label><label class="expand" for="c-37825766">[1 more]</label></div><br/><div class="children"><div class="content">I find that task priorities in general are not strict enough under Linux. Try running a cpu heavy but very low priority task in background and it still manages to measurably affect the latency of the more important process. And this is just the CPU, not to mention disk utilization and network usage.<p>I was too lazy to find a proper solution, so I just used mlockall after allocating a massive heap and pin the process to a core that is reserved only for this specific purpose.<p>I think cgroups has very flexible tools for reserving system wide resources, but haven&#x27;t had the time to test it yet.</div><br/></div></div></div></div><div id="37824921" class="c"><input type="checkbox" id="c-37824921" checked=""/><div class="controls bullet"><span class="by">mavhc</span><span>|</span><a href="#37824999">prev</a><span>|</span><label class="collapse" for="c-37824921">[-]</label><label class="expand" for="c-37824921">[1 more]</label></div><br/><div class="children"><div class="content">My Linux ram problems are 1: Ubuntu default install, ends up with xwayland using 5GB ram. 2: when running out of ram it seems to default to crashing back to the logon screen</div><br/></div></div></div></div></div></div></div></body></html>