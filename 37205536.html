<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692694862317" as="style"/><link rel="stylesheet" href="styles.css?v=1692694862317"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/unix/UnixTechnologyAndIdea">Unix is both a technology and an idea</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>zdw</span> | <span>32 comments</span></div><br/><div><div id="37219876" class="c"><input type="checkbox" id="c-37219876" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#37219221">next</a><span>|</span><label class="collapse" for="c-37219876">[-]</label><label class="expand" for="c-37219876">[4 more]</label></div><br/><div class="children"><div class="content">This article just keeps repeating the two concepts of Unix technology and Unix ideas but doesn&#x27;t clarify what they mean by either. The links, seemingly complaining about iOS or Android, don&#x27;t really seem to clarify.<p>It seems many want Unix technology or ideas to be about what Unix meant in the 70s and 80s and don&#x27;t have much interest in moving things forward from that plateau. (To be clear, I think <i>all</i> the major operating systems of today leave a lot to be desired, but each one has their own pros and cons.)<p>Aside from the file system parts, my understanding of the <i>idea</i> of Unix is that it is a bunch of small utilities interacting with each other. I think almost anyone agrees with that idea, see functional programming and node based tools that link up data between dedicated functions and nodes, respectively. This idea is quite pervasive, and I don&#x27;t think it was necessarily Unix that conceived of it. But in reality, the implementation of this idea in Unix leaves a lot to be desired. The collection of utilities that have very few standards in interfacing, documentation, naming, usability, and more importantly, data structures leaves one wanting. The idea that everything should be text is implicit and highly limiting. This is why programming languages that are somewhat OS-like and have their own scripting are so well liked, becuase it removes the need to worry about the various OSes&#x27; implementation of these ideas, leaving one to stay at a virtual machine level. For example, Elixir and the BEAM.<p>It&#x27;s typically viewed as blasphamous, but I think the PowerShell model is the more powerful one if we&#x27;re just considering OS-level provided interactions. But even then, restricting oneself to the terminal is limiting. I find the ideas in Smalltalk to be much more powerful and forward thinking, despite being as old as Unix itself.</div><br/><div id="37220035" class="c"><input type="checkbox" id="c-37220035" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#37219876">parent</a><span>|</span><a href="#37219937">next</a><span>|</span><label class="collapse" for="c-37220035">[-]</label><label class="expand" for="c-37220035">[2 more]</label></div><br/><div class="children"><div class="content">I agree, PowerShell does the same thing better.<p>And I&#x27;m disappointed that things have stagnated so much. I mean, cool, a commandline is an useful concept that sometimes fits a given task excellently well. But why in the hell are we still emulating a VT100? How is a modern Linux console sticking to a 50 year old level of functionality?<p>And why are we scripting in something as painful as Bash?</div><br/><div id="37220105" class="c"><input type="checkbox" id="c-37220105" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37219876">root</a><span>|</span><a href="#37220035">parent</a><span>|</span><a href="#37219937">next</a><span>|</span><label class="collapse" for="c-37220105">[-]</label><label class="expand" for="c-37220105">[1 more]</label></div><br/><div class="children"><div class="content">Terminals are a central idea affecting Unix process control and hierarchy, and signal delivery. Emulating them was the easier decision that didn&#x27;t require any changes to the rest of the system. You introduce a virtual terminal device and the rest stays the same. We are still trapped in those basic abstractions of the 1970s without even noticing them, building shiny stuff on top.</div><br/></div></div></div></div><div id="37219937" class="c"><input type="checkbox" id="c-37219937" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37219876">parent</a><span>|</span><a href="#37220035">prev</a><span>|</span><a href="#37219221">next</a><span>|</span><label class="collapse" for="c-37219937">[-]</label><label class="expand" for="c-37219937">[1 more]</label></div><br/><div class="children"><div class="content">The communal spirit of Unix as described by Ritchie back in the day revolves around minicomputers (aka PDP-11) shared in a single organisation, accessible via multiple terminals. A close community of users would log into the system and would eventually come up with their own small tools for a particular purpose. Those oddly-named tools would be adopted by the small community without need for extensive documentation. This is the &quot;Unix spirit&quot; of the 1970s that everyone seems to be referring to.</div><br/></div></div></div></div><div id="37219221" class="c"><input type="checkbox" id="c-37219221" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37219876">prev</a><span>|</span><a href="#37219143">next</a><span>|</span><label class="collapse" for="c-37219221">[-]</label><label class="expand" for="c-37219221">[8 more]</label></div><br/><div class="children"><div class="content">Those that keep trying to make a point of Android being UNIX, never really shipped anything on the Play Store.<p>Yes, it uses the Linux kernel, and several components born on the Linux world and that is about it.<p>Only Google and OEM partners get to see that layer, and those that root their devices.<p>Nothing on the Android userspace, the Java and Kotlin frameworks, or the NDK official APIs have anything to do with Linux in any kind, form and fashion.<p>As for putting UNIX in a pedestal, most of the so called culture, is mostly circled around nerd circles, hardly ever noticed in big iron commercial UNIXes, and now that most of them faded away, gets passed by as a kind of old culture myth told during cold nights around the fire.<p>As for the technology, the UNIX haters book exists for a reason, had AT&amp;T been allowed to sell UNIX from the get go, and most likely it wouldn&#x27;t have picked up steam on the market.<p>Being source tapes available for symbolic prices, when compared with the real cost of a commercial OS on the 1970&#x27;s, is of course a different matter.<p>I find great that at least the mobile OSes, and cloud infrastructure nowadays focus on other stacks, instead of being yet another UNIX clone, no need for OS monoculture stuck in the past.<p>Signed, a recovered UNIX zealot.</div><br/><div id="37219600" class="c"><input type="checkbox" id="c-37219600" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37219221">parent</a><span>|</span><a href="#37219717">next</a><span>|</span><label class="collapse" for="c-37219600">[-]</label><label class="expand" for="c-37219600">[2 more]</label></div><br/><div class="children"><div class="content">Well you can ssh to an Android phone through the USB developer tools, and you get a bunch of Unix commands like ls, df, etc.<p>Anyway what&#x27;s wrong about Unix is that it assumes that users need to be protected from each other (good) but installed binaries can be somehow trusted (bad). We&#x27;re in the internet age now where we download so many executable code that we need better sandboxing, as part of the OS.</div><br/><div id="37219664" class="c"><input type="checkbox" id="c-37219664" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37219221">root</a><span>|</span><a href="#37219600">parent</a><span>|</span><a href="#37219717">next</a><span>|</span><label class="collapse" for="c-37219664">[-]</label><label class="expand" for="c-37219664">[1 more]</label></div><br/><div class="children"><div class="content">After enabling the developer mode, and using tools regular users never get to see.</div><br/></div></div></div></div><div id="37219717" class="c"><input type="checkbox" id="c-37219717" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#37219221">parent</a><span>|</span><a href="#37219600">prev</a><span>|</span><a href="#37219887">next</a><span>|</span><label class="collapse" for="c-37219717">[-]</label><label class="expand" for="c-37219717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and cloud infrastructure nowadays focus on other stacks, instead of being yet another UNIX clone<p>could you elaborate? I was under the impression, that most clouds heavily rely on unix, both for host and guest systems (and containers)</div><br/></div></div><div id="37219887" class="c"><input type="checkbox" id="c-37219887" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#37219221">parent</a><span>|</span><a href="#37219717">prev</a><span>|</span><a href="#37219584">next</a><span>|</span><label class="collapse" for="c-37219887">[-]</label><label class="expand" for="c-37219887">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how much of the hate Windows gets is simply because Windows has nothing to do with Unix&#x27;s bloodlines and heritage.<p>Aside from cursory accomodations like the Microsoft POSIX Subsystem (what we would in theory call Windows Subsystem for POSIX if it existed today), that is.</div><br/><div id="37220079" class="c"><input type="checkbox" id="c-37220079" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#37219221">root</a><span>|</span><a href="#37219887">parent</a><span>|</span><a href="#37219584">next</a><span>|</span><label class="collapse" for="c-37220079">[-]</label><label class="expand" for="c-37220079">[1 more]</label></div><br/><div class="children"><div class="content">Windows NT and all subsequent Windows versions trace their heritage to VMS.<p>Had it not been so monolithic, almost excluding all other OS’s I think we would celebrate Windows too.<p>Unix ultimately won mindshare because it was relatively open. Any technical advantage mattered far less at he end of the day.</div><br/></div></div></div></div><div id="37219584" class="c"><input type="checkbox" id="c-37219584" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37219221">parent</a><span>|</span><a href="#37219887">prev</a><span>|</span><a href="#37219143">next</a><span>|</span><label class="collapse" for="c-37219584">[-]</label><label class="expand" for="c-37219584">[2 more]</label></div><br/><div class="children"><div class="content">iOS is also a UNIX btw ;)</div><br/><div id="37219656" class="c"><input type="checkbox" id="c-37219656" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37219221">root</a><span>|</span><a href="#37219584">parent</a><span>|</span><a href="#37219143">next</a><span>|</span><label class="collapse" for="c-37219656">[-]</label><label class="expand" for="c-37219656">[1 more]</label></div><br/><div class="children"><div class="content">Now try to ship an app using only UNIX apis.</div><br/></div></div></div></div></div></div><div id="37219143" class="c"><input type="checkbox" id="c-37219143" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#37219221">prev</a><span>|</span><a href="#37218342">next</a><span>|</span><label class="collapse" for="c-37219143">[-]</label><label class="expand" for="c-37219143">[4 more]</label></div><br/><div class="children"><div class="content">Unix was a couple of guys in an attic. Hack was one guy. Unix was collaborative, personally collaborative between some extraordinary intelligent people. If you read Kernighan&#x27;s memoir, it talks about the second version problem. Unix solved a problem. GNU solved a problem. Linux solved a problem, and WSL2 solved a problem. Using a hammer to rid your house of ants is a solution, that does not fit the problem. I do not consider a hammer harmful in itself, if its used to drive nails. Everything needs a tersely named tool is outdated, useful for trouble shooting but outdated UX&#x2F;UI. We need to continue with our tools, and develop them further, but not with extraneous bells and whistles. ( This bit of wisdom came from a 5th grader, who now has a degree in Political Economics, and I do not understand a single thing he says. ) Read Kernighan&#x27;s memoir.</div><br/><div id="37219329" class="c"><input type="checkbox" id="c-37219329" checked=""/><div class="controls bullet"><span class="by">safety1st</span><span>|</span><a href="#37219143">parent</a><span>|</span><a href="#37218342">next</a><span>|</span><label class="collapse" for="c-37219329">[-]</label><label class="expand" for="c-37219329">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s often lost in a simple review of the history is that in modern times certain elements of the Unix philosophy [1] have become more important than ever. In fact as technology becomes more pervasive I would argue that the ideas it encapsulates are no longer only relevant to computer architecture, they&#x27;re now relevant to the survival of a free and open society. This isn&#x27;t just about how to build the best widget anymore (though I still think the Unix philosophy is a great contender for that).<p>In particular I&#x27;m referring to the principles of composability and universal interfaces. These principles make the Unix philosophy inherently democratizing - when you apply it you&#x27;re producing something that&#x27;s intended to interoperate with other agents in a diverse ecosystem beyond your control. This is in stark contrast to the monoliths that tend to emerge from proprietary software development where the socioeconomic goals are to control everything strictly and limit interoperability because there&#x27;s commercial value in having a &quot;moat&quot; or a &quot;walled garden&quot; which people can&#x27;t escape.<p>As computers become interwoven with our lives and our society the general purpose computer has become a tool like the printing press. The printing press was a precursor for democracy as we know it because it enabled the dissemination of information on a scale that was previously impossible.<p>What sort of social progress we might ultimately achieve through the general purpose computer is yet to be fully determined. But in the modern era we have many examples of what the competing philosophy of proprietary monoliths looks like - it&#x27;s a hellscape where more your time and attention are harnessed by the monolith&#x27;s owner, to serve his own ends, even at the detriment of your health and well-being [2].<p>Facebook and Instagram wouldn&#x27;t be killing our children if they had been designed around the Unix principles of composability and a universal interface. How many people have lamented their inability to take their data, content and relationships away from Meta&#x27;s silo? It&#x27;s a constant refrain in our industry that people wish they could get away from a service that started out great and gradually &quot;enshittified&quot; - had these services been designed with the Unix philosophy in mind, it would be possible.<p>Either way, the Unix philosophy is now just as much about your human freedom and well-being, as it is about whether your code works well.<p>Stallman of course saw this coming decades ago and predicted with disturbing prescience - that &quot;either the user would control the program, or the program would control the user.&quot;<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unix_philosophy" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unix_philosophy</a><p>[2] <a href="https:&#x2F;&#x2F;jonathanhaidt.substack.com&#x2F;p&#x2F;social-media-mental-illness-epidemic" rel="nofollow noreferrer">https:&#x2F;&#x2F;jonathanhaidt.substack.com&#x2F;p&#x2F;social-media-mental-ill...</a></div><br/><div id="37219895" class="c"><input type="checkbox" id="c-37219895" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#37219143">root</a><span>|</span><a href="#37219329">parent</a><span>|</span><a href="#37219864">next</a><span>|</span><label class="collapse" for="c-37219895">[-]</label><label class="expand" for="c-37219895">[1 more]</label></div><br/><div class="children"><div class="content">The principles are good, the implementation sadly is not.<p>Plain data streams have outstayed their welcome. Pretty much nothing but the classic old Unix tools communicates with plain text streams. Smarter, new commandline tools tend to provide at least JSON, but there&#x27;s plenty that don&#x27;t and that makes them absolutely painful to reuse. I&#x27;ve written large amounts of code that amount to running a process, parsing its output, and then translating that to the actual API I want: methods and events. Basically all that work is a waste that doesn&#x27;t actually get what I want done.<p>Of all things, Microsoft had a better idea with Powershell: it does the same concept, but far better.<p>The internet has seen something similar: a huge amount of users take a TCP socket and proceed to build an improvised messaging protocol on top, because that actually fulfills the needs of many applications far better, yet the API doesn&#x27;t actually provide it.<p>IMO, there&#x27;s been too much Unix philosophy worship. We&#x27;ve stuck to an early, simple idea and on the long term it&#x27;s a huge detriment. Since it&#x27;s so lacking, everyone builds their proprietary hacks on top.</div><br/></div></div><div id="37219864" class="c"><input type="checkbox" id="c-37219864" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#37219143">root</a><span>|</span><a href="#37219329">parent</a><span>|</span><a href="#37219895">prev</a><span>|</span><a href="#37218342">next</a><span>|</span><label class="collapse" for="c-37219864">[-]</label><label class="expand" for="c-37219864">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Stallman of course saw this coming decades ago and predicted with disturbing prescience - that &quot;either the user would control the program, or the program would control the user.&quot;<p>Do you have a source for this quote?  Best I can find is this text from 2013:<p><a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;philosophy&#x2F;free-software-even-more-important.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;philosophy&#x2F;free-software-even-more-impor...</a></div><br/></div></div></div></div></div></div><div id="37218342" class="c"><input type="checkbox" id="c-37218342" checked=""/><div class="controls bullet"><span class="by">kgr</span><span>|</span><a href="#37219143">prev</a><span>|</span><a href="#37219823">next</a><span>|</span><label class="collapse" for="c-37218342">[-]</label><label class="expand" for="c-37218342">[3 more]</label></div><br/><div class="children"><div class="content">If we analyze the computational complexity of software architectures the way we do regular algorithms, we see that UNIX was much more efficient than previous OSes&#x2F;approaches.<p>It&#x27;s demonstrated in this short video:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3Ea3pkTCYx4">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3Ea3pkTCYx4</a></div><br/><div id="37218569" class="c"><input type="checkbox" id="c-37218569" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#37218342">parent</a><span>|</span><a href="#37219823">next</a><span>|</span><label class="collapse" for="c-37218569">[-]</label><label class="expand" for="c-37218569">[2 more]</label></div><br/><div class="children"><div class="content">Yup, I cited that <i>Unix vs Google</i> video in my post <i>The Internet Was Designed With a Narrow Waist</i><p><a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;02&#x2F;diagrams.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;02&#x2F;diagrams.html</a><p>A narrow waist is an idea or interface that gives you O(M x N) functionality for O(M + N) code.  It&#x27;s a way to reuse code and data by  interoperating.<p>If you can&#x27;t interoperate, you end up writing bad versions of the same application code, over and over again.<p>More concretely, I remember there was this whole &quot;re-architect google3&quot; idea &gt;10 years ago, which seemed to get brushed aside for the cloud.  I think they were trying to have more of a narrow waist, not 10 different distributed databases made by 10 competing teams, 10 different auth libraries, etc.<p>The management&#x27;s perception then was that product dev was extremely slow, and had poor quality results<p>That video is about the application side of Google (e.g. docs and maps), but the internal side had similar architectural problems.<p>---<p>As another example, it seems like the dev tools group at Google wanted this article to be published, and I have no idea why:<p><i>Google Is 2 Billion Lines of Code—And It&#x27;s All in One Place</i><p><a href="https:&#x2F;&#x2F;www.wired.com&#x2F;2015&#x2F;09&#x2F;google-2-billion-lines-codeand-one-place&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.wired.com&#x2F;2015&#x2F;09&#x2F;google-2-billion-lines-codeand...</a><p>It&#x27;s saying Microsoft Windows has 50 M lines of code, while Google has 2 B lines of code.<p>There are all sorts of problems with those numbers, but in any case, it&#x27;s not a flattering comparison -- not something you want to brag about<p>I think they wanted to emphasize the scalability of the source control system, and ended up saying that Google has a lot of bad code that doesn&#x27;t work well</div><br/><div id="37218748" class="c"><input type="checkbox" id="c-37218748" checked=""/><div class="controls bullet"><span class="by">dmoy</span><span>|</span><a href="#37218342">root</a><span>|</span><a href="#37218569">parent</a><span>|</span><a href="#37219823">next</a><span>|</span><label class="collapse" for="c-37218748">[-]</label><label class="expand" for="c-37218748">[1 more]</label></div><br/><div class="children"><div class="content">Is there a linux OS (or two?) in google3?<p>google3 vs windows might not be a reasonable comparison, than say google3 vs windows + office + azure + dozens of other Microsoft products.</div><br/></div></div></div></div></div></div><div id="37219823" class="c"><input type="checkbox" id="c-37219823" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37218342">prev</a><span>|</span><a href="#37218109">next</a><span>|</span><label class="collapse" for="c-37219823">[-]</label><label class="expand" for="c-37219823">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and specifically, a bad idea: <a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;~simsong&#x2F;www&#x2F;ugh.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.mit.edu&#x2F;~simsong&#x2F;www&#x2F;ugh.pdf</a></div><br/></div></div><div id="37218109" class="c"><input type="checkbox" id="c-37218109" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#37219823">prev</a><span>|</span><a href="#37219916">next</a><span>|</span><label class="collapse" for="c-37218109">[-]</label><label class="expand" for="c-37218109">[4 more]</label></div><br/><div class="children"><div class="content">Android is a great NEGATIVE example of the Unix philosophy!  The code is based on the Linux kernel, which might make you think it&#x27;s Unix, but isn&#x27;t Unix [1]<p>An OS is where 3 things meet: code, data, and people.<p>AKA apps, files, and users.<p>AKA CPU, storage, and networking when viewed from hardware (in the old days, you&#x27;d have terminals and serial ports, not Internet)<p>I&#x27;d argue that (if you take away the historical &quot;hairs&quot;), Unix is a minimal and efficient implementation of those ideas.<p>It&#x27;s efficient enough to build heterogeneous &quot;platforms&quot; on top -- Lisp, JVM, JavaScript, Python, etc.  Databases, hardware virtual machines, the entire modern cloud<p>The shebang line is basically &quot;polymorphism&quot; for those runtimes -- everything looks like .&#x2F;foo arg1 arg2<p>The args are often unstructured files that you share between different programs<p>--<p>Android breaks from that design in many, many ways<p>- Applications are written to the Java runtime, not to the OS<p>- They written in Java or Kotlin.  Escaping to C++ is a &quot;special&quot; thing, you use the &quot;NDK&quot; for that<p>- It doesn&#x27;t expose raw files to applications, or at least it seems apps can&#x27;t really share files.  It uses its own security model, not Unix security (which was almost certainly necessary!)<p>Hm I clicked on the original link, and Rob Pike said it better: <i>The very idea of a &quot;Files app&quot; is high on my list of world-defeating idiocies perpetrated by technology.</i><p>- It doesn&#x27;t use Unix IPC, it has its own &quot;binder&quot; mechanism between apps.  Although most modern Unixes don&#x27;t find it enough either - <a href="https:&#x2F;&#x2F;roxanageambasu.github.io&#x2F;publications&#x2F;eurosys2016posix.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;roxanageambasu.github.io&#x2F;publications&#x2F;eurosys2016pos...</a><p>So Android is more like a &quot;monoglot&quot; operating system on top of Unix.  It&#x27;s just using Linux as a bunch of device drivers basically<p>(Makes me think of the quote from the 90&#x27;s regarding browser&#x2F;JVM: &quot;Windows should just be a bunch of poorly debugged device drivers&quot;, and that rhymes a bit with how Android turned out.)<p>---<p>I think the cloud is missing the &quot;Unix&quot; layer, i.e. a good factoring of mechanism and policy, C and shell, which you can build other platforms on top of.<p>I&#x27;ll refer to my own post: <i>Kubernetes is our generation&#x27;s Multics</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27903720">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27903720</a><p>The cloud is kind of an incoherent architectural mess -- it doesn&#x27;t really have the code &#x2F; data &#x2F; users model.<p>It basically has the incoherent &quot;Files app&quot; architecture, as Pike says<p>What&#x27;s code in the cloud?  How do I invoke it?  What are files?  What are users?  There&#x27;s a million answers, and it causes a lot of work for us programmers.<p>Most app code seems to be papering over the differences between different representations of these fundamental things, which ultimately makes them slow and unreliable<p>[1] Incidentally, Android is also not GNU&#x2F;Linux -- it&#x27;s the Linux kernel, without GNU at the platform layer</div><br/><div id="37220134" class="c"><input type="checkbox" id="c-37220134" checked=""/><div class="controls bullet"><span class="by">didntcheck</span><span>|</span><a href="#37218109">parent</a><span>|</span><a href="#37219866">next</a><span>|</span><label class="collapse" for="c-37220134">[-]</label><label class="expand" for="c-37220134">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m having trouble understanding what he&#x27;s criticising in that Mastodon post<p>If he&#x27;s saying he doesn&#x27;t have sufficient OS access rights to his files, surely the <i>existence</i> of a &quot;Files App&quot; (aka a file explorer, hardly new) disproves his claim. Android also has multiple-choice file associations just like a desktop OS<p>If he&#x27;s complaining that the formats are opaque, or that we keep reinventing very similar CRUD apps, then isn&#x27;t the Unix model of &quot;a file is just a bag of bytes in a hierarchical namespace&quot; the <i>cause</i> of his problem? It explicitly rejects having standard formats and the result is every application <i>having</i> to bring its own, with all the resultant opaqueness and reinvented wheels</div><br/></div></div><div id="37219866" class="c"><input type="checkbox" id="c-37219866" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37218109">parent</a><span>|</span><a href="#37220134">prev</a><span>|</span><a href="#37219253">next</a><span>|</span><label class="collapse" for="c-37219866">[-]</label><label class="expand" for="c-37219866">[1 more]</label></div><br/><div class="children"><div class="content">Basically an argument is this:<p>Android could in the future replace the Linux kernel and libs with their own Fucscia kernel&#x2F;OS and (aside from some light porting effort for some minor behaviors breaking and affecting very few items) nobody would even know.<p>That&#x27;s how non-essential Linux&#x2F;UNIX&#x2F;POSIX is to Android.<p>And that&#x27;s for the kernel and libs and APIs. When it comes to the philosophy, experience, etc, it&#x27;s even more remote.</div><br/></div></div><div id="37219253" class="c"><input type="checkbox" id="c-37219253" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37218109">parent</a><span>|</span><a href="#37219866">prev</a><span>|</span><a href="#37219916">next</a><span>|</span><label class="collapse" for="c-37219253">[-]</label><label class="expand" for="c-37219253">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So Android is more like a &quot;monoglot&quot; operating system on top of Unix. It&#x27;s just using Linux as a bunch of device drivers basically<p>Not even that since Project Treble.<p>From Project Treble point of view, Linux kernel is a microkernel, and the only in-kernel drivers are legacy drivers, all modern drivers should run on their own userspace process (written in C++ or Java), and use Android IPC to talk to the kernel.<p>Android has zero to do with UNIX philosophy, they could ship a version using Zirkon instead of Linux kernel and nothing in userspace would notice, unless they are trying to use private APIs, or are OEM partners.</div><br/></div></div></div></div><div id="37219916" class="c"><input type="checkbox" id="c-37219916" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37218109">prev</a><span>|</span><a href="#37219120">next</a><span>|</span><label class="collapse" for="c-37219916">[-]</label><label class="expand" for="c-37219916">[1 more]</label></div><br/><div class="children"><div class="content">And ioctl is the hack that made that idea work.</div><br/></div></div><div id="37218011" class="c"><input type="checkbox" id="c-37218011" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#37219120">prev</a><span>|</span><label class="collapse" for="c-37218011">[-]</label><label class="expand" for="c-37218011">[5 more]</label></div><br/><div class="children"><div class="content">I would argue that while Unix the technology is helpful, Unix the idea is now actively harmful.<p>The Unix idea just doesn’t scale well or have the necessary security.<p>It seems we are more and more going to an idea that is even older than Unix - the mainframe.<p>From fault tolerance to distributed computing to security to memory channels our modern architectures are more resembling mainframes than Unix and that is good.<p>Everything is a file is a very, very leaky abstraction. There are all sorts of issues with latency, cost, atomicity, security, persistence.<p>I feel at this point, that this constant looking back to Unix “purity” is holding us back and closing our mind to new solutions.</div><br/><div id="37218387" class="c"><input type="checkbox" id="c-37218387" checked=""/><div class="controls bullet"><span class="by">chargingmarmot</span><span>|</span><a href="#37218011">parent</a><span>|</span><a href="#37218849">next</a><span>|</span><label class="collapse" for="c-37218387">[-]</label><label class="expand" for="c-37218387">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a book I like called &quot;Design Rules: The Power of Modularity&quot;; it was written by some business professors in 2000 and is loosely about the industrial organization and the history of IBM&#x27;s System&#x2F;360 (the first &quot;modular computer family&quot;) and more generally about how modularity enables innovation and growth.<p>They enumerate what they call &quot;modular operators&quot; which are basic ways a system can be changed:<p>* &quot;splitting&quot; a design into modules<p>* &quot;substituting&quot; one module design for another<p>* &quot;augmenting&quot; adding a new module to the system<p>* &quot;excluding&quot; a module from the system<p>* &quot;inverting&quot; to create new design rules<p>* &quot;porting&quot; a module to another system<p>It doesn&#x27;t matter here whether the modules are functions, computer programs, hardware components, business units, 2 pizza teams, or companies in an industry (Intel, AMD, RAM manufacturers...).<p>Modularity is a core part of the Unix philosophy.  Unix itself is an operating system and involves some particular concepts (pipes, files, processes).<p>It seems obvious that the concepts for an operating system (pipes, files) will be less relevant in a different domain (say, web programming).<p>While I agree that maybe the Unix abstractions aren&#x27;t appropriate for new problems in different domains, I think some parts of the Unix philosophy (i.e. modularity, minimalism, and compositionality) still deserve consideration.</div><br/></div></div><div id="37218849" class="c"><input type="checkbox" id="c-37218849" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#37218011">parent</a><span>|</span><a href="#37218387">prev</a><span>|</span><a href="#37218695">next</a><span>|</span><label class="collapse" for="c-37218849">[-]</label><label class="expand" for="c-37218849">[2 more]</label></div><br/><div class="children"><div class="content">&gt; “purity” is holding us back and closing our mind to new solutions.<p>Maybe. But consider shebang. It means that any program (&#x2F;script) written in any language known by the system can call any other program  written in any other language.  That keeps open the option of which laguage should we use for our next module. Right?</div><br/><div id="37219891" class="c"><input type="checkbox" id="c-37219891" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37218011">root</a><span>|</span><a href="#37218849">parent</a><span>|</span><a href="#37218695">next</a><span>|</span><label class="collapse" for="c-37219891">[-]</label><label class="expand" for="c-37219891">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an constrained example of the general concept of a file-association (having a file plus the info of what application executes that file).<p>As such, it predates UNIX, exist in other OSes as well, and can be even more dynamic (as shebangs are hardcoded into the file, where file + executable associations could be external).<p>Linux offers another way anyway: linux_binfmt<p>If I&#x27;m not mistaken that&#x27;s also how jar files can be executed by themselves without calling java on them.</div><br/></div></div></div></div><div id="37218695" class="c"><input type="checkbox" id="c-37218695" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#37218011">parent</a><span>|</span><a href="#37218849">prev</a><span>|</span><label class="collapse" for="c-37218695">[-]</label><label class="expand" for="c-37218695">[1 more]</label></div><br/><div class="children"><div class="content">Have you ever used a mainframe OS like MVS, or the z&#x2F;OS or earlier versions of it?</div><br/></div></div></div></div></div></div></div></div></div></body></html>