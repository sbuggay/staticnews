<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686474046306" as="style"/><link rel="stylesheet" href="styles.css?v=1686474046306"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://underjord.io/why-ml-on-erlang.html">Why Do ML on the Erlang VM?</a> <span class="domain">(<a href="https://underjord.io">underjord.io</a>)</span></div><div class="subtext"><span>lawik</span> | <span>42 comments</span></div><br/><div><div id="36279434" class="c"><input type="checkbox" id="c-36279434" checked=""/><div class="controls bullet"><span class="by">sdwolfz</span><span>|</span><a href="#36277084">next</a><span>|</span><label class="collapse" for="c-36279434">[-]</label><label class="expand" for="c-36279434">[1 more]</label></div><br/><div class="children"><div class="content">Many years ago I was studying deep learning using this resource:<p>* <a href="http:&#x2F;&#x2F;neuralnetworksanddeeplearning.com&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;neuralnetworksanddeeplearning.com&#x2F;</a><p>I decided to try to implement everything from scratch in Elixir (after initially doing all the math with pen and paper on a trivial example to get the feel of it). Obviously pure elixir was extremely slow, so I started creating NIFs to pass over matrix multiplication to OpenBLAS. Then I was thinking more and more of what things I can pass to C code and just have Elixir as a &quot;frontend&quot; for it. My enthusiasm died down when I realised I was simply implementing things in C with the pretext of &quot;doing elixir&quot;, a nice learning experience but I could see I was not doing the things that initially got me pumped up.<p>Don&#x27;t get me wrong, I loved the discovery part of it, reading research and trying to understand so I can implement the different new (at the time) deep learning techniques, like convolutions, LSTM, and the different nuances of it. I think it gave me a better understanding of how things work and why it works. But it deviated from the initial scope and I lost interest once the learning phase was over and I knew I could simply use tensorflow or pytoorch as I did not actually need the advantages BEAM offers for this type of workload.<p>Code is still available here:<p>* <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;sdwolfz&#x2F;experimental&#x2F;-&#x2F;tree&#x2F;master&#x2F;exlearn" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;sdwolfz&#x2F;experimental&#x2F;-&#x2F;tree&#x2F;master&#x2F;exlear...</a></div><br/></div></div><div id="36277084" class="c"><input type="checkbox" id="c-36277084" checked=""/><div class="controls bullet"><span class="by">paddw</span><span>|</span><a href="#36279434">prev</a><span>|</span><a href="#36278185">next</a><span>|</span><label class="collapse" for="c-36277084">[-]</label><label class="expand" for="c-36277084">[19 more]</label></div><br/><div class="children"><div class="content">People will go through any number of hoops to not give, &quot;I like the feel of the language more&quot;, as a reason for using it. Clearly, the main reason you would consider using Elixir for this is just that. There may be benefits to Elixir as a language, but there is no way they are going to overcome the ecosystem deficiencies to make it worth while in any unbiased cost benefit calculation. Just say you want to work in Elixir! It&#x27;s okay to have a preference on the tools you use, even if it&#x27;s for aesthetic or experiential reasons.</div><br/><div id="36278903" class="c"><input type="checkbox" id="c-36278903" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36278694">next</a><span>|</span><label class="collapse" for="c-36278903">[-]</label><label class="expand" for="c-36278903">[1 more]</label></div><br/><div class="children"><div class="content">Oh, author here. I absolutely do simply prefer it but I also think it has distinct upside compared to Python in this context. I see a number of companies orchestrating their Python ML with Elixir. For them the advantage is even more obvious. But overall Elixir has certain strengths. It also has drawbacks and trade-offs.<p>I would absokutely write the post &quot;Why I prefer Elixir&quot; and I think I have. But this was not intended to be that.</div><br/></div></div><div id="36278694" class="c"><input type="checkbox" id="c-36278694" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36278903">prev</a><span>|</span><a href="#36278074">next</a><span>|</span><label class="collapse" for="c-36278694">[-]</label><label class="expand" for="c-36278694">[4 more]</label></div><br/><div class="children"><div class="content">&gt; but there is no way they are going to overcome the ecosystem deficiencies to make it worth while in any unbiased cost benefit calculation<p>Is there a concrete reason for that? A lot of the approach in Elixir is to not go the route of other languages and merely slap an adapter interface on Python libraries. The approach is to approach things from a very Elixir and BEAM specific point of view. This is how Livebook was developed and how the machine learning libraries are being developed.<p>In fact, one could view it as Python being the one that&#x27;s going to struggle to overcome the limitations set forth by its own language design. Elixir comes with very tightly integrated tooling (projects, testing, type analysis, static analysis, notebooks, scripting, etc.) that basically has 100% adoption rate without a plethora of third-party competitors and lack of integration with the language such as Python has. With immutability and concurrency built into the language, Elixir has a leg up, and there is active research into bringing static typing to Elixir and also binding Elixir to faster runtime environments, such as Rust.<p>Python simply cannot make the jump to Elixir, Erlang, and BEAM&#x27;s language and VM capabilities like they can to a machine learning ecosystem akin to Python&#x27;s.</div><br/><div id="36279340" class="c"><input type="checkbox" id="c-36279340" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36278694">parent</a><span>|</span><a href="#36278074">next</a><span>|</span><label class="collapse" for="c-36279340">[-]</label><label class="expand" for="c-36279340">[3 more]</label></div><br/><div class="children"><div class="content">&gt; type analysis, static analysis<p>These two are so terribly, laughably bad in Elixir that you listing them as advantages makes me doubt the integrity of your entire post.</div><br/><div id="36279422" class="c"><input type="checkbox" id="c-36279422" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36279340">parent</a><span>|</span><a href="#36279424">next</a><span>|</span><label class="collapse" for="c-36279422">[-]</label><label class="expand" for="c-36279422">[1 more]</label></div><br/><div class="children"><div class="content">Worse than Python? It&#x27;s a question; I don&#x27;t know. I do know that the two most terrible (for me; I like types and a working IDE that helps me, not fight me) languages (js&#x2F;py) are also the most popular. I don&#x27;t know what that means, but as I did build large systems with Erlang in the past (in banking) which are still running production with massive load (and don&#x27;t fall down in 2 weeks because the ENTIRE ecosystem had a minor version update, invalidating all the ABI&#x27;s), I cannot imagine it&#x27;s worse than Python or JS.<p>I hope you can tell me.</div><br/></div></div><div id="36279424" class="c"><input type="checkbox" id="c-36279424" checked=""/><div class="controls bullet"><span class="by">411111111111111</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36279340">parent</a><span>|</span><a href="#36279422">prev</a><span>|</span><a href="#36278074">next</a><span>|</span><label class="collapse" for="c-36279424">[-]</label><label class="expand" for="c-36279424">[1 more]</label></div><br/><div class="children"><div class="content">My last weekend Project in Elixir is roughly 3 yrs ago now, but from what I recall the system was leagues better then pythons optional typing. It&#x27;s just bad if you&#x27;re used to languages that have been built around types from the start.</div><br/></div></div></div></div></div></div><div id="36278074" class="c"><input type="checkbox" id="c-36278074" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36278694">prev</a><span>|</span><a href="#36278218">next</a><span>|</span><label class="collapse" for="c-36278074">[-]</label><label class="expand" for="c-36278074">[1 more]</label></div><br/><div class="children"><div class="content">What hoops?  Your comment makes it sound like the author is hacking together some libraries that happen to exist just to do ML in Elixir.  Numerical Elixir is a very real thing being actively worked on by the creator of the language.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-nx">https:&#x2F;&#x2F;github.com&#x2F;elixir-nx</a></div><br/></div></div><div id="36278218" class="c"><input type="checkbox" id="c-36278218" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36278074">prev</a><span>|</span><a href="#36277882">next</a><span>|</span><label class="collapse" for="c-36278218">[-]</label><label class="expand" for="c-36278218">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but there is no way they are going to overcome the ecosystem deficiencies to make it worth while in any unbiased cost benefit calculation.<p>Another way to say this is: &quot;no other language will ever be better than X&quot;, which is clearly not true.<p>Eventually something better will arrive. Maybe that&#x27;s Elixir, maybe not, but is sure won&#x27;t be Python forever.</div><br/><div id="36279396" class="c"><input type="checkbox" id="c-36279396" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36278218">parent</a><span>|</span><a href="#36277882">next</a><span>|</span><label class="collapse" for="c-36279396">[-]</label><label class="expand" for="c-36279396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe that&#x27;s Elixir, maybe not, but is sure won&#x27;t be Python forever.<p>It will be Python for all of our lifetimes here.</div><br/></div></div></div></div><div id="36277882" class="c"><input type="checkbox" id="c-36277882" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36278218">prev</a><span>|</span><a href="#36277890">next</a><span>|</span><label class="collapse" for="c-36277882">[-]</label><label class="expand" for="c-36277882">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the language specification that makes the languages special, its the VM they run on.<p>(Elixir is a little more special with its hygienic macros, whi allow for for libs like NX to exist.)<p>The BEAM&#x2F;erlangVM is probably closer to a OS than a traditional-ish VM like the JVM.</div><br/></div></div><div id="36277890" class="c"><input type="checkbox" id="c-36277890" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36277882">prev</a><span>|</span><a href="#36277180">next</a><span>|</span><label class="collapse" for="c-36277890">[-]</label><label class="expand" for="c-36277890">[1 more]</label></div><br/><div class="children"><div class="content">I unironically think this is an absolutely legitimate reason even in a purely results-oriented, commercial context... but saying that is not politically expedient :(</div><br/></div></div><div id="36277180" class="c"><input type="checkbox" id="c-36277180" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36277890">prev</a><span>|</span><a href="#36278046">next</a><span>|</span><label class="collapse" for="c-36277180">[-]</label><label class="expand" for="c-36277180">[6 more]</label></div><br/><div class="children"><div class="content">I think BEAM languages are kind of one of the few exceptions to this argument. Its tradeoffs and runtime semantics really are just very different from other mainstream languages. Other languages &amp; communities are adapting to modern trends towards high concurrency, distributed systems, horizontal scaling, tight fault detection &amp; recovery with varying degrees of struggle and success. Meanwhile in erlang these have been priority concerns for decades and they have highly sophisticated refined solutions to them built directly into the system.<p>Not that this article makes a good argument for the benefit of any of those things <i>for ML</i>. But at least generally while I am a pretty strong believer of &quot;eh language doesn&#x27;t really matter&quot; erlang-based languages I do entertain a possible exception for.</div><br/><div id="36277742" class="c"><input type="checkbox" id="c-36277742" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36277180">parent</a><span>|</span><a href="#36277774">next</a><span>|</span><label class="collapse" for="c-36277742">[-]</label><label class="expand" for="c-36277742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think BEAM languages are kind of one of the few exceptions to this argument. Its tradeoffs and runtime semantics really are just very different from other mainstream languages.<p>Agree wholeheartedly. Elixir&#x2F;BEAM&#x2F;Erlang are a league of their own.</div><br/></div></div><div id="36277774" class="c"><input type="checkbox" id="c-36277774" checked=""/><div class="controls bullet"><span class="by">drowsspa</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36277180">parent</a><span>|</span><a href="#36277742">prev</a><span>|</span><a href="#36277553">next</a><span>|</span><label class="collapse" for="c-36277774">[-]</label><label class="expand" for="c-36277774">[3 more]</label></div><br/><div class="children"><div class="content">Never really played with the Erlang VM other than a little more than the Hello World in Elixir, but when I&#x27;m in the debugging hell of Apache Spark I really wish it wasn&#x27;t based on the JVM.</div><br/><div id="36278315" class="c"><input type="checkbox" id="c-36278315" checked=""/><div class="controls bullet"><span class="by">kaycey2022</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36277774">parent</a><span>|</span><a href="#36277553">next</a><span>|</span><label class="collapse" for="c-36278315">[-]</label><label class="expand" for="c-36278315">[2 more]</label></div><br/><div class="children"><div class="content">I think debugging in Elixir is easier precisely because of it functional immutable nature. To contrast it, take Ruby (Ruby on Rails) where objects will acquire functionality at runtime. That makes debugging particularly difficult especially if you have jumped into a new codebase with little context.</div><br/><div id="36279398" class="c"><input type="checkbox" id="c-36279398" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36278315">parent</a><span>|</span><a href="#36277553">next</a><span>|</span><label class="collapse" for="c-36279398">[-]</label><label class="expand" for="c-36279398">[1 more]</label></div><br/><div class="children"><div class="content">Java has breakpoints though.</div><br/></div></div></div></div></div></div><div id="36277553" class="c"><input type="checkbox" id="c-36277553" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36277180">parent</a><span>|</span><a href="#36277774">prev</a><span>|</span><a href="#36278046">next</a><span>|</span><label class="collapse" for="c-36277553">[-]</label><label class="expand" for="c-36277553">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, You might find <i>Handbook of Neuroevolution Through Erlang by Gene Sher</i> interesting.</div><br/></div></div></div></div><div id="36278046" class="c"><input type="checkbox" id="c-36278046" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36277084">parent</a><span>|</span><a href="#36277180">prev</a><span>|</span><a href="#36278185">next</a><span>|</span><label class="collapse" for="c-36278046">[-]</label><label class="expand" for="c-36278046">[2 more]</label></div><br/><div class="children"><div class="content">The interesting thing about BEAM languages is that they naturally treat the gpu as an asynchronously communicating resource.  No other language gets that abstraction correct.</div><br/><div id="36279318" class="c"><input type="checkbox" id="c-36279318" checked=""/><div class="controls bullet"><span class="by">qprofyeh</span><span>|</span><a href="#36277084">root</a><span>|</span><a href="#36278046">parent</a><span>|</span><a href="#36278185">next</a><span>|</span><label class="collapse" for="c-36279318">[-]</label><label class="expand" for="c-36279318">[1 more]</label></div><br/><div class="children"><div class="content">Just to inform the reader, the experimental WebGPU API does embrace async communications with rendering devices: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;GPUDevice" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;GPUDevice</a></div><br/></div></div></div></div></div></div><div id="36278185" class="c"><input type="checkbox" id="c-36278185" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#36277084">prev</a><span>|</span><a href="#36276845">next</a><span>|</span><label class="collapse" for="c-36278185">[-]</label><label class="expand" for="c-36278185">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Adding ML to X&quot; is a powerful way to probe what X is really made of and maybe even give direction to efforts to improve X.<p>That is because &quot;ML&quot; is a proxy for an entire domain (data science) that has both very distinct requirements and patterns developed over decades and is now evolving very fast as it broke out of the whitecoat lab and (for good or bad) into our lives.<p>The ascent of python is as the article noted &quot;accidental&quot; but that doesnt mean it is suboptimal given <i>all</i> the requirements of the domain and the available alternatives (here and now).<p>Its natural to focus on an exceptional attribute (like concurrency) to motivate even having the discussion but this addresses only one of three critical requirements if you decide to do everything within one langauge.<p>1) Ability to experiment interactively (REPL and friends), expressivity, human oriented language design etc<p>2) Ability to build production scale models (training or estimation phase) utilizing heterogeneous and fiddly compute<p>3) Ability to deploy to diverse devices and footprint &#x2F; latency requirements both natively and as part of a web application. NB: Its only here that the intrinsic qualities of erlang might put it above the rest<p>Historically there was never an ecosystem than could do all that optimally within just one language. Some of the requirements are arguably even incompatible.<p>The current preferred solution is not &quot;python&quot; but python&#x2F;c++ which does some of that well (1, 2) and 3 only passably.<p>The only declared single language contender is julia but its very far from being a complete ecosystem in the above sense.<p>Another emerging possibility is mojo, as a superset of python. But that is not even available yet.<p>Back to the erlang&#x2F;elixir combo. Its not even clear to me if it can address all of the above in a passable way.<p>But on the other hand ML is really shaking the game and what is mayne more imprortant is the vitality and resourcefulness of different communities to develop in the direction of the new rewuirement.<p>We have not seen the end of ecosystem evolution.</div><br/></div></div><div id="36276845" class="c"><input type="checkbox" id="c-36276845" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#36278185">prev</a><span>|</span><a href="#36277134">next</a><span>|</span><label class="collapse" for="c-36276845">[-]</label><label class="expand" for="c-36276845">[1 more]</label></div><br/><div class="children"><div class="content">There is a good talk about switching from Python to Elixir for a ML stack from ElixirCon 2022.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Y2Nr4dNu6hI">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Y2Nr4dNu6hI</a></div><br/></div></div><div id="36277134" class="c"><input type="checkbox" id="c-36277134" checked=""/><div class="controls bullet"><span class="by">rch</span><span>|</span><a href="#36276845">prev</a><span>|</span><a href="#36276614">next</a><span>|</span><label class="collapse" for="c-36277134">[-]</label><label class="expand" for="c-36277134">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Elixir&#x2F;Nx needs to check boxes in an exhaustive point by point comparison with Python to emerge as a viable platform for ML work. It&#x27;s a solid option, and that&#x27;s enough for me to invest some time exploring.</div><br/></div></div><div id="36276614" class="c"><input type="checkbox" id="c-36276614" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#36277134">prev</a><span>|</span><a href="#36277889">next</a><span>|</span><label class="collapse" for="c-36276614">[-]</label><label class="expand" for="c-36276614">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, anyone have an anecdote where using Python for data processing or machine learning became a performance problem?<p>My experience is that Python has so many high quality packages to deal with cpu intensive tasks that unless you absolutely cannot use them, for some reason, performance is rarely a problem. But I&#x27;d like to be informed about the exceptions.</div><br/><div id="36279046" class="c"><input type="checkbox" id="c-36279046" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36278207">next</a><span>|</span><label class="collapse" for="c-36279046">[-]</label><label class="expand" for="c-36279046">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run into some pretty straight-forward problems (eg: modeling physical systems, with linear algebra and some other basic math) where avoiding python for loops meant allocating memory up front for massive numpy, and then doing multiple separate vectorized operations on them rather than fusing all of them into a single for loop. Required several hundred GB of RAM and took a few hours IIRC. This was of course still better than Python for loops... &#x2F;facepalm<p>I wrote the same thing in Julia in about the same number of lines of code -- avoiding the sins above -- and I could run it on my laptop in a few seconds.</div><br/></div></div><div id="36278207" class="c"><input type="checkbox" id="c-36278207" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36279046">prev</a><span>|</span><a href="#36277224">next</a><span>|</span><label class="collapse" for="c-36278207">[-]</label><label class="expand" for="c-36278207">[1 more]</label></div><br/><div class="children"><div class="content">Not a single one of our data scientists knows how to use multiprocessing. Their jobs are all 1 CPU core, hundreds of gigabytes of RAM. The EC2 instances they run on end up wasting tons of cores, even with high-memory instances. This isn&#x27;t necessarily Python&#x27;s fault, but rather because Python has a lot of users who are not computer programmers.<p>One thing we <i>can</i> blame Python for is that the data scientists can&#x27;t ever loop over their data with a regular loop. Simply impossible; it&#x27;s too slow and would immediately wreck performance. They&#x27;re more Pandas programmers than they are Python programmers; everything has to be done with Pandas operations for performance to be acceptable.<p>This limits our (the computer programmers) ability to help out, because the languages we use are not slow like that, so we may give suggestions from our world that simply can&#x27;t be used in Python because it&#x27;s too slow. &quot;Can&#x27;t you just loop over the data and do XYZ?&quot; Nope, they can&#x27;t.<p>We still use Python because it&#x27;s all the data scientists know, and it&#x27;s easier&#x2F;cheaper to just write a bigger check to AWS than to hire people with both data science and computer programming backgrounds.</div><br/></div></div><div id="36277224" class="c"><input type="checkbox" id="c-36277224" checked=""/><div class="controls bullet"><span class="by">jebarker</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36278207">prev</a><span>|</span><a href="#36276672">next</a><span>|</span><label class="collapse" for="c-36277224">[-]</label><label class="expand" for="c-36277224">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve hit problems a couple of times with compute intensive data loading tasks in Pytorch.<p>One involved custom data augmentations on spatial graphs. I couldn&#x27;t find any python libraries that offered performant implementations of the functions needed and ended up writing custom C++ extensions to call from python.<p>The other involved running video encoders and decoders inside the dataloader. The problem was more Pytorch specific than python per se, but the way Pytorch handles multiprocessing and CUDA streams made efficient parallelism very difficult. It would have been much easier in C++.<p>I&#x27;ve also needed to ditch python for ML inference in production when extremely low latency was required.</div><br/></div></div><div id="36276672" class="c"><input type="checkbox" id="c-36276672" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36277224">prev</a><span>|</span><a href="#36278106">next</a><span>|</span><label class="collapse" for="c-36276672">[-]</label><label class="expand" for="c-36276672">[2 more]</label></div><br/><div class="children"><div class="content">At least for data processing pure python can quickly become a problem when handling somewhat large, dozens of GB, files. I&#x27;ve encountered this a few times and tge way to go is usually to either, if viable, port to a different language or only port the hot parts to a relevant library or Cython&#x2F;Rust with pyo3.</div><br/><div id="36277082" class="c"><input type="checkbox" id="c-36277082" checked=""/><div class="controls bullet"><span class="by">layoric</span><span>|</span><a href="#36276614">root</a><span>|</span><a href="#36276672">parent</a><span>|</span><a href="#36278106">next</a><span>|</span><label class="collapse" for="c-36277082">[-]</label><label class="expand" for="c-36277082">[1 more]</label></div><br/><div class="children"><div class="content">Out of interest, did you find this was a problem that using optimised numpy still didn’t perform good enough? (depending on what you call pure python, yes I agree python loops etc are extremely slow)</div><br/></div></div></div></div><div id="36278106" class="c"><input type="checkbox" id="c-36278106" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36276672">prev</a><span>|</span><a href="#36277146">next</a><span>|</span><label class="collapse" for="c-36278106">[-]</label><label class="expand" for="c-36278106">[1 more]</label></div><br/><div class="children"><div class="content">I rarely see performance problems that are show stoppers, especially in the cloud, where you can always just buy a bigger node. Usually if something is going to be rewritten C++&#x2F;Rust&#x2F;$performant_lang it&#x27;s that high velocity iteration on the codebase has mostly stopped and we could save 50-60% in infrastructure costs by running it on nodes with less resources. Then naturally you start to factor in the engineering manhours for the rewrite vs the potential savings.</div><br/></div></div><div id="36277146" class="c"><input type="checkbox" id="c-36277146" checked=""/><div class="controls bullet"><span class="by">efxhoy</span><span>|</span><a href="#36276614">parent</a><span>|</span><a href="#36278106">prev</a><span>|</span><a href="#36277889">next</a><span>|</span><label class="collapse" for="c-36277146">[-]</label><label class="expand" for="c-36277146">[1 more]</label></div><br/><div class="children"><div class="content">I wrote simulation software at a research department previously. 99.8% of the problems were perfect for numpy&#x2F;pandas and learning a compiled language wasn’t worth it for the 0.2%. If I was to work the same problems again I’d do it in two years when polars has all the good stuff from pandas and I’d learn enough rust to drop down to it for the custom stuff.</div><br/></div></div></div></div><div id="36277889" class="c"><input type="checkbox" id="c-36277889" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#36276614">prev</a><span>|</span><a href="#36277865">next</a><span>|</span><label class="collapse" for="c-36277889">[-]</label><label class="expand" for="c-36277889">[2 more]</label></div><br/><div class="children"><div class="content">I was hoping this was about the programming language ML on BEAM.</div><br/><div id="36277929" class="c"><input type="checkbox" id="c-36277929" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36277889">parent</a><span>|</span><a href="#36277865">next</a><span>|</span><label class="collapse" for="c-36277929">[-]</label><label class="expand" for="c-36277929">[1 more]</label></div><br/><div class="children"><div class="content">I thought this was a call for Standard ML or something a rather on the Erlang VM.<p>(I really enjoyed this article though!)<p>As far as I know theres a few implementations of ML like languages on the Erlang VM<p><a href="https:&#x2F;&#x2F;github.com&#x2F;llaisdy&#x2F;beam_languages">https:&#x2F;&#x2F;github.com&#x2F;llaisdy&#x2F;beam_languages</a><p>caramel and alpaca are worth checking out.<p>Gleam doesn&#x27;t look like a ML lang but has a lot of the same semantics of a ML lang</div><br/></div></div></div></div><div id="36277865" class="c"><input type="checkbox" id="c-36277865" checked=""/><div class="controls bullet"><span class="by">c7b</span><span>|</span><a href="#36277889">prev</a><span>|</span><a href="#36277729">next</a><span>|</span><label class="collapse" for="c-36277865">[-]</label><label class="expand" for="c-36277865">[1 more]</label></div><br/><div class="children"><div class="content">Great post. I&#x27;d be interested in a similar comparison when it comes to distributed computing&#x2F;concurrency&#x2F;fault tolerance&#x2F;scaling&#x2F;observability of Erlang&#x2F;Elixir&#x2F;Beam vs eg Rust or Go.</div><br/></div></div><div id="36277729" class="c"><input type="checkbox" id="c-36277729" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#36277865">prev</a><span>|</span><a href="#36278263">next</a><span>|</span><label class="collapse" for="c-36277729">[-]</label><label class="expand" for="c-36277729">[1 more]</label></div><br/><div class="children"><div class="content">&quot;It is ridiculous how easily I can swing together a Phoenix web app and add some ML smarts to it. &quot;<p>I&#x27;d rather optimize the current julia web app stack a bit and use with existing julia ML libraries.</div><br/></div></div><div id="36278263" class="c"><input type="checkbox" id="c-36278263" checked=""/><div class="controls bullet"><span class="by">lunatuna</span><span>|</span><a href="#36277729">prev</a><span>|</span><a href="#36277139">next</a><span>|</span><label class="collapse" for="c-36278263">[-]</label><label class="expand" for="c-36278263">[1 more]</label></div><br/><div class="children"><div class="content">This is like a game ad that doesn’t show you the actual game play. For all the arguments made the code wasn’t shown.</div><br/></div></div><div id="36277139" class="c"><input type="checkbox" id="c-36277139" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#36278263">prev</a><span>|</span><a href="#36278781">next</a><span>|</span><label class="collapse" for="c-36277139">[-]</label><label class="expand" for="c-36277139">[1 more]</label></div><br/><div class="children"><div class="content">If you want to experiment and tune ML, I think Python is great. Once you actually want other people to use it, C++ is the best.<p>The user experience of trying to set up one of the Python libraries for LLama vs llama.cpp is night and day.</div><br/></div></div><div id="36278781" class="c"><input type="checkbox" id="c-36278781" checked=""/><div class="controls bullet"><span class="by">moomoo11</span><span>|</span><a href="#36277139">prev</a><span>|</span><label class="collapse" for="c-36278781">[-]</label><label class="expand" for="c-36278781">[4 more]</label></div><br/><div class="children"><div class="content">I wish I could not use python and other languages with def whatever.<p>Can’t be the only one to dislike these languages. I don’t even care about languages that much, but I avoid AI stuff because I just can’t stand the python or elixir ecosystems. So much crap is required to get something basic working, although it’s less annoying with elixir.<p>Oh well</div><br/><div id="36279204" class="c"><input type="checkbox" id="c-36279204" checked=""/><div class="controls bullet"><span class="by">polvalente</span><span>|</span><a href="#36278781">parent</a><span>|</span><label class="collapse" for="c-36279204">[-]</label><label class="expand" for="c-36279204">[3 more]</label></div><br/><div class="children"><div class="content">Could elaborate on this? I&#x27;m genuinely curious about what annoys you regarding Elixir specifically.</div><br/><div id="36279475" class="c"><input type="checkbox" id="c-36279475" checked=""/><div class="controls bullet"><span class="by">moomoo11</span><span>|</span><a href="#36278781">root</a><span>|</span><a href="#36279204">parent</a><span>|</span><label class="collapse" for="c-36279475">[-]</label><label class="expand" for="c-36279475">[2 more]</label></div><br/><div class="children"><div class="content">Just the syntax really. I work primarily with Go TS Dart. I just never liked the ruby&#x2F;py syntax with def and lack of type safety.<p>I just stick to Go for all my backend needs. It does everything elixir is capable of and provides more than just raw IO handling without blowing up memory or struggling with computations. Never got into ruby either the syntax just makes me lose interest.</div><br/><div id="36279511" class="c"><input type="checkbox" id="c-36279511" checked=""/><div class="controls bullet"><span class="by">polvalente</span><span>|</span><a href="#36278781">root</a><span>|</span><a href="#36279475">parent</a><span>|</span><label class="collapse" for="c-36279511">[-]</label><label class="expand" for="c-36279511">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense! I on the other hand prefer more &quot;human-like&quot; syntax like Python and elixir provide, though I really dislike Python being so sensitive to whitespace (especially tabs vs spaces sensitivity)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>