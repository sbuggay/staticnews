<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689066068329" as="style"/><link rel="stylesheet" href="styles.css?v=1689066068329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mkirchner/hamt">Show HN: A hash array-mapped trie implementation in C</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mkirchner</span> | <span>36 comments</span></div><br/><div><div id="36673364" class="c"><input type="checkbox" id="c-36673364" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#36673611">next</a><span>|</span><label class="collapse" for="c-36673364">[-]</label><label class="expand" for="c-36673364">[1 more]</label></div><br/><div class="children"><div class="content">I discovered HAMTs first when Erlang added support for first-class maps, and it was sort of a &quot;holy shit!&quot; moment for me. They felt like the &quot;holy grail&quot; of data structures for me; I can treat any updates as &quot;copies&quot; without the cost of a copy.<p>About a year later, I learned Clojure, and fell even more in love with the data structure; when the language fully embraces a useful data structure, it changes the way you think about the entire program, and now it&#x27;s sort of hard for me to go back to languages that don&#x27;t have a good HAMT implementation.<p>I mean, I still do it, but I do think that having a &quot;go to standard&quot; in C really has the potential to set a great precedent.</div><br/></div></div><div id="36673611" class="c"><input type="checkbox" id="c-36673611" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#36673364">prev</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36673611">[-]</label><label class="expand" for="c-36673611">[18 more]</label></div><br/><div class="children"><div class="content">Just a note about your &#x27;exported memory allocation&#x27; API:<p><pre><code>    struct hamt_allocator {
        void *(*malloc)(const size_t size);
        void *(*realloc)(void *chunk, const size_t size);
        void (*free)(void *chunk);
    };
</code></pre>
This whole thing could just be:<p><pre><code>    struct hamt_allocator {
        void *cookie;
        void*  (*realloc) (struct hamt_allocator* h, void* chk, const size_t size);
    };
</code></pre>
With the following constraints:<p>1. `realloc(H, nullptr, N)` -- allocated N bytes<p>2. `realloc(H, p, 0)` -- frees the pointer p<p>3. `realloc(H, p, N)` -- resizes the pointer p<p>And, the user has access to a &#x27;context&#x27; (`cookie`) so they can use a (for instance) pool allocation scheme. Personally, I like a slightly different API:<p><pre><code>    struct hamt_allocator {
        void *cookie;
        void*  (*realloc) (struct hamt_allocator* h, void* chk, const size_t oldsize, const size_t newsize);
    };
</code></pre>
With the following constraints:<p>1. `realloc(H, nullptr, 0, N)` -- allocated N bytes<p>2. `realloc(H, p, N, 0)` -- frees the pointer p<p>3. `realloc(H, p, N, M)` -- resizes the pointer p<p>But I know a lot of people get confused and&#x2F;or don&#x27;t like having to pass (&amp; thus keep) so much information to the allocator.</div><br/><div id="36674390" class="c"><input type="checkbox" id="c-36674390" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36675901">next</a><span>|</span><label class="collapse" for="c-36674390">[-]</label><label class="expand" for="c-36674390">[3 more]</label></div><br/><div class="children"><div class="content">Sadly, this pattern doesn&#x27;t work with standard realloc() anymore. C23 makes this undefined behavior due to existing non-conforming implementations.<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2464.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2464.pdf</a></div><br/><div id="36676044" class="c"><input type="checkbox" id="c-36676044" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36674390">parent</a><span>|</span><a href="#36677231">next</a><span>|</span><label class="collapse" for="c-36676044">[-]</label><label class="expand" for="c-36676044">[1 more]</label></div><br/><div class="children"><div class="content">The pattern was never specified as fully working. Not in C99 and C90.<p>It&#x27;s due to the following reason: it was never specified that realloc(ptr, 0) behaves like free(ptr).<p>The case of size == 0 is not separately discussed in the C99 description of realloc.<p>realloc(ptr, 0) can behave like (free(ptr), malloc(0)), where malloc(0) doesn&#x27;t necessarily behave like ((void *) 0).  Malloc may return a unique object that may be later freed.<p>That is to say, realloc can effectively reduce an object to zero size without freeing it, or possibly even free an object only to replace it with a different, unique zero-sized object.<p>Note that in the case when ptr == NULL, which is discussed in C99, realloc behaves like malloc. So in the case realloc(NULL, 0), we know that it&#x27;s the same as malloc(0). That&#x27;s a case when size == 0, and realloc is required to behave like malloc.<p>This is a standard-conforming realloc, and always has been:<p><pre><code>  void *realloc(void *oldptr, size_t newsize)
  {
    size_t oldsize = __allocated_size(oldptr); &#x2F;&#x2F; this handles NULL, and returns 0

    void *newptr = malloc(newsize);

    if (newptr != NULL &amp;&amp; oldptr != NULL)
       memcpy(newptr, oldptr, min(newsize, oldsize);
    
    return newptr;
  }
</code></pre>
This realloc will not behave like free if malloc(0) returns unique pointers.<p>If you want a realloc-like function that behaves like an &quot;all in one allocator&quot;, you have to write your own:<p><pre><code>   void *git_reset_of_allocators(void *oldptr, size_t newsize)
   {
      if (size == 0) {
        free(oldptr);
        return NULL;
      } else { 
        &#x2F;&#x2F; handles all other cases OK
        return realloc(oldptr, newsize);
      }
   }</code></pre></div><br/></div></div><div id="36677231" class="c"><input type="checkbox" id="c-36677231" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36674390">parent</a><span>|</span><a href="#36676044">prev</a><span>|</span><a href="#36675901">next</a><span>|</span><label class="collapse" for="c-36677231">[-]</label><label class="expand" for="c-36677231">[1 more]</label></div><br/><div class="children"><div class="content">POSIX loosened its guarantee here too?<p><a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009696899&#x2F;functions&#x2F;realloc.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009696899&#x2F;functions&#x2F;re...</a><p><a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;functions&#x2F;realloc.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;functions&#x2F;r...</a></div><br/></div></div></div></div><div id="36675901" class="c"><input type="checkbox" id="c-36675901" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36674390">prev</a><span>|</span><a href="#36677078">next</a><span>|</span><label class="collapse" for="c-36675901">[-]</label><label class="expand" for="c-36675901">[3 more]</label></div><br/><div class="children"><div class="content">I would drop the API directly and concentrate on the algorithm.<p>If users integrating HAMT need a different allocator situation, they can solve that problem by themselves, without a run-time indirection shim.<p>You can help those users by providing some macros somewhere like #define hamt_malloc(ctx, x) malloc(x) and so forth, so it can be retargeted in one place. Leave an ignored context argument in place for those who would like to have a run-time switch per-instance.</div><br/><div id="36677406" class="c"><input type="checkbox" id="c-36677406" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36675901">parent</a><span>|</span><a href="#36676623">next</a><span>|</span><label class="collapse" for="c-36677406">[-]</label><label class="expand" for="c-36677406">[1 more]</label></div><br/><div class="children"><div class="content">I used macros in my libraries for overriding the allocation functions before, but have switched to runtime callbacks later, same for logging btw (I&#x27;d need to look through the issues list for the exact reasons which led to this decision though). In any case, passing callbacks as part of the initialization &quot;feels&quot; right and I didn&#x27;t hear any complaints since the switch (and it&#x27;s definitely a lot more convenient for the library user).<p>Also, if the library calls those function so frequently that the pointer indirection would be a performance problem, then there&#x27;s arguably something very wrong with the library&#x27;s design.</div><br/></div></div><div id="36676623" class="c"><input type="checkbox" id="c-36676623" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36675901">parent</a><span>|</span><a href="#36677406">prev</a><span>|</span><a href="#36677078">next</a><span>|</span><label class="collapse" for="c-36676623">[-]</label><label class="expand" for="c-36676623">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen this type of API design in C before, but not with a context. I&#x27;m curious where HAMT would get the ctx instance to pass to hamt_malloc in this design?</div><br/></div></div></div></div><div id="36677078" class="c"><input type="checkbox" id="c-36677078" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36675901">prev</a><span>|</span><a href="#36677350">next</a><span>|</span><label class="collapse" for="c-36677078">[-]</label><label class="expand" for="c-36677078">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I know a lot of people get confused and&#x2F;or don&#x27;t like having to pass (&amp; thus keep) so much information to the allocator.<p>That&#x27;s not why I think it&#x27; a bad idea.<p>I prefer the original because:<p>1. I can pass use the existing `free`, `malloc` and `realloc` implementations. By using a function with a different set of params I cannot do that. The user has to always write the `realloc` function you propose.<p>2. The interface for free, malloc and realloc is already documented, I don&#x27;t have to explain to the programmers what constraints are needed for their memory allocator function. Under your proposal the programmer has to now have, and read, the documentation</div><br/></div></div><div id="36677350" class="c"><input type="checkbox" id="c-36677350" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36677078">prev</a><span>|</span><a href="#36674428">next</a><span>|</span><label class="collapse" for="c-36677350">[-]</label><label class="expand" for="c-36677350">[1 more]</label></div><br/><div class="children"><div class="content">The advantage of the alloc&#x2F;realloc&#x2F;free interface is that you can simply plug in the standard functions malloc, realloc and free though, and any other allocator implementation which follows this convention without your own wrapper function inbetween.</div><br/></div></div><div id="36674428" class="c"><input type="checkbox" id="c-36674428" checked=""/><div class="controls bullet"><span class="by">cataphract</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36677350">prev</a><span>|</span><a href="#36675884">next</a><span>|</span><label class="collapse" for="c-36674428">[-]</label><label class="expand" for="c-36674428">[1 more]</label></div><br/><div class="children"><div class="content">The biggest advantages here are not having a single function, but instead:<p>1. Having a context.<p>2. Having free and realloc getting the old size. Not having the size passed is more or less consensually regarded as a mistake in the C stdlib.</div><br/></div></div><div id="36675884" class="c"><input type="checkbox" id="c-36675884" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36674428">prev</a><span>|</span><a href="#36674119">next</a><span>|</span><label class="collapse" for="c-36675884">[-]</label><label class="expand" for="c-36675884">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s also what Lua does: <a href="https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;5.3&#x2F;manual.html#lua_Alloc" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;5.3&#x2F;manual.html#lua_Alloc</a></div><br/></div></div><div id="36674119" class="c"><input type="checkbox" id="c-36674119" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#36673611">parent</a><span>|</span><a href="#36675884">prev</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36674119">[-]</label><label class="expand" for="c-36674119">[7 more]</label></div><br/><div class="children"><div class="content">I generally like this pattern, but why pass the allocator instead of the cookie?</div><br/><div id="36674280" class="c"><input type="checkbox" id="c-36674280" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36674119">parent</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36674280">[-]</label><label class="expand" for="c-36674280">[6 more]</label></div><br/><div class="children"><div class="content">If you want to &quot;shim&quot; the API, then it&#x27;s easier to have the whole previous object, rather than just the cookie.</div><br/><div id="36674462" class="c"><input type="checkbox" id="c-36674462" checked=""/><div class="controls bullet"><span class="by">cataphract</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36674280">parent</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36674462">[-]</label><label class="expand" for="c-36674462">[5 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need the cookie then. You can just allocate a larger struct (sort of subclassing it). You save a pointer indirection.</div><br/><div id="36675558" class="c"><input type="checkbox" id="c-36675558" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36674462">parent</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36675558">[-]</label><label class="expand" for="c-36675558">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a limit to what can be crammed into a HN comment!</div><br/><div id="36675647" class="c"><input type="checkbox" id="c-36675647" checked=""/><div class="controls bullet"><span class="by">pixelpoet</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36675558">parent</a><span>|</span><a href="#36675908">next</a><span>|</span><label class="collapse" for="c-36675647">[-]</label><label class="expand" for="c-36675647">[2 more]</label></div><br/><div class="children"><div class="content">I have discovered a truly marvelous allocator pattern which this HN comment is too small to contain.</div><br/><div id="36678114" class="c"><input type="checkbox" id="c-36678114" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36675647">parent</a><span>|</span><a href="#36675908">next</a><span>|</span><label class="collapse" for="c-36678114">[-]</label><label class="expand" for="c-36678114">[1 more]</label></div><br/><div class="children"><div class="content">[350 years later] I have confirmed the optimality of the allocator pattern as a special case in my proof of the Inter-universal Teichmüller theorem (Springer, 879pp).</div><br/></div></div></div></div><div id="36675908" class="c"><input type="checkbox" id="c-36675908" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#36673611">root</a><span>|</span><a href="#36675558">parent</a><span>|</span><a href="#36675647">prev</a><span>|</span><a href="#36678113">next</a><span>|</span><label class="collapse" for="c-36675908">[-]</label><label class="expand" for="c-36675908">[1 more]</label></div><br/><div class="children"><div class="content">The solution is obviously to realloc the comment.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36678113" class="c"><input type="checkbox" id="c-36678113" checked=""/><div class="controls bullet"><span class="by">query2</span><span>|</span><a href="#36673611">prev</a><span>|</span><a href="#36675361">next</a><span>|</span><label class="collapse" for="c-36678113">[-]</label><label class="expand" for="c-36678113">[1 more]</label></div><br/><div class="children"><div class="content">Is enum { N = 5; }; legal C now with the semiclolon inside the braces?</div><br/></div></div><div id="36675361" class="c"><input type="checkbox" id="c-36675361" checked=""/><div class="controls bullet"><span class="by">nnx</span><span>|</span><a href="#36678113">prev</a><span>|</span><a href="#36676218">next</a><span>|</span><label class="collapse" for="c-36675361">[-]</label><label class="expand" for="c-36675361">[3 more]</label></div><br/><div class="children"><div class="content">how does HAMTs compare with more recent designs like Swiss Tables? [1]<p>[1] <a href="https:&#x2F;&#x2F;abseil.io&#x2F;about&#x2F;design&#x2F;swisstables" rel="nofollow noreferrer">https:&#x2F;&#x2F;abseil.io&#x2F;about&#x2F;design&#x2F;swisstables</a></div><br/><div id="36678159" class="c"><input type="checkbox" id="c-36678159" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36675361">parent</a><span>|</span><a href="#36675523">next</a><span>|</span><label class="collapse" for="c-36678159">[-]</label><label class="expand" for="c-36678159">[1 more]</label></div><br/><div class="children"><div class="content">Completely unrelated.<p>The primary advantage of hamt is that they’re <i>persistent</i>, so they’re immutable with cheap update, but with efficient lookup &amp; good cache behaviour thanks to the dense nodes and high branching factor.</div><br/></div></div><div id="36675523" class="c"><input type="checkbox" id="c-36675523" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#36675361">parent</a><span>|</span><a href="#36678159">prev</a><span>|</span><a href="#36676218">next</a><span>|</span><label class="collapse" for="c-36675523">[-]</label><label class="expand" for="c-36675523">[1 more]</label></div><br/><div class="children"><div class="content">Swiss Tables are hash tables. O(1) lookup, but expensive to copy.<p>HAMTs are hash tries. O(log(n)) lookup, but persistent &#x2F; cheep to copy.<p>They are not really comparable, since hash tables are not persistent.<p>In functional languages, persistent data structures are MUCH more natural to work with. HAMTs we&#x27;re originally created for the Clojure standard library, IIRC.<p>HAMTs lend themselves to more elegant&#x2F;performant implementations than self-balancing trees, since they don&#x27;t need to rebalance as long as your hash function is good.<p>Also, HAMTs generally have a high branching factor, so the search can be as fast as a hash table for small-to-medium maps. Though I don&#x27;t know of any HAMTs using SIMD tricks like Swiss Table.<p>(EDIT: I guess the popcnt thing that HAMTs do would be considered a SIMD trick. Larger registers would allow the branching factor to be raised.)<p>Like hash tables, HAMTs don&#x27;t require intermediate key comparison for lookup.<p>The original HAMT paper is a good read: <a href="http:&#x2F;&#x2F;infoscience.epfl.ch&#x2F;record&#x2F;64398&#x2F;files&#x2F;idealhashtrees.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;infoscience.epfl.ch&#x2F;record&#x2F;64398&#x2F;files&#x2F;idealhashtrees...</a></div><br/></div></div></div></div><div id="36676218" class="c"><input type="checkbox" id="c-36676218" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#36675361">prev</a><span>|</span><a href="#36675559">next</a><span>|</span><label class="collapse" for="c-36676218">[-]</label><label class="expand" for="c-36676218">[2 more]</label></div><br/><div class="children"><div class="content">Are these the same as Crit-bit trees [0]?<p>[0]: <a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;critbit.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;cr.yp.to&#x2F;critbit.html</a><p>Edit: I think I understand now from the design section on your page, they are both tries, but the HAMT uses the hash of the key to locate the node whereas Crit-bit uses the key itself.</div><br/><div id="36676377" class="c"><input type="checkbox" id="c-36676377" checked=""/><div class="controls bullet"><span class="by">silasdavis</span><span>|</span><a href="#36676218">parent</a><span>|</span><a href="#36675559">next</a><span>|</span><label class="collapse" for="c-36676377">[-]</label><label class="expand" for="c-36676377">[1 more]</label></div><br/><div class="children"><div class="content">Crit bit tries are also, therefore, sorted. They can be iterated in order.<p>See also <a href="https:&#x2F;&#x2F;dotat.at&#x2F;prog&#x2F;qp&#x2F;README.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;dotat.at&#x2F;prog&#x2F;qp&#x2F;README.html</a></div><br/></div></div></div></div><div id="36675559" class="c"><input type="checkbox" id="c-36675559" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#36676218">prev</a><span>|</span><a href="#36677306">next</a><span>|</span><label class="collapse" for="c-36675559">[-]</label><label class="expand" for="c-36675559">[1 more]</label></div><br/><div class="children"><div class="content">Not much to add other than this is cool and the README was very informative. Nice work!</div><br/></div></div><div id="36675322" class="c"><input type="checkbox" id="c-36675322" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#36677306">prev</a><span>|</span><a href="#36676557">next</a><span>|</span><label class="collapse" for="c-36675322">[-]</label><label class="expand" for="c-36675322">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in persistent data structures for C++, then I highly recommend Immer. High quality and easy to work with.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer">https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer</a></div><br/></div></div><div id="36676557" class="c"><input type="checkbox" id="c-36676557" checked=""/><div class="controls bullet"><span class="by">robbintt</span><span>|</span><a href="#36675322">prev</a><span>|</span><a href="#36675858">next</a><span>|</span><label class="collapse" for="c-36676557">[-]</label><label class="expand" for="c-36676557">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool! I recently had GPT-4 write me a HAMT in C++, and it somewhat works, a lot of the basics are there. I ran out of time but am planning on fixing it up with instruct. It missed a lot of stuff and its tests run but they aren&#x27;t very good.</div><br/></div></div><div id="36675858" class="c"><input type="checkbox" id="c-36675858" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36676557">prev</a><span>|</span><a href="#36675582">next</a><span>|</span><label class="collapse" for="c-36675858">[-]</label><label class="expand" for="c-36675858">[1 more]</label></div><br/><div class="children"><div class="content">Doc fix: Iterators section repeats a code block with these declaration from the previous section:<p><pre><code>  size_t hamt_size(const struct hamt *trie);
  const void *hamt_get(const struct hamt *trie, void *key);</code></pre></div><br/></div></div><div id="36675582" class="c"><input type="checkbox" id="c-36675582" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#36675858">prev</a><span>|</span><label class="collapse" for="c-36675582">[-]</label><label class="expand" for="c-36675582">[5 more]</label></div><br/><div class="children"><div class="content">How does this compare to <a href="https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer">https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer</a> (other than the C&#x2F;C++ difference)?<p>Also, it&#x27;s my understanding that, in practice, persistent data structures require a garbage collector in order to handle deallocation when used in a general-purpose way. How does your implementation handle that?<p>Also, have you seen <a href="https:&#x2F;&#x2F;github.com&#x2F;cnuernber&#x2F;ham-fisted">https:&#x2F;&#x2F;github.com&#x2F;cnuernber&#x2F;ham-fisted</a> ? I think there are a few other Java-based persistent collections as well in the overall Clojure ecosystem that also improve on Hickey&#x27;s original implementation, but I can&#x27;t recall them now…</div><br/><div id="36676235" class="c"><input type="checkbox" id="c-36676235" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36675582">parent</a><span>|</span><label class="collapse" for="c-36676235">[-]</label><label class="expand" for="c-36676235">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How does your implementation handle that?<p>This is explained in the readme[1]. You can pass custom allocation functions (mallic, realloc, free), so you can plug in Boehm fex.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;mkirchner&#x2F;hamt#memory-management">https:&#x2F;&#x2F;github.com&#x2F;mkirchner&#x2F;hamt#memory-management</a></div><br/><div id="36676531" class="c"><input type="checkbox" id="c-36676531" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36675582">root</a><span>|</span><a href="#36676235">parent</a><span>|</span><label class="collapse" for="c-36676531">[-]</label><label class="expand" for="c-36676531">[3 more]</label></div><br/><div class="children"><div class="content">So refcounting?</div><br/><div id="36676934" class="c"><input type="checkbox" id="c-36676934" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36675582">root</a><span>|</span><a href="#36676531">parent</a><span>|</span><label class="collapse" for="c-36676934">[-]</label><label class="expand" for="c-36676934">[2 more]</label></div><br/><div class="children"><div class="content">Beohm is not refcounting, it&#x27;s a tracing GC.</div><br/><div id="36678005" class="c"><input type="checkbox" id="c-36678005" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#36675582">root</a><span>|</span><a href="#36676934">parent</a><span>|</span><label class="collapse" for="c-36678005">[-]</label><label class="expand" for="c-36678005">[1 more]</label></div><br/><div class="children"><div class="content">Boehm is not tracing, it&#x27;s a conservative GC.<p>PS admittedly, terminology is not precise enough in this space.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>