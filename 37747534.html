<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696323664195" as="style"/><link rel="stylesheet" href="styles.css?v=1696323664195"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nextword.substack.com/p/vector-database-is-not-a-separate">Every database will become a vector database sooner or later</a>Â <span class="domain">(<a href="https://nextword.substack.com">nextword.substack.com</a>)</span></div><div class="subtext"><span>nextworddev</span> | <span>45 comments</span></div><br/><div><div id="37748151" class="c"><input type="checkbox" id="c-37748151" checked=""/><div class="controls bullet"><span class="by">loondri</span><span>|</span><a href="#37748044">next</a><span>|</span><label class="collapse" for="c-37748151">[-]</label><label class="expand" for="c-37748151">[6 more]</label></div><br/><div class="children"><div class="content">I think the move towards vector databases might be more hype than necessity. Traditional databases, when properly optimized, can handle vector data for many use cases. The push for specialized vector databases could be re-evaluated in terms of efficiency and cost-effectiveness compared to optimizing existing scalar databases.</div><br/><div id="37748182" class="c"><input type="checkbox" id="c-37748182" checked=""/><div class="controls bullet"><span class="by">avereveard</span><span>|</span><a href="#37748151">parent</a><span>|</span><a href="#37748735">next</a><span>|</span><label class="collapse" for="c-37748182">[-]</label><label class="expand" for="c-37748182">[3 more]</label></div><br/><div class="children"><div class="content">Well you could store numbers all fine, but indexing vectors for similarity queries seems fairly recent and not all that widespread in the transactional world.<p>As the traditional db move forward in the space the need for dedicated vector databases will likely shrink, except for some very specific implementation that offer unique enough features (I.e. deeplake does vector search over object storage, which is very convenient for certain specific scenarios)</div><br/><div id="37749204" class="c"><input type="checkbox" id="c-37749204" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#37748151">root</a><span>|</span><a href="#37748182">parent</a><span>|</span><a href="#37748424">next</a><span>|</span><label class="collapse" for="c-37749204">[-]</label><label class="expand" for="c-37749204">[1 more]</label></div><br/><div class="children"><div class="content">What is &quot;vector search over object storage?&quot; Does deeplake performs some computations on objects and search on their embeddings?</div><br/></div></div><div id="37748424" class="c"><input type="checkbox" id="c-37748424" checked=""/><div class="controls bullet"><span class="by">sgu999</span><span>|</span><a href="#37748151">root</a><span>|</span><a href="#37748182">parent</a><span>|</span><a href="#37749204">prev</a><span>|</span><a href="#37748735">next</a><span>|</span><label class="collapse" for="c-37748424">[-]</label><label class="expand" for="c-37748424">[1 more]</label></div><br/><div class="children"><div class="content">sqlite has r-trees for instance [0]. Could it be good enough for most use cases? If it&#x27;s to query a knowledge base for instance, a couple dimensions should be sufficient. With the added benefit of being able to query your data in other ways.<p>[0] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;rtree.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;rtree.html</a></div><br/></div></div></div></div><div id="37748735" class="c"><input type="checkbox" id="c-37748735" checked=""/><div class="controls bullet"><span class="by">mnky9800n</span><span>|</span><a href="#37748151">parent</a><span>|</span><a href="#37748182">prev</a><span>|</span><a href="#37748044">next</a><span>|</span><label class="collapse" for="c-37748735">[-]</label><label class="expand" for="c-37748735">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, Vector databases does sound more official as &quot;new and important technology&quot; compared to the last db hype of NOSQL.</div><br/><div id="37748895" class="c"><input type="checkbox" id="c-37748895" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#37748151">root</a><span>|</span><a href="#37748735">parent</a><span>|</span><a href="#37748044">next</a><span>|</span><label class="collapse" for="c-37748895">[-]</label><label class="expand" for="c-37748895">[1 more]</label></div><br/><div class="children"><div class="content">I mean NOSQL was hype with no substance but &quot;you can scale more if you deal with not having ACID&quot; is just generally true.<p>Of course ACID scales to well into the Fortune 500 scale so...</div><br/></div></div></div></div></div></div><div id="37748044" class="c"><input type="checkbox" id="c-37748044" checked=""/><div class="controls bullet"><span class="by">muratsu</span><span>|</span><a href="#37748151">prev</a><span>|</span><a href="#37748146">next</a><span>|</span><label class="collapse" for="c-37748044">[-]</label><label class="expand" for="c-37748044">[3 more]</label></div><br/><div class="children"><div class="content">Supabase has pgvector extension and thatâ€™s enough for my limited RAG use cases. I dont really need to use anything beyond postgres. On the other hand, enterprise might find it easier&#x2F;cheaper to buy a second db than migrating their existing db to whatever the latest version. I dont think itâ€™s as simple</div><br/><div id="37748217" class="c"><input type="checkbox" id="c-37748217" checked=""/><div class="controls bullet"><span class="by">weird-eye-issue</span><span>|</span><a href="#37748044">parent</a><span>|</span><a href="#37748146">next</a><span>|</span><label class="collapse" for="c-37748217">[-]</label><label class="expand" for="c-37748217">[2 more]</label></div><br/><div class="children"><div class="content">Exactly. We use Supabase too but are at a scale where it just made sense to use a second, dedicated vector db (Pinecone) than to bloat our Postgres db that has a completely different workload</div><br/><div id="37749183" class="c"><input type="checkbox" id="c-37749183" checked=""/><div class="controls bullet"><span class="by">crazy_marksman</span><span>|</span><a href="#37748044">root</a><span>|</span><a href="#37748217">parent</a><span>|</span><a href="#37748146">next</a><span>|</span><label class="collapse" for="c-37749183">[-]</label><label class="expand" for="c-37749183">[1 more]</label></div><br/><div class="children"><div class="content">How do you deal with security and access control across postgres and pinecone?</div><br/></div></div></div></div></div></div><div id="37748146" class="c"><input type="checkbox" id="c-37748146" checked=""/><div class="controls bullet"><span class="by">aiappreciator</span><span>|</span><a href="#37748044">prev</a><span>|</span><a href="#37748536">next</a><span>|</span><label class="collapse" for="c-37748146">[-]</label><label class="expand" for="c-37748146">[3 more]</label></div><br/><div class="children"><div class="content">It is true that every major DB ventor, SQL or not, is smashing the AI&#x2F;vector keyword on their front pages. In Elastic for example, their vector capabilities have gone from laughable to respectable in  a year. Its a lot simpler to just use one DB instead of many.<p>But a question for true DB experts here:<p>1. Is there any real advantage to building a dedicated vector DB from scratch?<p>2. Is vector DB something that can be just &#x27;tacked on&#x27; to a normal DB with no major performance penalties?<p>We know from history, that data warehouses are genuinely different from databases, and cloud data warehouses are overwhelmingly superior to on-prem ones. So that emerged as a distinct, enduring category with Snowflake&#x2F;Databricks&#x2F;Bigquery.</div><br/><div id="37748253" class="c"><input type="checkbox" id="c-37748253" checked=""/><div class="controls bullet"><span class="by">jamesblonde</span><span>|</span><a href="#37748146">parent</a><span>|</span><a href="#37748499">next</a><span>|</span><label class="collapse" for="c-37748253">[-]</label><label class="expand" for="c-37748253">[1 more]</label></div><br/><div class="children"><div class="content">Data warehouses are columnar stores. They are very different from row-oriented databases - like Postgres, MySQL. Operations on columns - e.g., aggregations (mean of a column) are very efficient.<p>Most vector databases use one of a few different vector indexing libraries - FAISS, hnswlib, and scann (google only) are popular. The newer vector dbs, like weaviate, have introduced their own indexes, but i haven&#x27;t seen any performance difference -<p>Reference: <a href="https:&#x2F;&#x2F;ann-benchmarks.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ann-benchmarks.com&#x2F;</a></div><br/></div></div><div id="37748499" class="c"><input type="checkbox" id="c-37748499" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37748146">parent</a><span>|</span><a href="#37748253">prev</a><span>|</span><a href="#37748536">next</a><span>|</span><label class="collapse" for="c-37748499">[-]</label><label class="expand" for="c-37748499">[1 more]</label></div><br/><div class="children"><div class="content">The trade off that you are interested in isn&#x27;t about storing vectors, but rather about whether an index should be a part of the DBMS or external to it.<p>Some advantages of having a separate index is that it can work with different backends, it can be independently scaled, and it can index data for more than 1 database server.<p>Some disadvantages are increased latency, increased complexity, and distributed system problems.</div><br/></div></div></div></div><div id="37748536" class="c"><input type="checkbox" id="c-37748536" checked=""/><div class="controls bullet"><span class="by">pmm</span><span>|</span><a href="#37748146">prev</a><span>|</span><a href="#37748103">next</a><span>|</span><label class="collapse" for="c-37748536">[-]</label><label class="expand" for="c-37748536">[1 more]</label></div><br/><div class="children"><div class="content">I think just as with full-text search, vector search, if supported, will be full of tradeoffs for general purposes databases.<p>The view that everything needs to support direct input for generative AI is short sighted. There are other use cases as well. Even if ultimately these will become just building blocks for whatever AGI there comes. Horses for courses</div><br/></div></div><div id="37748103" class="c"><input type="checkbox" id="c-37748103" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#37748536">prev</a><span>|</span><a href="#37748466">next</a><span>|</span><label class="collapse" for="c-37748103">[-]</label><label class="expand" for="c-37748103">[1 more]</label></div><br/><div class="children"><div class="content">Sure, some companies will use it. Other companies will continue to use specialised focused tools.<p>It&#x27;s why data engineering is a thing in our industry. We move and prepare data for a set of tools, and we pay good money to do so, because we believe we derive value from those tools.<p>Let&#x27;s say MySQL offers it, anyone already using MySQL is likely to fence the MySQL instance(s) focused on vector stuff off for various reasons (resilience, different read&#x2F;write patterns, security, etc.)<p>MySQL as the (imaginary) basis only offers some transferable skills, because this DB will require different care and feeding.<p>Like the difference between Postgres and PG with cstore_fdw, similar, but sufficiently different.</div><br/></div></div><div id="37748466" class="c"><input type="checkbox" id="c-37748466" checked=""/><div class="controls bullet"><span class="by">_pdp_</span><span>|</span><a href="#37748103">prev</a><span>|</span><a href="#37748813">next</a><span>|</span><label class="collapse" for="c-37748466">[-]</label><label class="expand" for="c-37748466">[2 more]</label></div><br/><div class="children"><div class="content">I do agree with the article that this feature will be more or less available in all DB types.<p>Vector databases are a gimmick at the moment. Ultimately conversational AI agents should be able to extract information from a diverse set of sources with a diverse set of tools. The approach that is currently taken is hit-and-miss at best. How often do you searched something and the first result happens to be the thing you are looking for? Why should it be any different with vector DBs? Obviously the query matters a lot no matter how the information is searched.</div><br/><div id="37749048" class="c"><input type="checkbox" id="c-37749048" checked=""/><div class="controls bullet"><span class="by">nunodonato</span><span>|</span><a href="#37748466">parent</a><span>|</span><a href="#37748813">next</a><span>|</span><label class="collapse" for="c-37749048">[-]</label><label class="expand" for="c-37749048">[1 more]</label></div><br/><div class="children"><div class="content">hard disagree. Extracting information is much more costly (fetch data, feed data (which might be huge) into the model).<p>Embeddings work really well to store semantic meaning and are great for searching. Or, at least, a 1st stage of searching to filter out the non-relevant content.<p>I&#x27;m working on my own &quot;notes&quot; app, based on embeddings because I &#x27;m tired of never finding what I need due to bad search&#x2F;tagging&#x2F;categorizing</div><br/></div></div></div></div><div id="37748813" class="c"><input type="checkbox" id="c-37748813" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#37748466">prev</a><span>|</span><a href="#37748056">next</a><span>|</span><label class="collapse" for="c-37748813">[-]</label><label class="expand" for="c-37748813">[2 more]</label></div><br/><div class="children"><div class="content">This article is extremely correct and true, bordering on obvious. Vectors are a feature of a database engine that all engines will eventually offer -- not a new category of databases.</div><br/><div id="37749177" class="c"><input type="checkbox" id="c-37749177" checked=""/><div class="controls bullet"><span class="by">topicseed</span><span>|</span><a href="#37748813">parent</a><span>|</span><a href="#37748056">next</a><span>|</span><label class="collapse" for="c-37749177">[-]</label><label class="expand" for="c-37749177">[1 more]</label></div><br/><div class="children"><div class="content">Would you say the same about graph databases? (e.g., Neo4j, ArangoDB, Neptune)</div><br/></div></div></div></div><div id="37748056" class="c"><input type="checkbox" id="c-37748056" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#37748813">prev</a><span>|</span><a href="#37748124">next</a><span>|</span><label class="collapse" for="c-37748056">[-]</label><label class="expand" for="c-37748056">[1 more]</label></div><br/><div class="children"><div class="content">I just googled this now if MariaDB offers a vector search and the first hit is a stack overflow question from me in 2014. If they jumped on it then they could have been ahead of this AI business but noooo...</div><br/></div></div><div id="37748124" class="c"><input type="checkbox" id="c-37748124" checked=""/><div class="controls bullet"><span class="by">mlfia</span><span>|</span><a href="#37748056">prev</a><span>|</span><a href="#37748607">next</a><span>|</span><label class="collapse" for="c-37748124">[-]</label><label class="expand" for="c-37748124">[2 more]</label></div><br/><div class="children"><div class="content">Curious how this will work in practice as vectors are specific to a given embedding model, and could be domain-specific for better results. Could it lead to industry standard embedding models, with regular (costly) upgrades?</div><br/><div id="37748830" class="c"><input type="checkbox" id="c-37748830" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#37748124">parent</a><span>|</span><a href="#37748607">next</a><span>|</span><label class="collapse" for="c-37748830">[-]</label><label class="expand" for="c-37748830">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering the same thing. Standardization would be interesting but I wouldn&#x27;t bet on it. Maintaining different vector columns for different models might work well?</div><br/></div></div></div></div><div id="37748607" class="c"><input type="checkbox" id="c-37748607" checked=""/><div class="controls bullet"><span class="by">andre-z</span><span>|</span><a href="#37748124">prev</a><span>|</span><a href="#37748114">next</a><span>|</span><label class="collapse" for="c-37748607">[-]</label><label class="expand" for="c-37748607">[4 more]</label></div><br/><div class="children"><div class="content">ğ•ğğœğ­ğ¨ğ« ğƒğšğ­ğšğ›ğšğ¬ğğ¬ ğšğ«ğ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! You can just use traditional NoSQL DBs or Text Search Engines with Lucene-based vector index support. Who cares about performance, scalability, dedicated features, and resource costs? Keep it simple! Amen.<p>ğ’ğğšğ«ğœğ¡ ğ„ğ§ğ ğ¢ğ§ğğ¬ ğšğ«ğ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! You probably already use RDS like PostGres or similar. There is full-text index support included, so just use it instead and you do not need two different tools. BASE principles? Never heard about it. Only ACID rocks!<p>ğğ¨ğ’ğğ‹ ğƒğğ¬ ğšğ«ğ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! Modern relational databases support JSON-structured data fields. With a bit of workaround, you can achieve almost the same functionality. Monolith data storage architecture and one tool strategy for the win!<p>ğ‘ğğ¥ğšğ­ğ¢ğ¨ğ§ğšğ¥ ğƒğšğ­ğšğ›ğšğ¬ğğ¬ ğšğ«ğ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! Let&#x27;s use true foundational technology and store data in flat files. Files are super flexible and accept any structure of information, really any. What the future brings after vector embeddings, we will solve with just flat files. Let&#x27;s stick to the roots!<p>ğ…ğ¢ğ¥ğğ¬ ğ’ğ­ğ¨ğ«ğšğ ğğ¬ ğšğ«ğ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! ğ˜šğ˜°ğ˜§ğ˜µğ˜¸ğ˜¢ğ˜³ğ˜¦ ğ˜¸ğ˜¢ğ˜´ ğ˜¢ ğ˜®ğ˜ªğ˜´ğ˜µğ˜¢ğ˜¬ğ˜¦! Only hard copies on paper are authentic and secure. Used thousands of years ago by ancient people. So, it is proven by human history and cannot be wrong. Introducing new tools is just unnecessary complexity, produces costs, and brings other problems. Piece of paper and a pencil, no need for fancy devices, dramatic cost reduction. You only need to learn to write, that&#x27;s it!<p>ğğšğ©ğğ« ğ¢ğ¬ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! Remember what happened to the Library of Alexandria
? The human brain can keep all the information needed and we transfer it simply from generation to generation. Save the forests; just keep it in mind!<p>ğŒğğ¦ğ¨ğ«ğ² ğ¢ğ¬ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! Forget everything. Do not fill your brain with new information. Do not learn new stuff! Just relax and enjoy life!<p>I skipped Graph DBs, Object DBs, and Cave Paintings. Those are also overrated types of information storing and retrieval.</div><br/><div id="37748619" class="c"><input type="checkbox" id="c-37748619" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37748607">parent</a><span>|</span><a href="#37748755">next</a><span>|</span><label class="collapse" for="c-37748619">[-]</label><label class="expand" for="c-37748619">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ğŒğğ¦ğ¨ğ«ğ² ğ¢ğ¬ ğ¨ğ¯ğğ«ğ«ğšğ­ğğ! Forget everything. Do not fill your brain with new information. Do not learn new stuff! Just relax and enjoy life!<p>Okay, but like... as someone with a dissociative disorder this is scarily accurate<p>forget everything! Wake up one day and don&#x27;t remember what you did the previous day. It&#x27;s fine. Constantly run into friends you don&#x27;t remember making. It&#x27;s <i>fine</i>. Just be happy. Just be happy Just be happy Just be ha</div><br/></div></div><div id="37748755" class="c"><input type="checkbox" id="c-37748755" checked=""/><div class="controls bullet"><span class="by">BoorishBears</span><span>|</span><a href="#37748607">parent</a><span>|</span><a href="#37748619">prev</a><span>|</span><a href="#37748114">next</a><span>|</span><label class="collapse" for="c-37748755">[-]</label><label class="expand" for="c-37748755">[2 more]</label></div><br/><div class="children"><div class="content">Super lazy comment. SQL databases got JSON handling. NoSQL databases added indexes and ACID compliance.<p>An entire new class of databases that operate identically to existing ones with the exception of a single column type is silly, it&#x27;s only getting traction because of aggressive VC-funded marketing.</div><br/><div id="37749198" class="c"><input type="checkbox" id="c-37749198" checked=""/><div class="controls bullet"><span class="by">andre-z</span><span>|</span><a href="#37748607">root</a><span>|</span><a href="#37748755">parent</a><span>|</span><a href="#37748114">next</a><span>|</span><label class="collapse" for="c-37749198">[-]</label><label class="expand" for="c-37749198">[1 more]</label></div><br/><div class="children"><div class="content">Would you say the same about Keyword Search engines like Elastic, Solr, etc? It is just another column type, full-text index, that is available in any proper database. Just a hype...</div><br/></div></div></div></div></div></div><div id="37748114" class="c"><input type="checkbox" id="c-37748114" checked=""/><div class="controls bullet"><span class="by">jsemrau</span><span>|</span><a href="#37748607">prev</a><span>|</span><a href="#37748048">next</a><span>|</span><label class="collapse" for="c-37748114">[-]</label><label class="expand" for="c-37748114">[1 more]</label></div><br/><div class="children"><div class="content">The benefits of using specialized vendors like pinecone is about their offering a combination of performance (clustered&#x2F;loadbalancing), fast&#x2F;effective algorithms, and data storage.</div><br/></div></div><div id="37748048" class="c"><input type="checkbox" id="c-37748048" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#37748114">prev</a><span>|</span><a href="#37748111">next</a><span>|</span><label class="collapse" for="c-37748048">[-]</label><label class="expand" for="c-37748048">[9 more]</label></div><br/><div class="children"><div class="content">&gt; It genuinely makes sense for incumbent database players to offer vector search, because that eliminates unnecessary data movement to separate vector databases. Co-locating vectors and original documents also reduces latency.<p>Yet OLAP databases continue to thrive alongside OLTP databases, the nascence of NewSQL hybrid (HTAP) databases notwithstanding. Different needs dictate different design choices for optimality.</div><br/><div id="37749470" class="c"><input type="checkbox" id="c-37749470" checked=""/><div class="controls bullet"><span class="by">nhourcard</span><span>|</span><a href="#37748048">parent</a><span>|</span><a href="#37748346">next</a><span>|</span><label class="collapse" for="c-37749470">[-]</label><label class="expand" for="c-37749470">[1 more]</label></div><br/><div class="children"><div class="content">Different needs dictate different design choices for optimality.<p>Could not agree more. Even for time series, which could be seen as a subset of OLAP, trade-offs and design choices inherent to time-series data are necessary. As an example of a TSDB that I know well, QuestDB: Data is always ordered by time once it lands on the disk, the data is partitioned by time, and the ingestion protocol is conceived to stream large volumes of data, which can be either continuous or in bursts.</div><br/></div></div><div id="37748346" class="c"><input type="checkbox" id="c-37748346" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#37748048">parent</a><span>|</span><a href="#37749470">prev</a><span>|</span><a href="#37748096">next</a><span>|</span><label class="collapse" for="c-37748346">[-]</label><label class="expand" for="c-37748346">[2 more]</label></div><br/><div class="children"><div class="content">Is anyone considering a new OLAP system these days?  If â€œNewSQLâ€ (which seems to be a fancy buzzword for running analytics in your transactional database) takes off wont it be the final nail in the coffin for OLAP?</div><br/><div id="37749407" class="c"><input type="checkbox" id="c-37749407" checked=""/><div class="controls bullet"><span class="by">panda888888</span><span>|</span><a href="#37748048">root</a><span>|</span><a href="#37748346">parent</a><span>|</span><a href="#37748096">next</a><span>|</span><label class="collapse" for="c-37749407">[-]</label><label class="expand" for="c-37749407">[1 more]</label></div><br/><div class="children"><div class="content">I think the opposite concept, &quot;reverse ETL,&quot; is actually more popular. You put everything into your data warehouse and then pump whatever you need out from there.</div><br/></div></div></div></div><div id="37748096" class="c"><input type="checkbox" id="c-37748096" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37748048">parent</a><span>|</span><a href="#37748346">prev</a><span>|</span><a href="#37748111">next</a><span>|</span><label class="collapse" for="c-37748096">[-]</label><label class="expand" for="c-37748096">[5 more]</label></div><br/><div class="children"><div class="content">Itâ€™s interesting that I never considered why OLTP and OLAP are basically orthogonal technologies. Are there any major players that have an integrated solution for both?<p>I guess it makes sense because the infra is so different, but Iâ€™m not sure whether it need be.</div><br/><div id="37748565" class="c"><input type="checkbox" id="c-37748565" checked=""/><div class="controls bullet"><span class="by">xvinci</span><span>|</span><a href="#37748048">root</a><span>|</span><a href="#37748096">parent</a><span>|</span><a href="#37748171">next</a><span>|</span><label class="collapse" for="c-37748565">[-]</label><label class="expand" for="c-37748565">[1 more]</label></div><br/><div class="children"><div class="content">I think they have, they are just not that well known. E.g. SQL Server - <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;indexes&#x2F;columnstore-indexes-overview?view=sql-server-ver16" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;i...</a> - you can also find quite a lot of papers by microsoft employees on the designs and capabilities (starting around 2016 I believe, so &quot;pretty new&quot;). I have used it with TPC-H and it worked wonders, never got around to using it in a production workload though.</div><br/></div></div><div id="37748171" class="c"><input type="checkbox" id="c-37748171" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#37748048">root</a><span>|</span><a href="#37748096">parent</a><span>|</span><a href="#37748565">prev</a><span>|</span><a href="#37748166">next</a><span>|</span><label class="collapse" for="c-37748171">[-]</label><label class="expand" for="c-37748171">[1 more]</label></div><br/><div class="children"><div class="content">As far as the big players are concerned, Google offers AlloyDB (<a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;alloydb" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;alloydb</a>) while Amazon offers Aurora (<a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;rds&#x2F;aurora&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;rds&#x2F;aurora&#x2F;</a>)</div><br/></div></div><div id="37748166" class="c"><input type="checkbox" id="c-37748166" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#37748048">root</a><span>|</span><a href="#37748096">parent</a><span>|</span><a href="#37748171">prev</a><span>|</span><a href="#37748111">next</a><span>|</span><label class="collapse" for="c-37748166">[-]</label><label class="expand" for="c-37748166">[2 more]</label></div><br/><div class="children"><div class="content">Effecient OLAP queries need a different shape of data - some combination of columnar storage for efficient scanning, and roll-up tables with pre-aggregated measures. Even in an integrated scenario, behind the scenes there will need to be a bunch of copying to transpose and &#x2F; or refresh roll-ups.</div><br/><div id="37748262" class="c"><input type="checkbox" id="c-37748262" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#37748048">root</a><span>|</span><a href="#37748166">parent</a><span>|</span><a href="#37748111">next</a><span>|</span><label class="collapse" for="c-37748262">[-]</label><label class="expand" for="c-37748262">[1 more]</label></div><br/><div class="children"><div class="content">The pre-aggregation is one too many try and skip.  People seem to think they can build a single schema to rule all things, and then assume they can quickly calculate any aggregation on demand.</div><br/></div></div></div></div></div></div></div></div><div id="37748111" class="c"><input type="checkbox" id="c-37748111" checked=""/><div class="controls bullet"><span class="by">shri_krishna</span><span>|</span><a href="#37748048">prev</a><span>|</span><a href="#37748186">next</a><span>|</span><label class="collapse" for="c-37748111">[-]</label><label class="expand" for="c-37748111">[5 more]</label></div><br/><div class="children"><div class="content">The one DB fits all approach only works when the size of the database is really small and never grows. Imagine you have 100 customers. Each customer generates, on average, a million 1536 dimension vector embeddings (considering OpenAI Ada dimensions which is the most popular right now). That is 6GB (1536 x 4 bytes per dimension for f32 x 1000_000) of just embeddings PER CUSTOMER. If you use HNSW it will take at least that much of RAM if not more. If you use PQ (and variants) you can reduce the size of index in RAM to say 512MB-1GB per customer. It is still quite a lot of memory requirement. That is just the way it is and there is no way around it.<p>Now imagine you are using that database for storing transactions and other day to day business ops that will still be storing millions of records but with small indexes. This would have ideally only required a single DB instance with a replica for redundancy. Now if you integrate Vectors into the equation, you will have to needlessly scale this DB both horizontally and vertically just to maintain a decent query&#x2F;write performance to your DB (which would have ideally been extremely fast without embeddings in the mix). You will eventually separate the embeddings out as it makes no sense for the entire DB to be scaled just for the sake of scaling your embeddings. I am not even accounting for index generation for these vectors which will require nearly 100% of all CPU cores while the index is being generated (depending on type of ANN you are using) and which in turn would slow your DB to a crawl.</div><br/><div id="37748520" class="c"><input type="checkbox" id="c-37748520" checked=""/><div class="controls bullet"><span class="by">totetsu</span><span>|</span><a href="#37748111">parent</a><span>|</span><a href="#37748132">next</a><span>|</span><label class="collapse" for="c-37748520">[-]</label><label class="expand" for="c-37748520">[2 more]</label></div><br/><div class="children"><div class="content">Are there any DB that could support both use cases while being able to partition them in such a way that the transactions etc are only kept on part of the resources they need to be. Basically two seperated DBs but sharing the same interfaces and security etc.</div><br/><div id="37748726" class="c"><input type="checkbox" id="c-37748726" checked=""/><div class="controls bullet"><span class="by">shri_krishna</span><span>|</span><a href="#37748111">root</a><span>|</span><a href="#37748520">parent</a><span>|</span><a href="#37748132">next</a><span>|</span><label class="collapse" for="c-37748726">[-]</label><label class="expand" for="c-37748726">[1 more]</label></div><br/><div class="children"><div class="content">What you are talking about is possible to do in regular SQL dbs with extensions. However, when it comes to scaling traditional DBs don&#x27;t have the necessary tools to do so automatically. Most extensions provide support for an underlying ANN algorithm it implements and there&#x27;s that and nothing more. Everything else you&#x27;ll have to hand roll yourself.<p>Clustering, load balancing, aggregating queries etc are quite different for a vector database in comparison to traditional OLTP databases.<p>It&#x27;s the same as difference between OLAP vs OLTP. Both have different underlying architectural differences which make it incompatible for both to run in an integrated fashion.<p>For instance, in a traditional DB the index is maintained and rebuilt alongside data storage  and for scaling you can separate it into read&#x2F;write nodes. The write nodes typically only focus on building indexes while the read nodes for querying eventually consistent indexes (eventual consistency is achieved by broadcasting only the changed rows rather than sending entire index).<p>Now it&#x27;s similar in vector dbs too. You can seperate the indexer from query nodes (which access eventually consistent index). However, the load is way higher than a regular db as the index is humongous&#x2F;takes a long time to build and sharing the index with query nodes is also more time consuming and resource&#x2F;network intensive, as you won&#x27;t be sharing few rows but the entire index itself. It requires a totally different strategy to get all query nodes to be eventually consistent.<p>The only advantage of traditional DBs also implementing vector extensions is familiarity for the end user. If you are already familiar with postgres you wouldn&#x27;t want to leave your comfort zone. However, scaling a traditional DB is different from scaling a vector DB and you&#x27;ll encounter those pain points only in production and will be forced to switch to proper vector databases anyways.</div><br/></div></div></div></div><div id="37748132" class="c"><input type="checkbox" id="c-37748132" checked=""/><div class="controls bullet"><span class="by">beoberha</span><span>|</span><a href="#37748111">parent</a><span>|</span><a href="#37748520">prev</a><span>|</span><a href="#37748186">next</a><span>|</span><label class="collapse" for="c-37748132">[-]</label><label class="expand" for="c-37748132">[2 more]</label></div><br/><div class="children"><div class="content">Exactly - vector indexes are so different than traditional RDBMS B-Tree or LSM Tree indexes that it doesnâ€™t make sense to use the same store for both unless itâ€™s basically a toy app.<p>Someone makes the example in another comment, but itâ€™s analogous to OLTP vs OLAP</div><br/><div id="37748452" class="c"><input type="checkbox" id="c-37748452" checked=""/><div class="controls bullet"><span class="by">Foobar8568</span><span>|</span><a href="#37748111">root</a><span>|</span><a href="#37748132">parent</a><span>|</span><a href="#37748186">next</a><span>|</span><label class="collapse" for="c-37748452">[-]</label><label class="expand" for="c-37748452">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even want to imagine the workload on a high txn OLTP mixed with OLAP access pattern. 
IMHO If you can, you don&#x27;t need OLAP in the first place.</div><br/></div></div></div></div></div></div><div id="37748186" class="c"><input type="checkbox" id="c-37748186" checked=""/><div class="controls bullet"><span class="by">shaburn</span><span>|</span><a href="#37748111">prev</a><span>|</span><a href="#37748304">next</a><span>|</span><label class="collapse" for="c-37748186">[-]</label><label class="expand" for="c-37748186">[1 more]</label></div><br/><div class="children"><div class="content">Postgres and Mongo support it. ElasticSearch incorporates vector search. I have failed to identify an objective difference(beyond marketing nomeclature) between any pure play vector solution after exaustive research.</div><br/></div></div><div id="37748134" class="c"><input type="checkbox" id="c-37748134" checked=""/><div class="controls bullet"><span class="by">ooJeesh9fidujoh</span><span>|</span><a href="#37748304">prev</a><span>|</span><a href="#37748012">next</a><span>|</span><label class="collapse" for="c-37748134">[-]</label><label class="expand" for="c-37748134">[1 more]</label></div><br/><div class="children"><div class="content">The reason everyone&#x27;s rushing to build vector databases is because they&#x27;ve tried to store vector data in a scalar database previously and realized they&#x27;re hot garbage for the workload.<p>You should probably try it too before blogging about it.</div><br/></div></div></div></div></div></div></div></body></html>