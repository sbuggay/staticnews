<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695200461593" as="style"/><link rel="stylesheet" href="styles.css?v=1695200461593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/loopvar-preview">Fixing for loops in Go 1.22</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>354 comments</span></div><br/><div><div id="37578231" class="c"><input type="checkbox" id="c-37578231" checked=""/><div class="controls bullet"><span class="by">jjwiseman</span><span>|</span><a href="#37575812">next</a><span>|</span><label class="collapse" for="c-37578231">[-]</label><label class="expand" for="c-37578231">[5 more]</label></div><br/><div class="children"><div class="content">I know there are much earlier examples, but the earliest warning about this behavior I could find in 60 seconds of searching is from the comp.lang.lisp FAQ, posted more than 30 years ago, in 1992:<p><pre><code>    Mar 21, 1992, 1:00:47 AM
    Last-Modified: Tue Feb 25 17:34:30 1992 by Mark Kantrowitz
    ;;; ****************************************************************
    ;;; Answers to Frequently Asked Questions about Lisp ***************
    ;;; ****************************************************************
    ;;; Written by Mark Kantrowitz and Barry Margolin
    ;;; lisp-faq-3.text -- 16886 bytes
    
    [...]

    ----------------------------------------------------------------
    [3-9] Closures don&#x27;t seem to work properly when referring to the
    iteration variable in DOLIST, DOTIMES and DO.
    
    DOTIMES, DOLIST, and DO all use assignment instead of binding to
    update the value of the iteration variables. So something like
    
    (dotimes (n 10)
      (push #&#x27;(lambda () (incf n))
            *counters*))
    
    will produce 10 closures over the same value of the variable N.
    ----------------------------------------------------------------</code></pre></div><br/><div id="37581732" class="c"><input type="checkbox" id="c-37581732" checked=""/><div class="controls bullet"><span class="by">junke</span><span>|</span><a href="#37578231">parent</a><span>|</span><a href="#37580653">next</a><span>|</span><label class="collapse" for="c-37581732">[-]</label><label class="expand" for="c-37581732">[2 more]</label></div><br/><div class="children"><div class="content">In the standard it is not specified if such loops mutate or rebind, and you have to assume it doesn&#x27;t rebind if you capture variables. I do think however that once you learn how it works it stops being a problem (in any case I can select the form, macroexpand it and it shows how it&#x27;s implemented)</div><br/><div id="37581988" class="c"><input type="checkbox" id="c-37581988" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#37578231">root</a><span>|</span><a href="#37581732">parent</a><span>|</span><a href="#37580653">next</a><span>|</span><label class="collapse" for="c-37581988">[-]</label><label class="expand" for="c-37581988">[1 more]</label></div><br/><div class="children"><div class="content">In theory sure. In practice it&#x27;s easy enough to make this mistake mindlessly. I had this happen to me after many years of practice just this year (in an elaborate extended LOOP form which has same semantics).</div><br/></div></div></div></div><div id="37580653" class="c"><input type="checkbox" id="c-37580653" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#37578231">parent</a><span>|</span><a href="#37581732">prev</a><span>|</span><a href="#37578324">next</a><span>|</span><label class="collapse" for="c-37580653">[-]</label><label class="expand" for="c-37580653">[1 more]</label></div><br/><div class="children"><div class="content">D too <a href="https:&#x2F;&#x2F;issues.dlang.org&#x2F;show_bug.cgi?id=2043" rel="nofollow noreferrer">https:&#x2F;&#x2F;issues.dlang.org&#x2F;show_bug.cgi?id=2043</a>.<p>That&#x27;s actually expected when capturing by reference.</div><br/></div></div></div></div><div id="37575812" class="c"><input type="checkbox" id="c-37575812" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#37578231">prev</a><span>|</span><a href="#37576726">next</a><span>|</span><label class="collapse" for="c-37575812">[-]</label><label class="expand" for="c-37575812">[94 more]</label></div><br/><div class="children"><div class="content">The C# language team encountered this as well, after introducing lightweight closures in C# 4.0 it quickly became apparent that this was a footgun. Users almost always used loop variables incorrectly, and C# 5.0 made the breaking change.<p>Eric Lippert has a wonderful blog on the &quot;why&quot; from their perspective: <a href="https:&#x2F;&#x2F;ericlippert.com&#x2F;2009&#x2F;11&#x2F;12&#x2F;closing-over-the-loop-variable-considered-harmful-part-one&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ericlippert.com&#x2F;2009&#x2F;11&#x2F;12&#x2F;closing-over-the-loop-var...</a><p>I had a bit of trouble finding the original C# 5 announcement; that&#x27;s hopefully not been lost in the (several?) blog migrations on the Microsoft domain since 2012.</div><br/><div id="37576593" class="c"><input type="checkbox" id="c-37576593" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575812">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37576593">[-]</label><label class="expand" for="c-37576593">[66 more]</label></div><br/><div class="children"><div class="content">Meanwhile Python has received this same feature request many times over the years, and the answer is always that it would break existing code for little major benefit <a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;make-lambdas-proper-closures&#x2F;10553" rel="nofollow noreferrer">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;make-lambdas-proper-closures&#x2F;10...</a><p>Given how much of an uproar there was over changing the string type in the Python 2 -&gt; 3 transition, I can&#x27;t imagine this change would ever end up in Python before a 4.0.<p>Cue someone arguing about how bad Python is because it won&#x27;t fix these things, and then arguing about how bad Python is because their scripts from 2003 stopped working...</div><br/><div id="37577790" class="c"><input type="checkbox" id="c-37577790" checked=""/><div class="controls bullet"><span class="by">travisd</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576593">parent</a><span>|</span><a href="#37580700">next</a><span>|</span><label class="collapse" for="c-37577790">[-]</label><label class="expand" for="c-37577790">[23 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that it&#x27;s much less of a problem in Python due to the lack of ergonomic closures&#x2F;lambdas. You have to construct rather esoteric looking code for it to be a problem.<p><pre><code>    add_n = []
    for n in range(10):
        add_n.append(lambda x: x + n)
    add_n[9](10)  # 19
    add_n[0](10)  # 19
</code></pre>
This isn&#x27;t to say it&#x27;s *not* a footgun (and it has bit me in Python before), but it&#x27;s much worse in Go due to the idiomatic use of goroutines in a loop:<p><pre><code>    for i := 0; i &lt; 10; i++ {
        go func() { fmt.Printf(&quot;num: %d\n&quot;, i) }()
    }</code></pre></div><br/><div id="37579710" class="c"><input type="checkbox" id="c-37579710" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37579024">next</a><span>|</span><label class="collapse" for="c-37579710">[-]</label><label class="expand" for="c-37579710">[3 more]</label></div><br/><div class="children"><div class="content">In Python you are much more likely to hit that problem not with closures constructed with an explicit &#x27;lambda&#x27;, but with generator-comprehension expressions.<p><pre><code>    (((i, j) for i in &quot;abc&quot;) for j in range(3))
</code></pre>
The values of the above depends on in which order you evaluate the whole thing.<p>(Do take what I wrote with a grain of salt.  Either the above is already a problem, or perhaps you also need to mix in list-comprehension expressions, too, to surface the bug.)</div><br/><div id="37579819" class="c"><input type="checkbox" id="c-37579819" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579710">parent</a><span>|</span><a href="#37579024">next</a><span>|</span><label class="collapse" for="c-37579819">[-]</label><label class="expand" for="c-37579819">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this one is weird:<p><pre><code>  gs1 = (((i, j) for i in &quot;abc&quot;) for j in range(3))
  gs2 = [((i, j) for i in &quot;abc&quot;) for j in range(3)]

  print(list(map(list, gs1)))
  print(list(map(list, gs2)))
</code></pre>
Results:<p><pre><code>  [[(&#x27;a&#x27;, 0), (&#x27;b&#x27;, 0), (&#x27;c&#x27;, 0)], [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 1)], [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 2)]]
  [[(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 2)], [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 2)], [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 2)]]
</code></pre>
That&#x27;s a nice &quot;wat&quot; right there. I believe the explanation is that in gs2, the range() is iterated through immediately, so j is always set to 2 before you have a chance to access any of the inner generators. Whereas in gs1 the range() is still being iterated over as you access each inner generator, so when you access the first generator j=1, then j=2, etc.<p>Equivalents:<p><pre><code>  def make_gs1():
      for j in range(2):
          yield ((i, j) for i in &quot;abc&quot;)

  def make_gs2():
      gs = []
      for j in range(2):
          gs.append(((i, j) for i in &quot;abc&quot;))
      return gs
</code></pre>
Late binding applies in both cases of course, but in the first case it doesn&#x27;t matter, whereas in the latter case it matters.<p>I think early binding would produce the same result in both cases.</div><br/><div id="37580626" class="c"><input type="checkbox" id="c-37580626" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579819">parent</a><span>|</span><a href="#37579024">next</a><span>|</span><label class="collapse" for="c-37580626">[-]</label><label class="expand" for="c-37580626">[1 more]</label></div><br/><div class="children"><div class="content">or you could just be eager and use lists:<p><pre><code>    &gt;&gt;&gt; [[(i, j) for i in &quot;abc&quot;] for j in range(3)]
    [[(&#x27;a&#x27;, 0), (&#x27;b&#x27;, 0), (&#x27;c&#x27;, 0)], [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 1)], [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 2)]]</code></pre></div><br/></div></div></div></div></div></div><div id="37579024" class="c"><input type="checkbox" id="c-37579024" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37579710">prev</a><span>|</span><a href="#37578091">next</a><span>|</span><label class="collapse" for="c-37579024">[-]</label><label class="expand" for="c-37579024">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually <i>worse</i> in Python since there&#x27;s no support for variable lifetimes within a function, so the `v2` workaround is still broken. (the default-argument workaround &quot;works&quot; but is scary)<p>This makes it clear: the underlying problem is NOT about for loops - it&#x27;s closures that are broken.</div><br/><div id="37579324" class="c"><input type="checkbox" id="c-37579324" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579024">parent</a><span>|</span><a href="#37578091">next</a><span>|</span><label class="collapse" for="c-37579324">[-]</label><label class="expand" for="c-37579324">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not <i>broken</i>, it&#x27;s a different design. Maybe worse in a lot of cases, but it&#x27;s not broken. It&#x27;s working as intended.</div><br/><div id="37579713" class="c"><input type="checkbox" id="c-37579713" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579324">parent</a><span>|</span><a href="#37578091">next</a><span>|</span><label class="collapse" for="c-37579713">[-]</label><label class="expand" for="c-37579713">[1 more]</label></div><br/><div class="children"><div class="content">You could say the design is broken, but the implementation is working as intended by the design.</div><br/></div></div></div></div></div></div><div id="37578091" class="c"><input type="checkbox" id="c-37578091" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37579024">prev</a><span>|</span><a href="#37578388">next</a><span>|</span><label class="collapse" for="c-37578091">[-]</label><label class="expand" for="c-37578091">[9 more]</label></div><br/><div class="children"><div class="content">Everyone else solved this problem by using list comprehensions instead. Rob has surely heard of those.</div><br/><div id="37578628" class="c"><input type="checkbox" id="c-37578628" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578091">parent</a><span>|</span><a href="#37578682">next</a><span>|</span><label class="collapse" for="c-37578628">[-]</label><label class="expand" for="c-37578628">[5 more]</label></div><br/><div class="children"><div class="content">Of the two comprehension syntaxes in Haskell, Python picked the wrong one. Do notation (or, equivalently, Scala-style for&#x2F;yield) feels much more consistent and easy to use - in particular the clauses are in the same order as a regular for loop, rather than the middle-endian order used by list comprehensions.</div><br/><div id="37579720" class="c"><input type="checkbox" id="c-37579720" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578628">parent</a><span>|</span><a href="#37578682">next</a><span>|</span><label class="collapse" for="c-37579720">[-]</label><label class="expand" for="c-37579720">[4 more]</label></div><br/><div class="children"><div class="content">Haskell has both do-notation and list comprehension.<p>Comprehension in both Python and Haskell (for both lists and other structures) use the same order in both language, as far as I remember.</div><br/><div id="37579816" class="c"><input type="checkbox" id="c-37579816" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579720">parent</a><span>|</span><a href="#37578682">next</a><span>|</span><label class="collapse" for="c-37579816">[-]</label><label class="expand" for="c-37579816">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Haskell has both do-notation and list comprehension.<p>Right, and do-notation is the one everyone uses, because it&#x27;s better. Python picked the wrong one.<p>&gt; Comprehension in both Python and Haskell (for both lists and other structures) use the same order in both language, as far as I remember.<p>It may be the same order as Haskell but it&#x27;s a terrible confusing order. In particular if you want to go from a nested list comprehension to a flat one (or vice versa) then you have to completely rearrange the order it&#x27;s written in, whereas if you go from nested do-blocks to flat do-blocks then it all makes sense.</div><br/><div id="37581774" class="c"><input type="checkbox" id="c-37581774" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579816">parent</a><span>|</span><a href="#37579938">next</a><span>|</span><label class="collapse" for="c-37581774">[-]</label><label class="expand" for="c-37581774">[1 more]</label></div><br/><div class="children"><div class="content">When I was starting in Python years ago I had to turn my brain inside out to learn how to write list comprehensions. Sometimes I wonder what it&#x27;s like to be a normal person with a normal non-programmer brain, having forgotten it entirely these last many years.</div><br/></div></div><div id="37579938" class="c"><input type="checkbox" id="c-37579938" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579816">parent</a><span>|</span><a href="#37581774">prev</a><span>|</span><a href="#37578682">next</a><span>|</span><label class="collapse" for="c-37579938">[-]</label><label class="expand" for="c-37579938">[1 more]</label></div><br/><div class="children"><div class="content">I see what you mean, but I don&#x27;t find the order that confusing in neither Haskell or Python.<p>However, I can imagine a feature that we could add to Python to fix this: make it possible for statements to have a value.  Perhaps something like this:<p><pre><code>    my_generator = \
      for i in &quot;abc&quot;:
        for b in range(3):
          print(&quot;foo&quot;)
          yield (i, b)
</code></pre>
or perhaps have the last statement in block be its value (just like Rust or Ruby or Haskell do with the last statement in a block), and make the value of a for-loop be a generator of the individual values:<p><pre><code>    my_list = list(
      for i in &quot;abc&quot;:
        for b in range(3):
          (i, b))
</code></pre>
Though there&#x27;s a bit of confusion here whether the latter examples should be a flat structure or a nested one.  You could probably use a similiar mechanism as the existing &#x27;yield from&#x27; to explicitly ask for the flat version, and otherwise get the nested one:<p><pre><code>    my_list = list(
      for i in &quot;abc&quot;:
        yield from for b in range(3):
          (i, b))
</code></pre>
Making Python statements have values looks to me like the more generally useful change than tweaking comprehensions.  You&#x27;d probably not need comprehension at all in that case.  Especially since you can already write loop header and body on a single line like<p><pre><code>    for i in range(10): print(i)
</code></pre>
if they are short enough.</div><br/></div></div></div></div></div></div></div></div><div id="37578682" class="c"><input type="checkbox" id="c-37578682" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578091">parent</a><span>|</span><a href="#37578628">prev</a><span>|</span><a href="#37578908">next</a><span>|</span><label class="collapse" for="c-37578682">[-]</label><label class="expand" for="c-37578682">[2 more]</label></div><br/><div class="children"><div class="content">How does list comprehension change anything here? This has the same problem:<p><pre><code>    add_n = [lambda x: x + n for n in range(10)]
    add_n[9](10)  # 19
    add_n[0](10)  # 19</code></pre></div><br/><div id="37578982" class="c"><input type="checkbox" id="c-37578982" checked=""/><div class="controls bullet"><span class="by">billyjmc</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578682">parent</a><span>|</span><a href="#37578908">next</a><span>|</span><label class="collapse" for="c-37578982">[-]</label><label class="expand" for="c-37578982">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure what they mean by list comprehensions, either, but for completeness’s sake, I must point out that this is solvable by adding `n` as a keyword argument defaulting to `n`:<p><pre><code>    add_n = [lambda x, n=n: x + n for n in range(10)]
    add_n[9](10)  # 19
    add_n[0](10)  # 10</code></pre></div><br/></div></div></div></div></div></div><div id="37578388" class="c"><input type="checkbox" id="c-37578388" checked=""/><div class="controls bullet"><span class="by">jshen</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37578091">prev</a><span>|</span><a href="#37579701">next</a><span>|</span><label class="collapse" for="c-37578388">[-]</label><label class="expand" for="c-37578388">[2 more]</label></div><br/><div class="children"><div class="content">Doesn’t go vet complain about your code? I’m not at my computer right now so can’t check.</div><br/><div id="37581163" class="c"><input type="checkbox" id="c-37581163" checked=""/><div class="controls bullet"><span class="by">_ikke_</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578388">parent</a><span>|</span><a href="#37579701">next</a><span>|</span><label class="collapse" for="c-37581163">[-]</label><label class="expand" for="c-37581163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Tools have been written to identify these mistakes, but it is hard to analyze whether references to a variable outlive its iteration or not. These tools must choose between false negatives and false positives. The loopclosure analyzer used by go vet and gopls opts for false negatives, only reporting when it is sure there is a problem but missing others.<p>So it will warn in certain situations, but not all of them</div><br/></div></div></div></div><div id="37579701" class="c"><input type="checkbox" id="c-37579701" checked=""/><div class="controls bullet"><span class="by">Frotag</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37578388">prev</a><span>|</span><a href="#37578813">next</a><span>|</span><label class="collapse" for="c-37579701">[-]</label><label class="expand" for="c-37579701">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run into this once. IIRC the workaround was to add a n=n arg to the lambda</div><br/></div></div><div id="37578813" class="c"><input type="checkbox" id="c-37578813" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577790">parent</a><span>|</span><a href="#37579701">prev</a><span>|</span><a href="#37580700">next</a><span>|</span><label class="collapse" for="c-37578813">[-]</label><label class="expand" for="c-37578813">[4 more]</label></div><br/><div class="children"><div class="content">Ignoring the strange nature of this code in the first place the more pythonic way to do it would be<p><pre><code>    from functools import partial
    from operators import add

    add_n = [partial(add, n)) for n in range(10)]

    assert add_n[5](4) == 9
</code></pre>
Look ma, no closures.</div><br/><div id="37579723" class="c"><input type="checkbox" id="c-37579723" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578813">parent</a><span>|</span><a href="#37580700">next</a><span>|</span><label class="collapse" for="c-37579723">[-]</label><label class="expand" for="c-37579723">[3 more]</label></div><br/><div class="children"><div class="content">&#x27;partial&#x27; creates a closure for you.</div><br/><div id="37579907" class="c"><input type="checkbox" id="c-37579907" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579723">parent</a><span>|</span><a href="#37580700">next</a><span>|</span><label class="collapse" for="c-37579907">[-]</label><label class="expand" for="c-37579907">[2 more]</label></div><br/><div class="children"><div class="content">Unless you&#x27;re talking philosophically how classes and closures are actually isomorphic then no, it doesn&#x27;t. None of the variables in the outer scope are captured in the class instance.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;main&#x2F;Lib&#x2F;functools.py#L276">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;main&#x2F;Lib&#x2F;functools.py...</a><p>Here&#x27;s a simplified version of that code that demonstrates the pattern.<p><pre><code>    class partial:
      def __init__(self, func, *args, **kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs

      def __call__(self, *args, **kwargs):
        return self.func(*self.args, *args, **(self.kwargs | kwargs))

      p = partial(add, 5)  # -&gt; an instance of partial with self.args = (5,)
      res = p(4)  # -&gt; calls __call__ which merges the args and calls add(5, 4)</code></pre></div><br/><div id="37580481" class="c"><input type="checkbox" id="c-37580481" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579907">parent</a><span>|</span><a href="#37580700">next</a><span>|</span><label class="collapse" for="c-37580481">[-]</label><label class="expand" for="c-37580481">[1 more]</label></div><br/><div class="children"><div class="content">I was talking &#x27;philosophically&#x27; in that sense.  The partial object does create a new scope that binds a few of those variables.<p>But you are also right that the mechanisms in Python are different (on some suitable mid-level of abstraction) for those two.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37580700" class="c"><input type="checkbox" id="c-37580700" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576593">parent</a><span>|</span><a href="#37577790">prev</a><span>|</span><a href="#37577359">next</a><span>|</span><label class="collapse" for="c-37580700">[-]</label><label class="expand" for="c-37580700">[5 more]</label></div><br/><div class="children"><div class="content">Python is in a larger bind because it only has function scoping <i>and</i> variable declaration is implicit. It does not <i>have</i> sub-function scopes.<p>So does not really have a good way to fix the issue, even by using a different keyword as JS did.<p>OTOH default parameters being evaluated at function definition  make mitigating it relatively simple.</div><br/><div id="37580859" class="c"><input type="checkbox" id="c-37580859" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580700">parent</a><span>|</span><a href="#37577359">next</a><span>|</span><label class="collapse" for="c-37580859">[-]</label><label class="expand" for="c-37580859">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, block scoping is one of those &quot;weird CS ideas&quot; that I&#x27;m sure at some point early in Python&#x27;s design was deemed too complicated for the intended audience, but is also quite a natural way to prevent some human errors. JavaScript made the same mistake and later fixed it (let&#x2F;const).</div><br/><div id="37581563" class="c"><input type="checkbox" id="c-37581563" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580859">parent</a><span>|</span><a href="#37580885">next</a><span>|</span><label class="collapse" for="c-37581563">[-]</label><label class="expand" for="c-37581563">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a computer scientist so I can&#x27;t rule whether function scope was a mistake, and can&#x27;t see how block scoping would be considered too complicated, I personally think it fits much better with my mental model. Then again, Python doesn&#x27;t have blocks in the traditional sense of the word IIRC, in C style languages the accolades are a pretty clear delineator.<p>Parts of my previous job were terrible because it had JS functions thousands of lines of code long where variables were constantly reused (and often had to be unset before another block of code). That said, that wasn&#x27;t the fault of function scope per se, but of a bad but very productive developer.</div><br/><div id="37581700" class="c"><input type="checkbox" id="c-37581700" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37581563">parent</a><span>|</span><a href="#37580885">next</a><span>|</span><label class="collapse" for="c-37581700">[-]</label><label class="expand" for="c-37581700">[1 more]</label></div><br/><div class="children"><div class="content">TBF you can have block scoping in an indentation-based language, though it probably help to merge the too, as in Haskell: `let…in` will define variables in the `let` clause, and those variables are only accessible in the `in` clause (similarly case…of)</div><br/></div></div></div></div><div id="37580885" class="c"><input type="checkbox" id="c-37580885" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580859">parent</a><span>|</span><a href="#37581563">prev</a><span>|</span><a href="#37577359">next</a><span>|</span><label class="collapse" for="c-37580885">[-]</label><label class="expand" for="c-37580885">[1 more]</label></div><br/><div class="children"><div class="content">I love python, but it&#x27;s one of the biggest annoyances. Local variables like in Lua make a lot of sense.</div><br/></div></div></div></div></div></div><div id="37577359" class="c"><input type="checkbox" id="c-37577359" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576593">parent</a><span>|</span><a href="#37580700">prev</a><span>|</span><a href="#37578230">next</a><span>|</span><label class="collapse" for="c-37577359">[-]</label><label class="expand" for="c-37577359">[30 more]</label></div><br/><div class="children"><div class="content">Somehow, Go managed to not break old code and also fix the problem.<p>I think this is a good case of Python not fixing things, given that a fix exists that solves both problems.</div><br/><div id="37581896" class="c"><input type="checkbox" id="c-37581896" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577359">parent</a><span>|</span><a href="#37577452">next</a><span>|</span><label class="collapse" for="c-37581896">[-]</label><label class="expand" for="c-37581896">[1 more]</label></div><br/><div class="children"><div class="content">Python probably could change this with a from __future__ import, i.e. in the same way.</div><br/></div></div><div id="37577452" class="c"><input type="checkbox" id="c-37577452" checked=""/><div class="controls bullet"><span class="by">pcl</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577359">parent</a><span>|</span><a href="#37581896">prev</a><span>|</span><a href="#37577856">next</a><span>|</span><label class="collapse" for="c-37577452">[-]</label><label class="expand" for="c-37577452">[17 more]</label></div><br/><div class="children"><div class="content"><i>&gt; To ensure backwards compatibility with existing code, the new semantics will only apply in packages contained in modules that declare go 1.22 or later in their go.mod files.</i></div><br/><div id="37577699" class="c"><input type="checkbox" id="c-37577699" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577452">parent</a><span>|</span><a href="#37577758">next</a><span>|</span><label class="collapse" for="c-37577699">[-]</label><label class="expand" for="c-37577699">[3 more]</label></div><br/><div class="children"><div class="content">Right, and Go has the luxury of being a compiler that generates reasonably portable binaries, while Python requires the presence of an interpreter on the system at run time.</div><br/><div id="37580567" class="c"><input type="checkbox" id="c-37580567" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577699">parent</a><span>|</span><a href="#37577758">next</a><span>|</span><label class="collapse" for="c-37580567">[-]</label><label class="expand" for="c-37580567">[2 more]</label></div><br/><div class="children"><div class="content">The same trick would work with python just as well. There’s nothing about Python’s status as an interpreter which would stop them from adding a python semantic version somewhere in each python program - either in a comment at the top of each source file or in an adjacent config file. The comment could specify the version of python’s semantics to use, which would allow people to opt in to new syntax (or opt out of changes which may break the code in the future).<p>Eg # py 3.4</div><br/><div id="37581572" class="c"><input type="checkbox" id="c-37581572" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580567">parent</a><span>|</span><a href="#37577758">next</a><span>|</span><label class="collapse" for="c-37581572">[-]</label><label class="expand" for="c-37581572">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it would just mean that the interpreter - just like the Go compiler - would need to have the equivalent of &quot;if version &gt; 3.4 do this, else do that&quot;. Which is fine for a while, but I can imagine it adds a lot of complexity and edge cases to the interpreter &#x2F; compiler.<p>Which makes me think that a Go 2.0 or Python 4 will mainly be about removing branches and edge cases from the compiler more than making backwards-incompatible language changes.</div><br/></div></div></div></div></div></div><div id="37577758" class="c"><input type="checkbox" id="c-37577758" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577452">parent</a><span>|</span><a href="#37577699">prev</a><span>|</span><a href="#37577856">next</a><span>|</span><label class="collapse" for="c-37577758">[-]</label><label class="expand" for="c-37577758">[13 more]</label></div><br/><div class="children"><div class="content">Python could very easily have a similar mechanism. Hell even CMake manages to do this right, and they got &quot;if&quot; wrong.<p>The Python devs sometimes seem stubbornly attached to bugs. Another one: to reliably get Python 3 on Linux and Mac you have to run `python3`. But on Windows there&#x27;s no `python3.exe`.<p>Will they add one? Hell no. It might confuse people or something.<p>Except... if you install Python from the Microsoft Store it <i>does</i> have `python3.exe`.</div><br/><div id="37581506" class="c"><input type="checkbox" id="c-37581506" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577758">parent</a><span>|</span><a href="#37577893">next</a><span>|</span><label class="collapse" for="c-37581506">[-]</label><label class="expand" for="c-37581506">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Except... if you install Python from the Microsoft Store it does have `python3.exe`.<p>It&#x27;s worse. If you <i>don&#x27;t</i> install Python from the Microsoft Store there will still be a `python3.exe`. But running it just opens Microsoft Store.<p>Imagine how confused one could be when someone typed `python3 a.py` over a SSH session and nothing happened.</div><br/></div></div><div id="37577893" class="c"><input type="checkbox" id="c-37577893" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577758">parent</a><span>|</span><a href="#37581506">prev</a><span>|</span><a href="#37578526">next</a><span>|</span><label class="collapse" for="c-37577893">[-]</label><label class="expand" for="c-37577893">[6 more]</label></div><br/><div class="children"><div class="content">I’ve not run “python3” in years on my Mac, and I’m almost certain I never type it into Linux machines either; either I’m losing my mind, or there are some ludicrous takes in this thread.</div><br/><div id="37578105" class="c"><input type="checkbox" id="c-37578105" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577893">parent</a><span>|</span><a href="#37578526">next</a><span>|</span><label class="collapse" for="c-37578105">[-]</label><label class="expand" for="c-37578105">[5 more]</label></div><br/><div class="children"><div class="content">You are surely losing your mind then. Python3 isn&#x27;t something esoteric.</div><br/><div id="37578208" class="c"><input type="checkbox" id="c-37578208" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578105">parent</a><span>|</span><a href="#37578526">next</a><span>|</span><label class="collapse" for="c-37578208">[-]</label><label class="expand" for="c-37578208">[4 more]</label></div><br/><div class="children"><div class="content">Entirely possible, but my point was I just type “python” and Python 3 happens. Do modern OS even come with Python 2 anymore?<p>I’m not claiming any mystery about Python, just disputing how the modern version is invoked.</div><br/><div id="37580272" class="c"><input type="checkbox" id="c-37580272" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578208">parent</a><span>|</span><a href="#37578787">next</a><span>|</span><label class="collapse" for="c-37580272">[-]</label><label class="expand" for="c-37580272">[1 more]</label></div><br/><div class="children"><div class="content">Just tried &quot;python&quot; and &quot;python3&quot; on various Linux distros, which output respectively:<p>On an Ubuntu 20.04 desktop VM:<p><pre><code>  python  =&gt; Python 2.7.18 (default, Jul  1 2022, 12:27:04)
  python3 =&gt; Python 3.8.10 (default, May 26 2023, 14:05:08)
</code></pre>
On an Ubuntu 19.04 server:<p><pre><code>  python  =&gt; -bash: python: command not found
  python3 =&gt; Python 3.7.5 (default, Apr 19 2020, 20:18:17)
</code></pre>
On an Ubuntu 20.10 server:<p><pre><code>  python  =&gt; -bash: python: command not found
  python3 =&gt; Python 3.8.10 (default, Jun  2 2021, 10:49:15)
</code></pre>
I no longer have access to some RHEL7 and RHEL8 machines used for work recently, but if I recall correctly they do this by default:<p>Red Hat Enterprise Linux 7:<p><pre><code>  python  =&gt; Some version of Python 2
  python3 =&gt; Some version of Python 3
</code></pre>
Red Hat Enterprise Linux 8:<p><pre><code>  python  =&gt; -bash: python: command not found # (use &quot;python2&quot; for Python 2)
  python3 =&gt; Some version of Python 3
</code></pre>
You can change the default behaviour of unversioned &quot;python&quot; to version 2 or 3 on all the above systems, I think, so if you&#x27;re running a Linux distro when &quot;python&quot; gets you Python 3, that configuration might have been done already.<p>MacOS 10.15 (Catalina) does something interesting:<p><pre><code>  python  =&gt; WARNING: Python 2.7 is not recommended.
             This version is included in macOS for compatibility with legacy software.
             Future versions of macOS will not include Python 2.7.
             Instead, it is recommended that you transition to using &#x27;python3&#x27; from within Terminal.
             Python 2.7.16 (default, Jun  5 2020, 22:59:21)
  python3 =&gt; Python 3.8.2 (default, Jul 14 2020, 05:39:05)</code></pre></div><br/></div></div><div id="37578787" class="c"><input type="checkbox" id="c-37578787" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578208">parent</a><span>|</span><a href="#37580272">prev</a><span>|</span><a href="#37578393">next</a><span>|</span><label class="collapse" for="c-37578787">[-]</label><label class="expand" for="c-37578787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I just type “python” and Python 3 happens.<p>That was the old way. Python now recommends against installing Python3 in a way that does that, and most modern *nix don&#x27;t.</div><br/></div></div><div id="37578393" class="c"><input type="checkbox" id="c-37578393" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578208">parent</a><span>|</span><a href="#37578787">prev</a><span>|</span><a href="#37578526">next</a><span>|</span><label class="collapse" for="c-37578393">[-]</label><label class="expand" for="c-37578393">[1 more]</label></div><br/><div class="children"><div class="content">13.5.2 has &#x2F;usr&#x2F;bin&#x2F;python3 (it’s 3.9.6) but not python2 or just python. Not sure when they changed, and YMMV with Homebrew.</div><br/></div></div></div></div></div></div></div></div><div id="37578526" class="c"><input type="checkbox" id="c-37578526" checked=""/><div class="controls bullet"><span class="by">beeburrt</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577758">parent</a><span>|</span><a href="#37577893">prev</a><span>|</span><a href="#37577856">next</a><span>|</span><label class="collapse" for="c-37578526">[-]</label><label class="expand" for="c-37578526">[5 more]</label></div><br/><div class="children"><div class="content">&gt; to reliably get Python 3 on Linux and Mac you have to run `python3`.<p>This is not true on my Fedora 38 system, same with current Kali linux. Although, it is the case with Ubuntu 22.04.3.</div><br/><div id="37578739" class="c"><input type="checkbox" id="c-37578739" checked=""/><div class="controls bullet"><span class="by">wnoise</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578526">parent</a><span>|</span><a href="#37581110">next</a><span>|</span><label class="collapse" for="c-37578739">[-]</label><label class="expand" for="c-37578739">[3 more]</label></div><br/><div class="children"><div class="content">_reliably_, as in on the vast majority of machines.</div><br/><div id="37578993" class="c"><input type="checkbox" id="c-37578993" checked=""/><div class="controls bullet"><span class="by">billyjmc</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578739">parent</a><span>|</span><a href="#37581110">next</a><span>|</span><label class="collapse" for="c-37578993">[-]</label><label class="expand" for="c-37578993">[2 more]</label></div><br/><div class="children"><div class="content">Is that really python’s fault? It seems like it’s the distro making a design decision.</div><br/><div id="37579315" class="c"><input type="checkbox" id="c-37579315" checked=""/><div class="controls bullet"><span class="by">wnoise</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578993">parent</a><span>|</span><a href="#37581110">next</a><span>|</span><label class="collapse" for="c-37579315">[-]</label><label class="expand" for="c-37579315">[1 more]</label></div><br/><div class="children"><div class="content">Well, no, not python&#x27;s fault -- clearly the distros&#x27;, and they probably should be blamed.  But a PEP saying python2 and python3 should invoke the correct interpreter would help motivate the distributions.<p>(This is isomorphic to the usual victim-blaming discussion.  Fault and blame vs some ability to make a difference; it&#x27;s a shame that correctly pointing out a better strategy is both used to attack victims and attacked for attacking victims in the cases when that wasn&#x27;t intended.)</div><br/></div></div></div></div></div></div><div id="37581110" class="c"><input type="checkbox" id="c-37581110" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578526">parent</a><span>|</span><a href="#37578739">prev</a><span>|</span><a href="#37577856">next</a><span>|</span><label class="collapse" for="c-37581110">[-]</label><label class="expand" for="c-37581110">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean? Fedora 38 doesn&#x27;t have `python3`? Are you sure?</div><br/></div></div></div></div></div></div></div></div><div id="37577856" class="c"><input type="checkbox" id="c-37577856" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577359">parent</a><span>|</span><a href="#37577452">prev</a><span>|</span><a href="#37578345">next</a><span>|</span><label class="collapse" for="c-37577856">[-]</label><label class="expand" for="c-37577856">[7 more]</label></div><br/><div class="children"><div class="content">By letting you specify a language version requirement? Not exactly backwards compatible (because it is explicitly not, as per the article).<p>Python doesn’t make breaking changes in non-major versions, so as mentioned by the upthread comment the appropriate place for this change would be in Python 4.<p>Given the above, I’m really not sure what point you think you’re making in that final paragraph.</div><br/><div id="37577907" class="c"><input type="checkbox" id="c-37577907" checked=""/><div class="controls bullet"><span class="by">carbotaniuman</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577856">parent</a><span>|</span><a href="#37580640">next</a><span>|</span><label class="collapse" for="c-37577907">[-]</label><label class="expand" for="c-37577907">[5 more]</label></div><br/><div class="children"><div class="content">This seems weird to given the number of breakages and standard library changes I seem to run into every version.</div><br/><div id="37578233" class="c"><input type="checkbox" id="c-37578233" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577907">parent</a><span>|</span><a href="#37580640">next</a><span>|</span><label class="collapse" for="c-37578233">[-]</label><label class="expand" for="c-37578233">[4 more]</label></div><br/><div class="children"><div class="content">Really? I find that surprising. I don’t write as much code as I used to but I’ve been writing Python for a long time and the only standard library breakages that come to mind were during the infamous 2 -&gt; 3 days.<p>What sort of problems are have you faced upgrading minor versions?</div><br/><div id="37580832" class="c"><input type="checkbox" id="c-37580832" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578233">parent</a><span>|</span><a href="#37578353">next</a><span>|</span><label class="collapse" for="c-37580832">[-]</label><label class="expand" for="c-37580832">[1 more]</label></div><br/><div class="children"><div class="content">One of the few that I remember is fractions.gcd() -&gt; math.gcd().<p>See <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.0&#x2F;library&#x2F;fractions.html#fractions.gcd" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3.0&#x2F;library&#x2F;fractions.html#fractions...</a> , <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;library&#x2F;fractions.html#fractions.gcd" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;library&#x2F;fractions.html#fractions...</a> , <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.9&#x2F;library&#x2F;fractions.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3.9&#x2F;library&#x2F;fractions.html</a> (gone), <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;library&#x2F;math.html#math.gcd" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;library&#x2F;math.html#math.gcd</a></div><br/></div></div><div id="37578353" class="c"><input type="checkbox" id="c-37578353" checked=""/><div class="controls bullet"><span class="by">orbisvicis</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578233">parent</a><span>|</span><a href="#37580832">prev</a><span>|</span><a href="#37580640">next</a><span>|</span><label class="collapse" for="c-37578353">[-]</label><label class="expand" for="c-37578353">[2 more]</label></div><br/><div class="children"><div class="content">The docs are full of remarks like &quot;removed in 3.0 and reintroduced in 3.4&quot; or &quot;deprecated in 3.10&quot;, etc. A big one is the removal of the loop parameter in asyncio, but a lot of asyncio internals are (still?) undergoing significant changes, as getting the shutdown behavior correct is surprisingly difficult. Personally it&#x27;s never cause me any issues - I&#x27;m always on board with the changes.</div><br/><div id="37579778" class="c"><input type="checkbox" id="c-37579778" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578353">parent</a><span>|</span><a href="#37580640">next</a><span>|</span><label class="collapse" for="c-37579778">[-]</label><label class="expand" for="c-37579778">[1 more]</label></div><br/><div class="children"><div class="content">Asyncio was explicitly marked as provisional for years and most of the incompatible changes happened during that time. Same goes for typing. The rest of the language is very very stable.</div><br/></div></div></div></div></div></div></div></div><div id="37580640" class="c"><input type="checkbox" id="c-37580640" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577856">parent</a><span>|</span><a href="#37577907">prev</a><span>|</span><a href="#37578345">next</a><span>|</span><label class="collapse" for="c-37580640">[-]</label><label class="expand" for="c-37580640">[1 more]</label></div><br/><div class="children"><div class="content">They do and have made relatively small ones, e.g. promoting __future__ features to default, etc.</div><br/></div></div></div></div><div id="37578345" class="c"><input type="checkbox" id="c-37578345" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577359">parent</a><span>|</span><a href="#37577856">prev</a><span>|</span><a href="#37578230">next</a><span>|</span><label class="collapse" for="c-37578345">[-]</label><label class="expand" for="c-37578345">[4 more]</label></div><br/><div class="children"><div class="content">If the change &#x2F;doesn&#x27;t&#x2F; break old code, it&#x27;s also poorly justified.<p>It means code doesn&#x27;t care about the issue being addressed.<p>The feature is only justified if it changes existing code, such that bugs you didn&#x27;t even know about are fixed.<p>I.e. people read about the issue, investigate their code bases and go, oh hey, we actually have a latent bug here which the change will fix.</div><br/><div id="37579703" class="c"><input type="checkbox" id="c-37579703" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578345">parent</a><span>|</span><a href="#37579020">next</a><span>|</span><label class="collapse" for="c-37579703">[-]</label><label class="expand" for="c-37579703">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a second motivation in my opinion. Code might work today without the change, but it could be because the author originally wrote buggy code, caught it in testing, and had to waste time tracking it down and understanding nuances that don&#x27;t need to be there. Once they figured that out, they implemented an ugly workaround (adding an extra function parameter to a goroutine or shadowing the loop variable with n := n).<p>Good language designers want to avoid both wasting developer&#x27;s time and requiring ugly workarounds. Making a change that does both, especially if it doesn&#x27;t break old code, is great imo.</div><br/></div></div><div id="37579020" class="c"><input type="checkbox" id="c-37579020" checked=""/><div class="controls bullet"><span class="by">esrauch</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578345">parent</a><span>|</span><a href="#37579703">prev</a><span>|</span><a href="#37578230">next</a><span>|</span><label class="collapse" for="c-37579020">[-]</label><label class="expand" for="c-37579020">[2 more]</label></div><br/><div class="children"><div class="content">New code written today will use the new version and have the correct behavior from day 1.<p>Old code that is maintained will eventually be upgraded, which yes does come with work sometimes where you realize your code works on version X but not version X+10 and you do a combination of tests and reading patch notes to see what changed.</div><br/><div id="37579224" class="c"><input type="checkbox" id="c-37579224" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579020">parent</a><span>|</span><a href="#37578230">next</a><span>|</span><label class="collapse" for="c-37579224">[-]</label><label class="expand" for="c-37579224">[1 more]</label></div><br/><div class="children"><div class="content">There is no &quot;correct&quot; behavior here; either one is a valid choice that can be documented and that programs can rely on and exploit.<p>Code doesn&#x27;t care about when it&#x27;s written, only what you run it on, and with what compatibility options.<p>E.g. one possibility is that ten-year-old code that wrongly assumed the opposite behavior, and has a bug, will start to work correctly on the altered implementation.</div><br/></div></div></div></div></div></div></div></div><div id="37578230" class="c"><input type="checkbox" id="c-37578230" checked=""/><div class="controls bullet"><span class="by">orbisvicis</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576593">parent</a><span>|</span><a href="#37577359">prev</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37578230">[-]</label><label class="expand" for="c-37578230">[7 more]</label></div><br/><div class="children"><div class="content">Is it a bug? I&#x27;ve always depended on late-binding closures and I think even recently in a for loop, not that I&#x27;m going to go digging. You can do neat things with multiple functions sharing the same closure. If you don&#x27;t want the behavior bind the variable to a new name in a new scope. From the post I get the sense that this is more problematic for languages with pointers.</div><br/><div id="37578645" class="c"><input type="checkbox" id="c-37578645" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578230">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37578645">[-]</label><label class="expand" for="c-37578645">[6 more]</label></div><br/><div class="children"><div class="content">IMO it&#x27;s a misdesign in the same way as e.g. JavaScript&#x27;s &quot;this&quot;. Most languages figured out 40 or so years ago that scoping should be lexical.</div><br/><div id="37578898" class="c"><input type="checkbox" id="c-37578898" checked=""/><div class="controls bullet"><span class="by">orbisvicis</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578645">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37578898">[-]</label><label class="expand" for="c-37578898">[5 more]</label></div><br/><div class="children"><div class="content">The scope is lexical, the lookup is dynamic. What you want is for each loop iteration to create a new scope, which I would categorize as &quot;not lexical&quot;.</div><br/><div id="37579686" class="c"><input type="checkbox" id="c-37579686" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578898">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37579686">[-]</label><label class="expand" for="c-37579686">[4 more]</label></div><br/><div class="children"><div class="content">By that argument a recursive function shouldn&#x27;t create a new scope every time it recurses, and a language that fails Knuth&#x27;s 1964 benchmark of reasonable scoping (the &quot;man or boy test&quot;) would be fine. The loop body is lexically a block and like any other block it should have its own scope every time it runs.</div><br/><div id="37580533" class="c"><input type="checkbox" id="c-37580533" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579686">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37580533">[-]</label><label class="expand" for="c-37580533">[3 more]</label></div><br/><div class="children"><div class="content">Also, loop bodies <i>already did</i> have their own scope each iteration.<p>I wouldn&#x27;t say either behavior is non-lexical.  The only thing changing is which lexical scope these variables go into.</div><br/><div id="37580645" class="c"><input type="checkbox" id="c-37580645" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580533">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37580645">[-]</label><label class="expand" for="c-37580645">[2 more]</label></div><br/><div class="children"><div class="content">If the loop &quot;variable&quot; (and IMO thinking of it as a variable is halfway to making the mistake) is in a single scope whose lifetime is all passes through the loop body, that&#x27;s literally non-lexical; there is no block in the program text that corresponds to that scope. Lexically there&#x27;s the containing function and the loop body, there&#x27;s no intermediate scope nestled between them.</div><br/><div id="37581332" class="c"><input type="checkbox" id="c-37581332" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580645">parent</a><span>|</span><a href="#37575933">next</a><span>|</span><label class="collapse" for="c-37581332">[-]</label><label class="expand" for="c-37581332">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and IMO thinking of it as a variable is halfway to making the mistake<p>I used plural for a reason.<p>&gt; there is no block in the program text that corresponds to that scope.<p>The scope starts at the for.  There is a bunch of state that is tied to the loop, and if you rewrote it as a less magic kind of loop you&#x27;d need to explicitly mark a scope here.<p>What&#x27;s non-lexical about it?  You could replace &quot;for&quot; with &quot;{ for&quot; to see that a scope of &quot;all passes through the loop body&quot; does not require anything dynamic.<p>And surely whether a scope is implicit or explicit doesn&#x27;t change whether a scope is lexical.  In C I can write &quot;if (1) int x=2;&quot; and that x is scoped to an implicit block that ends at the semicolon.<p>Would you say an if with a declaration in it is non-lexical, because both the true block and the else block can access the variable?  I would just say the if has a scope, and there are two scopes inside it, all lexical.  And the same of a for loop having an outer and inner scope.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37575933" class="c"><input type="checkbox" id="c-37575933" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37575812">parent</a><span>|</span><a href="#37576593">prev</a><span>|</span><a href="#37578072">next</a><span>|</span><label class="collapse" for="c-37575933">[-]</label><label class="expand" for="c-37575933">[2 more]</label></div><br/><div class="children"><div class="content">jaredpar on the C# team offered the very first comment on the Github issue for this proposal: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56010">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56010</a><p>I think it played a large part in helping get past the default-deny that any language change proposal should have. The other big one for me was the scan done over the open source code base and the balance of bugs fixed versus created.</div><br/><div id="37576329" class="c"><input type="checkbox" id="c-37576329" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37575933">parent</a><span>|</span><a href="#37578072">next</a><span>|</span><label class="collapse" for="c-37576329">[-]</label><label class="expand" for="c-37576329">[1 more]</label></div><br/><div class="children"><div class="content">as soon as i saw mention of c# going through the same thing, i realized that this was discussed before: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33160236">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33160236</a></div><br/></div></div></div></div><div id="37578072" class="c"><input type="checkbox" id="c-37578072" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37575812">parent</a><span>|</span><a href="#37575933">prev</a><span>|</span><a href="#37576907">next</a><span>|</span><label class="collapse" for="c-37578072">[-]</label><label class="expand" for="c-37578072">[4 more]</label></div><br/><div class="children"><div class="content">Java also had this problem with anonymous classes. The solution is usually to introduce a functor. Being pass-by-value, it captures the state of the variables at its call time, which helps remove some ambiguity in your code.<p>If you try to do something weird with variable capture, then any collections you accumulate data into (eg, for turning an array into a map), will behave differently than any declared variables.<p>Go is trying to thread the needle by only having loop counters work this way. But that still means that some variables act weird (it&#x27;s just a variable that tends to act weird anyway). And I wonder what happens when you define multiple loop variables, which people often do when there will be custom scanning of the inputs.</div><br/><div id="37579741" class="c"><input type="checkbox" id="c-37579741" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578072">parent</a><span>|</span><a href="#37576907">next</a><span>|</span><label class="collapse" for="c-37579741">[-]</label><label class="expand" for="c-37579741">[3 more]</label></div><br/><div class="children"><div class="content">Which of the various meanings of the word &#x27;functor&#x27; are you using here?</div><br/><div id="37580493" class="c"><input type="checkbox" id="c-37580493" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579741">parent</a><span>|</span><a href="#37576907">next</a><span>|</span><label class="collapse" for="c-37580493">[-]</label><label class="expand" for="c-37580493">[2 more]</label></div><br/><div class="children"><div class="content">Function that returns a function.<p>You pass your counter into the function, it returns a function that remembers the original value, not the value as it keeps iterating later on in the caller.</div><br/><div id="37581753" class="c"><input type="checkbox" id="c-37581753" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580493">parent</a><span>|</span><a href="#37576907">next</a><span>|</span><label class="collapse" for="c-37581753">[-]</label><label class="expand" for="c-37581753">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just a higher order function?<p>That&#x27;s an interesting definition.  I thought you would either go with <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(functional_programming)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(functional_programmin...</a> or with <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_object" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_object</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(disambiguation)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(disambiguation)</a> has a few more choices, but doesn&#x27;t seem to have yours.</div><br/></div></div></div></div></div></div></div></div><div id="37576907" class="c"><input type="checkbox" id="c-37576907" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#37575812">parent</a><span>|</span><a href="#37578072">prev</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37576907">[-]</label><label class="expand" for="c-37576907">[20 more]</label></div><br/><div class="children"><div class="content">It is crazy that such behaviour even gets deployed<p>It is so unintuitive...</div><br/><div id="37577304" class="c"><input type="checkbox" id="c-37577304" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576907">parent</a><span>|</span><a href="#37577414">next</a><span>|</span><label class="collapse" for="c-37577304">[-]</label><label class="expand" for="c-37577304">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s unintuitive to users of the language, but it&#x27;s very intuitive from the perspective of those implementing the language. Everybody seems to make this mistake. Lua 5.0 (2003) made this mistake, but they fixed it in Lua 5.1 (2006). (Lua 5.0 was the first version with full lexical scoping.)</div><br/><div id="37577683" class="c"><input type="checkbox" id="c-37577683" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577304">parent</a><span>|</span><a href="#37577414">next</a><span>|</span><label class="collapse" for="c-37577683">[-]</label><label class="expand" for="c-37577683">[4 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s unintuitive to users of the language, but it&#x27;s very intuitive from the perspective of those implementing the language.<p>It sounds like a lack of dogfooding, lack of review?</div><br/><div id="37578168" class="c"><input type="checkbox" id="c-37578168" checked=""/><div class="controls bullet"><span class="by">catach</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577683">parent</a><span>|</span><a href="#37581748">next</a><span>|</span><label class="collapse" for="c-37578168">[-]</label><label class="expand" for="c-37578168">[1 more]</label></div><br/><div class="children"><div class="content">To the degree the the implementers are also users they carry their implementer understanding into their use. Dogfooding doesn&#x27;t help when your understanding doesn&#x27;t match that of your users.</div><br/></div></div><div id="37581748" class="c"><input type="checkbox" id="c-37581748" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577683">parent</a><span>|</span><a href="#37578168">prev</a><span>|</span><a href="#37578864">next</a><span>|</span><label class="collapse" for="c-37581748">[-]</label><label class="expand" for="c-37581748">[1 more]</label></div><br/><div class="children"><div class="content">No, it’s just an obvious behaviour when you understand how the language works.</div><br/></div></div><div id="37578864" class="c"><input type="checkbox" id="c-37578864" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577683">parent</a><span>|</span><a href="#37581748">prev</a><span>|</span><a href="#37577414">next</a><span>|</span><label class="collapse" for="c-37578864">[-]</label><label class="expand" for="c-37578864">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that the error conditions are relatively rare. Most of the time it doesn’t break anything. So even with dogfooding you can miss it or not see it as a problem early on. But after 10 years of evidence that it was a mistake, that it’s almost never intended, and the fix won’t break much if anything, it’s time to fix it.</div><br/></div></div></div></div></div></div><div id="37577414" class="c"><input type="checkbox" id="c-37577414" checked=""/><div class="controls bullet"><span class="by">gtowey</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37576907">parent</a><span>|</span><a href="#37577304">prev</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37577414">[-]</label><label class="expand" for="c-37577414">[14 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not crazy. It&#x27;s just the difference between a pointer and a value, which is like comp sci 101.<p>I think the main things that make it such a trap is that the variable type definition is implicit so the fact that it&#x27;s a pointer becomes a bit hidden, and that easy concurrency means the value is evaluated outside of the loop execution more often.</div><br/><div id="37581616" class="c"><input type="checkbox" id="c-37581616" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577414">parent</a><span>|</span><a href="#37577598">next</a><span>|</span><label class="collapse" for="c-37581616">[-]</label><label class="expand" for="c-37581616">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s just the difference between a pointer and a value, which is like comp sci 101.<p>That might be the case, but my comp sci 101 was 15 odd years ago now and since then I have _never_ had to think about pointers vs values, until I started a Go project a few years ago. But even that was more comprehensible than the pointer wizardry we had to do in C&#x2F;C++ back when.<p>I don&#x27;t want to have to think about managing my application&#x27;s memory, I much prefer being in the code, thinking of variable scope and maintainability which in a lot of languages automatically translates to healthy memory usage.</div><br/></div></div><div id="37577598" class="c"><input type="checkbox" id="c-37577598" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577414">parent</a><span>|</span><a href="#37581616">prev</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37577598">[-]</label><label class="expand" for="c-37577598">[12 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s not crazy.<p>No. Full disagree.<p>Array represents a concept of holding multiple values (let&#x27;s simplify) of the same type.<p>Loop (not index based) over array represents concept of going *over* array&#x27;s elements and executing some code body for each of it.<p>Now, if the behaviour isn&#x27;t that loop&#x27;s body is executed for each array element (let&#x27;s forget about returns, breaks, etc)<p>then the design is terrible (or implementation, but that&#x27;d mean that it was a bug)<p>I have totally no idea how can you design this thing in such a unintuitive way unless by mistake&#x2F;accidentally.</div><br/><div id="37578084" class="c"><input type="checkbox" id="c-37578084" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577598">parent</a><span>|</span><a href="#37578119">next</a><span>|</span><label class="collapse" for="c-37578084">[-]</label><label class="expand" for="c-37578084">[6 more]</label></div><br/><div class="children"><div class="content">The loop semantics do not have anything to do with arrays.  The point of confusion is whether a new slot for data is being created before each iteration, or whether the same slot is being used for each iteration.  It turns out that the same slot is being used.  The Go code itself is clear `for i := 0; i &lt; 10; i++`.  `i := 0` is where you declare i.  Nothing else would imply that space is being allocated for each iteration; the first clause of the (;;) statement is only run before the loop.  So you&#x27;re using the same i for every iteration.  This is surprising despite how explicit it is; programmers expect that a new slot is being allocated to store each value of i, so they take the address to it, and are surprised when it&#x27;s at the same address every iteration.  (Sugar like `for i, x := range xs` is even more confusing.  The := strongly implies creating a new i and x, but it&#x27;s not doing that!)<p>Basically, here are two pseudocode implementations.  This is what currently happens:<p><pre><code>     i = malloc(sizeof(int))
     *i = 0
   loop:
     &lt;code&gt;
     *i = *i + 1
     goto loop if *i &lt; 10
</code></pre>
This is what people expect:<p><pre><code>     secret = malloc(sizeof(int))
     *secret = 0
   loop:
     i = malloc(sizeof(int))
     *i = *secret
     &lt;code&gt;
     *secret = *secret + 1
     goto loop if *secret &lt; 10
</code></pre>
You can see that they are not crazy for picking the first implementation; it&#x27;s less instructions and less code, AND the for loop is pretty much exactly implementing what you&#x27;re typing in.  It&#x27;s just so easy to forget what you&#x27;re actually saying that most languages are choosing to do something like the second example (though no doubt, not allocating 8 bytes of memory for each iteration).<p>Remember, simple cases work:<p><pre><code>    for i := 0; i &lt; 10; i++ {
        fmt.Println(i) &#x2F;&#x2F; 0 1 2 3 4 ...
    }
</code></pre>
It&#x27;s the tricky cases that are tricky:<p><pre><code>    var is []*int
    for i := 0; i &lt; 10; i++ {
        is = append(is, &amp;i)
    }
    for _, i := range is {
       fmt.Println(*i) &#x2F;&#x2F; 9 9 9 9 9 ...
    }
</code></pre>
If you really think about it, the second example is exactly what you&#x27;re asking for.  You declared i into existence once.  Of course its address isn&#x27;t going to change every iteration.</div><br/><div id="37578669" class="c"><input type="checkbox" id="c-37578669" checked=""/><div class="controls bullet"><span class="by">beeburrt</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578084">parent</a><span>|</span><a href="#37578440">next</a><span>|</span><label class="collapse" for="c-37578669">[-]</label><label class="expand" for="c-37578669">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m getting 10s for your last code example (not 9s)</div><br/><div id="37579552" class="c"><input type="checkbox" id="c-37579552" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578669">parent</a><span>|</span><a href="#37578440">next</a><span>|</span><label class="collapse" for="c-37579552">[-]</label><label class="expand" for="c-37579552">[1 more]</label></div><br/><div class="children"><div class="content">Ah yup.  I didn&#x27;t test it and you normally never see i after that last increment!</div><br/></div></div></div></div><div id="37578440" class="c"><input type="checkbox" id="c-37578440" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578084">parent</a><span>|</span><a href="#37578669">prev</a><span>|</span><a href="#37578119">next</a><span>|</span><label class="collapse" for="c-37578440">[-]</label><label class="expand" for="c-37578440">[3 more]</label></div><br/><div class="children"><div class="content">&gt;The loop semantics do not have anything to do with arrays.<p>Loop in general or &quot;for each&quot; style loop, that&#x27;s huge difference.<p>The 2nd one has a lot to do with collections.<p>&gt;You can see that they are not crazy for picking the first implementation; it&#x27;s less instructions and less code<p>Yes, it is not crazy when you&#x27;re looking at it from the reverse engineering &#x2F; implementation side<p>but if you start thinking about it from user&#x27;s perspective then it is very bad behaviour<p>because they used &quot;foreach&quot; like loop which is a concept of walking thru every element of collection.</div><br/><div id="37580823" class="c"><input type="checkbox" id="c-37580823" checked=""/><div class="controls bullet"><span class="by">kweingar</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578440">parent</a><span>|</span><a href="#37578119">next</a><span>|</span><label class="collapse" for="c-37580823">[-]</label><label class="expand" for="c-37580823">[2 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t see how looping over a collection is different from looping over a sequence of numbers from 1 to n.</div><br/><div id="37580913" class="c"><input type="checkbox" id="c-37580913" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37580823">parent</a><span>|</span><a href="#37578119">next</a><span>|</span><label class="collapse" for="c-37580913">[-]</label><label class="expand" for="c-37580913">[1 more]</label></div><br/><div class="children"><div class="content">Depends what do you actually mean by sequence, but mostly purpose.<p>Normal &quot;for&quot; is like: repeat this code body as long as condition is satisfied<p>Foreach is more like: walk thru this collection<p>Look (c#):<p>foreach (var item in items) ...<p>for (int i=0; i&lt;10; i++) { }<p>In the 2nd version it is possible to jumps ahead, back, do not move, etc. Generally play around &quot;i&#x27;s&quot; values<p>Meanwhile I haven&#x27;t seen yet any1 trying to do anything like this in foreach, because it is meant for just walking thru collection</div><br/></div></div></div></div></div></div></div></div><div id="37578119" class="c"><input type="checkbox" id="c-37578119" checked=""/><div class="controls bullet"><span class="by">mik1998</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577598">parent</a><span>|</span><a href="#37578084">prev</a><span>|</span><a href="#37578114">next</a><span>|</span><label class="collapse" for="c-37578119">[-]</label><label class="expand" for="c-37578119">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know much about Go but the design seems very intuitive to me. You&#x27;re doing something like (let ((i variable)) (loop (setf i ...) ...body)), which if there is a closure in the loop body will capture the variable i and also subsequent mutations.<p>The fix is to make a new variable for each iteration, which is less obvious implementation wise but as per the post works better if you&#x27;re enclosing over the loop variable.</div><br/><div id="37579758" class="c"><input type="checkbox" id="c-37579758" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578119">parent</a><span>|</span><a href="#37578114">next</a><span>|</span><label class="collapse" for="c-37579758">[-]</label><label class="expand" for="c-37579758">[1 more]</label></div><br/><div class="children"><div class="content">And an optimizing compiler can reduce your latter case to the former, if they can prove it&#x27;s safe to do so.</div><br/></div></div></div></div><div id="37578114" class="c"><input type="checkbox" id="c-37578114" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37577598">parent</a><span>|</span><a href="#37578119">prev</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37578114">[-]</label><label class="expand" for="c-37578114">[3 more]</label></div><br/><div class="children"><div class="content">If I understood the example, Java had this same problem. I&#x27;m wondering if C# does as well.</div><br/><div id="37579180" class="c"><input type="checkbox" id="c-37579180" checked=""/><div class="controls bullet"><span class="by">xmcqdpt2</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37578114">parent</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37579180">[-]</label><label class="expand" for="c-37579180">[2 more]</label></div><br/><div class="children"><div class="content">It would be hard to trigger it in Java. All references are pass-by-value, so you would have to do something like creating an array, passing that array and then replacing an element in it in on every loop iteration. Unless I got something wrong, it would be hard to do this by mistake IMO.</div><br/><div id="37580408" class="c"><input type="checkbox" id="c-37580408" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37575812">root</a><span>|</span><a href="#37579180">parent</a><span>|</span><a href="#37578122">next</a><span>|</span><label class="collapse" for="c-37580408">[-]</label><label class="expand" for="c-37580408">[1 more]</label></div><br/><div class="children"><div class="content">If you do an asynchronous callback in an inner loop that tries to log the loop counter and a calculated value at the same time, you will find that the loop counter has incremented underneath you and you&#x27;ll get for instance &#x27;20&#x27; for all of the logs.  That was my introduction to this sort of problem.<p>The solution as I said elsewhere is to pop out the inner block to a separate function, where the value of the counter is captured when the outer function is called, not when the inner one runs.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37576726" class="c"><input type="checkbox" id="c-37576726" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#37575812">prev</a><span>|</span><a href="#37576394">next</a><span>|</span><label class="collapse" for="c-37576726">[-]</label><label class="expand" for="c-37576726">[5 more]</label></div><br/><div class="children"><div class="content">I think <a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2019&#x2F;go-internals-capturing-loop-variables-in-closures&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2019&#x2F;go-internals-capturing-lo...</a> describes the problem in more detail?</div><br/><div id="37577337" class="c"><input type="checkbox" id="c-37577337" checked=""/><div class="controls bullet"><span class="by">msteffen</span><span>|</span><a href="#37576726">parent</a><span>|</span><a href="#37577536">next</a><span>|</span><label class="collapse" for="c-37577337">[-]</label><label class="expand" for="c-37577337">[3 more]</label></div><br/><div class="children"><div class="content">This post was great—thanks for posting it!<p>Interestingly, the reason the old i := i trick works is not at all what I thought!<p>The trick, for reference:<p><pre><code>    for i := 0; i &lt; 5; i++ {
     i := i  &#x2F;&#x2F; the trick 
     go func() {
      print(i)
     }()
    }
</code></pre>
What I assumed happened:<p>- The escape analyzer sees that the new `i` is passed to a goroutine, so it is marked as escaping its lexical scope<p>- Because it&#x27;s escaping its lexical scope, the allocator allocates it on the heap<p>- One heap allocation is done per loop iteration, and even though the new `i` is captured by reference, each goro holds a unique reference to a unique memory location<p>What actually happens:<p>- Go&#x27;s compiler has heuristics to decide whether to capture by reference or by value. One component of the heuristic is that values that aren&#x27;t updated after initialization are captured by value<p>- The new i is scoped to the for loop body, and is not updated by the for loop itself. Therefore it&#x27;s identified as a value that isn&#x27;t updated after initialization<p>- As a result, the Go compiler generates code that captures `i` by value instead of by reference. No heap allocations or anything like that are done.<p>I recognize that the latter behavior is better, but if anyone with intimate knowledge of Go knows why the former doesn&#x27;t (also) happen (is that even how Go works?) I would love to find out!</div><br/><div id="37577858" class="c"><input type="checkbox" id="c-37577858" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#37576726">root</a><span>|</span><a href="#37577337">parent</a><span>|</span><a href="#37577536">next</a><span>|</span><label class="collapse" for="c-37577858">[-]</label><label class="expand" for="c-37577858">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think it’s so complex. Without i := i, there’s only one i. With i := i, there’s one i per iteration.<p>Closure captures are always by reference.<p>Heap vs stack allocation don’t affect the language semantics.</div><br/><div id="37579222" class="c"><input type="checkbox" id="c-37579222" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37576726">root</a><span>|</span><a href="#37577858">parent</a><span>|</span><a href="#37577536">next</a><span>|</span><label class="collapse" for="c-37579222">[-]</label><label class="expand" for="c-37579222">[1 more]</label></div><br/><div class="children"><div class="content">Yup. The linked article is a little confused. It thinks that an optimization to pass by value is affecting the behavior. In reality it only passes by value when it is indistinguishable from passing by reference (and it thinks it would be cheaper).</div><br/></div></div></div></div></div></div><div id="37577536" class="c"><input type="checkbox" id="c-37577536" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#37576726">parent</a><span>|</span><a href="#37577337">prev</a><span>|</span><a href="#37576394">next</a><span>|</span><label class="collapse" for="c-37577536">[-]</label><label class="expand" for="c-37577536">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a much better explanation for someone like me who isn&#x27;t very familiar with Go.</div><br/></div></div></div></div><div id="37576394" class="c"><input type="checkbox" id="c-37576394" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37576726">prev</a><span>|</span><a href="#37575630">next</a><span>|</span><label class="collapse" for="c-37576394">[-]</label><label class="expand" for="c-37576394">[5 more]</label></div><br/><div class="children"><div class="content">I have run into this problem in Python too, but not recently. I&#x27;m not sure if Python has changed or if I just caught on to the problem.<p>This should be enough to show that it still can wind up as a problem in Python:<p><pre><code>    funcs = [(lambda: x) for x in range(3)]
    funcs[0]()  # outputs: 2</code></pre></div><br/><div id="37576549" class="c"><input type="checkbox" id="c-37576549" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37576394">parent</a><span>|</span><a href="#37576784">next</a><span>|</span><label class="collapse" for="c-37576549">[-]</label><label class="expand" for="c-37576549">[3 more]</label></div><br/><div class="children"><div class="content">That is correct.<p>Python used to be worse; it used to share scope <i>outside the list comprehension</i>.</div><br/><div id="37578368" class="c"><input type="checkbox" id="c-37578368" checked=""/><div class="controls bullet"><span class="by">nightfly</span><span>|</span><a href="#37576394">root</a><span>|</span><a href="#37576549">parent</a><span>|</span><a href="#37576784">next</a><span>|</span><label class="collapse" for="c-37578368">[-]</label><label class="expand" for="c-37578368">[2 more]</label></div><br/><div class="children"><div class="content">It still does for regular loops right?</div><br/><div id="37579392" class="c"><input type="checkbox" id="c-37579392" checked=""/><div class="controls bullet"><span class="by">thatguysaguy</span><span>|</span><a href="#37576394">root</a><span>|</span><a href="#37578368">parent</a><span>|</span><a href="#37576784">next</a><span>|</span><label class="collapse" for="c-37579392">[-]</label><label class="expand" for="c-37579392">[1 more]</label></div><br/><div class="children"><div class="content">Yeah loops don&#x27;t get their own scopes (unless you add one using this thing I made as a joke: <a href="https:&#x2F;&#x2F;github.com&#x2F;davisyoshida&#x2F;360blockscope">https:&#x2F;&#x2F;github.com&#x2F;davisyoshida&#x2F;360blockscope</a>)</div><br/></div></div></div></div></div></div><div id="37576784" class="c"><input type="checkbox" id="c-37576784" checked=""/><div class="controls bullet"><span class="by">pulvinar</span><span>|</span><a href="#37576394">parent</a><span>|</span><a href="#37576549">prev</a><span>|</span><a href="#37575630">next</a><span>|</span><label class="collapse" for="c-37576784">[-]</label><label class="expand" for="c-37576784">[1 more]</label></div><br/><div class="children"><div class="content">GPT-4 says: The behavior you&#x27;re observing is due to the late binding nature of closures in Python. When you use a lambda inside a list comprehension (or any loop), it captures a reference to the variable x, not its current value. By the time you call funcs[0](), x has already been set to the last value in the range, which is 2.<p>To get the desired behavior, you can pass x as a default argument to the lambda:<p><pre><code>   funcs = [(lambda x=x: x) for x in range(3)]
   funcs[0]() # outputs 0</code></pre></div><br/></div></div></div></div><div id="37575630" class="c"><input type="checkbox" id="c-37575630" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#37576394">prev</a><span>|</span><a href="#37575957">next</a><span>|</span><label class="collapse" for="c-37575630">[-]</label><label class="expand" for="c-37575630">[40 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t this end up breaking programs that depend on the current behavior?</div><br/><div id="37575673" class="c"><input type="checkbox" id="c-37575673" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575783">next</a><span>|</span><label class="collapse" for="c-37575673">[-]</label><label class="expand" for="c-37575673">[8 more]</label></div><br/><div class="children"><div class="content">&gt; To ensure backwards compatibility with existing code, the new semantics will only apply in packages contained in modules that declare go 1.22 or later in their go.mod files. ... It is also possible to use &#x2F;&#x2F;go:build lines to control the decision on a per-file basis.</div><br/><div id="37576677" class="c"><input type="checkbox" id="c-37576677" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575673">parent</a><span>|</span><a href="#37575783">next</a><span>|</span><label class="collapse" for="c-37576677">[-]</label><label class="expand" for="c-37576677">[7 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t that mean that all code written so far can&#x27;t take up newer versions of the Go compiler for any other reason like new features&#x2F;bugfixes&#x2F;optimizations&#x2F;etc without a full audit of codepaths involving for loops?</div><br/><div id="37579129" class="c"><input type="checkbox" id="c-37579129" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576677">parent</a><span>|</span><a href="#37581639">next</a><span>|</span><label class="collapse" for="c-37579129">[-]</label><label class="expand" for="c-37579129">[1 more]</label></div><br/><div class="children"><div class="content">No, the version declared in go.mod is different than the version of the toolchain used to compile the project. If you declare an older version even new toolchains will act like the previous versions.</div><br/></div></div><div id="37581639" class="c"><input type="checkbox" id="c-37581639" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576677">parent</a><span>|</span><a href="#37579129">prev</a><span>|</span><a href="#37581186">next</a><span>|</span><label class="collapse" for="c-37581639">[-]</label><label class="expand" for="c-37581639">[1 more]</label></div><br/><div class="children"><div class="content">No I don&#x27;t think so; any old working code will be using the x := x workaround, which will keep working when going to this version with the changed loop mechanics. What may happen is a form of... some adage, I forgot the name, where code accidentally relies on the old behaviour and breaks when that old behaviour is no longer there.<p>(that same adage applies to e.g. browser manufacturers having to implement bugs to not break certain websites)</div><br/></div></div><div id="37581186" class="c"><input type="checkbox" id="c-37581186" checked=""/><div class="controls bullet"><span class="by">s17n</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576677">parent</a><span>|</span><a href="#37581639">prev</a><span>|</span><a href="#37577282">next</a><span>|</span><label class="collapse" for="c-37581186">[-]</label><label class="expand" for="c-37581186">[1 more]</label></div><br/><div class="children"><div class="content">There isn’t really anything that you could actually use the old behavior for, any code that depends on it is probably wrong anyway.</div><br/></div></div><div id="37577282" class="c"><input type="checkbox" id="c-37577282" checked=""/><div class="controls bullet"><span class="by">ericpauley</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576677">parent</a><span>|</span><a href="#37581186">prev</a><span>|</span><a href="#37575783">next</a><span>|</span><label class="collapse" for="c-37577282">[-]</label><label class="expand" for="c-37577282">[3 more]</label></div><br/><div class="children"><div class="content">No, it does not. Packages can compile using 1.22 and gain other benefits without opting into this change.</div><br/><div id="37578191" class="c"><input type="checkbox" id="c-37578191" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37577282">parent</a><span>|</span><a href="#37575783">next</a><span>|</span><label class="collapse" for="c-37578191">[-]</label><label class="expand" for="c-37578191">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I didn&#x27;t see the part about &#x2F;&#x2F;go:build</div><br/><div id="37580953" class="c"><input type="checkbox" id="c-37580953" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37578191">parent</a><span>|</span><a href="#37575783">next</a><span>|</span><label class="collapse" for="c-37580953">[-]</label><label class="expand" for="c-37580953">[1 more]</label></div><br/><div class="children"><div class="content">Without  &#x2F;:go:build tags, you can just define 1.21 as your Go version in go.mod to opt out of new features while getting other benefits of the new compiler</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37575783" class="c"><input type="checkbox" id="c-37575783" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575673">prev</a><span>|</span><a href="#37576861">next</a><span>|</span><label class="collapse" for="c-37575783">[-]</label><label class="expand" for="c-37575783">[16 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why you&#x27;re being down voted, but it is actually breaking the Go1 compat promise. Which says:<p><pre><code>    It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. At some indefinite point, a Go 2 specification may arise, but until that time, Go programs that work today should continue to work even as future &quot;point&quot; releases of Go 1 arise (Go 1.1, Go 1.2, etc.).</code></pre></div><br/><div id="37575882" class="c"><input type="checkbox" id="c-37575882" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37579881">next</a><span>|</span><label class="collapse" for="c-37575882">[-]</label><label class="expand" for="c-37575882">[4 more]</label></div><br/><div class="children"><div class="content">I upvoted the question to offset one of the downs because I agree it&#x27;s a fair question.  However I would guess the downvotes are because TFA addressed this issue directly and comprehensively, so it&#x27;s a clear &quot;I didn&#x27;t read the article&quot; indicator :-)  Possibly also because the downvoters can&#x27;t imagine a scenario where this would be desirable behavior (i.e. it&#x27;s always a bug)</div><br/><div id="37576246" class="c"><input type="checkbox" id="c-37576246" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575882">parent</a><span>|</span><a href="#37575928">next</a><span>|</span><label class="collapse" for="c-37576246">[-]</label><label class="expand" for="c-37576246">[1 more]</label></div><br/><div class="children"><div class="content">But if it’s a bug, then the logic to not compile future versions is wrong, IMO. If it’s a feature change, then such logic would make sense.</div><br/></div></div><div id="37575928" class="c"><input type="checkbox" id="c-37575928" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575882">parent</a><span>|</span><a href="#37576246">prev</a><span>|</span><a href="#37575931">next</a><span>|</span><label class="collapse" for="c-37575928">[-]</label><label class="expand" for="c-37575928">[1 more]</label></div><br/><div class="children"><div class="content">Yeah its fair, I didn&#x27;t closely read that section. Although, I&#x27;m not entirely convinced the approach is safe, maybe its worth it to fix such a common pitfall.</div><br/></div></div></div></div><div id="37579881" class="c"><input type="checkbox" id="c-37579881" checked=""/><div class="controls bullet"><span class="by">efuquen</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37575882">prev</a><span>|</span><a href="#37581659">next</a><span>|</span><label class="collapse" for="c-37579881">[-]</label><label class="expand" for="c-37579881">[2 more]</label></div><br/><div class="children"><div class="content">In a previous blog post they basically said they will never make a Go 2, and also addressed a lot of things about compatibility:<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;compat" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;compat</a><p>In particular they said:<p>&gt; The end of the document warns, “[It] is impossible to guarantee that no future change will break any program.” Then it lays out a number of reasons why programs might still break.<p>&gt; For example, it makes sense that if your program depends on a buggy behavior and we fix the bug, your program will break. But we try very hard to break as little as possible and keep Go boring.</div><br/><div id="37581672" class="c"><input type="checkbox" id="c-37581672" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37579881">parent</a><span>|</span><a href="#37581659">next</a><span>|</span><label class="collapse" for="c-37581672">[-]</label><label class="expand" for="c-37581672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In a previous blog post they basically said they will never make a Go 2<p>No, they didn&#x27;t say that, they said it wouldn&#x27;t be backwards-incompatible with Go 1. Relevant quote:<p>&gt; [...] when should we expect the Go 2 specification that breaks old Go 1 programs?<p>&gt; The answer is never. Go 2, <i>in the sense of breaking with the past and no longer compiling old programs</i>, is never going to happen. Go 2 in the sense of being the major revision of Go 1 we started toward in 2017 has already happened.</div><br/></div></div></div></div><div id="37581659" class="c"><input type="checkbox" id="c-37581659" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37579881">prev</a><span>|</span><a href="#37575863">next</a><span>|</span><label class="collapse" for="c-37581659">[-]</label><label class="expand" for="c-37581659">[1 more]</label></div><br/><div class="children"><div class="content">No, it doesn&#x27;t break the promise; &quot;Go programs that work today should continue to work even as future &quot;point&quot; releases of Go 1 arise (Go 1.1, Go 1.2, etc.).&quot;<p>You can install Go 1.22 and your program will compile and run as-is. That&#x27;s the promise. If however you opt-in to the changed for loop behaviour by adjusting your go.mod, the onus is on you to update your program accordingly.<p>It&#x27;s only a backwards incompatible change if the developer makes a backwards incompatible change by updating the configured target version.<p>(I&#x27;m aware I&#x27;m probably being pedantic here, I understand the language used seems to imply you can just set it to v1.22 and it works but it&#x27;s a bit more specific)</div><br/></div></div><div id="37575863" class="c"><input type="checkbox" id="c-37575863" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37581659">prev</a><span>|</span><a href="#37575903">next</a><span>|</span><label class="collapse" for="c-37575863">[-]</label><label class="expand" for="c-37575863">[5 more]</label></div><br/><div class="children"><div class="content">Note the word “programs”, not “files”. If your program doesn’t declare go 1.22 in its go.mod, it will continue to work (or not work!), unchanged.</div><br/><div id="37576003" class="c"><input type="checkbox" id="c-37576003" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575863">parent</a><span>|</span><a href="#37575903">next</a><span>|</span><label class="collapse" for="c-37576003">[-]</label><label class="expand" for="c-37576003">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that &quot;working with future point releases&quot;, though? If I don&#x27;t declare 1.22, am I not excluded from that point release?</div><br/><div id="37576287" class="c"><input type="checkbox" id="c-37576287" checked=""/><div class="controls bullet"><span class="by">mrkstu</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576003">parent</a><span>|</span><a href="#37576216">next</a><span>|</span><label class="collapse" for="c-37576287">[-]</label><label class="expand" for="c-37576287">[1 more]</label></div><br/><div class="children"><div class="content">No, the compiler will revert to the original behavior, it only adopts the new behavior with the declaration.</div><br/></div></div><div id="37576216" class="c"><input type="checkbox" id="c-37576216" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576003">parent</a><span>|</span><a href="#37576287">prev</a><span>|</span><a href="#37578918">next</a><span>|</span><label class="collapse" for="c-37576216">[-]</label><label class="expand" for="c-37576216">[1 more]</label></div><br/><div class="children"><div class="content">I assume that if compiling with 1.22 or later, you still get all the benefits from that version like other new features, bug fixes or perf improvements, just not this particular change.</div><br/></div></div><div id="37578918" class="c"><input type="checkbox" id="c-37578918" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576003">parent</a><span>|</span><a href="#37576216">prev</a><span>|</span><a href="#37575903">next</a><span>|</span><label class="collapse" for="c-37578918">[-]</label><label class="expand" for="c-37578918">[1 more]</label></div><br/><div class="children"><div class="content">This has all been addressed in the proposal. The research was done and this change will impact so few projects that it’s worth making a technical exception to the compatibility promise to fix a real design flaw.</div><br/></div></div></div></div></div></div><div id="37575903" class="c"><input type="checkbox" id="c-37575903" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37575863">prev</a><span>|</span><a href="#37575934">next</a><span>|</span><label class="collapse" for="c-37575903">[-]</label><label class="expand" for="c-37575903">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mind.<p>Yeah, I thought this kind of change wouldn&#x27;t happen because of this promise.</div><br/></div></div><div id="37575934" class="c"><input type="checkbox" id="c-37575934" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37575903">prev</a><span>|</span><a href="#37576002">next</a><span>|</span><label class="collapse" for="c-37575934">[-]</label><label class="expand" for="c-37575934">[1 more]</label></div><br/><div class="children"><div class="content">I think it was downvoted precisely because of that. It&#x27;s a bit of a contentious issue.</div><br/></div></div><div id="37576002" class="c"><input type="checkbox" id="c-37576002" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575783">parent</a><span>|</span><a href="#37575934">prev</a><span>|</span><a href="#37576861">next</a><span>|</span><label class="collapse" for="c-37576002">[-]</label><label class="expand" for="c-37576002">[1 more]</label></div><br/><div class="children"><div class="content">And they do. You can specify the precise logic to use on a per-file basis.</div><br/></div></div></div></div><div id="37576861" class="c"><input type="checkbox" id="c-37576861" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575783">prev</a><span>|</span><a href="#37581242">next</a><span>|</span><label class="collapse" for="c-37576861">[-]</label><label class="expand" for="c-37576861">[1 more]</label></div><br/><div class="children"><div class="content">To add to the other comments, in the run-up to go1.21 they talked about how they’d analysed a very large corpus of Go code to see what would be affected, and it was a very very small number.<p>I remember thinking that the number of people who have created inadvertent bugs due to this design (myself included) would be significantly greater than the number of people affected by the fix.</div><br/></div></div><div id="37581242" class="c"><input type="checkbox" id="c-37581242" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37576861">prev</a><span>|</span><a href="#37576526">next</a><span>|</span><label class="collapse" for="c-37581242">[-]</label><label class="expand" for="c-37581242">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the loopvar change will break some programs, and hence the compatibility promise. But the Go team argues that the change will fix much more programs than it will break [1].<p>This makes me wonder, though, what guarantees that a similar breaking change won&#x27;t ever happen again in the future? If any change with #(programs fixed) &gt;&gt; #(programs broken) is accepted, we might as well remove the compatibility promise page [2].<p>---<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;60078">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;60078</a><p>[2] <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat</a></div><br/></div></div><div id="37576526" class="c"><input type="checkbox" id="c-37576526" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37581242">prev</a><span>|</span><a href="#37575656">next</a><span>|</span><label class="collapse" for="c-37576526">[-]</label><label class="expand" for="c-37576526">[1 more]</label></div><br/><div class="children"><div class="content">Python has the same problem (to the extent that it&#x27;s actually a problem, which you might or might not agree with), and this is the #1 reason they won&#x27;t change it.</div><br/></div></div><div id="37575656" class="c"><input type="checkbox" id="c-37575656" checked=""/><div class="controls bullet"><span class="by">matthewmueller</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37576526">prev</a><span>|</span><a href="#37575727">next</a><span>|</span><label class="collapse" for="c-37575656">[-]</label><label class="expand" for="c-37575656">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only enabled for modules that run Go 1.22 and higher</div><br/><div id="37575725" class="c"><input type="checkbox" id="c-37575725" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575656">parent</a><span>|</span><a href="#37575727">next</a><span>|</span><label class="collapse" for="c-37575725">[-]</label><label class="expand" for="c-37575725">[6 more]</label></div><br/><div class="children"><div class="content">I also can&#x27;t imagine a case where it is useful or even truly intended to rely on this behavior.</div><br/><div id="37576274" class="c"><input type="checkbox" id="c-37576274" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575725">parent</a><span>|</span><a href="#37581681">next</a><span>|</span><label class="collapse" for="c-37576274">[-]</label><label class="expand" for="c-37576274">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I don&#x27;t think it&#x27;s so much &quot;we explicitly rely on this behavior, how dare you change this&quot; as &quot;somewhere in our mountains of maintenance-mode code that haven&#x27;t seen the sun shine through an editor window in years, this behavior cancels out another bug that we never noticed&quot;. Tooling should be able to detect when code relies on this, but it&#x27;s still gonna cost some non-zero amount of developer effort to touch ancient code and safely roll out a new version if it needs to be actively addressed.</div><br/><div id="37577405" class="c"><input type="checkbox" id="c-37577405" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37576274">parent</a><span>|</span><a href="#37581681">next</a><span>|</span><label class="collapse" for="c-37577405">[-]</label><label class="expand" for="c-37577405">[2 more]</label></div><br/><div class="children"><div class="content">If you have tests and they break with GOEXPERIMENT=loopvar, then there is a new tool that will tell you exactly which loop is causing the breakage. That&#x27;s a post for a few weeks from now.</div><br/><div id="37579419" class="c"><input type="checkbox" id="c-37579419" checked=""/><div class="controls bullet"><span class="by">kuchenbecker</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37577405">parent</a><span>|</span><a href="#37581681">next</a><span>|</span><label class="collapse" for="c-37579419">[-]</label><label class="expand" for="c-37579419">[1 more]</label></div><br/><div class="children"><div class="content">If</div><br/></div></div></div></div></div></div><div id="37581681" class="c"><input type="checkbox" id="c-37581681" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575725">parent</a><span>|</span><a href="#37576274">prev</a><span>|</span><a href="#37575904">next</a><span>|</span><label class="collapse" for="c-37581681">[-]</label><label class="expand" for="c-37581681">[1 more]</label></div><br/><div class="children"><div class="content">Neither can I, but there may be cases of code accidentally relying on it - there&#x27;s an adage that I forgot the name of that says just that, and I think compiler manufacturers are the most aware of that adage.</div><br/></div></div><div id="37575904" class="c"><input type="checkbox" id="c-37575904" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575725">parent</a><span>|</span><a href="#37581681">prev</a><span>|</span><a href="#37575727">next</a><span>|</span><label class="collapse" for="c-37575904">[-]</label><label class="expand" for="c-37575904">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it’s def a code smell …</div><br/></div></div></div></div></div></div><div id="37575727" class="c"><input type="checkbox" id="c-37575727" checked=""/><div class="controls bullet"><span class="by">minroot</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575656">prev</a><span>|</span><a href="#37578894">next</a><span>|</span><label class="collapse" for="c-37575727">[-]</label><label class="expand" for="c-37575727">[2 more]</label></div><br/><div class="children"><div class="content">Some time spent with Go gives a strong indication that Go team always has backwards compatibility in mind</div><br/><div id="37576029" class="c"><input type="checkbox" id="c-37576029" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37575630">root</a><span>|</span><a href="#37575727">parent</a><span>|</span><a href="#37578894">next</a><span>|</span><label class="collapse" for="c-37576029">[-]</label><label class="expand" for="c-37576029">[1 more]</label></div><br/><div class="children"><div class="content">They do. Go has avoided most of the pitfalls that other language eco-systems have fallen for over the years (backwards compatibility issues, soft forks masquerading as language improvements, re-booting the whole language under the same name, aggressively pushing down on other languages etc). They&#x27;ve done <i>remarkably</i> well in those respects, and should deserve huge credit for it.</div><br/></div></div></div></div><div id="37578894" class="c"><input type="checkbox" id="c-37578894" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575727">prev</a><span>|</span><a href="#37575689">next</a><span>|</span><label class="collapse" for="c-37578894">[-]</label><label class="expand" for="c-37578894">[1 more]</label></div><br/><div class="children"><div class="content">The original proposal for this change went into great detail about the research they did into existing uses of this syntax. In my memory, they found vanishingly few cases in the Google codebase or GitHub code where the change would violate the expected behavior. The decision to break the backwards compatibility here came only after determining how few codebases would be affected and developing a mechanism in Go itself (the version specification in go.mod) to require actively modifying the code to build with the new behavior.</div><br/></div></div><div id="37575892" class="c"><input type="checkbox" id="c-37575892" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#37575630">parent</a><span>|</span><a href="#37575689">prev</a><span>|</span><a href="#37575957">next</a><span>|</span><label class="collapse" for="c-37575892">[-]</label><label class="expand" for="c-37575892">[1 more]</label></div><br/><div class="children"><div class="content">Seems like yes, though hopefully that should be rare.</div><br/></div></div></div></div><div id="37575957" class="c"><input type="checkbox" id="c-37575957" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#37575630">prev</a><span>|</span><a href="#37579088">next</a><span>|</span><label class="collapse" for="c-37575957">[-]</label><label class="expand" for="c-37575957">[8 more]</label></div><br/><div class="children"><div class="content">&gt; as a consequence of our forward compatibility work, Go 1.21 will not attempt to compile code that declares go 1.22 or later. We included a special case with the same effect in the point releases Go 1.20.8 and Go 1.19.13, so when Go 1.22 is released, code written depending on the new semantics will never be compiled with the old semantics, unless people are using very old, unsupported Go versions<p>How does this work? If I pull in a package that decided to pin 1.22 (as they should) and I compile with 1.18, would it compile or error that I need to use the 1.22 compiler?</div><br/><div id="37578259" class="c"><input type="checkbox" id="c-37578259" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#37575957">parent</a><span>|</span><a href="#37576119">next</a><span>|</span><label class="collapse" for="c-37578259">[-]</label><label class="expand" for="c-37578259">[1 more]</label></div><br/><div class="children"><div class="content">They did something sneaky. In go 1.21, they changed the version number format in the `go.mod` files. So trying to build with go 1.18 will result in:<p><pre><code>  go: errors parsing go.mod:
  go.mod:3: invalid go version &#x27;1.21.0&#x27;: must match format 1.23
</code></pre>
However, this will only happen if you use the `go mod init` to create your module. If you manually specify `go 1.21` in your `go.mod`, it will build without complaining.</div><br/></div></div><div id="37576119" class="c"><input type="checkbox" id="c-37576119" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37575957">parent</a><span>|</span><a href="#37578259">prev</a><span>|</span><a href="#37576243">next</a><span>|</span><label class="collapse" for="c-37576119">[-]</label><label class="expand" for="c-37576119">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, though, if you use Go 1.21 and a module declares a later version of Go, the default behavior is actually to go fetch a newer toolchain and use it instead[1]. It&#x27;s a pretty cool feature, but I am a bit on the fence due to the fact that it is surprising and phones home to Google-controlled servers to fetch the binaries. That and the module proxy are for sure two of the most conflicting features in Go and I&#x27;d feel a lot better about them if Go was controlled by a foundation that Google merely had a stake in. Alas.<p>edit: Actually, though, I just realized what I am talking about is different than what you and your quote is talking about, which is what happens when you have a dependency that declares a different version, not the current module. Oops.<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;toolchain" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;toolchain</a></div><br/></div></div><div id="37576243" class="c"><input type="checkbox" id="c-37576243" checked=""/><div class="controls bullet"><span class="by">yankput</span><span>|</span><a href="#37575957">parent</a><span>|</span><a href="#37576119">prev</a><span>|</span><a href="#37576188">next</a><span>|</span><label class="collapse" for="c-37576243">[-]</label><label class="expand" for="c-37576243">[3 more]</label></div><br/><div class="children"><div class="content">They way I understand this, with go 1.18, 1.22 module as a dependency will compile and produce errorneous logic (!!) if it depends on this feature<p>Thus it will be actively dangerous using go 1.18. I understand it like that.<p>With go 1.19, you will get a compiler error.<p>But as go is not fixing security bugs in old releases and std library, I think it is dangerous to use them anyway.</div><br/><div id="37576440" class="c"><input type="checkbox" id="c-37576440" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37575957">root</a><span>|</span><a href="#37576243">parent</a><span>|</span><a href="#37576188">next</a><span>|</span><label class="collapse" for="c-37576440">[-]</label><label class="expand" for="c-37576440">[2 more]</label></div><br/><div class="children"><div class="content">&quot;But as go is not fixing security bugs in old releases and std library, I think it is dangerous to use them anyway.&quot;<p>A bit of a harsh way to phrase that. In my experience, the backwards compatibility promises have been very good, and the way you stay up-to-date with security fixes and bugs in the standard library is to upgrade Go.<p>I know that may strike terror in the hearts of developers used to the nightmare that major version upgrades can be in other languages, where a major version upgrade gets a multi-week task added into the task tracker, but it&#x27;s completely routine for me to upgrade across Go major versions just to get some particular fix or to play with a new feature. I expect it to be a roughly five minute task, routinely.<p>The only thing that has bitten me about it is arguably not even Go&#x27;s fault, which is its continuing advances in TLS security and the increasing fussiness with which it treats things connecting with old-style certificates. I can&#x27;t even necessarily disagree... I would also like to upgrade them but while it&#x27;s my server, the clients connecting to it are using certs that are not mine and it&#x27;s out of my control.</div><br/><div id="37576742" class="c"><input type="checkbox" id="c-37576742" checked=""/><div class="controls bullet"><span class="by">yankput</span><span>|</span><a href="#37575957">root</a><span>|</span><a href="#37576440">parent</a><span>|</span><a href="#37576188">next</a><span>|</span><label class="collapse" for="c-37576742">[-]</label><label class="expand" for="c-37576742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A bit of a harsh way to phrase that. In my experience, the backwards compatibility promises have been very good, and the way you stay up-to-date with security fixes and bugs in the standard library is to upgrade Go.<p>I don’t think we disagree? There is no reason to use old version of go.<p>I speak about grandparent comment who wanted to still run go1.18. It is not a good idea to still run go1.18, as it doesn’t get security updates.</div><br/></div></div></div></div></div></div><div id="37576188" class="c"><input type="checkbox" id="c-37576188" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37575957">parent</a><span>|</span><a href="#37576243">prev</a><span>|</span><a href="#37575994">next</a><span>|</span><label class="collapse" for="c-37576188">[-]</label><label class="expand" for="c-37576188">[1 more]</label></div><br/><div class="children"><div class="content">You should get a compile error.<p>But your code, when compiled with go 1.22, will still have go 1.18 semantics.</div><br/></div></div><div id="37575994" class="c"><input type="checkbox" id="c-37575994" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37575957">parent</a><span>|</span><a href="#37576188">prev</a><span>|</span><a href="#37579088">next</a><span>|</span><label class="collapse" for="c-37575994">[-]</label><label class="expand" for="c-37575994">[1 more]</label></div><br/><div class="children"><div class="content">Yes.</div><br/></div></div></div></div><div id="37579088" class="c"><input type="checkbox" id="c-37579088" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#37575957">prev</a><span>|</span><a href="#37575699">next</a><span>|</span><label class="collapse" for="c-37579088">[-]</label><label class="expand" for="c-37579088">[3 more]</label></div><br/><div class="children"><div class="content">Feel a great sense of relief reading this. This fixes the single biggest wart in Go.</div><br/><div id="37579100" class="c"><input type="checkbox" id="c-37579100" checked=""/><div class="controls bullet"><span class="by">darren0</span><span>|</span><a href="#37579088">parent</a><span>|</span><a href="#37575699">next</a><span>|</span><label class="collapse" for="c-37579100">[-]</label><label class="expand" for="c-37579100">[2 more]</label></div><br/><div class="children"><div class="content">Next they can fix nil checks on interfaces.</div><br/><div id="37581631" class="c"><input type="checkbox" id="c-37581631" checked=""/><div class="controls bullet"><span class="by">cyphar</span><span>|</span><a href="#37579088">root</a><span>|</span><a href="#37579100">parent</a><span>|</span><a href="#37575699">next</a><span>|</span><label class="collapse" for="c-37581631">[-]</label><label class="expand" for="c-37581631">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, the distinction is sometimes (though rarely) useful and would be a far more disruptive change than this one. I think you would actually need a Go v2 to change it.</div><br/></div></div></div></div></div></div><div id="37575699" class="c"><input type="checkbox" id="c-37575699" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37579088">prev</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37575699">[-]</label><label class="expand" for="c-37575699">[18 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written a tiny bit of Go and am aware of the general problem this solves. I don&#x27;t get their more subtle examples (the letsencrypt one or &quot;range c.informerMap&quot; vs &quot;range alarms&quot;.<p>When you do &quot;for k, v := range someMap&quot;, is &quot;v&quot; of the map&#x27;s value type (and one binding for the whole loop, copied before each iteration)? This would explain the problem, but I would have expected &quot;v&quot; to be a reference into the map, and I couldn&#x27;t find the answer in a quick skim of the &quot;For statements with range clause&quot; in the spec. I&#x27;m probably looking in the wrong place because I touch Go rarely...<p>[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#For_statements" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#For_statements</a><p>edit: oh, the answer is in the &quot;code block&quot;-formatted table. Guess I had banner blindness. &quot;v&quot; is the copied value, not a reference. I&#x27;m surprised!</div><br/><div id="37576306" class="c"><input type="checkbox" id="c-37576306" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37575699">parent</a><span>|</span><a href="#37575776">next</a><span>|</span><label class="collapse" for="c-37576306">[-]</label><label class="expand" for="c-37576306">[4 more]</label></div><br/><div class="children"><div class="content">Go doesn’t support pointers to map keys or values. It does support pointers to array slots, but for-range copies each slot rather than giving you a pointer to it.</div><br/><div id="37576558" class="c"><input type="checkbox" id="c-37576558" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576306">parent</a><span>|</span><a href="#37575776">next</a><span>|</span><label class="collapse" for="c-37576558">[-]</label><label class="expand" for="c-37576558">[3 more]</label></div><br/><div class="children"><div class="content">I suppose that makes sense when I think about it for a bit. My recent expectations come from work in Rust. There the language prevents you from mutating a map while holding a reference into it. Go doesn&#x27;t have a mechanism to prevent that (except the one you said, simply not supporting those references at all). If you had a reference into a map that was resized because of a subsequent mutation, your reference would have to keep the whole previous map alive and point to different memory than a reference acquired since then. Both seem undesirable.<p>With array slots, the same issue is present but is a bit more explicit because those resizes happen with `mySlice = append(mySlice, ...)`.</div><br/><div id="37580497" class="c"><input type="checkbox" id="c-37580497" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576558">parent</a><span>|</span><a href="#37577010">next</a><span>|</span><label class="collapse" for="c-37580497">[-]</label><label class="expand" for="c-37580497">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If you had a reference into a map<p>Maps in golang are of reference type, just to be clear.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps</a><p>implementation: <a href="https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;runtime&#x2F;map.go" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;runtime&#x2F;map.go</a></div><br/></div></div><div id="37577010" class="c"><input type="checkbox" id="c-37577010" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576558">parent</a><span>|</span><a href="#37580497">prev</a><span>|</span><a href="#37575776">next</a><span>|</span><label class="collapse" for="c-37577010">[-]</label><label class="expand" for="c-37577010">[1 more]</label></div><br/><div class="children"><div class="content">I think the slice append semantics are very error-prone, and it would have been better if a slice was a shareable reference to a single mutable thing, like a map (or a list from Python or Java or …)</div><br/></div></div></div></div></div></div><div id="37575776" class="c"><input type="checkbox" id="c-37575776" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37575699">parent</a><span>|</span><a href="#37576306">prev</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37575776">[-]</label><label class="expand" for="c-37575776">[13 more]</label></div><br/><div class="children"><div class="content">If you have a map of string to int, then v is of type int. It&#x27;s a value. It&#x27;s not pointer to int.</div><br/><div id="37576153" class="c"><input type="checkbox" id="c-37576153" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37575776">parent</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37576153">[-]</label><label class="expand" for="c-37576153">[12 more]</label></div><br/><div class="children"><div class="content">Is the expectation that you simply won&#x27;t create a `map[...]expensivetocopyvalue`, but instead always do `map[...]*expensivetocopyvalue`?</div><br/><div id="37576190" class="c"><input type="checkbox" id="c-37576190" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576153">parent</a><span>|</span><a href="#37579817">prev</a><span>|</span><a href="#37576214">next</a><span>|</span><label class="collapse" for="c-37576190">[-]</label><label class="expand" for="c-37576190">[6 more]</label></div><br/><div class="children"><div class="content">No expectations whatsoever. You can use pointer or a values. It&#x27;s up to you.</div><br/><div id="37576261" class="c"><input type="checkbox" id="c-37576261" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576190">parent</a><span>|</span><a href="#37576214">next</a><span>|</span><label class="collapse" for="c-37576261">[-]</label><label class="expand" for="c-37576261">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s silly. Language constructs and APIs are always made with expectations for how they&#x27;re used, stated or not. You can write code that compiles without understanding and matching those expectations but it probably won&#x27;t be good code.<p>I&#x27;m asking because I think if it were expected that folks used large&#x2F;expensive-to-copy map values, this construct would return a reference instead of copying. In Rust for example, the std library&#x27;s &quot;normal&quot; [1] iterators return references.<p>[1] not those returned by into_* or drain.</div><br/><div id="37576740" class="c"><input type="checkbox" id="c-37576740" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576261">parent</a><span>|</span><a href="#37576399">prev</a><span>|</span><a href="#37576518">next</a><span>|</span><label class="collapse" for="c-37576740">[-]</label><label class="expand" for="c-37576740">[1 more]</label></div><br/><div class="children"><div class="content">Here an example: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;He0lBEYZJ03" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;He0lBEYZJ03</a><p>Value is always a copy. Either a copy of a struct (in case of map[T]struct{}) or a copy of a pointer (in case of map[T]*struct{})</div><br/></div></div><div id="37576518" class="c"><input type="checkbox" id="c-37576518" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576261">parent</a><span>|</span><a href="#37576740">prev</a><span>|</span><a href="#37576214">next</a><span>|</span><label class="collapse" for="c-37576518">[-]</label><label class="expand" for="c-37576518">[2 more]</label></div><br/><div class="children"><div class="content">Returning references to storage within the map would be a substantial footgun without borrowing.</div><br/><div id="37576807" class="c"><input type="checkbox" id="c-37576807" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576518">parent</a><span>|</span><a href="#37576214">next</a><span>|</span><label class="collapse" for="c-37576807">[-]</label><label class="expand" for="c-37576807">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, useful reply. I just realized that myself: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37576558">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37576558</a><p>The peer comments along the lines of &quot;the expecation is it does what it does&quot; are not so helpful from a perspective of learning to write code that is in harmony with the language philosophy.</div><br/></div></div></div></div></div></div></div></div><div id="37576214" class="c"><input type="checkbox" id="c-37576214" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576153">parent</a><span>|</span><a href="#37576190">prev</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37576214">[-]</label><label class="expand" for="c-37576214">[4 more]</label></div><br/><div class="children"><div class="content">The expectation is the compiler does what you tell it? If you want pointers in your map, you can do that too.</div><br/><div id="37577007" class="c"><input type="checkbox" id="c-37577007" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37576214">parent</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37577007">[-]</label><label class="expand" for="c-37577007">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re asking that, if the programmer wants the map to store expensivetocopyvalue semantically but also doesn&#x27;t want to have iteration generate expensive copies, does the programmer have to change the map to store *expensivetocopyvalue instead?<p>Anyway I believe the answer is that expensivetocopyvalue is not a type that exists in golang, because golang&#x27;s &quot;copy&quot; operation is always a simple bitwise copy ala C struct copy &#x2F; Rust&#x27;s Copy trait, not like C++ copy ctor &#x2F; Rust&#x27;s Clone trait that can be arbitrarily expensive.</div><br/><div id="37577227" class="c"><input type="checkbox" id="c-37577227" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#37575699">root</a><span>|</span><a href="#37577007">parent</a><span>|</span><a href="#37579810">prev</a><span>|</span><a href="#37575641">next</a><span>|</span><label class="collapse" for="c-37577227">[-]</label><label class="expand" for="c-37577227">[1 more]</label></div><br/><div class="children"><div class="content">In Go, `expensivetocopyvalue` can still be achieved via an enormous (e.g. multi-KB&#x2F;MB) structure (which is most literally expensive to copy) or something containing a lot of pointers (which is not really expensive to copy but will start to pressure the GC).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37575641" class="c"><input type="checkbox" id="c-37575641" checked=""/><div class="controls bullet"><span class="by">matthewmueller</span><span>|</span><a href="#37575699">prev</a><span>|</span><a href="#37575777">next</a><span>|</span><label class="collapse" for="c-37575641">[-]</label><label class="expand" for="c-37575641">[3 more]</label></div><br/><div class="children"><div class="content">Anyone know how this will impact loop performance?</div><br/><div id="37576115" class="c"><input type="checkbox" id="c-37576115" checked=""/><div class="controls bullet"><span class="by">jsmith45</span><span>|</span><a href="#37575641">parent</a><span>|</span><a href="#37575744">next</a><span>|</span><label class="collapse" for="c-37576115">[-]</label><label class="expand" for="c-37576115">[1 more]</label></div><br/><div class="children"><div class="content">Most commonly no impact. It can require an additional heap allocation per iteration if taking the address or capturing in a closure, but even in those cases escape analysis may be able to determine that the value can remain on the stack because it will not remain referenced longer than the current loop iteration. If that happens then this change has no impact.<p>I&#x27;m not sure how thorough Go&#x27;s escape analysis is, but nearly all programs that capture the loop variable in a closure and are not buggy right now could be shown to have that closure not escape by a sufficient thorough escape analysis. On the other hand for existing buggy programs, then perf hit is the same as assigning a variable and capturing that (the normal fix for the bug).<p>Google saw no statistically significant change in their benchmarks or internal applications.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;wiki&#x2F;LoopvarExperiment#will-the-change-make-programs-slower-by-causing-more-allocations">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;wiki&#x2F;LoopvarExperiment#will-the...</a></div><br/></div></div><div id="37575744" class="c"><input type="checkbox" id="c-37575744" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37575641">parent</a><span>|</span><a href="#37576115">prev</a><span>|</span><a href="#37575777">next</a><span>|</span><label class="collapse" for="c-37575744">[-]</label><label class="expand" for="c-37575744">[1 more]</label></div><br/><div class="children"><div class="content">Nonexistent? It can still reuse the memory if you don&#x27;t capture it. And if you were capturing it &quot;properly&quot; it was already making a copy.</div><br/></div></div></div></div><div id="37575777" class="c"><input type="checkbox" id="c-37575777" checked=""/><div class="controls bullet"><span class="by">orblivion</span><span>|</span><a href="#37575641">prev</a><span>|</span><a href="#37577955">next</a><span>|</span><label class="collapse" for="c-37575777">[-]</label><label class="expand" for="c-37575777">[4 more]</label></div><br/><div class="children"><div class="content">For migrating, I wonder if there are any tools that could, let&#x27;s say, go through your codebase and add a &quot;&#x2F;&#x2F; TODO - check&quot; to every place that might be affected.</div><br/><div id="37581717" class="c"><input type="checkbox" id="c-37581717" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575777">parent</a><span>|</span><a href="#37575886">next</a><span>|</span><label class="collapse" for="c-37581717">[-]</label><label class="expand" for="c-37581717">[1 more]</label></div><br/><div class="children"><div class="content">I know for previous code changes they had a tool that would just do a find &amp; replace for you.<p>But you&#x27;re describing a linter, which just outputs a line on your terminal with a warning; I wouldn&#x27;t want a tool like that to add churn and tasks to my codebase (even though I&#x27;m guilty of adding TODOs myself and leaving them for years because ultimately they&#x27;re not important enough)</div><br/></div></div><div id="37575886" class="c"><input type="checkbox" id="c-37575886" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37575777">parent</a><span>|</span><a href="#37581717">prev</a><span>|</span><a href="#37575815">next</a><span>|</span><label class="collapse" for="c-37575886">[-]</label><label class="expand" for="c-37575886">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a linter for it, perhaps more than one, in golangci-lint. It might be exportloopref and&#x2F;or loopclosure.</div><br/></div></div></div></div><div id="37577955" class="c"><input type="checkbox" id="c-37577955" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37575777">prev</a><span>|</span><a href="#37578066">next</a><span>|</span><label class="collapse" for="c-37577955">[-]</label><label class="expand" for="c-37577955">[2 more]</label></div><br/><div class="children"><div class="content">Is this a common way to fix problems in language syntax? It seems unintuitive to me. Now you need to know what version is declared in one file to understand behavior in another file. I understand they want to fix this but I did not know this way was allowed.</div><br/><div id="37579296" class="c"><input type="checkbox" id="c-37579296" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37577955">parent</a><span>|</span><a href="#37578066">next</a><span>|</span><label class="collapse" for="c-37579296">[-]</label><label class="expand" for="c-37579296">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is common. But probably the best option in this case.<p>The next best alternative is introducing a new construct for this version. But then you either risk people still using the old one or you need to break lots of fine code by removing the old construct. So in this case the &quot;in place&quot; upgrade made the most sense.<p>Tying it to the declared compiler version is much like Rust&#x27;s edition system or Perl&#x27;s versioning, except tacked into an existing identifier rather than a separate variable. (The downside being that you are forced to make this upgrade at some point if you want to raise your minimum toolchains version. )</div><br/></div></div></div></div><div id="37578066" class="c"><input type="checkbox" id="c-37578066" checked=""/><div class="controls bullet"><span class="by">fyzix</span><span>|</span><a href="#37577955">prev</a><span>|</span><a href="#37575967">next</a><span>|</span><label class="collapse" for="c-37578066">[-]</label><label class="expand" for="c-37578066">[2 more]</label></div><br/><div class="children"><div class="content">This will result in more memory allocations but it&#x27;s well worth it.</div><br/><div id="37578618" class="c"><input type="checkbox" id="c-37578618" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#37578066">parent</a><span>|</span><a href="#37575967">next</a><span>|</span><label class="collapse" for="c-37578618">[-]</label><label class="expand" for="c-37578618">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason it can&#x27;t be optimized away when they&#x27;re not necessary.</div><br/></div></div></div></div><div id="37576451" class="c"><input type="checkbox" id="c-37576451" checked=""/><div class="controls bullet"><span class="by">assbuttbuttass</span><span>|</span><a href="#37575967">prev</a><span>|</span><a href="#37575617">next</a><span>|</span><label class="collapse" for="c-37576451">[-]</label><label class="expand" for="c-37576451">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    for _, informer := range c.informerMap {
        informer := informer
        go informer.Run(stopCh)
    }

    for _, a := range alarms {
        a := a
        go a.Monitor(b)
    }

</code></pre>
Not sure what the difference could be, but let me take a guess. In one case, the loop variable is a pointer, and in the other case a value. The method call uses a pointer receiver, so in the value case the compiler automatically inserts a reference to the receiver?</div><br/><div id="37581727" class="c"><input type="checkbox" id="c-37581727" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37576451">parent</a><span>|</span><a href="#37580292">next</a><span>|</span><label class="collapse" for="c-37581727">[-]</label><label class="expand" for="c-37581727">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking at the naming, the top one is a map, the bottom one is a slice; that&#x27;s where my internal knowledge ends though. I know a slice will have a backing array on the heap so there&#x27;s some pointers &#x2F; references involved.</div><br/></div></div><div id="37580292" class="c"><input type="checkbox" id="c-37580292" checked=""/><div class="controls bullet"><span class="by">thebears5454</span><span>|</span><a href="#37576451">parent</a><span>|</span><a href="#37581727">prev</a><span>|</span><a href="#37575617">next</a><span>|</span><label class="collapse" for="c-37580292">[-]</label><label class="expand" for="c-37580292">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely something like that where the compiler knows to grab the value.</div><br/></div></div></div></div><div id="37575617" class="c"><input type="checkbox" id="c-37575617" checked=""/><div class="controls bullet"><span class="by">ravivooda</span><span>|</span><a href="#37576451">prev</a><span>|</span><a href="#37577810">next</a><span>|</span><label class="collapse" for="c-37575617">[-]</label><label class="expand" for="c-37575617">[2 more]</label></div><br/><div class="children"><div class="content">Similar: <a href="https:&#x2F;&#x2F;github.com&#x2F;ravivooda&#x2F;gofor">https:&#x2F;&#x2F;github.com&#x2F;ravivooda&#x2F;gofor</a></div><br/><div id="37576249" class="c"><input type="checkbox" id="c-37576249" checked=""/><div class="controls bullet"><span class="by">chen_dev</span><span>|</span><a href="#37575617">parent</a><span>|</span><a href="#37577810">next</a><span>|</span><label class="collapse" for="c-37576249">[-]</label><label class="expand" for="c-37576249">[1 more]</label></div><br/><div class="children"><div class="content">the &#x27;fix&#x27; to the example in the README should be obvious, but for reference:<p>- for _, e := range es {<p>-   pumpUp(&amp;e)<p>}<p>+ for i := range es {<p>+   pumpUp(&amp;es[i])<p>}</div><br/></div></div></div></div><div id="37577810" class="c"><input type="checkbox" id="c-37577810" checked=""/><div class="controls bullet"><span class="by">raydiatian</span><span>|</span><a href="#37575617">prev</a><span>|</span><a href="#37576497">next</a><span>|</span><label class="collapse" for="c-37577810">[-]</label><label class="expand" for="c-37577810">[4 more]</label></div><br/><div class="children"><div class="content">Can somebody please explain to me why this doesn’t constitute a major version due to a breaking change? Maybe I didn’t read precisely enough but it sure sounds like a breaking semantic, esp. with the fact that “this will only work for versions 1.22 and later.” Sounds like a version upgrade trap to me? What am I missing?<p>Or is it just because it’s Golang and they’re “we’ll never release a go v2 even if we actually do release go v2 and call it v1.x”</div><br/><div id="37581730" class="c"><input type="checkbox" id="c-37581730" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37577810">parent</a><span>|</span><a href="#37578193">next</a><span>|</span><label class="collapse" for="c-37581730">[-]</label><label class="expand" for="c-37581730">[1 more]</label></div><br/><div class="children"><div class="content">In practice it won&#x27;t break anything, unless there is code that accidentally relies on this behaviour. Most of the code affected by this will already have a workaround - the `x := x` mentioned - which can be removed after applying this change.</div><br/></div></div><div id="37578193" class="c"><input type="checkbox" id="c-37578193" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#37577810">parent</a><span>|</span><a href="#37581730">prev</a><span>|</span><a href="#37576497">next</a><span>|</span><label class="collapse" for="c-37578193">[-]</label><label class="expand" for="c-37578193">[2 more]</label></div><br/><div class="children"><div class="content">Seems like a pragmatic decision where the breakyness of the change is mitigated by the module versioning thing. Old code gets the old behavior, code written in newly created or updated modules gets the new behavior. Everybody is happy, compared to the alternative where this ships in a mythical go v2 which nobody uses while this sort of bug keeps sneaking people&#x27;s actual work.</div><br/><div id="37578939" class="c"><input type="checkbox" id="c-37578939" checked=""/><div class="controls bullet"><span class="by">raydiatian</span><span>|</span><a href="#37577810">root</a><span>|</span><a href="#37578193">parent</a><span>|</span><a href="#37576497">next</a><span>|</span><label class="collapse" for="c-37578939">[-]</label><label class="expand" for="c-37578939">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, must have missed the module versioning bit</div><br/></div></div></div></div></div></div><div id="37576497" class="c"><input type="checkbox" id="c-37576497" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#37577810">prev</a><span>|</span><a href="#37575845">next</a><span>|</span><label class="collapse" for="c-37576497">[-]</label><label class="expand" for="c-37576497">[1 more]</label></div><br/><div class="children"><div class="content">Thank god!!!</div><br/></div></div><div id="37575845" class="c"><input type="checkbox" id="c-37575845" checked=""/><div class="controls bullet"><span class="by">nzoschke</span><span>|</span><a href="#37576497">prev</a><span>|</span><a href="#37577226">next</a><span>|</span><label class="collapse" for="c-37575845">[-]</label><label class="expand" for="c-37575845">[39 more]</label></div><br/><div class="children"><div class="content">Thank you Go team and project!<p>Go continues to be my favorite language and experience to build and maintain in.<p>They got so much right from the start, then have managed to make consistent well reasoned, meaningful and safe improvements to the language over the years.<p>It’s not perfect, nothing is, but the “cost” of maintaining old code is so much lower compared to pretty much every other language I have used.</div><br/><div id="37576041" class="c"><input type="checkbox" id="c-37576041" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37575845">parent</a><span>|</span><a href="#37576871">next</a><span>|</span><label class="collapse" for="c-37576041">[-]</label><label class="expand" for="c-37576041">[26 more]</label></div><br/><div class="children"><div class="content">Go is such a productive language to work with, it&#x27;s absolutely mind blowing how little adoption it has around where I live. Well I guess Lunar went from node to java to go, and harvested insane benefits from it, but a lot of places have issues moving into new languages. Not that I think that you should necessarily swap to a new hipster tech, I really don&#x27;t, but Go is really the first language we&#x27;ve worked with that competes with Python as far as productivity goes. At least in my experience.<p>We&#x27;ll likely continue using Typescript as our main language for a while since we&#x27;re a small team and it lets us share resources better, but we&#x27;re definitely keeping an eye on Go.</div><br/><div id="37577302" class="c"><input type="checkbox" id="c-37577302" checked=""/><div class="controls bullet"><span class="by">rcv</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37576041">parent</a><span>|</span><a href="#37576107">next</a><span>|</span><label class="collapse" for="c-37577302">[-]</label><label class="expand" for="c-37577302">[22 more]</label></div><br/><div class="children"><div class="content">I typically develop in Python, C++, and Typescript, and recently had to implement some code in Go.  So far I&#x27;ve found it a pretty unpleasant language to use.  It feels pedantic when I don&#x27;t need it to be, and yet I have to deal with `interface{}` all over the place.  Simple things that would be a one-liner Python or TS (or even just an std::algorithm and a lambda in C++) feel like pulling teeth to me in Go.<p>I&#x27;d love to hear of any resources that can help me understand the Zen of Go, because so far I just don&#x27;t get it.</div><br/><div id="37577335" class="c"><input type="checkbox" id="c-37577335" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37577385">next</a><span>|</span><label class="collapse" for="c-37577335">[-]</label><label class="expand" for="c-37577335">[3 more]</label></div><br/><div class="children"><div class="content">I write Go every day, and can count the number of times per year I have to involve an `interface{}` literal on one hand. Unless you&#x27;re doing JSON wrong or working with an API that simply doesn&#x27;t care about returning consistently structured data, I can&#x27;t fathom why you&#x27;d be using it &quot;all over the place.&quot;</div><br/><div id="37578145" class="c"><input type="checkbox" id="c-37578145" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577335">parent</a><span>|</span><a href="#37577385">next</a><span>|</span><label class="collapse" for="c-37578145">[-]</label><label class="expand" for="c-37578145">[2 more]</label></div><br/><div class="children"><div class="content">Me too. We have around a dozen go services and I have maybe used or seen interface{} once or twice for a hack. Especially after generics. I think the parent comment is suffering from poor quality go code. It’s like complaining about typescript because things in your codebase don’t have types</div><br/><div id="37580726" class="c"><input type="checkbox" id="c-37580726" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37578145">parent</a><span>|</span><a href="#37577385">next</a><span>|</span><label class="collapse" for="c-37580726">[-]</label><label class="expand" for="c-37580726">[1 more]</label></div><br/><div class="children"><div class="content">Dealing with databases and data scanning into custom structs, you would be writing lots Scanner&#x2F;Valuer custom functions which use interface{}<p>If you are the lucky ones not dealing with databases, I sort-of envy you...!</div><br/></div></div></div></div></div></div><div id="37577385" class="c"><input type="checkbox" id="c-37577385" checked=""/><div class="controls bullet"><span class="by">Spiwux</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37577335">prev</a><span>|</span><a href="#37577465">next</a><span>|</span><label class="collapse" for="c-37577385">[-]</label><label class="expand" for="c-37577385">[12 more]</label></div><br/><div class="children"><div class="content">You discovered the Zen of Go. There are no magic one liners. It&#x27;s boring, explicit and procedural.<p>Proponents argue that this forced simplicity enhances productivity on a larger organisational scale when you take things such as onboarding into account.<p>I&#x27;m not sure if that is true. I also think a senior Python &#x2F; Java &#x2F; etc resource is going to be more productive than a senior Go resource.</div><br/><div id="37577469" class="c"><input type="checkbox" id="c-37577469" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577385">parent</a><span>|</span><a href="#37577433">next</a><span>|</span><label class="collapse" for="c-37577469">[-]</label><label class="expand" for="c-37577469">[10 more]</label></div><br/><div class="children"><div class="content">... so the code ends up being really long then.</div><br/><div id="37577494" class="c"><input type="checkbox" id="c-37577494" checked=""/><div class="controls bullet"><span class="by">Spiwux</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577469">parent</a><span>|</span><a href="#37577433">next</a><span>|</span><label class="collapse" for="c-37577494">[-]</label><label class="expand" for="c-37577494">[9 more]</label></div><br/><div class="children"><div class="content">Yes, pretty much. It&#x27;s a pain to write, but easy to read. On a larger scale the average engineer likely spends more time reading code than writing code</div><br/><div id="37577641" class="c"><input type="checkbox" id="c-37577641" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577494">parent</a><span>|</span><a href="#37577696">next</a><span>|</span><label class="collapse" for="c-37577641">[-]</label><label class="expand" for="c-37577641">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find go that easy to read. It is so verbose that the actual business logic ends up buried in a lot of boilerplate code. Maybe I&#x27;m bad at reading code, but it ends up being a lot of text to read for very little information.<p>Like a one-line list comprehension to transform a collection is suddenly four lines of go: allocation, loop iteration, and append (don&#x27;t even start me on the append function). I don&#x27;t care about those housekeeping details. Let me read the business logic.</div><br/><div id="37581836" class="c"><input type="checkbox" id="c-37581836" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577641">parent</a><span>|</span><a href="#37579363">next</a><span>|</span><label class="collapse" for="c-37581836">[-]</label><label class="expand" for="c-37581836">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a tradeoff; I too find one-liner list comprehensions like simple transforms or filters easier to read than the for loop equivalent.<p>However, it&#x27;s a dangerous tool that some people just can&#x27;t be trusted with. Second, if you go full FP style, then you can&#x27;t just hire a Go developer, they need additional training to become productive.<p>Here&#x27;s an example of functional programming within Go taken far: <a href="https:&#x2F;&#x2F;github.com&#x2F;IBM&#x2F;fp-go&#x2F;blob&#x2F;main&#x2F;samples&#x2F;http&#x2F;http_test.go">https:&#x2F;&#x2F;github.com&#x2F;IBM&#x2F;fp-go&#x2F;blob&#x2F;main&#x2F;samples&#x2F;http&#x2F;http_tes...</a>. It basically adds a DSL on top of Go, which goes against its principles of simplicity.<p>There was another great resource that explains why functional programming in Go is a Bad Idea; one is function syntax (there&#x27;s no shorthand (yet?)), the other is performance (no tail call optimization), and another is Go&#x27;s formatter will make it very convoluted; I think it was this one: <a href="https:&#x2F;&#x2F;www.jerf.org&#x2F;iri&#x2F;post&#x2F;2955&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jerf.org&#x2F;iri&#x2F;post&#x2F;2955&#x2F;</a></div><br/></div></div><div id="37579363" class="c"><input type="checkbox" id="c-37579363" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577641">parent</a><span>|</span><a href="#37581836">prev</a><span>|</span><a href="#37577696">next</a><span>|</span><label class="collapse" for="c-37579363">[-]</label><label class="expand" for="c-37579363">[5 more]</label></div><br/><div class="children"><div class="content">Go offers a programming interface at a lower level of abstraction than languages like Python or Ruby. What you call boilerplate or housekeeping, I consider to be mechanical sympathy.<p>Modulo extremes like Java, the bottleneck for programmers understanding code is about semantics, not syntax -- effectively never the literal SLoC in source files. It&#x27;s not as if<p><pre><code>    for i := range x {
        x[i] = fn(x[i])
    }
</code></pre>
is any slower to read, or more difficult to parse, or whatever, than e.g.<p><pre><code>    x.transform(fn)
</code></pre>
in any meaningful sense.</div><br/><div id="37581859" class="c"><input type="checkbox" id="c-37581859" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37579363">parent</a><span>|</span><a href="#37579517">next</a><span>|</span><label class="collapse" for="c-37581859">[-]</label><label class="expand" for="c-37581859">[1 more]</label></div><br/><div class="children"><div class="content">One caveat; if `fn` is declared inline when calling that function, it&#x27;s not very pretty because Go doesn&#x27;t have a function shorthand (yet?):<p><pre><code>    x.transform(func(value int) string { return fmt.Sprintf(&quot;%b&quot;, value) })
</code></pre>
This quickly becomes more difficult to read, especially if you want to chain some operations this way.<p>But this applies to other languages as well, in JS (which has a function shorthand) I prefer to extract the predicates and give them a meaningful name.</div><br/></div></div><div id="37579517" class="c"><input type="checkbox" id="c-37579517" checked=""/><div class="controls bullet"><span class="by">xmcqdpt2</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37579363">parent</a><span>|</span><a href="#37581859">prev</a><span>|</span><a href="#37579937">next</a><span>|</span><label class="collapse" for="c-37579517">[-]</label><label class="expand" for="c-37579517">[2 more]</label></div><br/><div class="children"><div class="content">Your example is very simple though.<p>What&#x27;s the go equivalent to<p><pre><code>  x.map(fn).filter(predicate)
</code></pre>
ie returning a new collection of transformed items which is filtered by some predicate? Now we are talking more like 5-6 lines of Go.</div><br/><div id="37581908" class="c"><input type="checkbox" id="c-37581908" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37579517">parent</a><span>|</span><a href="#37579937">next</a><span>|</span><label class="collapse" for="c-37581908">[-]</label><label class="expand" for="c-37581908">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s the go equivalent to x.map(fn).filter(predicate)<p>Probably something like<p><pre><code>    var output []T
    for _, val := range input {
        if newval := transform(val); allow(newval) {
            output = append(output, newval)
        }
    }
</code></pre>
No problem?</div><br/></div></div></div></div><div id="37579937" class="c"><input type="checkbox" id="c-37579937" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37579363">parent</a><span>|</span><a href="#37579517">prev</a><span>|</span><a href="#37577696">next</a><span>|</span><label class="collapse" for="c-37579937">[-]</label><label class="expand" for="c-37579937">[1 more]</label></div><br/><div class="children"><div class="content">So my 2¢ as someone who&#x27;s just been skimming this thread: I read the second example faster. I mean it&#x27;s like 2 seconds vs 5 seconds, but in the first I have to actually read your loop to see what it&#x27;s doing, whereas in the latter I can just go &quot;oh apply fn over x&quot;.</div><br/></div></div></div></div></div></div><div id="37577696" class="c"><input type="checkbox" id="c-37577696" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577494">parent</a><span>|</span><a href="#37577641">prev</a><span>|</span><a href="#37577433">next</a><span>|</span><label class="collapse" for="c-37577696">[-]</label><label class="expand" for="c-37577696">[1 more]</label></div><br/><div class="children"><div class="content">I think that shorter code is easier to read - to a point! on balance most code is too long, not too short.</div><br/></div></div></div></div></div></div><div id="37577433" class="c"><input type="checkbox" id="c-37577433" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577385">parent</a><span>|</span><a href="#37577469">prev</a><span>|</span><a href="#37577465">next</a><span>|</span><label class="collapse" for="c-37577433">[-]</label><label class="expand" for="c-37577433">[1 more]</label></div><br/><div class="children"><div class="content">Go seems like the antithesis to Lisp.</div><br/></div></div></div></div><div id="37577465" class="c"><input type="checkbox" id="c-37577465" checked=""/><div class="controls bullet"><span class="by">gtowey</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37577385">prev</a><span>|</span><a href="#37580483">next</a><span>|</span><label class="collapse" for="c-37577465">[-]</label><label class="expand" for="c-37577465">[2 more]</label></div><br/><div class="children"><div class="content">Go is the language that&#x27;s not made for you, it&#x27;s made to make the life of the next guy who has to maintain your code easier! :-)</div><br/><div id="37581964" class="c"><input type="checkbox" id="c-37581964" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577465">parent</a><span>|</span><a href="#37580483">next</a><span>|</span><label class="collapse" for="c-37581964">[-]</label><label class="expand" for="c-37581964">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a great way to phrase it, I&#x27;m going to steal that :D</div><br/></div></div></div></div><div id="37580483" class="c"><input type="checkbox" id="c-37580483" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37577465">prev</a><span>|</span><a href="#37577476">next</a><span>|</span><label class="collapse" for="c-37580483">[-]</label><label class="expand" for="c-37580483">[1 more]</label></div><br/><div class="children"><div class="content">If I asked you to carve wood, would you prefer a carving knife or a Victorinox multipurpose tool? I get that it’s a bit or a cheesy analogy, but it’s basically why I liked Go. To me it’s the language that Python would have been if Python hasn’t been designed so long a go and is now caught in its myriad of opinions. Because I certainly get why you wouldn’t like an opinionated language, I really do. It’s just that after more than a decade, often spent cleaning up code for businesses that needed something to work better, I’ve really come to appreciate it when things are very simple and maintainable, and Go does that.<p>Similarly I’m not sure you would like working with Typescript in my team. Our linter is extremely pedantic, and will sometimes force you to write multiple lines of code for what could probably have been a one liner. Not always, mind you, but for the things we know will cause problems for some new hire down the line. (Or for yourself if you’re like me and can’t remember what you ate for breakfast). The smaller the responsibility, the less abstraction and the cleaner your code the easier it’ll be to do something with in 6+ months. Now, our linter is a total fascist, but it’s a group effort. We each contribute and we alter it to make it make sense for us as a team, and that’s frankly great. It’s nice that the ability to do this, and the ability to build in-house packages, is so easy in the Node ecosystem, but it’s still a lot of work that Go basically does for you.<p>So the zen is in relinquishing your freedom to architect the “linguistics” of your code and simply work on what really matters.<p>I’ve never used Interface{}.</div><br/></div></div><div id="37577476" class="c"><input type="checkbox" id="c-37577476" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37580483">prev</a><span>|</span><a href="#37580361">next</a><span>|</span><label class="collapse" for="c-37577476">[-]</label><label class="expand" for="c-37577476">[1 more]</label></div><br/><div class="children"><div class="content">One of the big things that I’ve found helped is to “stop being an architect”. Basically defer abstraction more.<p>People, esp from a Java-esque class based world want class inheritance and generics and all that jazz. I’ve found at work like 50% of methods and logic that has some sort of generic&#x2F;superclass&#x2F;OOP style abstraction feature only ever has 1 implemented type. Just use that type and when the second one shows up… then try to make some sort of abstraction.<p>For context, I can’t remember the last time that I actually used “interface{}”. Actual interfaces are cheap in go, so you can define the interface at use-time and pretty cheaply add the methods (or a wrapper) if needed.<p>If you’re actually doing abstract algorithms and stuff every day at work… you’re in the minority so I don’t know but all the CRUD type services are pretty ergonomic when you realize YAGNI when it comes to those extra abstractions.<p>Edit: also f** one liners. Make it 2 or three lines. It’s ok.</div><br/></div></div><div id="37580361" class="c"><input type="checkbox" id="c-37580361" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37577476">prev</a><span>|</span><a href="#37579243">next</a><span>|</span><label class="collapse" for="c-37580361">[-]</label><label class="expand" for="c-37580361">[1 more]</label></div><br/><div class="children"><div class="content">Since the advent of generics I rarely ever use `interface{}`.</div><br/></div></div><div id="37579243" class="c"><input type="checkbox" id="c-37579243" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577302">parent</a><span>|</span><a href="#37580361">prev</a><span>|</span><a href="#37576107">next</a><span>|</span><label class="collapse" for="c-37579243">[-]</label><label class="expand" for="c-37579243">[1 more]</label></div><br/><div class="children"><div class="content">interface{} is a pretty strong code smell.</div><br/></div></div></div></div><div id="37576107" class="c"><input type="checkbox" id="c-37576107" checked=""/><div class="controls bullet"><span class="by">hagbarth</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37576041">parent</a><span>|</span><a href="#37577302">prev</a><span>|</span><a href="#37576871">next</a><span>|</span><label class="collapse" for="c-37576107">[-]</label><label class="expand" for="c-37576107">[3 more]</label></div><br/><div class="children"><div class="content">One of the reasons I like Go is that it really doesn&#x27;t try to be a hipster language. It&#x27;s kinda boring, which is great!</div><br/><div id="37577041" class="c"><input type="checkbox" id="c-37577041" checked=""/><div class="controls bullet"><span class="by">Philip-J-Fry</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37576107">parent</a><span>|</span><a href="#37576871">next</a><span>|</span><label class="collapse" for="c-37577041">[-]</label><label class="expand" for="c-37577041">[2 more]</label></div><br/><div class="children"><div class="content">Boring is good when you want to build things that are maintainable by 100s of devs.<p>Something we have experienced over and over is that devs moving from languages like C# or Java just love how easy and straight forwarding developing in Go is. They pick it up in a week or two, the tool chain is just so simple, there&#x27;s no arguing around what languages features we can and can&#x27;t use.<p>Almost everyone I&#x27;ve spoke to finds it incredibly productive. These people want to be delivering features and products and it makes it easy for them to do so.</div><br/><div id="37578059" class="c"><input type="checkbox" id="c-37578059" checked=""/><div class="controls bullet"><span class="by">VirusNewbie</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577041">parent</a><span>|</span><a href="#37576871">next</a><span>|</span><label class="collapse" for="c-37578059">[-]</label><label class="expand" for="c-37578059">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a 100 devs Go is fine, but it gets to be a nightmare as you scale beyond that.<p>Language abstractions exist to prevent having developers build their own ad-hoc abstractions, and you find this time and time again in languages like Go.  You can read the Kubernetes code and see what I mean, they go out of their way to work around some of the missing language features.</div><br/></div></div></div></div></div></div></div></div><div id="37576871" class="c"><input type="checkbox" id="c-37576871" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37575845">parent</a><span>|</span><a href="#37576041">prev</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37576871">[-]</label><label class="expand" for="c-37576871">[11 more]</label></div><br/><div class="children"><div class="content">&gt; They got so much right from the start, then have managed to make consistent well reasoned, meaningful and safe improvements to the language over the years<p>In which universe? They have to constantly patch the language up and go back on previous assumptions.</div><br/><div id="37577582" class="c"><input type="checkbox" id="c-37577582" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37576871">parent</a><span>|</span><a href="#37577147">next</a><span>|</span><label class="collapse" for="c-37577582">[-]</label><label class="expand" for="c-37577582">[2 more]</label></div><br/><div class="children"><div class="content">Fast compiler, simple tooling, baked in fmt, simple cross platform compilation, decent standard library, a tendency towards good enough performance if doing things the Go way, async without function coloring. They got some things right and some things wrong. When tossing out orthodoxy, you’ll tend to get some things wrong. I think a lack of sum types is my biggest gripe.</div><br/><div id="37578147" class="c"><input type="checkbox" id="c-37578147" checked=""/><div class="controls bullet"><span class="by">nzoschke</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577582">parent</a><span>|</span><a href="#37577147">next</a><span>|</span><label class="collapse" for="c-37578147">[-]</label><label class="expand" for="c-37578147">[1 more]</label></div><br/><div class="children"><div class="content">The std library is a big part of the magic. It’s so shocking to go to JS land and see that there are 10 different 3rd party libraries to make http requests, all with wildly different ergonomics all within one code base due to cross dependency heck.<p>In Go there’s pretty much only the http package, and any 3rd party packages extend it and have the same ergonomics.<p>For a while my biggest gripe was package management but it’s a dream where we are now.</div><br/></div></div></div></div><div id="37577147" class="c"><input type="checkbox" id="c-37577147" checked=""/><div class="controls bullet"><span class="by">13415</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37576871">parent</a><span>|</span><a href="#37577582">prev</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37577147">[-]</label><label class="expand" for="c-37577147">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the <i>first</i> language change that can in theory break programs (in practice, it won&#x27;t). Everything else was just additions to the existing language with full backwards compatibility. That&#x27;s the opposite of constantly patching the language up.</div><br/><div id="37577266" class="c"><input type="checkbox" id="c-37577266" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577147">parent</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37577266">[-]</label><label class="expand" for="c-37577266">[7 more]</label></div><br/><div class="children"><div class="content">You can patch things up without breaking backwards compatibility.<p>But, going on a well-trodden path slower than the pioneers is not a big achievement.</div><br/><div id="37577653" class="c"><input type="checkbox" id="c-37577653" checked=""/><div class="controls bullet"><span class="by">vlunkr</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577266">parent</a><span>|</span><a href="#37577358">next</a><span>|</span><label class="collapse" for="c-37577653">[-]</label><label class="expand" for="c-37577653">[1 more]</label></div><br/><div class="children"><div class="content">So how do you think they are &quot;patching things up&quot; more than other languages?</div><br/></div></div><div id="37577358" class="c"><input type="checkbox" id="c-37577358" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577266">parent</a><span>|</span><a href="#37577653">prev</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37577358">[-]</label><label class="expand" for="c-37577358">[5 more]</label></div><br/><div class="children"><div class="content">Please point to when Go has broken backwards compatibility.</div><br/><div id="37577499" class="c"><input type="checkbox" id="c-37577499" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577358">parent</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37577499">[-]</label><label class="expand" for="c-37577499">[4 more]</label></div><br/><div class="children"><div class="content">That’s not my point.<p>Smart men learn from the mistakes of others.</div><br/><div id="37578088" class="c"><input type="checkbox" id="c-37578088" checked=""/><div class="controls bullet"><span class="by">nzoschke</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577499">parent</a><span>|</span><a href="#37578712">next</a><span>|</span><label class="collapse" for="c-37578088">[-]</label><label class="expand" for="c-37578088">[1 more]</label></div><br/><div class="children"><div class="content">Obviously different perspectives in this thread.<p>Robert Griesemer, Rob Pike, and Ken Thompson are objectively smart men and pioneers and have learned from lots of mistakes both they and the industry made.<p>Go embodied a lot of those learnings out of the gate.<p>If the bar is to be perfect out of the gate that’s impossible and I can’t think of any language that could pretend to be so.<p>Go was very good out of the gate and has slowly but surely evolved to be great.</div><br/></div></div><div id="37578712" class="c"><input type="checkbox" id="c-37578712" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37577499">parent</a><span>|</span><a href="#37578088">prev</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37578712">[-]</label><label class="expand" for="c-37578712">[2 more]</label></div><br/><div class="children"><div class="content">Java only just got green threads (goroutines), 11 years after Go 1.0 was introduced.  CSP had been around for yonks.<p>Nothing is perfect to begin with, and I think you could probably be a bit kinder to Golang here.</div><br/><div id="37580886" class="c"><input type="checkbox" id="c-37580886" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#37575845">root</a><span>|</span><a href="#37578712">parent</a><span>|</span><a href="#37578126">next</a><span>|</span><label class="collapse" for="c-37580886">[-]</label><label class="expand" for="c-37580886">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Green threads were briefly available in Java between 1997 and 2000.<p>-- <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Green_thread" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Green_thread</a><p>Also see <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;5713142&#x2F;green-threads-vs-non-green-threads" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;5713142&#x2F;green-threads-vs...</a> , <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E19455-01&#x2F;806-3461&#x2F;6jck06gqe&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E19455-01&#x2F;806-3461&#x2F;6jck06gqe&#x2F;inde...</a> .</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37577226" class="c"><input type="checkbox" id="c-37577226" checked=""/><div class="controls bullet"><span class="by">Spiwux</span><span>|</span><a href="#37575845">prev</a><span>|</span><a href="#37575695">next</a><span>|</span><label class="collapse" for="c-37577226">[-]</label><label class="expand" for="c-37577226">[6 more]</label></div><br/><div class="children"><div class="content">I have such a love-hate relationship with this language. I use it professionally every single day, and every single day there are moments when I think to myself &quot;this could be solved much more elegantly in language X&quot; or &quot;I wish Go had this feature.&quot;<p>Then again I also can&#x27;t deny that the lack of &quot;&quot;advanced&quot;&quot; features forces you to keep your code simple, which makes reading easier. So while I hate writing Go, I like reading unfamiliar Go code due to a distinct lack of magic. Go code always clearly spells out what it does.</div><br/><div id="37577754" class="c"><input type="checkbox" id="c-37577754" checked=""/><div class="controls bullet"><span class="by">bvinc</span><span>|</span><a href="#37577226">parent</a><span>|</span><a href="#37577714">next</a><span>|</span><label class="collapse" for="c-37577754">[-]</label><label class="expand" for="c-37577754">[1 more]</label></div><br/><div class="children"><div class="content">“Love-hate relationship” were the exact words that I used when I used go professionally every day.<p>I could complain all day about things the language does obviously wrong, often in the name of simplicity. But after all my complaints I still admit it’s a very good choice for certain kinds of software and software companies.</div><br/></div></div><div id="37577714" class="c"><input type="checkbox" id="c-37577714" checked=""/><div class="controls bullet"><span class="by">jamespwilliams</span><span>|</span><a href="#37577226">parent</a><span>|</span><a href="#37577754">prev</a><span>|</span><a href="#37578309">next</a><span>|</span><label class="collapse" for="c-37577714">[-]</label><label class="expand" for="c-37577714">[1 more]</label></div><br/><div class="children"><div class="content">Go is the worst language, except all the others</div><br/></div></div><div id="37578309" class="c"><input type="checkbox" id="c-37578309" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#37577226">parent</a><span>|</span><a href="#37577714">prev</a><span>|</span><a href="#37577964">next</a><span>|</span><label class="collapse" for="c-37578309">[-]</label><label class="expand" for="c-37578309">[1 more]</label></div><br/><div class="children"><div class="content">I’m in the same boat. Every once in a while, I go back and look at my old Haskell, OCaml, and Go code, and I remember why I like Go. Generally, I can hop back into my old code easily. That’s not true with more advanced languages. I just can’t resist the urge to be clever when writing them. OCaml is still pretty nice, though. Not gonna lie.</div><br/></div></div><div id="37577964" class="c"><input type="checkbox" id="c-37577964" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#37577226">parent</a><span>|</span><a href="#37578309">prev</a><span>|</span><a href="#37578131">next</a><span>|</span><label class="collapse" for="c-37577964">[-]</label><label class="expand" for="c-37577964">[1 more]</label></div><br/><div class="children"><div class="content">The first point cannot bother you after you&#x27;ve correctly realized your second point. The more empathy you have for your future-self or your peers, the clearer it becomes.</div><br/></div></div></div></div><div id="37575695" class="c"><input type="checkbox" id="c-37575695" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37577226">prev</a><span>|</span><a href="#37576900">next</a><span>|</span><label class="collapse" for="c-37575695">[-]</label><label class="expand" for="c-37575695">[45 more]</label></div><br/><div class="children"><div class="content">This was also an issue in Javascript (e.g. <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;for" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a>)<p>It&#x27;s somewhat amusing to see Go rediscover old ideas in programming language theory, given the stance against PLT that the Go developers took in the early years of the language.</div><br/><div id="37576710" class="c"><input type="checkbox" id="c-37576710" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37575993">next</a><span>|</span><label class="collapse" for="c-37576710">[-]</label><label class="expand" for="c-37576710">[8 more]</label></div><br/><div class="children"><div class="content">The entire story of go seems to be learning through repeating the same mistakes as other languages, one at a time.<p>Nil being another big one. Even more impressively they doubled down on this mistake with <i>typed</i> nils. Even if you explicitly do a comparison with nil you can still shoot yourself in the foot because it was a different nil than the one you compared against.</div><br/><div id="37576884" class="c"><input type="checkbox" id="c-37576884" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576710">parent</a><span>|</span><a href="#37575993">next</a><span>|</span><label class="collapse" for="c-37576884">[-]</label><label class="expand" for="c-37576884">[7 more]</label></div><br/><div class="children"><div class="content">Wait what? Do you have an example or more information on this?</div><br/><div id="37577022" class="c"><input type="checkbox" id="c-37577022" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576884">parent</a><span>|</span><a href="#37577069">next</a><span>|</span><label class="collapse" for="c-37577022">[-]</label><label class="expand" for="c-37577022">[4 more]</label></div><br/><div class="children"><div class="content">Basic example:<p><pre><code>    func foo() *bar {
      &#x2F;&#x2F; ...
      if something_wrong {
        return nil;
      }
    }
    
    var x interface{}
    
    x = bar()
    
    if x != nil {
      &#x2F;&#x2F; Dereference x
    }
</code></pre>
This will crash if `foo()` returns nil, because it&#x27;s checking if  `x == interface{}(nil)`, which is false. What you wanted to check was whether `x == *bar{nil}` or one of the other nil types that implements the interface; which must be done with `reflect.ValueOf(x).IsNil()`.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;30865">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;30865</a></div><br/><div id="37579394" class="c"><input type="checkbox" id="c-37579394" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577022">parent</a><span>|</span><a href="#37577069">next</a><span>|</span><label class="collapse" for="c-37579394">[-]</label><label class="expand" for="c-37579394">[3 more]</label></div><br/><div class="children"><div class="content">This is a great example of code that compiles, but would never pass code review at any decent organization. Specifically, you&#x27;d never assign a concrete return value like *bar to an interface{} and expect `x != nil` to behave like this code would imply.</div><br/><div id="37579532" class="c"><input type="checkbox" id="c-37579532" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579394">parent</a><span>|</span><a href="#37577069">next</a><span>|</span><label class="collapse" for="c-37579532">[-]</label><label class="expand" for="c-37579532">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it’s a contrived example. But it’s not like this is some obscure thing that no go programmer has ever run into in practice. It’s something I’d wager almost everyone has encountered if they’ve used it longer than a year.<p><a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2017&#x2F;08&#x2F;09&#x2F;typed-nils-in-go-2" rel="nofollow noreferrer">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2017&#x2F;08&#x2F;09&#x2F;typed-nils-in-go-2</a><p>If Dave Cheney says it hits every go programmer at least once, it caused hours of consternation for his coworkers, and it even has its own entry in the language FAQ, I don’t know what else to tell you.</div><br/><div id="37580804" class="c"><input type="checkbox" id="c-37580804" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579532">parent</a><span>|</span><a href="#37577069">next</a><span>|</span><label class="collapse" for="c-37580804">[-]</label><label class="expand" for="c-37580804">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s a not-uncommon gotcha or foot-gun. No argument there. But, like many other gotchas and foot-guns, they are not too difficult to spot in code review.</div><br/></div></div></div></div></div></div></div></div><div id="37577069" class="c"><input type="checkbox" id="c-37577069" checked=""/><div class="controls bullet"><span class="by">Spiwux</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576884">parent</a><span>|</span><a href="#37577022">prev</a><span>|</span><a href="#37576978">next</a><span>|</span><label class="collapse" for="c-37577069">[-]</label><label class="expand" for="c-37577069">[1 more]</label></div><br/><div class="children"><div class="content">e.g.<p><pre><code>  var typeA Interface = (*TypeA)(nil)
  println(typeA == nil)           &#x2F;&#x2F; false
  println(typeA == (*TypeA)(nil)) &#x2F;&#x2F; true
</code></pre>
Yes really
<a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;sz44kJW8OuT" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;sz44kJW8OuT</a></div><br/></div></div><div id="37576978" class="c"><input type="checkbox" id="c-37576978" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576884">parent</a><span>|</span><a href="#37577069">prev</a><span>|</span><a href="#37575993">next</a><span>|</span><label class="collapse" for="c-37576978">[-]</label><label class="expand" for="c-37576978">[1 more]</label></div><br/><div class="children"><div class="content">op is confused with nil interface.</div><br/></div></div></div></div></div></div><div id="37575993" class="c"><input type="checkbox" id="c-37575993" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37576710">prev</a><span>|</span><a href="#37576772">next</a><span>|</span><label class="collapse" for="c-37575993">[-]</label><label class="expand" for="c-37575993">[11 more]</label></div><br/><div class="children"><div class="content">Programming languages are an exercise in compromise,  not pure application of theory.  Well,  except maybe Haskell and it&#x27;s ilk,  but this should be your expectation of most languages and generally not a surprise.</div><br/><div id="37576380" class="c"><input type="checkbox" id="c-37576380" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37575993">parent</a><span>|</span><a href="#37576535">next</a><span>|</span><label class="collapse" for="c-37576380">[-]</label><label class="expand" for="c-37576380">[9 more]</label></div><br/><div class="children"><div class="content">I think OP’s point is that given the go devs casual disregard for every development in PL theory and design over the last 30 years, it’s amusing to watch them rediscover half the issues from scratch.</div><br/><div id="37576827" class="c"><input type="checkbox" id="c-37576827" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576380">parent</a><span>|</span><a href="#37576535">next</a><span>|</span><label class="collapse" for="c-37576827">[-]</label><label class="expand" for="c-37576827">[8 more]</label></div><br/><div class="children"><div class="content">This meme is commonly repeated on HN, but I think it&#x27;s inaccurate or at least greatly exaggerated.<p>There&#x27;s nothing <i>casual</i> about Go&#x27;s approach to language design, and I haven&#x27;t seen any evidence that they&#x27;re <i>unaware</i> of what other languages do.<p>I also haven&#x27;t seen much criticism of languages other than C++ or Java.</div><br/><div id="37577145" class="c"><input type="checkbox" id="c-37577145" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576827">parent</a><span>|</span><a href="#37577275">next</a><span>|</span><label class="collapse" for="c-37577145">[-]</label><label class="expand" for="c-37577145">[2 more]</label></div><br/><div class="children"><div class="content">If they&#x27;re aware of how other languages either handle these issues or suffer the consequences of not handling them, then it sure is odd that they consciously decided to introduce the same issues into their own language, only to fix them down the road.</div><br/><div id="37577566" class="c"><input type="checkbox" id="c-37577566" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577145">parent</a><span>|</span><a href="#37577275">next</a><span>|</span><label class="collapse" for="c-37577566">[-]</label><label class="expand" for="c-37577566">[1 more]</label></div><br/><div class="children"><div class="content">Given Go’s success, it seems like fixing certain footguns <i>much later</i> actually worked out pretty well for them? That doesn’t necessarily mean it was right, but it was perhaps not as big a deal as some people assume.</div><br/></div></div></div></div><div id="37577275" class="c"><input type="checkbox" id="c-37577275" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576827">parent</a><span>|</span><a href="#37577145">prev</a><span>|</span><a href="#37576535">next</a><span>|</span><label class="collapse" for="c-37577275">[-]</label><label class="expand" for="c-37577275">[5 more]</label></div><br/><div class="children"><div class="content">Sum&#x2F;Product types. Generics&#x2F;type-parameters. Bizarre handling of nil in places. Error handling that’s like some deliberately crippled version of a Result&lt;T,E&gt;. The absolutely unhinged decision about zero-value-defaults for types. I’m sure other people can think of some more, but that’s the ones I can think of off the top of my head.<p>Non PL theory but related: incorrect implementation of monotonic clocks, and then refusing to fix it because “just use google smear time bro”.</div><br/><div id="37579405" class="c"><input type="checkbox" id="c-37579405" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577275">parent</a><span>|</span><a href="#37577613">next</a><span>|</span><label class="collapse" for="c-37579405">[-]</label><label class="expand" for="c-37579405">[3 more]</label></div><br/><div class="children"><div class="content">Go definitely implements monotonic clocks correctly?<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;time#hdr-Monotonic_Clocks" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;time#hdr-Monotonic_Clocks</a></div><br/><div id="37579500" class="c"><input type="checkbox" id="c-37579500" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579405">parent</a><span>|</span><a href="#37577613">next</a><span>|</span><label class="collapse" for="c-37579500">[-]</label><label class="expand" for="c-37579500">[2 more]</label></div><br/><div class="children"><div class="content">It definitely didn’t used to lol:<p><a href="https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;i-want-off-mr-golangs-wild-ride" rel="nofollow noreferrer">https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;i-want-off-mr-golangs-wild-...</a></div><br/><div id="37580635" class="c"><input type="checkbox" id="c-37580635" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579500">parent</a><span>|</span><a href="#37577613">next</a><span>|</span><label class="collapse" for="c-37580635">[-]</label><label class="expand" for="c-37580635">[1 more]</label></div><br/><div class="children"><div class="content">That article is so cringeworthy</div><br/></div></div></div></div></div></div><div id="37577613" class="c"><input type="checkbox" id="c-37577613" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577275">parent</a><span>|</span><a href="#37579405">prev</a><span>|</span><a href="#37576535">next</a><span>|</span><label class="collapse" for="c-37577613">[-]</label><label class="expand" for="c-37577613">[1 more]</label></div><br/><div class="children"><div class="content">Everyone who disagrees with you is “unhinged.” This is just name-calling.</div><br/></div></div></div></div></div></div></div></div><div id="37576535" class="c"><input type="checkbox" id="c-37576535" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37575993">parent</a><span>|</span><a href="#37576380">prev</a><span>|</span><a href="#37576772">next</a><span>|</span><label class="collapse" for="c-37576535">[-]</label><label class="expand" for="c-37576535">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no need for compromise in this case. This issue is something I learned about in the late 90s &#x2F; early 2000s when I started reading about programming language theory. It&#x27;s found in introductory textbooks.</div><br/></div></div></div></div><div id="37576772" class="c"><input type="checkbox" id="c-37576772" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37575993">prev</a><span>|</span><a href="#37576605">next</a><span>|</span><label class="collapse" for="c-37576772">[-]</label><label class="expand" for="c-37576772">[4 more]</label></div><br/><div class="children"><div class="content">It’s also amusing to see someone talk about JavaScript and PLT in the same sentence, given the practical origins of JS.</div><br/><div id="37576902" class="c"><input type="checkbox" id="c-37576902" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576772">parent</a><span>|</span><a href="#37576605">next</a><span>|</span><label class="collapse" for="c-37576902">[-]</label><label class="expand" for="c-37576902">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not making any claims about the quality of design in JS here. I&#x27;m literally not talking about them in the same sentence for this reason. I&#x27;m, instead, merely noting that it had the same issue. Looks like it was fixed in 2014: <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2014&#x2F;06&#x2F;06&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2014&#x2F;06&#x2F;06&#x2F;</a>  C# also had the same issue, as noted elsewhere in the comments.</div><br/><div id="37578372" class="c"><input type="checkbox" id="c-37578372" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576902">parent</a><span>|</span><a href="#37578021">next</a><span>|</span><label class="collapse" for="c-37578372">[-]</label><label class="expand" for="c-37578372">[1 more]</label></div><br/><div class="children"><div class="content">It simply seems disingenuous to talk about how this was an issue in JS and then go on to say that Go devs have a &quot;stance against PLT&quot;. JS is not renowned for being an exemplar of PLT, so why would the Go developers use it as a reference point for their own design? JavaScript can&#x27;t even take the address of a variable - which is the underlying problem here.<p>In any case - I seem to remember that they discussed the rationale for the original decision in the release notes for go 1.21, along with additional context.<p>For whatever it&#x27;s worth, I don&#x27;t see any evidence that Go is specifically antagonistic to programming language theory at all - the existence of first-class constructs like channels and closures suggests otherwise. There are always costs and tradeoffs involved in adopting certain theoretical paradigms, and PLT is subject to fashion as much as any other endeavour.<p>Go focusses on simplicity, and when talking about simplicity I really like this quote from Dijkstra:<p><pre><code>    &quot;Simplicity requires hard work to be obtained and education for its appreciation, and complexity sells much better.” [0]
</code></pre>
I think Go works hard to be simple, and sometimes that comes across as being simplistic. Indeed, I was sceptical of Go when I set out to learn it, but having spent enough time with it to consider myself a professional Go developer, I also find that enjoy coding more than I have for many years, `err != nil` notwithstanding.<p>[0] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD10xx&#x2F;EWD1041.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD10xx&#x2F;E...</a></div><br/></div></div></div></div></div></div><div id="37576605" class="c"><input type="checkbox" id="c-37576605" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37576772">prev</a><span>|</span><a href="#37576629">next</a><span>|</span><label class="collapse" for="c-37576605">[-]</label><label class="expand" for="c-37576605">[5 more]</label></div><br/><div class="children"><div class="content">MDN goes into great detail, but the important point is that JavaScript fixed this with let and const.<p><pre><code>    &gt; a = []; for (i = 0; i &lt; 3; i++) a.push(() =&gt; i); a.map(f =&gt; f())
    [ 3, 3, 3 ]
    &gt; a = []; for (let i = 0; i &lt; 3; i++) a.push(() =&gt; i); a.map(f =&gt; f())
    [ 0, 1, 2 ]
    &gt; a = []; for (i of &quot;abc&quot;) a.push(() =&gt; i); a.map(f =&gt; f())
    [ &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27; ]
    &gt; a = []; for (const i of &quot;abc&quot;) a.push(() =&gt; i); a.map(f =&gt; f())
    [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</code></pre></div><br/><div id="37578124" class="c"><input type="checkbox" id="c-37578124" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576605">parent</a><span>|</span><a href="#37577243">next</a><span>|</span><label class="collapse" for="c-37578124">[-]</label><label class="expand" for="c-37578124">[3 more]</label></div><br/><div class="children"><div class="content">But isn&#x27;t it <i>completely wild</i> that the `for (let i =`... version works like that? What does the loop &#x27;desugar&#x27; into if written as a while-loop?</div><br/><div id="37578554" class="c"><input type="checkbox" id="c-37578554" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37578124">parent</a><span>|</span><a href="#37577243">next</a><span>|</span><label class="collapse" for="c-37578554">[-]</label><label class="expand" for="c-37578554">[2 more]</label></div><br/><div class="children"><div class="content">Before let&#x2F;const, scopes could only be introduced at function level, so @babel&#x2F;plugin-transform-block-scoping transpiles it using an extra function:<p><pre><code>    var _loop = function (i) {
      a.push(() =&gt; i);
    };
    for (var i = 0; i &lt; 3; i++) {
      _loop(i);
    }
</code></pre>
The key is that the scoping happens for each iteration, not around the entire loop. That detail is nonobvious, given how many other languages have gotten it wrong, but I wouldn’t say it’s wild.<p>(If you’re curious how Babel deals with the more complicated cases of break&#x2F;continue, labelled break&#x2F;continue, and return, try it out at <a href="https:&#x2F;&#x2F;babeljs.io&#x2F;repl" rel="nofollow noreferrer">https:&#x2F;&#x2F;babeljs.io&#x2F;repl</a>.)</div><br/><div id="37579408" class="c"><input type="checkbox" id="c-37579408" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37578554">parent</a><span>|</span><a href="#37577243">next</a><span>|</span><label class="collapse" for="c-37579408">[-]</label><label class="expand" for="c-37579408">[1 more]</label></div><br/><div class="children"><div class="content">Right, the wild thing for me is when you mutate `i` in the loop body. So at the same time `i` is scoped to the iteration so that you can capture it, but also mutating it affects the loop-scoped `i` that is incremented between iterations and checked for the termination condition. The iteration-scoped `i` is assigned back to the loop-scoped `i` at the end of the loop body. So if you have a closure close over `i` in the loop body and mutate it, whether that mutation affects the actual loop variable depends on whether the closure is called during the iteration it was created in or during a later iteration. Kinda spooky, but sure, less of a footgun than the original behavior.</div><br/></div></div></div></div></div></div><div id="37577243" class="c"><input type="checkbox" id="c-37577243" checked=""/><div class="controls bullet"><span class="by">zeroimpl</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576605">parent</a><span>|</span><a href="#37578124">prev</a><span>|</span><a href="#37576629">next</a><span>|</span><label class="collapse" for="c-37577243">[-]</label><label class="expand" for="c-37577243">[1 more]</label></div><br/><div class="children"><div class="content">In contrast, Java would have a compile error so long as the variable was not declared final.</div><br/></div></div></div></div><div id="37576629" class="c"><input type="checkbox" id="c-37576629" checked=""/><div class="controls bullet"><span class="by">biomcgary</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37576605">prev</a><span>|</span><a href="#37575915">next</a><span>|</span><label class="collapse" for="c-37576629">[-]</label><label class="expand" for="c-37576629">[2 more]</label></div><br/><div class="children"><div class="content">Is this loop variable problem really a theory issue (if so, does it have a label)? Or, primarily a practical one? Is there a database of known and historical programming language problems that are nicely tagged with &quot;theory problem&quot;, &quot;frequent foot-gun&quot;, etc?<p>Could an LLM coupled with a constraint solver create the perfect language (for particular domains, e.g., performance)? Or, just use Rust ;-)?</div><br/><div id="37576744" class="c"><input type="checkbox" id="c-37576744" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576629">parent</a><span>|</span><a href="#37575915">next</a><span>|</span><label class="collapse" for="c-37576744">[-]</label><label class="expand" for="c-37576744">[1 more]</label></div><br/><div class="children"><div class="content">In contrast to the view of many, programming language theory is very closely intertwined with programming practice. It both drives practice and reacts to practice.<p>In this particular case I imagine the issue was uncovered some time in the 1970s, which is when lexical scoping came to the fore in Scheme (in the US) and ML (in Europe). It&#x27;s a fairly natural problem to run into if you&#x27;re either thinking deeply about the interaction between closures (which capture environments) and loop constructs, or if you&#x27;re programming in a language that supports these features.</div><br/></div></div></div></div><div id="37575915" class="c"><input type="checkbox" id="c-37575915" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#37575695">parent</a><span>|</span><a href="#37576629">prev</a><span>|</span><a href="#37578136">next</a><span>|</span><label class="collapse" for="c-37575915">[-]</label><label class="expand" for="c-37575915">[13 more]</label></div><br/><div class="children"><div class="content">What stance against PLT are you referring to?</div><br/><div id="37576310" class="c"><input type="checkbox" id="c-37576310" checked=""/><div class="controls bullet"><span class="by">pseudonom-</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37575915">parent</a><span>|</span><a href="#37578136">next</a><span>|</span><label class="collapse" for="c-37576310">[-]</label><label class="expand" for="c-37576310">[12 more]</label></div><br/><div class="children"><div class="content">Probably quotes like:<p>&quot;It must be familiar, roughly C-like. Programmers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical.&quot;<p>And not including sum types despite having a sum-type-shaped hole in the language (`if err != nil`).<p>And some of the discussion about &quot;why no generics&quot; seemed kind of divorced from existing PL knowledge on the topic.</div><br/><div id="37576731" class="c"><input type="checkbox" id="c-37576731" checked=""/><div class="controls bullet"><span class="by">tensor</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576310">parent</a><span>|</span><a href="#37578136">next</a><span>|</span><label class="collapse" for="c-37576731">[-]</label><label class="expand" for="c-37576731">[11 more]</label></div><br/><div class="children"><div class="content">These were all intentional tradeoffs though, not any ignorance of theory. Also, it&#x27;s pretty rich for someone to be complaining about Go while referencing Javascript of all languages. Javascript&#x27;s design flaws are legendary. And I mean no disrespect to the creators of Javascript, they had to deal with some crazy last minute change requests to the language.</div><br/><div id="37577187" class="c"><input type="checkbox" id="c-37577187" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576731">parent</a><span>|</span><a href="#37577026">next</a><span>|</span><label class="collapse" for="c-37577187">[-]</label><label class="expand" for="c-37577187">[9 more]</label></div><br/><div class="children"><div class="content">Ehhh, I see absolutely no evidence that the Go developers were particularly <i>aware</i> of theory. It really feels more like they just were used to thinking in terms of C, and built a language which is kind of like C.<p>Go also has some really weird stuff in it, such as named return values.<p>Frankly, the lack of sum types hurts the most. The language would just be a lot better with a unifying Result type in the library. And don&#x27;t give me any of that &quot;oh, they tried to keep the language simple!&quot; stuff.<p>Intuitively, sum types are laughably simple. Everyone understands &quot;It&#x27;s one of these possible values, so you need to check which one it is and then handle that situation.&quot; They are more simple than enums on a conceptual level! Sum types are just not how C-programmers think about the world.</div><br/><div id="37579098" class="c"><input type="checkbox" id="c-37579098" checked=""/><div class="controls bullet"><span class="by">ianlancetaylor</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577187">parent</a><span>|</span><a href="#37579424">next</a><span>|</span><label class="collapse" for="c-37579098">[-]</label><label class="expand" for="c-37579098">[1 more]</label></div><br/><div class="children"><div class="content">As it happens, we considered sum types quite seriously in the early days.  In the end we decided that they were too similar to interface types, and that it would not help the language to have two concepts that were very similar but not quite the same.  <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;-94Fmnz9L6k&#x2F;m&#x2F;4BUxp-JqZFUJ" rel="nofollow noreferrer">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&#x2F;c&#x2F;-94Fmnz9L6k&#x2F;m&#x2F;4BUx...</a><p>There is a lot of discussion of sum types in Go at <a href="https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;19412" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;19412</a>.</div><br/></div></div><div id="37579424" class="c"><input type="checkbox" id="c-37579424" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577187">parent</a><span>|</span><a href="#37579098">prev</a><span>|</span><a href="#37579413">next</a><span>|</span><label class="collapse" for="c-37579424">[-]</label><label class="expand" for="c-37579424">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked for any evidence? There is plenty.<p>Sum types have been discussed since before the initial open source release of the language, at least according to some of the issue threads such as <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;19412">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;19412</a><p>If they&#x27;re laughably simple, then please contribute a proposal for how to add them to the language. You&#x27;ll find no one is really fighting against the concept of sum types.</div><br/></div></div><div id="37579413" class="c"><input type="checkbox" id="c-37579413" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37577187">parent</a><span>|</span><a href="#37579424">prev</a><span>|</span><a href="#37577026">next</a><span>|</span><label class="collapse" for="c-37579413">[-]</label><label class="expand" for="c-37579413">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I see absolutely no evidence that the Go developers were particularly aware of theory<p>Rob Pike and Ken Thompson are theory-unaware. Sure. Yes. This position is good and defensible.</div><br/><div id="37579431" class="c"><input type="checkbox" id="c-37579431" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579413">parent</a><span>|</span><a href="#37577026">next</a><span>|</span><label class="collapse" for="c-37579431">[-]</label><label class="expand" for="c-37579431">[5 more]</label></div><br/><div class="children"><div class="content">I believe it: Thompson is old enough and Pike is arrogant enough not to have learned the relevant programming-language theory.</div><br/><div id="37579498" class="c"><input type="checkbox" id="c-37579498" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579431">parent</a><span>|</span><a href="#37577026">next</a><span>|</span><label class="collapse" for="c-37579498">[-]</label><label class="expand" for="c-37579498">[4 more]</label></div><br/><div class="children"><div class="content">Nice joke.</div><br/><div id="37579674" class="c"><input type="checkbox" id="c-37579674" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579498">parent</a><span>|</span><a href="#37579642">next</a><span>|</span><label class="collapse" for="c-37579674">[-]</label><label class="expand" for="c-37579674">[2 more]</label></div><br/><div class="children"><div class="content">Thompson turns 80 this year. In what years does Thompson become old enough that you start to entertain the possibility that not everything he says or does is the result of having learned and understood all the possibly-relevant work, including the recent work?<p>I misspent a few thousand hours of my life on the 9fans mailing list long ago when Pike was very active on it, and my non-joking assessment is that ever since he finished his PhD or shortly after, Pike has probably felt he knows all he needs to learn about programming-language design except for the things he and the people in his immediate social environment invent.<p>Bell Labs was never good at designing programming languages. Did you know that in the Bourne shell (and possibly in all the other shells) you can have a statement of the form $foo = bar which will assign bar to the variable whose name is the value of foo? (Emacs Lisp, an old language, has the same functionality in the form of a function named &quot;set&quot;, but most Emacs Lisp programmers know to avoid it.) Well, I found that statement in a shell script written by one the Bell Labs guys, and the shell script was not doing anything fancy like interpreting a programming language or defining a new PL feature (not that it is sane to do either of things in a Unix shell).<p>None of what I say is more than a wisp of a reason not to choose Golang IMHO.</div><br/><div id="37580698" class="c"><input type="checkbox" id="c-37580698" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37579674">parent</a><span>|</span><a href="#37579642">next</a><span>|</span><label class="collapse" for="c-37580698">[-]</label><label class="expand" for="c-37580698">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re moving the goal posts. The claim isn&#x27;t that Ken Thompson  or whoever is flawless. The claim is that he isn&#x27;t stupid.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37577026" class="c"><input type="checkbox" id="c-37577026" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37575695">root</a><span>|</span><a href="#37576731">parent</a><span>|</span><a href="#37577187">prev</a><span>|</span><a href="#37578136">next</a><span>|</span><label class="collapse" for="c-37577026">[-]</label><label class="expand" for="c-37577026">[1 more]</label></div><br/><div class="children"><div class="content">With all the crazy warts that JS has, it is at least a lisp-like very dynamic language if you squint (a lot) at it. Its greatest fault is probably leaving out integers (I can’t even fathom why they decided on that, floats can’t represent properly ints).<p>Go is just simply badly designed, relying on hard-coded functionality a lot.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37576900" class="c"><input type="checkbox" id="c-37576900" checked=""/><div class="controls bullet"><span class="by">timrobinson333</span><span>|</span><a href="#37575695">prev</a><span>|</span><a href="#37575721">next</a><span>|</span><label class="collapse" for="c-37576900">[-]</label><label class="expand" for="c-37576900">[26 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll be the first to admit I know almost nothing about go, but it&#x27;s surprises me to find we&#x27;re still inventing languages with bobby traps like this, especially bobby traps that were well known and understood in other languages at the time.<p>Actually it surprises me we&#x27;re still inventing languages where local variables can be mutated, which seems to be at the root of the problem here</div><br/><div id="37577106" class="c"><input type="checkbox" id="c-37577106" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#37576900">parent</a><span>|</span><a href="#37577165">next</a><span>|</span><label class="collapse" for="c-37577106">[-]</label><label class="expand" for="c-37577106">[20 more]</label></div><br/><div class="children"><div class="content">Go has a long list of booby traps like this and prides itself on them. From outside of the Go team it looks like a small cultural shift might slowly be happening, cleaning up some of the obvious mistakes everyone&#x27;s been telling them about since the beginning. Rob Pike retiring and giving up some formal power with that probably helps.</div><br/><div id="37577312" class="c"><input type="checkbox" id="c-37577312" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577106">parent</a><span>|</span><a href="#37577265">next</a><span>|</span><label class="collapse" for="c-37577312">[-]</label><label class="expand" for="c-37577312">[4 more]</label></div><br/><div class="children"><div class="content">Speaking as the person Rob Pike handed the formal power to (8 years ago now), I don&#x27;t think that change has much to do with it.<p>We&#x27;ve known about the problem for a long time. I have notes from the run up to Go 1 (circa 2011) where we considered making this change, but it didn&#x27;t seem like a huge problem, and we were concerned about breaking old code, so on balance it didn&#x27;t seem worth it.<p>Two things moved the needle on this particular change:<p>1. A few years ago David Chase took the time to make the change in the compiler and inventory what it broke in a large code base (Google&#x27;s, but any code base would have worked for that purpose). Seeing that real-world data made it clear that the problem was more serious than we realized and needed to be addressed. That is, it made clear that the positive side of the balance was heavier than we thought it was back in 2011.<p>2. The design of Go modules added a go version line, which we can key the change off. That completely avoids breaking any old code. That zeroed out the negative side of the balance.</div><br/><div id="37577629" class="c"><input type="checkbox" id="c-37577629" checked=""/><div class="controls bullet"><span class="by">orblivion</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577312">parent</a><span>|</span><a href="#37577265">next</a><span>|</span><label class="collapse" for="c-37577629">[-]</label><label class="expand" for="c-37577629">[3 more]</label></div><br/><div class="children"><div class="content">What about let&#x27;s say 5 years from now, someone digs up a Go project from 2022, decides to get it up to speed for 2028, updates the version line. Is there something that would remind them to check for breaking changes, including this one? Perhaps the go project initializer could add a comment above the version line with a URL with a list of such changes. Though, that wouldn&#x27;t help for this change.</div><br/><div id="37578216" class="c"><input type="checkbox" id="c-37578216" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577629">parent</a><span>|</span><a href="#37577749">next</a><span>|</span><label class="collapse" for="c-37578216">[-]</label><label class="expand" for="c-37578216">[1 more]</label></div><br/><div class="children"><div class="content">I think the key difference here is to consider toleration vs adoption. Old code is able to tolerate the changes and still work in new ecosystems. There is still work on maintainers if they want to actually adopt the features themselves. Allowing these two concepts to work together is what allows iteratively updating the world, rather than requiring big bang introduction of features.<p>As for validating your software, the answer is the same as its always been… tests, tests and more tests.</div><br/></div></div></div></div></div></div><div id="37577265" class="c"><input type="checkbox" id="c-37577265" checked=""/><div class="controls bullet"><span class="by">thiht</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577106">parent</a><span>|</span><a href="#37577312">prev</a><span>|</span><a href="#37577165">next</a><span>|</span><label class="collapse" for="c-37577265">[-]</label><label class="expand" for="c-37577265">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Go has a long list of booby traps like this<p>Huh? Where’s the list? From the top of my head I think this is the only thing that repeatedly bit me, although I’m very aware of the behavior of for loop scoping. Linters save me nowadays at least.<p>Are there other things like that in the language that deserve a fix? Maybe things to do with json un&#x2F;marshaling?</div><br/><div id="37577417" class="c"><input type="checkbox" id="c-37577417" checked=""/><div class="controls bullet"><span class="by">wazzaps</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37577315">next</a><span>|</span><label class="collapse" for="c-37577417">[-]</label><label class="expand" for="c-37577417">[8 more]</label></div><br/><div class="children"><div class="content">Copying a mutex by value (thus duplicating the lock, causing deadlocks or worse) is far too easy</div><br/><div id="37577447" class="c"><input type="checkbox" id="c-37577447" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577417">parent</a><span>|</span><a href="#37577718">next</a><span>|</span><label class="collapse" for="c-37577447">[-]</label><label class="expand" for="c-37577447">[6 more]</label></div><br/><div class="children"><div class="content">`go vet` catches this.</div><br/><div id="37578048" class="c"><input type="checkbox" id="c-37578048" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577447">parent</a><span>|</span><a href="#37578170">next</a><span>|</span><label class="collapse" for="c-37578048">[-]</label><label class="expand" for="c-37578048">[3 more]</label></div><br/><div class="children"><div class="content">Is there a way to declare any type uncopyable? This is something I always thought Ada got right.</div><br/><div id="37578188" class="c"><input type="checkbox" id="c-37578188" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37578048">parent</a><span>|</span><a href="#37578130">next</a><span>|</span><label class="collapse" for="c-37578188">[-]</label><label class="expand" for="c-37578188">[1 more]</label></div><br/><div class="children"><div class="content">you stick this in your struct<p><pre><code>    type noCopy struct{}
    func (*noCopy) Lock()   {}
    func (*noCopy) Unlock() {}</code></pre></div><br/></div></div></div></div><div id="37578170" class="c"><input type="checkbox" id="c-37578170" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577447">parent</a><span>|</span><a href="#37578048">prev</a><span>|</span><a href="#37577718">next</a><span>|</span><label class="collapse" for="c-37578170">[-]</label><label class="expand" for="c-37578170">[2 more]</label></div><br/><div class="children"><div class="content">I use a tool called &quot;type theory&quot;</div><br/><div id="37578352" class="c"><input type="checkbox" id="c-37578352" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37578170">parent</a><span>|</span><a href="#37577718">next</a><span>|</span><label class="collapse" for="c-37578352">[-]</label><label class="expand" for="c-37578352">[1 more]</label></div><br/><div class="children"><div class="content">Keep posting about D, I&#x27;m sure it will catch on soon.</div><br/></div></div></div></div></div></div><div id="37577718" class="c"><input type="checkbox" id="c-37577718" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577417">parent</a><span>|</span><a href="#37577447">prev</a><span>|</span><a href="#37577315">next</a><span>|</span><label class="collapse" for="c-37577718">[-]</label><label class="expand" for="c-37577718">[1 more]</label></div><br/><div class="children"><div class="content">Wow, even c++ won&#x27;t let you do that (without invoking undefined behavior, anyway).</div><br/></div></div></div></div><div id="37577315" class="c"><input type="checkbox" id="c-37577315" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37577417">prev</a><span>|</span><a href="#37578412">next</a><span>|</span><label class="collapse" for="c-37577315">[-]</label><label class="expand" for="c-37577315">[2 more]</label></div><br/><div class="children"><div class="content">My number one is not having algebraic&#x2F;sum&#x2F;union types leading to needing zero-values. Which is more like a never idling foot gatling gun.</div><br/></div></div><div id="37578412" class="c"><input type="checkbox" id="c-37578412" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37577315">prev</a><span>|</span><a href="#37580130">next</a><span>|</span><label class="collapse" for="c-37578412">[-]</label><label class="expand" for="c-37578412">[1 more]</label></div><br/><div class="children"><div class="content">It has been a while, but yes, there were a lot of them and I forget most. It made it kinda pointless to me that the language was &quot;easy&quot; when the code felt so brittle (Null pointers...really?).<p>One weird thing that always goofed me up was that slices are passed by value but maps by reference. Always made it confusing how to pass them for serialization&#x2F;deserialization. The compiler didn&#x27;t complain it just panicked. Seemed like something the type system should catch.</div><br/></div></div><div id="37580130" class="c"><input type="checkbox" id="c-37580130" checked=""/><div class="controls bullet"><span class="by">telotortium</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37578412">prev</a><span>|</span><a href="#37578431">next</a><span>|</span><label class="collapse" for="c-37580130">[-]</label><label class="expand" for="c-37580130">[1 more]</label></div><br/><div class="children"><div class="content">Typed versus untyped nil (not sure how this could be easily fixed though)</div><br/></div></div><div id="37578431" class="c"><input type="checkbox" id="c-37578431" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37580130">prev</a><span>|</span><a href="#37579398">next</a><span>|</span><label class="collapse" for="c-37578431">[-]</label><label class="expand" for="c-37578431">[1 more]</label></div><br/><div class="children"><div class="content">If you append to a slice, you can&#x27;t rely on the changes showing up in the original slice, nor on them not showing up.</div><br/></div></div><div id="37579398" class="c"><input type="checkbox" id="c-37579398" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37576900">root</a><span>|</span><a href="#37577265">parent</a><span>|</span><a href="#37578431">prev</a><span>|</span><a href="#37577165">next</a><span>|</span><label class="collapse" for="c-37579398">[-]</label><label class="expand" for="c-37579398">[1 more]</label></div><br/><div class="children"><div class="content">That the printf functions shit garbage into your output if you get the formatting specifiers wrong.<p>I&#x27;d much rather have a crash than silently corrupting output.</div><br/></div></div></div></div></div></div><div id="37577165" class="c"><input type="checkbox" id="c-37577165" checked=""/><div class="controls bullet"><span class="by">zdimension</span><span>|</span><a href="#37576900">parent</a><span>|</span><a href="#37577106">prev</a><span>|</span><a href="#37577127">next</a><span>|</span><label class="collapse" for="c-37577165">[-]</label><label class="expand" for="c-37577165">[1 more]</label></div><br/><div class="children"><div class="content">There is a recurring joke about Go&#x27;s language design ignoring many bits of the general language design knowledge collectively acquired through decades of writing new languages. This change is an example of why this joke exists.</div><br/></div></div><div id="37577127" class="c"><input type="checkbox" id="c-37577127" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#37576900">parent</a><span>|</span><a href="#37577165">prev</a><span>|</span><a href="#37578005">next</a><span>|</span><label class="collapse" for="c-37577127">[-]</label><label class="expand" for="c-37577127">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we&#x27;re still inventing languages where local variables can be mutated<p>Local mutability is probably one of the most common uses of mutability. A lot of it is using local state to build up a more complicated structure, and then getting rid of that state. Getting rid of that use-case is just giving up performance.</div><br/></div></div><div id="37578005" class="c"><input type="checkbox" id="c-37578005" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#37576900">parent</a><span>|</span><a href="#37577127">prev</a><span>|</span><a href="#37577765">next</a><span>|</span><label class="collapse" for="c-37578005">[-]</label><label class="expand" for="c-37578005">[1 more]</label></div><br/><div class="children"><div class="content">Completely unrelated to the point you’re making, but the phrase is “booby trap”; I believe it originates from pranks played on younger schoolboys in 1600s England (the etymology of booby being the Spanish “bobo”).</div><br/></div></div><div id="37577765" class="c"><input type="checkbox" id="c-37577765" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#37576900">parent</a><span>|</span><a href="#37578005">prev</a><span>|</span><a href="#37578175">next</a><span>|</span><label class="collapse" for="c-37577765">[-]</label><label class="expand" for="c-37577765">[1 more]</label></div><br/><div class="children"><div class="content">&gt; where local variables can be mutated<p>They aren&#x27;t local, but belong to the outer scope.  The misconception in a nutshell.</div><br/></div></div></div></div><div id="37575721" class="c"><input type="checkbox" id="c-37575721" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#37576900">prev</a><span>|</span><a href="#37576906">next</a><span>|</span><label class="collapse" for="c-37575721">[-]</label><label class="expand" for="c-37575721">[27 more]</label></div><br/><div class="children"><div class="content">Russ Cox and the Go team learned that the loop variable capture semantics are flawed not by reflecting about how their language works, but through user feedback.<p>This could have been prevented by having one person on the team with actual language design experience, who could point this issue out in the design process.<p>In this case, after 10 or so years, and thousands of production bugs, they backpedaled. How many other badly designed features exist in the language, and are simply not being acknowledged?<p>If you point it out, and you&#x27;re right, will you be heard if you don&#x27;t have a flashy metric to point to, like a billion dollars lost?<p>What if the flaw is more subtle, and explaining why it&#x27;s bad is harder than in this very simple case, that can be illustrated with 5 lines of code? What if the link between it and its consequences isn&#x27;t that clear, but the consequences are just as grave? Will it ever get fixed?</div><br/><div id="37575984" class="c"><input type="checkbox" id="c-37575984" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37575936">next</a><span>|</span><label class="collapse" for="c-37575984">[-]</label><label class="expand" for="c-37575984">[2 more]</label></div><br/><div class="children"><div class="content">Others have suggested that Rob Pike and Ken Thompson have some language design experience, to state it mildly. I also want to point out...<p>&gt; Russ Cox and the Go team learned that the loop variable capture semantics are flawed not by reflecting about how their language works, but through user feedback.<p>I think &quot;user feedback&quot; isn&#x27;t the whole story. It&#x27;s not just the Go team passively listening as users point out obvious flaws. I&#x27;ve noticed in other changes (e.g. the monotonic time change [1]) the Go team has done a pretty disciplined study of user code in Google&#x27;s monorepo and on github. That&#x27;s mentioned in this case too. This is a good practice, not evidence of failure.<p>[1] <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;12914-monotonic.md#appendix_time_now-usage" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;master&#x2F;design&#x2F;12914-m...</a></div><br/><div id="37577084" class="c"><input type="checkbox" id="c-37577084" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575984">parent</a><span>|</span><a href="#37575936">next</a><span>|</span><label class="collapse" for="c-37577084">[-]</label><label class="expand" for="c-37577084">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rob Pike and Ken Thompson<p>They are huge names in the field, but honestly, they just suck at language design itself.</div><br/></div></div></div></div><div id="37575936" class="c"><input type="checkbox" id="c-37575936" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37575984">prev</a><span>|</span><a href="#37575740">next</a><span>|</span><label class="collapse" for="c-37575936">[-]</label><label class="expand" for="c-37575936">[12 more]</label></div><br/><div class="children"><div class="content">Many languages have made this mistake, despite having engineers and teams with many decades or centuries of total experience working on programming languages. Almost all languages have the loop variable semantics Go chose: C&#x2F;C++, Java, C# (until 5.0), JavaScript (when using `var`), Python. Honestly: are there any C-like, imperative languages with for loops, that _don&#x27;t_ behave like this?<p>That decision only becomes painful when capturing variables by reference becomes cheap and common; that is, when languages introduce lightweight closures (aka lambdas, anonymous functions, ...). Then the semantics of a for loop subtly change. Language designers have frequently implemented lightweight closures before realizing the risk, and then must make a difficult choice of whether to take a painful breaking change.<p>The Go team can be persuaded, it&#x27;s just a tall order. And give them credit where credit is due: this is genuinely a significant, breaking change. It&#x27;s the right change, but it&#x27;s not an easy decision to make more than a decade into a language&#x27;s usage.<p>That said, there may be a kernel of truth to what you&#x27;re alluding to: that the Go team can be hard to persuade and has taken some principled (I would argue, wrong) positions. I&#x27;m tracking several Go bugs myself where I believe the Go standard library behaves incorrectly. But I don&#x27;t think this situation is the right one to make this argument.</div><br/><div id="37576005" class="c"><input type="checkbox" id="c-37576005" checked=""/><div class="controls bullet"><span class="by">adra</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37576102">next</a><span>|</span><label class="collapse" for="c-37576005">[-]</label><label class="expand" for="c-37576005">[5 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t a bug in java. Java has the idea of &quot;effectively final&quot; variables, and only final or effectively final values are allowed to be passed into lambdas  seemingly to avoid this specific defect. Ironically, I just had a review the other day that touched on this go &quot;interaction&quot;.<p>The outcome of this go code in java would be as you&#x27;d expect, each lambda generated uses a unique copy of the loop reference value.</div><br/><div id="37576111" class="c"><input type="checkbox" id="c-37576111" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37576005">parent</a><span>|</span><a href="#37576102">next</a><span>|</span><label class="collapse" for="c-37576111">[-]</label><label class="expand" for="c-37576111">[4 more]</label></div><br/><div class="children"><div class="content">Oh, today I learned. I think this was an issue in Scala (with `var`), but this seems like a great compromise for Java core.<p>I suppose Java had many years after C#&#x27;s introduction of closures to reflect on what went well and what did not. Go, created in 2007, predates both languages having lightweight closures. Not surprising that they made the decision they did.<p>Your comment inspired me to ask what Rust does in this situation, but of course, they&#x27;ve opted for both a different &quot;for&quot; loop construct, but even if they hadn&#x27;t, the borrow checker enforces a similar requirement as Java&#x27;s effectively final lambda limitation.</div><br/><div id="37577011" class="c"><input type="checkbox" id="c-37577011" checked=""/><div class="controls bullet"><span class="by">ncann</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37576111">parent</a><span>|</span><a href="#37577313">next</a><span>|</span><label class="collapse" for="c-37577011">[-]</label><label class="expand" for="c-37577011">[1 more]</label></div><br/><div class="children"><div class="content">Newcomers to Java usually dislike the &quot;Variable used in lambda expression should be final or effectively final&quot; compiler error, but once you understand why that restriction is in place and what happens in other languages when there&#x27;s no such restriction, you start to love the subtle genius in how Java did it this way.</div><br/></div></div><div id="37577313" class="c"><input type="checkbox" id="c-37577313" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37576111">parent</a><span>|</span><a href="#37577011">prev</a><span>|</span><a href="#37576102">next</a><span>|</span><label class="collapse" for="c-37577313">[-]</label><label class="expand" for="c-37577313">[2 more]</label></div><br/><div class="children"><div class="content">Go, designed between 2007 and 2009, certainly had the opportunity to look at their introduction in C# 2.0, released 2005, or its syntactic sugar added in C# 3.0, released 2007.</div><br/><div id="37577591" class="c"><input type="checkbox" id="c-37577591" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37577313">parent</a><span>|</span><a href="#37576102">next</a><span>|</span><label class="collapse" for="c-37577591">[-]</label><label class="expand" for="c-37577591">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s an ahistorical reading of events. They did have the opportunity, but there were very few languages doing what Go was at the time it was designed. My recollection of the C# 3 to 5 and .NET 3 to 4.5 is a bit muddled, but it looks like the spec supports a different reading:<p>C# 3.0 in 2007 introduced arrow syntax. I believe this was primarily to support LINQ, and so users were typically creating closures as arguments to IEnumerable methods, not in a loop.<p>C# 4.0 in 2010 introduced Task&lt;T&gt; (by virtue of .NET 4), and with this it became much more likely users would create a closure in a loop. That&#x27;s how users would add tasks to the task pool, after all, from a for loop.<p>C# 5.0 in 2012 fixes loop variable behavior.<p>I think the thesis I have is sound: language designers did not predict how loops and lightweight closures would interact to create error-prone code until (by and large) users encountered these issues.</div><br/></div></div></div></div></div></div></div></div><div id="37576102" class="c"><input type="checkbox" id="c-37576102" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37576005">prev</a><span>|</span><a href="#37576244">next</a><span>|</span><label class="collapse" for="c-37576102">[-]</label><label class="expand" for="c-37576102">[1 more]</label></div><br/><div class="children"><div class="content">This bug appears to be because Go captures loop variables by reference, but C++ captures are by copy[1] unless user explicitly asked for reference (`&amp;variable`).  It seems like the same bug would be visually more obvious in C++.<p>[1] <a href="https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;expr.prim.lambda.capture#10" rel="nofollow noreferrer">https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;expr.prim.lambda.capture#10</a></div><br/></div></div><div id="37576244" class="c"><input type="checkbox" id="c-37576244" checked=""/><div class="controls bullet"><span class="by">MatthiasPortzel</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37576102">prev</a><span>|</span><a href="#37580706">next</a><span>|</span><label class="collapse" for="c-37576244">[-]</label><label class="expand" for="c-37576244">[2 more]</label></div><br/><div class="children"><div class="content">&gt; JavaScript (unless using `for...of`)<p>The change in Javscript doesn’t have anything to do with for…of, it’s the difference between `var` and `let`. And JS made the decision to move to `let` because the semantics made more sense before Go was even created (although code and browsers didn’t update for another several years). That’s why Go is being held to a higher standard, because it’s 10+ years newer than the other languages you mentioned.</div><br/><div id="37577308" class="c"><input type="checkbox" id="c-37577308" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37576244">parent</a><span>|</span><a href="#37580706">next</a><span>|</span><label class="collapse" for="c-37577308">[-]</label><label class="expand" for="c-37577308">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thanks for the correction! That&#x27;s right. But:<p>1. Did JS introduce this change after Go&#x27;s creation? Yes. (And also after C#.)<p>2. Did arrow functions support precede let and const support? Yes.<p>Answering the second question and finding the versions with support and their release dates answers the first question.<p><pre><code>             Arrow functions    let and const
    Firefox    22 (2013)          44 (2016)
    Chrome     45 (2015)          49 (2016)
    Node.js     4 (2015)           6 (2016)
    Safari     10 (2016)          10 (2016)
</code></pre>
This places it nearly 10 years after the creation of Go. And with the exception of Safari, arrow functions were available for months to years prior to let and const.<p>This is somewhat weak evidence for the thesis though; these features were part of the same specification (ES6&#x2F;ES2015), but to understand the origin of &quot;let&quot; we also need to look at the proliferation of alternative languages such as Coffeescript. A fuller history of the JavaScript feature, and maybe some of the TC39 meeting minutes, might help us understand the order of operations here.<p>(I&#x27;d be remiss not to observe that this is almost an accident of &quot;let&quot; as well, there&#x27;s no intrinsic reason it must behave like this in a loop, and some browsers chose to make &quot;var&quot; behave like &quot;let&quot;. Let and const were originally introduced, I believe, to implement lexical scoping, not to change loop variable hoisting.)</div><br/></div></div></div></div><div id="37580706" class="c"><input type="checkbox" id="c-37580706" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37576244">prev</a><span>|</span><a href="#37577770">next</a><span>|</span><label class="collapse" for="c-37580706">[-]</label><label class="expand" for="c-37580706">[1 more]</label></div><br/><div class="children"><div class="content">&gt; JavaScript (when using `var`)<p>I would argue that var is an entirely different issue.  If variables last the entire function then it&#x27;s far less confusing to see closures using the final value.  After exiting the loop the final value is <i>right there, still assigned to the variable</i>.  You can print it directly with no closures needed.</div><br/></div></div><div id="37577770" class="c"><input type="checkbox" id="c-37577770" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37580706">prev</a><span>|</span><a href="#37577522">next</a><span>|</span><label class="collapse" for="c-37577770">[-]</label><label class="expand" for="c-37577770">[1 more]</label></div><br/><div class="children"><div class="content">I hate to be <i>that</i> guy but this would not be possible with rust, as the captured reference could not escape the loop scope. Either copy the value, or get yelled at the lifetime of the reference.<p>This is one of the things the language was designed to fix, by people that looked at the past 50 years or so of programming languages, and decided to fix the sorest pain points.</div><br/></div></div><div id="37577522" class="c"><input type="checkbox" id="c-37577522" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575936">parent</a><span>|</span><a href="#37577770">prev</a><span>|</span><a href="#37575740">next</a><span>|</span><label class="collapse" for="c-37577522">[-]</label><label class="expand" for="c-37577522">[1 more]</label></div><br/><div class="children"><div class="content">C# made the mistake not when they introduced loops, but when they introduced closures, and it didn&#x27;t become evident until other features came along that propelled adoption of closures. Go had closures from the beginning and they were always central to the language design. C# fixed that mistake before the 1.0 release of Go. But the Go team didn&#x27;t learn from it.</div><br/></div></div></div></div><div id="37575740" class="c"><input type="checkbox" id="c-37575740" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37575936">prev</a><span>|</span><a href="#37577650">next</a><span>|</span><label class="collapse" for="c-37575740">[-]</label><label class="expand" for="c-37575740">[4 more]</label></div><br/><div class="children"><div class="content">Are you suggesting Rob Pike has no experience designing a programming language?</div><br/><div id="37575804" class="c"><input type="checkbox" id="c-37575804" checked=""/><div class="controls bullet"><span class="by">ziyao_w</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575740">parent</a><span>|</span><a href="#37575827">next</a><span>|</span><label class="collapse" for="c-37575804">[-]</label><label class="expand" for="c-37575804">[1 more]</label></div><br/><div class="children"><div class="content">I think the parent was trying to imply that Ken Thompson had no experience in designing a programming language :-)<p>Seriously though, &quot;having experience&quot; and &quot;getting things right&quot; are two different things, although Golang got a lot of things right, and the parent is being unnecessarily harsh.</div><br/></div></div><div id="37575827" class="c"><input type="checkbox" id="c-37575827" checked=""/><div class="controls bullet"><span class="by">ranting-moth</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575740">parent</a><span>|</span><a href="#37575804">prev</a><span>|</span><a href="#37575861">next</a><span>|</span><label class="collapse" for="c-37575827">[-]</label><label class="expand" for="c-37575827">[1 more]</label></div><br/><div class="children"><div class="content">Or Ken Thompson?</div><br/></div></div><div id="37575861" class="c"><input type="checkbox" id="c-37575861" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#37575721">root</a><span>|</span><a href="#37575740">parent</a><span>|</span><a href="#37575827">prev</a><span>|</span><a href="#37577650">next</a><span>|</span><label class="collapse" for="c-37575861">[-]</label><label class="expand" for="c-37575861">[1 more]</label></div><br/><div class="children"><div class="content">I should say language design knowledge.</div><br/></div></div></div></div><div id="37577650" class="c"><input type="checkbox" id="c-37577650" checked=""/><div class="controls bullet"><span class="by">amomchilov</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37575740">prev</a><span>|</span><a href="#37577443">next</a><span>|</span><label class="collapse" for="c-37577650">[-]</label><label class="expand" for="c-37577650">[1 more]</label></div><br/><div class="children"><div class="content">I can’t find it now, but I remember some joke about “it’s an interesting language, but why did you ignore the last 50 years of programming language design?”<p>I find Go quite frustrating in how it decries how over-complicated some features are, and slowly comes around to realize that oh, maybe people designed them for a reason (who woulda thunk it?).</div><br/></div></div><div id="37577443" class="c"><input type="checkbox" id="c-37577443" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37577650">prev</a><span>|</span><a href="#37576044">next</a><span>|</span><label class="collapse" for="c-37577443">[-]</label><label class="expand" for="c-37577443">[1 more]</label></div><br/><div class="children"><div class="content">I answered some of this above: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37577312">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37577312</a></div><br/></div></div><div id="37576044" class="c"><input type="checkbox" id="c-37576044" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37577443">prev</a><span>|</span><a href="#37576065">next</a><span>|</span><label class="collapse" for="c-37576044">[-]</label><label class="expand" for="c-37576044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This could have been prevented by having one person on the team with actual language design experience<p>I thought you were serious, right up to that bit. Well played. I hope.</div><br/></div></div><div id="37576065" class="c"><input type="checkbox" id="c-37576065" checked=""/><div class="controls bullet"><span class="by">alecbz</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37576044">prev</a><span>|</span><a href="#37576013">next</a><span>|</span><label class="collapse" for="c-37576065">[-]</label><label class="expand" for="c-37576065">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This could have been prevented by having one person on the team with actual language design experience, who could point this issue out in the design process.<p>Instead of making a mistake, they could have simply not.<p>See also RFC 9225: Software Defects Considered Harmful <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9225.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9225.html</a></div><br/></div></div><div id="37576013" class="c"><input type="checkbox" id="c-37576013" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37576065">prev</a><span>|</span><a href="#37576073">next</a><span>|</span><label class="collapse" for="c-37576013">[-]</label><label class="expand" for="c-37576013">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Russ Cox and the Go team learned that the loop variable capture semantics are flawed not by reflecting about how their language works, but through user feedback.</i><p>Since &quot;Go 1&quot; was deemed complete and the &quot;Go 2&quot; project began in 2018, the direction of the language was given to the community. It is no longer the Go team&#x27;s place to shove whatever they think into the language. It has to be what the community wants, and that feedback showed it is what they want.</div><br/></div></div><div id="37576073" class="c"><input type="checkbox" id="c-37576073" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37576013">prev</a><span>|</span><a href="#37578141">next</a><span>|</span><label class="collapse" for="c-37576073">[-]</label><label class="expand" for="c-37576073">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How many other badly designed features exist in the language, and are simply not being acknowledged?<p>Very few.<p>&gt; If you point it out, and you&#x27;re right, will you be heard if you don&#x27;t have a flashy metric to point to, like a billion dollars lost?<p>If you&#x27;re right yet don&#x27;t have a better idea then what do you expect to occur?<p>&gt; What if the link between it and its consequences isn&#x27;t that clear, but the consequences are just as grave?<p>The consequence is your developers must be careful with loop variables or they will introduce bugs.  That&#x27;s not particularly &quot;grave&quot; nor even especially novel.<p>I&#x27;ll admit,  it&#x27;s not a good ivory tower language,  but then again,  that&#x27;s probably why I use it so often.  It gets the job done and it doesn&#x27;t waste my time with useless hypothetical features.</div><br/></div></div><div id="37575881" class="c"><input type="checkbox" id="c-37575881" checked=""/><div class="controls bullet"><span class="by">Patrickmi</span><span>|</span><a href="#37575721">parent</a><span>|</span><a href="#37578141">prev</a><span>|</span><a href="#37576906">next</a><span>|</span><label class="collapse" for="c-37575881">[-]</label><label class="expand" for="c-37575881">[1 more]</label></div><br/><div class="children"><div class="content">So whats your point ?, 
old ideas never die ?, 
language design is not language purpose and goal ?, 
they made a mistake creating Go ?,
refusing to find something suitable or just break compatibility?</div><br/></div></div></div></div><div id="37576906" class="c"><input type="checkbox" id="c-37576906" checked=""/><div class="controls bullet"><span class="by">DonnyV</span><span>|</span><a href="#37575721">prev</a><span>|</span><a href="#37576991">next</a><span>|</span><label class="collapse" for="c-37576906">[-]</label><label class="expand" for="c-37576906">[5 more]</label></div><br/><div class="children"><div class="content">GO syntax is so hard to look at.</div><br/><div id="37577205" class="c"><input type="checkbox" id="c-37577205" checked=""/><div class="controls bullet"><span class="by">guessmyname</span><span>|</span><a href="#37576906">parent</a><span>|</span><a href="#37576946">next</a><span>|</span><label class="collapse" for="c-37577205">[-]</label><label class="expand" for="c-37577205">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>GO syntax is so hard to look at.</i><p>What do you mean by “hard”?<p>I find Rust syntax challenging to grasp in a specific way. Rust employs numerous symbols and expressions to convey statements, which makes reading Rust code a process of constantly navigating between different keywords, left and right. I have to create a mental map of what certain statements are accomplishing before I can truly comprehend the code.<p>In contrast, I find Go code relatively straightforward, especially for those familiar with C-like programming languages. This clarity is due to the deliberate verbosity of the language, which I personally appreciate, as well as the use of early return statements.<p>But don’t get me wrong. I enjoy programming in both Rust and Go when they are suitable for the task at hand, but I usually spend more time grappling with Rust’s syntax than with Go’s, because I often invest more time in understanding the structure and logic of Rust programs compared to their Go counterparts.</div><br/><div id="37577838" class="c"><input type="checkbox" id="c-37577838" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#37576906">root</a><span>|</span><a href="#37577205">parent</a><span>|</span><a href="#37577857">next</a><span>|</span><label class="collapse" for="c-37577838">[-]</label><label class="expand" for="c-37577838">[1 more]</label></div><br/><div class="children"><div class="content">I guess it depends on the way the brain works. I have very bad memory, but I prefer the expressiveness of Rust to the verbosity of Go. I value much more having the whole context on the screen that navigating countless words of boilerplate code. I do agree that it gets a bit of getting used to, but I find it easier to recognize by eye.</div><br/></div></div><div id="37577857" class="c"><input type="checkbox" id="c-37577857" checked=""/><div class="controls bullet"><span class="by">ShamelessC</span><span>|</span><a href="#37576906">root</a><span>|</span><a href="#37577205">parent</a><span>|</span><a href="#37577838">prev</a><span>|</span><a href="#37576946">next</a><span>|</span><label class="collapse" for="c-37577857">[-]</label><label class="expand" for="c-37577857">[1 more]</label></div><br/><div class="children"><div class="content">At least part of the issue for me was that many keywords&#x2F;syntax rules don’t match anything I’m familiar with, even considering “C-like” languages.<p>I have similar issues with Rust actually. There’s a lot of sugar used that you have to grok and that takes some time.<p>On the other hand Python, C#, Java all stick with a set of fairly familiar conventions. In terms of syntax (and only syntax), the learning curve is more intense with Go; perhaps similar to the initial alienation provided by JavaScript.<p>My experience has been that once you are being paid to learn a language these problems mostly disappear. Alas, no one ever paid me to learn Go.</div><br/></div></div></div></div><div id="37576946" class="c"><input type="checkbox" id="c-37576946" checked=""/><div class="controls bullet"><span class="by">knodi</span><span>|</span><a href="#37576906">parent</a><span>|</span><a href="#37577205">prev</a><span>|</span><a href="#37576991">next</a><span>|</span><label class="collapse" for="c-37576946">[-]</label><label class="expand" for="c-37576946">[1 more]</label></div><br/><div class="children"><div class="content">If you hate readability, sure.</div><br/></div></div></div></div><div id="37576991" class="c"><input type="checkbox" id="c-37576991" checked=""/><div class="controls bullet"><span class="by">wheelerof4te</span><span>|</span><a href="#37576906">prev</a><span>|</span><a href="#37576626">next</a><span>|</span><label class="collapse" for="c-37576991">[-]</label><label class="expand" for="c-37576991">[2 more]</label></div><br/><div class="children"><div class="content">Go never should have implemented closures.<p>You add them and the next thing people want are objects.</div><br/><div id="37577092" class="c"><input type="checkbox" id="c-37577092" checked=""/><div class="controls bullet"><span class="by">bagful</span><span>|</span><a href="#37576991">parent</a><span>|</span><a href="#37576626">next</a><span>|</span><label class="collapse" for="c-37577092">[-]</label><label class="expand" for="c-37577092">[1 more]</label></div><br/><div class="children"><div class="content">All you really need in an language is the former - closures provide encapsulation (instance variables become bound variables) and polymorphism (over closures with the same function signature) all the same</div><br/></div></div></div></div><div id="37576626" class="c"><input type="checkbox" id="c-37576626" checked=""/><div class="controls bullet"><span class="by">sidewndr46</span><span>|</span><a href="#37576991">prev</a><span>|</span><label class="collapse" for="c-37576626">[-]</label><label class="expand" for="c-37576626">[2 more]</label></div><br/><div class="children"><div class="content">This nonsense again? Where it is controlled per module, effectively making it impossible to review code for correctness without checking those controls. This is an anti-feature. If you can&#x27;t be bothered to make a local copy or reference the correct variable, the problem is the developer. Not the language.</div><br/><div id="37576751" class="c"><input type="checkbox" id="c-37576751" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#37576626">parent</a><span>|</span><label class="collapse" for="c-37576751">[-]</label><label class="expand" for="c-37576751">[1 more]</label></div><br/><div class="children"><div class="content">The problem is the language when its ergonomics coerce most developers to assume a construct works in a way it does not.<p>Programmers are often at fault when a language  complex, but I&#x27;d give them a pass when it&#x27;s simply counterintuitive.</div><br/></div></div></div></div></div></div></div></div></div></body></html>