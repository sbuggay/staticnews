<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704186060864" as="style"/><link rel="stylesheet" href="styles.css?v=1704186060864"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thisisimportant.net/posts/content-as-a-graph/">Displaying Content as a Graph</a> <span class="domain">(<a href="https://thisisimportant.net">thisisimportant.net</a>)</span></div><div class="subtext"><span>serverlessmom</span> | <span>28 comments</span></div><br/><div><div id="38839559" class="c"><input type="checkbox" id="c-38839559" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#38836346">next</a><span>|</span><label class="collapse" for="c-38839559">[-]</label><label class="expand" for="c-38839559">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this article.<p>I agree. I wanted to explore &quot;graph pageing&quot;. The problem with computer screens and large graphs is that they&#x27;re awkward to navigate because the viewport is smaller than the graph, and you can only scale the entire graph so much. You could pan around a large graph but it is not ideal, it&#x27;s kind of awkward.<p>I wrote a graph layout algorithm here but it makes no attempt to prevent overlapping.<p><a href="https:&#x2F;&#x2F;ibb.co&#x2F;1ZZFtVF" rel="nofollow">https:&#x2F;&#x2F;ibb.co&#x2F;1ZZFtVF</a><p><a href="https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;Processes3#public&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;Processes3#public&#x2F;index.ht...</a> (scroll down to &quot;Graph&quot; on a desktop computer)<p>I would like to write an algorithm that &quot;pages&quot; a graph and when you scroll it composits different nodes in-and-out as you scroll.</div><br/></div></div><div id="38836346" class="c"><input type="checkbox" id="c-38836346" checked=""/><div class="controls bullet"><span class="by">tunesmith</span><span>|</span><a href="#38839559">prev</a><span>|</span><a href="#38839245">next</a><span>|</span><label class="collapse" for="c-38836346">[-]</label><label class="expand" for="c-38836346">[7 more]</label></div><br/><div class="children"><div class="content">I think the main problem with using non-tree graphs isn&#x27;t the choice to use the graph; it&#x27;s the lack of definition for the edges. Most people, when they first reach for a non-tree graph, choose to weaken the definition of the edge even beyond what is implied by tree edges, which usually means &quot;owns&quot; or &quot;contains&quot; or the like. By default, an edge in a non-tree graph simply means &quot;relates to, somehow&quot;. And a beginning user faced with a bunch of nodes are just going to draw a bunch of lines between topics that seem to tangentially relate to other nodes, until they get the big hairball.<p>If, however, you get stricter about the definition of the edge in a graph, they&#x27;re superior to trees in many contexts. An edge might mean &quot;predates&quot;, or another edge might mean &quot;implies&quot;. Those are the two main definitions I use, because when needing a graph I&#x27;m usually either thinking of planning (prerequisites, when some things need to be done &quot;before&quot; another), or I&#x27;m thinking of arguing&#x2F;concluding (where some things when combined &quot;imply&quot; a conclusion). It doesn&#x27;t really work to conflate the two.<p>You can also combine multiple edge definitions into one graph, and maybe it&#x27;d look like a hairball if you&#x27;re displaying all of them at once, but if you filter it gets more useful.<p>Two more things... graphs almost always, in my experience, are more visually useful when they are directed, whether acyclic or not. Radial just doesn&#x27;t seem to have much added benefit. And, a pet peeve is mine is when people use radial UX to display a tree and then call it a &quot;graph&quot;. I know, it&#x27;s a picture of bubbles and arrows, so it&#x27;s a &quot;graph&quot; in that sense, but most bubble graph software doesn&#x27;t even support graph data structures. If you grab one bubble and apply gravity, it just shakes out into a tree.</div><br/><div id="38836501" class="c"><input type="checkbox" id="c-38836501" checked=""/><div class="controls bullet"><span class="by">Lichtso</span><span>|</span><a href="#38836346">parent</a><span>|</span><a href="#38837057">next</a><span>|</span><label class="collapse" for="c-38836501">[-]</label><label class="expand" for="c-38836501">[5 more]</label></div><br/><div class="children"><div class="content">Oh yes, edges of different types and their direction are definitely what the author of the post was missing.<p>This is precisely where triple (hyper) graphs and the idea of semantic networks comes in. Unfortunately, the designs, architecture and implementation of the semantic web are all completely impractical garbage.<p>I did a lot of research on rendering ontologies and in general the best way to do so is not at all. Instead try to do domain specific bijective projections (akin to DSLs). And if you really need graphs do not render the edges. It always leads to chaos, it is better to show all vertices and only display edges on request (e.g. on hover).</div><br/><div id="38836677" class="c"><input type="checkbox" id="c-38836677" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#38836346">root</a><span>|</span><a href="#38836501">parent</a><span>|</span><a href="#38836921">next</a><span>|</span><label class="collapse" for="c-38836677">[-]</label><label class="expand" for="c-38836677">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a dictionary system based on graph, the graph itself isn&#x27;t being displayed. I agree RDF is garbage tech, it&#x27;s easier to do something without it.<p>The solution is came with to display content from a given node is first to group neighbors nodes by the type of their relationship. Each vertex and relation type has a dedicated component for display and if not, uses a default one. The display order of relationships is set with configuration.<p>It very simple yet powerful system, that was implemented on mobile and web. I&#x27;ve prototype of very cool stuff (like a Chinese dictionary, and another multilingual one) but none very completed because most of more senior researchers I worked didn&#x27;t see the point.</div><br/></div></div><div id="38836921" class="c"><input type="checkbox" id="c-38836921" checked=""/><div class="controls bullet"><span class="by">davidy123</span><span>|</span><a href="#38836346">root</a><span>|</span><a href="#38836501">parent</a><span>|</span><a href="#38836677">prev</a><span>|</span><a href="#38837057">next</a><span>|</span><label class="collapse" for="c-38836921">[-]</label><label class="expand" for="c-38836921">[3 more]</label></div><br/><div class="children"><div class="content">Your approach doesn&#x27;t apply to the semantic web. Apples and oranges. Two dimensional non-tree graph are neat but in most cases at best a debugging tool or whirlygig.</div><br/><div id="38836943" class="c"><input type="checkbox" id="c-38836943" checked=""/><div class="controls bullet"><span class="by">Lichtso</span><span>|</span><a href="#38836346">root</a><span>|</span><a href="#38836921">parent</a><span>|</span><a href="#38837057">next</a><span>|</span><label class="collapse" for="c-38836943">[-]</label><label class="expand" for="c-38836943">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Your approach doesn&#x27;t apply to the semantic web.<p>Not sure which approach you are talking about.<p>&gt; Two dimensional non-tree graph are neat but in most cases at best a debugging tool or whirlygig.<p>That is what I was saying. Layouting and rendering general case graphs is a mess.</div><br/><div id="38837015" class="c"><input type="checkbox" id="c-38837015" checked=""/><div class="controls bullet"><span class="by">davidy123</span><span>|</span><a href="#38836346">root</a><span>|</span><a href="#38836943">parent</a><span>|</span><a href="#38837057">next</a><span>|</span><label class="collapse" for="c-38837015">[-]</label><label class="expand" for="c-38837015">[1 more]</label></div><br/><div class="children"><div class="content">I mean semantic web is designed to turn the entire web into a semantic database. You could treat &quot;your&quot; parts of the web as DSLs in the simplest possible RDF&#x2F;linked data and then link it to semantic web concepts (and other people can link it as appropriate), but I don&#x27;t think you can create anything like a semantic web with standalone DSLs.<p>&gt; That is what I was saying. Layouting and rendering general case graphs is a mess.<p>Yes, unfortunately and somewhat ironically since the web is a non-tree graph.</div><br/></div></div></div></div></div></div></div></div><div id="38837057" class="c"><input type="checkbox" id="c-38837057" checked=""/><div class="controls bullet"><span class="by">ivancho</span><span>|</span><a href="#38836346">parent</a><span>|</span><a href="#38836501">prev</a><span>|</span><a href="#38839245">next</a><span>|</span><label class="collapse" for="c-38837057">[-]</label><label class="expand" for="c-38837057">[1 more]</label></div><br/><div class="children"><div class="content">Knowledge graphs are traditionally collections of triplets, 2 vertices&#x2F;entities plus edge type&#x2F;relation. They are vastly superior to trees for data representation, but are completely useless for visualization. There is no meaningful question that can be answered faster or better by looking at the drawn edges - just print a list of entities and add hyperlinks.</div><br/></div></div></div></div><div id="38839245" class="c"><input type="checkbox" id="c-38839245" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#38836346">prev</a><span>|</span><a href="#38839309">next</a><span>|</span><label class="collapse" for="c-38839245">[-]</label><label class="expand" for="c-38839245">[1 more]</label></div><br/><div class="children"><div class="content">Graphs are neat. For your own notes or for heavily interconnected stuff. Like hypertext. The actual graph visualization is often just eye candy. Eye candy that makes nerd-hearts melt, but ultimately a list of related topics (and a single sentence describing that relationship) is much more powerful than seeing a word cloud or a complex graph.<p>If your topic is of the nature that there is (or should be) a logical starting point, graphs decrease the chance that interested people get presented information in the right order. If there is no logical starting point or there is no right order: <i>good</i>, so be it.<p>As someone who wants to like graphs: Graphs are great for organizing personal information, meaning they are great if you make the connections. However in practise graph-centric solutions are often solutions in search of a problem. And if you use graphs (anybody using hyperlinks to other hierarchical levels does) they shine most if they don&#x27;t take the center stage, but are presented on purpose at specific spots.</div><br/></div></div><div id="38839309" class="c"><input type="checkbox" id="c-38839309" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#38839245">prev</a><span>|</span><a href="#38839222">next</a><span>|</span><label class="collapse" for="c-38839309">[-]</label><label class="expand" for="c-38839309">[1 more]</label></div><br/><div class="children"><div class="content">I have built a few graph views and worked on a tool used to specify graph views for existing schemas. My thoughts.<p>Hierarchical views aren’t easy because they are common, they are easy because it matches how humans think on a basic level. We take a concept, draw a line down the middle, and get two refined concepts. That cleaving is a natural process that produces hierarchical trees. If you can display your data in a tree, you have the optimal view most of the time.<p>The trick isn’t finding a better graph. The trick is making your data look like a tree.<p>Don’t confuse your schema and your view. Your schema will almost always be a cyclic graph. But if you define an arbitrary root node and choose a subset of relationships, you can easily create a hierarchy view of a subset of the graph.<p>All generic nontree views suck beyond a certain complexity. Unless you have a specific kind of cyclic data and specific rendering, it will look bad. The issue is that there is one type of shape for acyclic hierarchical data, the tree, but infinite for cyclic data. If you are displaying cyclic data well, the graph has been tuned for the use case. Drawing cyclic graphs is an NP hard problem, and you need to choose heuristics to layout the nodes.<p>The best graphs views are a lot more than lines and boxes. They facilitate specific jobs, and surface key information and actions. When nodes have heterogeneous types they may need their own renderings beyond simple styling. Just drawing words with connecting lines provides shocking little value, especially for those who aren’t spatial thinkers.<p>To add to that, some people really like graphs and some don’t. No graph will be good enough to get a graph hater to like it. So any time you display a graph you need an alternate view, like a list. And that brings us back to hierarchical trees.</div><br/></div></div><div id="38839222" class="c"><input type="checkbox" id="c-38839222" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38839309">prev</a><span>|</span><a href="#38838020">next</a><span>|</span><label class="collapse" for="c-38839222">[-]</label><label class="expand" for="c-38839222">[1 more]</label></div><br/><div class="children"><div class="content">Always tough to traverse content when it is a graph, I see this a lot in low code tools which give an impossible to traverse graph</div><br/></div></div><div id="38838020" class="c"><input type="checkbox" id="c-38838020" checked=""/><div class="controls bullet"><span class="by">LASR</span><span>|</span><a href="#38839222">prev</a><span>|</span><a href="#38836393">next</a><span>|</span><label class="collapse" for="c-38838020">[-]</label><label class="expand" for="c-38838020">[1 more]</label></div><br/><div class="children"><div class="content">In the context of LLMs, graphs or their simpler cousins - trees are surprisingly good as both inputs and outputs.<p>My team builds LLM-based features as part of our b2b SaaS product.<p>The primary challenge is how to get fuzzy, incomplete, heterogeneous business knowledge into LLMs and do something useful with it. Trees have been excellent. Even simple cases like summarizing content, there is a big improvement in relevance, accuracy and precision.</div><br/></div></div><div id="38836393" class="c"><input type="checkbox" id="c-38836393" checked=""/><div class="controls bullet"><span class="by">ezpuzzle</span><span>|</span><a href="#38838020">prev</a><span>|</span><a href="#38838806">next</a><span>|</span><label class="collapse" for="c-38836393">[-]</label><label class="expand" for="c-38836393">[1 more]</label></div><br/><div class="children"><div class="content">Graph visualizations are more useful for data science than end user tasks.<p>Even in lower cardinality contexts like music genres users are better served by traversing topics through a similarity mechanism (e.g. list of suggested other topics) as it gets to user benefit sooner.  How often are users clicking far away topics from their area of interest? How do they know which direction to travel in?<p>Sufficiently large graphs are always subject to classification mechanisms of human benefit and cardinality.  That means most graphs are best accessed through hierarchical interfaces.<p>One interesting thing is the weights of classification, e.g a band could play multiple genres but are they more representative of some than others.  This might benefit from a creative interface to represent how dimensionally similar a topic is to some ideal entity in each classification value.  Possibly a graph?</div><br/></div></div><div id="38838806" class="c"><input type="checkbox" id="c-38838806" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#38836393">prev</a><span>|</span><a href="#38836179">next</a><span>|</span><label class="collapse" for="c-38838806">[-]</label><label class="expand" for="c-38838806">[1 more]</label></div><br/><div class="children"><div class="content">If human systematics for .. let&#x27;s go with the last 1000+ years has tended to not do this, biblical concordance and the Talmud&#x2F;Kabbalah aside, why would you deliberately walk away from the simpler abstraction?<p>That said, &quot;see also&quot; links are basically making graphs out of trees.</div><br/></div></div><div id="38836179" class="c"><input type="checkbox" id="c-38836179" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#38838806">prev</a><span>|</span><a href="#38835744">next</a><span>|</span><label class="collapse" for="c-38836179">[-]</label><label class="expand" for="c-38836179">[1 more]</label></div><br/><div class="children"><div class="content">By default a large graph looks like a “hairball” when you graph it.<p>Most people in the biz are aware of this but somebody junior always comes around with a meaningless hairball and they can’t understand why people treat them the way a crypto enthusiast gets treated at most parties.</div><br/></div></div><div id="38835744" class="c"><input type="checkbox" id="c-38835744" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#38836179">prev</a><span>|</span><a href="#38837386">next</a><span>|</span><label class="collapse" for="c-38835744">[-]</label><label class="expand" for="c-38835744">[1 more]</label></div><br/><div class="children"><div class="content">Just don’t. There’s no real use case where people need to perceive this graph. It’s embarrassing to see the dreadful redesign of the C2 wiki shown here - the original wiki, no less! - which basically made it unusable. Hypertext is one of the most successful UI paradigms of all time, don’t overthink it.</div><br/></div></div><div id="38837386" class="c"><input type="checkbox" id="c-38837386" checked=""/><div class="controls bullet"><span class="by">mncharity</span><span>|</span><a href="#38835744">prev</a><span>|</span><a href="#38835921">next</a><span>|</span><label class="collapse" for="c-38837386">[-]</label><label class="expand" for="c-38837386">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why don’t we display content as a graph?<p>At least as of, err, 10-ish or 20-ish years ago, it seemed to me a key issue was a dearth of code - a severe disconnect between research literature and available FOSS code.<p>For example, to preserve user orientation, you&#x27;d like a graph&#x27;s presented layout to remain stable during user interactions and edits, rather than being needlessly, repeatedly, and extensively rearranged. There were lots of research papers and prototypes on ways to do that nicely, but crickets for code.<p>Now imagine you want to implement a GUI app, and it turned out &quot;well, first you&#x27;ll have to implement bitblit, and then line drawing, and ...&quot;. You might get articles &quot;Why don&#x27;t we display apps as a GUI?&quot;.<p>As someone who finds it deeply puzzling that people so prefer trees to directed graphs, it was frustrating.</div><br/></div></div><div id="38835921" class="c"><input type="checkbox" id="c-38835921" checked=""/><div class="controls bullet"><span class="by">CrimsonCape</span><span>|</span><a href="#38837386">prev</a><span>|</span><a href="#38836207">next</a><span>|</span><label class="collapse" for="c-38835921">[-]</label><label class="expand" for="c-38835921">[2 more]</label></div><br/><div class="children"><div class="content">The article ends with classifying the challenge as a UI problem and doesn&#x27;t explore the underlying logical design which is not a UI problem.<p>As the author identifies, a graph of all permutations is useless to a user.<p>And, as the author identifies, a hierarchy provides some organization.<p>Hierarchy and graphing are not equal. Hierarchy is a subset of graphing, where binary weight has been applied to the direction.<p>For example, given the set [Foo,Bar], we get the graph with equal weights.<p>Foo &lt;---&gt; Bar<p>If we want a hierarchy, we give full weight to the edge:<p>Foo ---&gt; Bar<p>Given a set and a graph with a weighted edge, we have a direction.<p>The challenge is to dynamically weigh the edge. In reality, an edge with a binary weight is useless. For example,<p>Foo &lt;10%------90%&gt; Bar<p>is a more realistic weight, as in computer programming Foo Bar is almost always the intent, unless the intent is to search a `.Reverse()` method, in which case Bar Foo makes more sense and the most common weight is not valid.<p>However, to the author&#x27;s point, neither the programmer nor the user know the optimal direction between vertices to arrive at the ideal path. The challenge is to generate a state machine in which the weights are dynamically adjusted as the user navigates the graph, resulting in the optimal direction. The best we can do is to analyze the input of other users to generate weights. &quot;Crowd-sourced&quot; weights.</div><br/><div id="38836159" class="c"><input type="checkbox" id="c-38836159" checked=""/><div class="controls bullet"><span class="by">Angostura</span><span>|</span><a href="#38835921">parent</a><span>|</span><a href="#38836207">next</a><span>|</span><label class="collapse" for="c-38836159">[-]</label><label class="expand" for="c-38836159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The challenge is to generate a state machine in which the weights are dynamically adjusted as the user navigates the graph, resulting in the optimal direction. The best we can do is to analyze the input of other users to generate weights. &quot;Crowd-sourced&quot; weights.<p>I think you are right on point 1, but point 2, perhaps we can generate the weights for te individual user, by asking a (very) few simple &#x27;onboarding questions&#x27; that help generate the hierarchy that would suit the user?<p>You sometimes see sites reaching for this kind of approach with the &#x27;For user type X&#x27;, &#x27;for user type Y&#x27; top-level navigation - but this then just leads to multiple static heirarchies.</div><br/></div></div></div></div><div id="38836207" class="c"><input type="checkbox" id="c-38836207" checked=""/><div class="controls bullet"><span class="by">CrypticShift</span><span>|</span><a href="#38835921">prev</a><span>|</span><a href="#38836029">next</a><span>|</span><label class="collapse" for="c-38836207">[-]</label><label class="expand" for="c-38836207">[1 more]</label></div><br/><div class="children"><div class="content">The funny thing is that the web has always been (by definition) a &quot;Content as a Graph&quot; (of interlinks). It is just not &quot;displayed,&quot; or rather, it is displayed sequentially, as though we zoom through the graph&#x27;s edges themselves. There&#x27;s no extensive overview, but that might be precisely what makes it so mentally unburdensome.</div><br/></div></div><div id="38836029" class="c"><input type="checkbox" id="c-38836029" checked=""/><div class="controls bullet"><span class="by">Agraillo</span><span>|</span><a href="#38836207">prev</a><span>|</span><a href="#38835849">next</a><span>|</span><label class="collapse" for="c-38836029">[-]</label><label class="expand" for="c-38836029">[1 more]</label></div><br/><div class="children"><div class="content">Wikipedia has categories that from what is perceived, should form a DAG (Direct Acyclic Graph). But very often they don&#x27;t. I saw this with my own eyes when tried to implement &quot;DagView&quot; (a visual control trying to navigate DAGs similar to trees). So you keep opening sub-categories and one of them suddenly is a super-category noticed before. This indicated for me that despite the fact that DAGs have luxury of having many &quot;parents&quot; it doesn&#x27;t make things easy in the heads of those who try to work with them. Probably our brains are not very good at dealing with non-hierarchical structures</div><br/></div></div><div id="38835849" class="c"><input type="checkbox" id="c-38835849" checked=""/><div class="controls bullet"><span class="by">Veuxdo</span><span>|</span><a href="#38836029">prev</a><span>|</span><a href="#38835867">next</a><span>|</span><label class="collapse" for="c-38835849">[-]</label><label class="expand" for="c-38835849">[1 more]</label></div><br/><div class="children"><div class="content">Graphs work really well for displaying relational data if you can get labels on all (or most) of the arrows and you can zoom in &#x2F; change perspectives to see different relations between the same nodes.<p>Graphs with unlabeled arrows can still be useful, but not without someone there walking you through what the arrows mean. Otherwise, when embedded in an article, they&#x27;re not much more than stock imagery.</div><br/></div></div><div id="38835867" class="c"><input type="checkbox" id="c-38835867" checked=""/><div class="controls bullet"><span class="by">aworks</span><span>|</span><a href="#38835849">prev</a><span>|</span><a href="#38836305">next</a><span>|</span><label class="collapse" for="c-38835867">[-]</label><label class="expand" for="c-38835867">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions Glenn McDonald&#x27;s musical genre page (<a href="https:&#x2F;&#x2F;everynoise.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;everynoise.com&#x2F;</a>, no longer refreshing with new Spotify data) as an example of a flexible graph-like exploration format, without being burdened by explicit connections.<p>The author also has a thorough description of pros and cons of the general concept.</div><br/></div></div><div id="38836305" class="c"><input type="checkbox" id="c-38836305" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#38835867">prev</a><span>|</span><a href="#38835847">next</a><span>|</span><label class="collapse" for="c-38836305">[-]</label><label class="expand" for="c-38836305">[1 more]</label></div><br/><div class="children"><div class="content">imho as a <i>reader</i> a proper lattice (see concept lattice) is useful. Everything else is typically less helpful than it could be. I don&#x27;t find network graphs like those usually produced by &quot;second brain&quot; tools that useful at all. Even  Niklas Luhmann, who largely inspired this networked hypertext approach with his analog zettelkasten imposed enough structure through meta notes and special linkages such that browsing at a particular node could be more hierarchical latticeesque and directed. Browsing pure undirected networks is usually not super useful when it comes to fashioning structured understanding precisely because such an object almost completely lacks structure. Perhaps a set (sans any linkages) is perhaps the only other object with less structure than the undirected network.</div><br/></div></div><div id="38835847" class="c"><input type="checkbox" id="c-38835847" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#38836305">prev</a><span>|</span><a href="#38835974">next</a><span>|</span><label class="collapse" for="c-38835847">[-]</label><label class="expand" for="c-38835847">[1 more]</label></div><br/><div class="children"><div class="content">I guess we’re used to dealing with non-hierarchical data in real life. I have a shelf of books, some list of movies, and a stack of documents.<p>Popular platforms are already prioritizing “recommended” views (as opposed to nested or hierarchical lists). With ai assistants and vr becoming more popular, I could see graph UIs following too.</div><br/></div></div><div id="38835974" class="c"><input type="checkbox" id="c-38835974" checked=""/><div class="controls bullet"><span class="by">tbwriting</span><span>|</span><a href="#38835847">prev</a><span>|</span><a href="#38836118">next</a><span>|</span><label class="collapse" for="c-38835974">[-]</label><label class="expand" for="c-38835974">[1 more]</label></div><br/><div class="children"><div class="content">wikipedia! <a href="https:&#x2F;&#x2F;wikijumps.com" rel="nofollow">https:&#x2F;&#x2F;wikijumps.com</a></div><br/></div></div><div id="38836118" class="c"><input type="checkbox" id="c-38836118" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#38835974">prev</a><span>|</span><label class="collapse" for="c-38836118">[-]</label><label class="expand" for="c-38836118">[1 more]</label></div><br/><div class="children"><div class="content">This is a great article and fun to see fundamental concepts get (re)discovered here!<p>A perspective that we can generalize from the hierarchy discussion is to think about tool-for-the-job: what is the &#x27;content&#x27; job, and what &#x27;jobs&#x27; do graphs do well? We think about this a lot as we work on problems like how to make it easy to explore 100,000X+ more relationships on screen than they&#x27;re showing: <a href="https:&#x2F;&#x2F;github.com&#x2F;graphistry&#x2F;pygraphistry">https:&#x2F;&#x2F;github.com&#x2F;graphistry&#x2F;pygraphistry</a> .<p>First, what do graph visualizations do?<p>- They let us see the relationships in data. The article discusses hierarchy. But there is also progression, root cause, scope, and basically any correlation&#x2F;causation relationship ML&#x2F;AI figures out. There are many interesting relationship questions that pop out as soon as you logs, tables, events, etc!<p>- They let us directly manipulate the nodes &amp; edges, such as for drilling down, navigating, reclustering, etc.<p>- A useful &#x27;aha&#x27; is thinking of modern information visualization as trying to optimize some sort of time-to-insight through a sequence of visual interactions. So each view must be information dense for visually revealing certain insights, and make it easy to get to the next set of visual Q&amp;A.<p>- Ex: When the entities are the interesting thing wrt questions, being able to drill down into individual nodes&#x2F;edges into great dedicated views becomes important, so graphs should often be multimodal. And if the relationship aspect is unimportant... then using graph view hurts more than it helps.<p>- From optimization perspective, it now makes sense to specialize for specific domains. Maybe what is needed is more of a small diagram, and not actually investigating a lot of relationships. Or a graph of subway stops, which has additional visual considerations. For a website, a sitemap navigation vs clickstream product analytics view would likewise need<p>A good analogy is a map. Sometimes exploring Google Maps is great, and you drill into a business inspector sidebar or down to a street view. But other times, it&#x27;s better to have the map embedded into Yelp.com restaurant entry when you just need a quick view of mapping information as part of some broader context. Or you don&#x27;t care about that map at all and can skip it.<p>Given all that.. it&#x27;s interesting to revisit asking... what is the &#x27;content&#x27; job to be solved? What kinds of content lean towards graph, and which don&#x27;t?</div><br/></div></div></div></div></div></div></div></body></html>