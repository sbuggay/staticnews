<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689498054811" as="style"/><link rel="stylesheet" href="styles.css?v=1689498054811"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.orioledata.com/blog/no-more-vacuum-in-postgresql/">PostgreSQL: No More Vacuum, No More Bloat</a> <span class="domain">(<a href="https://www.orioledata.com">www.orioledata.com</a>)</span></div><div class="subtext"><span>pella</span> | <span>88 comments</span></div><br/><div><div id="36742978" class="c"><input type="checkbox" id="c-36742978" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#36743079">next</a><span>|</span><label class="collapse" for="c-36742978">[-]</label><label class="expand" for="c-36742978">[6 more]</label></div><br/><div class="children"><div class="content">Good job! That&#x27;s cool.<p>How do you plan to make your new project keep up to date with the release cadence of the parent project?<p>...because otherwise, I can&#x27;t see how this is a good idea.<p>Look, I have the same reaction whenever someone does this.<p>If someone goes and forks rust and creates a new programming language call dust that solves I dunno, the fundamental async compatibility story, or adds (somehow) a zero cost native GC type back into the language, I&#x27;d say the same thing.<p>You&#x27;ve taken a big open source project, forked it and laid some significant changes on it, which you don&#x27;t believe this be accepted upstream.<p>Ok...is this a toy that you made for fun?<p>...or a serious project you expect to maintain?<p>If the answer is &#x27;serious project&#x27;, please make <i>explicit</i> your plans to avoid becoming abandonware in the future, your plans to fold future release from (original project) into yours, or your plans to diverge henceforth into an entirely new project.<p>To be fair, I get it, this is an extension that seems like it could... probably... receive changes that are made upstream in postgres; but, if it was that easy, it belongs as part of the postgres projecct; so, I guess, it&#x27;s not that easy.<p>So, serious? Or just for fun?</div><br/><div id="36744403" class="c"><input type="checkbox" id="c-36744403" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#36742978">parent</a><span>|</span><a href="#36744548">next</a><span>|</span><label class="collapse" for="c-36744403">[-]</label><label class="expand" for="c-36744403">[1 more]</label></div><br/><div class="children"><div class="content">The author wrote this, answering the question in a reply on the post:<p>&gt; Yes, sure! But that&#x27;s the long way to go. Right now OrioleDB is an extension, which comes with PostgreSQL core patch. The mid-term goal for OrioleDB is to become a pure extension. The long-term goal is to make OrioleDB part of PostgreSQL core.</div><br/></div></div><div id="36744548" class="c"><input type="checkbox" id="c-36744548" checked=""/><div class="controls bullet"><span class="by">somsak2</span><span>|</span><a href="#36742978">parent</a><span>|</span><a href="#36744403">prev</a><span>|</span><a href="#36743037">next</a><span>|</span><label class="collapse" for="c-36744548">[-]</label><label class="expand" for="c-36744548">[1 more]</label></div><br/><div class="children"><div class="content">are you considering using this in production somewhere in the next few days? your reply comes off as absurdly aggressive, especially when you mention no intention of supporting the project monetarily. and that&#x27;s on top of this question being addressed already, as other commenters pointed out.<p>maybe don&#x27;t come in so hot next time.</div><br/></div></div><div id="36743037" class="c"><input type="checkbox" id="c-36743037" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#36742978">parent</a><span>|</span><a href="#36744548">prev</a><span>|</span><a href="#36743403">next</a><span>|</span><label class="collapse" for="c-36743037">[-]</label><label class="expand" for="c-36743037">[1 more]</label></div><br/><div class="children"><div class="content">As a data point, that&#x27;s already been answered: :)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36742001">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36742001</a></div><br/></div></div><div id="36743403" class="c"><input type="checkbox" id="c-36743403" checked=""/><div class="controls bullet"><span class="by">fshbbdssbbgdd</span><span>|</span><a href="#36742978">parent</a><span>|</span><a href="#36743037">prev</a><span>|</span><a href="#36743079">next</a><span>|</span><label class="collapse" for="c-36743403">[-]</label><label class="expand" for="c-36743403">[2 more]</label></div><br/><div class="children"><div class="content">Reasonable points. As an onlooker who has run into VACUUM in years past, I have wondered: is this a fundamental necessity, or could it possibly be fixed? Seeing an example of it being fixed is certainly helpful. If I work at a company with the resources to maintain a Postgres fork, great! If not, we can evaluate whether the challenges of using this fork are worth the performance benefit.</div><br/><div id="36743859" class="c"><input type="checkbox" id="c-36743859" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36742978">root</a><span>|</span><a href="#36743403">parent</a><span>|</span><a href="#36743079">next</a><span>|</span><label class="collapse" for="c-36743859">[-]</label><label class="expand" for="c-36743859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a company with the resources to maintain a Postgres fork<p>That sounds like a monumental feat</div><br/></div></div></div></div></div></div><div id="36743079" class="c"><input type="checkbox" id="c-36743079" checked=""/><div class="controls bullet"><span class="by">mjlawson</span><span>|</span><a href="#36742978">prev</a><span>|</span><a href="#36742620">next</a><span>|</span><label class="collapse" for="c-36743079">[-]</label><label class="expand" for="c-36743079">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited about the title, but I have to say that my initial impression has left me frustrated. The main README on GitHub[1] smells of corporate-speak. So far I&#x27;ve learned that:<p>- OrioleDB is a new storage engine for PostgreSQL<p>- PostgreSQL is most-loved (whatever that means)<p>- OrioleDB is an extension that builds on.. other extensions?<p>- OrioleDB opens the door to the cloud!<p>In the wake of crypto and other Web 3.0 grift, this is not the tact that I&#x27;d take to release something that extends and improves on something as important as PostgreSQL.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb</a></div><br/><div id="36743870" class="c"><input type="checkbox" id="c-36743870" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#36743079">parent</a><span>|</span><a href="#36742620">next</a><span>|</span><label class="collapse" for="c-36743870">[-]</label><label class="expand" for="c-36743870">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OrioleDB is an extension that builds on.. other extensions<p>I assume you are referring to this part:<p>&gt; OrioleDB consists of an extension, building on the innovative table access method framework and other standard Postgres extension interfaces.<p>I don&#x27;t know how they could be more clear? Table access methods were introduced in PostgreSQL to support alternative storage methods (like zheap, which tries to do something very similar, or possibly columnar data stores).<p>Mentioning this fact is important, because there are a bunch of forks of PostgreSQL with alternative data storage systems; this is designed to work as an extension for an unforked PostgreSQL. (It doesn&#x27;t yet)<p>The Readme seems very clear if you are familiar with PostgreSQL.</div><br/></div></div></div></div><div id="36742620" class="c"><input type="checkbox" id="c-36742620" checked=""/><div class="controls bullet"><span class="by">ctippett</span><span>|</span><a href="#36743079">prev</a><span>|</span><a href="#36742497">next</a><span>|</span><label class="collapse" for="c-36742620">[-]</label><label class="expand" for="c-36742620">[6 more]</label></div><br/><div class="children"><div class="content">The article makes some convincing arguments and the benchmarks seem to corroborate their performance claims, but I don&#x27;t understand the dichotomy between this proposed new storage engine (OrioleDB?) and PostgreSQL itself.<p>Besides the commercial motivations and wanting to profit from the innovations discussed in the article, is there any reason why this needs to be a whole new database marketed as OrioleDB versus contributing these improvements upstream?</div><br/><div id="36742992" class="c"><input type="checkbox" id="c-36742992" checked=""/><div class="controls bullet"><span class="by">akorotkov</span><span>|</span><a href="#36742620">parent</a><span>|</span><a href="#36742793">next</a><span>|</span><label class="collapse" for="c-36742992">[-]</label><label class="expand" for="c-36742992">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m seeing OrioleDB as a future engine for PostgreSQL. I&#x27;d like to see it as the default engine.
However, the changes in OrioleDB are too big to be made incrementally.  This is why I&#x27;m comparing the current PostgreSQL engine (with more than just heap, but many other subsystems as well) with OrioleDB.</div><br/><div id="36744272" class="c"><input type="checkbox" id="c-36744272" checked=""/><div class="controls bullet"><span class="by">tarasglek</span><span>|</span><a href="#36742620">root</a><span>|</span><a href="#36742992">parent</a><span>|</span><a href="#36744250">next</a><span>|</span><label class="collapse" for="c-36744272">[-]</label><label class="expand" for="c-36744272">[1 more]</label></div><br/><div class="children"><div class="content">Curious if you could share further roadmap.
Potential interesting directions:
1. plans for integration with object store ala neon?<p>2. Columnar?<p>3. Async-io oriented redesign<p>4. Interesting new features ala subscriotions to table changes<p>5. Zero copy client bindings</div><br/></div></div><div id="36744250" class="c"><input type="checkbox" id="c-36744250" checked=""/><div class="controls bullet"><span class="by">tarasglek</span><span>|</span><a href="#36742620">root</a><span>|</span><a href="#36742992">parent</a><span>|</span><a href="#36744272">prev</a><span>|</span><a href="#36742793">next</a><span>|</span><label class="collapse" for="c-36744250">[-]</label><label class="expand" for="c-36744250">[1 more]</label></div><br/><div class="children"><div class="content">Just curious, are you ukrainian?<p>Never thought I would see a fellow ukrainian rewriting my fav db.</div><br/></div></div></div></div><div id="36742793" class="c"><input type="checkbox" id="c-36742793" checked=""/><div class="controls bullet"><span class="by">fuy</span><span>|</span><a href="#36742620">parent</a><span>|</span><a href="#36742992">prev</a><span>|</span><a href="#36742773">next</a><span>|</span><label class="collapse" for="c-36742793">[-]</label><label class="expand" for="c-36742793">[1 more]</label></div><br/><div class="children"><div class="content">Alexander Korotkov (OrioleDb author) idea, - based on his Postgres committer experience, I believe, - is that these changes are way too big to be ever accepted upstream, hence separate engine. More info <a href="https:&#x2F;&#x2F;www.socallinuxexpo.org&#x2F;sites&#x2F;default&#x2F;files&#x2F;presentations&#x2F;solving-postgres-wicked-problems.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.socallinuxexpo.org&#x2F;sites&#x2F;default&#x2F;files&#x2F;presentat...</a>, see esp. slides 9-11</div><br/></div></div><div id="36742773" class="c"><input type="checkbox" id="c-36742773" checked=""/><div class="controls bullet"><span class="by">waplot</span><span>|</span><a href="#36742620">parent</a><span>|</span><a href="#36742793">prev</a><span>|</span><a href="#36742497">next</a><span>|</span><label class="collapse" for="c-36742773">[-]</label><label class="expand" for="c-36742773">[1 more]</label></div><br/><div class="children"><div class="content">These changes are way too big to integrated into postgresql&#x27;s engine itself. It fundamentally changes how MVCC is done.</div><br/></div></div></div></div><div id="36742497" class="c"><input type="checkbox" id="c-36742497" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#36742620">prev</a><span>|</span><a href="#36741097">next</a><span>|</span><label class="collapse" for="c-36742497">[-]</label><label class="expand" for="c-36742497">[1 more]</label></div><br/><div class="children"><div class="content">Since this is an engine extension, I wonder if it would have any effect when combined with others. For example, timescaledb [0] acts on underlying tables. I wonder if this would have some effect if you did something like<p><pre><code>    create table xyz(...) using orioledb;
    select create_hypertable(xyz, ts);
</code></pre>
[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;timescaledb">https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;timescaledb</a></div><br/></div></div><div id="36741097" class="c"><input type="checkbox" id="c-36741097" checked=""/><div class="controls bullet"><span class="by">daenney</span><span>|</span><a href="#36742497">prev</a><span>|</span><a href="#36741589">next</a><span>|</span><label class="collapse" for="c-36741097">[-]</label><label class="expand" for="c-36741097">[23 more]</label></div><br/><div class="children"><div class="content">I love the whole “2.3x less CPU overhead per transaction” where Postgres scales from 5% to 65% CPU usage and Oriole sits constantly at 90%. That doesn’t seem like a huge success to me? The predictability sure is nice, but moving the lower end up by 85% is something I’d be rather worried about</div><br/><div id="36741480" class="c"><input type="checkbox" id="c-36741480" checked=""/><div class="controls bullet"><span class="by">acjohnson55</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741337">next</a><span>|</span><label class="collapse" for="c-36741480">[-]</label><label class="expand" for="c-36741480">[13 more]</label></div><br/><div class="children"><div class="content">You generally want to keep your CPU fully utilized. It looks like Oriole is doing significantly more transactions and is CPU-bound, due to much lower IO requirements. The good news is that it implies you could get even more performance out of Oriole by vertically scaling to a more powerful CPU, whereas Postgres would not continue to increase in performance this way.<p>Those idle times on the Postgres server <i>could</i> be used for something else, if you&#x27;re thinking in a desktop OS mindset. But for servers, you tend to want machines that are doing one thing and are optimized for that thing.</div><br/><div id="36741619" class="c"><input type="checkbox" id="c-36741619" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741480">parent</a><span>|</span><a href="#36742791">next</a><span>|</span><label class="collapse" for="c-36741619">[-]</label><label class="expand" for="c-36741619">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You generally want to keep your CPU fully utilized.<p>Not in real life concurrent systems where latency matters.   In addition to the queuing&#x2F;random request arrival rate reasons, all kinds of funky latency hiccups start happening both at the DB and OS level when you run your CPU <i>average</i> utilization near 100%. Spinlocks, priority inversion, etc. Some bugs show up that don’t manifest when running with lower CPU utilization etc.</div><br/><div id="36744857" class="c"><input type="checkbox" id="c-36744857" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741619">parent</a><span>|</span><a href="#36744584">next</a><span>|</span><label class="collapse" for="c-36744857">[-]</label><label class="expand" for="c-36744857">[1 more]</label></div><br/><div class="children"><div class="content">This is a benchmark that tries to execute as many queries as possible, so the interesting stat is transactions per second, not CPU usage. This benchmark is testing top speed, not real world behaviour.<p>If you tested both systems with the same workload (eg. a specific number of queries per second), then the average CPU usage would be much lower for the more efficient engine.<p>The low CPU usage in this benchmark is just a sign that the performance is not CPU bound, but limited by other factors like locking or IO.</div><br/></div></div><div id="36744584" class="c"><input type="checkbox" id="c-36744584" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741619">parent</a><span>|</span><a href="#36744857">prev</a><span>|</span><a href="#36742726">next</a><span>|</span><label class="collapse" for="c-36744584">[-]</label><label class="expand" for="c-36744584">[1 more]</label></div><br/><div class="children"><div class="content">Here the system is doing a pretty consistent 750k TPS instead of oscillating between 0 and 225k-- often sitting near 0TPS for tens of seconds.  Which system do you think will have better latency for any given loading?</div><br/></div></div><div id="36742726" class="c"><input type="checkbox" id="c-36742726" checked=""/><div class="controls bullet"><span class="by">deadbeeves</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741619">parent</a><span>|</span><a href="#36744584">prev</a><span>|</span><a href="#36742791">next</a><span>|</span><label class="collapse" for="c-36742726">[-]</label><label class="expand" for="c-36742726">[2 more]</label></div><br/><div class="children"><div class="content">So what you&#x27;re saying is that an acceptable way to compensate the system&#x27;s bugginess is by making it more inefficient? I&#x27;d rather use a system that&#x27;s stable under load.</div><br/><div id="36743919" class="c"><input type="checkbox" id="c-36743919" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36742726">parent</a><span>|</span><a href="#36742791">next</a><span>|</span><label class="collapse" for="c-36743919">[-]</label><label class="expand" for="c-36743919">[1 more]</label></div><br/><div class="children"><div class="content">OP has a point [0], though I&#x27;m unsure if Kernels under load are really that unstable &#x2F; untested.<p>[0] <a href="https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2021&#x2F;05&#x2F;24&#x2F;metastable.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2021&#x2F;05&#x2F;24&#x2F;metastable.html</a> &#x2F; <a href="https:&#x2F;&#x2F;archive.is&#x2F;6Qtet" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.is&#x2F;6Qtet</a></div><br/></div></div></div></div></div></div><div id="36742791" class="c"><input type="checkbox" id="c-36742791" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741480">parent</a><span>|</span><a href="#36741619">prev</a><span>|</span><a href="#36741535">next</a><span>|</span><label class="collapse" for="c-36742791">[-]</label><label class="expand" for="c-36742791">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You generally want to keep your CPU fully utilized<p>Only if your load is very predictable. If there is a chance of a spike, you often want enough headroom to handle it. Even if you have some kind of automated scaling, that can take time, and you probably want a buffer until your new capacity is available.</div><br/><div id="36744597" class="c"><input type="checkbox" id="c-36744597" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36742791">parent</a><span>|</span><a href="#36741535">next</a><span>|</span><label class="collapse" for="c-36744597">[-]</label><label class="expand" for="c-36744597">[1 more]</label></div><br/><div class="children"><div class="content">I think many here is misunderstanding what was likely meant:  postgresql was not able to use all the available CPU under this situation, in that it was oscillating from 10% to 70% CPU use.  That 40% average cpu use isn&#x27;t an asset on a dedicated database server: it just means that the other 60% of available cycles are a perishable resource that are immediately spoiling.<p>In that sense, you want to be able to have your database be able to use all the resources available: all the IOPS, all the CPU cycles, etc.<p>And, of course, the real thing is the amount of work you get done: this thing does more work-- partially by using more  CPU cycles, and partially by doing more work per CPU cycle.</div><br/></div></div></div></div><div id="36741535" class="c"><input type="checkbox" id="c-36741535" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741480">parent</a><span>|</span><a href="#36742791">prev</a><span>|</span><a href="#36741337">next</a><span>|</span><label class="collapse" for="c-36741535">[-]</label><label class="expand" for="c-36741535">[5 more]</label></div><br/><div class="children"><div class="content">It’s hard to generalize on these points. In a situation where the throughput was inverted but the proportional system usage was the same, you would instead say “you can still vertically scale by adding more disks”, rather than saying adding bigger cpu. It’s not meaningful in isolation.<p>It may be reasonable to suggest that for a new code base that is cpu bound there’s a good chance there is low hanging fruit for cpu optimizations that may further increase the throughput gap. It’s also the case however that the prior engines tuning starting life on much older computer architectures, drastically different proportional syscall costs and so on, it very often means that there’s low hanging fruit in configuration to improve baseline benchmarks such as these. High io time suggests poor caching which in many scenarios you’d consider a suboptimal deployed configuration.<p>It’s not just the devil that’s in the details, it’s everything.</div><br/><div id="36741595" class="c"><input type="checkbox" id="c-36741595" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741535">parent</a><span>|</span><a href="#36741618">next</a><span>|</span><label class="collapse" for="c-36741595">[-]</label><label class="expand" for="c-36741595">[1 more]</label></div><br/><div class="children"><div class="content">To be a little more clear on what the detail of the benchmark in question is: it’s a benchmark that explicitly exercises a pathological use case for postgresqls current design, one that nonetheless functions, and demonstrates that the advertised engine does not have that pathology. A key takeaway should probably be, if you’re a Postgres user: if your workload looks exactly like this (sparse upserts into a large data set at a high rate) then you might want to evaluate your the runway of your architecture before the geometric costs or latency stalls become relevant - just as for cost analysis of any other system. What is somewhat interesting in this article, and not super clearly presented, is that this workload is actually fairly pathological for most existing engines offering this set of structural and query facilities, and that’s interesting, if this is the niche you need. Most people do some amount of this, but not always at a super high rate, and there are ways to get the same effective writable&#x2F;readable data using a different schema, while avoiding it. Nice thing here is you can do the one-liner version.</div><br/></div></div><div id="36741618" class="c"><input type="checkbox" id="c-36741618" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741535">parent</a><span>|</span><a href="#36741595">prev</a><span>|</span><a href="#36741585">next</a><span>|</span><label class="collapse" for="c-36741618">[-]</label><label class="expand" for="c-36741618">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you can still vertically scale by adding more disks<p>Parallelizing IO is a lot different from scaling up CPU power, though. I&#x27;d imagine DB server IO performance has a lot less lower-hanging fruit than CPU&#x2F;software performance.</div><br/><div id="36742749" class="c"><input type="checkbox" id="c-36742749" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741618">parent</a><span>|</span><a href="#36741585">next</a><span>|</span><label class="collapse" for="c-36742749">[-]</label><label class="expand" for="c-36742749">[1 more]</label></div><br/><div class="children"><div class="content">That depends, the ratio of free bus capacity for data fetch, and free capacity for inter-CPU synchronization is skewed _massively_ in favor of capacity for data fetch. An x86 system is already under-capacity at the cpu&#x2F;bus interface, which is why we keep throwing more and more cache at the problem and it works.<p>Similarly in the cloud on AWS fro example, you have publicly available scalability options starting from 5k IOPS up to 2M IOPS, &gt;400x or 3 orders of magnitude. By contrast you&#x27;re going from 1vcpu to 192 cores, about half the raise, and a lower performance scaling due to the increased cost of cross-package shootdowns.<p>Yup, they&#x27;re different, for sure, but the implication that CPU is easier is not all that clear. In either case, with a database style workload, and with either of these engines in practice you&#x27;re going to hit a limit at the bus in practice long before you hit a limit on compute or disk io, for any sustained workload - bursts are different.</div><br/></div></div></div></div><div id="36741585" class="c"><input type="checkbox" id="c-36741585" checked=""/><div class="controls bullet"><span class="by">acjohnson55</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741535">parent</a><span>|</span><a href="#36741618">prev</a><span>|</span><a href="#36741337">next</a><span>|</span><label class="collapse" for="c-36741585">[-]</label><label class="expand" for="c-36741585">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense. I&#x27;m mostly just trying to explain the counterintuitive reason that the high CPU usage shouldn&#x27;t be interpreted as a flaw.</div><br/></div></div></div></div></div></div><div id="36741337" class="c"><input type="checkbox" id="c-36741337" checked=""/><div class="controls bullet"><span class="by">jklehm</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741480">prev</a><span>|</span><a href="#36741721">next</a><span>|</span><label class="collapse" for="c-36741337">[-]</label><label class="expand" for="c-36741337">[1 more]</label></div><br/><div class="children"><div class="content">My read is that it&#x27;s at 90% because they are saturating the CPU to that point with the TPS threshold they use for comparison, the TPS of Oriole is constant and way higher than pg in these charts at least.<p>I&#x27;d think the CPU will drop proportionally to the TPS, they just want to show how high it can go here.</div><br/></div></div><div id="36741721" class="c"><input type="checkbox" id="c-36741721" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741337">prev</a><span>|</span><a href="#36742633">next</a><span>|</span><label class="collapse" for="c-36741721">[-]</label><label class="expand" for="c-36741721">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but now that your CPU utilization is uncapped, you can more easily scale the utilization down and retain some form of proportional performance, so it doesn&#x27;t matter. If you capped the system to 60% of your CPU, it might change the overall numbers, but say you&#x27;re doing 1.8x more TPS at the same usage, it&#x27;s a win either way. It&#x27;s not a marketing trick; those numbers come across as &quot;Very good&quot;, to me.<p>If Expensive Server CPU = X dollars per unit, and it&#x27;s only used at 60% capacity and can realistically only be used at that capacity, then you have effectively just set .4*X amount of dollars on fire, per unit. If you can vertically take a workload and scale it to saturate 90% of a machine, it&#x27;s generally easy to apply QOS and other isolation techniques to achieve lower saturation and retain some proportional level of performance. The reverse is not true: if you can only hit 60% of your total machine saturation before you need to scale out, then the only way to get to 90% or higher saturation is through a redesign. Which is exactly what has happened here.</div><br/></div></div><div id="36742633" class="c"><input type="checkbox" id="c-36742633" checked=""/><div class="controls bullet"><span class="by">avianlyric</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741721">prev</a><span>|</span><a href="#36741341">next</a><span>|</span><label class="collapse" for="c-36742633">[-]</label><label class="expand" for="c-36742633">[1 more]</label></div><br/><div class="children"><div class="content">It was a performance test, where presumably the objective was to apply the maximum possible load each DB engine could handle, and apply that load continuous for a long period of time.<p>The CPU load jumping up and down isn’t Postgres “scaling” it Postgres hitting performance bottlenecks on a regular basis, presumably driven by the need to perform vacuums which are very IO insensitive. So instead of using IO to serve queries, Postgres is using IO for janitorial work, and TPS (and thus CPU usage) crater.<p>Oriole on the other hand manages much higher throughput, and much more consistently than Postgres.<p>What would you prefer a car that does a constant 100mph when your foot’s down. Or one that wildly oscillates between 40mph and 70mph, despite you trying to put the pedal through the floor?</div><br/></div></div><div id="36741341" class="c"><input type="checkbox" id="c-36741341" checked=""/><div class="controls bullet"><span class="by">pella</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36742633">prev</a><span>|</span><a href="#36742957">next</a><span>|</span><label class="collapse" for="c-36741341">[-]</label><label class="expand" for="c-36741341">[1 more]</label></div><br/><div class="children"><div class="content">With the same equipment, your performance is now five times better. (5X higher TPS) We need to test again with more hardware, but if you can maintain 3 times the performance at the lower end, it could be a good alternative for some users.<p><i>&quot;As the cumulative result of the improvements discussed above, OrioleDB provides:<p>- 5X higher TPS,<p>- 2.3X less CPU load per transaction,<p>- 22X less IOPS per transaction,<p>- No table and index bloat.&quot;</i></div><br/></div></div><div id="36742957" class="c"><input type="checkbox" id="c-36742957" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741341">prev</a><span>|</span><a href="#36741469">next</a><span>|</span><label class="collapse" for="c-36742957">[-]</label><label class="expand" for="c-36742957">[1 more]</label></div><br/><div class="children"><div class="content">Yes, because they are performing more transactions per second, by virtue of performing less I&#x2F;O per transaction.  This is a good thing.</div><br/></div></div><div id="36741469" class="c"><input type="checkbox" id="c-36741469" checked=""/><div class="controls bullet"><span class="by">waterproof</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36742957">prev</a><span>|</span><a href="#36741321">next</a><span>|</span><label class="collapse" for="c-36741469">[-]</label><label class="expand" for="c-36741469">[2 more]</label></div><br/><div class="children"><div class="content">Eyeballing the tps graph, OrioleDB is doing 5x tps while using 2x the CPU. So about 5&#x2F;2=2.5x the CPU per transaction.<p>Checks out.</div><br/><div id="36741662" class="c"><input type="checkbox" id="c-36741662" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#36741097">root</a><span>|</span><a href="#36741469">parent</a><span>|</span><a href="#36741321">next</a><span>|</span><label class="collapse" for="c-36741662">[-]</label><label class="expand" for="c-36741662">[1 more]</label></div><br/><div class="children"><div class="content">5x tps with 2x CPU is 2&#x2F;5 = 0.4x the CPU (ie. it&#x27;s more efficient per transaction).</div><br/></div></div></div></div><div id="36741321" class="c"><input type="checkbox" id="c-36741321" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#36741097">parent</a><span>|</span><a href="#36741469">prev</a><span>|</span><a href="#36741336">next</a><span>|</span><label class="collapse" for="c-36741321">[-]</label><label class="expand" for="c-36741321">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not clear if the CPU cost per tx is any worse. Was OrioleDB doing 5x the transactions at this CPU usage?</div><br/></div></div></div></div><div id="36741589" class="c"><input type="checkbox" id="c-36741589" checked=""/><div class="controls bullet"><span class="by">rickette</span><span>|</span><a href="#36741097">prev</a><span>|</span><a href="#36744091">next</a><span>|</span><label class="collapse" for="c-36741589">[-]</label><label class="expand" for="c-36741589">[11 more]</label></div><br/><div class="children"><div class="content">The article contains a link with the rather curious title &quot;10 things that Richard Branson hates about PostgreSQL&quot;.... Turns out the guy who wrote that blog is called Rick Branson, not Richard.</div><br/><div id="36741661" class="c"><input type="checkbox" id="c-36741661" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36741589">parent</a><span>|</span><a href="#36741757">next</a><span>|</span><label class="collapse" for="c-36741661">[-]</label><label class="expand" for="c-36741661">[7 more]</label></div><br/><div class="children"><div class="content">Rick is a nickname for Richard.</div><br/><div id="36741937" class="c"><input type="checkbox" id="c-36741937" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#36741589">root</a><span>|</span><a href="#36741661">parent</a><span>|</span><a href="#36741697">next</a><span>|</span><label class="collapse" for="c-36741937">[-]</label><label class="expand" for="c-36741937">[5 more]</label></div><br/><div class="children"><div class="content">True words can still be clickbait.<p>In fact, I&#x27;d argue that many of the most effective ways to mislead people involve sticking rigidly to literal truth, because it makes them so much harder to counter. When there&#x27;s no literal untruth to correct, it&#x27;s natural to end up implying bad faith _without having any definitive proof_, and that is mighty unstable ground from which to argue.</div><br/><div id="36742405" class="c"><input type="checkbox" id="c-36742405" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36741589">root</a><span>|</span><a href="#36741937">parent</a><span>|</span><a href="#36743021">next</a><span>|</span><label class="collapse" for="c-36742405">[-]</label><label class="expand" for="c-36742405">[2 more]</label></div><br/><div class="children"><div class="content">I get what you’re saying, but imagine your name was Richard Branson. You’d hear no end to the jokes. At what point can you consider this an internalized behavior of the author? Is it still clickbait if the author believes his main raison d’etre is to have a meme name?</div><br/><div id="36742489" class="c"><input type="checkbox" id="c-36742489" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#36741589">root</a><span>|</span><a href="#36742405">parent</a><span>|</span><a href="#36743021">next</a><span>|</span><label class="collapse" for="c-36742489">[-]</label><label class="expand" for="c-36742489">[1 more]</label></div><br/><div class="children"><div class="content">I think I basically agree with you. And this example is pretty benign — I&#x27;m not actually meaning to criticize anyone here.<p>However I will not that the author in question refers to himself as &quot;Rick Branson&quot;, and the article title is &quot;10 Things I Hate About PostgreSQL&quot;. So I think it&#x27;s just the person who made the link who is being a bit cheeky.<p>My comment was going off on a wild tangent. :)</div><br/></div></div></div></div><div id="36743021" class="c"><input type="checkbox" id="c-36743021" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#36741589">root</a><span>|</span><a href="#36741937">parent</a><span>|</span><a href="#36742405">prev</a><span>|</span><a href="#36742171">next</a><span>|</span><label class="collapse" for="c-36743021">[-]</label><label class="expand" for="c-36743021">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like that album by Pete Best, who was a drummer in The Beatles. He published a solo album called &quot;Best of the Beatles&quot;.</div><br/></div></div><div id="36742171" class="c"><input type="checkbox" id="c-36742171" checked=""/><div class="controls bullet"><span class="by">mattl</span><span>|</span><a href="#36741589">root</a><span>|</span><a href="#36741937">parent</a><span>|</span><a href="#36743021">prev</a><span>|</span><a href="#36741697">next</a><span>|</span><label class="collapse" for="c-36742171">[-]</label><label class="expand" for="c-36742171">[1 more]</label></div><br/><div class="children"><div class="content">See the guy on Bluesky who is called Steve Wozniak and isn’t trying to pretend to be Woz and yet has issues while Bluesky also let someone with a racial slur username get an account</div><br/></div></div></div></div></div></div><div id="36741757" class="c"><input type="checkbox" id="c-36741757" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36741589">parent</a><span>|</span><a href="#36741661">prev</a><span>|</span><a href="#36742501">next</a><span>|</span><label class="collapse" for="c-36741757">[-]</label><label class="expand" for="c-36741757">[2 more]</label></div><br/><div class="children"><div class="content">That caught my eye, too. What do I care what the Virgin CEO thinks of a database?<p>Oh, not that one.</div><br/></div></div><div id="36742501" class="c"><input type="checkbox" id="c-36742501" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#36741589">parent</a><span>|</span><a href="#36741757">prev</a><span>|</span><a href="#36744091">next</a><span>|</span><label class="collapse" for="c-36742501">[-]</label><label class="expand" for="c-36742501">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Richard Branson&quot; is not a unique identifier. Maybe we should all go by UUIDs</div><br/></div></div></div></div><div id="36744091" class="c"><input type="checkbox" id="c-36744091" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#36741589">prev</a><span>|</span><a href="#36741496">next</a><span>|</span><label class="collapse" for="c-36744091">[-]</label><label class="expand" for="c-36744091">[2 more]</label></div><br/><div class="children"><div class="content">If this engine is so much better than the internal one shouldn&#x27;t we expect that at least the big cloud providers will use it on their managed servers? They have an economic incentive to do so. If that happens eventually the PostgreSQL project itself will replace the default engine, or am I wrong?</div><br/><div id="36744126" class="c"><input type="checkbox" id="c-36744126" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36744091">parent</a><span>|</span><a href="#36741496">next</a><span>|</span><label class="collapse" for="c-36744126">[-]</label><label class="expand" for="c-36744126">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure the risk of an immature engine is worth it to them. Customers pay for hosted Postgres because they want to not worry about doing it themselves for cheaper. They are paying for reliability.<p>I think you’re correct about the existence of an economic incentive for the cloud providers, but I anticipate it would be offered as a distinct product to “vanilla” (at least in the sort term).<p>Things get interesting though because this space of database products has trended towards restricting who can host in their license terms (TimeScale, ClickHouse, etc). If that’s Orioles cash-in play then maybe cloud providers can’t use it anyway.<p>I suspect the fate of the engine will be determined by its funding source</div><br/></div></div></div></div><div id="36741496" class="c"><input type="checkbox" id="c-36741496" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#36744091">prev</a><span>|</span><a href="#36741409">next</a><span>|</span><label class="collapse" for="c-36741496">[-]</label><label class="expand" for="c-36741496">[3 more]</label></div><br/><div class="children"><div class="content">Vacuum does more than removing dead tuples though, there is still a need to update statistics and summarize BRINs.</div><br/><div id="36741523" class="c"><input type="checkbox" id="c-36741523" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#36741496">parent</a><span>|</span><a href="#36741522">next</a><span>|</span><label class="collapse" for="c-36741523">[-]</label><label class="expand" for="c-36741523">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re thinking of ANALYZE which is a separate operation that&#x27;s commonly run during vacuuming but can be invoked independently</div><br/></div></div><div id="36741522" class="c"><input type="checkbox" id="c-36741522" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#36741496">parent</a><span>|</span><a href="#36741523">prev</a><span>|</span><a href="#36741409">next</a><span>|</span><label class="collapse" for="c-36741522">[-]</label><label class="expand" for="c-36741522">[1 more]</label></div><br/><div class="children"><div class="content">Yes. The (psql 15) docs are well written: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;routine-vacuuming.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;routine-vacuuming.html</a></div><br/></div></div></div></div><div id="36741409" class="c"><input type="checkbox" id="c-36741409" checked=""/><div class="controls bullet"><span class="by">ccleve</span><span>|</span><a href="#36741496">prev</a><span>|</span><a href="#36741419">next</a><span>|</span><label class="collapse" for="c-36741409">[-]</label><label class="expand" for="c-36741409">[5 more]</label></div><br/><div class="children"><div class="content">Is there any documentation on the &quot;extensibility patches&quot;? What did you have to do to core Postgres to get this new approach to work?</div><br/><div id="36742001" class="c"><input type="checkbox" id="c-36742001" checked=""/><div class="controls bullet"><span class="by">akorotkov</span><span>|</span><a href="#36741409">parent</a><span>|</span><a href="#36741419">next</a><span>|</span><label class="collapse" for="c-36742001">[-]</label><label class="expand" for="c-36742001">[4 more]</label></div><br/><div class="children"><div class="content">Please, check this.
<a href="https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-pluggable-strorage">https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-pluggable-strorage</a>
<a href="https:&#x2F;&#x2F;www.pgcon.org&#x2F;events&#x2F;pgcon_2023&#x2F;schedule&#x2F;session&#x2F;470-future-of-table-access-methods&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pgcon.org&#x2F;events&#x2F;pgcon_2023&#x2F;schedule&#x2F;session&#x2F;470...</a>
Pushing patches to PostgreSQL Core requires a lot of work.  But there is a progress already: 5k lines patchset to PG 14, and 2k lines patchset to PG 16.</div><br/><div id="36743559" class="c"><input type="checkbox" id="c-36743559" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#36741409">root</a><span>|</span><a href="#36742001">parent</a><span>|</span><a href="#36742970">next</a><span>|</span><label class="collapse" for="c-36743559">[-]</label><label class="expand" for="c-36743559">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Please, check this. <a href="https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-pluggable-strorage">https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-pluggable-strorage</a><p>So 60% of code committed to PG 16 already?</div><br/><div id="36744607" class="c"><input type="checkbox" id="c-36744607" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#36741409">root</a><span>|</span><a href="#36743559">parent</a><span>|</span><a href="#36742970">next</a><span>|</span><label class="collapse" for="c-36744607">[-]</label><label class="expand" for="c-36744607">[1 more]</label></div><br/><div class="children"><div class="content">60% of the code needed to run it as a normal outside extension.</div><br/></div></div></div></div><div id="36742970" class="c"><input type="checkbox" id="c-36742970" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#36741409">root</a><span>|</span><a href="#36742001">parent</a><span>|</span><a href="#36743559">prev</a><span>|</span><a href="#36741419">next</a><span>|</span><label class="collapse" for="c-36742970">[-]</label><label class="expand" for="c-36742970">[1 more]</label></div><br/><div class="children"><div class="content">Awesome.  Thanks heaps for your efforts on this!<p>Hopefully it all gets through the hurdles eventually, becoming a new storage engine shipped by default in PG.  Maybe even becoming the new default. :)</div><br/></div></div></div></div></div></div><div id="36741419" class="c"><input type="checkbox" id="c-36741419" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36741409">prev</a><span>|</span><a href="#36741466">next</a><span>|</span><label class="collapse" for="c-36741419">[-]</label><label class="expand" for="c-36741419">[7 more]</label></div><br/><div class="children"><div class="content">I read object relational? Can someone enlighten me? Entity relational fine but what makes it object relational? Has someone flipped on the buzzword in the years I did not pay attention</div><br/><div id="36741450" class="c"><input type="checkbox" id="c-36741450" checked=""/><div class="controls bullet"><span class="by">feike</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36741455">next</a><span>|</span><label class="collapse" for="c-36741450">[-]</label><label class="expand" for="c-36741450">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL has used this term for decades!<p>The oldest I can find is from 1998 (PostgreSQL 6.3), but it was probably in use even before.<p>&gt; Postgres offers substantial additional power by incorporating the following four additional basic concepts in such a way that users can easily extend the system:<p>classes
inheritance
types
functions<p>Other features provide additional power and flexibility:<p>constraints
triggers
rules
transaction integrity<p>These features put Postgres into the category of databases referred to as object-relational<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;6.3&#x2F;c0101.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;6.3&#x2F;c0101.htm</a></div><br/></div></div><div id="36741455" class="c"><input type="checkbox" id="c-36741455" checked=""/><div class="controls bullet"><span class="by">grzm</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36741450">prev</a><span>|</span><a href="#36742035">next</a><span>|</span><label class="collapse" for="c-36741455">[-]</label><label class="expand" for="c-36741455">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been object relational (and described as such) going <i>way</i> back. I think the most visible (if infrequently used) object-oriented feature that it has is inheritance: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;tutorial-inheritance.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;tutorial-inheritance...</a></div><br/></div></div><div id="36742035" class="c"><input type="checkbox" id="c-36742035" checked=""/><div class="controls bullet"><span class="by">stubish</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36741455">prev</a><span>|</span><a href="#36741431">next</a><span>|</span><label class="collapse" for="c-36742035">[-]</label><label class="expand" for="c-36742035">[1 more]</label></div><br/><div class="children"><div class="content">Object Databases were once a thing, and PostgreSQL PostgreSQL used the term Object Relational to indicate it could be used as both an Object Database (it supports table inheritance) and&#x2F;or a Relational Database. Not that you should ever use the feature, being a historical artifact full of historical gotchas and your clever design becomes a maintenance burden.</div><br/></div></div><div id="36741431" class="c"><input type="checkbox" id="c-36741431" checked=""/><div class="controls bullet"><span class="by">zetalyrae</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36742035">prev</a><span>|</span><a href="#36741459">next</a><span>|</span><label class="collapse" for="c-36741431">[-]</label><label class="expand" for="c-36741431">[1 more]</label></div><br/><div class="children"><div class="content">I looked this up the other day because I was similarly surprised, I think it refers to Postgres&#x27; ability to do table inheritance: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;tutorial-inheritance.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;tutorial-inheritance...</a></div><br/></div></div><div id="36741459" class="c"><input type="checkbox" id="c-36741459" checked=""/><div class="controls bullet"><span class="by">nieve</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36741431">prev</a><span>|</span><a href="#36741453">next</a><span>|</span><label class="collapse" for="c-36741459">[-]</label><label class="expand" for="c-36741459">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because PostgreSQL has inheritance and has almost certainly used the term object relational since before you heard of it.</div><br/></div></div><div id="36741453" class="c"><input type="checkbox" id="c-36741453" checked=""/><div class="controls bullet"><span class="by">brazzy</span><span>|</span><a href="#36741419">parent</a><span>|</span><a href="#36741459">prev</a><span>|</span><a href="#36741466">next</a><span>|</span><label class="collapse" for="c-36741453">[-]</label><label class="expand" for="c-36741453">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;45865961&#x2F;what-does-postgresql-to-be-ordbms-mean" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;45865961&#x2F;what-does-postg...</a></div><br/></div></div></div></div><div id="36741466" class="c"><input type="checkbox" id="c-36741466" checked=""/><div class="controls bullet"><span class="by">glogla</span><span>|</span><a href="#36741419">prev</a><span>|</span><a href="#36741355">next</a><span>|</span><label class="collapse" for="c-36741466">[-]</label><label class="expand" for="c-36741466">[9 more]</label></div><br/><div class="children"><div class="content">I with people would stop with the &quot;Uber migrated from Postgres to MySQL&quot; thing. Uber migrated from Postgres used as relational database to something that is basically their own non-relational database using MySQL as distributed key-value store. It is not really situation applicable to most users of Postgres.<p>Anyway, this design of MVCC which moves older data into undo logs &#x2F; segments is used by Oracle DB, so it definitely works. The common challenge with it is that reading older versions of data is slower, because you have to look it up in a log, and sometimes the data is removed from the log before your transactions finishes, getting the dreaded &quot;Snapshot Too Old&quot; error.<p>E: I don&#x27;t see in the article when rows get evicted from the undo logs. If when they are no longer needed, I&#x27;m not sure where the improvement comes from because it should be similar amount of bookkeeping? If it&#x27;s a circular buffer that can ran out of space like Oracle does it that would mean under high write load long-running transactions starts to fail which is pretty unpleasant.</div><br/><div id="36741885" class="c"><input type="checkbox" id="c-36741885" checked=""/><div class="controls bullet"><span class="by">akorotkov</span><span>|</span><a href="#36741466">parent</a><span>|</span><a href="#36741499">next</a><span>|</span><label class="collapse" for="c-36741885">[-]</label><label class="expand" for="c-36741885">[1 more]</label></div><br/><div class="children"><div class="content">&gt; E: I don&#x27;t see in the article when rows get evicted from the undo logs.<p>The undo records are truncated once they aren&#x27;t needed for any transaction.<p>&gt; If when they are no longer needed, I&#x27;m not sure where the improvement comes from because it should be similar amount of bookkeeping?<p>It depends on what exactly is &quot;bookkeeping&quot;.
If we consider amount of work, then improvement comes because old undo records can be just bulk deleted very cheap (corresponding files get unliked). No vacuum scan is needed.
If we consider amount of space occupied, then indeed the same amount of versions take the same amount of space. But saving old versions of rows in the separate storage can save their primary storage from long-term degradation. Also, note that OrioleDB implements automatic merging of sparse pages.<p>&gt; If it&#x27;s a circular buffer that can ran out of space like Oracle does it that would mean under high write load long-running transactions starts to fail which is pretty unpleasant.<p>OrioleDB implements in-memory circular buffer for undo logs. Once circular buffer can&#x27;t handle all the undo records, least recent records are evicted to the storage. Currently, we don&#x27;t place limitation on the site of undo logs. Undo records are kept  while any transaction can need them. So, no &quot;Snapshot Too Old&quot; errors. However, we can consider implementing this Oracle-like error as an option, which allows to limit the undo size.<p>Also, please, check the architecture documentation of github (if didn&#x27;t already).
<a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb&#x2F;blob&#x2F;main&#x2F;doc&#x2F;arch.md">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb&#x2F;blob&#x2F;main&#x2F;doc&#x2F;arch.md</a></div><br/></div></div><div id="36741499" class="c"><input type="checkbox" id="c-36741499" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36741466">parent</a><span>|</span><a href="#36741885">prev</a><span>|</span><a href="#36741355">next</a><span>|</span><label class="collapse" for="c-36741499">[-]</label><label class="expand" for="c-36741499">[7 more]</label></div><br/><div class="children"><div class="content">SQL Server avoids vacuum as well, it might be this way, I can&#x27;t recall.<p>And of course MySQL avoids vacuum by giving a giant middle to concurrency considerations.</div><br/><div id="36741882" class="c"><input type="checkbox" id="c-36741882" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741499">parent</a><span>|</span><a href="#36741531">next</a><span>|</span><label class="collapse" for="c-36741882">[-]</label><label class="expand" for="c-36741882">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because they don&#x27;t store non-current versions of rows in the table itself, so why would they need a vacuum? MySQL does need to vacuum indexes, however.</div><br/></div></div><div id="36741531" class="c"><input type="checkbox" id="c-36741531" checked=""/><div class="controls bullet"><span class="by">glogla</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741499">parent</a><span>|</span><a href="#36741882">prev</a><span>|</span><a href="#36741355">next</a><span>|</span><label class="collapse" for="c-36741531">[-]</label><label class="expand" for="c-36741531">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure SQL Server and MySQL use locking instead of MultiVersion Concurrency Control so they don&#x27;t keep more copies of data around. No vacuum needed but there&#x27;s a possibility of things blocking.<p>But I might be out of date.</div><br/><div id="36741646" class="c"><input type="checkbox" id="c-36741646" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741531">parent</a><span>|</span><a href="#36741639">next</a><span>|</span><label class="collapse" for="c-36741646">[-]</label><label class="expand" for="c-36741646">[1 more]</label></div><br/><div class="children"><div class="content">InnoDB (MySQL&#x27;s default storage engine) implements MVCC using undo logging and background purge threads. It scales to highly concurrent OLTP workloads quite well. It doesn&#x27;t work well with OLAP workloads &#x2F; long-running transactions though. The oldest active transaction will block purging of anything newer than that transaction&#x27;s snapshot.</div><br/></div></div><div id="36741639" class="c"><input type="checkbox" id="c-36741639" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741531">parent</a><span>|</span><a href="#36741646">prev</a><span>|</span><a href="#36741717">next</a><span>|</span><label class="collapse" for="c-36741639">[-]</label><label class="expand" for="c-36741639">[1 more]</label></div><br/><div class="children"><div class="content">Yes, MySQL has read locks.<p>But I don&#x27;t believe SQL Server does.</div><br/></div></div><div id="36741717" class="c"><input type="checkbox" id="c-36741717" checked=""/><div class="controls bullet"><span class="by">arbitrix</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741531">parent</a><span>|</span><a href="#36741639">prev</a><span>|</span><a href="#36741355">next</a><span>|</span><label class="collapse" for="c-36741717">[-]</label><label class="expand" for="c-36741717">[2 more]</label></div><br/><div class="children"><div class="content">SQL Server has had MVCC since 2005.</div><br/><div id="36742446" class="c"><input type="checkbox" id="c-36742446" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#36741466">root</a><span>|</span><a href="#36741717">parent</a><span>|</span><a href="#36741355">next</a><span>|</span><label class="collapse" for="c-36742446">[-]</label><label class="expand" for="c-36742446">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but doesn&#x27;t it require opt-in to enable snapshopt isolation? Most T-SQL devs will probably default to locking (TABLLOCK, etc) becuase that&#x27;s what the bulk of google search results for &quot;how do I fix my broken query?&quot; tell people to do: it&#x27;s only very, very rarely do I see a stackoverflow or dba.se answer that mentions MVCC-related topics.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36741355" class="c"><input type="checkbox" id="c-36741355" checked=""/><div class="controls bullet"><span class="by">pella</span><span>|</span><a href="#36741466">prev</a><span>|</span><a href="#36741373">next</a><span>|</span><label class="collapse" for="c-36741355">[-]</label><label class="expand" for="c-36741355">[1 more]</label></div><br/><div class="children"><div class="content">simple OrioleDB docker build tutorial :<p><a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb&#x2F;blob&#x2F;main&#x2F;doc&#x2F;docker_usage.md">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb&#x2F;blob&#x2F;main&#x2F;doc&#x2F;docker_us...</a></div><br/></div></div><div id="36741833" class="c"><input type="checkbox" id="c-36741833" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#36741373">prev</a><span>|</span><a href="#36742143">next</a><span>|</span><label class="collapse" for="c-36741833">[-]</label><label class="expand" for="c-36741833">[7 more]</label></div><br/><div class="children"><div class="content">Experimental format to help readability of a long rant:<p>1.<p>According to the OP, there&#x27;s a &quot;terrifying tale of VACUUM in PostgreSQL,&quot; dating back to &quot;a historical artifact that traces its roots back to the Berkeley Postgres project.&quot; (1986?)<p>2.<p>Maybe the whole idea of &quot;use X, it has been battle-tested for [TIME], is robust, all the bugs have been and keep being fixed,&quot; etc., should not really be that attractive or realistic for at least a large subset of projects.<p>3.<p>In the case of Postgres, on top of piles of &quot;historic code&quot; and cruft, there&#x27;s the fact that each user of Postgres installs and runs a huge software artifact with hundreds or even thousands of features and dependencies, of which every particular user may only use a tiny subset.<p>4.<p>In Kleppmann&#x27;s DDOA [1], after explaining why the declarative SQL language is &quot;better,&quot; he writes: &quot;in databases, declarative query languages like SQL turned out to be much better than imperative query APIs.&quot; I find this footnote to the paragraph a bit ironic: &quot;IMS and CODASYL both used imperative query APIs. Applications typically used COBOL code to iterate over records in the database, one record at a time.&quot; So, SQL was better than CODASYL and COBOL in a number of ways... big surprise?<p>Postgres&#x27; own PL&#x2F;pgSQL [2] is a language that (I imagine) most people would rather NOT use: hence a bunch of alternatives, including PL&#x2F;v8, on its own a huge mass of additional complexity. SQL is definitely &quot;COBOLESQUE&quot; itself.<p>5.<p>Could we come up with something more minimal than SQL and looking less like COBOL? (Hopefully also getting rid of ORMs in the process). Also, I have found inspiring to see some people creating databases for themselves. Perhaps not a bad idea for small applications? For instance, I found BuntDB [3], which the developer seems to be using to run his own business [4]. Also, HYTRADBOI? :-) [5].<p>6.<p>A usual objection to use anything other than a stablished relational DB is &quot;creating a database is too difficult for the average programmer.&quot; How about debugging PostgreSQL issues, developing new storage engines for it, or even building expertise on how to set up the instances properly and keep it alive and performant? Is that easier?<p>I personally feel more capable of implementing a small, well-tested, problem-specific, small implementation of a B-Tree than learning how to develop Postgres extensions, become an expert in its configuration and internals, or debug its many issues.<p>Another common opinion is &quot;SQL is easy to use for non-programmers.&quot; But every person that knows SQL had to learn it somehow. I&#x27;m 100% confident that anyone able to learn SQL should be able to learn a simple, domain-specific, programming language designed for querying DBs. And how many of these people that are not able to program imperatively would be able to read a SQL EXPLAIN output and fix deficient queries? If they can, that supports even more the idea that they should be able to learn something different than SQL.<p>----<p>1: <a href="https:&#x2F;&#x2F;dataintensive.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dataintensive.net&#x2F;</a><p>2: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;7.3&#x2F;plpgsql-examples.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;7.3&#x2F;plpgsql-examples.html</a><p>3: <a href="https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;buntdb">https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;buntdb</a><p>4: <a href="https:&#x2F;&#x2F;tile38.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tile38.com&#x2F;</a><p>5: <a href="https:&#x2F;&#x2F;www.hytradboi.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.hytradboi.com&#x2F;</a></div><br/><div id="36743375" class="c"><input type="checkbox" id="c-36743375" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#36741833">parent</a><span>|</span><a href="#36742650">next</a><span>|</span><label class="collapse" for="c-36743375">[-]</label><label class="expand" for="c-36743375">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I personally feel more capable of implementing a small, well-tested, problem-specific, small implementation of a B-Tree than learning how to develop Postgres extensions, become an expert in its configuration and internals, or debug its many issues.<p>It gets harder as you delve into high concurrency and ensuring ACID: if you are using an established database, these are simply problems you don&#x27;t have to deal with (or rather more truthfully, there are known ways to deal with them like issuing an &quot;UPDATE x=x+1&quot; instead of fetching x and then setting it to x+1).<p>Still, writing an application expecting the datastore to ensure consistency is one thing, and ensuring that consistency are different problems requiring a different mindset (you are thinking of hard problems of your business logic, but you also have to think of hard problems common to db engines at the same time?).<p>&gt; But every person that knows SQL had to learn it somehow. I&#x27;m 100% confident that anyone able to learn SQL should be able to learn a simple, domain-specific, programming language designed for querying DBs.<p>The benefit of languages as ubiquitous as SQL is that once you need something that you did not think of, SQL already enables it.  But plenty of non-relational databases provide their own non-SQL APIs already (ElasticSearch, Redis, MongoDB, DynamoDB...), and as you suggest, developers cope with them just fine.<p>However, people used to expressiveness of SQL (even if we all know it&#x27;s imperfect), always miss what they can achieve with a single query moving performance (and some correctness) considerations to the database.  The idea is as old as programming: transfer responsibilities for accessing data performantly to whatever is managing that data, even if we know that there are always cases where it&#x27;s an uphill battle.<p>It&#x27;s that combination of good-enough performance, good-enough expressiveness, impressive consistency and correctness, and relational databases (and SQL) are a great choice for most applications today.</div><br/><div id="36743499" class="c"><input type="checkbox" id="c-36743499" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#36741833">root</a><span>|</span><a href="#36743375">parent</a><span>|</span><a href="#36742650">next</a><span>|</span><label class="collapse" for="c-36743499">[-]</label><label class="expand" for="c-36743499">[2 more]</label></div><br/><div class="children"><div class="content">The ACID and concurrency aspects are definitely harder to deal with, but it also depends on what you need. I wonder if many people would find a nice perf increase by running a simpler, well designed db that runs in a single process of a beefy modern computer in a compiled language. In any case, writing any multithreading or multiprocess code is hard, and I doubt a multi-million LoC codebase makes it any easier.<p>&gt; you are thinking of hard problems of your business logic, but you also have to think of hard problems common to db engines at the same time?<p>YES! everyone is complaining these days about slow software in our beefy machines. I guess the core of my rant is that it feels like all of us programmers should start caring a lot more about data organization, code size, minimizing dependencies, data oriented design and &quot;mechanical sympathy&quot;. Advances in languages, tooling and accessibility to information should demystify the how-to of managing our own application data ourselves.</div><br/><div id="36743910" class="c"><input type="checkbox" id="c-36743910" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#36741833">root</a><span>|</span><a href="#36743499">parent</a><span>|</span><a href="#36742650">next</a><span>|</span><label class="collapse" for="c-36743910">[-]</label><label class="expand" for="c-36743910">[1 more]</label></div><br/><div class="children"><div class="content">I symphatise with your last point! And I agree that great developers should understand how to build a sufficiently performant database for their app, even if they won&#x27;t build one.<p>However, I think our applications are not slow due to database access, but one too many layers of indirection otherwise: eg even ORMs usually introduce a huge performance and complexity cost.<p>Just like we are trying to come up with better and less error prone concurrency models in code (async&#x2F;await, coroutines...), I get that you are trying to come up with better tooling support for data access, and we should.<p>But we also need to be aware that some people simply want to solve a problem more efficiently, but not most efficiently (look at most ML code and you can barf at it — yet it still makes a huge progress in one area they care about).</div><br/></div></div></div></div></div></div><div id="36742650" class="c"><input type="checkbox" id="c-36742650" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#36741833">parent</a><span>|</span><a href="#36743375">prev</a><span>|</span><a href="#36742143">next</a><span>|</span><label class="collapse" for="c-36742650">[-]</label><label class="expand" for="c-36742650">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A usual objection to use anything other than a stablished relational DB is &quot;creating a database is too difficult for the average programmer.&quot; How about debugging PostgreSQL issues, developing new storage engines for it<p>that&#x27;s exactly what OP company is doing: they are building storage engine for postgres.</div><br/><div id="36743391" class="c"><input type="checkbox" id="c-36743391" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#36741833">root</a><span>|</span><a href="#36742650">parent</a><span>|</span><a href="#36742143">next</a><span>|</span><label class="collapse" for="c-36743391">[-]</label><label class="expand" for="c-36743391">[2 more]</label></div><br/><div class="children"><div class="content">I doubt this initiative is gonna make Postgres easier to use, smaller in terms of dependencies, simplicity of its codebase or resource usage.</div><br/><div id="36743989" class="c"><input type="checkbox" id="c-36743989" checked=""/><div class="controls bullet"><span class="by">cuu508</span><span>|</span><a href="#36741833">root</a><span>|</span><a href="#36743391">parent</a><span>|</span><a href="#36742143">next</a><span>|</span><label class="collapse" for="c-36743989">[-]</label><label class="expand" for="c-36743989">[1 more]</label></div><br/><div class="children"><div class="content">Regarding resource usage, the benchmarks in the article show reduced IO usage. Are you doubting the validity of those benchmarks?</div><br/></div></div></div></div></div></div></div></div><div id="36742143" class="c"><input type="checkbox" id="c-36742143" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#36741833">prev</a><span>|</span><label class="collapse" for="c-36742143">[-]</label><label class="expand" for="c-36742143">[3 more]</label></div><br/><div class="children"><div class="content">Oh I see it’s not<p>Oracle db<p>It’s<p>Oriole db<p>Totally different<p>Oracle<p>Oriole<p><i>cough</i></div><br/><div id="36742503" class="c"><input type="checkbox" id="c-36742503" checked=""/><div class="controls bullet"><span class="by">resist_futility</span><span>|</span><a href="#36742143">parent</a><span>|</span><a href="#36742496">next</a><span>|</span><label class="collapse" for="c-36742503">[-]</label><label class="expand" for="c-36742503">[1 more]</label></div><br/><div class="children"><div class="content">But also not to be confused with OLEDB</div><br/></div></div></div></div></div></div></div></div></div></body></html>