<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694422870094" as="style"/><link rel="stylesheet" href="styles.css?v=1694422870094"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/eduard-permyakov/peredvizhnikov-engine">Peredvizhnikov Engine: Lock-free game engine written in C++20</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>gjvc</span> | <span>173 comments</span></div><br/><div><div id="37457162" class="c"><input type="checkbox" id="c-37457162" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#37464555">next</a><span>|</span><label class="collapse" for="c-37457162">[-]</label><label class="expand" for="c-37457162">[53 more]</label></div><br/><div class="children"><div class="content">I have an Actor framework which uses a vanilla std::deque for method pointers, and to add messages to the queue, the locking technique is a Benaphore (the original Futex, which uses an atomic and a locking primitive, with the twist that my locking primitive is a combo of spinlock&#x2F;mutex based on retry count).  Nothing special. 
 Benchmarks show that very rarely does the message push function block, and the chance of an OS context switch is also very low, so even though occasionally we get a locked thread swapping out, it is so infrequent that it doesn&#x27;t justify the lock-free algorithm cost.<p>In a nutshell, non lock free queues are much faster than lock free queues, however you must be prepared to accept the very infrequent longer delay due to a context switch (where the lock is not available to anyone).  My benchmarks show that the price is acceptable since so much more performance is available with non lock free queues.  10 million messages per second per work thread can be queued on modern hardware.</div><br/><div id="37460511" class="c"><input type="checkbox" id="c-37460511" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37457416">next</a><span>|</span><label class="collapse" for="c-37460511">[-]</label><label class="expand" for="c-37460511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the original Futex<p>The &quot;Benaphore&quot; was a pretty old idea, but the Futex isn&#x27;t just &quot;Oh it&#x27;s a Benaphore but Linux&quot; the <i>essential</i> trick is that you don&#x27;t actually need a kernel object - your &quot;locking primitive&quot; at all, and that idea is where this goes from &quot;Yeah, everybody knows that&quot; to OK, our OS should add this feature ASAP.<p>Instead of an OS synchronisation object which is used to handle conflicts, with the futex design the OS carries a list of address -&gt; thread mappings. If a thread T is asleep on a futex at address X, the address X goes in the list pointing to thread T. When the OS is asked to wake the X futex, it walks the list and wakes T.<p>The give away is the limits. For something like Benaphores you&#x27;re constrained, these are a costly OS wide resource, I think BeOS only allowed 65536 per machine or something. But a Futex is just memory, so there&#x27;s no reason to have any limit at all.</div><br/></div></div><div id="37457416" class="c"><input type="checkbox" id="c-37457416" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37460511">prev</a><span>|</span><a href="#37462116">next</a><span>|</span><label class="collapse" for="c-37457416">[-]</label><label class="expand" for="c-37457416">[2 more]</label></div><br/><div class="children"><div class="content">With a post like this, however interesting, you really should link the code. Not only will it prove your claim, but others like me will find the idea intriguing and immediately want to see how it&#x27;s done.</div><br/><div id="37457934" class="c"><input type="checkbox" id="c-37457934" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457416">parent</a><span>|</span><a href="#37462116">next</a><span>|</span><label class="collapse" for="c-37457934">[-]</label><label class="expand" for="c-37457934">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;smallstepforman&#x2F;Medo&#x2F;tree&#x2F;main&#x2F;Actor">https:&#x2F;&#x2F;github.com&#x2F;smallstepforman&#x2F;Medo&#x2F;tree&#x2F;main&#x2F;Actor</a></div><br/></div></div></div></div><div id="37462116" class="c"><input type="checkbox" id="c-37462116" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37457416">prev</a><span>|</span><a href="#37458748">next</a><span>|</span><label class="collapse" for="c-37462116">[-]</label><label class="expand" for="c-37462116">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on the specifics.  If there&#x27;s a lot of contention then performance will drop off a cliff.  Even atomic instructions can become a bottleneck ( <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;2538070" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;2538070</a> ).<p>I think what you&#x27;re observing, i.e. that in many cases just use a lock and don&#x27;t worry about it (or your variation) is true.  But there are certain applications&#x2F;situations where you can do better.  Having a consumer pull out everything from the queue with one locking operation and being careful with how you signal the consumer from the producer(s), assuming there&#x27;s a signal, can also make the queue more efficient&#x2F;have higher throughput (e.g. you shouldn&#x27;t signal for every item you put in the queue, only when it becomes non-empty).</div><br/></div></div><div id="37458748" class="c"><input type="checkbox" id="c-37458748" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37462116">prev</a><span>|</span><a href="#37457568">next</a><span>|</span><label class="collapse" for="c-37458748">[-]</label><label class="expand" for="c-37458748">[5 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t lock free data structures more about reducing the impact of contention than throughput under low contention?</div><br/><div id="37460310" class="c"><input type="checkbox" id="c-37460310" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458748">parent</a><span>|</span><a href="#37460635">next</a><span>|</span><label class="collapse" for="c-37460310">[-]</label><label class="expand" for="c-37460310">[2 more]</label></div><br/><div class="children"><div class="content">Lock free is kind of an overloaded term that can mean a variety of things depending on what the user is thinking.  Usually the goal is being able to make forward progress even if one thread is context switched out by the OS scheduler, which might be called wait-free or non-blocking.  Using mutexes (unless you can prevent OS scheduling, interrupts, etc) makes this property impossible to achieve.  In general, MPSC queues are super fast and there&#x27;s no real reason to prefer a locked queue.</div><br/><div id="37463505" class="c"><input type="checkbox" id="c-37463505" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37460310">parent</a><span>|</span><a href="#37460635">next</a><span>|</span><label class="collapse" for="c-37463505">[-]</label><label class="expand" for="c-37463505">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In general, MPSC queues are super fast and there&#x27;s no real reason to prefer a locked queue.</i><p>There&#x27;s one significant advantage that a locked vector or deque has over MPSC&#x2F;MPMC queues: the consumers can dequeue all messages in a single operation by locking the vector, swapping it with an empty vector (typically, that&#x27;s just 3 words), and locking it again. That&#x27;s such a simple operation that it will typically be as fast or even faster than a single pop-one-message operation in an MPSC&#x2F;MPMP. Similarly, if the vector is empty, a producer can push any number of messages in a single, constant-time operation.</div><br/></div></div></div></div><div id="37460635" class="c"><input type="checkbox" id="c-37460635" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458748">parent</a><span>|</span><a href="#37460310">prev</a><span>|</span><a href="#37460264">next</a><span>|</span><label class="collapse" for="c-37460635">[-]</label><label class="expand" for="c-37460635">[1 more]</label></div><br/><div class="children"><div class="content">Under a lock free algorithm, we promise that across our entire system, eventually some progress is made. I can&#x27;t necessarily point at any specific thread of execution and say &quot;This thread makes progress&quot; but I can say that forward progress is made for the system as a whole.<p>Under a <i>wait free</i> algorithm, we promise that every individual thread eventually makes progress.<p>Suppose I have one really dumb thread which just goes to sleep for 10 seconds in a loop, as well as other threads which do some actual work. If we&#x27;re a lock free algorithm, it is OK if the 10-second-sleep thread is always chosen to make progress, its &quot;progress&quot; consists of sleeping for 10 seconds, too bad, try again next time.<p>With a wait free algorithm, the threads which actually do useful work will also make at least some progress, eventually despite the 10 second sleeper.<p>Generally we can&#x27;t say for sure that we e.g. &quot;reduce impact of contention&quot; only that we definitely make <i>some</i> forward progress, on <i>at least one thread</i> eventually.</div><br/></div></div><div id="37460264" class="c"><input type="checkbox" id="c-37460264" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458748">parent</a><span>|</span><a href="#37460635">prev</a><span>|</span><a href="#37457568">next</a><span>|</span><label class="collapse" for="c-37460264">[-]</label><label class="expand" for="c-37460264">[1 more]</label></div><br/><div class="children"><div class="content">Depends what you mean by “the impact of contention”. It is possible, if you build a lock-free system, to end up with threads that keep churning and never make forward progress.</div><br/></div></div></div></div><div id="37457568" class="c"><input type="checkbox" id="c-37457568" checked=""/><div class="controls bullet"><span class="by">EliRivers</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37458748">prev</a><span>|</span><a href="#37458642">next</a><span>|</span><label class="collapse" for="c-37457568">[-]</label><label class="expand" for="c-37457568">[32 more]</label></div><br/><div class="children"><div class="content"><i>My benchmarks show that the price is acceptable</i><p>Well, except to people who have a hard requirement that there never be this unpredictable, infrequent longer delay you mention.</div><br/><div id="37458003" class="c"><input type="checkbox" id="c-37458003" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457568">parent</a><span>|</span><a href="#37458551">next</a><span>|</span><label class="collapse" for="c-37458003">[-]</label><label class="expand" for="c-37458003">[29 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably fair to claim that zero* game developers have this hard requirement.  At best they have a <i>strong desire</i> which might be partially backed up by benchmarks and squinting hard enough.<p>*: ignoring deliberately esoteric cases, like Doom on a hard real-time system.</div><br/><div id="37458126" class="c"><input type="checkbox" id="c-37458126" checked=""/><div class="controls bullet"><span class="by">EarthLaunch</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458003">parent</a><span>|</span><a href="#37458551">next</a><span>|</span><label class="collapse" for="c-37458126">[-]</label><label class="expand" for="c-37458126">[28 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a requirement for any game that needs a reliable frame rate.  Unpredictable delays during frame rendering cause jank.<p>(This is not to say the OP has any such issues in its context.)</div><br/><div id="37458251" class="c"><input type="checkbox" id="c-37458251" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458126">parent</a><span>|</span><a href="#37459455">next</a><span>|</span><label class="collapse" for="c-37458251">[-]</label><label class="expand" for="c-37458251">[23 more]</label></div><br/><div class="children"><div class="content">This is usually called &quot;soft realtime&quot; -- you want it to be fast but it&#x27;s not <i>wrong</i> if it misses deadlines. It doesn&#x27;t violate correctness of the system to miss a deadline. In a &quot;hard realtime&quot; system, it is a fatal error if the system misses a deadline because correctness is violated. I presume this difference is what OP is talking about. Games are never hard realtime; missing frame deadlines reduces user experience but it doesn&#x27;t break the game. Hard realtime is things like industrial motion control, automotive and aviation electronics, pacemakers, etc.</div><br/><div id="37459380" class="c"><input type="checkbox" id="c-37459380" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458251">parent</a><span>|</span><a href="#37463291">prev</a><span>|</span><a href="#37458294">next</a><span>|</span><label class="collapse" for="c-37459380">[-]</label><label class="expand" for="c-37459380">[2 more]</label></div><br/><div class="children"><div class="content">I would say that an exception could be made for VR games where any frame rate &#x27;jank&#x27; causes an uncomfortable experience and can lead to increased simulator sickness.</div><br/><div id="37459780" class="c"><input type="checkbox" id="c-37459780" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37459380">parent</a><span>|</span><a href="#37458294">next</a><span>|</span><label class="collapse" for="c-37459780">[-]</label><label class="expand" for="c-37459780">[1 more]</label></div><br/><div class="children"><div class="content">VR games almost all use Unity and Unreal. They drop frames left and right. VR platforms use extremely complex time warp algorithms to hide the jank.<p>So you&#x27;re not wrong. VR games are <i>much</i> more susceptible to dropped frames causing problems. But it both happens and is hidden remarkably well.</div><br/></div></div></div></div><div id="37458294" class="c"><input type="checkbox" id="c-37458294" checked=""/><div class="controls bullet"><span class="by">jefftk</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458251">parent</a><span>|</span><a href="#37459380">prev</a><span>|</span><a href="#37458500">next</a><span>|</span><label class="collapse" for="c-37458294">[-]</label><label class="expand" for="c-37458294">[6 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Games are never hard realtime</i><p>Depends how high your standards are! One of the things that makes playing old games on the original hardware really satisfying is how consistent they are.</div><br/><div id="37458471" class="c"><input type="checkbox" id="c-37458471" checked=""/><div class="controls bullet"><span class="by">brokencode</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458294">parent</a><span>|</span><a href="#37458500">next</a><span>|</span><label class="collapse" for="c-37458471">[-]</label><label class="expand" for="c-37458471">[5 more]</label></div><br/><div class="children"><div class="content">Those old games could be so consistent because the software and hardware were both so incredibly simple compared to today.<p>Today, a PC game has to work on a large range of hardware that has come out over the past 5+ years. And there are GPU features that are only available on certain cards, like hardware ray tracing and things like DLSS and FSR for upscaling.<p>And the game engines are incredibly more complex today to handle modern expectations, with dynamic lighting and shadows, huge maps, etc.<p>It doesn’t matter what your standards are. Hard realtime just isn’t realistic or even possible any more, except maybe in a game that would be considered truly primitive by today’s standards.</div><br/><div id="37459146" class="c"><input type="checkbox" id="c-37459146" checked=""/><div class="controls bullet"><span class="by">EliRivers</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458471">parent</a><span>|</span><a href="#37458500">next</a><span>|</span><label class="collapse" for="c-37459146">[-]</label><label class="expand" for="c-37459146">[4 more]</label></div><br/><div class="children"><div class="content">I am sure I have memories of how hard it was to support a range of hardware when I had to write specifically for each piece. When I had to write separately for a Soundblaster card and an Adlib and a Disney SoundSource and a Roland and a Gravis.<p>And that was just the sound cards. Writing for different hardware became so much easier when OpenGl and DirectX came into being. Suddenly I just had to write to these APIs.<p>I think I&#x27;m disagreeing with you. Supporting multiple hardware configuration way back when was so much harder than doing it today.</div><br/><div id="37461129" class="c"><input type="checkbox" id="c-37461129" checked=""/><div class="controls bullet"><span class="by">gamacodre</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37459146">parent</a><span>|</span><a href="#37459612">next</a><span>|</span><label class="collapse" for="c-37461129">[-]</label><label class="expand" for="c-37461129">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, and Tandy graphics were different from EGA or VGA, just enough that you needed to write different display code for them. And you had to get the user to tell you which ports&#x2F;IRQ numbers half of their hardware was configured at.<p>We have <i>way</i> better hardware abstractions in the OS today, which I would agree makes modern development easier overall.</div><br/><div id="37464329" class="c"><input type="checkbox" id="c-37464329" checked=""/><div class="controls bullet"><span class="by">EliRivers</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37461129">parent</a><span>|</span><a href="#37459612">next</a><span>|</span><label class="collapse" for="c-37464329">[-]</label><label class="expand" for="c-37464329">[1 more]</label></div><br/><div class="children"><div class="content">Oh yes, that brings it all back. Having the user tell me the IRQ and also DMAs and... I&#x27;m sure there was more. Sometimes the user would end up having to open up the PC and reseat physical jumpers on hardware cards to have the cards use values that were both offered by the software and not clashing with anything else.<p>Different world. So much easier now.</div><br/></div></div></div></div><div id="37459612" class="c"><input type="checkbox" id="c-37459612" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37459146">parent</a><span>|</span><a href="#37461129">prev</a><span>|</span><a href="#37458500">next</a><span>|</span><label class="collapse" for="c-37459612">[-]</label><label class="expand" for="c-37459612">[1 more]</label></div><br/><div class="children"><div class="content">Oh gosh, the many different variants of SVGA that existed back in the days...<p>&#x2F;me shivers at the recollection</div><br/></div></div></div></div></div></div></div></div><div id="37458500" class="c"><input type="checkbox" id="c-37458500" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458251">parent</a><span>|</span><a href="#37458294">prev</a><span>|</span><a href="#37459455">next</a><span>|</span><label class="collapse" for="c-37458500">[-]</label><label class="expand" for="c-37458500">[13 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Games are never hard realtime; missing frame deadlines reduces user experience but it doesn&#x27;t break the game.</i><p>It depends on whether the game is multi-player and, if so, how it keeps the different players in sync with each other.<p>Games that rely on deterministic gameplay can desync (two players don&#x27;t see the same world state) and abort if one player&#x27;s simulation drops a frame while the other doesn&#x27;t.</div><br/><div id="37458532" class="c"><input type="checkbox" id="c-37458532" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37464230">next</a><span>|</span><label class="collapse" for="c-37458532">[-]</label><label class="expand" for="c-37458532">[1 more]</label></div><br/><div class="children"><div class="content">If you have multiplayer like this, you <i>absolutely</i> do not have a hard requirement on frame latency.<p>You don&#x27;t control network latency spikes. Latency <i>tolerance</i> is a hard requirement, or you will have constant problems and likely be unplayable.  Or custom networking and hardware stacks, which is deep into esoteric territory.</div><br/></div></div><div id="37464230" class="c"><input type="checkbox" id="c-37464230" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37458532">prev</a><span>|</span><a href="#37458536">next</a><span>|</span><label class="collapse" for="c-37464230">[-]</label><label class="expand" for="c-37464230">[1 more]</label></div><br/><div class="children"><div class="content">Since you can’t control latency of individual packets let alone that the hardware timing is identical this isn’t practical as a requirement.<p>Deterministic gameplay means after the same x frames with the same external inputs you will end up with the same state y on different hardware. Therefore we only need to make sure the clients stay within a reasonable margin. We can do this by waiting for all players inputs so moving at the slowest speed possible which is the lock-step method. Or we can change our measured frame time so each tick (which still ticks the same amount of sim time) is seen as faster or slower. That way we can track the other frames that other clients have completed from the input they send and slow or speed ourselves up to maintain a decent margin. This is the scheme used in rollback networking as the naïve implementation where this isn’t the case forces all rollbacks onto the faster machine.</div><br/></div></div><div id="37458536" class="c"><input type="checkbox" id="c-37458536" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37464230">prev</a><span>|</span><a href="#37458785">next</a><span>|</span><label class="collapse" for="c-37458536">[-]</label><label class="expand" for="c-37458536">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s still just a degradation of user experience and not a fatal fault. Indeed, support for running in desynced mode is written is because they know deadlines can be missed. In hard realtime, deadlines <i>can&#x27;t</i> be missed. There&#x27;s no recovery; it&#x27;s a critical fault and you have to halt or failover to a backup.</div><br/><div id="37458623" class="c"><input type="checkbox" id="c-37458623" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458536">parent</a><span>|</span><a href="#37458785">next</a><span>|</span><label class="collapse" for="c-37458623">[-]</label><label class="expand" for="c-37458623">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; That&#x27;s still just a degradation of user experience and not a fatal fault.</i><p>I don&#x27;t know how you&#x27;d describe a game spontaneously aborting not a &quot;fatal fault&quot;. Yes, it&#x27;s not turning off someone&#x27;s pacemaker, but within the scope of what a game is able to do, kicking the player back to the matchmaking screen in the middle of a game is about as fatal as it gets.</div><br/><div id="37458758" class="c"><input type="checkbox" id="c-37458758" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458623">parent</a><span>|</span><a href="#37458941">next</a><span>|</span><label class="collapse" for="c-37458758">[-]</label><label class="expand" for="c-37458758">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only going to happen if the client has such a massive network latency spike that the server thinks it&#x27;s disconnected. At least half a second, possibly more. You&#x27;re never going to get that kind of delay from synchronizing threads, unless the process totally deadlocks.<p>EDIT: Well, there is one situation where you might get delays like that: if the computer is so woefully inadequate to run the game that it consistently misses frame deadlines by several hundred milliseconds. Of course, in such a situation a different concurrent algorithm wouldn&#x27;t have solved anything anyway.</div><br/></div></div><div id="37458941" class="c"><input type="checkbox" id="c-37458941" checked=""/><div class="controls bullet"><span class="by">caconym_</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458623">parent</a><span>|</span><a href="#37458758">prev</a><span>|</span><a href="#37458781">next</a><span>|</span><label class="collapse" for="c-37458941">[-]</label><label class="expand" for="c-37458941">[1 more]</label></div><br/><div class="children"><div class="content">Literally any multiplayer game will have a &quot;fatal fault&quot; if its connection to the other players and&#x2F;or server is interrupted for long enough, but it seems disingenuous to describe a system tolerant of delays variable across several orders of magnitude, up to hundreds of milliseconds or even full seconds, as &quot;hard real time&quot; in the sense in which the term is generally understood.</div><br/></div></div><div id="37458781" class="c"><input type="checkbox" id="c-37458781" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458623">parent</a><span>|</span><a href="#37458941">prev</a><span>|</span><a href="#37458785">next</a><span>|</span><label class="collapse" for="c-37458781">[-]</label><label class="expand" for="c-37458781">[2 more]</label></div><br/><div class="children"><div class="content">What I don’t understand here is how missing a frame deadline in this situation (&lt;1&#x2F;60 of a second or 16ms) is intolerable when typical network latency varies constantly by much more than this. It seems to me that if the latency requirements were this strict you could only support LAN multiplayer.</div><br/><div id="37460378" class="c"><input type="checkbox" id="c-37460378" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458781">parent</a><span>|</span><a href="#37458785">next</a><span>|</span><label class="collapse" for="c-37460378">[-]</label><label class="expand" for="c-37460378">[1 more]</label></div><br/><div class="children"><div class="content">The only scenario I can imagine is some interactive game installation at Disney&#x2F;etc. But there&#x27;d still be no actual benefit over an architecture more lenient to timing deviations.</div><br/></div></div></div></div></div></div></div></div><div id="37458785" class="c"><input type="checkbox" id="c-37458785" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37458536">prev</a><span>|</span><a href="#37459349">next</a><span>|</span><label class="collapse" for="c-37458785">[-]</label><label class="expand" for="c-37458785">[1 more]</label></div><br/><div class="children"><div class="content">If you want to support players with ping over 16ms, there&#x27;s no way you&#x27;re gonna be synchronizing input from one frame to the output of the same frame for another player; there&#x27;ll necessarily be some latency hiding, at which point any freeze should be coverable via just treating it as a temporarily-high ping and thus temporarily more latency hiding.</div><br/></div></div><div id="37459349" class="c"><input type="checkbox" id="c-37459349" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37458785">prev</a><span>|</span><a href="#37464052">next</a><span>|</span><label class="collapse" for="c-37459349">[-]</label><label class="expand" for="c-37459349">[1 more]</label></div><br/><div class="children"><div class="content">Lockstep simulation can&#x27;t be hard tied to frame rate. Two computers will never have precisely the same frame timing -- even if they are running identical video modes, clocks are only accurate to within a tolerance and will diverge. The simulation has to allow for simulation ticks running independently from rendering frames.</div><br/></div></div><div id="37464052" class="c"><input type="checkbox" id="c-37464052" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37459349">prev</a><span>|</span><a href="#37459805">next</a><span>|</span><label class="collapse" for="c-37464052">[-]</label><label class="expand" for="c-37464052">[1 more]</label></div><br/><div class="children"><div class="content">If your program state tracking&#x2F;management is so tightly coupled to renderer that missing a frame can desync, then you have much bigger architectural problems anyway.<p>Network latency is a thing and your state management subsystem absolutely has to be fault tolerant.</div><br/></div></div><div id="37459805" class="c"><input type="checkbox" id="c-37459805" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458500">parent</a><span>|</span><a href="#37464052">prev</a><span>|</span><a href="#37459455">next</a><span>|</span><label class="collapse" for="c-37459805">[-]</label><label class="expand" for="c-37459805">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Games that rely on deterministic gameplay can desync (two players don&#x27;t see the same world state) and abort if one player&#x27;s simulation drops a frame while the other doesn&#x27;t.<p>Right. This is why lockstep deterministic (LSD) games are bound to the SLOWEST player&#x27;s machine.<p>No LSD game in existence crashes the game if one player&#x27;s machine falls behind. Instead you either pause the simulation for all players until they catch up or you slow down time itself.<p>Source: shipped RTS games that were lockstep deterministic.</div><br/></div></div></div></div></div></div><div id="37459455" class="c"><input type="checkbox" id="c-37459455" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37458126">parent</a><span>|</span><a href="#37458251">prev</a><span>|</span><a href="#37458231">next</a><span>|</span><label class="collapse" for="c-37459455">[-]</label><label class="expand" for="c-37459455">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Unpredictable delays during frame rendering cause jank&quot;<p>This is usually not serious inflicted and the presentation threads will be higher priority than the simulation in order to minimize visual &#x27;jank&#x27;<p>Lockfree game code ain&#x27;t fixing jank from the OS.</div><br/><div id="37462152" class="c"><input type="checkbox" id="c-37462152" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37459455">parent</a><span>|</span><a href="#37460079">prev</a><span>|</span><a href="#37458231">next</a><span>|</span><label class="collapse" for="c-37462152">[-]</label><label class="expand" for="c-37462152">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Lockfree game code ain&#x27;t fixing jank from the OS.<p>Latency is like a chain. Every link matters.<p>A game engine programmer can&#x27;t do a thing about the OS, but can still keep latency bounded in the code under their control.</div><br/></div></div></div></div></div></div></div></div><div id="37458551" class="c"><input type="checkbox" id="c-37458551" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457568">parent</a><span>|</span><a href="#37458003">prev</a><span>|</span><a href="#37459034">next</a><span>|</span><label class="collapse" for="c-37458551">[-]</label><label class="expand" for="c-37458551">[1 more]</label></div><br/><div class="children"><div class="content">These people are probably not game developers because frame dips are all over the place on console and PC gaming.</div><br/></div></div><div id="37459034" class="c"><input type="checkbox" id="c-37459034" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457568">parent</a><span>|</span><a href="#37458551">prev</a><span>|</span><a href="#37458642">next</a><span>|</span><label class="collapse" for="c-37459034">[-]</label><label class="expand" for="c-37459034">[1 more]</label></div><br/><div class="children"><div class="content">Well do we have a benchmark where the price of locking is unacceptable? I think the linked project is a fun theoretical exercise, but I personally don’t accept the assertion that locking is unacceptable without seeing evidence.</div><br/></div></div></div></div><div id="37458642" class="c"><input type="checkbox" id="c-37458642" checked=""/><div class="controls bullet"><span class="by">Phelinofist</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37457568">prev</a><span>|</span><a href="#37460088">next</a><span>|</span><label class="collapse" for="c-37458642">[-]</label><label class="expand" for="c-37458642">[1 more]</label></div><br/><div class="children"><div class="content">I agree, lock free is cool and all, but often times it is more complex and not every case justifies the increased complexity.</div><br/></div></div><div id="37460088" class="c"><input type="checkbox" id="c-37460088" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37458642">prev</a><span>|</span><a href="#37463744">next</a><span>|</span><label class="collapse" for="c-37460088">[-]</label><label class="expand" for="c-37460088">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing this.<p>Could you tell me if your 10 million figure includes batching or are they a loop that tries to enqueue as many items as possible?</div><br/></div></div><div id="37463744" class="c"><input type="checkbox" id="c-37463744" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37460088">prev</a><span>|</span><a href="#37460453">next</a><span>|</span><label class="collapse" for="c-37463744">[-]</label><label class="expand" for="c-37463744">[1 more]</label></div><br/><div class="children"><div class="content">The problem with vanilla std::deque is that the only acceptable implementation is in clang libc++. On MSVC it&#x27;s basically an overcomplicated linked list.</div><br/></div></div><div id="37460453" class="c"><input type="checkbox" id="c-37460453" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37463744">prev</a><span>|</span><a href="#37457559">next</a><span>|</span><label class="collapse" for="c-37460453">[-]</label><label class="expand" for="c-37460453">[1 more]</label></div><br/><div class="children"><div class="content">I gather from your comment that lock-free is actually the best choice for videogames. Where consistent frame timing should be paramount.</div><br/></div></div><div id="37457559" class="c"><input type="checkbox" id="c-37457559" checked=""/><div class="controls bullet"><span class="by">enqk</span><span>|</span><a href="#37457162">parent</a><span>|</span><a href="#37460453">prev</a><span>|</span><a href="#37460496">next</a><span>|</span><label class="collapse" for="c-37457559">[-]</label><label class="expand" for="c-37457559">[6 more]</label></div><br/><div class="children"><div class="content">how do you deal with msvc&#x27;s `std::deque`? (or maybe you&#x27;re not using literal std::dequeue)</div><br/><div id="37457815" class="c"><input type="checkbox" id="c-37457815" checked=""/><div class="controls bullet"><span class="by">OnionBlender</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457559">parent</a><span>|</span><a href="#37458103">next</a><span>|</span><label class="collapse" for="c-37457815">[-]</label><label class="expand" for="c-37457815">[4 more]</label></div><br/><div class="children"><div class="content">What is special about msvc&#x27;s `std::deque`?</div><br/><div id="37458657" class="c"><input type="checkbox" id="c-37458657" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457815">parent</a><span>|</span><a href="#37459261">next</a><span>|</span><label class="collapse" for="c-37458657">[-]</label><label class="expand" for="c-37458657">[1 more]</label></div><br/><div class="children"><div class="content">The memory chunks it allocates to store entries are so small that it ends up allocating one chunk for every element for almost every type. The result is a lot of allocation overhead, pointer indirection and various other things that are bad for performance.</div><br/></div></div><div id="37459261" class="c"><input type="checkbox" id="c-37459261" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457815">parent</a><span>|</span><a href="#37458657">prev</a><span>|</span><a href="#37458103">next</a><span>|</span><label class="collapse" for="c-37459261">[-]</label><label class="expand" for="c-37459261">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s block size is something stupid like 16 bytes, so it effectively becomes a slower linked list.</div><br/><div id="37464518" class="c"><input type="checkbox" id="c-37464518" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37459261">parent</a><span>|</span><a href="#37458103">next</a><span>|</span><label class="collapse" for="c-37464518">[-]</label><label class="expand" for="c-37464518">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20230810-00&#x2F;?p=108587" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20230810-00&#x2F;?p=10...</a> which includes confirmation &amp; a brief commentary of the tiny block size.</div><br/></div></div></div></div></div></div><div id="37458103" class="c"><input type="checkbox" id="c-37458103" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#37457162">root</a><span>|</span><a href="#37457559">parent</a><span>|</span><a href="#37457815">prev</a><span>|</span><a href="#37460496">next</a><span>|</span><label class="collapse" for="c-37458103">[-]</label><label class="expand" for="c-37458103">[1 more]</label></div><br/><div class="children"><div class="content">Whatever the issue is, they support Clang on linux, i.e. no MSVC standard library.</div><br/></div></div></div></div></div></div><div id="37464555" class="c"><input type="checkbox" id="c-37464555" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37457162">prev</a><span>|</span><a href="#37458322">next</a><span>|</span><label class="collapse" for="c-37464555">[-]</label><label class="expand" for="c-37464555">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why it is using clang modules instead of proper C++20 modules.<p>Except for header units, the support is already mostly there.</div><br/></div></div><div id="37458322" class="c"><input type="checkbox" id="c-37458322" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#37464555">prev</a><span>|</span><a href="#37457330">next</a><span>|</span><label class="collapse" for="c-37458322">[-]</label><label class="expand" for="c-37458322">[8 more]</label></div><br/><div class="children"><div class="content">It says that it&#x27;s actor-based, and sending messages to an actor is equivalent to running the actor function under a mutex, and thus reduces parallelism (in other words, you have N threads sending messages, but only 1 thread running the actor code, so it&#x27;s just as serialized as a mutex), so while it may technically be &quot;fully lock-free&quot;, using actors means that there is no parallelization improvement.</div><br/><div id="37459172" class="c"><input type="checkbox" id="c-37459172" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37458322">parent</a><span>|</span><a href="#37458954">next</a><span>|</span><label class="collapse" for="c-37459172">[-]</label><label class="expand" for="c-37459172">[4 more]</label></div><br/><div class="children"><div class="content">&gt; sending messages to an actor is equivalent to running the actor function under a mutex<p>Where does it say that? In my understanding actor model means message-passing with asynchronous execution. So quite the contrary, actor model allows N threads executing in parallel given N actors.</div><br/><div id="37460286" class="c"><input type="checkbox" id="c-37460286" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37458322">root</a><span>|</span><a href="#37459172">parent</a><span>|</span><a href="#37458954">next</a><span>|</span><label class="collapse" for="c-37460286">[-]</label><label class="expand" for="c-37460286">[3 more]</label></div><br/><div class="children"><div class="content">Whenever I read any press about actors or goroutines, they say the same thing about preventing races (and the need for explicit locking) through share-nothing concurrency.<p>It&#x27;s easy to scatter the computations, but they never go on to explain how to gather them back up.<p>You&#x27;re going to render one frame to the screen.  Did multiple actors have a write-handle into the frame buffer?  What about collisions, does each entity collide with itself, without sharing position information with other actors?</div><br/><div id="37461381" class="c"><input type="checkbox" id="c-37461381" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37458322">root</a><span>|</span><a href="#37460286">parent</a><span>|</span><a href="#37460564">next</a><span>|</span><label class="collapse" for="c-37461381">[-]</label><label class="expand" for="c-37461381">[1 more]</label></div><br/><div class="children"><div class="content">How to gather them up, I guess messages again? It depends on the situation how easy it is, and yes I would assume typically not very.</div><br/></div></div><div id="37460564" class="c"><input type="checkbox" id="c-37460564" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37458322">root</a><span>|</span><a href="#37460286">parent</a><span>|</span><a href="#37461381">prev</a><span>|</span><a href="#37458954">next</a><span>|</span><label class="collapse" for="c-37460564">[-]</label><label class="expand" for="c-37460564">[1 more]</label></div><br/><div class="children"><div class="content">One way or another, there has to be a master thread that gathers things back. So instead of a mutex, you have a supervisor.</div><br/></div></div></div></div></div></div><div id="37458954" class="c"><input type="checkbox" id="c-37458954" checked=""/><div class="controls bullet"><span class="by">onjectic</span><span>|</span><a href="#37458322">parent</a><span>|</span><a href="#37459172">prev</a><span>|</span><a href="#37458938">next</a><span>|</span><label class="collapse" for="c-37458954">[-]</label><label class="expand" for="c-37458954">[1 more]</label></div><br/><div class="children"><div class="content">Your right that there is no parallelization improvement, but it does not reduce parallelism either, its just a different(imo easier) way to think about concurrency.<p>Because it is easier for me to think about it is easier for me to see where things will contend the same resource and actually helps me improve potential parallelism. Once you recognize a particular opportunity where SMP can speed things up, you can stray a way from the actor-model a bit and have multiple threads receiving on your message queue, or if that isn&#x27;t possible, you can just add more actors and split up the data better.</div><br/></div></div><div id="37459129" class="c"><input type="checkbox" id="c-37459129" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#37458322">parent</a><span>|</span><a href="#37458938">prev</a><span>|</span><a href="#37457330">next</a><span>|</span><label class="collapse" for="c-37459129">[-]</label><label class="expand" for="c-37459129">[1 more]</label></div><br/><div class="children"><div class="content">Not quite; with mutex based actors an interruption of the actor thread would cause that mutex (and thus that actor code) to remain locked until the original thread resumes. No additional parallelism will allow that actor code to be &quot;restarted&quot; or &quot;resumed&quot; as the mutex owned by the interrupted thread is locked.<p>This implementation relies heavily on restartable functions in order to allow another parallel thread to pick up and continue the work of an already in progress but otherwise interrupted actor. See page three of the (excellent) design document: <a href="https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine&#x2F;blob&#x2F;master&#x2F;docs&#x2F;lockfree.pdf">https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine&#x2F;bl...</a><p>Thus while it might not strictly be &quot;more parallel&quot; (same number of actors), it does seem to be able to make better use of more parallelism for completing the same set of work.</div><br/></div></div></div></div><div id="37457330" class="c"><input type="checkbox" id="c-37457330" checked=""/><div class="controls bullet"><span class="by">schmichael</span><span>|</span><a href="#37458322">prev</a><span>|</span><a href="#37463478">next</a><span>|</span><label class="collapse" for="c-37457330">[-]</label><label class="expand" for="c-37457330">[5 more]</label></div><br/><div class="children"><div class="content">Does anyone have experience debugging&#x2F;profiling highly contended critical sections of STM vs a more traditional mutex implementation? At the end of the day <i>something</i> has to mediate concurrent access to shared memory, there’s no free lunches, and mutexes are so well optimized, profiled, and understood. I’m unclear if the same applies to STM where a transaction may need to be retried an unbounded(?!) number of times.</div><br/><div id="37463484" class="c"><input type="checkbox" id="c-37463484" checked=""/><div class="controls bullet"><span class="by">pramalhe</span><span>|</span><a href="#37457330">parent</a><span>|</span><a href="#37457402">next</a><span>|</span><label class="collapse" for="c-37463484">[-]</label><label class="expand" for="c-37463484">[1 more]</label></div><br/><div class="children"><div class="content">Actually, for starvation-free STMs, transactions will retried a _bounded_ number of times. One example is 2PLSF, but there are several others <a href="https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718" rel="nofollow noreferrer">https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718</a></div><br/></div></div><div id="37457402" class="c"><input type="checkbox" id="c-37457402" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37457330">parent</a><span>|</span><a href="#37463484">prev</a><span>|</span><a href="#37463478">next</a><span>|</span><label class="collapse" for="c-37457402">[-]</label><label class="expand" for="c-37457402">[3 more]</label></div><br/><div class="children"><div class="content">Yes. The mediator in this case is the scheduler. The one that actually calls the asynchronous block. Potentially retrying it if it fails. In the OP’s code, there’s atomic blocks, sequential execution of blocks, stateful blocks, etc for ensuring singular access at a time.<p>The meat here is scheduler.cpp. It uses std::coroutines.<p>This is like async&#x2F;await in other languages. The scheduler has a queue of work(coroutines) and a pool of threads(N&gt;0) to execute those on.<p>In this case, messages are passed between work that contains the data. No locks are required at the expense of memory footprint.</div><br/><div id="37458068" class="c"><input type="checkbox" id="c-37458068" checked=""/><div class="controls bullet"><span class="by">schmichael</span><span>|</span><a href="#37457330">root</a><span>|</span><a href="#37457402">parent</a><span>|</span><a href="#37463478">next</a><span>|</span><label class="collapse" for="c-37458068">[-]</label><label class="expand" for="c-37458068">[2 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>So the scheduler serializes execution of critical sections?<p>&gt; In this case, messages are passed between work that contains the data. No locks are required at the expense of memory footprint.<p>Are messages copied or moved? If moved is there compile time checking for ownership or runtime debugging tools?</div><br/><div id="37458807" class="c"><input type="checkbox" id="c-37458807" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37457330">root</a><span>|</span><a href="#37458068">parent</a><span>|</span><a href="#37463478">next</a><span>|</span><label class="collapse" for="c-37458807">[-]</label><label class="expand" for="c-37458807">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;coroutines" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;coroutines</a></div><br/></div></div></div></div></div></div></div></div><div id="37463478" class="c"><input type="checkbox" id="c-37463478" checked=""/><div class="controls bullet"><span class="by">snaury</span><span>|</span><a href="#37457330">prev</a><span>|</span><a href="#37456947">next</a><span>|</span><label class="collapse" for="c-37463478">[-]</label><label class="expand" for="c-37463478">[1 more]</label></div><br/><div class="children"><div class="content">The lockfree scheduler certainly looks interesting (especially linearizability of event broadcasts), but I was surprised to see benchmark results in the paper with a peak of 43500 messages&#x2F;s for 12 pairs of actors (and 12 cores?), with a graph showing ~5000 messages&#x2F;s for a single core, which is surprisingly low for that kind of benchmark. Unfortunately the engine requires linux and more importantly x86 (due to asm intructions) so I wasn&#x27;t able to replicate them yet, but I would expect at least ~1 million requests&#x2F;s per a pair of actors (e.g. with Erlang), otherwise the overhead is prohibilitely low.<p>The engine also focuses on message passing, but from experience it&#x27;s very difficult to work with (state machines are hard, especially when working with multiple downstream actors), and at the core actors are more about isolating state without locks than message passing. Swift actors did it right in my opinion, method calls instead of messages are not only easier to reason about, they give additional hints to the runtime when context may switch without involving a scheduler at all (any shared state is slow and inhibits scalability).<p>I actually wrote a header-only library recently (search for &quot;coroactors&quot; if you&#x27;re interested) that implements something similar to Swift actors with C++20 coroutines, and I thought ~10 million requests&#x2F;s (when uncontended) or ~1-3 million&#x2F;s (when contended and depending on a scheduler) was a way too high of an overhead, especially when compared to normal method calls with shared state protected with mutexes. Coroutines tend to go viral (with more and more functions becoming &quot;async&quot; coroutines), and any non-trivial code base would have a lot of coroutine calls (or messages passed), and that overhead needs to be as low as possible, otherwise you&#x27;d spend more time task switching than doing useful work.</div><br/></div></div><div id="37456947" class="c"><input type="checkbox" id="c-37456947" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#37463478">prev</a><span>|</span><a href="#37463742">next</a><span>|</span><label class="collapse" for="c-37456947">[-]</label><label class="expand" for="c-37456947">[1 more]</label></div><br/><div class="children"><div class="content">Looks BEAMish to me?<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;bo5WL5IQAd0?feature=shared" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;bo5WL5IQAd0?feature=shared</a></div><br/></div></div><div id="37463742" class="c"><input type="checkbox" id="c-37463742" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#37456947">prev</a><span>|</span><a href="#37457670">next</a><span>|</span><label class="collapse" for="c-37463742">[-]</label><label class="expand" for="c-37463742">[1 more]</label></div><br/><div class="children"><div class="content">As cool as lock free sounds, in my opinion any amount of non-trivial atomics usage should be accompanied by a formal, ideally machine checked, proof.  Non sequential consistent atomic ordering usage is so difficult to get right. I&#x27;ve repeatedly seen code that gets it wrong, and the bugs that creates are the worst.</div><br/></div></div><div id="37457670" class="c"><input type="checkbox" id="c-37457670" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#37463742">prev</a><span>|</span><a href="#37456919">next</a><span>|</span><label class="collapse" for="c-37457670">[-]</label><label class="expand" for="c-37457670">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t see mention of how hard it is to debug such an engine.</div><br/></div></div><div id="37456919" class="c"><input type="checkbox" id="c-37456919" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37457670">prev</a><span>|</span><a href="#37463980">next</a><span>|</span><label class="collapse" for="c-37456919">[-]</label><label class="expand" for="c-37456919">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have time to read through the impl, but the readme makes it sound like a classic distributed system between game threads, where patterns like retry-backoff will be common.</div><br/><div id="37457288" class="c"><input type="checkbox" id="c-37457288" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#37456919">parent</a><span>|</span><a href="#37463980">next</a><span>|</span><label class="collapse" for="c-37457288">[-]</label><label class="expand" for="c-37457288">[1 more]</label></div><br/><div class="children"><div class="content">The paper goes into more detail without forcing you to go into the impl but it does seem to be a decent bit more advanced than that.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine&#x2F;blob&#x2F;master&#x2F;docs&#x2F;lockfree.pdf">https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine&#x2F;bl...</a></div><br/></div></div></div></div><div id="37463980" class="c"><input type="checkbox" id="c-37463980" checked=""/><div class="controls bullet"><span class="by">kovacs_x</span><span>|</span><a href="#37456919">prev</a><span>|</span><a href="#37461166">next</a><span>|</span><label class="collapse" for="c-37463980">[-]</label><label class="expand" for="c-37463980">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m 99% sure, the author has never done any completed &#x2F; published non trivial game...<p>.. because doing lock-free programming is least of problems when creating games.</div><br/></div></div><div id="37461166" class="c"><input type="checkbox" id="c-37461166" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#37463980">prev</a><span>|</span><a href="#37459184">next</a><span>|</span><label class="collapse" for="c-37461166">[-]</label><label class="expand" for="c-37461166">[3 more]</label></div><br/><div class="children"><div class="content">Where is the game demo? Also to be considered gaming engine nowadays, you need actual tools, exporters (Maya, 3DSMax, etc.) + who knows what else (collaboration tooling, metrics, alerts)</div><br/><div id="37461227" class="c"><input type="checkbox" id="c-37461227" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#37461166">parent</a><span>|</span><a href="#37459184">next</a><span>|</span><label class="collapse" for="c-37461227">[-]</label><label class="expand" for="c-37461227">[2 more]</label></div><br/><div class="children"><div class="content">I disagree—&quot;game engine&quot; does not necessarily mean &quot;thing I can replace Unity or Unreal with&quot;.</div><br/><div id="37461439" class="c"><input type="checkbox" id="c-37461439" checked=""/><div class="controls bullet"><span class="by">xwdv</span><span>|</span><a href="#37461166">root</a><span>|</span><a href="#37461227">parent</a><span>|</span><a href="#37459184">next</a><span>|</span><label class="collapse" for="c-37461439">[-]</label><label class="expand" for="c-37461439">[1 more]</label></div><br/><div class="children"><div class="content">Not even asking for that much. <i>Any</i> game demo would be appreciated.</div><br/></div></div></div></div></div></div><div id="37460956" class="c"><input type="checkbox" id="c-37460956" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37459184">prev</a><span>|</span><a href="#37456931">next</a><span>|</span><label class="collapse" for="c-37460956">[-]</label><label class="expand" for="c-37460956">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Lock-free<p><pre><code>    export std::mutex iolock{};
    export std::mutex errlock{};
    SDL_PollEvent
</code></pre>
Not yet at least.</div><br/></div></div><div id="37456931" class="c"><input type="checkbox" id="c-37456931" checked=""/><div class="controls bullet"><span class="by">xwdv</span><span>|</span><a href="#37460956">prev</a><span>|</span><a href="#37456858">next</a><span>|</span><label class="collapse" for="c-37456931">[-]</label><label class="expand" for="c-37456931">[2 more]</label></div><br/><div class="children"><div class="content">Any games built with this</div><br/><div id="37457226" class="c"><input type="checkbox" id="c-37457226" checked=""/><div class="controls bullet"><span class="by">minitoar</span><span>|</span><a href="#37456931">parent</a><span>|</span><a href="#37456858">next</a><span>|</span><label class="collapse" for="c-37457226">[-]</label><label class="expand" for="c-37457226">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it’s called C++20 Game Engine Developer.</div><br/></div></div></div></div><div id="37456858" class="c"><input type="checkbox" id="c-37456858" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#37456931">prev</a><span>|</span><a href="#37456771">next</a><span>|</span><label class="collapse" for="c-37456858">[-]</label><label class="expand" for="c-37456858">[16 more]</label></div><br/><div class="children"><div class="content">All those people who complain about project names squatting on existing words have finally been heard :-D</div><br/><div id="37457000" class="c"><input type="checkbox" id="c-37457000" checked=""/><div class="controls bullet"><span class="by">pekka22</span><span>|</span><a href="#37456858">parent</a><span>|</span><a href="#37457192">next</a><span>|</span><label class="collapse" for="c-37457000">[-]</label><label class="expand" for="c-37457000">[2 more]</label></div><br/><div class="children"><div class="content">Peredvizhniki [0] were a group of Russian realist painters from the 19th century. Among other things, they organized &quot;traveling&quot; art exhibitions to promote Russian art in the provinces. The name roughly translates as &quot;The travelers&quot;.<p>- [0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Peredvizhniki" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Peredvizhniki</a></div><br/><div id="37457591" class="c"><input type="checkbox" id="c-37457591" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#37456858">root</a><span>|</span><a href="#37457000">parent</a><span>|</span><a href="#37457192">next</a><span>|</span><label class="collapse" for="c-37457591">[-]</label><label class="expand" for="c-37457591">[1 more]</label></div><br/><div class="children"><div class="content">Not all who wander are lost.</div><br/></div></div></div></div><div id="37457192" class="c"><input type="checkbox" id="c-37457192" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#37456858">parent</a><span>|</span><a href="#37457000">prev</a><span>|</span><a href="#37456976">next</a><span>|</span><label class="collapse" for="c-37457192">[-]</label><label class="expand" for="c-37457192">[2 more]</label></div><br/><div class="children"><div class="content">I tried in it a zxcvbn simulator, and it qualified as a strong password ;)</div><br/><div id="37461281" class="c"><input type="checkbox" id="c-37461281" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37456858">root</a><span>|</span><a href="#37457192">parent</a><span>|</span><a href="#37456976">next</a><span>|</span><label class="collapse" for="c-37461281">[-]</label><label class="expand" for="c-37461281">[1 more]</label></div><br/><div class="children"><div class="content">My experience is that zxcvbn lacks many non-English dictionaries, it often gives false-positives for foreign languages...</div><br/></div></div></div></div></div></div><div id="37456771" class="c"><input type="checkbox" id="c-37456771" checked=""/><div class="controls bullet"><span class="by">datameta</span><span>|</span><a href="#37456858">prev</a><span>|</span><a href="#37456844">next</a><span>|</span><label class="collapse" for="c-37456771">[-]</label><label class="expand" for="c-37456771">[16 more]</label></div><br/><div class="children"><div class="content">The painting used is Barge Haulers on the Volga - <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Barge_Haulers_on_the_Volga" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Barge_Haulers_on_the_Volga</a><p>Can someone please expand on the significance of this achievement to someone used to shooting their foot off in C++ in a predominantly single threaded manner?</div><br/><div id="37457123" class="c"><input type="checkbox" id="c-37457123" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#37456771">parent</a><span>|</span><a href="#37461354">next</a><span>|</span><label class="collapse" for="c-37457123">[-]</label><label class="expand" for="c-37457123">[10 more]</label></div><br/><div class="children"><div class="content">Never mind that a lot of Volga boats were <i>very</i> single-threaded.<p><a href="https:&#x2F;&#x2F;www.amusingplanet.com&#x2F;2021&#x2F;12&#x2F;belyana-russias-giant-wooden-boats.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amusingplanet.com&#x2F;2021&#x2F;12&#x2F;belyana-russias-giant-...</a></div><br/><div id="37457605" class="c"><input type="checkbox" id="c-37457605" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457123">parent</a><span>|</span><a href="#37457139">next</a><span>|</span><label class="collapse" for="c-37457605">[-]</label><label class="expand" for="c-37457605">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a logging framework! :D</div><br/><div id="37464593" class="c"><input type="checkbox" id="c-37464593" checked=""/><div class="controls bullet"><span class="by">aldanor</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457605">parent</a><span>|</span><a href="#37457139">next</a><span>|</span><label class="collapse" for="c-37464593">[-]</label><label class="expand" for="c-37464593">[1 more]</label></div><br/><div class="children"><div class="content">Streaming logging framework</div><br/></div></div></div></div><div id="37457139" class="c"><input type="checkbox" id="c-37457139" checked=""/><div class="controls bullet"><span class="by">3seashells</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457123">parent</a><span>|</span><a href="#37457605">prev</a><span>|</span><a href="#37461354">next</a><span>|</span><label class="collapse" for="c-37457139">[-]</label><label class="expand" for="c-37457139">[7 more]</label></div><br/><div class="children"><div class="content">You can even see the steam ships that replaced the slave in the background.</div><br/><div id="37457641" class="c"><input type="checkbox" id="c-37457641" checked=""/><div class="controls bullet"><span class="by">beatcracker</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457139">parent</a><span>|</span><a href="#37457825">next</a><span>|</span><label class="collapse" for="c-37457641">[-]</label><label class="expand" for="c-37457641">[4 more]</label></div><br/><div class="children"><div class="content">They were not the slaves, but unionized workers:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Burlak" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Burlak</a></div><br/><div id="37457735" class="c"><input type="checkbox" id="c-37457735" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457641">parent</a><span>|</span><a href="#37462059">next</a><span>|</span><label class="collapse" for="c-37457735">[-]</label><label class="expand" for="c-37457735">[2 more]</label></div><br/><div class="children"><div class="content">AFAIU an артель <i>artelʼ</i> usually did not engage in collective bargaining as such, so calling it a union is not really accurate; you might compare it to a guild but I think there’s no implicaton of a monopoly on a particular trade either. The most accurate description I can think of is perhaps a cooperative combined with a mutual insurance fund.</div><br/><div id="37458351" class="c"><input type="checkbox" id="c-37458351" checked=""/><div class="controls bullet"><span class="by">beatcracker</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457735">parent</a><span>|</span><a href="#37462059">next</a><span>|</span><label class="collapse" for="c-37458351">[-]</label><label class="expand" for="c-37458351">[1 more]</label></div><br/><div class="children"><div class="content">Agree, I might&#x27;ve stretched It a bit. Your descriptions is more accurate.</div><br/></div></div></div></div><div id="37462059" class="c"><input type="checkbox" id="c-37462059" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457641">parent</a><span>|</span><a href="#37457735">prev</a><span>|</span><a href="#37457825">next</a><span>|</span><label class="collapse" for="c-37462059">[-]</label><label class="expand" for="c-37462059">[1 more]</label></div><br/><div class="children"><div class="content">YEp, somewhat resemblance to Teamsters</div><br/></div></div></div></div><div id="37457825" class="c"><input type="checkbox" id="c-37457825" checked=""/><div class="controls bullet"><span class="by">datameta</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457139">parent</a><span>|</span><a href="#37457641">prev</a><span>|</span><a href="#37462054">next</a><span>|</span><label class="collapse" for="c-37457825">[-]</label><label class="expand" for="c-37457825">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact - this was painted about 8 to 10 years after the abolition of serfdom in the Russian Empire. Coincidentally, it happened two years prior to the US Emancipation Proclamation. I&#x27;ve wondered from time to time how linked the two events were, if at all.</div><br/></div></div><div id="37462054" class="c"><input type="checkbox" id="c-37462054" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37457139">parent</a><span>|</span><a href="#37457825">prev</a><span>|</span><a href="#37461354">next</a><span>|</span><label class="collapse" for="c-37462054">[-]</label><label class="expand" for="c-37462054">[1 more]</label></div><br/><div class="children"><div class="content">they were not slaves, but something like Russian Teamsters</div><br/></div></div></div></div></div></div><div id="37461354" class="c"><input type="checkbox" id="c-37461354" checked=""/><div class="controls bullet"><span class="by">datameta</span><span>|</span><a href="#37456771">parent</a><span>|</span><a href="#37457123">prev</a><span>|</span><a href="#37458311">next</a><span>|</span><label class="collapse" for="c-37461354">[-]</label><label class="expand" for="c-37461354">[1 more]</label></div><br/><div class="children"><div class="content">As an addendum - a fair portion here should be in one way or another familiar with Ilya Repin&#x27;s Reply of the Zaporozhian Cossacks (aka Zaporozhian Cossacks are Writing a Letter to the Turkish Sultan)
<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Reply_of_the_Zaporozhian_Cossacks" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Reply_of_the_Zaporozhian_Cos...</a></div><br/></div></div><div id="37458311" class="c"><input type="checkbox" id="c-37458311" checked=""/><div class="controls bullet"><span class="by">hathym</span><span>|</span><a href="#37456771">parent</a><span>|</span><a href="#37461354">prev</a><span>|</span><a href="#37458612">next</a><span>|</span><label class="collapse" for="c-37458311">[-]</label><label class="expand" for="c-37458311">[1 more]</label></div><br/><div class="children"><div class="content">I hope the author is not picturing developers using his engine.</div><br/></div></div><div id="37458612" class="c"><input type="checkbox" id="c-37458612" checked=""/><div class="controls bullet"><span class="by">drums8787</span><span>|</span><a href="#37456771">parent</a><span>|</span><a href="#37458311">prev</a><span>|</span><a href="#37458839">next</a><span>|</span><label class="collapse" for="c-37458612">[-]</label><label class="expand" for="c-37458612">[2 more]</label></div><br/><div class="children"><div class="content">Barge hauler 4th from the back appears to be checking his messages.</div><br/><div id="37458697" class="c"><input type="checkbox" id="c-37458697" checked=""/><div class="controls bullet"><span class="by">tetris11</span><span>|</span><a href="#37456771">root</a><span>|</span><a href="#37458612">parent</a><span>|</span><a href="#37458839">next</a><span>|</span><label class="collapse" for="c-37458697">[-]</label><label class="expand" for="c-37458697">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Tut tut, those poor Canadian renters...&quot;</div><br/></div></div></div></div></div></div><div id="37456844" class="c"><input type="checkbox" id="c-37456844" checked=""/><div class="controls bullet"><span class="by">hesdeadjim</span><span>|</span><a href="#37456771">prev</a><span>|</span><a href="#37458043">next</a><span>|</span><label class="collapse" for="c-37456844">[-]</label><label class="expand" for="c-37456844">[15 more]</label></div><br/><div class="children"><div class="content">It’s quite the stretch to call this a game engine, rather than a tech demo for clever locking strategies.</div><br/><div id="37458008" class="c"><input type="checkbox" id="c-37458008" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#37456844">parent</a><span>|</span><a href="#37456929">next</a><span>|</span><label class="collapse" for="c-37458008">[-]</label><label class="expand" for="c-37458008">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t even call it clever. The Actor model trivializes avoiding locks, since you&#x27;re letting everything act on stale information (if the actors process concurrently) and then just iterating through their intended actions against a singleton state and resolving those conflicts with sequential code.</div><br/><div id="37458827" class="c"><input type="checkbox" id="c-37458827" checked=""/><div class="controls bullet"><span class="by">sigg3</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37458008">parent</a><span>|</span><a href="#37456929">next</a><span>|</span><label class="collapse" for="c-37458827">[-]</label><label class="expand" for="c-37458827">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the summary, mate.</div><br/></div></div></div></div><div id="37456929" class="c"><input type="checkbox" id="c-37456929" checked=""/><div class="controls bullet"><span class="by">DennisP</span><span>|</span><a href="#37456844">parent</a><span>|</span><a href="#37458008">prev</a><span>|</span><a href="#37461107">next</a><span>|</span><label class="collapse" for="c-37456929">[-]</label><label class="expand" for="c-37456929">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s not done yet.</div><br/></div></div><div id="37461107" class="c"><input type="checkbox" id="c-37461107" checked=""/><div class="controls bullet"><span class="by">Reticularas</span><span>|</span><a href="#37456844">parent</a><span>|</span><a href="#37456929">prev</a><span>|</span><a href="#37457956">next</a><span>|</span><label class="collapse" for="c-37461107">[-]</label><label class="expand" for="c-37461107">[1 more]</label></div><br/><div class="children"><div class="content">This model isn&#x27;t novel, there&#x27;s been experimental engines using this technique for years now.  They&#x27;re just not practical at scale</div><br/></div></div><div id="37457956" class="c"><input type="checkbox" id="c-37457956" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#37456844">parent</a><span>|</span><a href="#37461107">prev</a><span>|</span><a href="#37456932">next</a><span>|</span><label class="collapse" for="c-37457956">[-]</label><label class="expand" for="c-37457956">[7 more]</label></div><br/><div class="children"><div class="content">Say you are in the middle of building a house.   The foundation has been built and they are framing it up.<p>Is it a house?</div><br/><div id="37461059" class="c"><input type="checkbox" id="c-37461059" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37457956">parent</a><span>|</span><a href="#37458065">next</a><span>|</span><label class="collapse" for="c-37461059">[-]</label><label class="expand" for="c-37461059">[2 more]</label></div><br/><div class="children"><div class="content">No, because otherwise you wouldn&#x27;t say &quot;the foundation has been built&quot;. You&#x27;d say the &quot;the house has been built&quot;.<p>Does a house need a foundation? Yes. Is the foundation the same as the house? No.</div><br/><div id="37464346" class="c"><input type="checkbox" id="c-37464346" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37461059">parent</a><span>|</span><a href="#37458065">next</a><span>|</span><label class="collapse" for="c-37464346">[-]</label><label class="expand" for="c-37464346">[1 more]</label></div><br/><div class="children"><div class="content">But you do say, “I am building a house.”</div><br/></div></div></div></div><div id="37458065" class="c"><input type="checkbox" id="c-37458065" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37457956">parent</a><span>|</span><a href="#37461059">prev</a><span>|</span><a href="#37458109">next</a><span>|</span><label class="collapse" for="c-37458065">[-]</label><label class="expand" for="c-37458065">[1 more]</label></div><br/><div class="children"><div class="content">No</div><br/></div></div><div id="37458261" class="c"><input type="checkbox" id="c-37458261" checked=""/><div class="controls bullet"><span class="by">xwdv</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37457956">parent</a><span>|</span><a href="#37458109">prev</a><span>|</span><a href="#37456932">next</a><span>|</span><label class="collapse" for="c-37458261">[-]</label><label class="expand" for="c-37458261">[2 more]</label></div><br/><div class="children"><div class="content">No, and if you accept it as a house then this is a recipe for developing a bad habit of leaving a trail of half finished projects in your wake.</div><br/><div id="37464384" class="c"><input type="checkbox" id="c-37464384" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37458261">parent</a><span>|</span><a href="#37456932">next</a><span>|</span><label class="collapse" for="c-37464384">[-]</label><label class="expand" for="c-37464384">[1 more]</label></div><br/><div class="children"><div class="content">Can you point at a house and say “I designed this house?”  If the house didn’t have some kind of existence while you were even designing it, how could it be that you designed that, particular house?</div><br/></div></div></div></div></div></div><div id="37456932" class="c"><input type="checkbox" id="c-37456932" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37456844">parent</a><span>|</span><a href="#37457956">prev</a><span>|</span><a href="#37458850">next</a><span>|</span><label class="collapse" for="c-37456932">[-]</label><label class="expand" for="c-37456932">[2 more]</label></div><br/><div class="children"><div class="content">This. There’s no demonstration of any game made with this “game engine”. The benchmarks are some matrix multiplication and unimpressive message passing.<p>There might be some cool data container ideas or primitives. Those could have useful applications. But it isn’t really a “game engine”. Nor does it seem like an interesting way to build one.</div><br/><div id="37457105" class="c"><input type="checkbox" id="c-37457105" checked=""/><div class="controls bullet"><span class="by">erwincoumans</span><span>|</span><a href="#37456844">root</a><span>|</span><a href="#37456932">parent</a><span>|</span><a href="#37458850">next</a><span>|</span><label class="collapse" for="c-37457105">[-]</label><label class="expand" for="c-37457105">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. The project has no renderer or game physics code it seems? If so, it is too premature to be a game engine.</div><br/></div></div></div></div></div></div><div id="37458043" class="c"><input type="checkbox" id="c-37458043" checked=""/><div class="controls bullet"><span class="by">edfletcher_t137</span><span>|</span><a href="#37456844">prev</a><span>|</span><a href="#37460418">next</a><span>|</span><label class="collapse" for="c-37458043">[-]</label><label class="expand" for="c-37458043">[22 more]</label></div><br/><div class="children"><div class="content">&gt; At the moment, the only supported platform is Linux.<p>Regardless of your feelings on the status quo, there is one thing you <i>must</i> do when building a game engine if you want it to succeed: <i>support Windows</i>.</div><br/><div id="37458100" class="c"><input type="checkbox" id="c-37458100" checked=""/><div class="controls bullet"><span class="by">StevenXC</span><span>|</span><a href="#37458043">parent</a><span>|</span><a href="#37458225">next</a><span>|</span><label class="collapse" for="c-37458100">[-]</label><label class="expand" for="c-37458100">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see the Steam Deck &quot;console&quot; change this status quo.</div><br/><div id="37458118" class="c"><input type="checkbox" id="c-37458118" checked=""/><div class="controls bullet"><span class="by">tmccrary55</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458100">parent</a><span>|</span><a href="#37458119">next</a><span>|</span><label class="collapse" for="c-37458118">[-]</label><label class="expand" for="c-37458118">[1 more]</label></div><br/><div class="children"><div class="content">Most of the SteamDeck games are just running windows games through photon, wine and other compatibility layers.<p>While that works amazingly well, I tend to prefer games with native Linux and SteamOS builds, even though they&#x27;re rare.</div><br/></div></div><div id="37458119" class="c"><input type="checkbox" id="c-37458119" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458100">parent</a><span>|</span><a href="#37458118">prev</a><span>|</span><a href="#37458225">next</a><span>|</span><label class="collapse" for="c-37458119">[-]</label><label class="expand" for="c-37458119">[1 more]</label></div><br/><div class="children"><div class="content">win32 is the stable ABI for SteamOS, same as any other Linux distro</div><br/></div></div></div></div><div id="37458506" class="c"><input type="checkbox" id="c-37458506" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#37458043">parent</a><span>|</span><a href="#37458225">prev</a><span>|</span><a href="#37462930">next</a><span>|</span><label class="collapse" for="c-37458506">[-]</label><label class="expand" for="c-37458506">[15 more]</label></div><br/><div class="children"><div class="content">bullshit, consoles&#x2F;mobile are bigger markets than PC&#x2F;Windows<p>PC is just less than 1&#x2F;3 of the whole picture<p><a href="https:&#x2F;&#x2F;www.data.ai&#x2F;en&#x2F;insights&#x2F;mobile-gaming&#x2F;2022-gaming-spotlight-report&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.data.ai&#x2F;en&#x2F;insights&#x2F;mobile-gaming&#x2F;2022-gaming-sp...</a></div><br/><div id="37461667" class="c"><input type="checkbox" id="c-37461667" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458506">parent</a><span>|</span><a href="#37458592">next</a><span>|</span><label class="collapse" for="c-37461667">[-]</label><label class="expand" for="c-37461667">[1 more]</label></div><br/><div class="children"><div class="content">I feel like it&#x27;s a mistake to consider mobile games as being part of the same market as PC&#x2F;console games.<p>Sure they&#x27;re both &quot;games&quot; but I don&#x27;t know that they&#x27;re competing for the same set of users - either people play one or the other, or the people that do crossover in both markets are probably playing PC&#x2F;console games at home and mobile games on the bus or train.</div><br/></div></div><div id="37458592" class="c"><input type="checkbox" id="c-37458592" checked=""/><div class="controls bullet"><span class="by">5e92cb50239222b</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458506">parent</a><span>|</span><a href="#37461667">prev</a><span>|</span><a href="#37460579">next</a><span>|</span><label class="collapse" for="c-37458592">[-]</label><label class="expand" for="c-37458592">[8 more]</label></div><br/><div class="children"><div class="content">A bit more than that since Xbox runs Windows too.</div><br/><div id="37458723" class="c"><input type="checkbox" id="c-37458723" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458592">parent</a><span>|</span><a href="#37460579">next</a><span>|</span><label class="collapse" for="c-37458723">[-]</label><label class="expand" for="c-37458723">[7 more]</label></div><br/><div class="children"><div class="content">July console sales:<p>PS5: 1.2m<p>Switch: 950k<p>Xbox: 370k<p>Xbox accounts for just 17% of total console sales in July<p>Both Switch and PS5 are FreeBSD based<p>If we count the whole period of the current gen of each vendors, it only accounts for 13%, it&#x27;s not big<p><a href="https:&#x2F;&#x2F;www.vgchartz.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.vgchartz.com&#x2F;</a></div><br/><div id="37461085" class="c"><input type="checkbox" id="c-37461085" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458723">parent</a><span>|</span><a href="#37459632">next</a><span>|</span><label class="collapse" for="c-37461085">[-]</label><label class="expand" for="c-37461085">[1 more]</label></div><br/><div class="children"><div class="content">And what about actual game sales and revenue through things like GamePass. It doesn&#x27;t help your game if a million people bought a Nintendo Switch if 80% of them only buy Pokémon, Mario Kart and Zelda.</div><br/></div></div><div id="37459632" class="c"><input type="checkbox" id="c-37459632" checked=""/><div class="controls bullet"><span class="by">rstat1</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458723">parent</a><span>|</span><a href="#37461085">prev</a><span>|</span><a href="#37460579">next</a><span>|</span><label class="collapse" for="c-37459632">[-]</label><label class="expand" for="c-37459632">[5 more]</label></div><br/><div class="children"><div class="content">Actually its only the PS5 that&#x27;s FreeBSD based. Switch runs a completely proprietary Nintendo OS that borrows a lot from Android.</div><br/><div id="37460253" class="c"><input type="checkbox" id="c-37460253" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37459632">parent</a><span>|</span><a href="#37459748">next</a><span>|</span><label class="collapse" for="c-37460253">[-]</label><label class="expand" for="c-37460253">[2 more]</label></div><br/><div class="children"><div class="content">A mix of the two<p>&quot;partially Unix-like via certain components which are based on FreeBSD and Android&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nintendo_Switch_system_software" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nintendo_Switch_system_softwar...</a></div><br/><div id="37461702" class="c"><input type="checkbox" id="c-37461702" checked=""/><div class="controls bullet"><span class="by">rstat1</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37460253">parent</a><span>|</span><a href="#37459748">next</a><span>|</span><label class="collapse" for="c-37461702">[-]</label><label class="expand" for="c-37461702">[1 more]</label></div><br/><div class="children"><div class="content">from the same article<p>&quot;it is based on a proprietary microkernel&quot;<p>&quot;....Despite popular misconceptions to the contrary, Horizon (the Switch&#x27;s OS) is not largely derived from FreeBSD code, nor from Android...&quot;</div><br/></div></div></div></div><div id="37459748" class="c"><input type="checkbox" id="c-37459748" checked=""/><div class="controls bullet"><span class="by">GranPC</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37459632">parent</a><span>|</span><a href="#37460253">prev</a><span>|</span><a href="#37460579">next</a><span>|</span><label class="collapse" for="c-37459748">[-]</label><label class="expand" for="c-37459748">[2 more]</label></div><br/><div class="children"><div class="content">It borrows very little from Android - I think it mostly draws some parts from stagefright.</div><br/><div id="37461681" class="c"><input type="checkbox" id="c-37461681" checked=""/><div class="controls bullet"><span class="by">rstat1</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37459748">parent</a><span>|</span><a href="#37460579">next</a><span>|</span><label class="collapse" for="c-37461681">[-]</label><label class="expand" for="c-37461681">[1 more]</label></div><br/><div class="children"><div class="content">Also borrows the whole of its compositor &quot;nvnflinger&quot; from Android&#x27;s &quot;SurfaceFlinger&quot;.<p>I&#x27;d call that a pretty significant piece.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37460579" class="c"><input type="checkbox" id="c-37460579" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458506">parent</a><span>|</span><a href="#37458592">prev</a><span>|</span><a href="#37459857">next</a><span>|</span><label class="collapse" for="c-37460579">[-]</label><label class="expand" for="c-37460579">[1 more]</label></div><br/><div class="children"><div class="content">Rude way of putting it, but yeah, mobile dwarfs everything.</div><br/></div></div><div id="37459857" class="c"><input type="checkbox" id="c-37459857" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458506">parent</a><span>|</span><a href="#37460579">prev</a><span>|</span><a href="#37459135">next</a><span>|</span><label class="collapse" for="c-37459857">[-]</label><label class="expand" for="c-37459857">[1 more]</label></div><br/><div class="children"><div class="content">Got bad news for you about what the console SDKs run on<p>(Also, the consoles don&#x27;t run Linux)</div><br/></div></div><div id="37459135" class="c"><input type="checkbox" id="c-37459135" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37458506">parent</a><span>|</span><a href="#37459857">prev</a><span>|</span><a href="#37462930">next</a><span>|</span><label class="collapse" for="c-37459135">[-]</label><label class="expand" for="c-37459135">[3 more]</label></div><br/><div class="children"><div class="content">He&#x27;s probably referring to the Desktop&#x2F;laptop market. In which case windows controls like 90%.</div><br/><div id="37460292" class="c"><input type="checkbox" id="c-37460292" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37459135">parent</a><span>|</span><a href="#37462930">next</a><span>|</span><label class="collapse" for="c-37460292">[-]</label><label class="expand" for="c-37460292">[2 more]</label></div><br/><div class="children"><div class="content">Title is: &quot;Peredvizhnikov Engine is a fully lock-free game engine written in C++20 &quot;<p>A Game Engine targets various platforms<p>A &quot;video-game&quot; is not something exclusive to desktop&#x2F;laptop windows market</div><br/><div id="37461380" class="c"><input type="checkbox" id="c-37461380" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37458043">root</a><span>|</span><a href="#37460292">parent</a><span>|</span><a href="#37462930">next</a><span>|</span><label class="collapse" for="c-37461380">[-]</label><label class="expand" for="c-37461380">[1 more]</label></div><br/><div class="children"><div class="content">Right but a toolchain that targets anything else other then a desktop is not straightforward to find or setup.<p>Toy game engines like this are in the majority of cases used on desktop.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37460418" class="c"><input type="checkbox" id="c-37460418" checked=""/><div class="controls bullet"><span class="by">hankman86</span><span>|</span><a href="#37458043">prev</a><span>|</span><a href="#37460494">next</a><span>|</span><label class="collapse" for="c-37460418">[-]</label><label class="expand" for="c-37460418">[3 more]</label></div><br/><div class="children"><div class="content">It’s licensed under GPL3, where the developer suggests individually negotiating a license for commercial projects. I am not sure this is a good approach given the early stage of this project. Video game development is already commercially and technically risky enough.<p>I cannot see game developers lining up to even try out this unproven technology when they have no sense of what the eventual fees will be.</div><br/><div id="37460447" class="c"><input type="checkbox" id="c-37460447" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#37460418">parent</a><span>|</span><a href="#37460471">next</a><span>|</span><label class="collapse" for="c-37460447">[-]</label><label class="expand" for="c-37460447">[1 more]</label></div><br/><div class="children"><div class="content">quoting <a href="https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine">https:&#x2F;&#x2F;github.com&#x2F;eduard-permyakov&#x2F;peredvizhnikov-engine</a><p><i>The source code of Peredvizhnikov Engine is freely available under the GPLv3 license. However, I may grant permission to use parts or all of the code under a different license on a case-by-case basis. Please inquire by e-mail.</i></div><br/></div></div></div></div><div id="37460162" class="c"><input type="checkbox" id="c-37460162" checked=""/><div class="controls bullet"><span class="by">pshirshov</span><span>|</span><a href="#37460494">prev</a><span>|</span><a href="#37458060">next</a><span>|</span><label class="collapse" for="c-37460162">[-]</label><label class="expand" for="c-37460162">[6 more]</label></div><br/><div class="children"><div class="content">Actors is one of the worst programming models possible. It&#x27;s hard to observe actor-based systems and debug them. The protocol complexity (and complete protocol informality) usually brings much more trouble than any kind of locking&#x2F;synchronization.</div><br/><div id="37460246" class="c"><input type="checkbox" id="c-37460246" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#37460162">parent</a><span>|</span><a href="#37460607">next</a><span>|</span><label class="collapse" for="c-37460246">[-]</label><label class="expand" for="c-37460246">[1 more]</label></div><br/><div class="children"><div class="content">I’ve had good success with actor based models. When you say “protocol complexity”, I don’t understand what you mean.<p>Observation requires good logging, but this isn’t out of line for any complex system. Debugging (as in actual breakpoints in an IDE or post-mortem analysis) can be facilitated with stack tracking (this same problem occurs with async await patterns and is solved in a similar way).<p>The advantages and disadvantages exist, but I think it’s an extremely effective programming model for many use cases. Formal state-machine programming, that’s the worst model, unless you need it.</div><br/></div></div><div id="37460607" class="c"><input type="checkbox" id="c-37460607" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37460162">parent</a><span>|</span><a href="#37460246">prev</a><span>|</span><a href="#37460194">next</a><span>|</span><label class="collapse" for="c-37460607">[-]</label><label class="expand" for="c-37460607">[3 more]</label></div><br/><div class="children"><div class="content">For game dev or in general? I hate using actors for general backend stuff, but for game dev maybe it makes more sense.</div><br/><div id="37461644" class="c"><input type="checkbox" id="c-37461644" checked=""/><div class="controls bullet"><span class="by">legosexmagic</span><span>|</span><a href="#37460162">root</a><span>|</span><a href="#37460607">parent</a><span>|</span><a href="#37460194">next</a><span>|</span><label class="collapse" for="c-37461644">[-]</label><label class="expand" for="c-37461644">[2 more]</label></div><br/><div class="children"><div class="content">Actors tend to lead to bloated incomprehensible code. Even when you do want game objects to look like independent message passing actors. Faking it is always easier.<p>Actors are self defeating because they turn everything into a distributed system.</div><br/><div id="37463100" class="c"><input type="checkbox" id="c-37463100" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37460162">root</a><span>|</span><a href="#37461644">parent</a><span>|</span><a href="#37460194">next</a><span>|</span><label class="collapse" for="c-37463100">[-]</label><label class="expand" for="c-37463100">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I was thinking. I&#x27;m trying not to write Actors off because I&#x27;m not an expert on game dev and can imagine the possibility of an unusually large-scaled game. But yeah, if you&#x27;re writing a typical game, I imagine you&#x27;re best off doing it the typical way that&#x27;s been optimized for.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>