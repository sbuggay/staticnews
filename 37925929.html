<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697706062620" as="style"/><link rel="stylesheet" href="styles.css?v=1697706062620"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://queue.acm.org/detail.cfm?id=2349257">A Generation Lost in the Bazaar (2012)</a> <span class="domain">(<a href="https://queue.acm.org">queue.acm.org</a>)</span></div><div class="subtext"><span>pjmlp</span> | <span>25 comments</span></div><br/><div><div id="37940062" class="c"><input type="checkbox" id="c-37940062" checked=""/><div class="controls bullet"><span class="by">MrDresden</span><span>|</span><a href="#37939307">next</a><span>|</span><label class="collapse" for="c-37940062">[-]</label><label class="expand" for="c-37940062">[1 more]</label></div><br/><div class="children"><div class="content">While the architecture, quality and general decisions made in many (even majority) of FOSS projects can be called into question, this piece makes it sound like this would not happen in projects with &#x27;professional&#x27; developers.<p>The horror shows I have witnessed and had to work with inside some of the companies that have employeed me over the last 15 years have been much worse than anything I have come accross in reasonably large and active FOSS projects.<p>The Peter Principle lives on strong in both camps.<p><i>edits: spelling</i></div><br/></div></div><div id="37939307" class="c"><input type="checkbox" id="c-37939307" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#37940062">prev</a><span>|</span><a href="#37938820">next</a><span>|</span><label class="collapse" for="c-37939307">[-]</label><label class="expand" for="c-37939307">[1 more]</label></div><br/><div class="children"><div class="content">I feel like its a bit weird all the examples are coordination between separate (possibly competing) projects, when the implied solution is having a single person responsible for quality. That doesn&#x27;t make sense to me.<p>Sure you could have a single person responsible for quality within a project, and that may even be a good idea (BDFL is a pattern for a reason). However you can&#x27;t do that across organizational boundries. Ports will have lots of duplication because the entire point is to bring the wider world together including projects competing against each other.<p>Like the solution just doesn&#x27;t seem applicable here. It feels like the equivalent of someone suggesting to fix the problem of firefox &amp; chrome doing the same thing by appointing a single person responsible for web quality. The solution doesn&#x27;t seem wrong so much as non-sensical.<p>I don&#x27;t particularly see the connection to cathedral &amp; bazaar either. Even before that book competing software projects had duplication.</div><br/></div></div><div id="37938820" class="c"><input type="checkbox" id="c-37938820" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37939307">prev</a><span>|</span><a href="#37939141">next</a><span>|</span><label class="collapse" for="c-37938820">[-]</label><label class="expand" for="c-37938820">[3 more]</label></div><br/><div class="children"><div class="content">And get off my lawn.<p>Few forces favor convergence and standardization in open source. After a few decades of this, we have far too much duplicative stuff.<p>It&#x27;s really hard to clean that up. At one time I tried to get the 6 or 8 Python packages that parse ISO8601 date strings standardized. All of them had bugs. It took 6 years of bikeshedding discussions.[1] Issue filed in 2012, patch applied in 2018. For something that&#x27;s a few screens of code.<p>[1] <a href="https:&#x2F;&#x2F;bugs.python.org&#x2F;issue15873" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugs.python.org&#x2F;issue15873</a></div><br/><div id="37940038" class="c"><input type="checkbox" id="c-37940038" checked=""/><div class="controls bullet"><span class="by">AdamN</span><span>|</span><a href="#37938820">parent</a><span>|</span><a href="#37939023">next</a><span>|</span><label class="collapse" for="c-37940038">[-]</label><label class="expand" for="c-37940038">[1 more]</label></div><br/><div class="children"><div class="content">Over time I&#x27;ve concluded that a single standard for anything important simply isn&#x27;t enough.  It&#x27;s best to accept that 2 standards and optionally a 3rd and 4th slot for upcoming standards are the best that can be done.  Fixating on getting to one is actually counter-productive.<p>This isn&#x27;t just true of standards, it&#x27;s also true of implementations of a standard.</div><br/></div></div><div id="37939023" class="c"><input type="checkbox" id="c-37939023" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37938820">parent</a><span>|</span><a href="#37940038">prev</a><span>|</span><a href="#37939141">next</a><span>|</span><label class="collapse" for="c-37939023">[-]</label><label class="expand" for="c-37939023">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the last mile is the hardest</div><br/></div></div></div></div><div id="37939141" class="c"><input type="checkbox" id="c-37939141" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37938820">prev</a><span>|</span><a href="#37937163">next</a><span>|</span><label class="collapse" for="c-37939141">[-]</label><label class="expand" for="c-37939141">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. He might rail against &#x2F;usr&#x2F;ports&#x2F; but it was better than the alternatives of the time (I note pkgsrc, maybe comparable, certainly similar)<p>His beef is that people are lazy. If there is a perl tool to munge something you use it, even if the rest of the process uses Python. This is the reductionism of
&quot;if you start in awk stay in awk&quot; which is good, honest and .. hard.<p>Ports is better than APT. apt, has the disease of &#x27;I made a bundle for you but the name is not indicative of whats in it&#x27; -where Ports has metaports which are explicit what they pull in to make the &quot;thing&quot; they meta over.<p>APT has the &quot;-dev&quot; norm now. thats ok, but sort of stupid too. How can it possibly make sense to have to pull in the -dev thing to use its shared libs standalone in another package? (I have seen this)<p>Ports is the bazaar but with sub-zones. Like the Grand Bazaar in Istanbul, things tend to clump together. Sometimes you wonder why its in sysadmin&#x2F; and not text&#x2F; but in the end its birds-of-a-feather.<p>Homebrew ditched M4 for Ruby. Gak.<p>CPAN is the enemy.</div><br/></div></div><div id="37937163" class="c"><input type="checkbox" id="c-37937163" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#37939141">prev</a><span>|</span><a href="#37933595">next</a><span>|</span><label class="collapse" for="c-37937163">[-]</label><label class="expand" for="c-37937163">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Well, autoconf, for reasons that have never made sense, was written in the obscure M4 macro language<p>This immediately reminded me of Helm charts (Kubernetes) and their implementation with Go templates, that work in the syntatic level instead of semantic, which makes it unnecessarily hard to operate it.</div><br/><div id="37937196" class="c"><input type="checkbox" id="c-37937196" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#37937163">parent</a><span>|</span><a href="#37933595">next</a><span>|</span><label class="collapse" for="c-37937196">[-]</label><label class="expand" for="c-37937196">[4 more]</label></div><br/><div class="children"><div class="content">Helm templates literally make me nauseous.  I don&#x27;t mean literally in the smart-alecky, Zoomer sense.  I mean actual nausea.<p>It disturbs me that Helm templates became a defacto standard for k8s.  Something went very wrong there.</div><br/><div id="37937424" class="c"><input type="checkbox" id="c-37937424" checked=""/><div class="controls bullet"><span class="by">edrxty</span><span>|</span><a href="#37937163">root</a><span>|</span><a href="#37937196">parent</a><span>|</span><a href="#37933595">next</a><span>|</span><label class="collapse" for="c-37937424">[-]</label><label class="expand" for="c-37937424">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s especially frustrating because so many projects only ship with helm chart documentation for their containers.<p>If you&#x27;re not doing a unicorn style deployment (100% of users) then you&#x27;re SOL.<p>K8s is probably the best&#x2F;closest thing we have to a workable service &quot;package manager&quot; for server environments.  It&#x27;s a fairly reasonable way of packaging and deploying random stuff to random servers in a sustainable and secure fashion when all you&#x27;re trying to manage is a small dev pipeline or a prototype&#x2F;homelab type setup.  Instead it feels like the community is trying to skip right over some of the most beneficial use cases for the tech and go straight to nonsense unicorn land.</div><br/><div id="37939174" class="c"><input type="checkbox" id="c-37939174" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#37937163">root</a><span>|</span><a href="#37937424">parent</a><span>|</span><a href="#37933595">next</a><span>|</span><label class="collapse" for="c-37939174">[-]</label><label class="expand" for="c-37939174">[2 more]</label></div><br/><div class="children"><div class="content">I like the idea of &quot;package manager&quot; for servers.  Could that not be docker &#x2F; nix plus another layer?<p>I think the issue is that for <i>almost everyone</i> tens of servers is the sweet spot.  Most teams and even most companies don&#x27;t need to manage more than tens of servers (how many teams even in large companies actually use or even touch more than 100 servers in prod?)<p>But kubernetes can scale to thousands.<p>The leap past those 2 orders of magnitude chnages the game and makes the seeet spot out of reach for the majority.  It&#x27;s like we are taking F1 racing cars on our daily commute and stopping off for groceries</div><br/><div id="37939256" class="c"><input type="checkbox" id="c-37939256" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#37937163">root</a><span>|</span><a href="#37939174">parent</a><span>|</span><a href="#37933595">next</a><span>|</span><label class="collapse" for="c-37939256">[-]</label><label class="expand" for="c-37939256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the issue is that for almost everyone tens of servers is the sweet spot<p>No for almost everyone one server with some packages installed is the sweet spot.<p>&gt; What if it goes down?<p>You users will survive a little downtime, if it happens at the right time they wont even know<p>&gt; But containers<p>For this use case? A solution looking for a problem<p>&gt; Why?<p>Don&#x27;t be a company with more servers than users</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37933595" class="c"><input type="checkbox" id="c-37933595" checked=""/><div class="controls bullet"><span class="by">RetroTechie</span><span>|</span><a href="#37937163">prev</a><span>|</span><a href="#37938549">next</a><span>|</span><label class="collapse" for="c-37933595">[-]</label><label class="expand" for="c-37933595">[5 more]</label></div><br/><div class="children"><div class="content">Once you have a certain size codebase &#x2F; ecosystem, removing unnecessary complexity from it is a much harder skill than adding more.<p>Some &#x27;law&#x27; about always something, somewhere depending on whatever got built previously. Documented or not.<p>Of course there&#x27;s the rewrite. Read: starting over with a <i>better</i> design than existing one. Yet another skill that few mortals possess when it comes to intricate machinery like an OS.<p>And then a whole bunch of functionality must be re-implemented. Which takes countless human-hours (always in short supply). If not years.<p>That leaves the option to replace pieces one by one with better ones, leaving overall structure (mostly) in place &#x2F; working. Oh wait, that&#x27;s what is usually done. Rip something out, plug the hole, move on.</div><br/><div id="37937402" class="c"><input type="checkbox" id="c-37937402" checked=""/><div class="controls bullet"><span class="by">spacecadet</span><span>|</span><a href="#37933595">parent</a><span>|</span><a href="#37938791">next</a><span>|</span><label class="collapse" for="c-37937402">[-]</label><label class="expand" for="c-37937402">[2 more]</label></div><br/><div class="children"><div class="content">I worked with an engineer once who spent most of their time refactoring and cleaning up. They explained over beers how they wanted to spend more time being net-negative. After they left, sure enough, removed more code than ever added and was the best member of the team. That stuck with me and I also now strive, where it makes sense, to remove before create.</div><br/><div id="37938497" class="c"><input type="checkbox" id="c-37938497" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#37933595">root</a><span>|</span><a href="#37937402">parent</a><span>|</span><a href="#37938791">next</a><span>|</span><label class="collapse" for="c-37938497">[-]</label><label class="expand" for="c-37938497">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I do the same. I always get reminded of a quote which compares adding lines of code to a codebase being similar to adding weight to an aircraft.</div><br/></div></div></div></div><div id="37938791" class="c"><input type="checkbox" id="c-37938791" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#37933595">parent</a><span>|</span><a href="#37937402">prev</a><span>|</span><a href="#37936853">next</a><span>|</span><label class="collapse" for="c-37938791">[-]</label><label class="expand" for="c-37938791">[1 more]</label></div><br/><div class="children"><div class="content">Ah, you&#x27;re thinking of Hyrum&#x27;s Law.<p>Hyrum&#x27;s Law in comic form: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div></div></div><div id="37938549" class="c"><input type="checkbox" id="c-37938549" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#37933595">prev</a><span>|</span><a href="#37938603">next</a><span>|</span><label class="collapse" for="c-37938549">[-]</label><label class="expand" for="c-37938549">[1 more]</label></div><br/><div class="children"><div class="content">I could not have articulated it like this, but looking back on my career i can see it playing out, in my own work and the work of others.<p>But it&#x27;s probably worth pointing out that while cathedrals are built, with one architect&#x27;s vision, not all people are capable of envisioning a cathedral. Many see only ugly 4-walled-flat-roof sprawl. They might build it really well, but its still sprawl.<p>Equally, things improve with practice and time. My early work may be &quot;single vision&quot;, but I&#x27;m more skilled now, my vision is clearer and my execution of that vision is improved.<p>Wonderful software, like wonderful buildings, are wonderful partly because it is not common.<p>Good vision is partly driven by talent, partly by experience - good software is the result of both great architecture and a capable team willing to work in service of that vision.<p>Of course all good builders want to be architects, and few want to be remembered as the successor to someone else&#x27;s vision.</div><br/></div></div><div id="37938603" class="c"><input type="checkbox" id="c-37938603" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37938549">prev</a><span>|</span><a href="#37937000">next</a><span>|</span><label class="collapse" for="c-37938603">[-]</label><label class="expand" for="c-37938603">[1 more]</label></div><br/><div class="children"><div class="content">Meh, this does the rounds every so often, but the fact remains that auto* work a lot better than everything that&#x27;s supposed to replace them, especially if your system is even slightly obscure. Want to build a unix program under SUA? If it uses autoconf, you&#x27;re fine, just push the button and it works; at worst if the release is older than your OS then you may have to replace two files, a standard and well-known procedure. Want to build varnish under SUA? Lol, good luck.<p>The problem of duplicated dependencies in linux comes from doing too little splitting of packages, not too much. You get a lot less of this on a platform like nodejs where people properly split up functions into much smaller libraries, because the dependency management is much more effective. (Of course people on HN moan more when you do that, for no discernible reason, as if having 1000 dependencies is somehow morally inferior to having 10).<p>Ultimately a certain amount of duplication is necessary and healthy. There is a nugget of real criticism to be found here - the &quot;Bazaar&quot; nature of open-source OSes makes it very difficult to deprecate and remove anything, where a more centrally-managed system is able to make decisions like &quot;we&#x27;ll stop using or supporting Perl from 2020&quot; and enforce them. But &quot;herp derp 122 packages herp derp 22 tests&quot; is not what we should be focusing on.</div><br/></div></div><div id="37937000" class="c"><input type="checkbox" id="c-37937000" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#37938603">prev</a><span>|</span><a href="#37939781">next</a><span>|</span><label class="collapse" for="c-37937000">[-]</label><label class="expand" for="c-37937000">[3 more]</label></div><br/><div class="children"><div class="content">I love this article for its critical perspective. We need more of that if we want to move past the rather unimpressive status quo.<p>But, the reason for the described situation is no mystery, and may not have that much to do with the bazaar. Programmers like to reinvent stuff, as well as use what they’re familiar with. Those two facts alone explain a lot of the criticisms.<p>I suppose, in a properly managed cathedral, these tendencies might be somewhat mitigated. But how many cathedrals are properly managed, or have the luxury to “do things right”?<p>The whole “worse is better” debate is relevant here. Worse may not be better because it’s actually better, but because it’s more easily achievable, particularly by people without infinite time, expertise, and money.</div><br/><div id="37937833" class="c"><input type="checkbox" id="c-37937833" checked=""/><div class="controls bullet"><span class="by">harimau777</span><span>|</span><a href="#37937000">parent</a><span>|</span><a href="#37937997">next</a><span>|</span><label class="collapse" for="c-37937833">[-]</label><label class="expand" for="c-37937833">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add onto this that it is in the programmer&#x27;s best interest to reinvent stuff in order to improve their technical skills.<p>It would be interesting to see a company provide professional development so that programmers feel less pressure to do so in their day to day jobs.</div><br/></div></div><div id="37937997" class="c"><input type="checkbox" id="c-37937997" checked=""/><div class="controls bullet"><span class="by">vba616</span><span>|</span><a href="#37937000">parent</a><span>|</span><a href="#37937833">prev</a><span>|</span><a href="#37939781">next</a><span>|</span><label class="collapse" for="c-37937997">[-]</label><label class="expand" for="c-37937997">[1 more]</label></div><br/><div class="children"><div class="content">A thing that seems incredibly rare these days, in my perceptual bubble anyway, is an online address form that lets you enter US states on the keyboard with the standard postal abbreviation.</div><br/></div></div></div></div><div id="37939781" class="c"><input type="checkbox" id="c-37939781" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#37937000">prev</a><span>|</span><a href="#37938332">next</a><span>|</span><label class="collapse" for="c-37939781">[-]</label><label class="expand" for="c-37939781">[1 more]</label></div><br/><div class="children"><div class="content">This is a poorly-thought-out screed by longtime BSD hacker Poul-Henning Kamp, a.k.a., someone who should freaking know better.<p>Autoconf doesn&#x27;t exist because &quot;the bazaar&quot; is full of lazy incompetents and only cathedrals have halfway decent design. It comes from the bad old days when &quot;open&quot; meant &quot;spec documents are available under RAND terms&quot; and had little to do with what we now call open source. Unix had splintered into lots of different idiosyncratic systems, each with its own configuration, and the GNU stuff had to run on all of them. Autoconf provided a portable way to paper over all those differences.<p>The same with libtool. The Unix splintering had already happened when shared libs became relevant for Unix. There wasn&#x27;t even agreement among the various vendors on how to <i>implement</i> shared libs! For example, how do you resolve the fact that a dynamic&#x2F;shared library could be loaded anywhere into a process&#x27;s address space, making absolute pointers inside the library invalid? There were two main schools of thought:<p>* when linking the library, replace all exported pointers with placeholder values. Then when the dynamic linker loads the library, it swizzles the placeholder values back into pointers. (Windows)<p>* use position-independent code, taking advantage of relative jumps, calls, and data accesses to create an object file that can be loaded anywhere. (ELF)<p>I&#x27;ve seen some half-measures as well:<p>* give each library a fixed address where it&#x27;s loaded every time (Linux a.out)<p>* punt on symbol resolution; hand the programmer a base address and have them call into the library at fixed offsets from the base (AmigaOS through 3.x)<p>Each of the implementation strategies for shared libs required a different constellation of compiler and linker flags. Again, libtool papered over these and made it tractable to write shared libs for a variety of operating systems. It is true that these days, compiling with &#x27;gcc -fPIC&#x27; and linking with &#x27;gcc -shared&#x27; will probably do what you want. But that assumes a modern enough OS and toolchain, something that GNU couldn&#x27;t and still cannot in some cases necessarily assume.<p>The purpose of both these programs is to portably solve problems that were created by multiple, competing cathedrals. I don&#x27;t <i>like</i> Autoconf or Libtool. They&#x27;re unholy messes. But they&#x27;re largely that way out of necessity considering the problems they solve, problems which would otherwise be nigh-intractable -- not because their developers were lazy or incompetent.<p>And no, Meson does not solve the same problem, it punts on working on any OS that&#x27;s insufficiently modern.<p>The neat thing about  the open source bazaar is that it can produce reference implementations for things everybody agrees should be in the finished product, reducing the friction of competing implementations. An example is the 86open consortium, an effort by various proprietary x86 Unix vendors (mainly BSDi, Sun, and SCO) to agree on a single binary standard for x86 Unixes. Well, the vendors got together fully expecting to get into the weeds with meetings and committees and stuff... but what they found was all their products had Linux&#x2F;ELF kernel personalities already built in. So they declared Linux&#x2F;ELF to be the binary standard and disbanded the 86open initiative!</div><br/></div></div><div id="37938332" class="c"><input type="checkbox" id="c-37938332" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#37939781">prev</a><span>|</span><label class="collapse" for="c-37938332">[-]</label><label class="expand" for="c-37938332">[2 more]</label></div><br/><div class="children"><div class="content">Has anyone tried developing a project to machine translate all these autoconf&#x2F;etc configurations to something more modern like Meson that&#x27;s been able to learn from past mistakes?  Like obviously there&#x27;s many hacks over the many years that wouldn&#x27;t be digestible and able to be translated but surely it can be done on a best-effort basis.</div><br/><div id="37938528" class="c"><input type="checkbox" id="c-37938528" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37938332">parent</a><span>|</span><label class="collapse" for="c-37938528">[-]</label><label class="expand" for="c-37938528">[1 more]</label></div><br/><div class="children"><div class="content">Yes, these things have been done, but largely end up being abandoned. If the maintainer doesn&#x27;t want to port to Meson or whatever your alternative is, they&#x27;re pretty useless - your &quot;best effort&quot; port will break arbitrarily. If the maintainer does want to port to Meson, it&#x27;s probably easier for them to write what the build should be from scratch than pull anything out of autoconf.</div><br/></div></div></div></div></div></div></div></div></div></body></html>