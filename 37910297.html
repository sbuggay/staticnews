<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697533267604" as="style"/><link rel="stylesheet" href="styles.css?v=1697533267604"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.sligocki.com//2023/10/16/bb-3-3-is-hard.html">BB(3, 3) is Hard</a> <span class="domain">(<a href="https://www.sligocki.com">www.sligocki.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>67 comments</span></div><br/><div><div id="37910942" class="c"><input type="checkbox" id="c-37910942" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#37910951">next</a><span>|</span><label class="collapse" for="c-37910942">[-]</label><label class="expand" for="c-37910942">[2 more]</label></div><br/><div class="children"><div class="content">Probably more accurate to say that BB(3, 3) <i>looks</i> hard; that is, it encodes a Collatz-type problem, and many Collatz-type problems are very hard to solve (including, of course, the classic Collatz conjecture).<p>However, this instance might not necessarily be hard. For one, the behaviour seems to be heavily biased; for another, we only have to consider a single trajectory instead of the trajectories for all integers (as with the classic Collatz problem).</div><br/><div id="37911169" class="c"><input type="checkbox" id="c-37911169" checked=""/><div class="controls bullet"><span class="by">sligocki</span><span>|</span><a href="#37910942">parent</a><span>|</span><a href="#37910951">next</a><span>|</span><label class="collapse" for="c-37911169">[-]</label><label class="expand" for="c-37911169">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve oversimplified a bit with this title. The more accurate statement is in the first paragraph of the article: &quot;Solving the BB(3, 3) problem is at least as hard as solving this Collatz-like problem.&quot;<p>I also agree somewhat on the one trajectory vs. multiple trajectories point. However, note that (assuming we live in the world where this TM never halts) proving a single trajectory in this system is &quot;harder&quot; than a single trajectory in the classic Collatz conjecture. Specifically, (assuming the Collatz conjecture is true) proving any single trajectory is &quot;simply&quot; a finite computation. However, proving a single trajectory from the article requires showing that it never halts which will require some more fancy math!<p>Anywho, I don&#x27;t want to oversell it. This does not prove that BB(3, 3) requires proving the Collatz conjecture or any existing well-studied open problem in Math. But I think it&#x27;s sort of a &quot;second best&quot; result: As hard a problem akin to a well studied problem.<p>How hard is this Collatz-like problem? Well, let&#x27;s see if anyone can solve it :)</div><br/></div></div></div></div><div id="37910951" class="c"><input type="checkbox" id="c-37910951" checked=""/><div class="controls bullet"><span class="by">tybug</span><span>|</span><a href="#37910942">prev</a><span>|</span><a href="#37910647">next</a><span>|</span><label class="collapse" for="c-37910951">[-]</label><label class="expand" for="c-37910951">[33 more]</label></div><br/><div class="children"><div class="content">I&#x27;m hoping someone can enlighten me here. My understanding is that there is a turing machine of 748 states [0], which halts iff ZFC is inconsistent (Thm 1). But this machine is a &quot;physical&quot; object, in the sense that we can materialize it on a computer and run it. Though we don&#x27;t have the computing power for this currently, there is nothing in principle stopping us from running this machine for BB(748) steps: if it halts, we have proven by Thm 1 that ZFC is inconsistent. If not, we have similarly proven that ZFC is consistent.<p>I want to stress that this is key to my confusion. This is not just some abstract result; this is a computation that <i>we can perform</i> and draw a real value from.<p>Of course, I&#x27;ll now fall back on godel&#x27;s second incompleteness theorem and say that one cannot prove, inside ZFC, that ZFC is consistent. But if the above turing machine halts, then we proved ZFC is consistent - a contradiction!<p>Where is the mistake here? My current guess is there is a technical detail in the proof of Thm 1 which uses a stronger metatheory than ZFC to show that the 758-state turing machine halts iff ZFC is inconsistent. This is not a contradiction, because yes, we can run the turing machine for BB(748) steps, but that will only show that ZFC+ proves ZFC is consistent, which is already well known - ZFC + there exists an inaccessible cardinal does the job.<p>However, I haven&#x27;t looked at the paper in detail to know whether this is the case. Does anybody who has thought deeply about this problem have insight to offer?<p>[0] <a href="https:&#x2F;&#x2F;www.ingo-blechschmidt.eu&#x2F;assets&#x2F;bachelor-thesis-undecidability-bb748.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ingo-blechschmidt.eu&#x2F;assets&#x2F;bachelor-thesis-unde...</a></div><br/><div id="37911067" class="c"><input type="checkbox" id="c-37911067" checked=""/><div class="controls bullet"><span class="by">sligocki</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37911027">next</a><span>|</span><label class="collapse" for="c-37911067">[-]</label><label class="expand" for="c-37911067">[3 more]</label></div><br/><div class="children"><div class="content">The issue is the &quot;run the turing machine for BB(748) steps&quot; part. We don&#x27;t know what BB(748) is. If the god of busy beavers came to us and told us that value, then we could (in theory) run the TM that long and just like you say, that would prove whether ZFC is consistent. But in order for us mere mortals to compute BB(748) we would effectively need to figure out if this specific 748-state TM ever halted (along with all the other 748-state TMs).</div><br/><div id="37911602" class="c"><input type="checkbox" id="c-37911602" checked=""/><div class="controls bullet"><span class="by">kevinventullo</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911067">parent</a><span>|</span><a href="#37911308">next</a><span>|</span><label class="collapse" for="c-37911602">[-]</label><label class="expand" for="c-37911602">[1 more]</label></div><br/><div class="children"><div class="content">To put it another way, an oracle telling us an upper bound on BB(748) would be strictly more powerful than an oracle telling us ZFC is consistent.</div><br/></div></div><div id="37911308" class="c"><input type="checkbox" id="c-37911308" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911067">parent</a><span>|</span><a href="#37911602">prev</a><span>|</span><a href="#37911027">next</a><span>|</span><label class="collapse" for="c-37911308">[-]</label><label class="expand" for="c-37911308">[1 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t need to know BB(748), just an upper bound on BB(748).<p>... which means we can&#x27;t prove any upper bound on BB(748) within ZFC.</div><br/></div></div></div></div><div id="37911027" class="c"><input type="checkbox" id="c-37911027" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37911067">prev</a><span>|</span><a href="#37910993">next</a><span>|</span><label class="collapse" for="c-37911027">[-]</label><label class="expand" for="c-37911027">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is not just some abstract result; this is a computation that we can perform and draw a real value from.<p>No, this isn&#x27;t a computation we can perform. There isn&#x27;t enough energy in the visible Universe we can use to increase entropy to run this computation.<p>Even if we built a computer that would use all matter and energy in the Universe, even if the computer only had one task and even if it ran the task as efficiently as is physically possible, it would not complete the computation.<p>So this is kinda where mathematics gets disconnected from physics and reality in that we can talk and reason about those things but they no longer have physical meaning.</div><br/><div id="37911524" class="c"><input type="checkbox" id="c-37911524" checked=""/><div class="controls bullet"><span class="by">thethimble</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911027">parent</a><span>|</span><a href="#37910993">next</a><span>|</span><label class="collapse" for="c-37911524">[-]</label><label class="expand" for="c-37911524">[4 more]</label></div><br/><div class="children"><div class="content">But if the universe is infinitely large then any finite thing should fit in it, right? Or are we saying that BB(748) can be infinite?</div><br/><div id="37911799" class="c"><input type="checkbox" id="c-37911799" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911524">parent</a><span>|</span><a href="#37911854">next</a><span>|</span><label class="collapse" for="c-37911799">[-]</label><label class="expand" for="c-37911799">[1 more]</label></div><br/><div class="children"><div class="content">Even if the universe is infinite, you can&#x27;t use its infiniteness because you can&#x27;t communicate partial results across infinite distances.<p>It is natural to think that the more time you have, the further you can travel to, potentially. But when it comes to the universe, the opposite is actually true. The more time passes, the less of the universe you can reach. A lot of universe you can see today is actually not at all reachable, meaning even if you shine the light back it will never reach the destination.</div><br/></div></div><div id="37911854" class="c"><input type="checkbox" id="c-37911854" checked=""/><div class="controls bullet"><span class="by">diogenes4</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911524">parent</a><span>|</span><a href="#37911799">prev</a><span>|</span><a href="#37910993">next</a><span>|</span><label class="collapse" for="c-37911854">[-]</label><label class="expand" for="c-37911854">[2 more]</label></div><br/><div class="children"><div class="content">Spacetime (might be) infinitely large, but that doesn&#x27;t imply that there is infinite matter or energy.<p>That said, this is kind of a dumb argument because far lower k values have lower BB(k) values already exceed the apparent information value of the universe at any given instant. Maybe there is infinite energy and matter, but that&#x27;s also irrelevant if we can&#x27;t perceive more than a finite subset of it.<p>Edit: well, i guess what would matter would be the information value of time, multiplied by enough bits to store the machine—I&#x27;m not sure i&#x27;m literate enough in the area to compute that. But, assuming that the heat death of the universe reaches a single (possibly compressed) end-state, it should still be finite—it&#x27;s seeming quantized, anyway.</div><br/><div id="37912127" class="c"><input type="checkbox" id="c-37912127" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911854">parent</a><span>|</span><a href="#37910993">next</a><span>|</span><label class="collapse" for="c-37912127">[-]</label><label class="expand" for="c-37912127">[1 more]</label></div><br/><div class="children"><div class="content">It does not matter how much energy is there available in the Universe. Even if there is infinite amount of it, you can&#x27;t still use it because only finite amount can ever be reached &#x2F; affected by any single observer. Only finite amount of universe can ever reach any single observer.<p>So for example, there is a limit on the mass of the computer that can be constructed and still send its result to a single spot in space in the future. And the longer you wait, the smaller the limit because less and less of the universe is available to you to build the computer.</div><br/></div></div></div></div></div></div></div></div><div id="37910993" class="c"><input type="checkbox" id="c-37910993" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37911027">prev</a><span>|</span><a href="#37912039">next</a><span>|</span><label class="collapse" for="c-37910993">[-]</label><label class="expand" for="c-37910993">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Of course, I&#x27;ll now fall back on godel&#x27;s second incompleteness theorem and say that one cannot prove, inside ZFC, that ZFC is consistent. But if the above turing machine halts, then we proved ZFC is consistent - a contradiction!<p>No, the machine halts iff ZFC is <i>inconsistent</i> -- as you correctly stated up top.  Somewhere along the way you got this reversed, looks like.  There&#x27;s the problem.</div><br/><div id="37911039" class="c"><input type="checkbox" id="c-37911039" checked=""/><div class="controls bullet"><span class="by">tybug</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37910993">parent</a><span>|</span><a href="#37911249">next</a><span>|</span><label class="collapse" for="c-37911039">[-]</label><label class="expand" for="c-37911039">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, I misstated this - but I don&#x27;t think this is fatal. The other sibling commenters pointed out the real issue with my thinking.<p>The argument goes the same even though I misspoke here. If the machine {halts, runs forever} then ZFC is consistent. But this is a contradiction; so ZFC must be inconsistent. Tada, I have an inconsistency proof!<p>That was the implied next step which made me think my logic was clearly incorrect (which, it was).</div><br/><div id="37911218" class="c"><input type="checkbox" id="c-37911218" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911039">parent</a><span>|</span><a href="#37911990">next</a><span>|</span><label class="collapse" for="c-37911218">[-]</label><label class="expand" for="c-37911218">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simpler than this still. If it runs forever (likely), then you will never be able to say anything about ZFC.<p>If you see it halt, ZFC is inconsistent. If you never see it halt, you CAN&#x27;T conclude anything.<p>But we could already do that under Gödel incompleteness, so there&#x27;s nothing unusual there!<p>If you write down random proofs on paper and find a correct proof that leads to contradiction, you&#x27;ve proved ZFC inconsistent, without using BB. If you keep trying forever and never find one, you&#x27;ll never be able to conclude anything at any point, just like with watching the machine run</div><br/><div id="37911251" class="c"><input type="checkbox" id="c-37911251" checked=""/><div class="controls bullet"><span class="by">l33t7332273</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911218">parent</a><span>|</span><a href="#37911990">next</a><span>|</span><label class="collapse" for="c-37911251">[-]</label><label class="expand" for="c-37911251">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If it runs forever (likely), then you will never be able to say anything about ZFC.<p>But if you run it for BB(754) many steps, you will know.</div><br/><div id="37911303" class="c"><input type="checkbox" id="c-37911303" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911251">parent</a><span>|</span><a href="#37911990">next</a><span>|</span><label class="collapse" for="c-37911303">[-]</label><label class="expand" for="c-37911303">[1 more]</label></div><br/><div class="children"><div class="content">Yep. But I think it&#x27;s easy to show that this is circular, since you can&#x27;t know BB(754) without knowing whether it runs forever.<p>And you can&#x27;t prove that it&#x27;ll run forever without seeing it go past BB(754) and still keep going<p>BB(754) is X if ZFC is consistent, Y otherwise<p>Since you can&#x27;t prove that ZFC is consistent (only disprove), you can&#x27;t know BB(754), which is the thing we were trying to use to determine whether ZFC is consistent in the first place!<p>The definition doesn&#x27;t make it obvious, but this is just the same as plain Gödel incompleteness, we can&#x27;t get any extra info about ZFC even in principle (unless we happen to see it halt, by chance)</div><br/></div></div></div></div></div></div><div id="37911990" class="c"><input type="checkbox" id="c-37911990" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911039">parent</a><span>|</span><a href="#37911218">prev</a><span>|</span><a href="#37911249">next</a><span>|</span><label class="collapse" for="c-37911990">[-]</label><label class="expand" for="c-37911990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re right, I misstated this - but I don&#x27;t think this is fatal.<p>It is crucial at this types of results, when you search for a proof.<p>There are a lot of things true, better make a table of it, instead of a wall of text:<p><pre><code>  - If you observe the machine halting, ZFC is inconsistent. 
  - If the machine hasn&#x27;t halted yet, you don&#x27;t know if ZFC is consistent or not.

  - If ZFC is inconsistent, the machine will eventually halt. (You have an upper bound for this, given a contradiction.)
  - If ZFC is consistent, then the machine won&#x27;t halt ever.
</code></pre>
Also it is consistent with ZFC that this machine <i>halts</i>, since it is consistent with ZFC that ZFC has a contradiction. This means that if ZFC happens to be consistent, and you work in ZFC+contradiction, then you will <i>know</i> that your machine will eventually halt, yet it won&#x27;t halt ever.</div><br/></div></div></div></div><div id="37911249" class="c"><input type="checkbox" id="c-37911249" checked=""/><div class="controls bullet"><span class="by">l33t7332273</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37910993">parent</a><span>|</span><a href="#37911039">prev</a><span>|</span><a href="#37912039">next</a><span>|</span><label class="collapse" for="c-37911249">[-]</label><label class="expand" for="c-37911249">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think that’s it. I think it’s easy to take such a machine and make a new one that halts iff ZFC is consistent.<p>Call the machine that halts iff ZFC is inconsistent A. Now consider the machine which computes the following algorithm:<p>Run A BB(754) times. If A halts, then run forever, else halt.<p>If A halts then our machine runs forever, and vice versa. Thus, our machine halts when ZFC is consistent and our machine runs forever when A halts, so ZFC is consistent iff our machine halts.<p>“Halts” doesn’t seem like a real word after writing that.</div><br/><div id="37911288" class="c"><input type="checkbox" id="c-37911288" checked=""/><div class="controls bullet"><span class="by">meithecatte</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911249">parent</a><span>|</span><a href="#37912039">next</a><span>|</span><label class="collapse" for="c-37911288">[-]</label><label class="expand" for="c-37911288">[2 more]</label></div><br/><div class="children"><div class="content">How do you make the new machine compute BB(754)? BB is the canonical example of an uncomputable function, precisely because you can decide the halting problem if you can compute it (or any upper bound). Granted, BB may be computed for specific arguments, as OP mentions for 1–4, but the existence of the ZFC-dependent machine is, at least to me, a very good argument that the boundary of what&#x27;s possible is much lower.</div><br/><div id="37911403" class="c"><input type="checkbox" id="c-37911403" checked=""/><div class="controls bullet"><span class="by">l33t7332273</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911288">parent</a><span>|</span><a href="#37912039">next</a><span>|</span><label class="collapse" for="c-37911403">[-]</label><label class="expand" for="c-37911403">[1 more]</label></div><br/><div class="children"><div class="content">Oh, sure. I was just pointing out that the hardness is in determining the busy beaver number and that it didn’t matter if your algorithm halts iff ZFC is consistent or if it’s an algorithm that halts iff ZFC is inconsistent.</div><br/></div></div></div></div></div></div></div></div><div id="37912039" class="c"><input type="checkbox" id="c-37912039" checked=""/><div class="controls bullet"><span class="by">generic92034</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37910993">prev</a><span>|</span><a href="#37910970">next</a><span>|</span><label class="collapse" for="c-37912039">[-]</label><label class="expand" for="c-37912039">[1 more]</label></div><br/><div class="children"><div class="content">It is funny to me that you are going for BB(748) in this context when you could go for the much, much, ... lower number BB(745), as outlined in [0].<p>[0]: <a href="https:&#x2F;&#x2F;www.ingo-blechschmidt.eu&#x2F;assets&#x2F;bachelor-thesis-undecidability-bb748.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ingo-blechschmidt.eu&#x2F;assets&#x2F;bachelor-thesis-unde...</a></div><br/></div></div><div id="37910970" class="c"><input type="checkbox" id="c-37910970" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37912039">prev</a><span>|</span><a href="#37911070">next</a><span>|</span><label class="collapse" for="c-37910970">[-]</label><label class="expand" for="c-37910970">[1 more]</label></div><br/><div class="children"><div class="content">The only problem is that proving it halts is &quot;easy&quot; - run the program, wait a few million years, it halts. Yey.<p>Proving it doesn&#x27;t halt is much harder, since you can run it for TREE(3) steps if you want, that&#x27;s still not proof it won&#x27;t halt in TREE(3)+1 steps.<p>So in a way, it&#x27;s not possible to &quot;just run it&quot;, sadly.</div><br/></div></div><div id="37910978" class="c"><input type="checkbox" id="c-37910978" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37911070">prev</a><span>|</span><a href="#37910974">next</a><span>|</span><label class="collapse" for="c-37910978">[-]</label><label class="expand" for="c-37910978">[4 more]</label></div><br/><div class="children"><div class="content">So… what if BB(748) is uncomputable? Or rather, didn’t you just prove that it is?</div><br/><div id="37911030" class="c"><input type="checkbox" id="c-37911030" checked=""/><div class="controls bullet"><span class="by">tybug</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37910978">parent</a><span>|</span><a href="#37910974">next</a><span>|</span><label class="collapse" for="c-37911030">[-]</label><label class="expand" for="c-37911030">[3 more]</label></div><br/><div class="children"><div class="content">I suppose I did!<p>I was having a hard time reconciling this with the intuition that BB(n) is in principle &quot;computable&quot; (colloquially speaking) for any n - my thinking went that if I want to compute BB(n), I can enumerate turing machines and run them until they halt, since infinitely looping machines are excluded from BB(n). But of course I have now reduced this to the halting problem! How do you know when you&#x27;re &quot;done&quot; for that n? You don&#x27;t.<p>Thanks to you and sibling commenters.</div><br/><div id="37911062" class="c"><input type="checkbox" id="c-37911062" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911030">parent</a><span>|</span><a href="#37911465">next</a><span>|</span><label class="collapse" for="c-37911062">[-]</label><label class="expand" for="c-37911062">[1 more]</label></div><br/><div class="children"><div class="content">Similarly, if you know BB(n), you can use it to solve the halting problem for Turing machines up to that size.</div><br/></div></div><div id="37911465" class="c"><input type="checkbox" id="c-37911465" checked=""/><div class="controls bullet"><span class="by">kuboble</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911030">parent</a><span>|</span><a href="#37911062">prev</a><span>|</span><a href="#37910974">next</a><span>|</span><label class="collapse" for="c-37911465">[-]</label><label class="expand" for="c-37911465">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the easier proof that BB(n) isn&#x27;t computable something like<p>- assume BB is computable<p>- there exist a TM called X that computes the function<p>- it has K states<p>- X(K+1) produces BB(K+1) but from the definition of BB our machine cannot produce a result higher than BB(K).</div><br/></div></div></div></div></div></div><div id="37910974" class="c"><input type="checkbox" id="c-37910974" checked=""/><div class="controls bullet"><span class="by">hakuseki</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37910978">prev</a><span>|</span><a href="#37911080">next</a><span>|</span><label class="collapse" for="c-37910974">[-]</label><label class="expand" for="c-37910974">[5 more]</label></div><br/><div class="children"><div class="content">&gt; there is nothing in principle stopping us from running this machine for BB(748) steps<p>How would we compute the value of BB(748)?</div><br/><div id="37911045" class="c"><input type="checkbox" id="c-37911045" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37910974">parent</a><span>|</span><a href="#37911080">next</a><span>|</span><label class="collapse" for="c-37911045">[-]</label><label class="expand" for="c-37911045">[4 more]</label></div><br/><div class="children"><div class="content">Computing BB(748) would be best, but if we could get an upper-bound estimate that&#x27;s reasonably close, that would suffice.</div><br/><div id="37911269" class="c"><input type="checkbox" id="c-37911269" checked=""/><div class="controls bullet"><span class="by">meithecatte</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911045">parent</a><span>|</span><a href="#37911172">next</a><span>|</span><label class="collapse" for="c-37911269">[-]</label><label class="expand" for="c-37911269">[1 more]</label></div><br/><div class="children"><div class="content">Do note that any function f(n) that is always (or even just eventually always) greater than BB(n), is uncomputable, for very similar reasons.</div><br/></div></div><div id="37911172" class="c"><input type="checkbox" id="c-37911172" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911045">parent</a><span>|</span><a href="#37911269">prev</a><span>|</span><a href="#37911080">next</a><span>|</span><label class="collapse" for="c-37911172">[-]</label><label class="expand" for="c-37911172">[2 more]</label></div><br/><div class="children"><div class="content">Reaching a &quot;reasonably close&quot; upper bound estimate wouldn&#x27;t provide <i>proof</i> ... probability maybe, but not proof.</div><br/><div id="37911330" class="c"><input type="checkbox" id="c-37911330" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911172">parent</a><span>|</span><a href="#37911080">next</a><span>|</span><label class="collapse" for="c-37911330">[-]</label><label class="expand" for="c-37911330">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;ve proved that a number is an upper bound on BB(748), then running for that many steps without halting means it has also run BB(748) steps without halting.</div><br/></div></div></div></div></div></div></div></div><div id="37911080" class="c"><input type="checkbox" id="c-37911080" checked=""/><div class="controls bullet"><span class="by">dandanua</span><span>|</span><a href="#37910951">parent</a><span>|</span><a href="#37910974">prev</a><span>|</span><a href="#37910647">next</a><span>|</span><label class="collapse" for="c-37911080">[-]</label><label class="expand" for="c-37911080">[3 more]</label></div><br/><div class="children"><div class="content">&gt; if it halts, we have proven by Thm 1 that ZFC is inconsistent. If not, we have similarly proven that ZFC is consistent.<p>The second part is wrong. We can&#x27;t physically check that a program runs forever - this requires an infinite amount of time.</div><br/><div id="37911262" class="c"><input type="checkbox" id="c-37911262" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911080">parent</a><span>|</span><a href="#37910647">next</a><span>|</span><label class="collapse" for="c-37911262">[-]</label><label class="expand" for="c-37911262">[2 more]</label></div><br/><div class="children"><div class="content">His point is if you know the value of BB(748) then you don&#x27;t have to wait forever, just BB(748) steps, as after that the Turing machine is guaranteed not to halt. The problem with his argument is that we don&#x27;t know the value of BB(748). Not only that, it is incomputable, which resolves the contradiction.</div><br/><div id="37911422" class="c"><input type="checkbox" id="c-37911422" checked=""/><div class="controls bullet"><span class="by">dandanua</span><span>|</span><a href="#37910951">root</a><span>|</span><a href="#37911262">parent</a><span>|</span><a href="#37910647">next</a><span>|</span><label class="collapse" for="c-37911422">[-]</label><label class="expand" for="c-37911422">[1 more]</label></div><br/><div class="children"><div class="content">Right, we don&#x27;t know the value BB(748), and moreover, &quot;knowing&quot; it is not enough, we would still need a proof that a certain number matches BB(748). And such a proof is not easier than a direct proof of ZFC consistency, I presume.<p>BTW, a value can&#x27;t be uncomputable, only a function can.</div><br/></div></div></div></div></div></div></div></div><div id="37910647" class="c"><input type="checkbox" id="c-37910647" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#37910951">prev</a><span>|</span><a href="#37910577">next</a><span>|</span><label class="collapse" for="c-37910647">[-]</label><label class="expand" for="c-37910647">[12 more]</label></div><br/><div class="children"><div class="content">Is this what we mean when we says BB are uncomputable? That as BB grows they incompass all of maths, requiring us to prove everything?</div><br/><div id="37910754" class="c"><input type="checkbox" id="c-37910754" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#37910647">parent</a><span>|</span><a href="#37910725">next</a><span>|</span><label class="collapse" for="c-37910754">[-]</label><label class="expand" for="c-37910754">[2 more]</label></div><br/><div class="children"><div class="content"><i>Sort of</i>. Uncomputable functions exist because the halting problem exists. So any function whose definition includes anything to do with halting also becomes uncomputable. e.g. BB is uncomputable because you have to determine all the TMs that would halt given n and m.<p>The entire rest of mathematics is smuggled into BB via the halting problem: you can write programs that only halt if arbitrary mathematical conjectures are true or false, so anything that wants to solve the halting problem or solve BB has to be able to know <i>all maths</i>[0]. Of course, this is possible because Turing-completeness <i>is</i> the boundary of computability. Anything that can have a computer in it is itself a computer.<p>[0] This isn&#x27;t actually the thing that makes halting undecidable. Undecidability comes from programs that &quot;pull themselves into the halting problem&quot; by only halting if a hypothetical halting problem decider would claim that they don&#x27;t halt.</div><br/><div id="37911214" class="c"><input type="checkbox" id="c-37911214" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910754">parent</a><span>|</span><a href="#37910725">next</a><span>|</span><label class="collapse" for="c-37911214">[-]</label><label class="expand" for="c-37911214">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can write programs that only halt if arbitrary mathematical conjectures are true or false<p>I don&#x27;t think this is quite right - you can write programs that halt iff arbitrary mathematical conjectures are provable (in a suitable system of logic&#x2F;axioms such as ZFC), but there are problems (such as questions about Turing machines with a halting problem oracle[0]) for which we can&#x27;t straightforwardly construct a program which halts iff they are true.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Oracle_machine#Oracles_and_halting_problems" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Oracle_machine#Oracles_and_hal...</a></div><br/></div></div></div></div><div id="37910725" class="c"><input type="checkbox" id="c-37910725" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#37910647">parent</a><span>|</span><a href="#37910754">prev</a><span>|</span><a href="#37910928">next</a><span>|</span><label class="collapse" for="c-37910725">[-]</label><label class="expand" for="c-37910725">[5 more]</label></div><br/><div class="children"><div class="content">Sort of.<p>There are math problems that we &quot;know&quot; we can&#x27;t prove or disprove, unless we can prove every statement both true and false (this is Godel&#x27;s first incompleteness theorem). If we can prove every statement both true and false then our proof system just sucks and proving something means nothing so we should choose another proof system where that&#x27;s not the case, so we assume we&#x27;re in the first case (there are math problems that we know we can&#x27;t prove or disprove). Incidentally Godel&#x27;s second incompleteness theorem is that we can&#x27;t ever prove we are in the first case.<p>And then ya, BB being incomputable means that as BB grows at some point they start to be able to encode programs that halt if and only if a problem we can&#x27;t prove or disprove is true. So we can&#x27;t prove that program does or doesn&#x27;t halt.<p>Now, technically, proving&#x2F;disproving something you can&#x27;t prove or disprove would be proving false, which in turn could be used to &quot;prove&quot; every statement, and would therefore &quot;encompass all maths&quot;, so what you said is in a sense correct. It&#x27;s a threshold condition though, and one that kicks in well before you have turing machines large enough to encode &quot;every&quot; math problem. And in fact there is no finite number of states sufficient to encode every math problem (I can just make longer and longer strings of arithmetic for instance)...</div><br/><div id="37910784" class="c"><input type="checkbox" id="c-37910784" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910725">parent</a><span>|</span><a href="#37910928">next</a><span>|</span><label class="collapse" for="c-37910784">[-]</label><label class="expand" for="c-37910784">[4 more]</label></div><br/><div class="children"><div class="content">So is this (BB) then just an exercise demonstrating our inability to reasonably solve the problem? 
I suppose what I’m asking is what is its significance? Or why does this matter? 
As a self taught programmer, I realize I have definite gaps in the more theoretical realms of computer science.</div><br/><div id="37910857" class="c"><input type="checkbox" id="c-37910857" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910784">parent</a><span>|</span><a href="#37911226">next</a><span>|</span><label class="collapse" for="c-37910857">[-]</label><label class="expand" for="c-37910857">[2 more]</label></div><br/><div class="children"><div class="content">The collatz conjecture isn&#x27;t a problem that we think is unsolvable, it probably (maybe even definitely?) has a solution. It is a problem that a lot of really good mathematicians have sunk a lot of time into and made basically no progress. Collectively the mathematical community has more or less decided that we don&#x27;t know how to even approach solving this kind of problem yet, and probably won&#x27;t be able to solve it in the foreseeable future.<p>This article is saying that solving for BB(3, 3) requires solving a collatz-conjecture like problem, so it&#x27;s probably also beyond our current abilities in mathematics. It&#x27;s not saying it&#x27;s unsolvable, just that we probably won&#x27;t figure out the solution anytime soon.<p>As for why solving BB(3, 3) matters... it doesn&#x27;t really. It&#x27;s just an intellectual curiosity. We&#x27;ve figured out some busy beaver numbers. We&#x27;ve proven some upper bounds on the biggest ones we can figure out, but there&#x27;s a big gap between what we&#x27;ve solved and what we&#x27;ve shown we can&#x27;t solve for. Making that gap smaller is something of a game.</div><br/><div id="37910919" class="c"><input type="checkbox" id="c-37910919" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910857">parent</a><span>|</span><a href="#37911226">next</a><span>|</span><label class="collapse" for="c-37910919">[-]</label><label class="expand" for="c-37910919">[1 more]</label></div><br/><div class="children"><div class="content">Got it. Thanks for adding context!</div><br/></div></div></div></div><div id="37911226" class="c"><input type="checkbox" id="c-37911226" checked=""/><div class="controls bullet"><span class="by">sligocki</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910784">parent</a><span>|</span><a href="#37910857">prev</a><span>|</span><a href="#37910928">next</a><span>|</span><label class="collapse" for="c-37911226">[-]</label><label class="expand" for="c-37911226">[1 more]</label></div><br/><div class="children"><div class="content">The Busy Beaver problem sits somewhere on the range from &quot;intellectual curiosity&quot; to &quot;lens that allows us to view the edges of uncomputability&quot;. I would guess that the majority of people doing work here are hobbyists (including myself). In fact, when Tibor Rado first introduced BB, he introduced it as the &quot;Busy Beaver Game&quot;, so it has had a playful energy since the beginning :)</div><br/></div></div></div></div></div></div><div id="37910928" class="c"><input type="checkbox" id="c-37910928" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#37910647">parent</a><span>|</span><a href="#37910725">prev</a><span>|</span><a href="#37910701">next</a><span>|</span><label class="collapse" for="c-37910928">[-]</label><label class="expand" for="c-37910928">[2 more]</label></div><br/><div class="children"><div class="content">Greatly simplifying, the most important result in comparability is “the halting problem”, which means we have no way of telling, for any program, if given some input it will halt or run forever.<p>After that, it’s not surprising there is some BB we can’t solve, and it’s interesting to investigate which we can, and can’t, solve.</div><br/><div id="37911089" class="c"><input type="checkbox" id="c-37911089" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37910647">root</a><span>|</span><a href="#37910928">parent</a><span>|</span><a href="#37910701">next</a><span>|</span><label class="collapse" for="c-37911089">[-]</label><label class="expand" for="c-37911089">[1 more]</label></div><br/><div class="children"><div class="content">Not &quot;for any program&quot;, but &quot;for an arbitrary program&quot;.<p>We can trivially prove that a program that always goes to the next step, without branching, always terminates. With more effort we can prove termination of certain segments with conditional jumps,  certain forms of recursion and loops, etc. This is not purely theoretic: e.g. EBPF programs in the Linux kernel are only admitted if the kernel can prove that they terminahe.<p>What we can&#x27;t do is to prove it in an arbitrary case, without putting limits on the program&#x27;s structure.</div><br/></div></div></div></div><div id="37910701" class="c"><input type="checkbox" id="c-37910701" checked=""/><div class="controls bullet"><span class="by">noqc</span><span>|</span><a href="#37910647">parent</a><span>|</span><a href="#37910928">prev</a><span>|</span><a href="#37910767">next</a><span>|</span><label class="collapse" for="c-37910701">[-]</label><label class="expand" for="c-37910701">[1 more]</label></div><br/><div class="children"><div class="content">If BB is a computable function, then you can solve the halting problem by running every turing machine with n states for BB(n), and the ones that don&#x27;t halt by then don&#x27;t halt at all.</div><br/></div></div></div></div><div id="37910577" class="c"><input type="checkbox" id="c-37910577" checked=""/><div class="controls bullet"><span class="by">throwawa14223</span><span>|</span><a href="#37910647">prev</a><span>|</span><a href="#37910765">next</a><span>|</span><label class="collapse" for="c-37910577">[-]</label><label class="expand" for="c-37910577">[2 more]</label></div><br/><div class="children"><div class="content">I appreciate the authors writing style. It helped me understand the subject without seeming verbose. That sweet spot can be difficult.</div><br/><div id="37911173" class="c"><input type="checkbox" id="c-37911173" checked=""/><div class="controls bullet"><span class="by">sligocki</span><span>|</span><a href="#37910577">parent</a><span>|</span><a href="#37910765">next</a><span>|</span><label class="collapse" for="c-37911173">[-]</label><label class="expand" for="c-37911173">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I&#x27;m so glad to hear!</div><br/></div></div></div></div><div id="37910765" class="c"><input type="checkbox" id="c-37910765" checked=""/><div class="controls bullet"><span class="by">diziet</span><span>|</span><a href="#37910577">prev</a><span>|</span><a href="#37911329">next</a><span>|</span><label class="collapse" for="c-37910765">[-]</label><label class="expand" for="c-37910765">[1 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;nickdrozd.github.io&#x2F;2020&#x2F;08&#x2F;13&#x2F;beeping-busy-beavers.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;nickdrozd.github.io&#x2F;2020&#x2F;08&#x2F;13&#x2F;beeping-busy-beavers....</a> and <a href="https:&#x2F;&#x2F;googology.fandom.com&#x2F;wiki&#x2F;Googology_Wiki" rel="nofollow noreferrer">https:&#x2F;&#x2F;googology.fandom.com&#x2F;wiki&#x2F;Googology_Wiki</a></div><br/></div></div><div id="37911329" class="c"><input type="checkbox" id="c-37911329" checked=""/><div class="controls bullet"><span class="by">joshxyz</span><span>|</span><a href="#37910765">prev</a><span>|</span><a href="#37910730">next</a><span>|</span><label class="collapse" for="c-37911329">[-]</label><label class="expand" for="c-37911329">[8 more]</label></div><br/><div class="children"><div class="content">This is too much nerd for me.<p>Can anyone tell me what is the required pre-requisite of knowledge to understand things like this? Like will knowing basic calculus be enough? What specific topics or subjects will give me good fundamentals on these things?<p>Thank you.</div><br/><div id="37911398" class="c"><input type="checkbox" id="c-37911398" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#37911329">parent</a><span>|</span><a href="#37911383">next</a><span>|</span><label class="collapse" for="c-37911398">[-]</label><label class="expand" for="c-37911398">[1 more]</label></div><br/><div class="children"><div class="content">This [1] is a really accessible introduction to busy beaver numbers.<p>[1] <a href="https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html</a></div><br/></div></div><div id="37911383" class="c"><input type="checkbox" id="c-37911383" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#37911329">parent</a><span>|</span><a href="#37911398">prev</a><span>|</span><a href="#37911401">next</a><span>|</span><label class="collapse" for="c-37911383">[-]</label><label class="expand" for="c-37911383">[3 more]</label></div><br/><div class="children"><div class="content">This fits squarely into theoretical computer science.<p>Going through any introductory TCS textbook will help you understand most of this stuff.<p>CS students do this in their first or second year of their studies, and yes it&#x27;s tough (at my uni this was among the most feared exams).</div><br/><div id="37911500" class="c"><input type="checkbox" id="c-37911500" checked=""/><div class="controls bullet"><span class="by">acmiyaguchi</span><span>|</span><a href="#37911329">root</a><span>|</span><a href="#37911383">parent</a><span>|</span><a href="#37911401">next</a><span>|</span><label class="collapse" for="c-37911500">[-]</label><label class="expand" for="c-37911500">[2 more]</label></div><br/><div class="children"><div class="content">A first or second year (undergrad) student doing theoretical science to this level is astounding to me. It was an upper-division course for me, albeit a prerequisite for things like compilers and cryptography, so I&#x27;m sure it could be put earlier in the journey.<p>Sipser&#x27;s &quot;Introduction to the Theory of Computation&quot; was the book I had to read, and it certainly makes this post more accessible.</div><br/><div id="37911655" class="c"><input type="checkbox" id="c-37911655" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37911329">root</a><span>|</span><a href="#37911500">parent</a><span>|</span><a href="#37911401">next</a><span>|</span><label class="collapse" for="c-37911655">[-]</label><label class="expand" for="c-37911655">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, Sipser starts the natural numbers with 1 in this book, instead of 0.<p>I like this choice, and I would like to use it myself. But if ℕ starts with 1, what do I call {0} ∪ ℕ? I guess ℕ₀ is a reasonable choice.</div><br/></div></div></div></div></div></div><div id="37911401" class="c"><input type="checkbox" id="c-37911401" checked=""/><div class="controls bullet"><span class="by">unhammer</span><span>|</span><a href="#37911329">parent</a><span>|</span><a href="#37911383">prev</a><span>|</span><a href="#37911395">next</a><span>|</span><label class="collapse" for="c-37911401">[-]</label><label class="expand" for="c-37911401">[1 more]</label></div><br/><div class="children"><div class="content">More like discrete math and automata theory <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Automata_theory" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Automata_theory</a> or theory of computation. 
Hopcroft &amp; Ullmann&#x27;s intro book is nice. But there&#x27;s so much related stuff here, it&#x27;s just a starting point.</div><br/></div></div><div id="37911395" class="c"><input type="checkbox" id="c-37911395" checked=""/><div class="controls bullet"><span class="by">markuswt</span><span>|</span><a href="#37911329">parent</a><span>|</span><a href="#37911401">prev</a><span>|</span><a href="#37911385">next</a><span>|</span><label class="collapse" for="c-37911395">[-]</label><label class="expand" for="c-37911395">[1 more]</label></div><br/><div class="children"><div class="content">Calculus has little to do with this kind of problem. You should study theoretical computer science, in particular computability theory, to understand the article. Many CS undergraduate programs will have courses with public resources you can follow.</div><br/></div></div><div id="37911385" class="c"><input type="checkbox" id="c-37911385" checked=""/><div class="controls bullet"><span class="by">jcagalawan</span><span>|</span><a href="#37911329">parent</a><span>|</span><a href="#37911395">prev</a><span>|</span><a href="#37910730">next</a><span>|</span><label class="collapse" for="c-37911385">[-]</label><label class="expand" for="c-37911385">[1 more]</label></div><br/><div class="children"><div class="content">Theory of Computation, Number Theory, and Probability are good starts.</div><br/></div></div></div></div><div id="37910730" class="c"><input type="checkbox" id="c-37910730" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#37911329">prev</a><span>|</span><a href="#37910889">next</a><span>|</span><label class="collapse" for="c-37910730">[-]</label><label class="expand" for="c-37910730">[2 more]</label></div><br/><div class="children"><div class="content">I have always been curious about BB but never saw Scott Aaronson&#x27;s survey of the topic. Link within.</div><br/><div id="37911187" class="c"><input type="checkbox" id="c-37911187" checked=""/><div class="controls bullet"><span class="by">sligocki</span><span>|</span><a href="#37910730">parent</a><span>|</span><a href="#37910889">next</a><span>|</span><label class="collapse" for="c-37911187">[-]</label><label class="expand" for="c-37911187">[1 more]</label></div><br/><div class="children"><div class="content">His survey 3 years ago has kicked off quite a flurry of Busy Beaver activity of which my entire blog and <a href="https:&#x2F;&#x2F;bbchallenge.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bbchallenge.org&#x2F;</a> are a couple examples.</div><br/></div></div></div></div><div id="37910889" class="c"><input type="checkbox" id="c-37910889" checked=""/><div class="controls bullet"><span class="by">philip-b</span><span>|</span><a href="#37910730">prev</a><span>|</span><a href="#37910498">next</a><span>|</span><label class="collapse" for="c-37910889">[-]</label><label class="expand" for="c-37910889">[4 more]</label></div><br/><div class="children"><div class="content">`1RB2RA1LC_2LC1RB2RB_---2LA1LA` - how do I read this?</div><br/><div id="37910917" class="c"><input type="checkbox" id="c-37910917" checked=""/><div class="controls bullet"><span class="by">twiceaday</span><span>|</span><a href="#37910889">parent</a><span>|</span><a href="#37910929">next</a><span>|</span><label class="collapse" for="c-37910917">[-]</label><label class="expand" for="c-37910917">[1 more]</label></div><br/><div class="children"><div class="content">It is a state transition table, the expansion is featured in the article right under it, or here<p><a href="https:&#x2F;&#x2F;bbchallenge.org&#x2F;1RB2RA1LC_2LC1RB2RB_---2LA1LA" rel="nofollow noreferrer">https:&#x2F;&#x2F;bbchallenge.org&#x2F;1RB2RA1LC_2LC1RB2RB_---2LA1LA</a><p>For example: If in state B and the tape at the current marker reads 0: write 2, move the head Left once, and go to state C.</div><br/></div></div><div id="37910929" class="c"><input type="checkbox" id="c-37910929" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#37910889">parent</a><span>|</span><a href="#37910917">prev</a><span>|</span><a href="#37910920">next</a><span>|</span><label class="collapse" for="c-37910929">[-]</label><label class="expand" for="c-37910929">[1 more]</label></div><br/><div class="children"><div class="content">There is a more readable state table but each underscore separates a group of transitions for one symbol, writen as groups of 3 characters for each symbol. These are the symbol to write, new state and direction to move. The --- state halts.</div><br/></div></div><div id="37910920" class="c"><input type="checkbox" id="c-37910920" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#37910889">parent</a><span>|</span><a href="#37910929">prev</a><span>|</span><a href="#37910498">next</a><span>|</span><label class="collapse" for="c-37910920">[-]</label><label class="expand" for="c-37910920">[1 more]</label></div><br/><div class="children"><div class="content">Click on the link in the article [0] and you&#x27;ll get a page that expands it to a human readable table. Each current (state, tape value) pair maps to a (new tape value, direction to move tape head, new tape value) triple.<p>[0] <a href="https:&#x2F;&#x2F;bbchallenge.org&#x2F;1RB2RA1LC_2LC1RB2RB_---2LA1LA" rel="nofollow noreferrer">https:&#x2F;&#x2F;bbchallenge.org&#x2F;1RB2RA1LC_2LC1RB2RB_---2LA1LA</a></div><br/></div></div></div></div><div id="37910498" class="c"><input type="checkbox" id="c-37910498" checked=""/><div class="controls bullet"><span class="by">haltist</span><span>|</span><a href="#37910889">prev</a><span>|</span><a href="#37910536">next</a><span>|</span><label class="collapse" for="c-37910498">[-]</label><label class="expand" for="c-37910498">[1 more]</label></div><br/><div class="children"><div class="content">Pretty good writeup.</div><br/></div></div></div></div></div></div></div></body></html>