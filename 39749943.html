<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710838876782" as="style"/><link rel="stylesheet" href="styles.css?v=1710838876782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.philipzucker.com/compile_constraints/">Compiling with Constraints</a> <span class="domain">(<a href="https://www.philipzucker.com">www.philipzucker.com</a>)</span></div><div class="subtext"><span>philzook</span> | <span>28 comments</span></div><br/><div><div id="39750492" class="c"><input type="checkbox" id="c-39750492" checked=""/><div class="controls bullet"><span class="by">mad0</span><span>|</span><a href="#39751139">next</a><span>|</span><label class="collapse" for="c-39750492">[-]</label><label class="expand" for="c-39750492">[4 more]</label></div><br/><div class="children"><div class="content">Huh I haven&#x27;t thought that I will see minizinc outside of my university. I keep being pleasantly surprised that constraint programming and formal methods are being used somewhere out there.</div><br/><div id="39751190" class="c"><input type="checkbox" id="c-39751190" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39750492">parent</a><span>|</span><a href="#39750956">next</a><span>|</span><label class="collapse" for="c-39751190">[-]</label><label class="expand" for="c-39751190">[1 more]</label></div><br/><div class="children"><div class="content">There are some nice coursera courses on minizinc<p>- <a href="https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;discrete-optimization" rel="nofollow">https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;discrete-optimization</a> good hats. very fun.<p>- <a href="https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;basic-modeling" rel="nofollow">https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;basic-modeling</a></div><br/></div></div><div id="39750956" class="c"><input type="checkbox" id="c-39750956" checked=""/><div class="controls bullet"><span class="by">scholaronroad</span><span>|</span><a href="#39750492">parent</a><span>|</span><a href="#39751190">prev</a><span>|</span><a href="#39751139">next</a><span>|</span><label class="collapse" for="c-39750956">[-]</label><label class="expand" for="c-39750956">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, which university is this?
IMO the number of universities that actually teach CP is small.</div><br/><div id="39752996" class="c"><input type="checkbox" id="c-39752996" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#39750492">root</a><span>|</span><a href="#39750956">parent</a><span>|</span><a href="#39751139">next</a><span>|</span><label class="collapse" for="c-39752996">[-]</label><label class="expand" for="c-39752996">[1 more]</label></div><br/><div class="children"><div class="content">Guessing Monash.</div><br/></div></div></div></div></div></div><div id="39751139" class="c"><input type="checkbox" id="c-39751139" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#39750492">prev</a><span>|</span><a href="#39750413">next</a><span>|</span><label class="collapse" for="c-39751139">[-]</label><label class="expand" for="c-39751139">[3 more]</label></div><br/><div class="children"><div class="content">Holy shit, this is an excellent tour. I want to look at constraint-based
register allocation for my next project, I think. I also wanted to see if it
were possible to synthesize a data format and short x86 opcode sequences that
would satisfy certain mathematical laws, but I did not figure out how to do
that. Maybe we should chat.<p>In particular, I love the tiny tiny Union-Find!<p><pre><code>    uf = {}
    def find(x):
      while x in uf:
        x = uf[x]
      return x

    def union(x,y):
      x = find(x)
      y = find(y)
      if x != y:
        uf[x] = y
      return y
</code></pre>
That&#x27;s even smaller than the impl I use in toy projects. Wow.<p>And thanks for linking to my DDCG posts :)</div><br/><div id="39751164" class="c"><input type="checkbox" id="c-39751164" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39751139">parent</a><span>|</span><a href="#39753464">next</a><span>|</span><label class="collapse" for="c-39751164">[-]</label><label class="expand" for="c-39751164">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Big fan of your posts! Keep it up!</div><br/></div></div><div id="39753464" class="c"><input type="checkbox" id="c-39753464" checked=""/><div class="controls bullet"><span class="by">UncleEntity</span><span>|</span><a href="#39751139">parent</a><span>|</span><a href="#39751164">prev</a><span>|</span><a href="#39750413">next</a><span>|</span><label class="collapse" for="c-39753464">[-]</label><label class="expand" for="c-39753464">[1 more]</label></div><br/><div class="children"><div class="content">Man, that&#x27;s a very good explanation of DDCG.<p>I&#x27;ve actually tried to understand the original paper at one point and translated all the complicated greek pseudo-code into, umm...pseudo-code to use at some future point. I spent a little time pondering on how to combine it with global value numbering (if that&#x27;s even something worthwhile to pursue is still an open question) for an added &#x27;cheap&#x27; optimization and to manage a java-like local variable heap(?) but haven&#x27;t done anything with it yet.<p>A little off topic but props where they&#x27;re due...</div><br/></div></div></div></div><div id="39750413" class="c"><input type="checkbox" id="c-39750413" checked=""/><div class="controls bullet"><span class="by">anonymous_union</span><span>|</span><a href="#39751139">prev</a><span>|</span><label class="collapse" for="c-39750413">[-]</label><label class="expand" for="c-39750413">[20 more]</label></div><br/><div class="children"><div class="content">its fascinating how register allocation is not a solved problem. thinking about it, it seems like optimal allocation would depend on input&#x2F;workload, so any ahead of time selection will always be a compromise.</div><br/><div id="39750654" class="c"><input type="checkbox" id="c-39750654" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39750413">parent</a><span>|</span><a href="#39750580">next</a><span>|</span><label class="collapse" for="c-39750654">[-]</label><label class="expand" for="c-39750654">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s np hard. You can solve it perfectly for a given instance using a constraint solver and adequate patience.<p>Unfortunately instruction selection is also NP, and so is instruction scheduling, and all three are inter-related. An optimal solution for one tends to be suboptimal for the other two.<p>Ideally one would feed all three problems into a constraint solver together. Thus far this is considered computationally infeasible, though I don&#x27;t think that belief would bear up to scrutiny with a supercomputer.</div><br/><div id="39753935" class="c"><input type="checkbox" id="c-39753935" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750654">parent</a><span>|</span><a href="#39750987">next</a><span>|</span><label class="collapse" for="c-39753935">[-]</label><label class="expand" for="c-39753935">[1 more]</label></div><br/><div class="children"><div class="content">&gt;You can solve it perfectly for a given instance using a constraint solver and adequate patience.<p>Is this really true for cases where there is no choice but to spill registers? How would a graph coloring solver understand to spill outer loop variables instead of inner loop ones? I&#x27;ve never written a &quot;proper&quot; register allocator so I&#x27;m curious.</div><br/></div></div><div id="39750987" class="c"><input type="checkbox" id="c-39750987" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750654">parent</a><span>|</span><a href="#39753935">prev</a><span>|</span><a href="#39750580">next</a><span>|</span><label class="collapse" for="c-39750987">[-]</label><label class="expand" for="c-39750987">[1 more]</label></div><br/><div class="children"><div class="content">&gt; though I don&#x27;t think that belief would bear up to scrutiny with a supercomputer.<p>It&#x27;s certainly computationally infeasible for home users, that&#x27;s for sure.</div><br/></div></div></div></div><div id="39750580" class="c"><input type="checkbox" id="c-39750580" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39750413">parent</a><span>|</span><a href="#39750654">prev</a><span>|</span><a href="#39750696">next</a><span>|</span><label class="collapse" for="c-39750580">[-]</label><label class="expand" for="c-39750580">[9 more]</label></div><br/><div class="children"><div class="content">I think one of the biggest problems is even stating what the solution an optimal compiler would be. How does one model a program or a CPU? There almost certainly isn&#x27;t one perfect model for all situations. CPU&#x27;s are extremely complicated despite the surface simplicity of assembly. Naive notions of registers or instruction ordering don&#x27;t really exist. But also because of this, perfect compilation isn&#x27;t that crucial. The CPU kind of JITs for you. The only objective function that seems pretty clear to me is code size.</div><br/><div id="39750695" class="c"><input type="checkbox" id="c-39750695" checked=""/><div class="controls bullet"><span class="by">anonymous_union</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750580">parent</a><span>|</span><a href="#39750713">next</a><span>|</span><label class="collapse" for="c-39750695">[-]</label><label class="expand" for="c-39750695">[6 more]</label></div><br/><div class="children"><div class="content">right yea, modern CPUs seem to have all sorts of abstract optimizations. its kind of strange how we meet in the middle with hardware ISA manufacturers. they do all sorts of tricks on their side to make code go faster, and we try to generate machine code that we think will go faster, but neither side works with the other (compiler writers and ISA developers). i bet there is easy low hanging fruit here.</div><br/><div id="39751003" class="c"><input type="checkbox" id="c-39751003" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750695">parent</a><span>|</span><a href="#39750713">next</a><span>|</span><label class="collapse" for="c-39751003">[-]</label><label class="expand" for="c-39751003">[5 more]</label></div><br/><div class="children"><div class="content">There sort of is, but isn&#x27;t that why stuff like VLIW exists? So that the compiler can optimize the hell out of the machine code, and the CPU doesn&#x27;t have to do its own OoO nonsense?</div><br/><div id="39751143" class="c"><input type="checkbox" id="c-39751143" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39751003">parent</a><span>|</span><a href="#39750713">next</a><span>|</span><label class="collapse" for="c-39751143">[-]</label><label class="expand" for="c-39751143">[4 more]</label></div><br/><div class="children"><div class="content">VLIW is what the Unison project (the context behind this post) was attacking. <a href="https:&#x2F;&#x2F;unison-code.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;unison-code.github.io&#x2F;</a> My best understanding is that exposing the details of the CPU to the compiler via a more complex ISA has not worked that well. Possibly because the compilation problem just gets too hard, but maybe also for momeentum and ecosystem reasons. I think another lesson is that it is unwise to make your isa expose microarchitecture because microarchitecture changes quite a bit between generations and inidividual CPUs. Things like delay slots seem like misfeatures now.</div><br/><div id="39751649" class="c"><input type="checkbox" id="c-39751649" checked=""/><div class="controls bullet"><span class="by">gsnedders</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39751143">parent</a><span>|</span><a href="#39751184">next</a><span>|</span><label class="collapse" for="c-39751649">[-]</label><label class="expand" for="c-39751649">[2 more]</label></div><br/><div class="children"><div class="content">And it&#x27;s worth noting VLIW survived longer in GPUs—where there <i>isn&#x27;t</i> any expectation of ISA stability, which avoids that problem.</div><br/><div id="39752161" class="c"><input type="checkbox" id="c-39752161" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39751649">parent</a><span>|</span><a href="#39751184">next</a><span>|</span><label class="collapse" for="c-39752161">[-]</label><label class="expand" for="c-39752161">[1 more]</label></div><br/><div class="children"><div class="content">And, perhaps also relevantly, your compute kernel probably fits in iCache, even with VLIW instructions.</div><br/></div></div></div></div><div id="39751184" class="c"><input type="checkbox" id="c-39751184" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39751143">parent</a><span>|</span><a href="#39751649">prev</a><span>|</span><a href="#39750713">next</a><span>|</span><label class="collapse" for="c-39751184">[-]</label><label class="expand" for="c-39751184">[1 more]</label></div><br/><div class="children"><div class="content">Not to be confused with the Unison language, I guess. <a href="https:&#x2F;&#x2F;www.unison-lang.org" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org</a></div><br/></div></div></div></div></div></div></div></div><div id="39750713" class="c"><input type="checkbox" id="c-39750713" checked=""/><div class="controls bullet"><span class="by">anonymous_union</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750580">parent</a><span>|</span><a href="#39750695">prev</a><span>|</span><a href="#39750696">next</a><span>|</span><label class="collapse" for="c-39750713">[-]</label><label class="expand" for="c-39750713">[2 more]</label></div><br/><div class="children"><div class="content">interesting that code size is important to you. hey everyone, write shorter programs :)</div><br/><div id="39751155" class="c"><input type="checkbox" id="c-39751155" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750713">parent</a><span>|</span><a href="#39750696">next</a><span>|</span><label class="collapse" for="c-39751155">[-]</label><label class="expand" for="c-39751155">[1 more]</label></div><br/><div class="children"><div class="content">I do like short programs :).  Code size does matter for instruction cache. In my application in particular, post hoc binary patching, a single byte can make a big difference in difficulty of patching.</div><br/></div></div></div></div></div></div><div id="39750696" class="c"><input type="checkbox" id="c-39750696" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#39750413">parent</a><span>|</span><a href="#39750580">prev</a><span>|</span><a href="#39750438">next</a><span>|</span><label class="collapse" for="c-39750696">[-]</label><label class="expand" for="c-39750696">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re willing to work in the SSA domain, and not do any spill&#x2F;fill, you can do optimal RA in polynomial time. (Usually quoted as linear, but quadraticish IRL.)</div><br/></div></div><div id="39750438" class="c"><input type="checkbox" id="c-39750438" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39750413">parent</a><span>|</span><a href="#39750696">prev</a><span>|</span><label class="collapse" for="c-39750438">[-]</label><label class="expand" for="c-39750438">[6 more]</label></div><br/><div class="children"><div class="content">certainly optimal would be global, and I&#x27;m pretty sure its isomorphic to bin packing..whether you use a fixed call interface or not. so its solved, its just exponential</div><br/><div id="39750560" class="c"><input type="checkbox" id="c-39750560" checked=""/><div class="controls bullet"><span class="by">anonymous_union</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750438">parent</a><span>|</span><label class="collapse" for="c-39750560">[-]</label><label class="expand" for="c-39750560">[5 more]</label></div><br/><div class="children"><div class="content">im not sure. given a hypothetical arch with only 1 free register, which local variable do you allocate to it?<p><pre><code>  1 int
  2 main(int argc, char *argv[])
  3 {
  4         int sum = 0;
  5         int sum2 = 0;
  6
  7         if (argc &gt;= 2)
  8                 for (int i = 0; i &lt; argv[1]; i++)
  9                         sum += i;
 10
 11         if (argc &gt;= 3)
 12                 for (int i = 0; i &lt; argv[2]; i++)
 13                         sum2 += sum + i;
 14
 15         return 0;
 16 }</code></pre></div><br/><div id="39753901" class="c"><input type="checkbox" id="c-39753901" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750560">parent</a><span>|</span><a href="#39753350">next</a><span>|</span><label class="collapse" for="c-39753901">[-]</label><label class="expand" for="c-39753901">[1 more]</label></div><br/><div class="children"><div class="content">&gt; given a hypothetical arch with only 1 free register, which local variable do you allocate to it?<p>A truly good compiler would use the same register for <i>sum</i> and <i>sum2</i> and for <i>argv[1]</i> and <i>argv[2]</i> if it needs to.<p>With only one register, the answer probably will be “none or every single one”, depending on the instruction set, though.<p>For example, how do you index into arrays? Self modifying code as often is done on the 6502? Or do you have stack-relative indirect addressing that allows you to say “add the contents of the address pointed to by the value at stack pointer plus 6 to the register”? Either way, there will be lots of contention for that single register.<p>Or does this hypothetical architecture have various complex “add contents of addresses <i>foo[register]</i> and <i>bar</i> and store the result in <i>baz[3]</i> instructions? (Which would probably make it a very bad design. Adding a second register would be about the first thing to do, but maybe this design has RAM that’s as fast as registers?)</div><br/></div></div><div id="39753350" class="c"><input type="checkbox" id="c-39753350" checked=""/><div class="controls bullet"><span class="by">UncleEntity</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750560">parent</a><span>|</span><a href="#39753901">prev</a><span>|</span><a href="#39750572">next</a><span>|</span><label class="collapse" for="c-39753350">[-]</label><label class="expand" for="c-39753350">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I want to play...<p>So, an optimizing compiler would see that pretty much everything is dead code it would assign 0 to the return register and done.</div><br/></div></div><div id="39750572" class="c"><input type="checkbox" id="c-39750572" checked=""/><div class="controls bullet"><span class="by">anonymous_union</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750560">parent</a><span>|</span><a href="#39753350">prev</a><span>|</span><label class="collapse" for="c-39750572">[-]</label><label class="expand" for="c-39750572">[2 more]</label></div><br/><div class="children"><div class="content">oops im dumb, convert argv[1] and argv[2] to integers first.</div><br/><div id="39752226" class="c"><input type="checkbox" id="c-39752226" checked=""/><div class="controls bullet"><span class="by">T_MacThrowFace</span><span>|</span><a href="#39750413">root</a><span>|</span><a href="#39750572">parent</a><span>|</span><label class="collapse" for="c-39752226">[-]</label><label class="expand" for="c-39752226">[1 more]</label></div><br/><div class="children"><div class="content">youngun, this is why line numbers always increase by 10</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>