<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695805265369" as="style"/><link rel="stylesheet" href="styles.css?v=1695805265369"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/deconstructing-type-parameters">Deconstructing Go Type Parameters</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>psxuaw</span> | <span>26 comments</span></div><br/><div><div id="37670111" class="c"><input type="checkbox" id="c-37670111" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#37670165">next</a><span>|</span><label class="collapse" for="c-37670111">[-]</label><label class="expand" for="c-37670111">[7 more]</label></div><br/><div class="children"><div class="content">It really doesn&#x27;t help that the major (perhaps only?) official resources on generics in golang are these blog posts [1][2] and the spec. And now this blog post.<p>The whole &quot;what type am I getting&quot;&#x2F;make()ing is really tricky (as outlined in this doc) especially when its a pointer&#x2F;interface&#x2F;slice&#x2F;etc. And a lot of feels like it doesn&#x27;t need to be as much of a complex decision tree as it is. Is there any other documentation on this stuff that I&#x27;m missing?<p>Theres a lot of complication buried in golang people don&#x27;t talk about that much. nil vs empty slices, interface{} and any behavior differences, make() and what it would do for various type scenarios, impossible to remember channel semantics (which ones panic again?). Of course, theres always a good explanation for why it is the way it is, but for a language so opinionated, stronger opinions on better DX in the deeper parts would be great.<p>[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;intro-generics" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;intro-generics</a>
[2] <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;tutorial&#x2F;generics" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;tutorial&#x2F;generics</a></div><br/><div id="37670221" class="c"><input type="checkbox" id="c-37670221" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37670111">parent</a><span>|</span><a href="#37670466">next</a><span>|</span><label class="collapse" for="c-37670221">[-]</label><label class="expand" for="c-37670221">[3 more]</label></div><br/><div class="children"><div class="content">Pointing people at the spec is probably the best decision the Go team ever made.  Why wonder about things when you can have true authority in an honestly very short piece of text?  No guessing, just an exact description of what&#x27;s going to happen.<p>(I was in there recently reading about operator precedence recently and discovered an operator I didn&#x27;t know existed, &quot;bit clear (AND NOT)&quot;, &amp;^.  Amusingly, I needed to do that operation but wasn&#x27;t sure if I needed parentheses for X &amp; (^Y) or not.  I still don&#x27;t know why it&#x27;s a dedicated operator, however.  The spec rarely says WHY, just WHAT.)</div><br/><div id="37670259" class="c"><input type="checkbox" id="c-37670259" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37670111">root</a><span>|</span><a href="#37670221">parent</a><span>|</span><a href="#37670466">next</a><span>|</span><label class="collapse" for="c-37670259">[-]</label><label class="expand" for="c-37670259">[2 more]</label></div><br/><div class="children"><div class="content">It does help that the spec (and memory model!) is quite good and reasonably concise.  I send people there as often as possible when they start getting interested in learning things For Real, blogspam is rarely anywhere near as useful despite being multiple times longer.<p>(Which is not meant to claim this article is blogspam - making <i>recommendations with examples</i> is quite different from <i>a spec</i>, and we definitely need recommendations)</div><br/><div id="37670293" class="c"><input type="checkbox" id="c-37670293" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37670111">root</a><span>|</span><a href="#37670259">parent</a><span>|</span><a href="#37670466">next</a><span>|</span><label class="collapse" for="c-37670293">[-]</label><label class="expand" for="c-37670293">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.  Effective Go feels a little dated now.  My most frequent link is to Code Review Comments: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;wiki&#x2F;CodeReviewComments">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;wiki&#x2F;CodeReviewComments</a></div><br/></div></div></div></div></div></div><div id="37670466" class="c"><input type="checkbox" id="c-37670466" checked=""/><div class="controls bullet"><span class="by">AlbinoDrought</span><span>|</span><a href="#37670111">parent</a><span>|</span><a href="#37670221">prev</a><span>|</span><a href="#37670928">next</a><span>|</span><label class="collapse" for="c-37670466">[-]</label><label class="expand" for="c-37670466">[2 more]</label></div><br/><div class="children"><div class="content">The one that got me was the implicit wrapping of structs into interface types. As an example, the below code segfaults with `fatal error: panic while printing panic value: type runtime.errorString`:<p><pre><code>    package main
    
    type SomeError struct {
        SomeMessage   string
    }
    
    func (se *SomeError) Error() string {
        return se.SomeMessage
    }
    
    func doSomethingSomeWay() *SomeError {
        return nil
    }
    
    func DoSomething() error {
        return doSomethingSomeWay()
    }
    
    func main() {
        err := DoSomething()
        if err != nil {
            panic(err)
        }
    }</code></pre></div><br/><div id="37671684" class="c"><input type="checkbox" id="c-37671684" checked=""/><div class="controls bullet"><span class="by">EspressoGPT</span><span>|</span><a href="#37670111">root</a><span>|</span><a href="#37670466">parent</a><span>|</span><a href="#37670928">next</a><span>|</span><label class="collapse" for="c-37671684">[-]</label><label class="expand" for="c-37671684">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this has to do with interface values and how interfaces are implemented in Go. It&#x27;s a bit weird.</div><br/></div></div></div></div><div id="37670928" class="c"><input type="checkbox" id="c-37670928" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#37670111">parent</a><span>|</span><a href="#37670466">prev</a><span>|</span><a href="#37670165">next</a><span>|</span><label class="collapse" for="c-37670928">[-]</label><label class="expand" for="c-37670928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; interface{} and any behavior differences,<p>I&#x27;m curious now. They are type aliases. In which situations there is a difference in behavior?</div><br/></div></div></div></div><div id="37670165" class="c"><input type="checkbox" id="c-37670165" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37670111">prev</a><span>|</span><a href="#37670022">next</a><span>|</span><label class="collapse" for="c-37670165">[-]</label><label class="expand" for="c-37670165">[1 more]</label></div><br/><div class="children"><div class="content">I suppose this is necessary because this:<p><pre><code>  func clone[S ~[]any)(s S) S
</code></pre>
would only allow things with an underlying type of []interface{}, not &quot;any type&quot; as an inferred type...  and that applies to the final example too:<p><pre><code>  &#x2F;&#x2F; allows any collection of stringable things
  func WithStrings[S ~[]E, E interface { String() string }](
  
  &#x2F;&#x2F; allows only things like:
  &#x2F;&#x2F; []interface { String() string }{...}
  &#x2F;&#x2F; and named types like that, but not:
  &#x2F;&#x2F; []strings.Builder{...}
  &#x2F;&#x2F; because that isn&#x27;t the same collection type,
  &#x2F;&#x2F; it&#x27;s just a collection of compatible elements
  func WithStrings[S ~[]interface { String() string }](...)
</code></pre>
I guess this is the price to pay to avoid introducing co&#x2F;contra variance?  It may be worth it, and it seems likely that it would be a thing you can improve without breaking compatibility.</div><br/></div></div><div id="37670022" class="c"><input type="checkbox" id="c-37670022" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#37670165">prev</a><span>|</span><a href="#37669929">next</a><span>|</span><label class="collapse" for="c-37670022">[-]</label><label class="expand" for="c-37670022">[11 more]</label></div><br/><div class="children"><div class="content">Wow, I&#x27;m not super happy about the syntax of this language. I&#x27;m familiar with what each paragraph is describing from multiple other languages, but I can&#x27;t even <i>guess</i> how some of the syntax here maps onto those other languages, even with the explanations.</div><br/><div id="37670171" class="c"><input type="checkbox" id="c-37670171" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37670022">parent</a><span>|</span><a href="#37669929">next</a><span>|</span><label class="collapse" for="c-37670171">[-]</label><label class="expand" for="c-37670171">[10 more]</label></div><br/><div class="children"><div class="content">You have to click through to read the assignability rules.  A very short summary is that people often create new types based on core types.  For example:<p><pre><code>   type Name string
</code></pre>
Now you can define methods on Name:<p><pre><code>   func (n Name) Foo() { ... }
   ...
   x := Name(&quot;Me&quot;)
   x.Foo()
</code></pre>
But, you can&#x27;t use Name and string interchangeably:<p><pre><code>   func StringFoo(x string) { ... }
   StringFoo(Name(&quot;Me&quot;)) &#x2F;&#x2F; does not compile
</code></pre>
In the case of generics, maybe you want to write a function that can handle any string:<p><pre><code>   func Bar[T string](x T) { ... }
   Bar(Name(&quot;Me&quot;))
   Bar(&quot;Me&quot;)
</code></pre>
This doesn&#x27;t compile, because Name isn&#x27;t assignable to string.  The fix is to declare the type parameter as [T ~string].  (The compile error suggests this, in fact.  You can also write string(Name(&quot;Me&quot;)) but if T were being used as the type of the return value, the returned value would be type string, not type Name.)<p>In the case of slices, it can be more complicated.  These types all seem similar, but aren&#x27;t the same:<p><pre><code>  []string
  []Name
  type StringSlice []string
  type NameSlice []Name
</code></pre>
The idea of the article is figuring out how to write a generic type signature that would accept any of these and return the right type.<p>Finally, you can rename types and use them interchangeably if you don&#x27;t want the &quot;safety&quot; of making a new type:<p><pre><code>  type Name = string
</code></pre>
Now you can&#x27;t write methods on Name, but you can use Name and string interchangably.  (This, incidentally, is how &quot;any&quot; works.  The package builtin contains &quot;type any = interface{}&quot;.)<p>If the complaint about syntax is not using &lt;T type&gt; to denote type parameters like Java and C++, [] simplifies the parser.  You can read the original generics proposal for all the details.</div><br/><div id="37671904" class="c"><input type="checkbox" id="c-37671904" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670171">parent</a><span>|</span><a href="#37670629">next</a><span>|</span><label class="collapse" for="c-37671904">[-]</label><label class="expand" for="c-37671904">[1 more]</label></div><br/><div class="children"><div class="content">Awesome explanation!</div><br/></div></div><div id="37670629" class="c"><input type="checkbox" id="c-37670629" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670171">parent</a><span>|</span><a href="#37671904">prev</a><span>|</span><a href="#37670558">next</a><span>|</span><label class="collapse" for="c-37670629">[-]</label><label class="expand" for="c-37670629">[6 more]</label></div><br/><div class="children"><div class="content">&gt; [] simplifies the parser<p>Strong PHP vibes. They also went for weird syntaxes that don&#x27;t exist or rarely exist in other languages to simplify the parser.<p>It&#x27;s 2023. How is parsing anything is a problem?</div><br/><div id="37670824" class="c"><input type="checkbox" id="c-37670824" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670629">parent</a><span>|</span><a href="#37670558">next</a><span>|</span><label class="collapse" for="c-37670824">[-]</label><label class="expand" for="c-37670824">[5 more]</label></div><br/><div class="children"><div class="content">Go 1.18 had to run programs written for Go 1.17.  What if this is your program:<p><pre><code>    a, b = w &lt; x, y &gt; (z)
</code></pre>
Is that &quot;a, b = w[x, y](z)&quot; (call function w of with type parameters x and y against z), or is it &quot;a = w &lt; x; b = w &gt; (z)&quot; (assign true to a if w is less than x, ...).<p>With type information, this is possible to disambiguate, but the goal of the parser is to not require type information.  Remember, now if you want correct syntax highlighting your <i>editor</i> has to have the type information, but you haven&#x27;t typed that in yet!<p>As always, I think they made the right choice here.</div><br/><div id="37670903" class="c"><input type="checkbox" id="c-37670903" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670824">parent</a><span>|</span><a href="#37670558">next</a><span>|</span><label class="collapse" for="c-37670903">[-]</label><label class="expand" for="c-37670903">[4 more]</label></div><br/><div class="children"><div class="content">&gt; With type information, this is possible to disambiguate, but the goal of the parser is to not require type information.<p>Why?<p>It looks like a pretense at purity for the sake of purity.</div><br/><div id="37671973" class="c"><input type="checkbox" id="c-37671973" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670903">parent</a><span>|</span><a href="#37671433">next</a><span>|</span><label class="collapse" for="c-37671973">[-]</label><label class="expand" for="c-37671973">[1 more]</label></div><br/><div class="children"><div class="content">lots of things in Go are very annoying, but this isn&#x27;t one of them.  being able to parse the language without type information makes parsing way easier and faster, which you definitely care about in at least one case - syntax highlighting in your editor.</div><br/></div></div><div id="37671433" class="c"><input type="checkbox" id="c-37671433" checked=""/><div class="controls bullet"><span class="by">reuben364</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670903">parent</a><span>|</span><a href="#37671973">prev</a><span>|</span><a href="#37671099">next</a><span>|</span><label class="collapse" for="c-37671433">[-]</label><label class="expand" for="c-37671433">[1 more]</label></div><br/><div class="children"><div class="content">Do you want to parsing your language to require implementing the typechecker and using shotgun heuristics, all so you can use &lt;&gt; instead of []? Compiler writers die for your sins in code. Let them do things that can drastically simplify things everywhere, instead of suggesting that they&#x27;re intellectually jerking themselves off. Not that they&#x27;re immune to that.<p>EDIT: Apologies, after a bit I realized the above is a bad comment.<p>Separation of concerns is a common pattern in programming. It allows for things to be testable and changes to be more localized. This is an example of that.</div><br/></div></div><div id="37671099" class="c"><input type="checkbox" id="c-37671099" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670903">parent</a><span>|</span><a href="#37671433">prev</a><span>|</span><a href="#37670558">next</a><span>|</span><label class="collapse" for="c-37671099">[-]</label><label class="expand" for="c-37671099">[1 more]</label></div><br/><div class="children"><div class="content">Separating parsing from semantic analysis simplifies the parser considerably.<p>If one of Go&#x27;s aims was to make different trade-offs than [C++][1] did, then the choice not to use &quot;&lt;&quot; as a grouping operator was a good one.<p>[1]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;WfIr7lKT4Sk?t=204" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;WfIr7lKT4Sk?t=204</a></div><br/></div></div></div></div></div></div></div></div><div id="37670558" class="c"><input type="checkbox" id="c-37670558" checked=""/><div class="controls bullet"><span class="by">VirusNewbie</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670171">parent</a><span>|</span><a href="#37670629">prev</a><span>|</span><a href="#37669929">next</a><span>|</span><label class="collapse" for="c-37670558">[-]</label><label class="expand" for="c-37670558">[2 more]</label></div><br/><div class="children"><div class="content">All that instead of type classes eh?</div><br/><div id="37671869" class="c"><input type="checkbox" id="c-37671869" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#37670022">root</a><span>|</span><a href="#37670558">parent</a><span>|</span><a href="#37669929">next</a><span>|</span><label class="collapse" for="c-37671869">[-]</label><label class="expand" for="c-37671869">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Pains me to see what they are doing while not learning from existing and well established language patterns.<p>I understand that Go wants (or wanted) to stay &quot;simple&quot; but now it seems to become the worst of two worlds: it&#x27;s neither simple anymore but also doesn&#x27;t benefit from high level language features like typeclasses because it&#x27;s too late to add them now.</div><br/></div></div></div></div></div></div></div></div><div id="37669929" class="c"><input type="checkbox" id="c-37669929" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#37670022">prev</a><span>|</span><a href="#37670790">next</a><span>|</span><label class="collapse" for="c-37669929">[-]</label><label class="expand" for="c-37669929">[3 more]</label></div><br/><div class="children"><div class="content">I’m almost a grey beard in typed functional programming and I’m actually confused by this.</div><br/><div id="37669970" class="c"><input type="checkbox" id="c-37669970" checked=""/><div class="controls bullet"><span class="by">sharno</span><span>|</span><a href="#37669929">parent</a><span>|</span><a href="#37670790">next</a><span>|</span><label class="collapse" for="c-37669970">[-]</label><label class="expand" for="c-37669970">[2 more]</label></div><br/><div class="children"><div class="content">The language and way of writing feels very weird. The concepts are simple genetics but for some reason I don’t get the idea of underlying type. Wish they used a more formal language</div><br/><div id="37670473" class="c"><input type="checkbox" id="c-37670473" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#37669929">root</a><span>|</span><a href="#37669970">parent</a><span>|</span><a href="#37670790">next</a><span>|</span><label class="collapse" for="c-37670473">[-]</label><label class="expand" for="c-37670473">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not doing anything particularly interesting from a formal perspective. If you&#x27;re familiar with Haskell&#x27;s newtype deriving, the tilde is solving the same problem—just at the use-sites of the type instead of at the declaration site. The types it tends to be useful for are the types that Go allows as constants (<a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Constants" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Constants</a>), which tend to be the type classes that modern Preludes will overload the literals for.</div><br/></div></div></div></div></div></div><div id="37670790" class="c"><input type="checkbox" id="c-37670790" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#37669929">prev</a><span>|</span><a href="#37670698">next</a><span>|</span><label class="collapse" for="c-37670790">[-]</label><label class="expand" for="c-37670790">[1 more]</label></div><br/><div class="children"><div class="content">I am a Go fan and have been coding in it for years, but this crap:<p>func Clone[S ~[]E, E any](s S) S {
    return append(s[:0:0], s...)
}<p>looks just like Rust, which has the fugliest syntax I have ever seen. Personally I use maybe 3 or 4 generic functions to work with arrays(oh, sorry SLICES), otherwise I do not touch them. Could not care less about them and all that noise they caused.</div><br/></div></div><div id="37670698" class="c"><input type="checkbox" id="c-37670698" checked=""/><div class="controls bullet"><span class="by">mutatio</span><span>|</span><a href="#37670790">prev</a><span>|</span><label class="collapse" for="c-37670698">[-]</label><label class="expand" for="c-37670698">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I&#x27;m following the preamble about the nuances of a slice with a zero capacity allocating a new backing array, given the fact that if I follow the link to the docs and then to the source, the implementation is exactly how I would have expected it to be done: append(S([]E{}), s...) - which of course is different and would make the preamble redundant.</div><br/><div id="37670815" class="c"><input type="checkbox" id="c-37670815" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#37670698">parent</a><span>|</span><label class="collapse" for="c-37670815">[-]</label><label class="expand" for="c-37670815">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that originally, the post didn&#x27;t have &quot;&#x2F;&#x2F; body omitted&quot; below.<p>The actual implementation requires having the `S` type to refer to, and the point of this post is to explain why the `S` type has to be named. By writing it as they did, the &quot;&#x2F;&#x2F; body omitted&quot; one _could_ have had the same body, even without an &#x27;S&#x27; type to refer to.<p>I bet the &quot;&#x2F;&#x2F; body omitted&quot; bit of the post got refactored, and the reason for making the first one different from the stdlib impl got lost.</div><br/></div></div></div></div></div></div></div></div></div></body></html>