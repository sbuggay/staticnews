<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690621243288" as="style"/><link rel="stylesheet" href="styles.css?v=1690621243288"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://capnproto.org/news/2023-07-28-capnproto-1.0.html">Cap&#x27;n Proto 1.0</a> <span class="domain">(<a href="https://capnproto.org">capnproto.org</a>)</span></div><div class="subtext"><span>kentonv</span> | <span>201 comments</span></div><br/><div><div id="36911490" class="c"><input type="checkbox" id="c-36911490" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36909145">next</a><span>|</span><label class="collapse" for="c-36911490">[-]</label><label class="expand" for="c-36911490">[12 more]</label></div><br/><div class="children"><div class="content">I have some very unfortunate news to share with the Cap&#x27;n Proto and Sandstorm communities.<p>Ian Denhardt (zenhack on HN), a lead contributor to the Go implementation, suddenly and unexpectedly passed away a few weeks ago.  Before making a request to the community, I want to express how deeply saddened I am by this loss.  Ian and I collaborated extensively over the past three years, and we had become friends.<p>As the <i>de facto</i> project lead, it now befalls me to fill Ian&#x27;s very big shoes.  Please, if you&#x27;re able to contribute to the project, I could really use the help.  And if you&#x27;re a contributor or maintainer of some other implementation (C++, Rust, etc.), I would *REALLY* appreciate it if we could connect.  I&#x27;m going to need to surround myself with very smart people if I am to continue Ian&#x27;s work.<p>RIP Ian, and thank you.  I learned so much working with you.<p>------<p>P.S:  I can be reached in the following places<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;lthibault">https:&#x2F;&#x2F;github.com&#x2F;lthibault</a><p>- <a href="https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#go-capnp:matrix.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#go-capnp:matrix.org</a><p>- Telegram:  @lthibault<p>- gmail:  louist87</div><br/><div id="36912975" class="c"><input type="checkbox" id="c-36912975" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#36911490">parent</a><span>|</span><a href="#36912167">next</a><span>|</span><label class="collapse" for="c-36912975">[-]</label><label class="expand" for="c-36912975">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a couple people suddenly taken from me, and it is soul crushing.  Every time it happens it reminds me of how fragile life is, and how quickly things can change.  I&#x27;ve started trying to enjoy the small things in life more, and while I don&#x27;t neglect the future, I also try to enjoy the present.<p>He has left an amazing legacy that has touched a lot of people.  RIP Ian.</div><br/><div id="36914347" class="c"><input type="checkbox" id="c-36914347" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912975">parent</a><span>|</span><a href="#36912167">next</a><span>|</span><label class="collapse" for="c-36914347">[-]</label><label class="expand" for="c-36914347">[1 more]</label></div><br/><div class="children"><div class="content">Every damn day, something comes up that makes me go, &quot;Oh, I should ask Ian about tha-&quot;<p>It really sucks.  And I know exactly what you mean.</div><br/></div></div></div></div><div id="36912167" class="c"><input type="checkbox" id="c-36912167" checked=""/><div class="controls bullet"><span class="by">jcalabro</span><span>|</span><a href="#36911490">parent</a><span>|</span><a href="#36912975">prev</a><span>|</span><a href="#36912092">next</a><span>|</span><label class="collapse" for="c-36912167">[-]</label><label class="expand" for="c-36912167">[6 more]</label></div><br/><div class="children"><div class="content">Oh gosh, I didn&#x27;t know that. Thank you for sharing :( I really loved his blog. That&#x27;s awful.</div><br/><div id="36912316" class="c"><input type="checkbox" id="c-36912316" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912167">parent</a><span>|</span><a href="#36912092">next</a><span>|</span><label class="collapse" for="c-36912316">[-]</label><label class="expand" for="c-36912316">[5 more]</label></div><br/><div class="children"><div class="content">Indeed.  His blog was outstanding.  It might be a good idea to mirror his blog before the domain expires, as it&#x27;s a real treasure-trove.</div><br/><div id="36912606" class="c"><input type="checkbox" id="c-36912606" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912316">parent</a><span>|</span><a href="#36912092">next</a><span>|</span><label class="collapse" for="c-36912606">[-]</label><label class="expand" for="c-36912606">[4 more]</label></div><br/><div class="children"><div class="content">I already have a copy (it&#x27;s a static site). I can rehost it if needed, but I&#x27;d want to get permission to do so from someone first.</div><br/><div id="36912673" class="c"><input type="checkbox" id="c-36912673" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912606">parent</a><span>|</span><a href="#36913028">next</a><span>|</span><label class="collapse" for="c-36912673">[-]</label><label class="expand" for="c-36912673">[1 more]</label></div><br/><div class="children"><div class="content">Christine Lemmer-Webber (<a href="https:&#x2F;&#x2F;dustycloud.org&#x2F;contact&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dustycloud.org&#x2F;contact&#x2F;</a>) may be able to put you in touch with Ian&#x27;s surviving partner.</div><br/></div></div><div id="36913028" class="c"><input type="checkbox" id="c-36913028" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912606">parent</a><span>|</span><a href="#36912673">prev</a><span>|</span><a href="#36912092">next</a><span>|</span><label class="collapse" for="c-36913028">[-]</label><label class="expand" for="c-36913028">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m able to connect you with Ian&#x27;s partner, if you&#x27;d like.</div><br/></div></div></div></div></div></div></div></div><div id="36912092" class="c"><input type="checkbox" id="c-36912092" checked=""/><div class="controls bullet"><span class="by">pja</span><span>|</span><a href="#36911490">parent</a><span>|</span><a href="#36912167">prev</a><span>|</span><a href="#36914564">next</a><span>|</span><label class="collapse" for="c-36912092">[-]</label><label class="expand" for="c-36912092">[2 more]</label></div><br/><div class="children"><div class="content">It seems @zenhack maintained the Haskell bindings as well.</div><br/><div id="36912292" class="c"><input type="checkbox" id="c-36912292" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36911490">root</a><span>|</span><a href="#36912092">parent</a><span>|</span><a href="#36914564">next</a><span>|</span><label class="collapse" for="c-36912292">[-]</label><label class="expand" for="c-36912292">[1 more]</label></div><br/><div class="children"><div class="content">I think the Haskell project was a complete implementation, not just bindings.  But yes, Ian was truly prolific.</div><br/></div></div></div></div><div id="36914564" class="c"><input type="checkbox" id="c-36914564" checked=""/><div class="controls bullet"><span class="by">doh</span><span>|</span><a href="#36911490">parent</a><span>|</span><a href="#36912092">prev</a><span>|</span><a href="#36909145">next</a><span>|</span><label class="collapse" for="c-36914564">[-]</label><label class="expand" for="c-36914564">[1 more]</label></div><br/><div class="children"><div class="content">That is really sad news. Ian was an inspiration. Sorry for your loss and the loss of the whole community. He will be greatly missed.</div><br/></div></div></div></div><div id="36909145" class="c"><input type="checkbox" id="c-36909145" checked=""/><div class="controls bullet"><span class="by">CodesInChaos</span><span>|</span><a href="#36911490">prev</a><span>|</span><a href="#36909087">next</a><span>|</span><label class="collapse" for="c-36909145">[-]</label><label class="expand" for="c-36909145">[18 more]</label></div><br/><div class="children"><div class="content">I find it surprising how few protocols (besides Cap&#x27;n Proto) have promise pipelining. The only other example I can think of is 9p, but that&#x27;s not a general purpose protocol.<p><a href="https:&#x2F;&#x2F;capnproto.org&#x2F;news&#x2F;2013-12-13-promise-pipelining-capnproto-vs-ice.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;capnproto.org&#x2F;news&#x2F;2013-12-13-promise-pipelining-cap...</a></div><br/><div id="36909642" class="c"><input type="checkbox" id="c-36909642" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36911259">next</a><span>|</span><label class="collapse" for="c-36909642">[-]</label><label class="expand" for="c-36909642">[6 more]</label></div><br/><div class="children"><div class="content">As neat as it is I guess it&#x27;s hard optimize the backend for it compared to explicitly grouping the queries.  I imagine a bespoke RPC call that results in a single SQL query is better than several pipelined but separate RPC calls, for example.<p>But even still, you would think it would be more popular.</div><br/><div id="36911688" class="c"><input type="checkbox" id="c-36911688" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36909642">parent</a><span>|</span><a href="#36911259">next</a><span>|</span><label class="collapse" for="c-36911688">[-]</label><label class="expand" for="c-36911688">[5 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re thinking strictly about stateless backends that just convert every request into a SQL query, then yeah, promise pipelining might not be very helpful.<p>I think where it shines is when interacting with stateful services. I think part of the reason everyone tries to make everything stateless is because we don&#x27;t have good protocols for managing state. Cap&#x27;n Proto RPC is actually quite good at it.</div><br/><div id="36912159" class="c"><input type="checkbox" id="c-36912159" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36911688">parent</a><span>|</span><a href="#36917030">next</a><span>|</span><label class="collapse" for="c-36912159">[-]</label><label class="expand" for="c-36912159">[3 more]</label></div><br/><div class="children"><div class="content">The issue is that having per-session&#x2F;transaction state on the server makes load balancing requests more difficult; especially when that state is long-lived.</div><br/><div id="36912537" class="c"><input type="checkbox" id="c-36912537" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36912159">parent</a><span>|</span><a href="#36917030">next</a><span>|</span><label class="collapse" for="c-36912537">[-]</label><label class="expand" for="c-36912537">[2 more]</label></div><br/><div class="children"><div class="content">While it&#x27;s true that load-balancing long-lived resources is harder than short-lived, a lot of the difficulty of load balancing with stateful servers is actually in the protocol, because you somehow have to make sure subsequent requests for the same state land on the correct server.<p>Cap&#x27;n Proto actually does really well with this basic difficulty, because it treats object references as a first-class thing. When you create some state, you receive back a reference to the state, and you can make subsequent requests on that reference. The load balancer can <i>see</i> that this has happened, even if it doesn&#x27;t know the details of the application, because object references are marked as such at the RPC layer independent of schema. Whereas in a system that returns some sort of &quot;object ID&quot; as a string, and expects you to pass that ID back to the server on subsequent requests, the load balancer is not going to have any idea what&#x27;s going on, unless you do extra work to teach the load balancer about your protocol.</div><br/><div id="36916616" class="c"><input type="checkbox" id="c-36916616" checked=""/><div class="controls bullet"><span class="by">parkerduckworth</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36912537">parent</a><span>|</span><a href="#36917030">next</a><span>|</span><label class="collapse" for="c-36916616">[-]</label><label class="expand" for="c-36916616">[1 more]</label></div><br/><div class="children"><div class="content">Wow that is super interesting. Thanks for sharing.</div><br/></div></div></div></div></div></div><div id="36917030" class="c"><input type="checkbox" id="c-36917030" checked=""/><div class="controls bullet"><span class="by">TOGoS</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36911688">parent</a><span>|</span><a href="#36912159">prev</a><span>|</span><a href="#36911259">next</a><span>|</span><label class="collapse" for="c-36917030">[-]</label><label class="expand" for="c-36917030">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s the same backend handling multiple chained requests that happen to use the same database, it could in turn build a single big SQL query to generate the result(s).  I used to write stuff like this all the time (not specifically Cap&#x27;n Proto servers, but general functional expression -&gt; SQL -&gt; here&#x27;s your answer engines).</div><br/></div></div></div></div></div></div><div id="36911259" class="c"><input type="checkbox" id="c-36911259" checked=""/><div class="controls bullet"><span class="by">catern</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36909642">prev</a><span>|</span><a href="#36913715">next</a><span>|</span><label class="collapse" for="c-36911259">[-]</label><label class="expand" for="c-36911259">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know 9p had promise pipelining!<p>Or more specifically, it seems to have client-chosen file descriptors, so the client can open a file, then immediately send a read on that file, and if the open fails, the read will also fail (with EBADF).  Awesome!<p>This is great, but &quot;promise pipelining&quot; also needs support in the client. 
 Are there 9p clients which support promise pipelining?  For example, if the user issues several walks, they&#x27;re all sent before waiting for the reply to the first walk?<p>Also, it only has promise pipelining for file descriptors.  That gives you a lot, definitely, but if for example you wanted to read every file in a directory, you&#x27;d want to be able to issue a read and then walk to the result of that read.  Which 9p doesn&#x27;t seem to support.  (I actually support this in my own remote syscall protocol library thing, rsyscall :) )</div><br/></div></div><div id="36913715" class="c"><input type="checkbox" id="c-36913715" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36911259">prev</a><span>|</span><a href="#36913495">next</a><span>|</span><label class="collapse" for="c-36913715">[-]</label><label class="expand" for="c-36913715">[1 more]</label></div><br/><div class="children"><div class="content">There is also CapnP’s moral ancestor CapTP[1]&#x2F;VatTP aka Pluribus developed to accompany Mark Miller’s E language (yes, it’s a pun, there is also a gadget called an “unum” in there). For deeper genealogy—including a reference to Barbara Liskov for promise pipelining and a number of other relevant ideas in the CLU extension Argus—see his thesis[2].<p>(If I’m not misremembering, Mark Miller later wrote the promise proposal for JavaScript, except the planned extension for RPC never materialized and instead we got async&#x2F;await, which don’t seem compatible with pipelining.)<p>The more recent attempts to make a distributed capability system in the image of E, like Spritely Goblins[3] and the OCapN effort[4], also try for pipelining, so maybe if you hang out on cap-talk[5] you’ll hear about a couple of other protocols that do it, if not ones with any real-world usage.<p>(And I again reiterate that, neat as it is, promise pipelining seems to require programming with actual explicit promises, and at this point it’s well-established how gnarly that can get.)<p>One idea that I find interesting and little-known from the other side—event loops and cooperatively concurrent “active objects”—is “causality IDs”[6] from DCOM&#x2F;COM+ as a means of controlling reentrancy, see CoGetCurrentLogicalThreadId[7] in the Microsoft documentation and the discussion of CALLTYPE_TOPLEVEL_CALLPENDING in <i>Effective COM</i>[8]—I think they later tried to sell this as a new feature in Win8&#x2F;UWP’s ASTAs[9]?<p>[1] <a href="http:&#x2F;&#x2F;erights.org&#x2F;elib&#x2F;distrib&#x2F;captp&#x2F;index.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;erights.org&#x2F;elib&#x2F;distrib&#x2F;captp&#x2F;index.html</a><p>[2] <a href="http:&#x2F;&#x2F;erights.org&#x2F;talks&#x2F;thesis&#x2F;index.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;erights.org&#x2F;talks&#x2F;thesis&#x2F;index.html</a><p>[3] <a href="https:&#x2F;&#x2F;spritely.institute&#x2F;goblins&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;spritely.institute&#x2F;goblins&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;ocapn&#x2F;ocapn">https:&#x2F;&#x2F;github.com&#x2F;ocapn&#x2F;ocapn</a><p>[5] <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;captalk&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;captalk&#x2F;</a><p>[6] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-dcom&#x2F;e3884865-47e6-40c3-8b24-0ffd0309f4b7" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-d...</a><p>[7] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;windows&#x2F;win32&#x2F;api&#x2F;combaseapi&#x2F;nf-combaseapi-cogetcurrentlogicalthreadid" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;windows&#x2F;win32&#x2F;api&#x2F;combaseapi&#x2F;nf-...</a><p>[8] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;effectivecom50wa00boxd&#x2F;page&#x2F;150" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;effectivecom50wa00boxd&#x2F;page&#x2F;150</a><p>[9] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20210224-00&#x2F;?p=104901" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20210224-00&#x2F;?p=10...</a></div><br/></div></div><div id="36913495" class="c"><input type="checkbox" id="c-36913495" checked=""/><div class="controls bullet"><span class="by">dontlaugh</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36913715">prev</a><span>|</span><a href="#36910962">next</a><span>|</span><label class="collapse" for="c-36913495">[-]</label><label class="expand" for="c-36913495">[3 more]</label></div><br/><div class="children"><div class="content">io_uring supports that too, although not a network protocol.</div><br/><div id="36914302" class="c"><input type="checkbox" id="c-36914302" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36913495">parent</a><span>|</span><a href="#36910962">next</a><span>|</span><label class="collapse" for="c-36914302">[-]</label><label class="expand" for="c-36914302">[2 more]</label></div><br/><div class="children"><div class="content">Last time I checked (a couple of years ago) they wanted to use eBPF to handle this sort of problem. Did they end up doing something simpler?</div><br/><div id="36914337" class="c"><input type="checkbox" id="c-36914337" checked=""/><div class="controls bullet"><span class="by">dontlaugh</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36914302">parent</a><span>|</span><a href="#36910962">next</a><span>|</span><label class="collapse" for="c-36914337">[-]</label><label class="expand" for="c-36914337">[1 more]</label></div><br/><div class="children"><div class="content">Yes. io_uring lets you issue multiple syscalls together, with the result from some being parameters for others.</div><br/></div></div></div></div></div></div><div id="36910962" class="c"><input type="checkbox" id="c-36910962" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36913495">prev</a><span>|</span><a href="#36909426">next</a><span>|</span><label class="collapse" for="c-36910962">[-]</label><label class="expand" for="c-36910962">[2 more]</label></div><br/><div class="children"><div class="content">Without knowing how exactly capnproto promise pipelining works, when I thought about it, I was concerned about cases like reading a directory and stating everything in it, or getting back two response values and wanting to pass only one to the next call. The latter could be made to work, I guess, but the former depends on eg the number of values in the result list.</div><br/><div id="36912599" class="c"><input type="checkbox" id="c-36912599" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36910962">parent</a><span>|</span><a href="#36909426">next</a><span>|</span><label class="collapse" for="c-36912599">[-]</label><label class="expand" for="c-36912599">[1 more]</label></div><br/><div class="children"><div class="content">In the actual implementation, when making a pipelined call on a result X, you actually say something like &quot;Call X.foo.bar.baz()&quot; -- that is, you can specify a nested property of the results which names the object that you actually want to operate on.<p>At present, the only operation allowed here is reading a nested property, and that seems to solve 99% of use cases. But one could imagine allowing other operations, like &quot;take the Nth element of this array&quot; or even &quot;apply this call to <i>all</i> elements in the array, returning an array of results&quot;.</div><br/></div></div></div></div><div id="36909426" class="c"><input type="checkbox" id="c-36909426" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#36909145">parent</a><span>|</span><a href="#36910962">prev</a><span>|</span><a href="#36909087">next</a><span>|</span><label class="collapse" for="c-36909426">[-]</label><label class="expand" for="c-36909426">[4 more]</label></div><br/><div class="children"><div class="content">Redis transactions [1] also apply pipelining, but AFAICT there is no practical way to use them for implementing generic RPC.<p>[1] <a href="https:&#x2F;&#x2F;redis.com&#x2F;ebook&#x2F;part-2-core-concepts&#x2F;chapter-4-keeping-data-safe-and-ensuring-performance&#x2F;4-4-redis-transactions&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;redis.com&#x2F;ebook&#x2F;part-2-core-concepts&#x2F;chapter-4-keepi...</a></div><br/><div id="36909918" class="c"><input type="checkbox" id="c-36909918" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36909426">parent</a><span>|</span><a href="#36909087">next</a><span>|</span><label class="collapse" for="c-36909918">[-]</label><label class="expand" for="c-36909918">[3 more]</label></div><br/><div class="children"><div class="content">Does the pipelining in Redis allow you to have the second command depend on the result of the first command?</div><br/><div id="36910241" class="c"><input type="checkbox" id="c-36910241" checked=""/><div class="controls bullet"><span class="by">byroot</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36909918">parent</a><span>|</span><a href="#36909087">next</a><span>|</span><label class="collapse" for="c-36910241">[-]</label><label class="expand" for="c-36910241">[2 more]</label></div><br/><div class="children"><div class="content">No, but for that use case you have EVAL which execute an arbitrary lua script on the server.<p><a href="https:&#x2F;&#x2F;redis.io&#x2F;commands&#x2F;eval&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;redis.io&#x2F;commands&#x2F;eval&#x2F;</a></div><br/><div id="36910318" class="c"><input type="checkbox" id="c-36910318" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#36909145">root</a><span>|</span><a href="#36910241">parent</a><span>|</span><a href="#36909087">next</a><span>|</span><label class="collapse" for="c-36910318">[-]</label><label class="expand" for="c-36910318">[1 more]</label></div><br/><div class="children"><div class="content">That assumes you know &amp; can generate the complete pipeline ahead of time. The elegance of promise pipelining is that your pipeline can also be asynchronously grown.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36909087" class="c"><input type="checkbox" id="c-36909087" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#36909145">prev</a><span>|</span><a href="#36911349">next</a><span>|</span><label class="collapse" for="c-36909087">[-]</label><label class="expand" for="c-36909087">[10 more]</label></div><br/><div class="children"><div class="content">Congrats on the release! It must be very exciting after 10 years :)<p>If you don&#x27;t mind the question: will there be more work on implementations for other languages in the future? I really like the idea of the format, but the main languages in our stack aren&#x27;t supported in a way I&#x27;d use in a product.</div><br/><div id="36909323" class="c"><input type="checkbox" id="c-36909323" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909087">parent</a><span>|</span><a href="#36913016">next</a><span>|</span><label class="collapse" for="c-36909323">[-]</label><label class="expand" for="c-36909323">[8 more]</label></div><br/><div class="children"><div class="content">This is indeed the main weakness of Cap&#x27;n Proto. I only really maintain the C++ implementation. Other implementations come from various contributors which can lead to varying levels of completeness and quality.<p>Unfortunately I can&#x27;t really promise anything new here. My work on Cap&#x27;n Proto is driven by the needs of my main project, the Cloudflare Workers runtime, which is primarily C++. We do interact with Go and Rust services, and the respective implementations seem to get the job done there.<p>Put another way, Cap&#x27;n Proto is an open source project, and I hope it is useful to people, but it is not a product I&#x27;m trying to sell, so I am not particularly focused on trying to get everyone to adopt it. As always, contributions are welcome.<p>The one case where I might foresee a big change is if we (Cloudflare) decided to make Cap&#x27;n Proto be a public-facing feature of the Workers platform. Then we&#x27;d have a direct need to really polish it in many languages. That is certainly something we discuss from time to time but there are no plans at present.</div><br/><div id="36913371" class="c"><input type="checkbox" id="c-36913371" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36909323">parent</a><span>|</span><a href="#36909449">next</a><span>|</span><label class="collapse" for="c-36913371">[-]</label><label class="expand" for="c-36913371">[4 more]</label></div><br/><div class="children"><div class="content">Hmm, the main weakness of Cap&#x27;n Proto is that you have to already know so much stuff in order to understand why it makes all the great decisions it does. The weakness you&#x27;re talking about matters to me, sure, I don&#x27;t use Cap&#x27;n&#x27;Proto because it lacks the same tooling as gRPC, but it is better than gRPC from an ideas point of view.<p>I am not going to write those language implementations, I have other stuff I need to do, and gRPC is good enough. But the people who <i>love</i> writing language implementations <i>might not</i> understand why Cap&#x27;n Proto is great, or at least not understand as well as they understand Golang and Rust, so they will rewrite X in Golang and Rust instead.<p>Anyway, the great ideas haven&#x27;t changed in whatever it is, almost 10-15 years you&#x27;ve been working on this, they&#x27;ve been right all along. So it is really about communication.<p>A comment on HN that really stuck with me was like: &quot;Man dude, this is great, but try to explain to my team that it&#x27;s Not React. They won&#x27;t care.&quot;<p>I&#x27;m just a guy, I don&#x27;t know how to distill how good Cap&#x27;n Proto is. But &quot;The Unreasonable Effectiveness of Recurrent Neural Networks&quot; is the prototype. What is the unreasonable effectiveness of Cap&#x27;n Proto? In games, which I&#x27;m familiar with, entity component systems, user generated content and their tooling have a lot in common with Cap&#x27;n Proto. &quot;The Unreasonable Effectiveness of ECS&quot; is deterministic multiplayer, but that is also really poorly communicated, and thus limits adoption. Maybe you are already facing the same obstacles with Cloudflare Workers. It&#x27;s all very communications related and I hope you get more adoption.</div><br/><div id="36913432" class="c"><input type="checkbox" id="c-36913432" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36913371">parent</a><span>|</span><a href="#36909449">next</a><span>|</span><label class="collapse" for="c-36913432">[-]</label><label class="expand" for="c-36913432">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, this has been the struggle with Sandstorm and self-hosting too. Ten years on, I&#x27;m still confident it&#x27;s the best way to self-host, but to convince someone of that I have to sit them down and figure out how to get them to understand capability-based security, and most people lose interest about... immediately. :P<p>I suspect a lot of things will eventually look more like Cap&#x27;n Proto and Sandstorm, but it will take a lot of time for everyone else to get there.</div><br/><div id="36915131" class="c"><input type="checkbox" id="c-36915131" checked=""/><div class="controls bullet"><span class="by">pbronez</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36913432">parent</a><span>|</span><a href="#36909449">next</a><span>|</span><label class="collapse" for="c-36915131">[-]</label><label class="expand" for="c-36915131">[2 more]</label></div><br/><div class="children"><div class="content">I’m sold on Sandstorm, but the company folded before I could do anything with it. If someone makes another push at it, I have a lot of security-focused enterprise folks who want more robust &amp; streamlined ways to self host stuff.</div><br/><div id="36915191" class="c"><input type="checkbox" id="c-36915191" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36915131">parent</a><span>|</span><a href="#36909449">next</a><span>|</span><label class="collapse" for="c-36915191">[-]</label><label class="expand" for="c-36915191">[1 more]</label></div><br/><div class="children"><div class="content">I have been pretty invested into Sandstorm for like ten years now, so I am very interested in getting that new push moving. If you know people interested in contributing to the project in any way, we are definitely interested in looking at ways to make it happen.<p>We will probably put out a blog post sometime soon with an update.</div><br/></div></div></div></div></div></div></div></div><div id="36909449" class="c"><input type="checkbox" id="c-36909449" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36909323">parent</a><span>|</span><a href="#36913371">prev</a><span>|</span><a href="#36910196">next</a><span>|</span><label class="collapse" for="c-36909449">[-]</label><label class="expand" for="c-36909449">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s completely understandable, thank you for the answer! I&#x27;d love to try and help with at least one implementation for those languages, but there&#x27;s a good chance that it would end up like the existing implementations due to lack of time.<p>Anyway, thank you for making it open source and for working on it all this time!</div><br/></div></div><div id="36910196" class="c"><input type="checkbox" id="c-36910196" checked=""/><div class="controls bullet"><span class="by">thegagne</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36909323">parent</a><span>|</span><a href="#36909449">prev</a><span>|</span><a href="#36913016">next</a><span>|</span><label class="collapse" for="c-36910196">[-]</label><label class="expand" for="c-36910196">[2 more]</label></div><br/><div class="children"><div class="content">&gt; if we (Cloudflare) decided to make Cap&#x27;n Proto be a public-facing feature of the Workers platform.<p>How likely is this? What would be the benefits and use-cases of doing this? Would it be a standardized JS offering, or something specific to Workers that is deserialized before it hits the runtime?</div><br/><div id="36910681" class="c"><input type="checkbox" id="c-36910681" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909087">root</a><span>|</span><a href="#36910196">parent</a><span>|</span><a href="#36913016">next</a><span>|</span><label class="collapse" for="c-36910681">[-]</label><label class="expand" for="c-36910681">[1 more]</label></div><br/><div class="children"><div class="content">This really hasn&#x27;t been fleshed out at all, it&#x27;s more like: &quot;Well, we&#x27;re built on Cap&#x27;n Proto, it&#x27;d be really easy to expose it for applications to use. But is it useful?&quot;<p>Arguably Cap&#x27;n Proto RPC might be an interesting way for a Worker running on Cloudflare to talk to a back-end service, or to a service running in a container (if&#x2F;when we support containers). Today you mostly have to use HTTP for this (which has its drawbacks) or raw TCP (which requires bringing your own protocol parser to run in &quot;userspace&quot;).<p>That said there&#x27;s obviously a much stronger case to make for supporting gRPC or other protocols that are more widely used.</div><br/></div></div></div></div></div></div><div id="36913016" class="c"><input type="checkbox" id="c-36913016" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36909087">parent</a><span>|</span><a href="#36909323">prev</a><span>|</span><a href="#36911349">next</a><span>|</span><label class="collapse" for="c-36913016">[-]</label><label class="expand" for="c-36913016">[1 more]</label></div><br/><div class="children"><div class="content">There are people who have tried to write the RPC layer without it simply being a wrapper around the C++ implementation, but it&#x27;s a <i>LOT</i> of code to rewrite for not a lot of direct benefit.<p>Feel free to take a crack at it.  People would likely be rather cooperative about it.  However, know that it&#x27;s just simply a lot of work.</div><br/></div></div></div></div><div id="36911349" class="c"><input type="checkbox" id="c-36911349" checked=""/><div class="controls bullet"><span class="by">hiddencost</span><span>|</span><a href="#36909087">prev</a><span>|</span><a href="#36908995">next</a><span>|</span><label class="collapse" for="c-36911349">[-]</label><label class="expand" for="c-36911349">[2 more]</label></div><br/><div class="children"><div class="content">For context: Kenton ran Google&#x27;s in house proto system for many years, before leaving and building his own open source version.</div><br/><div id="36911479" class="c"><input type="checkbox" id="c-36911479" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#36911349">parent</a><span>|</span><a href="#36908995">next</a><span>|</span><label class="collapse" for="c-36911479">[-]</label><label class="expand" for="c-36911479">[1 more]</label></div><br/><div class="children"><div class="content">I believe he was the one who open-sourced protobufs.</div><br/></div></div></div></div><div id="36908995" class="c"><input type="checkbox" id="c-36908995" checked=""/><div class="controls bullet"><span class="by">maccam912</span><span>|</span><a href="#36911349">prev</a><span>|</span><a href="#36909186">next</a><span>|</span><label class="collapse" for="c-36908995">[-]</label><label class="expand" for="c-36908995">[10 more]</label></div><br/><div class="children"><div class="content">If any cloudflare employees end up here who helped decide on Capn Proto over other stuff (e.g. protobuf), what considerations went into that choice? I&#x27;m curious if the reasons will be things important to me, or things that you don&#x27;t need to worry about unless you deal with huge scale.</div><br/><div id="36909488" class="c"><input type="checkbox" id="c-36909488" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36908995">parent</a><span>|</span><a href="#36909173">next</a><span>|</span><label class="collapse" for="c-36909488">[-]</label><label class="expand" for="c-36909488">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a blog post about Cloudflare&#x27;s use of Cap&#x27;n Proto in 2014, three years before I joined: <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-lua-capnproto-better-serialization-in-lua&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-lua-capnproto-better...</a><p>To this day, Cloudflare&#x27;s data pipeline (which produces logs and analytics from the edge) is largely based on Cap&#x27;n Proto serialization. I haven&#x27;t personally been much involved with that project.<p>As for Cloudflare Workers, of course, I started the project, so I used my stuff. Probably not the justification you&#x27;re looking for. :)<p>That said, I would argue the extreme expressiveness of Cap&#x27;n Proto&#x27;s RPC protocol compared to alternatives has been a big help in implementing sandboxing in the Workers Runtime, as well as distributed systems features like Durable Objects. <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-workers-durable-objects&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-workers-durable-obje...</a></div><br/></div></div><div id="36909173" class="c"><input type="checkbox" id="c-36909173" checked=""/><div class="controls bullet"><span class="by">coolsunglasses</span><span>|</span><a href="#36908995">parent</a><span>|</span><a href="#36909488">prev</a><span>|</span><a href="#36910969">next</a><span>|</span><label class="collapse" for="c-36909173">[-]</label><label class="expand" for="c-36909173">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t work at Cloudflare but follow their work and occasionally work on performance sensitive projects.<p>If I had to guess, they looked at the landscape a bit like I do and regarded Cap&#x27;n Proto, flatbuffers, SBE, etc. as being in one category apart from other data formats like Avro, protobuf, and the like.<p>So once you&#x27;re committed to record&#x27;ish shaped (rather than columnar like Parquet) data that has an upfront parse time of zero (nominally, there could be marshalling if you transmogrify the field values on read), the list gets pretty short.<p><a href="https:&#x2F;&#x2F;capnproto.org&#x2F;news&#x2F;2014-06-17-capnproto-flatbuffers-sbe.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;capnproto.org&#x2F;news&#x2F;2014-06-17-capnproto-flatbuffers-...</a> goes into some of the trade-offs here.<p>Cap&#x27;n Proto was originally made for <a href="https:&#x2F;&#x2F;sandstorm.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;sandstorm.io&#x2F;</a>. That work (which Kenton has presumably done at Cloudflare since he&#x27;s been employed there) eventually turned into Cloudflare workers.<p>Another consideration: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;flatbuffers&#x2F;issues&#x2F;2#issuecomment-215203333">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;flatbuffers&#x2F;issues&#x2F;2#issuecomment-...</a></div><br/><div id="36912728" class="c"><input type="checkbox" id="c-36912728" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36908995">root</a><span>|</span><a href="#36909173">parent</a><span>|</span><a href="#36910969">next</a><span>|</span><label class="collapse" for="c-36912728">[-]</label><label class="expand" for="c-36912728">[2 more]</label></div><br/><div class="children"><div class="content">Aside from CF Workers using capn proto, how is it related to capn proto or sandstorm?</div><br/><div id="36912987" class="c"><input type="checkbox" id="c-36912987" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36908995">root</a><span>|</span><a href="#36912728">parent</a><span>|</span><a href="#36910969">next</a><span>|</span><label class="collapse" for="c-36912987">[-]</label><label class="expand" for="c-36912987">[1 more]</label></div><br/><div class="children"><div class="content">They are all projects I started.<p>But other than who worked on them, and sharing some technology choices under the hood, there&#x27;s mostly no relationship between Workers and Sandstorm.</div><br/></div></div></div></div></div></div><div id="36910969" class="c"><input type="checkbox" id="c-36910969" checked=""/><div class="controls bullet"><span class="by">hblanks</span><span>|</span><a href="#36908995">parent</a><span>|</span><a href="#36909173">prev</a><span>|</span><a href="#36909032">next</a><span>|</span><label class="collapse" for="c-36910969">[-]</label><label class="expand" for="c-36910969">[1 more]</label></div><br/><div class="children"><div class="content">To summarize something from a little over a year after I joined there: Cloudflare was building out a way to ship logs from its edge to a central point for customer analytics and serving logs to enterprise customers. As I understood it, the primary engineer who built all of that out, Albert Strasheim, benchmarked the most likely serialization options available and found Cap&#x27;n Proto to be appreciably faster than protobuf. It had a great C++ implementation (which we could use from nginx, IIRC with some lua involved) and while the Go implementation, which we used on the consuming side, had its warts, folks were able to fix the key parts that needed attention.<p>Anyway. Cloudflare&#x27;s always been pretty cost efficient machine wise, so it was a natural choice given the performance needs we had. In my time in the data team there, Cap&#x27;n Proto was always pretty easy to work with, and sharing proto definitions from a central schema repo worked pretty well, too. Thanks for your work, Kenton!</div><br/></div></div><div id="36909032" class="c"><input type="checkbox" id="c-36909032" checked=""/><div class="controls bullet"><span class="by">matlin</span><span>|</span><a href="#36908995">parent</a><span>|</span><a href="#36910969">prev</a><span>|</span><a href="#36909186">next</a><span>|</span><label class="collapse" for="c-36909032">[-]</label><label class="expand" for="c-36909032">[4 more]</label></div><br/><div class="children"><div class="content">The lead dev of Cloudflare workers is the creator of Cap&#x27;n Proto so that likely made it an easy choice</div><br/><div id="36909921" class="c"><input type="checkbox" id="c-36909921" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36908995">root</a><span>|</span><a href="#36909032">parent</a><span>|</span><a href="#36909148">next</a><span>|</span><label class="collapse" for="c-36909921">[-]</label><label class="expand" for="c-36909921">[1 more]</label></div><br/><div class="children"><div class="content">The article says they were using it before hiring him though, so there must have been some prior motivation:<p>&gt; In fact, you are using Cap’n Proto right now, to view this site, which is served by Cloudflare, which uses Cap’n Proto extensively (and is also my employer, although they used Cap’n Proto before they hired me)</div><br/></div></div><div id="36909148" class="c"><input type="checkbox" id="c-36909148" checked=""/><div class="controls bullet"><span class="by">mikesurowiec</span><span>|</span><a href="#36908995">root</a><span>|</span><a href="#36909032">parent</a><span>|</span><a href="#36909921">prev</a><span>|</span><a href="#36909186">next</a><span>|</span><label class="collapse" for="c-36909148">[-]</label><label class="expand" for="c-36909148">[2 more]</label></div><br/><div class="children"><div class="content">The post states &quot;they used Cap’n Proto before they hired me&quot;</div><br/><div id="36909581" class="c"><input type="checkbox" id="c-36909581" checked=""/><div class="controls bullet"><span class="by">oxygen_crisis</span><span>|</span><a href="#36908995">root</a><span>|</span><a href="#36909148">parent</a><span>|</span><a href="#36909186">next</a><span>|</span><label class="collapse" for="c-36909581">[-]</label><label class="expand" for="c-36909581">[1 more]</label></div><br/><div class="children"><div class="content">He helped build the Workers platform after they hired him.</div><br/></div></div></div></div></div></div></div></div><div id="36909186" class="c"><input type="checkbox" id="c-36909186" checked=""/><div class="controls bullet"><span class="by">dannyobrien</span><span>|</span><a href="#36908995">prev</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36909186">[-]</label><label class="expand" for="c-36909186">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited by Cap&#x27;n Proto&#x27;s participation in the OCAPN standardization effort. Can you speak to if that&#x27;s going to be part of the Cap&#x27;n Proto 2.0 work?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ocapn&#x2F;ocapn">https:&#x2F;&#x2F;github.com&#x2F;ocapn&#x2F;ocapn</a></div><br/><div id="36909379" class="c"><input type="checkbox" id="c-36909379" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909186">parent</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36909379">[-]</label><label class="expand" for="c-36909379">[13 more]</label></div><br/><div class="children"><div class="content">Sadly, the person leading that participation, Ian &quot;zenhack&quot; Denhardt, recently and unexpectedly passed away.<p>For my part, I&#x27;m a fan of OCapN, but I am not sure how much time I can personally commit to it, with everything on my plate.<p>I wish I had better news here. This was a tragic loss for all of us.</div><br/><div id="36911603" class="c"><input type="checkbox" id="c-36911603" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36909379">parent</a><span>|</span><a href="#36910458">next</a><span>|</span><label class="collapse" for="c-36911603">[-]</label><label class="expand" for="c-36911603">[1 more]</label></div><br/><div class="children"><div class="content">Kenton, I&#x27;m @lthibault on GitHub.  I was working closely with Ian on the Go capnp implementation, and I would be happy to take over this initiative.  Can you point me in the right direction?<p>Also, are you on Matrix or Telegram or something of the sort?  I was hoping I could ping you with the occasional question as I continue work on go-capnp.</div><br/></div></div><div id="36910458" class="c"><input type="checkbox" id="c-36910458" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36909379">parent</a><span>|</span><a href="#36911603">prev</a><span>|</span><a href="#36910064">next</a><span>|</span><label class="collapse" for="c-36910458">[-]</label><label class="expand" for="c-36910458">[4 more]</label></div><br/><div class="children"><div class="content">The guy making Tempest?  That is tragic and deserves an HN front page.    Is there an obituary or good link you can submit and we can upvote?  Or would Ian have preferred not to have such?</div><br/><div id="36912587" class="c"><input type="checkbox" id="c-36912587" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910458">parent</a><span>|</span><a href="#36911687">next</a><span>|</span><label class="collapse" for="c-36912587">[-]</label><label class="expand" for="c-36912587">[1 more]</label></div><br/><div class="children"><div class="content">I would have sworn that HN is where I saw <a href="https:&#x2F;&#x2F;staticfree.info&#x2F;ian&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;staticfree.info&#x2F;ian&#x2F;</a> but at the time I didn&#x27;t realize why it was timely.<p>The best link I know is Christine Lemmer-Webber&#x27;s post:<a href="https:&#x2F;&#x2F;octodon.social&#x2F;@cwebber&#x2F;110712988569475393" rel="nofollow noreferrer">https:&#x2F;&#x2F;octodon.social&#x2F;@cwebber&#x2F;110712988569475393</a></div><br/></div></div><div id="36911687" class="c"><input type="checkbox" id="c-36911687" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910458">parent</a><span>|</span><a href="#36912587">prev</a><span>|</span><a href="#36910894">next</a><span>|</span><label class="collapse" for="c-36911687">[-]</label><label class="expand" for="c-36911687">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Ian was the driving force behind Tempest.  I am not aware of any obituary.</div><br/></div></div></div></div><div id="36910064" class="c"><input type="checkbox" id="c-36910064" checked=""/><div class="controls bullet"><span class="by">the_common_man</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36909379">parent</a><span>|</span><a href="#36910458">prev</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36910064">[-]</label><label class="expand" for="c-36910064">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s tragic. Was he also not helping maintain sandstorm? Would appreciate a blog post or a note about him there</div><br/><div id="36910346" class="c"><input type="checkbox" id="c-36910346" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910064">parent</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36910346">[-]</label><label class="expand" for="c-36910346">[6 more]</label></div><br/><div class="children"><div class="content">Yes, he was the most active developer over the last few years, although it wasn&#x27;t a huge amount of activity. And that activity had dropped off this year as Ian shifted his focus to Tempest, a mostly-from-scratch rewrite. <a href="https:&#x2F;&#x2F;github.com&#x2F;zenhack&#x2F;tempest">https:&#x2F;&#x2F;github.com&#x2F;zenhack&#x2F;tempest</a><p>For my part I stopped pushing monthly Sandstorm updates this year as there hasn&#x27;t really been anything to push. Unfortunately Sandstorm&#x27;s biggest dependencies can&#x27;t even be updated anymore because of breaking changes that would take significant effort to work around.<p>I agree a blog post is probably in order.</div><br/><div id="36911558" class="c"><input type="checkbox" id="c-36911558" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910346">parent</a><span>|</span><a href="#36910840">next</a><span>|</span><label class="collapse" for="c-36911558">[-]</label><label class="expand" for="c-36911558">[1 more]</label></div><br/><div class="children"><div class="content">Looking at <a href="https:&#x2F;&#x2F;sandstorm.io&#x2F;news&#x2F;2014-08-19-why-not-run-docker-apps" rel="nofollow noreferrer">https:&#x2F;&#x2F;sandstorm.io&#x2F;news&#x2F;2014-08-19-why-not-run-docker-apps</a> from 9 years ago, it seems you think that Docker was&#x2F;is poorly suited for individual user administration. Since the Internet has started enshittifying in the last few years I&#x27;ve been turning to self-hosting apps, but this requires researching distro-specific instructions for each new app I install, and I got burned when Arch updated their Postgres package which broke compatibility with the old database formats until I ran a manual upgrade script which required troubleshooting several errors along the way. (In hindsight, I should&#x27;ve picked a fixed-release distro like Debian or something.)<p>Would you say that there have been user-friendly Docker&#x2F;etc. wrappers for self-hosting LAN services? Someone has recommended casaOS (or the proprietary Umbrel), though I haven&#x27;t tried either yet.</div><br/></div></div><div id="36910840" class="c"><input type="checkbox" id="c-36910840" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910346">parent</a><span>|</span><a href="#36911558">prev</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36910840">[-]</label><label class="expand" for="c-36910840">[4 more]</label></div><br/><div class="children"><div class="content">I have thought a bit on this but I have also been pretty much just been recovering lately. We will probably need to assemble a blog post at some point soonish, but we need to talk to a few people first.</div><br/><div id="36912773" class="c"><input type="checkbox" id="c-36912773" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36910840">parent</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36912773">[-]</label><label class="expand" for="c-36912773">[3 more]</label></div><br/><div class="children"><div class="content">Who are you in this? Your profile just shows a username.</div><br/><div id="36912841" class="c"><input type="checkbox" id="c-36912841" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36912773">parent</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36912841">[-]</label><label class="expand" for="c-36912841">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m part of Sandstorm&#x27;s community team and the maintainer of some apps and tools relating to the project.</div><br/><div id="36913011" class="c"><input type="checkbox" id="c-36913011" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909186">root</a><span>|</span><a href="#36912841">parent</a><span>|</span><a href="#36909894">next</a><span>|</span><label class="collapse" for="c-36913011">[-]</label><label class="expand" for="c-36913011">[1 more]</label></div><br/><div class="children"><div class="content">Can confirm, ocdtrekkie is one of Sandstorm&#x27;s most active maintainers over the last few years.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36909894" class="c"><input type="checkbox" id="c-36909894" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909186">prev</a><span>|</span><a href="#36909258">next</a><span>|</span><label class="collapse" for="c-36909894">[-]</label><label class="expand" for="c-36909894">[68 more]</label></div><br/><div class="children"><div class="content">While I never used Cap&#x27;n Proto, I want to thank kentonv for the extremely informative FAQ answer [1] on why required fields are problematic in a protocol<p>I link it to people all the time, especially when they ask why protobuf 3 doesn&#x27;t have required fields.<p>[1] <a href="https:&#x2F;&#x2F;capnproto.org&#x2F;faq.html#how-do-i-make-a-field-required-like-in-protocol-buffers" rel="nofollow noreferrer">https:&#x2F;&#x2F;capnproto.org&#x2F;faq.html#how-do-i-make-a-field-require...</a></div><br/><div id="36909962" class="c"><input type="checkbox" id="c-36909962" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36909894">parent</a><span>|</span><a href="#36911151">next</a><span>|</span><label class="collapse" for="c-36909962">[-]</label><label class="expand" for="c-36909962">[3 more]</label></div><br/><div class="children"><div class="content">This is some very valuable perspective. Personally, I previously also struggled to understand why. For me, the thing that clicked was to understand protobuf and Cap&#x27;n proto as serialization formats that need to work across API boundaries and need to work with different versions of their schema in a backwards- and forwards-compatible way; do not treat them as in-memory data structures that represent the world from the perspective of a single process running a single version without no compatibility concerns. Thus, the widely repeated mantra of &quot;making illegal states unrepresentable&quot; does not apply.</div><br/><div id="36911033" class="c"><input type="checkbox" id="c-36911033" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36909962">parent</a><span>|</span><a href="#36911151">next</a><span>|</span><label class="collapse" for="c-36911033">[-]</label><label class="expand" for="c-36911033">[2 more]</label></div><br/><div class="children"><div class="content">Rich Hickey (creator of the Clojure language) has a good talk &quot;Maybe Not&quot; that touches on these issues, with a nice way of explaining it<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YR5WdGrpoug">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YR5WdGrpoug</a><p>The capnproto link  explains it concretely in terms of a message bus example, which is useful.<p>But more abstractly you can think of the shape of data (aka schema, names and types) and field presence (optional&#x2F;required) as separate things<p><a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;zdvg9y&#x2F;maybe_not_rich_hickey" rel="nofollow noreferrer">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;zdvg9y&#x2F;maybe_not_rich_hickey</a><p>First, being valid or invalid with respect to a static type system is a GLOBAL property of program -- writing a type checker will convince you of that.  And big distributed systems don&#x27;t have such global properties: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36590799">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36590799</a><p>If they did, they&#x27;d be small :)   Namely you could just reboot the whole thing at once.  You can&#x27;t reboot say the entire Internet at once, and this also holds for smaller systems, like the ones at say Google (and I&#x27;m sure Cloudflare, etc.).<p>So the idea is that the shape&#x2F;schema is a GLOBAL property -- you never want two messages called foo.RequestX or two fields called &quot;num_bar&quot; with different types -- ever, anywhere.<p>But optional&#x2F;required is LOCAL property.  It depends on what version of a schema is deployed in a particular binary.  Inherently, you need to be able to handle a mix of inconsistent versions running simultaneously.<p>---<p>To be pedantic, I woulds say &quot;making illegal states unrepresentable&quot; DOES apply, but you can&#x27;t do it in a STATIC type system.  [1]  Your  Maybe&lt;T&gt; type is not useful for data that crosses process boundaries.<p>A distributed system isn&#x27;t a state machine.<p>1. Lamport showed us one important reason why: the relative order of messages means that there is no globally coherent state.  You need something like Paxos to turn a distributed system back into a state machine (and this is very expensive in general)<p>2. The second reason is probably a consequence of the first.  You can think of deploying a binary to a node as a message to that node.  So you don&#x27;t have a completely consistent state -- you always have an in-between state, a mix of versions.  And presumably you want your system to keep working during this time period :)<p>And that coarse-grained problem (code versioning and deployment) implies the fine-grained problem (whether a specific message in a field is present).  This is because protobufs generate parsers with validation for you -- or they used to!<p>---<p>tl;dr Think of the shape of data (aka schema) and field presence (optional&#x2F;required) as different dimensions of data modeling.  Maybe&lt;T&gt; mixes those up, which is fine in a single process, but doesn&#x27;t work across processes.<p>---<p>[1] A very specific example of making illegal states unrepresentable without static types - my Oils project uses a DSL for algebraic data types, borrowed from CPython.  The funny thing is that in CPython, it generates C code, which doesn&#x27;t have any static notion of Maybe&lt;T&gt;.  It has tagged unions.<p>And in Oils we first generated dynamically typed Python at first.  Somewhat surprisingly, algebraic data types are STILL useful there.<p>Now the generated code is statically typed with MyPy (and with C++), and we do pleasant type-driven refactorings.  But using algebraic data types were still extremely useful before  static typing.  They made illegal states unrepresentable -- but you would get the error at runtime.</div><br/><div id="36912494" class="c"><input type="checkbox" id="c-36912494" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911033">parent</a><span>|</span><a href="#36911151">next</a><span>|</span><label class="collapse" for="c-36912494">[-]</label><label class="expand" for="c-36912494">[1 more]</label></div><br/><div class="children"><div class="content">I wonder about how to make this play nicely with systems that have different perspectives. Yes, a message bus is written to deal with any possible message and it can do that because it doesn&#x27;t care what&#x27;s in the message. Incomplete messages are useful to have, too.<p>This is sort of like the difference between a text editor and a compiler. An editor has to deal with code that doesn&#x27;t even parse, which is easiest if just treats it as a plain text file, but then you&#x27;re missing a lot of language-specific features that we take for granted these days. Meanwhile, a compiler can require all errors to be fixed before it emits a binary, but it has to be good at reporting what the errors are, because they will certainly happen.<p>It&#x27;s unclear to me how the type of the field can be a global property in a large system. From a text editor&#x27;s point of view, you can just edit the type. How can anyone guarantee that a type is always the same?<p>Also, SQL tables actually do make closed-world assumptions; every record meets the schema, or it can&#x27;t be stored there. If you change the schema, there is a migration step where all the old rows in the production database gets upgraded. This doesn&#x27;t seem unrealistic?<p>I guess it&#x27;s unrealistic that you only have <i>one</i> production database, and not also a staging database, and every developer having their own database? And they will be on different versions. As soon as you have lots of databases, things get complicated.</div><br/></div></div></div></div></div></div><div id="36911151" class="c"><input type="checkbox" id="c-36911151" checked=""/><div class="controls bullet"><span class="by">oftenwrong</span><span>|</span><a href="#36909894">parent</a><span>|</span><a href="#36909962">prev</a><span>|</span><a href="#36910030">next</a><span>|</span><label class="collapse" for="c-36911151">[-]</label><label class="expand" for="c-36911151">[2 more]</label></div><br/><div class="children"><div class="content">Typical provides &quot;asymmetric&quot; fields to assist with evolution of types:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#asymmetric-fields-can-safely-be-promoted-to-required-and-vice-versa">https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#asymmetric-fields-can...</a><p>&gt;To help you safely add and remove required fields, Typical offers an intermediate state between optional and required: asymmetric. An asymmetric field in a struct is considered required for the writer, but optional for the reader. Unlike optional fields, an asymmetric field can safely be promoted to required and vice versa.</div><br/><div id="36912520" class="c"><input type="checkbox" id="c-36912520" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911151">parent</a><span>|</span><a href="#36910030">next</a><span>|</span><label class="collapse" for="c-36912520">[-]</label><label class="expand" for="c-36912520">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it only works for migrations in fairly closed systems where you can upgrade or delete all the old data, though.</div><br/></div></div></div></div><div id="36910030" class="c"><input type="checkbox" id="c-36910030" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">parent</a><span>|</span><a href="#36911151">prev</a><span>|</span><a href="#36910114">next</a><span>|</span><label class="collapse" for="c-36910030">[-]</label><label class="expand" for="c-36910030">[48 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t we extend this argument to eliminating basically all static typing? And frankly that&#x27;d not even be wrong, and is why Alan Kay defined OOP as one that&#x27;s dynamically typed and late bound, and we went against it anyway to keep relearning the same lessons over and over.</div><br/><div id="36910105" class="c"><input type="checkbox" id="c-36910105" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910030">parent</a><span>|</span><a href="#36910391">next</a><span>|</span><label class="collapse" for="c-36910105">[-]</label><label class="expand" for="c-36910105">[18 more]</label></div><br/><div class="children"><div class="content">The argument is really more like: Always defer validation until the point where the data is actually consumed, because only the consumer actually knows what is valid.<p>Which is definitely a counterpoint to the oft-stated argument that you should validate all data upfront.<p>Either way though, you can still have types, the question is just when and where (in a distributed system, especially) they should be checked.</div><br/><div id="36910859" class="c"><input type="checkbox" id="c-36910859" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910105">parent</a><span>|</span><a href="#36910802">next</a><span>|</span><label class="collapse" for="c-36910859">[-]</label><label class="expand" for="c-36910859">[16 more]</label></div><br/><div class="children"><div class="content">The argument is actually more like: don&#x27;t use badly written middleman software that tries to parse messages it doesn&#x27;t need to parse.<p>I was at Google when the &quot;let&#x27;s get rid of optional&quot; crusade started. It didn&#x27;t make sense to me then and over a decade later it still doesn&#x27;t. If a program expects a field to be there then it has to be there, removing the protobuf level checking just meant that programs could now read garbage (some default value) instead of immediately crashing. But the whole reason we have types, assertions, bounds checking and so on is because, almost always, we&#x27;d like our software to NOT just blindly plough on into undefined territory when it doesn&#x27;t understand something properly, so in reality it just means everyone ends up coding those very same required-ness assertions by hand.<p>Now, Google&#x27;s business model is remarkably robust to generating and processing corrupt data, so you can argue that in the <i>specific</i> case of this <i>specific</i> company, it is actually better to silently serve garbage than to crash. This argument was made explicitly in other forms, like when they deleted all the assertions from the HTTP load balancers. But in every case where I examined an anti-required argument carefully the actual problem would turn out to be elsewhere, and removing assertions was just covering things up. The fact that so much of Google&#x27;s code is written in C++ that not only starts up slowly but also just immediately aborts the entire process when something goes wrong also contributes to the brittleness that encourages this kind of thing. If Google had been built on a language with usable exceptions right from the start it&#x27;d have been easier to limit the blast radius of data structure versioning errors to only the requests where that data structure turned up, instead of causing them to nuke the entire server (and then the RPC stack will helpfully retry because it doesn&#x27;t know why the server died, promptly killing all of them).<p>But this tolerance to undefined behavior is not true for almost any other business (except maybe video games?). In those businesses it&#x27;s better to be stopped than wrong. If you don&#x27;t then you can lose money, lose data, lose customers or in the worst cases even lose your life. I don&#x27;t think people appreciate the extent to which the unique oddities of Google&#x27;s business model and infrastructure choices have leaked out into the libraries their staffers&#x2F;ex-staffers release.</div><br/><div id="36911331" class="c"><input type="checkbox" id="c-36911331" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910859">parent</a><span>|</span><a href="#36913799">next</a><span>|</span><label class="collapse" for="c-36911331">[-]</label><label class="expand" for="c-36911331">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The argument is actually more like: don&#x27;t use badly written middleman software that tries to parse messages it doesn&#x27;t need to parse.<p>The middleman software in question often needed to process some part of the message but not others. It wasn&#x27;t realistic to define a boundary between what each middleman might need and what they wouldn&#x27;t need, and somehow push the &quot;not needed&quot; part into nested encoded blobs.<p>I&#x27;m not sure the rest of your comment is really addressing the issue here. The argument doesn&#x27;t have anything to do with proceeding forward in the face of corrupt data or undefined behavior. The argument is that validation needs to happen at the consumer. There should still be validation.</div><br/><div id="36912903" class="c"><input type="checkbox" id="c-36912903" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911331">parent</a><span>|</span><a href="#36911848">next</a><span>|</span><label class="collapse" for="c-36912903">[-]</label><label class="expand" for="c-36912903">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It wasn&#x27;t realistic to define a boundary between what each middleman might need and what they wouldn&#x27;t need, and somehow push the &quot;not needed&quot; part into nested encoded blobs.<p>This is an interesting argument that I would like to see more elaboration on, because that&#x27;s the obvious solution. Effectively you&#x27;re building a pipeline of data processors and each stage in the pipeline reads its own information and then passes along a payload with the rest of the information to the next stage. This would preserve full static typing with required fields, but I can see how it might inhibit some forms of dynamic instrumentation, eg. turning verbose logging on&#x2F;off might dynamically reconfigure the pipeline, which would affect all upstream producers if they&#x27;re wrapping messages for downstream consumers.<p>If this were a programming language I would immediately think of row typing to specify the parts that each stage depends on while being agnostic about the rest of the content, but I&#x27;m not sure how that might work for a serialization format. Effectively, you&#x27;re pulling out a typed &quot;view&quot; over the underlying data that contains offsets to the underlying fields (this is the dictionary-passing transform as found in Haskell).</div><br/><div id="36913834" class="c"><input type="checkbox" id="c-36913834" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912903">parent</a><span>|</span><a href="#36913733">next</a><span>|</span><label class="collapse" for="c-36913834">[-]</label><label class="expand" for="c-36913834">[3 more]</label></div><br/><div class="children"><div class="content">The particular piece of infrastructure I worked on sat in the middle of the search pipeline, between the front-end that served HTML web pages, and the back-end index. This middle piece would request search results from the back-end, tweak them in a bunch of ways, and forward them on.<p>These &quot;tweaks&quot; could be just about anything. Like: &quot;You searched for Jaguar, but I don&#x27;t know if you meant the cat or the car. The index decided that pages about the car rank higher so the first three pages of results are about the car. I&#x27;m going to pull some results about the cat from page 4 and put them near the top so just in case that&#x27;s what you really wanted, you&#x27;ll find it.&quot;<p>Google Search, at least when I worked on it, was composed of a huge number of such tweaks. People were constantly proposing them, testing if they led to an improvement, and shipping them if they do. For a variety of reasons, our middleman server was a great place to implement certain kinds of tweaks.<p>But what kinds of information are needed for these &quot;tweaks&quot;? Could be anything! It&#x27;s a general-purpose platform. Search results were annotated with all kinds of crazy information, and any piece of information might be useful in implementing some sort of middleman tweak at some point.<p>So you couldn&#x27;t very well say upfront &quot;OK, we&#x27;re going to put all the info that is only for the frontend into the special &#x27;frontend blob&#x27; that doesn&#x27;t get parsed by the middleman&quot;, because you have no idea what fields are only needed by the frontend. In fact, that set would change over time.<p>&gt; If this were a programming language I would immediately think of row typing to specify the parts that each stage depends on while being agnostic about the rest of the content<p>Indeed, perhaps one could develop an elaborate system where in the schemas, we could annotate certain fields as being relevant to certain servers. Anywhere else, those fields would be unavailable (but passed through without modification or validation). If you needed the fields in a new place, you change the annotations.<p>But that sounds... complicated to design and cumbersome to maintain the annotations. Simply banning required fields solved the problem for us, and everything else just worked.</div><br/><div id="36916289" class="c"><input type="checkbox" id="c-36916289" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36913834">parent</a><span>|</span><a href="#36913733">next</a><span>|</span><label class="collapse" for="c-36916289">[-]</label><label class="expand" for="c-36916289">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Indeed, perhaps one could develop an elaborate system where in the schemas, we could annotate certain fields as being relevant to certain servers. Anywhere else, those fields would be unavailable (but passed through without modification or validation). If you needed the fields in a new place, you change the annotations.<p>I don&#x27;t think it has to be elaborate. What I was thinking was something more like, in pseudo-C#:<p><pre><code>    &#x2F;&#x2F; the framework&#x27;s general channel type from which messages are read
    public interface IChannel
    {
        T Read&lt;T&gt;() where T : interface;
    }

    &#x2F;&#x2F; clients declare the interface they operate on:
    public interface IClientFields
    {
        public int Foo { get; set; }
        public string? Name { get; set; }
    }
    ...
    &#x2F;&#x2F; client middleware function
    Task MiddlewareFn(IChannel chan)
    {
        var client = chan.Read&lt;IClientFields&gt;();
        ... &#x2F;&#x2F; do something with client before resuming at next stage
    }
</code></pre>
The client&#x27;s interface type T must simply be a structural subtype of the underlying message type. As long as the underlying format is somewhat self-descriptive with a name and type map, you can perform the necessary checking that only applies locally to the client. Nothing fancy, and the required fields that client cares about are still there and the rest are ignored because they&#x27;re never referenced. This could return an interface that contains a series of offsets into the data stream, which I believe is how capnproto already works.</div><br/><div id="36917027" class="c"><input type="checkbox" id="c-36917027" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36916289">parent</a><span>|</span><a href="#36913733">next</a><span>|</span><label class="collapse" for="c-36917027">[-]</label><label class="expand" for="c-36917027">[1 more]</label></div><br/><div class="children"><div class="content">Are you saying that each service would need to declare, separately, the subset of fields they operate on, and make sure that those fields are always a strict subset of the overall set of fields the protocol contains?<p>This essentially means declaring the same protocol multiple times, which seems like a big pain.</div><br/></div></div></div></div></div></div><div id="36913733" class="c"><input type="checkbox" id="c-36913733" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912903">parent</a><span>|</span><a href="#36913834">prev</a><span>|</span><a href="#36911848">next</a><span>|</span><label class="collapse" for="c-36913733">[-]</label><label class="expand" for="c-36913733">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier to understand in context - some services (iirc web search but it might have been ads or something else very core) had kept adding fields to some core protobufs for years and years. It made sense, was the path of least resistance etc, but inevitably some of those fields became obsolete and they wanted to remove them but found it was hard, because every program that did anything with web search was deserializing these structures.<p>Truly generic middleware like RPC balancers did what you are saying, but there were also a lot of service specific &quot;middlemen&quot; which did need to look at parts of these mega-structures.<p>Now due to how protobufs work, you <i>can</i> do what you suggest and &quot;cast&quot; a byte stream to multiple different types, so they could have defined subsets of the overall structures and maybe they did, I don&#x27;t remember, but the issue then is code duplication. You end up defining the same structures multiple times, just as subsets. With a more advanced type system you can eliminate the duplication, but there was a strong reluctance to add features to protobufs.</div><br/></div></div></div></div><div id="36911848" class="c"><input type="checkbox" id="c-36911848" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911331">parent</a><span>|</span><a href="#36912903">prev</a><span>|</span><a href="#36912296">next</a><span>|</span><label class="collapse" for="c-36911848">[-]</label><label class="expand" for="c-36911848">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I wonder what is the big win in terms of performance by using static types here, because this sounds so terribly well fit for dynamic types (of which optionality by default is in fact a limited example). Such an odd choice to calcify a spec in a places where it changes all the time. &quot;Static&quot; optimizations should be local, not distributed.</div><br/></div></div><div id="36912296" class="c"><input type="checkbox" id="c-36912296" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911331">parent</a><span>|</span><a href="#36911848">prev</a><span>|</span><a href="#36913799">next</a><span>|</span><label class="collapse" for="c-36912296">[-]</label><label class="expand" for="c-36912296">[6 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re defining consumer as the literal line of code where the field is read, whereas a more natural definition would be something like &quot;the moment the data structure is deserialized&quot;. After all it&#x27;s usually better to abort early than half way through an operation.<p>It was quite realistic to improve protobufs to help dig web search out of their &quot;everything+dog consumes an enormous monolithic datastructure&quot; problem, assuming that&#x27;s what you&#x27;re thinking of (my memory of the details of this time is getting fuzzy).<p>A simple brute-force fix for their situation would have been to make validation of required fields toggle-able on a per-parse level, so they could disable validation for their own parts of the stack without taking it away for everyone else (none of the projects I worked on had problems with required fields that I can recall).<p>A better fix would have been for protobufs to support composition. They could then have started breaking down the mega-struct into overlapping protos, with the original being defined as a recursive merge of them. That&#x27;d have let them start narrowing down semantically meaningful views over what the programs really needed.<p>The worst fix was to remove validation features from the language, thus forcing everyone to manually re-add them without the help of the compiler.<p>Really, the protobuf type system was too simple for Google even in 2006. I recall during training wondering why it didn&#x27;t have a URL type given that this was a web-centric company. Shortly after I discovered a very simple and obvious bug in web search in which some local business results were 404s even though the URL existed. It had been there for months, maybe years, and I found it by reading the user support forums (nobody else did this, my manager considered me way out of my lane for doing so). The bug was that nothing anywhere in the pipeline checked that the website address entered by the business owner started with <a href="https:&#x2F;&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;</a>, so when the result was stuffed into an &lt;a&gt; tag it turned into &lt;a href=&quot;www.business.com&quot;&gt; and so the user ended up at <a href="https:&#x2F;&#x2F;www.google.com&#x2F;www.business.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.google.com&#x2F;www.business.com</a>. Oops. These bad strings made it all the way from the business owner, through the LBC frontend, the data pipeline, the intermediate microservices and the web search frontends to the user&#x27;s browser. The URL <i>did</i> pass crawl validation because when loaded into a URL type, the missing protocol was being added. SREs were trained to do post-mortems, so after it got fixed and the database was patched up, I naively asked whether there was a systematic fix for this, like maybe adding a URL type to protobufs so data would be validated right at the start. The answer was &quot;it sounds like you&#x27;re asking how to not write bugs&quot; and nothing was done, sigh. It&#x27;s entirely possible that similar bugs reoccurred dozens of times without being detected.<p>Those are just a couple of cases where the simplicity (or primitivity) of the protobuf type system led to avoidable problems. Sure, there are complexity limits too, but the actual languages Googlers were using all had more sophisticated type systems than protobuf and bugs at the edges weren&#x27;t uncommon.</div><br/><div id="36912924" class="c"><input type="checkbox" id="c-36912924" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912296">parent</a><span>|</span><a href="#36912643">next</a><span>|</span><label class="collapse" for="c-36912924">[-]</label><label class="expand" for="c-36912924">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think you&#x27;re defining consumer as the literal line of code where the field is read<p>I am.<p>&gt; After all it&#x27;s usually better to abort early than half way through an operation.<p>I realize this goes against common wisdom, but I actually disagree.<p>It&#x27;s simply unrealistic to imagine that we can fully determine whether an operation will succeed by examining the inputs upfront. Even if the inputs are fully valid, all sorts of things can go wrong at runtime. Maybe a database connection is randomly dropped. Maybe you run out of memory. Maybe the power goes out.<p>So we already have to design our code to be tolerant to random failures in the middle. This is why we try to group our state changes into a single transaction, or design things to be idempotent.<p>Given we already have to do all that, I think trying to validate input upfront creates more trouble than it solves. When your validation code is far away from the code that actually processes the data, it is easier to miss things and harder to keep in sync.<p>To be clear, though, this does not mean I like dynamic typing. Static types are great. But the reason I like them is more because they make programming easier, letting you understand the structure of the data you&#x27;re dealing with, letting the IDE implement auto-complete, jump-to-definition, and error checking, etc.<p>Consider TypeScript, which implements static typing on JavaScript, but explicitly does not perform any runtime checks whatsoever validating types. It&#x27;s absolutely possible that a value at runtime does not match the type that TypeScript assigned to it. The result is a runtime exception when you try to access the value in a way that it doesn&#x27;t support (even though its type says it should have). And yet, people love TypeScript, it clearly provides value despite this.<p>This stuff makes a programming language theorist&#x27;s head explode but it practice it works. Look, anything can be invalid in ways you never thought of, and no type system can fully defend you from that. You gotta get comfortable with the idea that exceptions might be thrown from anywhere, and design systems to accommodate failure.</div><br/><div id="36917767" class="c"><input type="checkbox" id="c-36917767" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912924">parent</a><span>|</span><a href="#36913693">next</a><span>|</span><label class="collapse" for="c-36917767">[-]</label><label class="expand" for="c-36917767">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consider TypeScript, which implements static typing on JavaScript, but explicitly does not perform any runtime checks whatsoever validating types. It&#x27;s absolutely possible that a value at runtime does not match the type that TypeScript assigned to it. The result is a runtime exception when you try to access the value in a way that it doesn&#x27;t support (even though its type says it should have). And yet, people love TypeScript, it clearly provides value despite this.<p>&gt; This stuff makes a programming language theorist&#x27;s head explode but it practice it works. Look, anything can be invalid in ways you never thought of, and no type system can fully defend you from that. You gotta get comfortable with the idea that exceptions might be thrown from anywhere, and design systems to accommodate failure.<p>It&#x27;s only possible if you&#x27;re doing something wrong type-wise.  In particular, when ingesting an object you&#x27;re supposed to validate it before&#x2F;as you assign the type to it.  Delaying the error until the particular field is accessed is bad TypeScript!  Those kinds of exceptions <i>aren&#x27;t</i> supposed to be thrown from anywhere.</div><br/></div></div><div id="36913693" class="c"><input type="checkbox" id="c-36913693" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912924">parent</a><span>|</span><a href="#36917767">prev</a><span>|</span><a href="#36912643">next</a><span>|</span><label class="collapse" for="c-36913693">[-]</label><label class="expand" for="c-36913693">[1 more]</label></div><br/><div class="children"><div class="content">I agree with a lot of this, but:<p>1. The advantage of having it in the type system is the compiler can&#x27;t forget.<p>2. It&#x27;s quite hard to unwind operations in C++. I think delaying validation to the last moment is easier when you have robust exceptions. At the top level the frameworks can reject RPCs or return a 400 or whatever it is you want to do, if it&#x27;s found out 20 frames deep into some massive chunk of code then you&#x27;re very likely to lose useful context as the error gets unwound (and worse error messages).<p>On forgetting, the risky situation is something like this:<p><pre><code>    message FooRequest {
        required string query = 1;
        optional list&lt;string&gt; options = 2;   &#x2F;&#x2F; added later
    }
</code></pre>
The intention is: in v1 of the message there&#x27;s some default information returned, but in v2 the client is given more control including the ability to return less information as well as more. In proto2 you can query if options is set, and if not, select the right default value. In proto3 you can&#x27;t tell the difference between an old client and a client that wants no extra information returned. That&#x27;s a bug waiting to happen: the difference between &quot;not set&quot; and &quot;default value&quot; is important. Other variants are things like adding &quot;int32 timeout&quot; where it defaults to zero, or even just having a client that forgets to set a required field by mistake.<p>TypeScript does indeed not do validation of type casts up front, but that&#x27;s more because it&#x27;s specifically designed to be compatible with JavaScript and the runtime doesn&#x27;t do strong typing. People like it compared to raw JS.</div><br/></div></div></div></div><div id="36912643" class="c"><input type="checkbox" id="c-36912643" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912296">parent</a><span>|</span><a href="#36912924">prev</a><span>|</span><a href="#36913799">next</a><span>|</span><label class="collapse" for="c-36912643">[-]</label><label class="expand" for="c-36912643">[2 more]</label></div><br/><div class="children"><div class="content">I think this comes from everyone wanting to use the same schema and parser. For example, a text editor and a compiler have obvious differences in how to deal with invalid programs.<p>Maybe there need to be levels of validation, like &quot;it&#x27;s a text file&quot; versus &quot;it parses&quot; versus &quot;it type checks.&quot;</div><br/><div id="36912775" class="c"><input type="checkbox" id="c-36912775" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912643">parent</a><span>|</span><a href="#36913799">next</a><span>|</span><label class="collapse" for="c-36912775">[-]</label><label class="expand" for="c-36912775">[1 more]</label></div><br/><div class="children"><div class="content">Sure, that would also have been a fine solution. There are lots of ways to tackle it really and some of it is just very subjective. There&#x27;s a lot of similarities here between the NoSQL vs SQL debates. Do you want a schemaless collection of JSON documents or do you want enforced schemas, people can debate this stuff for a long time.<p>You can also see it as a version control and awareness problem rather than a schema or serialization problem. The issues don&#x27;t occur if you always have full awareness of what code is running and what&#x27;s consuming what data, but that&#x27;s hard especially when you take into account batch jobs.</div><br/></div></div></div></div></div></div></div></div><div id="36913799" class="c"><input type="checkbox" id="c-36913799" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910859">parent</a><span>|</span><a href="#36911331">prev</a><span>|</span><a href="#36911805">next</a><span>|</span><label class="collapse" for="c-36913799">[-]</label><label class="expand" for="c-36913799">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The argument is actually more like: don&#x27;t use badly written middleman software that tries to parse messages it doesn&#x27;t need to parse.<p>&gt; I was at Google when the &quot;let&#x27;s get rid of optional&quot; crusade started. It didn&#x27;t make sense to me then and over a decade later it still doesn&#x27;t. If a program expects a field to be there then it has to be there, removing the protobuf level checking just meant that programs could now read garbage (some default value) instead of immediately crashing. But the whole reason we have types, assertions, bounds checking and so on is because, almost always, we&#x27;d like our software to NOT just blindly plough on into undefined territory when it doesn&#x27;t understand something properly, so in reality it just means everyone ends up coding those very same required-ness assertions by hand.<p>Yeah, that&#x27;s what stuck out to me from the linked explanation as well; the issue wasn&#x27;t that the field was required, it was that the message bus was not doing what was originally claimed. It sounds like either having the message bus _just_ process the header and not the entire message or having the header have a version number that indicated which fields are required (with versions numbers that are newer than the latest the bus was aware of  being considered to have no required fields). I don&#x27;t claim that it&#x27;s never correct to design a protocol optimizing for robustness when consumed by poorly written clients, but I similarly struggle to see how making that the only possible way to implement a protocol is the only valid option. Maybe the goal of cap&#x27;n proto is to be prescriptive about this sort of thing, so it wouldn&#x27;t be a good choice for uses where there&#x27;s more rigor in the implementation of services using the protocol, but if its intended for more general usage, I don&#x27;t understand this design decision at all.</div><br/></div></div><div id="36911805" class="c"><input type="checkbox" id="c-36911805" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910859">parent</a><span>|</span><a href="#36913799">prev</a><span>|</span><a href="#36910802">next</a><span>|</span><label class="collapse" for="c-36911805">[-]</label><label class="expand" for="c-36911805">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s valuable what you say, and it&#x27;s kinda odd some people here discard practical experience in favor of their subjective flavor of theoretical correctness.</div><br/></div></div></div></div><div id="36910802" class="c"><input type="checkbox" id="c-36910802" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910105">parent</a><span>|</span><a href="#36910859">prev</a><span>|</span><a href="#36910391">next</a><span>|</span><label class="collapse" for="c-36910802">[-]</label><label class="expand" for="c-36910802">[1 more]</label></div><br/><div class="children"><div class="content">The distributed part shifts the problem from &quot;find types that represent your solution&quot; to &quot;find a system of types that enable evolution of your solution over time.&quot; I think this is why bad things like json or xml do so well: they work fine with a client dev saying, &quot;I need this extra data&quot; and the server dev adding it, and then the client dev consuming it.<p>The more modern approaches, like protobuf or capn proto are designed with the experience of mutating protocols over time.<p>It works pretty well too unless the new field changes the semantics of old field values, e.g. adding a field &quot;payment_is_reversal_if_set&quot; to a payment info type, which would change the meaning of the signs of the amounts.  In that case, you have to reason more explicitly about when to roll out the protocol readers and when to roll out the protocol writers.  Or version it, etc.</div><br/></div></div></div></div><div id="36910391" class="c"><input type="checkbox" id="c-36910391" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910030">parent</a><span>|</span><a href="#36910105">prev</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36910391">[-]</label><label class="expand" for="c-36910391">[25 more]</label></div><br/><div class="children"><div class="content">&gt; Can&#x27;t we extend this argument to eliminating basically all static typing?<p>No, because static typing exists in all sorts of places. This argument is primarily about cases where you&#x27;re <i>exchanging data</i>, which is a very specific use case.</div><br/><div id="36910799" class="c"><input type="checkbox" id="c-36910799" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910391">parent</a><span>|</span><a href="#36910498">next</a><span>|</span><label class="collapse" for="c-36910799">[-]</label><label class="expand" for="c-36910799">[13 more]</label></div><br/><div class="children"><div class="content">To elaborate on your point:<p>Static type systems in programming languages are <i>designed</i> to break at <i>compilation-time</i>. The reason this works is because all users are within the same “program unit”, on the same version.<p>In other words, static typing allows more validation to be automated, and removes the need for multiple simultaneous versions, but assumes that the developer has access and ability to change <i>all other users</i> at the same “time” of their own change.<p>I find this whole topic fascinating. It seems like programmers are limited to an implicit understanding of these differences but it’s never formalized (or even properly conceptualized). Thus, our intuition often fails with complex systems (eg multiple simultaneous versions, etc). Case in point: even mighty Google distinguished engineers made this “billion-dollar mistake” with required fields, even though they had near-perfect up-front knowledge of their planned use-cases.</div><br/><div id="36911005" class="c"><input type="checkbox" id="c-36911005" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910799">parent</a><span>|</span><a href="#36910849">next</a><span>|</span><label class="collapse" for="c-36911005">[-]</label><label class="expand" for="c-36911005">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually the opposite. The billion dollar mistake is to have pervasive implicit nullability, not to have the concept of optionality in your type system. Encoding optionality in the type system and making things required by default is usually given as the <i>fix</i> for the billion dollar mistake.</div><br/><div id="36911098" class="c"><input type="checkbox" id="c-36911098" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911005">parent</a><span>|</span><a href="#36910849">next</a><span>|</span><label class="collapse" for="c-36911098">[-]</label><label class="expand" for="c-36911098">[8 more]</label></div><br/><div class="children"><div class="content">Huh? Did you read the link, from the guy who was there during the major failure at Google that led to proto3 being redesigned without that flaw?<p>The whole lesson is that you <i>can’t</i> apply the lessons from static type systems in PLs when you have multiple versions and fragmented validation across different subsystems. Counter-intuitively! Everyone thought it was a good idea, and it turned out to be a disaster.</div><br/><div id="36911654" class="c"><input type="checkbox" id="c-36911654" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911098">parent</a><span>|</span><a href="#36913688">next</a><span>|</span><label class="collapse" for="c-36911654">[-]</label><label class="expand" for="c-36911654">[2 more]</label></div><br/><div class="children"><div class="content">It remains a big asterisk to me, why was some random middleware validating an end-to-end message between two systems, instead of treating it as just an opaque message.<p>Why are we not having this debate about &quot;everything must be optional&quot; for Internet Packets (IP) for example? Because it&#x27;s just binary load. If you want to ensure integrity you checksum the binary load.</div><br/><div id="36912652" class="c"><input type="checkbox" id="c-36912652" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911654">parent</a><span>|</span><a href="#36913688">next</a><span>|</span><label class="collapse" for="c-36912652">[-]</label><label class="expand" for="c-36912652">[1 more]</label></div><br/><div class="children"><div class="content">Things like distributed tracing, auth data, metrics, error logging messages and other “meta-subsystems” is certainly typical use cases. Reverse proxies and other http middleware do exactly this with http headers all the time.</div><br/></div></div></div></div><div id="36912096" class="c"><input type="checkbox" id="c-36912096" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911098">parent</a><span>|</span><a href="#36913688">prev</a><span>|</span><a href="#36910849">next</a><span>|</span><label class="collapse" for="c-36912096">[-]</label><label class="expand" for="c-36912096">[4 more]</label></div><br/><div class="children"><div class="content">I did read the link and I was at Google at the time people started arguing for that. With respect, I think the argument was and still is incorrect, that the wrong lessons were drawn and that proto3 is worse than proto2.</div><br/><div id="36912610" class="c"><input type="checkbox" id="c-36912610" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912096">parent</a><span>|</span><a href="#36912831">next</a><span>|</span><label class="collapse" for="c-36912610">[-]</label><label class="expand" for="c-36912610">[1 more]</label></div><br/><div class="children"><div class="content">Alright, fair enough. Apologies for the dismissive tone. Could you elaborate (or point to) these wrong lessons or an alternative?</div><br/></div></div><div id="36912831" class="c"><input type="checkbox" id="c-36912831" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912096">parent</a><span>|</span><a href="#36912610">prev</a><span>|</span><a href="#36910849">next</a><span>|</span><label class="collapse" for="c-36912831">[-]</label><label class="expand" for="c-36912831">[2 more]</label></div><br/><div class="children"><div class="content">OK, what do you do when a message comes in missing a field?
Crash the server?</div><br/><div id="36915227" class="c"><input type="checkbox" id="c-36915227" checked=""/><div class="controls bullet"><span class="by">dastbe</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912831">parent</a><span>|</span><a href="#36910849">next</a><span>|</span><label class="collapse" for="c-36915227">[-]</label><label class="expand" for="c-36915227">[1 more]</label></div><br/><div class="children"><div class="content">you reject the message in the framework? and if the client is aware it’s required they fail to send?<p>the bigger challenge with proto3 is that people use it both for rpc and storage, in some cases directly serializing rpc payloads. Disregarding how awful a choice that is, you likely want to trade off flexible deserialization of old data at the expense of rigidity, and conformance.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36910849" class="c"><input type="checkbox" id="c-36910849" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910799">parent</a><span>|</span><a href="#36911005">prev</a><span>|</span><a href="#36910498">next</a><span>|</span><label class="collapse" for="c-36910849">[-]</label><label class="expand" for="c-36910849">[3 more]</label></div><br/><div class="children"><div class="content">No one has near-perfect up-front knowledge of a software system designed to change and expand. The solution space is too large and the efficient delivery methods are a search thru this space.</div><br/><div id="36911007" class="c"><input type="checkbox" id="c-36911007" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910849">parent</a><span>|</span><a href="#36910498">next</a><span>|</span><label class="collapse" for="c-36911007">[-]</label><label class="expand" for="c-36911007">[2 more]</label></div><br/><div class="children"><div class="content">I may have phrased it poorly. What I should have said is that Google absolutely could have “anticipated” that many of their subsystems would deal with partial messages and multiple versions, because they most certainly already did. The designers would have maintained, developed and debugged exactly such systems for years.</div><br/><div id="36912148" class="c"><input type="checkbox" id="c-36912148" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911007">parent</a><span>|</span><a href="#36910498">next</a><span>|</span><label class="collapse" for="c-36912148">[-]</label><label class="expand" for="c-36912148">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense: they knew arbitrary mutability was a requirement but did not think it thru for the required keyword.</div><br/></div></div></div></div></div></div></div></div><div id="36910498" class="c"><input type="checkbox" id="c-36910498" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910391">parent</a><span>|</span><a href="#36910799">prev</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36910498">[-]</label><label class="expand" for="c-36910498">[11 more]</label></div><br/><div class="children"><div class="content">Static types are a partial application&#x2F;reduction when certain mutable or unknown variables become constants (i.e. &quot;I for sure only need integers between 0-255 here&quot;).<p>I&#x27;m not rejecting static types entirely, and yes I was discussing exchanging data here, as Alan Kay&#x27;s OOP is inherently distributed. It&#x27;s much closer to Erlang than it is to Java.</div><br/><div id="36910676" class="c"><input type="checkbox" id="c-36910676" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910498">parent</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36910676">[-]</label><label class="expand" for="c-36910676">[10 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not rejecting static types entirely, and yes I was discussing exchanging data here<p>OK I guess I&#x27;m having a hard time reconciling that with:<p>&gt; basically all static typing</div><br/><div id="36910935" class="c"><input type="checkbox" id="c-36910935" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910676">parent</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36910935">[-]</label><label class="expand" for="c-36910935">[9 more]</label></div><br/><div class="children"><div class="content">Sorry, I see how I&#x27;m vague. The idea is you have no &quot;pre-burned&quot; static types, but dynamic types. And static types then become a disposable optimization compiled out of more dynamic code, in the same way JIT works in V8 and JVM for example (where type specialization is in fact part of the optimization strategy).</div><br/><div id="36910958" class="c"><input type="checkbox" id="c-36910958" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910935">parent</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36910958">[-]</label><label class="expand" for="c-36910958">[8 more]</label></div><br/><div class="children"><div class="content">You&#x27;re describing dynamic types</div><br/><div id="36911281" class="c"><input type="checkbox" id="c-36911281" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910958">parent</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36911281">[-]</label><label class="expand" for="c-36911281">[7 more]</label></div><br/><div class="children"><div class="content">But with the benefit of static types, and without the drawbacks of static types.</div><br/><div id="36911362" class="c"><input type="checkbox" id="c-36911362" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911281">parent</a><span>|</span><a href="#36910768">next</a><span>|</span><label class="collapse" for="c-36911362">[-]</label><label class="expand" for="c-36911362">[6 more]</label></div><br/><div class="children"><div class="content">No. &quot;Types only known at runtime&quot; are dynamic types. &quot;And also you can optimize by examining the types at runtime&quot; is just dynamic types. And it does not have the benefit of static types because it is dynamic types.</div><br/><div id="36912039" class="c"><input type="checkbox" id="c-36912039" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36911362">parent</a><span>|</span><a href="#36912362">next</a><span>|</span><label class="collapse" for="c-36912039">[-]</label><label class="expand" for="c-36912039">[4 more]</label></div><br/><div class="children"><div class="content">This is devolving into a &quot;word definition war&quot; so I&#x27;ll leave aside what you call static types and dynamic types and get down to specifics. Type info is available in these flavors, relative to runtime:<p>1. Type info which is available before runtime, but not at runtime (compiled away).<p>2. Type info which is available at runtime, but not at compile time (input, statistics, etc.).<p>3. Type info which is available both at compile time and runtime (say like a Java class).<p>When you have a JIT optimizer that can turn [3] and [2] into [1], there&#x27;s no longer a reason to have [1], except if you&#x27;re micro-optimizing embedded code for some device with 64kb RAM or whatever. We&#x27;ve carried through legacy practices, and we don&#x27;t even question them, and try to push them way out of their league into large-scale distributed software.<p>When I say we don&#x27;t need [1], this doesn&#x27;t mean I deny [3], which is still statically analyzable type information. It&#x27;s static types, but without throwing away flexibility and data at runtime, that doesn&#x27;t need to be thrown away.</div><br/><div id="36912233" class="c"><input type="checkbox" id="c-36912233" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912039">parent</a><span>|</span><a href="#36912362">next</a><span>|</span><label class="collapse" for="c-36912233">[-]</label><label class="expand" for="c-36912233">[3 more]</label></div><br/><div class="children"><div class="content">Short of time travel one can not turn (3) or (2) into (1). I&#x27;m not sure where the confusion here is or what you&#x27;re advocating for because this isn&#x27;t making sense to me.<p>&gt; there&#x27;s no longer a reason to have [1]<p>I guess if you&#x27;re assuming the value of static types is just performance? But it&#x27;s not, not by a long shot - hence &#x27;mypy&#x27;, a static typechecker that in no way impacts runtime.<p>I think this conversation is a bit too confusing for me so I&#x27;m gonna respectfully walk away :)</div><br/><div id="36912388" class="c"><input type="checkbox" id="c-36912388" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912233">parent</a><span>|</span><a href="#36912362">next</a><span>|</span><label class="collapse" for="c-36912388">[-]</label><label class="expand" for="c-36912388">[2 more]</label></div><br/><div class="children"><div class="content">The confusion is to assume &quot;runtime&quot; is statically defined. JIT generates code which omits type information that&#x27;s determined not to be needed in the context of the compiled method&#x2F;trace&#x2F;class&#x2F;module. That code still &quot;runs&quot; it&#x27;s &quot;runtime&quot;.</div><br/><div id="36912625" class="c"><input type="checkbox" id="c-36912625" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36912388">parent</a><span>|</span><a href="#36912362">next</a><span>|</span><label class="collapse" for="c-36912625">[-]</label><label class="expand" for="c-36912625">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the types that JIT omits are dynamic types.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36910768" class="c"><input type="checkbox" id="c-36910768" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910030">parent</a><span>|</span><a href="#36910391">prev</a><span>|</span><a href="#36910512">next</a><span>|</span><label class="collapse" for="c-36910768">[-]</label><label class="expand" for="c-36910768">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s up to you.<p>It&#x27;s easy to imagine any statically typed language having a general-purpose JSON type.  You could imagine all functions accepting and returning such objects.<p>Now it&#x27;s your turn to implement the sum(a,b) function.  Would you like to allow the caller to pass anything in as a and b?</div><br/><div id="36910825" class="c"><input type="checkbox" id="c-36910825" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910768">parent</a><span>|</span><a href="#36910512">next</a><span>|</span><label class="collapse" for="c-36910825">[-]</label><label class="expand" for="c-36910825">[1 more]</label></div><br/><div class="children"><div class="content">This is like when people use protobuf to send a list of key-value mappings, and call that a protocol.  (I&#x27;ve seen that same design in many protocol description arenas, even SQL database schemas that are just (entityId INT, key CLOB, value BLOB).</div><br/></div></div></div></div><div id="36910512" class="c"><input type="checkbox" id="c-36910512" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910030">parent</a><span>|</span><a href="#36910768">prev</a><span>|</span><a href="#36911248">next</a><span>|</span><label class="collapse" for="c-36910512">[-]</label><label class="expand" for="c-36910512">[1 more]</label></div><br/><div class="children"><div class="content">Do you need to make different versions of a program exchange information even though they do not agree on the types? No? Then this argument cannot be extended this way.</div><br/></div></div><div id="36911248" class="c"><input type="checkbox" id="c-36911248" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910030">parent</a><span>|</span><a href="#36910512">prev</a><span>|</span><a href="#36910114">next</a><span>|</span><label class="collapse" for="c-36911248">[-]</label><label class="expand" for="c-36911248">[1 more]</label></div><br/><div class="children"><div class="content">See my sibling comment, e.g. with respect to Rich Hickey&#x27;s framing - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36911033">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36911033</a></div><br/></div></div></div></div><div id="36910114" class="c"><input type="checkbox" id="c-36910114" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#36909894">parent</a><span>|</span><a href="#36910030">prev</a><span>|</span><a href="#36910607">next</a><span>|</span><label class="collapse" for="c-36910114">[-]</label><label class="expand" for="c-36910114">[13 more]</label></div><br/><div class="children"><div class="content">Avro solves this problem completely, and more elegantly with its schema resolution mechanism. Exchanging schemas at the beginning of a connection handshake is hardly burdensome</div><br/><div id="36910199" class="c"><input type="checkbox" id="c-36910199" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910114">parent</a><span>|</span><a href="#36910627">next</a><span>|</span><label class="collapse" for="c-36910199">[-]</label><label class="expand" for="c-36910199">[9 more]</label></div><br/><div class="children"><div class="content">If by &quot;solving&quot; you mean &quot;refuse to do anything at all unless you have the exact schema version of the message you&#x27;re trying to read&quot; then yes. In a RPC context that might even be fine, but in a message queue...<p>I will never use Avro again on a MQ. I also found the schema resolution mechanism anemic.<p>Avro was (is?) popular on Kafka, but it is such a bad fit that Confluent created a whole additional piece of infra called Schema Registry [1] to make it work. For Protobuf and JSON schema, it&#x27;s 90% useless and sometimes actively harmful.<p>I think you can also embed the schema in an Avro message to solve this, but then you add a massive amount of overhead if you send individual messages.<p>[1] <a href="https:&#x2F;&#x2F;docs.confluent.io&#x2F;platform&#x2F;current&#x2F;schema-registry&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.confluent.io&#x2F;platform&#x2F;current&#x2F;schema-registry&#x2F;i...</a></div><br/><div id="36910414" class="c"><input type="checkbox" id="c-36910414" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910199">parent</a><span>|</span><a href="#36910505">next</a><span>|</span><label class="collapse" for="c-36910414">[-]</label><label class="expand" for="c-36910414">[5 more]</label></div><br/><div class="children"><div class="content">&gt; but it is such a bad fit that Confluent created a whole additional piece of infra called Schema Registry [1] to make it work.<p>That seems like a weird way to describe it. It is assumed that a schema registry would be present for something like Avro. It&#x27;s just how it&#x27;s designed - the <i>assumption</i> with Avro is that you can share your schemas. If you can&#x27;t abide by that don&#x27;t use it.</div><br/><div id="36910694" class="c"><input type="checkbox" id="c-36910694" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910414">parent</a><span>|</span><a href="#36910505">next</a><span>|</span><label class="collapse" for="c-36910694">[-]</label><label class="expand" for="c-36910694">[4 more]</label></div><br/><div class="children"><div class="content">I do not think its unfair at all. Schema registry needs to add a wrapper and UUID to an Avro payload for it to work, so at the very least Avro as-is is unsuitable for a MQ like Kafka since you cannot use it efficiently without some out-of-band communication channel.</div><br/><div id="36910817" class="c"><input type="checkbox" id="c-36910817" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910694">parent</a><span>|</span><a href="#36910505">next</a><span>|</span><label class="collapse" for="c-36910817">[-]</label><label class="expand" for="c-36910817">[3 more]</label></div><br/><div class="children"><div class="content">Everyone knows you need an out of band channel for it, I don&#x27;t know why you&#x27;re putting this out there like it&#x27;s a fault instead of how it&#x27;s designed. Whether it&#x27;s RPC where you can deploy your services or a schema registry, that is literally just how it works.<p>Wrapping a message with its schema version so that you can look up that version is a really sensible way to go. A uuid is way more than what&#x27;s needed since they could have just used a serial integer but whatever, that&#x27;s on Kafka for building it that way, not Avro.</div><br/><div id="36913833" class="c"><input type="checkbox" id="c-36913833" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910817">parent</a><span>|</span><a href="#36910505">next</a><span>|</span><label class="collapse" for="c-36913833">[-]</label><label class="expand" for="c-36913833">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a serial integer<p>And now you can&#x27;t trivially port your data between environments.</div><br/><div id="36917017" class="c"><input type="checkbox" id="c-36917017" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36913833">parent</a><span>|</span><a href="#36910505">next</a><span>|</span><label class="collapse" for="c-36917017">[-]</label><label class="expand" for="c-36917017">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate? I don&#x27;t see any issue at all.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36910505" class="c"><input type="checkbox" id="c-36910505" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910199">parent</a><span>|</span><a href="#36910414">prev</a><span>|</span><a href="#36910627">next</a><span>|</span><label class="collapse" for="c-36910505">[-]</label><label class="expand" for="c-36910505">[3 more]</label></div><br/><div class="children"><div class="content">Having the schema for a data format I&#x27;m decoding has never been a problem in my line of work, and i&#x27;ve dealt with dozens of data formats. Evolution, versioning and deprecating fields on the other hand is always a pain in the butt.</div><br/><div id="36910615" class="c"><input type="checkbox" id="c-36910615" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910505">parent</a><span>|</span><a href="#36910627">next</a><span>|</span><label class="collapse" for="c-36910615">[-]</label><label class="expand" for="c-36910615">[2 more]</label></div><br/><div class="children"><div class="content">If a n+1 version producer sends a message to the message queue with a new optional field, how do the n version consumers have the right schema without relying on some external store?<p>In Protobuf or JSON this is not a problem at all, the new field is ignored. With Avro you cannot read the message.</div><br/><div id="36910714" class="c"><input type="checkbox" id="c-36910714" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910615">parent</a><span>|</span><a href="#36910627">next</a><span>|</span><label class="collapse" for="c-36910714">[-]</label><label class="expand" for="c-36910714">[1 more]</label></div><br/><div class="children"><div class="content">I mean a schema registry solves this problem, and you just put the schema in to the registry before the software is released.<p>A simpler option is to just publish the schema in to the queue periodically. Say every 30 seconds, and then receivers can cache schemas for message types they are  interested in.</div><br/></div></div></div></div></div></div></div></div><div id="36910627" class="c"><input type="checkbox" id="c-36910627" checked=""/><div class="controls bullet"><span class="by">throwboatyface</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910114">parent</a><span>|</span><a href="#36910199">prev</a><span>|</span><a href="#36910523">next</a><span>|</span><label class="collapse" for="c-36910627">[-]</label><label class="expand" for="c-36910627">[1 more]</label></div><br/><div class="children"><div class="content">Disagree. Avro makes messages slightly smaller by removing tags, but it makes individual messages completely incomprehensible without the writer schema. For serializing data on disk it&#x27;s fine and a reasonable tradeoff to save space, but for communication on the wire tagged formats allow for more flexibility on the receiver end.<p>The spec for evolving schemas is also full of ambiguity and relies on the canonical Java implementation. I&#x27;ve built an Avro decoder from scratch and some of the evolution behaviour is counter-intuitive.</div><br/></div></div><div id="36910523" class="c"><input type="checkbox" id="c-36910523" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910114">parent</a><span>|</span><a href="#36910627">prev</a><span>|</span><a href="#36910607">next</a><span>|</span><label class="collapse" for="c-36910523">[-]</label><label class="expand" for="c-36910523">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Exchanging schemas at the beginning of a connection handshake is hardly burdensome.<p>I dunno, that sounds extremely burdensome to me, especially if the actual payload is small.<p>And how exactly does exchanging schemas solve the problem? If my version of the schema says this field is required but yours says it is optional, and so you don&#x27;t send it, what am I supposed to do?</div><br/><div id="36910823" class="c"><input type="checkbox" id="c-36910823" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909894">root</a><span>|</span><a href="#36910523">parent</a><span>|</span><a href="#36910607">next</a><span>|</span><label class="collapse" for="c-36910823">[-]</label><label class="expand" for="c-36910823">[1 more]</label></div><br/><div class="children"><div class="content">Avro makes that case slightly better because you can default value for a missing field in one of the two schemas and then it works.<p>It&#x27;s not worth the boatload of problems it bring in all other and normal use cases though. Having the default value in the app or specified by the protocol is good enough.</div><br/></div></div></div></div></div></div><div id="36910607" class="c"><input type="checkbox" id="c-36910607" checked=""/><div class="controls bullet"><span class="by">alphanullmeric</span><span>|</span><a href="#36909894">parent</a><span>|</span><a href="#36910114">prev</a><span>|</span><a href="#36909258">next</a><span>|</span><label class="collapse" for="c-36910607">[-]</label><label class="expand" for="c-36910607">[1 more]</label></div><br/><div class="children"><div class="content">Rustaceans in shambles</div><br/></div></div></div></div><div id="36909258" class="c"><input type="checkbox" id="c-36909258" checked=""/><div class="controls bullet"><span class="by">batch12</span><span>|</span><a href="#36909894">prev</a><span>|</span><a href="#36913068">next</a><span>|</span><label class="collapse" for="c-36909258">[-]</label><label class="expand" for="c-36909258">[6 more]</label></div><br/><div class="children"><div class="content">I know this isn&#x27;t new, but I wonder if the name is an intentional nod to Star Trek Voyager or is there another reference I&#x27;m not aware of.<p><a href="https:&#x2F;&#x2F;memory-alpha.fandom.com&#x2F;wiki&#x2F;Captain_Proton" rel="nofollow noreferrer">https:&#x2F;&#x2F;memory-alpha.fandom.com&#x2F;wiki&#x2F;Captain_Proton</a></div><br/><div id="36909537" class="c"><input type="checkbox" id="c-36909537" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909258">parent</a><span>|</span><a href="#36909355">next</a><span>|</span><label class="collapse" for="c-36909537">[-]</label><label class="expand" for="c-36909537">[3 more]</label></div><br/><div class="children"><div class="content">Huh, that reference actually never occurred to me.<p>The name Cap&#x27;n Proto actually originally meant &quot;Capabilities and Protobufs&quot; -- it was a capability-based RPC protocol based on Protocol Buffers. However, early on I decided I wanted to try a whole different serialization format instead. &quot;Proto&quot; still makes sense, since it is a protocol, so I kept the name.<p>The pun &quot;cerealization protocol&quot; is actually something someone else had to point out to me, but I promptly added it to the logo. :)</div><br/><div id="36910326" class="c"><input type="checkbox" id="c-36910326" checked=""/><div class="controls bullet"><span class="by">mi_lk</span><span>|</span><a href="#36909258">root</a><span>|</span><a href="#36909537">parent</a><span>|</span><a href="#36909355">next</a><span>|</span><label class="collapse" for="c-36910326">[-]</label><label class="expand" for="c-36910326">[2 more]</label></div><br/><div class="children"><div class="content">What does capacity-based mean in this context?</div><br/><div id="36910400" class="c"><input type="checkbox" id="c-36910400" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909258">root</a><span>|</span><a href="#36910326">parent</a><span>|</span><a href="#36909355">next</a><span>|</span><label class="collapse" for="c-36910400">[-]</label><label class="expand" for="c-36910400">[1 more]</label></div><br/><div class="children"><div class="content">Capability, not capacity.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security</a><p><a href="https:&#x2F;&#x2F;capnproto.org&#x2F;rpc.html#distributed-objects" rel="nofollow noreferrer">https:&#x2F;&#x2F;capnproto.org&#x2F;rpc.html#distributed-objects</a><p>The idea really goes way beyond security and RPC. It&#x27;s hard to explain concisely but it&#x27;s sort of a way of thinking about software architecture.</div><br/></div></div></div></div></div></div><div id="36909355" class="c"><input type="checkbox" id="c-36909355" checked=""/><div class="controls bullet"><span class="by">azornathogron</span><span>|</span><a href="#36909258">parent</a><span>|</span><a href="#36909537">prev</a><span>|</span><a href="#36909278">next</a><span>|</span><label class="collapse" for="c-36909355">[-]</label><label class="expand" for="c-36909355">[1 more]</label></div><br/><div class="children"><div class="content">Given that it&#x27;s billed as a &quot;cerealization protocol&quot;, I always assumed it was a reference to Cap&#x27;n Crunch cereal.</div><br/></div></div></div></div><div id="36913068" class="c"><input type="checkbox" id="c-36913068" checked=""/><div class="controls bullet"><span class="by">jFriedensreich</span><span>|</span><a href="#36909258">prev</a><span>|</span><a href="#36917477">next</a><span>|</span><label class="collapse" for="c-36913068">[-]</label><label class="expand" for="c-36913068">[1 more]</label></div><br/><div class="children"><div class="content">i love how the main reference for workerd can be just one capnp file.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workerd&#x2F;blob&#x2F;main&#x2F;src&#x2F;workerd&#x2F;server&#x2F;workerd.capnp">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workerd&#x2F;blob&#x2F;main&#x2F;src&#x2F;workerd&#x2F;...</a><p>this changed my world how i think about computing on the web.<p>if there was just a good enough js library as for lua and you could directly send capnp messages to workerd instead of always going through files. I guess one day i have to relearn c++ and understand how the internals actually work.</div><br/></div></div><div id="36917477" class="c"><input type="checkbox" id="c-36917477" checked=""/><div class="controls bullet"><span class="by">up2isomorphism</span><span>|</span><a href="#36913068">prev</a><span>|</span><a href="#36909837">next</a><span>|</span><label class="collapse" for="c-36917477">[-]</label><label class="expand" for="c-36917477">[1 more]</label></div><br/><div class="children"><div class="content">Some of these “high perf” RPC libraries never get one key point, if I really need something to be fast, the most important aspect is that it must be simple.</div><br/></div></div><div id="36909837" class="c"><input type="checkbox" id="c-36909837" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#36917477">prev</a><span>|</span><a href="#36909926">next</a><span>|</span><label class="collapse" for="c-36909837">[-]</label><label class="expand" for="c-36909837">[10 more]</label></div><br/><div class="children"><div class="content">I always liked the idea of capnp, but it bothers me that what is ultimately a message encoding protocol has an opinion on how I should architect my server.<p>FWIW, gRPC certainly has this problem too, but it’s very clearly distinct from protobuf, although pb has gRPC-related features.<p>That entanglement makes me lean towards flatbuffers or even protobuf every time I weigh them against capnp, especially since it means that fb and pb have much simpler implementations, and I place great value on simplicity for both security and maintenance reasons.<p>I think the lack of good third-party language implementations speaks directly to the reasonability of that assessment.  It also makes the bus factor and longevity story very poor.  Simplicity rules.</div><br/><div id="36910094" class="c"><input type="checkbox" id="c-36910094" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909837">parent</a><span>|</span><a href="#36909944">next</a><span>|</span><label class="collapse" for="c-36910094">[-]</label><label class="expand" for="c-36910094">[4 more]</label></div><br/><div class="children"><div class="content">Part of the problem with cap&#x27;n&#x27;proto whenever I&#x27;ve approached it is that not only does it have an opinion on how to architect your server (fine, whatever) but in C++ it ends up shipping with its own very opinionated alternative to the STL (&quot;KJ&quot;) and when I played with it some years ago it really ended up getting its fingers everywhere and was hard to work into an existing codebase.<p>The Rust version also comes with its own normative lifestyle assumptions; many of which make sense in the context of its zero-copy world but still make a lot of things hard to express, and the documentation was hard to parse.<p>I tend to reach for flatbuffers instead, for this reason alone.<p>Still I think someday I hope to have need and use for cap&#x27;n&#x27;proto; or at least finish one of several hobby projects I&#x27;ve forked off to try to use it over the years. There&#x27;s some high quality engineering there.</div><br/><div id="36910285" class="c"><input type="checkbox" id="c-36910285" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910094">parent</a><span>|</span><a href="#36909944">next</a><span>|</span><label class="collapse" for="c-36910285">[-]</label><label class="expand" for="c-36910285">[3 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s true, the C++ implementation has become extremely opinionated.<p>I didn&#x27;t initially intend for KJ to become as all-encompassing as it has. I guess I kept running into things that didn&#x27;t work well about the standard library, so I&#x27;d make an alternative that worked well, but then other parts of the standard library would not play nicely with my alternative, so it snowballed a bit.<p>At the time the project started, C++11 -- which completely changed the language -- was brand new, and the standard library hadn&#x27;t been updated to really work well with the new features.<p>The KJ Promise library in particular, which made asynchronous programming much nicer using the newly-introduced lambdas, predated any equivalent landing in the standard library by quite a bit. This is probably the most opinionated part of KJ, hardest to integrate with other systems. (Though KJ&#x27;s even loop does actually have the ability to sit on top of other event loops, with some effort.)<p>And then I ended up with a complete ecosystem of libraries on top of Promises, like KJ HTTP.<p>With the Workers Runtime being built entirely in that ecosystem, it ends up making sense for me to keep improving that ecosystem, rather than try to make things work better across ecosystems... so here we are.</div><br/><div id="36910327" class="c"><input type="checkbox" id="c-36910327" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910285">parent</a><span>|</span><a href="#36909944">next</a><span>|</span><label class="collapse" for="c-36910327">[-]</label><label class="expand" for="c-36910327">[2 more]</label></div><br/><div class="children"><div class="content">Oh I understand completely how that would happen. I believe the first time I played with your work was not long after the C++11 transition, and so I could see why it happened.<p>This is why these days I just work in Rust :-) Less heterogenous of an environment (so far).</div><br/><div id="36910364" class="c"><input type="checkbox" id="c-36910364" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910327">parent</a><span>|</span><a href="#36909944">next</a><span>|</span><label class="collapse" for="c-36910364">[-]</label><label class="expand" for="c-36910364">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if I were starting from scratch today I&#x27;d use Rust. Unfortunately it was a little too early when work on Workers started.</div><br/></div></div></div></div></div></div></div></div><div id="36909944" class="c"><input type="checkbox" id="c-36909944" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909837">parent</a><span>|</span><a href="#36910094">prev</a><span>|</span><a href="#36909926">next</a><span>|</span><label class="collapse" for="c-36909944">[-]</label><label class="expand" for="c-36909944">[5 more]</label></div><br/><div class="children"><div class="content">How does the serialization layer impact your rpc choice?</div><br/><div id="36910444" class="c"><input type="checkbox" id="c-36910444" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36909944">parent</a><span>|</span><a href="#36909926">next</a><span>|</span><label class="collapse" for="c-36910444">[-]</label><label class="expand" for="c-36910444">[4 more]</label></div><br/><div class="children"><div class="content">Cap&#x27;N&#x27;Proto comes with a (quite good) RPC facility. Based on asynchronous promises and grounded in capabilities.<p>You don&#x27;t <i>have</i> to use it. You could just use it just as a &#x27;serialization&#x27; layer but if you&#x27;re writing services you could be missing half the advantage, really. And if you&#x27;re writing in C++ you&#x27;ll end up having to use their KJ library anyways.<p>If you take the whole package the zero copy, capability-security, and asynchrouny (a word I just coined!) all fit together nicely.</div><br/><div id="36910570" class="c"><input type="checkbox" id="c-36910570" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910444">parent</a><span>|</span><a href="#36910742">next</a><span>|</span><label class="collapse" for="c-36910570">[-]</label><label class="expand" for="c-36910570">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m aware of all of that. What I&#x27;m saying is that I don&#x27;t see what about the Schema Definition Language pushes you towards the RPC other than that they obviously go well together, just like gRPC is almost always used with protobuf, or http with JSON.<p>&gt;  but it bothers me that what is ultimately a message encoding protocol has an opinion on how I should architect my server.<p>To me, this is like saying &quot;Using JSON is unfortunate because it has an opinion that I should use HTTP&quot; when I don&#x27;t think anyone would argue that at all, and I don&#x27;t see the argument for capnp much either.</div><br/><div id="36910991" class="c"><input type="checkbox" id="c-36910991" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910570">parent</a><span>|</span><a href="#36910742">next</a><span>|</span><label class="collapse" for="c-36910991">[-]</label><label class="expand" for="c-36910991">[1 more]</label></div><br/><div class="children"><div class="content">The main thing that Cap&#x27;n Proto PRC really requires about the serialization is that object references are a first-class type. That is, when you make an RPC, the parameters or results can contain references to new, remote RPC objects. Upon receiving such a reference, that object is now callable.<p>Making this work nicely requires some integration between the serialization layer and the RPC layer, though it&#x27;s certainly possible to imagine Protobuf being extended with some sort of hooks for this.</div><br/></div></div></div></div><div id="36910742" class="c"><input type="checkbox" id="c-36910742" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#36909837">root</a><span>|</span><a href="#36910444">parent</a><span>|</span><a href="#36910570">prev</a><span>|</span><a href="#36909926">next</a><span>|</span><label class="collapse" for="c-36910742">[-]</label><label class="expand" for="c-36910742">[1 more]</label></div><br/><div class="children"><div class="content">Asynchrony?</div><br/></div></div></div></div></div></div></div></div><div id="36909926" class="c"><input type="checkbox" id="c-36909926" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909837">prev</a><span>|</span><a href="#36917059">next</a><span>|</span><label class="collapse" for="c-36909926">[-]</label><label class="expand" for="c-36909926">[2 more]</label></div><br/><div class="children"><div class="content">Any plans to improve the Rust side of things? The API could definitely use some more work&#x2F; docs around it.</div><br/><div id="36911786" class="c"><input type="checkbox" id="c-36911786" checked=""/><div class="controls bullet"><span class="by">dwrensha</span><span>|</span><a href="#36909926">parent</a><span>|</span><a href="#36917059">next</a><span>|</span><label class="collapse" for="c-36911786">[-]</label><label class="expand" for="c-36911786">[1 more]</label></div><br/><div class="children"><div class="content">I intend to continue work on capnproto-rust, at my own pace and according to my own priorities.<p>Are there any particular pain points that you want to call attention to?</div><br/></div></div></div></div><div id="36917059" class="c"><input type="checkbox" id="c-36917059" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#36909926">prev</a><span>|</span><a href="#36914904">next</a><span>|</span><label class="collapse" for="c-36917059">[-]</label><label class="expand" for="c-36917059">[1 more]</label></div><br/><div class="children"><div class="content">I am trying to revive C implementation [1]. Any help is welcome.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;opensourcerouting&#x2F;c-capnproto">https:&#x2F;&#x2F;github.com&#x2F;opensourcerouting&#x2F;c-capnproto</a></div><br/></div></div><div id="36914904" class="c"><input type="checkbox" id="c-36914904" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36917059">prev</a><span>|</span><a href="#36910433">next</a><span>|</span><label class="collapse" for="c-36914904">[-]</label><label class="expand" for="c-36914904">[1 more]</label></div><br/><div class="children"><div class="content">We support CapNProto as an import&#x2F;export format in ClickHouse.<p>It was contributed by Marek Vavruša from CloudFlare in 2017: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;pull&#x2F;1387">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;pull&#x2F;1387</a><p>Since then, we extended and improved the support: added it for export (initially, it was only for import) and improved the performance.<p>About strange stuff in the library - it uses a non-obvious approach for exception handling, and their C++ code feels like they too much focusing on some non-orthodox approaches.</div><br/></div></div><div id="36910433" class="c"><input type="checkbox" id="c-36910433" checked=""/><div class="controls bullet"><span class="by">shdh</span><span>|</span><a href="#36914904">prev</a><span>|</span><a href="#36916485">next</a><span>|</span><label class="collapse" for="c-36910433">[-]</label><label class="expand" for="c-36910433">[7 more]</label></div><br/><div class="children"><div class="content">We have a great plethora of binary serialization libraries now, but I&#x27;ve noticed none of them offer the following:<p>* Specification of the number of bits I want to cap out a field at during serialization, ie: `int` that only uses 3 bits.<p>* Delta encoding for serialization and deserialization, this would further decrease the size of each message if there is an older message that I can use as the initial message to delta encode&#x2F;decode from.</div><br/><div id="36910641" class="c"><input type="checkbox" id="c-36910641" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#36910433">parent</a><span>|</span><a href="#36915907">next</a><span>|</span><label class="collapse" for="c-36910641">[-]</label><label class="expand" for="c-36910641">[2 more]</label></div><br/><div class="children"><div class="content">&gt; `int` that only uses 3 bits.<p>CBOR approximates this, since it has several different widths for integers.<p>&gt; an older message that I can use as the initial message to delta encode&#x2F;decode from.<p>General-purpose compression on the encoded stream would do something toward this goal, but some protocol buffers library implementations offer merge functions. The question is what semantics of &quot;merge&quot; you expect. For repeated fields do you want to append or clobber?</div><br/><div id="36917936" class="c"><input type="checkbox" id="c-36917936" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36910433">root</a><span>|</span><a href="#36910641">parent</a><span>|</span><a href="#36915907">next</a><span>|</span><label class="collapse" for="c-36917936">[-]</label><label class="expand" for="c-36917936">[1 more]</label></div><br/><div class="children"><div class="content">CBOR has different integer widths, yes, but 1&#x2F;2&#x2F;3&#x2F;5&#x2F;9 bytes is not particularly flexible.<p>And if someone is asking for exact bit sizes and deltas, they probably don&#x27;t want a format that embeds every key in every message.</div><br/></div></div></div></div><div id="36915907" class="c"><input type="checkbox" id="c-36915907" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#36910433">parent</a><span>|</span><a href="#36910641">prev</a><span>|</span><a href="#36911642">next</a><span>|</span><label class="collapse" for="c-36915907">[-]</label><label class="expand" for="c-36915907">[1 more]</label></div><br/><div class="children"><div class="content">One thing I liked about Ada, the small amount I used it, is it has actual subtypes: you could define a variable as an integer within a specific range, and the compiler would (presumably) choose an appropriate underlying storage type for it.</div><br/></div></div><div id="36911642" class="c"><input type="checkbox" id="c-36911642" checked=""/><div class="controls bullet"><span class="by">no_circuit</span><span>|</span><a href="#36910433">parent</a><span>|</span><a href="#36915907">prev</a><span>|</span><a href="#36912627">next</a><span>|</span><label class="collapse" for="c-36911642">[-]</label><label class="expand" for="c-36911642">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at FAST protocol [1]. It has been around for a while. Was created for market&#x2F;trading data. There appears to be some open source implementations, but I don&#x27;t think in general they&#x27;d be maintained well since trading is, well, secretive.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FAST_protocol" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FAST_protocol</a></div><br/></div></div><div id="36912627" class="c"><input type="checkbox" id="c-36912627" checked=""/><div class="controls bullet"><span class="by">wichert</span><span>|</span><a href="#36910433">parent</a><span>|</span><a href="#36911642">prev</a><span>|</span><a href="#36911858">next</a><span>|</span><label class="collapse" for="c-36912627">[-]</label><label class="expand" for="c-36912627">[1 more]</label></div><br/><div class="children"><div class="content">zserio [1] has the former at least. It isn&#x27;t intended for the same use cases as protobuf&#x2F;capnproto&#x2F;flatbutter though; in particular it has no backward or forwards compatibility. But it&#x27;s great for situations where you know exactly what software is used on both ends and you need small data and fast en-&#x2F;decoding.<p>[1] <a href="http:&#x2F;&#x2F;zserio.org&#x2F;doc&#x2F;ZserioLanguageOverview.html#bit-field-types" rel="nofollow noreferrer">http:&#x2F;&#x2F;zserio.org&#x2F;doc&#x2F;ZserioLanguageOverview.html#bit-field-...</a></div><br/></div></div><div id="36911858" class="c"><input type="checkbox" id="c-36911858" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36910433">parent</a><span>|</span><a href="#36912627">prev</a><span>|</span><a href="#36916485">next</a><span>|</span><label class="collapse" for="c-36911858">[-]</label><label class="expand" for="c-36911858">[1 more]</label></div><br/><div class="children"><div class="content">Most formats use varints, so you can&#x27;t have a 3-bit int but they will store a 64-bit int in one byte if it fits. Going to smaller than a byte isn&#x27;t worth the extra complexity and slowness. If you&#x27;re <i>that</i> space sensitive you need to add proper compression.<p>By delta compression you mean <i>across messages</i>? Yeah I&#x27;ve never seen that but it&#x27;s hard to imagine a scenario where it would be useful and worth the insane complexity.</div><br/></div></div></div></div><div id="36916485" class="c"><input type="checkbox" id="c-36916485" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#36910433">prev</a><span>|</span><a href="#36909688">next</a><span>|</span><label class="collapse" for="c-36916485">[-]</label><label class="expand" for="c-36916485">[1 more]</label></div><br/><div class="children"><div class="content">[2013] Show HN: Cap&#x27;n Proto, by the ex-maintainer of Protocol Buffers: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5482081">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5482081</a></div><br/></div></div><div id="36909688" class="c"><input type="checkbox" id="c-36909688" checked=""/><div class="controls bullet"><span class="by">s17n</span><span>|</span><a href="#36916485">prev</a><span>|</span><a href="#36911016">next</a><span>|</span><label class="collapse" for="c-36909688">[-]</label><label class="expand" for="c-36909688">[2 more]</label></div><br/><div class="children"><div class="content">It’s a testament to the subtlety of software engineering that even after four tries (protobuf 1-3, capn proto 1) there are still breaking changes that need to be made to the solution of what on the surface appears to be a relatively constrained problem.</div><br/><div id="36910007" class="c"><input type="checkbox" id="c-36910007" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909688">parent</a><span>|</span><a href="#36911016">next</a><span>|</span><label class="collapse" for="c-36910007">[-]</label><label class="expand" for="c-36910007">[1 more]</label></div><br/><div class="children"><div class="content">Of course, nothing is ever &quot;solved&quot;. :)<p>I assume you are talking about the cancellation change. This is interesting, actually. When originally designing Cap&#x27;n Proto, I was convinced by a capabilities expert I talked to that cancellation should be considered dangerous, because software that isn&#x27;t expecting it might be vulnerable to attacks if cancellation occurs at an unexpected place. Especially in a language like C++, which lacks garbage collection or borrow checking, you might expect use-after-free to be a big issue. I found the argument compelling.<p>In practice, though, I&#x27;ve found the opposite: In a language with explicit lifetimes, and with KJ&#x27;s particular approach to Promises (used to handle async tasks in Cap&#x27;n Proto&#x27;s C++ implementation), cancellation safety is a natural side-effect of writing code to have correct lifetimes. You have to make cancellation safe because you have to cancel tasks all the time when the objects they depend on are going to be destroyed. Moreover, in a fault-tolerant distributed system, you have to assume any code might not complete, e.g. due to a power outage or maybe just throwing an unexpected exception in the middle, and you have to program defensively for that anyway. This all becomes second-nature pretty quick.<p>So all our code ends up cancellation-safe by default. We end up with way more problems from cancellation unexpectedly being prevented when we need it, than happening when we didn&#x27;t expect it.<p>EDIT: Re-reading, maybe you were referring to the breaking changes slated for 2.0. But those are primarily changes to the KJ toolkit library, not Cap&#x27;n Proto, and is all about API design... I&#x27;d say API design is not a constrained problem.</div><br/></div></div></div></div><div id="36911016" class="c"><input type="checkbox" id="c-36911016" checked=""/><div class="controls bullet"><span class="by">Timothycquinn</span><span>|</span><a href="#36909688">prev</a><span>|</span><a href="#36910547">next</a><span>|</span><label class="collapse" for="c-36911016">[-]</label><label class="expand" for="c-36911016">[2 more]</label></div><br/><div class="children"><div class="content">Congrats in 10 years! Question: Can Cap&#x27;n Proto be used as an alternative to Python Pickle library for serializing and de-serializing python object structures?</div><br/><div id="36911388" class="c"><input type="checkbox" id="c-36911388" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36911016">parent</a><span>|</span><a href="#36910547">next</a><span>|</span><label class="collapse" for="c-36911388">[-]</label><label class="expand" for="c-36911388">[1 more]</label></div><br/><div class="children"><div class="content">If your goal is to serialize an arbitrary Python object, Pickle is the way to go. Cap&#x27;n Proto requires you to define a schema, in Cap&#x27;n Proto schema language, for whatever you wan to serialize. It can&#x27;t just take an arbitrary Python value.</div><br/></div></div></div></div><div id="36910547" class="c"><input type="checkbox" id="c-36910547" checked=""/><div class="controls bullet"><span class="by">synthetigram</span><span>|</span><a href="#36911016">prev</a><span>|</span><a href="#36911202">next</a><span>|</span><label class="collapse" for="c-36910547">[-]</label><label class="expand" for="c-36910547">[1 more]</label></div><br/><div class="children"><div class="content">After exploring a few constant access serialization formats, I had to pass on Capn Proto in favor of Apache Avro.   Capn has a great experience for C++ users, but Java codegen ended up being too annoying to get started with.  If Capn Proto improved the developer experience for the other languages people write, I think it would really help a lot.</div><br/></div></div><div id="36911202" class="c"><input type="checkbox" id="c-36911202" checked=""/><div class="controls bullet"><span class="by">emtel</span><span>|</span><a href="#36910547">prev</a><span>|</span><a href="#36911314">next</a><span>|</span><label class="collapse" for="c-36911202">[-]</label><label class="expand" for="c-36911202">[1 more]</label></div><br/><div class="children"><div class="content">I used capnproto years ago as the network serialization format for a multiplayer RTS game. Although the API can be quite awkward, it was overall a joy to use and I wish I was able to use it in more projects.</div><br/></div></div><div id="36911314" class="c"><input type="checkbox" id="c-36911314" checked=""/><div class="controls bullet"><span class="by">richardfey</span><span>|</span><a href="#36911202">prev</a><span>|</span><a href="#36909472">next</a><span>|</span><label class="collapse" for="c-36911314">[-]</label><label class="expand" for="c-36911314">[1 more]</label></div><br/><div class="children"><div class="content">Amazing to see Cap&#x27;n Proto come this far!
I wonder how easy it would be to swap it for gRPC, and still have advanced load balancing support for it.</div><br/></div></div><div id="36909472" class="c"><input type="checkbox" id="c-36909472" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36911314">prev</a><span>|</span><a href="#36912244">next</a><span>|</span><label class="collapse" for="c-36909472">[-]</label><label class="expand" for="c-36909472">[22 more]</label></div><br/><div class="children"><div class="content">Great achievement. To be honest I wouldn&#x27;t recommend Capnp. The C++ API is very awkward.<p>The zero copy parsing is less of a benefit than you&#x27;d expect - pretty unlikely you&#x27;re going to want to keep your data as a Capnp data structure because of how awkward it is to use. 99% of the time you&#x27;ll just copy it into your own data structures anyway.<p>There&#x27;s also more friction with the rest of the world which has more or less settled on Protobuf as the most popular binary implementation of this sort of idea.<p>I only used it for serialisation. Maybe the RPC stuff is more compelling.<p>I really wish Thrift had taken off instead of Protobuf&#x2F;gRPC. It was so much better designed and more flexible than anything I&#x27;ve seen before or since. I think it died mainly due to terrible documentation. I guess it also didn&#x27;t have a big name behind it.</div><br/><div id="36909744" class="c"><input type="checkbox" id="c-36909744" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909472">parent</a><span>|</span><a href="#36909541">next</a><span>|</span><label class="collapse" for="c-36909744">[-]</label><label class="expand" for="c-36909744">[6 more]</label></div><br/><div class="children"><div class="content">I do agree that the API required for zero-copy turns out a bit awkward, particularly on the writing side. The reading side doesn&#x27;t look much different. Meanwhile zero-copy is really only a paradigm shift in certain scenarios, like when used with mmap(). For network communications it doesn&#x27;t change much unless you are doing something hardcore like RDMA. I&#x27;ve always wanted to add an optional alternative API to Cap&#x27;n Proto that uses &quot;plain old C structures&quot; (or something close to it) with one-copy serialization (just like protobuf) for the use cases where zero-copy doesn&#x27;t really matter. But haven&#x27;t gotten around to it yet...<p>That said I personally have always been much more excited about the RPC protocol than the serialization. I think the RPC protocol is actually a paradigm shift for almost any non-trivial use case.</div><br/><div id="36909991" class="c"><input type="checkbox" id="c-36909991" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909744">parent</a><span>|</span><a href="#36910524">next</a><span>|</span><label class="collapse" for="c-36909991">[-]</label><label class="expand" for="c-36909991">[4 more]</label></div><br/><div class="children"><div class="content">One thing about google proto is that, at least in many languages, every message throws off a ton of garbage that stresses the GC.  On the send side, you can obviously re-use objects, but on the receive side no.</div><br/><div id="36913762" class="c"><input type="checkbox" id="c-36913762" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909991">parent</a><span>|</span><a href="#36913358">next</a><span>|</span><label class="collapse" for="c-36913762">[-]</label><label class="expand" for="c-36913762">[2 more]</label></div><br/><div class="children"><div class="content">More and more languages are being built on top of the &quot;upb&quot; C library for protobuf (<a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb</a>) which is designed around arenas to avoid this very problem.<p>Currently Ruby, PHP, and Python are backed by upb.<p>Disclosure: I work on the protobuf team, and created the upb library.</div><br/><div id="36914738" class="c"><input type="checkbox" id="c-36914738" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36913762">parent</a><span>|</span><a href="#36913358">next</a><span>|</span><label class="collapse" for="c-36914738">[-]</label><label class="expand" for="c-36914738">[1 more]</label></div><br/><div class="children"><div class="content">Agreed but please do something about Go.</div><br/></div></div></div></div><div id="36913358" class="c"><input type="checkbox" id="c-36913358" checked=""/><div class="controls bullet"><span class="by">tignaj</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909991">parent</a><span>|</span><a href="#36913762">prev</a><span>|</span><a href="#36910524">next</a><span>|</span><label class="collapse" for="c-36913358">[-]</label><label class="expand" for="c-36913358">[1 more]</label></div><br/><div class="children"><div class="content">This is also because Google&#x27;s Protobuf implementations aren&#x27;t doing a very good job with avoiding unnecessary allocations. Gogoproto is better and it is possible to do even better, here is an example prototype I have put together for Go (even if you do not use the laziness part it is still much faster than Google&#x27;s implementation): <a href="https:&#x2F;&#x2F;github.com&#x2F;splunk&#x2F;exp-lazyproto">https:&#x2F;&#x2F;github.com&#x2F;splunk&#x2F;exp-lazyproto</a></div><br/></div></div></div></div><div id="36910524" class="c"><input type="checkbox" id="c-36910524" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909744">parent</a><span>|</span><a href="#36909991">prev</a><span>|</span><a href="#36909541">next</a><span>|</span><label class="collapse" for="c-36910524">[-]</label><label class="expand" for="c-36910524">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been excited about zero copy messages in the context of its potential in database systems; the thought of tuples working their way all the way from btree nodes in a pager, to query results on the network without copies seems fantastic.<p>But every time I&#x27;ve tried to prototype or implement around this model I&#x27;ve  run into conceptual blocks.  It&#x27;s a tricky paradigm to fully wrap one&#x27;s head around, and to squeeze into existing toolsets.</div><br/></div></div></div></div><div id="36909541" class="c"><input type="checkbox" id="c-36909541" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36909472">parent</a><span>|</span><a href="#36909744">prev</a><span>|</span><a href="#36909666">next</a><span>|</span><label class="collapse" for="c-36909541">[-]</label><label class="expand" for="c-36909541">[5 more]</label></div><br/><div class="children"><div class="content">You mean flatbuffers, not protobuf.<p>It has established itself as the de-facto standard, with a few other places using SBE instead.<p>In any case the main problems with binary serialization are:<p>- schemas and message version management<p>- delta-encoding<p>If you ignore these, flat binary serialization is trivial.<p>No library provides a good solution that covers the two points above.</div><br/><div id="36909783" class="c"><input type="checkbox" id="c-36909783" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909541">parent</a><span>|</span><a href="#36909836">next</a><span>|</span><label class="collapse" for="c-36909783">[-]</label><label class="expand" for="c-36909783">[3 more]</label></div><br/><div class="children"><div class="content">What part of the industry are you in where flatbuffers is seen as the de facto standard? Personally I&#x27;ve never randomly encountered a project using flatbuffers. I see protobuf all the time.<p>(I&#x27;ve randomly run into Cap&#x27;n Proto maybe 2-3 times but to be fair I&#x27;m probably more likely to notice that.)</div><br/><div id="36910421" class="c"><input type="checkbox" id="c-36910421" checked=""/><div class="controls bullet"><span class="by">ynx</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909783">parent</a><span>|</span><a href="#36910581">next</a><span>|</span><label class="collapse" for="c-36910421">[-]</label><label class="expand" for="c-36910421">[1 more]</label></div><br/><div class="children"><div class="content">As of the last time I was close, flatbuffer usage is or was near ubiquitous for use in FB&#x27;s (ha ha, go figure) mobile apps, across Android and iOS at least.</div><br/></div></div><div id="36910581" class="c"><input type="checkbox" id="c-36910581" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909783">parent</a><span>|</span><a href="#36910421">prev</a><span>|</span><a href="#36909836">next</a><span>|</span><label class="collapse" for="c-36910581">[-]</label><label class="expand" for="c-36910581">[1 more]</label></div><br/><div class="children"><div class="content">Flatbuffers seems to have penetration in the games industry. And it sounds like from other posters that Facebook uses it.<p>I recently started a job doing work on autonomy systems that run in tractors, and was surprised to see we use it (flatbuffers) in the messaging layer (in both C++ and Rust)</div><br/></div></div></div></div><div id="36909836" class="c"><input type="checkbox" id="c-36909836" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909541">parent</a><span>|</span><a href="#36909783">prev</a><span>|</span><a href="#36909666">next</a><span>|</span><label class="collapse" for="c-36909836">[-]</label><label class="expand" for="c-36909836">[1 more]</label></div><br/><div class="children"><div class="content">Protobuf is very widely used, I just had to Google flatbuffers...</div><br/></div></div></div></div><div id="36909666" class="c"><input type="checkbox" id="c-36909666" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#36909472">parent</a><span>|</span><a href="#36909541">prev</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36909666">[-]</label><label class="expand" for="c-36909666">[9 more]</label></div><br/><div class="children"><div class="content">I find MessagePack to be pretty great if you don&#x27;t need schema. JSON serialization is unreasonably fast in V8 though and even message pack can&#x27;t beat it; though it&#x27;s often faster in other languages and saves on bytes.</div><br/><div id="36910019" class="c"><input type="checkbox" id="c-36910019" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36909666">parent</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36910019">[-]</label><label class="expand" for="c-36910019">[8 more]</label></div><br/><div class="children"><div class="content">Except messagepack is really slow...</div><br/><div id="36910076" class="c"><input type="checkbox" id="c-36910076" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910019">parent</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36910076">[-]</label><label class="expand" for="c-36910076">[7 more]</label></div><br/><div class="children"><div class="content">Is it? It&#x27;s quite fast in DotNet..</div><br/><div id="36910539" class="c"><input type="checkbox" id="c-36910539" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910076">parent</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36910539">[-]</label><label class="expand" for="c-36910539">[6 more]</label></div><br/><div class="children"><div class="content">Historically I&#x27;ve heard and also experienced JSON + gzip&#x2F;zstd to be faster and smaller than msgpack.</div><br/><div id="36916037" class="c"><input type="checkbox" id="c-36916037" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910539">parent</a><span>|</span><a href="#36914124">next</a><span>|</span><label class="collapse" for="c-36916037">[-]</label><label class="expand" for="c-36916037">[1 more]</label></div><br/><div class="children"><div class="content">MsgPack is &gt;1.5 times faster than JSONL: <a href="https:&#x2F;&#x2F;pastila.nl&#x2F;?003d59f7&#x2F;15a4f09bfb4c44ca92082bd5e54d8b78" rel="nofollow noreferrer">https:&#x2F;&#x2F;pastila.nl&#x2F;?003d59f7&#x2F;15a4f09bfb4c44ca92082bd5e54d8b7...</a></div><br/></div></div><div id="36914124" class="c"><input type="checkbox" id="c-36914124" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910539">parent</a><span>|</span><a href="#36916037">prev</a><span>|</span><a href="#36912748">next</a><span>|</span><label class="collapse" for="c-36914124">[-]</label><label class="expand" for="c-36914124">[1 more]</label></div><br/><div class="children"><div class="content">It depends on your data. We ran comparisons on objects with lots of numbers and arrays (think GeoJSON) and messagepack came out way ahead. Of course, something like Arrow may have fared even better with its focus on columnar data, but we didn&#x27;t want to venture that far afield just yet.</div><br/></div></div><div id="36912748" class="c"><input type="checkbox" id="c-36912748" checked=""/><div class="controls bullet"><span class="by">c-cube</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910539">parent</a><span>|</span><a href="#36914124">prev</a><span>|</span><a href="#36911668">next</a><span>|</span><label class="collapse" for="c-36912748">[-]</label><label class="expand" for="c-36912748">[1 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t you compare JSON + gzip to msgpack + gzip? That&#x27;d be a more fair comparison.</div><br/></div></div><div id="36911668" class="c"><input type="checkbox" id="c-36911668" checked=""/><div class="controls bullet"><span class="by">coder543</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36910539">parent</a><span>|</span><a href="#36912748">prev</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36911668">[-]</label><label class="expand" for="c-36911668">[2 more]</label></div><br/><div class="children"><div class="content">I do not agree that JSON is faster.<p>Encoding JSON or MessagePack will be about the same speed, although I would expect MessagePack to be marginally faster from what I’ve seen over the years. It’s easy to encode data in most formats, compression excluded.<p>Parsing is the real problem with JSON, and no, it isn’t even close. MessagePack knows the length of every field, so it is extremely fast to parse, an advantage that grows rapidly when large strings are a common part of the data in question. I love the simple visual explanation of how MessagePack works here: <a href="https:&#x2F;&#x2F;msgpack.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;msgpack.org&#x2F;</a><p>Anyone who has written parsing code can instantly recognize what makes a format like this efficient to parse compared to JSON.<p>With some seriously wild SIMD JSON parsing libraries, you can get <i>closer</i> to the parsing performance of a format like MessagePack, but I think it is physically impossible for JSON to be faster. You simply have to read every byte of JSON one way or another, which takes time. You also don’t have any ability to pre-allocate for JSON unless you do two passes, which would be expensive to do too. You have no idea how many objects are in an array, you have no idea how long a string will be.<p>MessagePack objects are certainly smaller than JSON but larger than compressed JSON. Even compressed MessagePack objects are larger than the equivalent compressed JSON, in my experience, likely because the field length indicators add a randomness to the data that makes compression less effective.<p>For applications where you need to handle terabytes of data flowing through a pipeline every hour, MessagePack can be a huge win in terms of cost due to the increased CPU efficiency, and it’s a much smaller lift to switch to MessagePack from JSON than to switch to something statically typed like Protobuf or CapnProto, just due to how closely MessagePack matches JSON. (But, if you <i>can</i> switch to Protobuf or CapnProto, those should yield similar and perhaps even modestly better benefits.)<p>Compute costs are much higher than storage costs, so I would happily take a small size penalty if it reduced my CPU utilization by a large amount, which MessagePack easily does for applications that are very data-heavy. I’m sure there is at least one terribly slow implementation of MessagePack out there somewhere, but most of them seem quite fast compared to JSON.<p>Some random benchmarks in Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;shamaton&#x2F;msgpack#benchmark">https:&#x2F;&#x2F;github.com&#x2F;shamaton&#x2F;msgpack#benchmark</a><p>Also take note of the “ShamatonGen” results, which use codegen before compile time to do things even more efficiently for types known ahead of time, compared to the normal reflection-based implementation. The “Array” results are a weird version that isn’t strictly comparable, the encoding and decoding steps assume that the fields are in a fixed order, so the encoded data is just arrays of values, and no field names. It can be faster and more compact, but it’s not “normal” messagepack.<p>I’ve personally seen crazy differences in performance vs JSON.<p>If you’re not handling a minimum of terabytes of JSON per day, then the compute costs from JSON are probably irrelevant and not worth thinking too hard about, but there can be other benefits to switching away from JSON.</div><br/><div id="36914529" class="c"><input type="checkbox" id="c-36914529" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#36909472">root</a><span>|</span><a href="#36911668">parent</a><span>|</span><a href="#36911764">next</a><span>|</span><label class="collapse" for="c-36914529">[-]</label><label class="expand" for="c-36914529">[1 more]</label></div><br/><div class="children"><div class="content">Size savings depends I guess on the workload. That home page example gets larger gzip&#x27;d so raw msgpack is smaller. Another comment says their data was considerably smaller vs json.<p>Sometimes you can&#x27;t gzip for various reasons. There were per-message deflate bugs in Safari and Brave somewhat recently. Microsoft is obsessed with the decades old CRIME&#x2F;BREACH for some reason(I&#x27;ve never heard any other company or individual even mention them) so signalR still doesn&#x27;t have the compression option yet..</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36911764" class="c"><input type="checkbox" id="c-36911764" checked=""/><div class="controls bullet"><span class="by">nvarsj</span><span>|</span><a href="#36909472">parent</a><span>|</span><a href="#36909666">prev</a><span>|</span><a href="#36912244">next</a><span>|</span><label class="collapse" for="c-36911764">[-]</label><label class="expand" for="c-36911764">[1 more]</label></div><br/><div class="children"><div class="content">fbthrift is still alive and kicking.</div><br/></div></div></div></div><div id="36912244" class="c"><input type="checkbox" id="c-36912244" checked=""/><div class="controls bullet"><span class="by">unixhero</span><span>|</span><a href="#36909472">prev</a><span>|</span><a href="#36908941">next</a><span>|</span><label class="collapse" for="c-36912244">[-]</label><label class="expand" for="c-36912244">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations to kentonv and the team</div><br/></div></div><div id="36908941" class="c"><input type="checkbox" id="c-36908941" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36912244">prev</a><span>|</span><a href="#36910769">next</a><span>|</span><label class="collapse" for="c-36908941">[-]</label><label class="expand" for="c-36908941">[2 more]</label></div><br/><div class="children"><div class="content">Tell me about your uses of capn proto.</div><br/><div id="36911339" class="c"><input type="checkbox" id="c-36911339" checked=""/><div class="controls bullet"><span class="by">bkiran</span><span>|</span><a href="#36908941">parent</a><span>|</span><a href="#36910769">next</a><span>|</span><label class="collapse" for="c-36911339">[-]</label><label class="expand" for="c-36911339">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using Cap&#x27;N Proto in a message broker application(LcuidMQ) I&#x27;m building for serialization. It has allowed me to created client applications rather quickly. There are some quirks can be difficult to wrap your head around, but once you understand it is really solid.<p>There are some difference between the language libraries and documentation can be lacking around those language specific solutions. I&#x27;m hoping to add blog articles and or contribute back to the example of these repositories to help future users  who want to dabble.<p>Check out my repo here for how I use it across Rust and Python, with Golang coming soon: <a href="https:&#x2F;&#x2F;github.com&#x2F;lucidmq&#x2F;lucidmq">https:&#x2F;&#x2F;github.com&#x2F;lucidmq&#x2F;lucidmq</a></div><br/></div></div></div></div><div id="36910960" class="c"><input type="checkbox" id="c-36910960" checked=""/><div class="controls bullet"><span class="by">vicaya</span><span>|</span><a href="#36913809">prev</a><span>|</span><label class="collapse" for="c-36910960">[-]</label><label class="expand" for="c-36910960">[1 more]</label></div><br/><div class="children"><div class="content">Worker should really adopt Apache Arrow, which has a much bigger ecosystem.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow</a></div><br/></div></div></div></div></div></div></div></body></html>