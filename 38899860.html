<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704704462120" as="style"/><link rel="stylesheet" href="styles.css?v=1704704462120"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.kenanb.com/code/low-level/2024/01/06/encoding-diagram-attempt.html">Exploring x86-64 Instruction Encoding</a> <span class="domain">(<a href="https://blog.kenanb.com">blog.kenanb.com</a>)</span></div><div class="subtext"><span>kenanb</span> | <span>12 comments</span></div><br/><div><div id="38908523" class="c"><input type="checkbox" id="c-38908523" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#38907702">next</a><span>|</span><label class="collapse" for="c-38908523">[-]</label><label class="expand" for="c-38908523">[2 more]</label></div><br/><div class="children"><div class="content">This reminds me of some playing around I did with x86 instruction decoding. I&#x27;ve sort of come to a conclusion that both the assembly and the manual are lying to you a little bit about the actual instruction formats.<p>The basic form of an x86 instruction is as follows:<p>* The presence or absence of each of 5 &quot;legacy&quot; prefixes (0x66, 0x67, 0xf0, 0xf2, 0xf3). Supposedly, 0xf0, 0xf2, and 0xf3 can&#x27;t coexist (they&#x27;re all group 1), but if you look carefully at a few instructions, it turns out that there are some instructions which require you to specify two of them at the same time.<p>* The group 2 prefixes end up being a segment register specifier, although they got overloaded as branch hits for the branch instructions.<p>* If you use a REX prefix, it adds an extra bit to the opcode (REX.w). If you use a VEX prefix, it adds two extra bits (REX.w and VEX.l). EVEX adds five extra bits (REX.w, VEX.l + EVEX.l, EVEX.b, EVEX.z). Otherwise, everything they add is extra register bits, although some instructions may have differences if they use a &quot;modern&quot; prefix versus not.<p>* Opcode map. For VEX and EVEX, you specify this via a few bits in the prefix, but otherwise, you use 0x0f, 0x0f 0x38, or 0x0f 0x3a to specify.<p>* 1-byte opcode.<p>Combine all of these together, and you almost have every unique instruction. That&#x27;s roughly ~21 bits of opcode encoding (fewer due to holes and impossible encodings), and this will tell you what the instruction expects as its opcode form: whether it has a ModR&#x2F;M byte and how many subsequent immediate bytes it expects. The ModR&#x2F;M byte specifies a register and either a register or a memory location. It actually doesn&#x27;t take that long to iterate through every single x86 instruction!<p>However, there&#x27;s one last trick x86 plays: sometimes, the register of the ModR&#x2F;M byte is used to select between different instructions, particularly when you have an instruction that only takes memory instructions. So the instruction 0x0f 0x01 with r0 is a SGDT instruction, whereas the instruction 0x0f 0x01 with r3 is a LIDT instruction instead.</div><br/><div id="38908756" class="c"><input type="checkbox" id="c-38908756" checked=""/><div class="controls bullet"><span class="by">kenanb</span><span>|</span><a href="#38908523">parent</a><span>|</span><a href="#38907702">next</a><span>|</span><label class="collapse" for="c-38908756">[-]</label><label class="expand" for="c-38908756">[1 more]</label></div><br/><div class="children"><div class="content">Wow that&#x27;s a very interesting summary of the encoding of opcode itself. Thanks!<p>I find this part the most challenging. It is relatively easy to figure out the &quot;mapping between the assembly and instruction&quot; when you have both in front of you already, as I did in my posts.<p>But I would have difficulty translating from one to the other, because the opcode encoding is difficult. You can actually see me intentionally handwaving it in an earlier post: <a href="https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;04&#x2F;x86-insn-encoding.html#decoding-the-instruction" rel="nofollow">https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;04&#x2F;x86-insn-e...</a><p>Note for other people reading both my post and the comment above:<p>The terms <i>r0</i> and <i>r3</i> in the last paragraph corresponds to what I describe in my post as: The &quot;register code&quot; or &quot;opcode extension&quot; values stored in the &quot;ModR&#x2F;M.reg&quot; field. In this case, the values 0 and 3 are meant to be &quot;opcode extensions&quot;. You can see both instructions here: <a href="http:&#x2F;&#x2F;ref.x86asm.net&#x2F;coder64.html#x0F01" rel="nofollow">http:&#x2F;&#x2F;ref.x86asm.net&#x2F;coder64.html#x0F01</a> . The values 0 (for SGDT) and 3 (for LIDT) are shown in the column called &quot;o&quot;, which is defined as: &quot;Register&#x2F; Opcode Field&quot;</div><br/></div></div></div></div><div id="38907702" class="c"><input type="checkbox" id="c-38907702" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#38908523">prev</a><span>|</span><a href="#38907539">next</a><span>|</span><label class="collapse" for="c-38907702">[-]</label><label class="expand" for="c-38907702">[2 more]</label></div><br/><div class="children"><div class="content">Oh, cool. This is the first time I&#x27;ve encountered anyone else mentioning hand decompilation of x86-64 instructions. I spent some time doing that with small binaries a while back. The original motivation was SmithForth[0].<p>For those interested in this kind of thing, here are some useful resources I&#x27;ve stumbled upon:<p>- x86 Instruction and Opcode Reference: <a href="http:&#x2F;&#x2F;ref.x86asm.net&#x2F;" rel="nofollow">http:&#x2F;&#x2F;ref.x86asm.net&#x2F;</a><p>Probably the best reference for navigating opcodes. It&#x27;s extreme detail gives a good sense of x86 ISA nuances.<p>- Intel XED: <a href="https:&#x2F;&#x2F;intelxed.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;intelxed.github.io&#x2F;</a><p>An library and CLI tool for encoding and decoding instructions between hex and their mnemonics. This tool gave me a fun side quest, sending upstream a patch to make the build reproducible.<p>- Intel Software Developer Manuals<p>It takes a little bit of time to get into the groove with these, but the first chapters of each volume contain excellent high-level explanations of the different moving pieces in modern x86 chips.<p>- Agner Fog&#x27;s optimization resources: <a href="https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;</a><p>Excellent resource for going beyond the ISA and understanding microarchitectural details.<p>Anyway, I&#x27;m still quite green, but if anyone&#x27;s interested in chatting about this kind of thing, feel free to ping me. Email should be in my profile description.<p>[0]:<a href="https:&#x2F;&#x2F;dacvs.neocities.org&#x2F;SF&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dacvs.neocities.org&#x2F;SF&#x2F;</a></div><br/><div id="38908417" class="c"><input type="checkbox" id="c-38908417" checked=""/><div class="controls bullet"><span class="by">kenanb</span><span>|</span><a href="#38907702">parent</a><span>|</span><a href="#38907539">next</a><span>|</span><label class="collapse" for="c-38908417">[-]</label><label class="expand" for="c-38908417">[1 more]</label></div><br/><div class="children"><div class="content"><i>Author here.</i> Thanks a lot for the links!<p>I was actually collecting the relevant resources in another post I published yesterday: <a href="https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-encoding-resources.html" rel="nofollow">https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-e...</a><p><i>Intel XED</i> was missing, so I just added that one as an update at the end, quoting your description.<p>I had a look at Intel XED earlier. I found it interesting but had difficulty navigating the sources. I will give it another try. Thanks!<p>Re SmithForth: I was just watching through the &quot;Handmade Linux x86 Executables&quot;[0] videos from the same person. Definitely super interesting series of work.<p>[0]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLZCIHSjpQ12woLj0sjsnqDH8yVuXwTy3p" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLZCIHSjpQ12woLj0sjsnq...</a></div><br/></div></div></div></div><div id="38907539" class="c"><input type="checkbox" id="c-38907539" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38907702">prev</a><span>|</span><a href="#38908648">next</a><span>|</span><label class="collapse" for="c-38907539">[-]</label><label class="expand" for="c-38907539">[3 more]</label></div><br/><div class="children"><div class="content">Understanding x86 instruction encoding is far better done in octal --- you can memorise most of the instruction set this way: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30409100">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30409100</a><p>Of course, IMO the 64-bit extension by AMD that followed it was far messier.</div><br/><div id="38908477" class="c"><input type="checkbox" id="c-38908477" checked=""/><div class="controls bullet"><span class="by">kenanb</span><span>|</span><a href="#38907539">parent</a><span>|</span><a href="#38908648">next</a><span>|</span><label class="collapse" for="c-38908477">[-]</label><label class="expand" for="c-38908477">[2 more]</label></div><br/><div class="children"><div class="content"><i>Author here.</i> Thanks for the link! I added the &quot;x86 Is an Octal Machine&quot; link, quoting your comment, in the end of my &quot;encoding resources&quot; post here: <a href="https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-encoding-resources.html" rel="nofollow">https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-e...</a><p>I have also been referencing that document since I started writing on the topic: <a href="https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;04&#x2F;x86-insn-encoding.html#octal-system" rel="nofollow">https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;04&#x2F;x86-insn-e...</a><p>It really helps reasoning about the encoding, but as you pointed out, x64 extension makes it challenging. I basically end up switching between octal and hex, depending on the byte, during the process.</div><br/><div id="38908981" class="c"><input type="checkbox" id="c-38908981" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38907539">root</a><span>|</span><a href="#38908477">parent</a><span>|</span><a href="#38908648">next</a><span>|</span><label class="collapse" for="c-38908981">[-]</label><label class="expand" for="c-38908981">[1 more]</label></div><br/><div class="children"><div class="content">I suspect it&#x27;s similar to the 6502, picking the right arrangement and grouping of bits will make the patterns more apparent. The 6502 has a much more limited set of instructions, but here&#x27;s an example of changing the arrangement [1].<p>[1] <a href="https:&#x2F;&#x2F;www.nesdev.org&#x2F;wiki&#x2F;CPU_unofficial_opcodes" rel="nofollow">https:&#x2F;&#x2F;www.nesdev.org&#x2F;wiki&#x2F;CPU_unofficial_opcodes</a></div><br/></div></div></div></div></div></div><div id="38908648" class="c"><input type="checkbox" id="c-38908648" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#38907539">prev</a><span>|</span><a href="#38909031">next</a><span>|</span><label class="collapse" for="c-38908648">[-]</label><label class="expand" for="c-38908648">[2 more]</label></div><br/><div class="children"><div class="content">Neat post!<p>I wrote a little bit about this too because my assembler had a bug: <a href="https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;compiling-a-lisp-10&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;compiling-a-lisp-10&#x2F;</a></div><br/><div id="38908869" class="c"><input type="checkbox" id="c-38908869" checked=""/><div class="controls bullet"><span class="by">kenanb</span><span>|</span><a href="#38908648">parent</a><span>|</span><a href="#38909031">next</a><span>|</span><label class="collapse" for="c-38908869">[-]</label><label class="expand" for="c-38908869">[1 more]</label></div><br/><div class="children"><div class="content">This looks awesome! I really like that you have nicely organized pointers back to the reference document for each section along with diagrams!<p>It is also cool that this is written for the actual use-case of encoding instructions for a compiler. Being a lisper myself, I will probably start reading this series from scratch.<p>I also found a youtube video called &quot;X86_64 Instruction Encoding - Compiler Programming Ep4&quot;[0] which I added to my encoding resources[1] post.<p>I am hoping to add your link there as well, once I read through it.<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5FCgOFbKHYU" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5FCgOFbKHYU</a><p>[1] <a href="https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-encoding-resources.html" rel="nofollow">https:&#x2F;&#x2F;blog.kenanb.com&#x2F;code&#x2F;low-level&#x2F;2024&#x2F;01&#x2F;07&#x2F;x86-insn-e...</a></div><br/></div></div></div></div><div id="38909031" class="c"><input type="checkbox" id="c-38909031" checked=""/><div class="controls bullet"><span class="by">myrtus</span><span>|</span><a href="#38908648">prev</a><span>|</span><label class="collapse" for="c-38909031">[-]</label><label class="expand" for="c-38909031">[2 more]</label></div><br/><div class="children"><div class="content">You can visualize how instructions are encoded with zydisinfo. Pass in your architecture and the hex bytes of the instructions and it’ll show all relevant info<p><a href="https:&#x2F;&#x2F;github.com&#x2F;zyantific&#x2F;zydis&#x2F;tree&#x2F;master">https:&#x2F;&#x2F;github.com&#x2F;zyantific&#x2F;zydis&#x2F;tree&#x2F;master</a><p><a href="https:&#x2F;&#x2F;www.hexacorn.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;27&#x2F;zydisinfo-the-disassembler-that-breaks-the-code-twice&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hexacorn.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;27&#x2F;zydisinfo-the-disas...</a></div><br/><div id="38909117" class="c"><input type="checkbox" id="c-38909117" checked=""/><div class="controls bullet"><span class="by">kenanb</span><span>|</span><a href="#38909031">parent</a><span>|</span><label class="collapse" for="c-38909117">[-]</label><label class="expand" for="c-38909117">[1 more]</label></div><br/><div class="children"><div class="content">Looks super cool! This tells me:<p>- The general layout of the instruction (segments).<p>- The type and size of operands.<p>- Where, in the instruction, each operand is encoded.<p>I will probably use this a lot. Thanks!</div><br/></div></div></div></div></div></div></div></div></div></body></html>