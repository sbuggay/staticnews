<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685696458384" as="style"/><link rel="stylesheet" href="styles.css?v=1685696458384"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://elliottslaughter.com/2022/12/lisp">What are the enduring innovations of Lisp? (2022)</a> <span class="domain">(<a href="https://elliottslaughter.com">elliottslaughter.com</a>)</span></div><div class="subtext"><span>eslaught</span> | <span>141 comments</span></div><br/><div><div id="36156167" class="c"><input type="checkbox" id="c-36156167" checked=""/><div class="controls bullet"><span class="by">netbioserror</span><span>|</span><a href="#36160232">next</a><span>|</span><label class="collapse" for="c-36156167">[-]</label><label class="expand" for="c-36156167">[29 more]</label></div><br/><div class="children"><div class="content">Homoiconicity wins in my book. Clojure is the best proof I have of this: What mattered was not the linked list or the cons cell. What mattered was that all code was just nested calls to functions and macros with the SAME general form: (function arg1 arg2 arg3 ...)<p>Expression-based programming using this core form is trivially easy, and makes immutable data structures downright pleasurable to work with. It also makes code generation easy, though I&#x27;ve never taken full advantage of it; even so, a DSL made of runtime functions is not only possible, but a natural extension of anything you&#x27;re already doing. Backing those homoiconic expression forms with typical high-performance data structures like arrays and hash maps, as Clojure and Janet do, is a winning formula for making complex tasks simple.<p>All the patterns of yesteryear for modeling problems begin to look quaint when your program eventually just becomes a pyramid of expression calls, with `main` at the top and database hits at the bottom. The organization of the stuff in between really just becomes a question of standardizing function signatures and organizing modules so humans can easily navigate them.</div><br/><div id="36162822" class="c"><input type="checkbox" id="c-36162822" checked=""/><div class="controls bullet"><span class="by">kaliszad</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36158974">next</a><span>|</span><label class="collapse" for="c-36162822">[-]</label><label class="expand" for="c-36162822">[1 more]</label></div><br/><div class="children"><div class="content">In case of Clojure I would argue it is the combination of very consistent - simple some would say ;-) - syntax and stability in the language that partially stems from the simplicity and, as you mention, at the same time extensibility of Lisp&#x27;s approach &quot;function first, arguments later&quot; and homoiconicity. However, dynamic typing, immutable data structures by default, software transactional memory built into the language itself, stellar interop with Java (or JavaScript in case of ClojureScript) and the REPL workflow that eases things like hot-code reloading are all major contributors and reasons, why Clojure(Script) users are usually quite enthusiastic about the language family.<p>Don&#x27;t get me wrong, Clojure does have some warts inherited from the approach of the host platform. E.g. I think its math could do nil pruning by default with e.g. unchecked-add and similar skipping nil pruning and overflow checking (for best performance in some tight scenarios). ClojureScript basically does nil pruning already.<p>As a side note, I would love if ClojureCLR picked up steam a lot more. I heard .NET is not as dynamic as the JVM which makes these things harder but if ClojureCLR would be on the same level as at least ClojureScript in terms of support and tooling, the Clojure family of languages would be really hard to beat for any kind of business application development. With ClojureDart, Babashka, NBB and to some degree Clojerl, Joker, Jank and others it seems the family extends much beyond the original &quot;business applications&quot; area into scripting, embedded and to some degree HPC or network programming as well. I guess we will see where it catches on.</div><br/></div></div><div id="36158974" class="c"><input type="checkbox" id="c-36158974" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36162822">prev</a><span>|</span><a href="#36156255">next</a><span>|</span><label class="collapse" for="c-36158974">[-]</label><label class="expand" for="c-36158974">[3 more]</label></div><br/><div class="children"><div class="content">Embedded in this response is a consideration for how programming languages handle data. In Java, if you have a config file, does that file use Java syntax? No. What is that Java file written in? Likely XML. Can you write XML literals in Java? No. Wouldn&#x27;t it be nice to:<p><pre><code>    XMLElement el = &lt;html&gt;&lt;body&gt;Hello World!&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;;
</code></pre>
In JavaScript, we have probably the closest to Lisp in this regard with JSON. You can define JSON literals in your JavaScript code; config files like package.json are written using this object notation. If you want to work with, say XML, there are libraries to convert your XML to JSON and you can take it from there.<p>But, JSON is limited. How do you define dates for your datatypes? Probably use a string. In Lisp, you can use a string or have some (date year month day) form. How do you represent rational numbers? Maybe you&#x27;ll risk using floating point or you&#x27;ll just go with a string. Lisps have rationals built in or you could roll your own with (rational numerator denominator). So your JSON<p><pre><code>    {
      &#x27;name&#x27;: &#x27;John Doe&#x27;,
      &#x27;birth-date&#x27;: &#x27;1970-01-01&#x27;,
      &#x27;account-balance&#x27;: &#x27;1000.01&#x27;
    }
</code></pre>
can become<p><pre><code>    (user #:name &quot;John Doe&quot; #:birth-date (date 1970 1 1) #:account-balance 100001&#x2F;100)
</code></pre>
When Lispers need to interact with JSON, they convert it to S-expressions. When Lispers need to interact with XML, they convert it to S-expressions. Wouldn&#x27;t it be nice if the other languages had syntaxes that made you want to define data using that language&#x27;s syntax and not JSON or XML?</div><br/><div id="36160263" class="c"><input type="checkbox" id="c-36160263" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36158974">parent</a><span>|</span><a href="#36156255">next</a><span>|</span><label class="collapse" for="c-36160263">[-]</label><label class="expand" for="c-36160263">[2 more]</label></div><br/><div class="children"><div class="content">Visual Basic .NET actually does have XML literals [1] - one of the few reasons to use it!<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;visual-basic&#x2F;programming-guide&#x2F;language-features&#x2F;xml&#x2F;xml-literals-overview#simple-literals" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;visual-basic&#x2F;progra...</a></div><br/><div id="36161682" class="c"><input type="checkbox" id="c-36161682" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36160263">parent</a><span>|</span><a href="#36156255">next</a><span>|</span><label class="collapse" for="c-36161682">[-]</label><label class="expand" for="c-36161682">[1 more]</label></div><br/><div class="children"><div class="content">Scala also had it, but seems they replaced it in Scala 3 with a more general concept[1] as everyone thought it was a bad idea to special case XML (why XML, not JSON or something else?).<p>[1] <a href="https:&#x2F;&#x2F;docs.scala-lang.org&#x2F;scala3&#x2F;reference&#x2F;dropped-features&#x2F;xml.html" rel="nofollow">https:&#x2F;&#x2F;docs.scala-lang.org&#x2F;scala3&#x2F;reference&#x2F;dropped-feature...</a></div><br/></div></div></div></div></div></div><div id="36156255" class="c"><input type="checkbox" id="c-36156255" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36158974">prev</a><span>|</span><a href="#36159437">next</a><span>|</span><label class="collapse" for="c-36156255">[-]</label><label class="expand" for="c-36156255">[2 more]</label></div><br/><div class="children"><div class="content">Very much agree. It also gets you some really useful structural editing capabilities as a side-effect. I can shiffle code around so easily and blindly by just telling it to move an expression right or left, or adjust parens in or out. I also don&#x27;t have to learn new weird syntax every time the language wants to do something kinda new. So many new Clojure &quot;language&quot; features are actually just libraries which is awesome. Tooling just keeps working and others can provide competing implementations. For instance clojure.spec</div><br/><div id="36156657" class="c"><input type="checkbox" id="c-36156657" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36156255">parent</a><span>|</span><a href="#36159437">next</a><span>|</span><label class="collapse" for="c-36156657">[-]</label><label class="expand" for="c-36156657">[1 more]</label></div><br/><div class="children"><div class="content">This is the best part. Especially with JavaScript with so much difference in runtime and the importance of babel. Even the `loop` DSL can be broken down to basic lisp structure. The flexibility of the language, by allowing itself to be altered, is the most important aspect for me. After completing a first version of a solution, I often find my mind wandering searching for a cleaner, more understandable version of the code. And this is usually done by molding the language to the problem domain.<p>Something like React in JavaScript exemplifies this. JSX was added for an easier developer experience, but the issue itself is created by the separation of code and data in the language. And CLOS would be perfect for the Component model.</div><br/></div></div></div></div><div id="36159437" class="c"><input type="checkbox" id="c-36159437" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36156255">prev</a><span>|</span><a href="#36156702">next</a><span>|</span><label class="collapse" for="c-36159437">[-]</label><label class="expand" for="c-36159437">[1 more]</label></div><br/><div class="children"><div class="content">Although if you want to be maximally pedantic about it, homoiconicity you actually get for free in raw machine code. Though Lisp certainly &quot;rediscovered&quot; it in an abstract language(though Church&#x27;s lambda calculus is also homoiconic, and directly inspired much of Lisp so I suppose he deserved some credit too).<p>I sometimes ponder about whether we&#x27;d be able to recognise any programming languages from alien civilisations. And I usually come to the conclusion that it would have to be either a lisp or a forth, because at their core they&#x27;re so dead simple it&#x27;s hard to imagine not inventing them by accident at some point. The fact that Lisp was invented so incredibly early on in computing history, and at least partially by accident, supports this hypothesis.</div><br/></div></div><div id="36156702" class="c"><input type="checkbox" id="c-36156702" checked=""/><div class="controls bullet"><span class="by">JamesLeonis</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36159437">prev</a><span>|</span><a href="#36161157">next</a><span>|</span><label class="collapse" for="c-36156702">[-]</label><label class="expand" for="c-36156702">[8 more]</label></div><br/><div class="children"><div class="content">&gt; It also makes code generation easy, though I&#x27;ve never taken full advantage of it;<p>I bet you have because Hiccup is an HTML DSL! Compojure is likewise a DSL for building Ring handlers based on HTTP request types.<p>But to your larger point, I also find I don&#x27;t reach for macros at all. Looking carefully, I think this is because we have first-class syntax for vectors and maps, and those containers are <i>very</i> flexible about the type of their contents. Combined with the Seq abstraction and a well equipped standard library most Clojure code I write is macro-free.</div><br/><div id="36157947" class="c"><input type="checkbox" id="c-36157947" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36156702">parent</a><span>|</span><a href="#36157297">next</a><span>|</span><label class="collapse" for="c-36157947">[-]</label><label class="expand" for="c-36157947">[2 more]</label></div><br/><div class="children"><div class="content">&gt; most Clojure code I write is macro-free.<p>Conceptually, most forms that are not on the form (fn args...) are macros. You got like cond, lambda and label forms, that are not macros. I don&#x27;t think Clojure technically has label forms though.</div><br/><div id="36160313" class="c"><input type="checkbox" id="c-36160313" checked=""/><div class="controls bullet"><span class="by">JamesLeonis</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36157947">parent</a><span>|</span><a href="#36157297">next</a><span>|</span><label class="collapse" for="c-36160313">[-]</label><label class="expand" for="c-36160313">[1 more]</label></div><br/><div class="children"><div class="content">You are correct. I should have clarified. I meant I don&#x27;t write many custom macros myself.</div><br/></div></div></div></div><div id="36157297" class="c"><input type="checkbox" id="c-36157297" checked=""/><div class="controls bullet"><span class="by">maxfurman</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36156702">parent</a><span>|</span><a href="#36157947">prev</a><span>|</span><a href="#36161157">next</a><span>|</span><label class="collapse" for="c-36157297">[-]</label><label class="expand" for="c-36157297">[5 more]</label></div><br/><div class="children"><div class="content">Perhaps I&#x27;m being pedantic, but `if` and many other control-flow constructs are implemented as macros in Clojure. So you probably use macros a lot!</div><br/><div id="36160767" class="c"><input type="checkbox" id="c-36160767" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36157297">parent</a><span>|</span><a href="#36157622">prev</a><span>|</span><a href="#36157480">next</a><span>|</span><label class="collapse" for="c-36160767">[-]</label><label class="expand" for="c-36160767">[1 more]</label></div><br/><div class="children"><div class="content">In CL, IF is a special form and COND is a macro.</div><br/></div></div><div id="36157480" class="c"><input type="checkbox" id="c-36157480" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36157297">parent</a><span>|</span><a href="#36160767">prev</a><span>|</span><a href="#36161157">next</a><span>|</span><label class="collapse" for="c-36157480">[-]</label><label class="expand" for="c-36157480">[2 more]</label></div><br/><div class="children"><div class="content">So everyone uses C.</div><br/><div id="36159430" class="c"><input type="checkbox" id="c-36159430" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36157480">parent</a><span>|</span><a href="#36161157">next</a><span>|</span><label class="collapse" for="c-36159430">[-]</label><label class="expand" for="c-36159430">[1 more]</label></div><br/><div class="children"><div class="content">SBCL is self-hosting. It feels like a bit of a stretch to say syscalls are macros, but if you really want to torture language that way then sure because the kernel is mostly C.</div><br/></div></div></div></div></div></div></div></div><div id="36161157" class="c"><input type="checkbox" id="c-36161157" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36156702">prev</a><span>|</span><a href="#36161376">next</a><span>|</span><label class="collapse" for="c-36161157">[-]</label><label class="expand" for="c-36161157">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The organization of the stuff in between really just becomes a question of standardizing function signatures and organizing modules so humans can easily navigate them.<p>That’s one impressive load-bearing “just” you have in there..</div><br/></div></div><div id="36161376" class="c"><input type="checkbox" id="c-36161376" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36161157">prev</a><span>|</span><a href="#36156914">next</a><span>|</span><label class="collapse" for="c-36161376">[-]</label><label class="expand" for="c-36161376">[3 more]</label></div><br/><div class="children"><div class="content">&gt; functions and macros with the SAME general form: (function arg1 arg2 arg3 ...)<p>Macros don&#x27;t have this general form in Lisp. macros just have a symbol in the prefix form, but the rest enclosed objects are not a simple list of args. The enclosed forms are arbitrary and the interpretation (parsing, transformation, ...) is done by the macro.<p>These can be valid macro forms:<p><pre><code>   (infix c := a + b )

   (rule :if   (a &lt; c and temperature &gt; 20)
         :then set climate-control to cooling)</code></pre></div><br/><div id="36161467" class="c"><input type="checkbox" id="c-36161467" checked=""/><div class="controls bullet"><span class="by">eurleif</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36161376">parent</a><span>|</span><a href="#36156914">next</a><span>|</span><label class="collapse" for="c-36161467">[-]</label><label class="expand" for="c-36161467">[2 more]</label></div><br/><div class="children"><div class="content">But those <i>are</i> lists of args. The macros happens to be processing the lists in a non-linear way, but they&#x27;re still just lists.</div><br/><div id="36161611" class="c"><input type="checkbox" id="c-36161611" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36161467">parent</a><span>|</span><a href="#36156914">next</a><span>|</span><label class="collapse" for="c-36161611">[-]</label><label class="expand" for="c-36161611">[1 more]</label></div><br/><div class="children"><div class="content">Most people assume that args are restricted to Lisp syntax and that args are evaluated, like in function calls. But inside a macro form this is not the case: the macro can implement a whole new syntax and semantic -&gt; then to say the enclosed items are &#x27;args&#x27; is misleading: it&#x27;s source code in a new sublanguage with a different syntax&#x2F;semantics. Technically the macro gets called with arguments, but only as part of the process of code transformation. For the user there can be a different syntax and semantics. The enclosed code then may have a different syntax where the (operator . args) syntax is extended or no longer used.<p>That also means that the simple (foo . args) pattern is now no longer valid inside the macro form and analyzing the source code of a macro form can be arbitrarily complex.<p>&gt; The macros happens to be processing the lists in a non-linear way<p>Macros are code transformers. They get code as lists and return new code as a list. This generated code then is evaluated.<p>Different from functions, macros are not processing normal arguments and returning an evaluation result, but they are code transformers. The resulting transformed code is then run and it returns a value.<p>Thus we have two (interleaved) phases of execution, instead of one:<p>* the code transformation phase<p>* the evaluation of the code</div><br/></div></div></div></div></div></div><div id="36156914" class="c"><input type="checkbox" id="c-36156914" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36161376">prev</a><span>|</span><a href="#36159795">next</a><span>|</span><label class="collapse" for="c-36156914">[-]</label><label class="expand" for="c-36156914">[3 more]</label></div><br/><div class="children"><div class="content">No better example of this than Racket.<p>Function application itself is an overridable function. (f 1 2 3) compiles to something like (#%app f 1 2 3). <i>And you can hook into that</i>.<p>Runtime type checking, stack traces, debuggers..</div><br/><div id="36157134" class="c"><input type="checkbox" id="c-36157134" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36156914">parent</a><span>|</span><a href="#36159795">next</a><span>|</span><label class="collapse" for="c-36157134">[-]</label><label class="expand" for="c-36157134">[2 more]</label></div><br/><div class="children"><div class="content">You used to be able to do fun stuff like that in clojure but it ended up being axed in the name of performance.<p>(Well, I guess you still can, but the standard library is off limits now basically.)</div><br/><div id="36159743" class="c"><input type="checkbox" id="c-36159743" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36157134">parent</a><span>|</span><a href="#36159795">next</a><span>|</span><label class="collapse" for="c-36159743">[-]</label><label class="expand" for="c-36159743">[1 more]</label></div><br/><div class="children"><div class="content">In most cases, the new definition of #%app is a small wrapper around the standard one, with some special case. If the new definition is small enough, the Racket compiler can inline it and hopefully detect that it&#x27;s the standard case and you get the same speed at the run time.<p>In some cases, it may be useful to use a macro to &quot;force&quot; the inlining, but it may increase the total size of the code.<p>There are a few languages implemented in Racket that do this, <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rackjure&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rackjure&#x2F;index.html</a> <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;lua-manual@lua-lang&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;lua-manual@lua-lang&#x2F;index.html</a> that redefine the #%app and ITRC in most case get the fast application after the compilation.<p>In any case, if someone has a similar project with a custom #%app that is too slow, hey can ask using github or discourse and I(we)&#x27;ll try to help. In some case it&#x27;s impossible, but in other case some tweaks make the redefinition of #%app more optimizer friendly.</div><br/></div></div></div></div></div></div><div id="36159795" class="c"><input type="checkbox" id="c-36159795" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36156914">prev</a><span>|</span><a href="#36156527">next</a><span>|</span><label class="collapse" for="c-36159795">[-]</label><label class="expand" for="c-36159795">[3 more]</label></div><br/><div class="children"><div class="content">&gt; All the patterns of yesteryear for modeling problems begin to look quaint when your program eventually just becomes a pyramid of expression calls, with `main` at the top and database hits at the bottom. The organization of the stuff in between really just becomes a question of standardizing function signatures and organizing modules so humans can easily navigate them.<p>You don&#x27;t need homoiconicity for that; in fact expressions tend to be easier to write in a language that&#x27;s slightly non-homoiconic. Even Lisp or TCL fans tend to use a macro or similar to embed mathematical expressions, because regular infix mathematics is significantly more readable than Polish notation.<p>Having a good way to write data literals is important, and the lack of it is a big part of why Algol-family languages are so awful - C&#x2F;C++&#x2F;Java&#x2F;etc. code ends up being stringly typed because it&#x27;s easy to write literals for strings and a bunch of random number formats, and cumbersome to write literals of anything else. But that doesn&#x27;t mean your data syntax has to be exactly the same as your code syntax; some similarity is helpful, but the benefits of making your code look exactly like the AST of your code are pretty marginal.</div><br/><div id="36162440" class="c"><input type="checkbox" id="c-36162440" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36159795">parent</a><span>|</span><a href="#36160155">next</a><span>|</span><label class="collapse" for="c-36162440">[-]</label><label class="expand" for="c-36162440">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because regular infix mathematics is significantly more readable than Polish notation<p>I agree but maybe this is simply the result of our math education</div><br/></div></div><div id="36160155" class="c"><input type="checkbox" id="c-36160155" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#36156167">root</a><span>|</span><a href="#36159795">parent</a><span>|</span><a href="#36162440">prev</a><span>|</span><a href="#36156527">next</a><span>|</span><label class="collapse" for="c-36160155">[-]</label><label class="expand" for="c-36160155">[1 more]</label></div><br/><div class="children"><div class="content">Expressing data and instance declarations in the same syntax you express code and class definitions is an essential feature that enables &quot;Instance First Development&quot;, and the &quot;Instance Substitution Principal&quot;, as supported by OpenLaszlo, and described by Oliver Steele. And throwing declarative constraint based programming into that mix is really synergistically powerful and expressive.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21841054" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21841054</a><p>DonHopkins on Dec 20, 2019 | root | parent | next [–]<p>My remark was just an old Java joke I repurposed for Ant!<p>&quot;Java is a DSL for taking large XML files and converting them to stack traces.&quot; -Andrew Back<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;eaqgk&#x2F;java_is_a_dsl_for_taking_large_xml_files_and&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;eaqgk&#x2F;java_is_...</a><p>But in all seriousness:<p>OpenLaszlo used XML with embedded JavaScript in a way that let you extend XML by defining your own tags in XML+JavaScript. I&#x27;ve done a lot of work with it, and once you make your peace with XML (which seemed like a prudent thing to do at the time), it&#x27;s a really productive enjoyable way to program! But that&#x27;s more thanks to the design of OpenLaszlo itself, rather than XML.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OpenLaszlo" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OpenLaszlo</a><p>OpenLaszlo (which was released in 2001) inspired Adobe Flex (which was released in 2004), but Flex missed the point of several of the most important aspects of OpenLaszlo (first and foremost being cross platform and not locking you into Flash, which was the entire point of Flex, but also the declarative constraints and &quot;Instance First Development&quot; and the &quot;Instance Substitution Principal&quot;, as defined by Oliver Steele).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Apache_Flex" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Apache_Flex</a><p><a href="https:&#x2F;&#x2F;blog.osteele.com&#x2F;2004&#x2F;03&#x2F;classes-and-prototypes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.osteele.com&#x2F;2004&#x2F;03&#x2F;classes-and-prototypes&#x2F;</a><p>The mantle of constraint based programming (but not Instance First Development) has been recently taken up by the &quot;Reactive Programming&quot; craze (which is great, but would be better with a more homoiconic language that supported Instance First Development and the Instance Substitution Principle, which are different but complementary features with a lot of synergy). The term &quot;Reactive Programming&quot; describes a popular old idea: what spreadsheets had been doing for decades.<p>OpenLaszlo and Garnet (a research user interface system written by Brad Myers at CMU in Common Lisp) were exploring applying automatic constraints to user interface programming. Garnet started in the early 1990&#x27;s. Before that, Ivan Sutherland&#x27;s Sketchpad explored constraints in 1963, and inspired the Visual Geometry Project in the mid 1980&#x27;s and The Geometer&#x27;s Sketchpad in 1995.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reactive_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reactive_programming</a><p><a href="http:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;afs&#x2F;cs&#x2F;project&#x2F;garnet&#x2F;www&#x2F;garnet-home.html" rel="nofollow">http:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;afs&#x2F;cs&#x2F;project&#x2F;garnet&#x2F;www&#x2F;garnet-home....</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sketchpad" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sketchpad</a><p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160303205845&#x2F;http:&#x2F;&#x2F;math.coe.uga.edu&#x2F;TME&#x2F;Issues&#x2F;v10n2&#x2F;4scher.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160303205845&#x2F;http:&#x2F;&#x2F;math.coe.u...</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Geometer%27s_Sketchpad" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Geometer%27s_Sketchpad</a><p>I&#x27;ve written more about OpenLaszlo and Garnet:<p>What is OpenLaszlo, and what&#x27;s it good for?<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160312145555&#x2F;http:&#x2F;&#x2F;donhopkins.com&#x2F;drupal&#x2F;node&#x2F;124" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160312145555&#x2F;http:&#x2F;&#x2F;donhopkins...</a><p>&gt;Declarative Programming: Declarative programming is an elegant way of writing code that describes what to do, instead of how to do it. OpenLaszlo supports declarative programming in many ways: using XML to declare JavaScript classes, create object instances, configure them with automatic constraints, and bind them to XML datasets. Declarative programming dovetails and synergizes with other important OpenLaszlo techniques including objects, prototypes, events, constraints, data binding and instance first development.<p>Constraints and Prototypes in Garnet and Laszlo<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160405015129&#x2F;http:&#x2F;&#x2F;www.donhopkins.com&#x2F;drupal&#x2F;node&#x2F;69" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160405015129&#x2F;http:&#x2F;&#x2F;www.donhop...</a><p>&gt;Garnet is an advanced user interface development environment written in Common Lisp, developed by Brad Meyers (the author of the article). I worked for Brad on the Garnet project at the CMU CS department back in 1992-3.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17360883" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17360883</a><p>[...]</div><br/></div></div></div></div><div id="36156527" class="c"><input type="checkbox" id="c-36156527" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36159795">prev</a><span>|</span><a href="#36159999">next</a><span>|</span><label class="collapse" for="c-36156527">[-]</label><label class="expand" for="c-36156527">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think this is pretty much the only thing that still matters as an advantage: explicitly writing the source code as a tree, where the left part of the leaf specifies how to interpret the right part. Makes transformations pretty straightforward. Anything else is just window dressing at this point.<p>Too many people will end up using it to write horrible DSLs but it&#x27;s the spider man thing I guess. (Please, if you think your problem is best solved by a DSL, reconsider.)</div><br/></div></div><div id="36159999" class="c"><input type="checkbox" id="c-36159999" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36156527">prev</a><span>|</span><a href="#36156194">next</a><span>|</span><label class="collapse" for="c-36159999">[-]</label><label class="expand" for="c-36159999">[1 more]</label></div><br/><div class="children"><div class="content">PostScript is as truly homoiconic and polymorphic and interactive as Lisp.<p>And by truly homoiconic I mean not trivially and uselessly homoiconic like TCL, where &quot;everything is a string&quot;.<p>And at the same time it&#x27;s &quot;JSONic&quot; in the sense that it supports the full range of JSON data types, and is polymorphic in the sense that objects (as opposed to variables, arrays elements, and dict slots) have type and can contain objects of different types (unlike Forth, which is untyped, and is also commonly compared to PostScript because they&#x27;re both stack based).<p>But of course PostScript was designed decades before JSON was a thing. However, the point is that Lisp S-Expressions don&#x27;t directly support polymorphic dictionaries, but PostScript (and JavaScript&#x2F;JSON, and Python) do.<p>The PostScript-based NeWS window system:<p>1) Used PostScript code instead of JavaScript
for programming.<p>2) Used PostScript graphics instead of DHTML and CSS
for rendering.<p>3) Used PostScript data instead of XML and JSON
for data representation.<p>And PostScript (and thus NeWS) also has an interactive REPL like Lisp, to support live and exploratory programming. Imagine being able to telnet to an X11 server and create windows and draw on them interactively!<p>PostScript is not only homoiconic, but also point-free (or &quot;tacit&quot;), like Forth!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tacit_programming#Stack-based" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tacit_programming#Stack-based</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Talk%3AHomoiconicity#PostScript_is_homoiconic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Talk%3AHomoiconicity#PostScrip...</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18317280" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18317280</a><p>&gt;The beauty of your functional approach is that you&#x27;re using PostScript code as PostScript data, thanks to the fact that PostScript is fully homoiconic, just like Lisp! So it&#x27;s excellent for defining and processing domain specific languages, and it&#x27;s effectively like a stack based, point free or &quot;tacic,&quot; dynamically bound, object oriented Lisp!<p>The fact that PostScript code IS PostScript data, without any intermediate AST representation or reflection API, means that a PostScript data structure editor is also a code editor.<p>PostScript&#x27;s homoiconicity and interactivity (plus the fact that PostScript is great at drawing scalable text and graphics) makes it easy to make a visual programming language and debugger interface for PostScript, with a graphical direct manipulation REPL loop that supports &quot;direct stack manipulation&quot; by dragging objects on and off the stack, and editing code and data by drag-and-drop and cut-and-paste.<p>PSIBER Space Deck Demo<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iuC_DDgQmsM">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iuC_DDgQmsM</a><p>&gt;Demo of the NeWS PSIBER Space Deck. Research performed under the direction of Mark Weiser and Ben Shneiderman. Developed and documented thanks to the support of John Gilmore and Julia Menapace. Developed and demonstrated by Don Hopkins.
Described in &quot;The Shape of PSIBER Space: PostScript Interactive Bug Eradication Routines&quot;.<p>The Shape of PSIBER Space: PostScript Interactive Bug Eradication Routines — October 1989<p><a href="https:&#x2F;&#x2F;donhopkins.medium.com&#x2F;the-shape-of-psiber-space-october-1989-19e2dfa4d91e" rel="nofollow">https:&#x2F;&#x2F;donhopkins.medium.com&#x2F;the-shape-of-psiber-space-octo...</a><p>Written by Don Hopkins, October 1989.
University of Maryland Human-Computer Interaction Lab, Computer Science Department, College Park, Maryland 20742.<p>Abstract:
The PSIBER Space Deck is an interactive visual user interface to a graphical programming environment, the NeWS window system. It lets you display, manipulate, and navigate the data structures, programs, and processes living in the virtual memory space of NeWS. It is useful as a debugging tool, and as a hands on way to learn about programming in PostScript and NeWS.<p>PostScript Source Code Available Here:<p><a href="https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;pub&#x2F;NeWS&#x2F;litecyber&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.donhopkins.com&#x2F;home&#x2F;pub&#x2F;NeWS&#x2F;litecyber&#x2F;</a><p>Introduction:
Cyberspace. A consensual hallucination experienced daily by billions of legitimate operators, in every nation, by children being taught mathematical concepts … A graphic representation of data abstracted from the banks of every computer in the human system. Unthinkable complexity. Lines of light ranged in the nonspace of the mind, clusters and constellations of data. Like city lights, receding …. [Gibson, Neuromancer]<p>The PSIBER Space Deck is a programming tool that lets you graphically display, manipulate, and navigate the many PostScript data structures, programs, and processes living in the virtual memory space of NeWS.<p>The Network extensible Window System (NeWS) is a multitasking object oriented PostScript programming environment. NeWS programs and data structures make up the window system kernel, the user interface toolkit, and even entire applications.<p>The PSIBER Space Deck is one such application, written entirely in PostScript, the result of an experiment in using a graphical programming environment to construct an interactive visual user interface to itself.<p>It displays views of structured data objects in overlapping windows that can be moved around on the screen, and manipulated with the mouse: you can copy and paste data structures from place to place, execute them, edit them, open up compound objects to see their internal structure, adjust the scale to shrink or magnify parts of the display, and pop up menus of other useful commands. Deep or complex data structures can be more easily grasped by applying various views to them.<p>[...]</div><br/></div></div><div id="36156194" class="c"><input type="checkbox" id="c-36156194" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#36156167">parent</a><span>|</span><a href="#36159999">prev</a><span>|</span><a href="#36160232">next</a><span>|</span><label class="collapse" for="c-36156194">[-]</label><label class="expand" for="c-36156194">[1 more]</label></div><br/><div class="children"><div class="content">Definitely, when you can directly manipulate your AST with easy, metaprogramming becomes a breeze.</div><br/></div></div></div></div><div id="36160232" class="c"><input type="checkbox" id="c-36160232" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36156167">prev</a><span>|</span><a href="#36157725">next</a><span>|</span><label class="collapse" for="c-36160232">[-]</label><label class="expand" for="c-36160232">[3 more]</label></div><br/><div class="children"><div class="content"><i>It’s also worth noting that code generation (and therefore metaprogramming itself) are also not fundamentally innovations of Lisp. For example, in C++, it is entirely possible to link your application to libclang and build Clang ASTs inside your application C++ code, and use the Clang compiler to emit and run that code.</i><p>Ahem: can we discuss the word <i>innovations</i> and <i>fundamentally</i> above, and put two facts on the table:<p>LISP: 1959
C++: 1979<p>If they&#x27;d said &quot;is not unique&quot; I could agree. The innovation is a statement of origination. C++ did not originate this concept into a language system from 19 years prior to C++</div><br/><div id="36161734" class="c"><input type="checkbox" id="c-36161734" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36160232">parent</a><span>|</span><a href="#36157725">next</a><span>|</span><label class="collapse" for="c-36161734">[-]</label><label class="expand" for="c-36161734">[2 more]</label></div><br/><div class="children"><div class="content">C++ is not from 1979. What is from 1979 is the &quot;beginning of work on C with Classes&quot;, which is entirely different. It was not until 1985 C++ got its first real implementation and a specification.</div><br/><div id="36161794" class="c"><input type="checkbox" id="c-36161794" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36160232">root</a><span>|</span><a href="#36161734">parent</a><span>|</span><a href="#36157725">next</a><span>|</span><label class="collapse" for="c-36161794">[-]</label><label class="expand" for="c-36161794">[1 more]</label></div><br/><div class="children"><div class="content">Does that undermine my central point?</div><br/></div></div></div></div></div></div><div id="36157725" class="c"><input type="checkbox" id="c-36157725" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#36160232">prev</a><span>|</span><a href="#36155059">next</a><span>|</span><label class="collapse" for="c-36157725">[-]</label><label class="expand" for="c-36157725">[2 more]</label></div><br/><div class="children"><div class="content"><i>...code generation (and therefore metaprogramming itself) are also not fundamentally innovations of Lisp. For example, in C++...</i><p>Wait, what?<p>Maybe I&#x27;m confused but doesn&#x27;t innovation mean doing something not done <i>before</i>?<p>C++ and even C are more recent than Lisp, they can&#x27;t be used as counterexamples. Or am I missing something?<p>(Edit&gt; other than that, I forgot to say: nice article.)</div><br/><div id="36158581" class="c"><input type="checkbox" id="c-36158581" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36157725">parent</a><span>|</span><a href="#36155059">next</a><span>|</span><label class="collapse" for="c-36158581">[-]</label><label class="expand" for="c-36158581">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s actually a problem throughout most of the article. But I think we can get the point of what the author means: 
certain programming language features that have enduring impact rose to because they were in Lisp (and Lisp had a period of real prominence). So, they’re not strictly speaking innovations of Lisp, but Lisp d was responsible, as a matter of historical fact(ish), for them becoming more widespread.<p>I say “(ish)” because I very much suspect that if you did actual careful historical investigation of the sources, you would find that there’s vanishingly less genuine creation ex nihilo with computers than the standard stories say. Features or ideas that later become prominent, typically seem to be “in the air” or inchoate when the person or people we give credit to for creating them “created” them.</div><br/></div></div></div></div><div id="36155059" class="c"><input type="checkbox" id="c-36155059" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36157725">prev</a><span>|</span><a href="#36159629">next</a><span>|</span><label class="collapse" for="c-36155059">[-]</label><label class="expand" for="c-36155059">[19 more]</label></div><br/><div class="children"><div class="content">To anyone not already experienced with Lisps, there&#x27;s varying schools of thought and opinions on what&#x27;s important and valuable, within Common Lisp (CL), and within the broader Lisp family.<p>For example, although this writer doesn&#x27;t think macros are important, the Scheme (and especially Racket) branch of Lisp ran with macros, then with various other DSL support that take macros further (like Racket `#lang`).  Racket also moved towards a strict definition of phases, and a very nice module system that works with that.<p>That might horrify some CL people, because it moves further away from the dynamic REPL live manipulation strength of CL, but others of us have found the tradeoffs very practical for our needs.</div><br/><div id="36155815" class="c"><input type="checkbox" id="c-36155815" checked=""/><div class="controls bullet"><span class="by">patrec</span><span>|</span><a href="#36155059">parent</a><span>|</span><a href="#36155569">next</a><span>|</span><label class="collapse" for="c-36155815">[-]</label><label class="expand" for="c-36155815">[7 more]</label></div><br/><div class="children"><div class="content">Hygienic macros and a strict phase separation are not distinctive to scheme, many languages have this now, most importantly Rust. And just like Rust macros scheme macros are not really an organic part of the language but some extra edifice bolted on top. Scheme definitely deserves credit  for pioneering work here, but the only aspect that&#x27;s of enduring distinctiveness that I&#x27;m aware of is Racket&#x27;s #lang, which basically gives you a less messy and more powerful version of what you could do in Common Lisp with macros and read-tables.<p>My impression is that hygiene itself (which the scheme community tended to obsess over) is of minor practical benefit, but the fact that you get good error locations (because not using plain lists and symbols makes it easy to carry sufficient contextual information around[^1]) is a major upside.<p>Out of curiosity, are there additional important practical benefits you see, macro-wise, over Common Lisp (that would make up for the gimped repl)? I.e. in addition to better error messages?<p>[^1] I seem to remember being told Allegro Common Lisp does a good job here, but    I assume identity still imposes some major limitations.</div><br/><div id="36162385" class="c"><input type="checkbox" id="c-36162385" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155815">parent</a><span>|</span><a href="#36156225">next</a><span>|</span><label class="collapse" for="c-36162385">[-]</label><label class="expand" for="c-36162385">[1 more]</label></div><br/><div class="children"><div class="content">Rust macros still fail short, hence why so many crates need to drag syn for the ride, making even more of a mess of compile times.</div><br/></div></div><div id="36156225" class="c"><input type="checkbox" id="c-36156225" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155815">parent</a><span>|</span><a href="#36162385">prev</a><span>|</span><a href="#36156292">next</a><span>|</span><label class="collapse" for="c-36156225">[-]</label><label class="expand" for="c-36156225">[1 more]</label></div><br/><div class="children"><div class="content">Rust macros are not hygienic. The biggest issue with this, I suspect, is the visibility limitation: due to lack of hygiene a macro can only refer to a public value. Thus some crates will publicly expose a value with a doc string saying &quot;this is supposed to be private please don&#x27;t abuse it our you&#x27;ll clobber the invariants this crate otherwise upholds&quot;.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;macros-by-example.html#hygiene" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;macros-by-example.html#h...</a></div><br/></div></div><div id="36156292" class="c"><input type="checkbox" id="c-36156292" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155815">parent</a><span>|</span><a href="#36156225">prev</a><span>|</span><a href="#36156724">next</a><span>|</span><label class="collapse" for="c-36156292">[-]</label><label class="expand" for="c-36156292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hygienic macros and a strict phase separation are not distinctive to scheme, many languages have this now, most importantly Rust.<p>My understanding is that Rust&#x27;s macros are only <i>partially</i> hygienic. They fall short of Racket&#x27;s. To the best of my knowledge, Racket has the most hygienic and expressive macro system of any language today. The people behind it have put a lot of work into it over the past couple of decades, producing more than a few significant papers in the realm of PL research.<p>&gt; My impression is that hygiene itself (which the scheme community tended to obsess over) is of minor practical benefit<p>I assume you&#x27;ve not written many macros that generate identifiers before. I assure you, hygiene is quite important for safely reasoning about your syntax!<p>&gt; are there additional important practical benefits you see, macro-wise, over Common Lisp<p>Racket sports a focus on what they call &quot;language-oriented programming&quot;. The gist of this community philosophy is that all significant software really is an API (or a layer of multiple APIs), and by treating these APIs as &quot;languages&quot; we can make them more ergonomic. Expressive macros enable a style of programming where you can make your API look however you want while still implementing it within whatever other language you&#x27;re using. Pretty much all of my Racket projects end up with at least a few macros, though it&#x27;s worth pointing out that the community also stresses that things that can be functions <i>should</i> be functions rather than macros.</div><br/></div></div><div id="36156724" class="c"><input type="checkbox" id="c-36156724" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155815">parent</a><span>|</span><a href="#36156292">prev</a><span>|</span><a href="#36156578">next</a><span>|</span><label class="collapse" for="c-36156724">[-]</label><label class="expand" for="c-36156724">[1 more]</label></div><br/><div class="children"><div class="content">I think hygiene vs. defmacro is pretty simple: syntax-case is explicit non-hygiene where defmacro is explicit hygiene.<p>I prefer the former, even though syntax case doesn&#x27;t go far enough. As it is in r6rs bindings are introduced unhygienically within the extent of a macro transformer, which stinks for complex enough macros. Sadly srfi 72 never caught on.<p>The benefit of the thing giving us the gimped repl is that the runtime can know what something is at compile time. Modules can be compiled with something akin to blocks in SBCL, speeding up procedure calls in ways you can&#x27;t really achieve with inline caches.<p>Chez spends capararively very little time worrying about things like that, yet manages to have cheaper procedure calls than SBCL almost always.</div><br/></div></div><div id="36156578" class="c"><input type="checkbox" id="c-36156578" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155815">parent</a><span>|</span><a href="#36156724">prev</a><span>|</span><a href="#36155569">next</a><span>|</span><label class="collapse" for="c-36156578">[-]</label><label class="expand" for="c-36156578">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Hygienic macros and a strict phase separation are not distinctive to scheme, many languages have this now<p>Somebody has already written that Rust doesn&#x27;t. And I wouldn&#x27;t say &#x27;many&#x27;, I know of Elixir which does have them.</div><br/><div id="36157265" class="c"><input type="checkbox" id="c-36157265" checked=""/><div class="controls bullet"><span class="by">patrec</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36156578">parent</a><span>|</span><a href="#36155569">next</a><span>|</span><label class="collapse" for="c-36157265">[-]</label><label class="expand" for="c-36157265">[1 more]</label></div><br/><div class="children"><div class="content">Rust macros are partially hygienic, but even scheme&#x27;s macros turned out to have unintended hygiene violations (<a href="https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;Scheme&#x2F;Dirty-Macros.pdf" rel="nofollow">https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;Scheme&#x2F;Dirty-Macros.pdf</a>).<p>&gt; And I wouldn&#x27;t say &#x27;many&#x27;, I know of Elixir<p>Rust, Julia and Elixir are three fairly mainstream languages with hygienic macros, and there are many more obscure languages (Dylan, and I believe Perl6 aka Raku) to outright esoteric ones (PLOT), as well as hygenic macro add-ons like sweet.js.</div><br/></div></div></div></div></div></div><div id="36155569" class="c"><input type="checkbox" id="c-36155569" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36155059">parent</a><span>|</span><a href="#36155815">prev</a><span>|</span><a href="#36159629">next</a><span>|</span><label class="collapse" for="c-36155569">[-]</label><label class="expand" for="c-36155569">[11 more]</label></div><br/><div class="children"><div class="content">Honestly just using Steel Bank Common Lisp is the best choice if you are looking to build high quality software which just works.<p>A lot of my software which earns a $4 million profit per year has SBCL sub systems though that is slowly decreasing as we are moving away from Lisp.</div><br/><div id="36155718" class="c"><input type="checkbox" id="c-36155718" checked=""/><div class="controls bullet"><span class="by">valbaca</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155569">parent</a><span>|</span><a href="#36155694">next</a><span>|</span><label class="collapse" for="c-36155718">[-]</label><label class="expand" for="c-36155718">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious. May I ask what you&#x27;re moving toward and what the motivations and reasons were? What was great and not great about building on&#x2F;with Lisp?</div><br/><div id="36157522" class="c"><input type="checkbox" id="c-36157522" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155718">parent</a><span>|</span><a href="#36155694">next</a><span>|</span><label class="collapse" for="c-36157522">[-]</label><label class="expand" for="c-36157522">[3 more]</label></div><br/><div class="children"><div class="content">I am moving towards Go.<p>The greatest benefit of SBCL is that it&#x27;s got great performance and the REPL jack in allows you to debug any application state. Building CL software is just amazing.<p>So as the company is growing really fast, and I never want to talk to a VC, I need to add those reliability into the system as I can&#x27;t spend a lot of time training people.<p>That can only be done by having the highest performance to simplest code ratio (since we lose the repl jack in).<p>Go is the clear winner here after trying a bunch of them.<p>It is also easy for people to learn and the amount of tutorials and resources online is great.<p>It is a bit sad, but the Lisp hacker bucket is a really small pool if you want to hire from so at the end of the day I had to compromise.<p>Having said that Go is quite a workhorse and has the simplicity of C so it is actually not that bad.</div><br/><div id="36158994" class="c"><input type="checkbox" id="c-36158994" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36157522">parent</a><span>|</span><a href="#36157885">next</a><span>|</span><label class="collapse" for="c-36158994">[-]</label><label class="expand" for="c-36158994">[1 more]</label></div><br/><div class="children"><div class="content">How many CL hackers do you need?<p>What about having a core of a few people, and leverage that Lisp productivity potential?  If you need a lot more &quot;bulk&quot; work (say, for customer integrations&#x2F;customizations), is it something that the core people can make easier?  Such as with APIs or DSLs, and recipes, so that this other set of programmers doesn&#x27;t have to all be CL experts?<p>You&#x27;ll probably have to pay good money for that core of great CL hackers, though.  Go programmers are more numerous, and maybe easier to find competent ones at commodity rates.<p>And is the number of CL hackers available on the job market decreasing?  ITA found a lot of them, at one point.  There are many Scheme&#x2F;Racket programmers than there are jobs.</div><br/></div></div><div id="36157885" class="c"><input type="checkbox" id="c-36157885" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36157522">parent</a><span>|</span><a href="#36158994">prev</a><span>|</span><a href="#36155694">next</a><span>|</span><label class="collapse" for="c-36157885">[-]</label><label class="expand" for="c-36157885">[1 more]</label></div><br/><div class="children"><div class="content">Are you able tontalk about your product and SBCL&#x27;s role in it?</div><br/></div></div></div></div></div></div><div id="36155694" class="c"><input type="checkbox" id="c-36155694" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155569">parent</a><span>|</span><a href="#36155718">prev</a><span>|</span><a href="#36155867">next</a><span>|</span><label class="collapse" for="c-36155694">[-]</label><label class="expand" for="c-36155694">[1 more]</label></div><br/><div class="children"><div class="content">If you have some great Lisp hackers who are also experienced in industry team software engineering, you step back and let them use whatever they decide is best to use. :)</div><br/></div></div><div id="36155867" class="c"><input type="checkbox" id="c-36155867" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155569">parent</a><span>|</span><a href="#36155694">prev</a><span>|</span><a href="#36159629">next</a><span>|</span><label class="collapse" for="c-36155867">[-]</label><label class="expand" for="c-36155867">[5 more]</label></div><br/><div class="children"><div class="content">Did you build it on your own? And why are you moving away from Lisp?</div><br/><div id="36157454" class="c"><input type="checkbox" id="c-36157454" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36155867">parent</a><span>|</span><a href="#36159629">next</a><span>|</span><label class="collapse" for="c-36157454">[-]</label><label class="expand" for="c-36157454">[4 more]</label></div><br/><div class="children"><div class="content">Yes I wrote all the first images. I love Lisp and think it is amazing if you approach it in the right way.<p>Now the company is growing at a rate that I need to hire people and build teams.<p>That is where Lisp is a hard bargain. The bucket of people who can write a new system from scratch without falling for the common traps is really small.<p>So that is why we are slowly transitioning away.</div><br/><div id="36157883" class="c"><input type="checkbox" id="c-36157883" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36157454">parent</a><span>|</span><a href="#36158519">next</a><span>|</span><label class="collapse" for="c-36157883">[-]</label><label class="expand" for="c-36157883">[1 more]</label></div><br/><div class="children"><div class="content">As someone who dabbles in common lisp I would love to know some examples of common traps are in designing a system in cl, since I am probably bound to fall into many :)</div><br/></div></div><div id="36158519" class="c"><input type="checkbox" id="c-36158519" checked=""/><div class="controls bullet"><span class="by">felideon</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36157454">parent</a><span>|</span><a href="#36157883">prev</a><span>|</span><a href="#36159637">next</a><span>|</span><label class="collapse" for="c-36158519">[-]</label><label class="expand" for="c-36158519">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Now the company is growing at a rate that I need to hire people and build teams.<p>And yet you didn’t post on the Who’s Hiring thread. :) Not that I’m looking, nor am I not looking, but sounds like an interesting gig.</div><br/></div></div><div id="36159637" class="c"><input type="checkbox" id="c-36159637" checked=""/><div class="controls bullet"><span class="by">kaveh808</span><span>|</span><a href="#36155059">root</a><span>|</span><a href="#36157454">parent</a><span>|</span><a href="#36158519">prev</a><span>|</span><a href="#36159629">next</a><span>|</span><label class="collapse" for="c-36159637">[-]</label><label class="expand" for="c-36159637">[1 more]</label></div><br/><div class="children"><div class="content">What is the field of your software product?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36159629" class="c"><input type="checkbox" id="c-36159629" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#36155059">prev</a><span>|</span><a href="#36155992">next</a><span>|</span><label class="collapse" for="c-36159629">[-]</label><label class="expand" for="c-36159629">[5 more]</label></div><br/><div class="children"><div class="content">I just started learning Janet, and one of the things I really like is being able to use &#x27;-&#x27; in variable names. I didn&#x27;t realize how much friction snake-case or camel case, ie having to use shift in var names, generate. It&#x27;s a small thing, but a thing that differentiates lisps and algols.</div><br/><div id="36160068" class="c"><input type="checkbox" id="c-36160068" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#36159629">parent</a><span>|</span><a href="#36155992">next</a><span>|</span><label class="collapse" for="c-36160068">[-]</label><label class="expand" for="c-36160068">[4 more]</label></div><br/><div class="children"><div class="content">I love kebab case. I want it everywhere.</div><br/><div id="36160178" class="c"><input type="checkbox" id="c-36160178" checked=""/><div class="controls bullet"><span class="by">sigjuice</span><span>|</span><a href="#36159629">root</a><span>|</span><a href="#36160068">parent</a><span>|</span><a href="#36160330">next</a><span>|</span><label class="collapse" for="c-36160178">[-]</label><label class="expand" for="c-36160178">[2 more]</label></div><br/><div class="children"><div class="content">I discovered recently that bash function names and aliases allow -<p><pre><code>  pi@4b:~ $ kebab-case-ftw () { echo yum; }
  pi@4b:~ $ kebab-case-ftw 
  yum
  pi@4b:~ $ alias kebab-kebob=&#x27;echo yum&#x27;
  pi@4b:~ $ kebab-kebob 
  yum</code></pre></div><br/><div id="36160196" class="c"><input type="checkbox" id="c-36160196" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36159629">root</a><span>|</span><a href="#36160178">parent</a><span>|</span><a href="#36160330">next</a><span>|</span><label class="collapse" for="c-36160196">[-]</label><label class="expand" for="c-36160196">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t work for variable names:<p><pre><code>  $ foo-bar=3
  foo-bar=3: command not found
</code></pre>
Consistency in Unix? Sacrilege.<p>Make is better in this regard.  You can have variables with . in them and with computed variables, that can simulate structures.  $($(VAR).member).   $(VAR) expands to some abc, and so the $(abc.member) evaluates that variable with a dot in its name.</div><br/></div></div></div></div><div id="36160330" class="c"><input type="checkbox" id="c-36160330" checked=""/><div class="controls bullet"><span class="by">ibiza</span><span>|</span><a href="#36159629">root</a><span>|</span><a href="#36160068">parent</a><span>|</span><a href="#36160178">prev</a><span>|</span><a href="#36155992">next</a><span>|</span><label class="collapse" for="c-36160330">[-]</label><label class="expand" for="c-36160330">[1 more]</label></div><br/><div class="children"><div class="content">Same. Outside of Lisp &amp; some shell, you&#x27;ve got the OG Cobol and Raku. HTML attrs? CSS? It&#x27;s a shame really. So easy to type and read.</div><br/></div></div></div></div></div></div><div id="36155992" class="c"><input type="checkbox" id="c-36155992" checked=""/><div class="controls bullet"><span class="by">Max_Limelihood</span><span>|</span><a href="#36159629">prev</a><span>|</span><a href="#36157033">next</a><span>|</span><label class="collapse" for="c-36155992">[-]</label><label class="expand" for="c-36155992">[6 more]</label></div><br/><div class="children"><div class="content">This is a really good explanation of why I find Julia (effectively a Lisp in terms of these features) to be indispensable. The ability to generate code on the fly makes life so much easier that I just can&#x27;t live without it.</div><br/><div id="36156683" class="c"><input type="checkbox" id="c-36156683" checked=""/><div class="controls bullet"><span class="by">vchuravy</span><span>|</span><a href="#36155992">parent</a><span>|</span><a href="#36161800">next</a><span>|</span><label class="collapse" for="c-36156683">[-]</label><label class="expand" for="c-36156683">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I often describe Julia as a Lisp in sheep&#x27;s clothing.<p>Or as the m-Lisp promised to us :)
I chuckled when I read:<p>&gt; The way that common Lisp systems produce executable binaries to be used as application deliverables is by literally dumping the contents of memory into a file with a little header to start things back up again.<p>Which is pretty much of Julia&#x27;s sys-&#x2F;pkgimages work. Pkgimages are an incremental variation on this idea.<p>One of the novelties in Julia is the world-age system and the limits on dynamisim it introduces on eval.</div><br/><div id="36162396" class="c"><input type="checkbox" id="c-36162396" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36155992">root</a><span>|</span><a href="#36156683">parent</a><span>|</span><a href="#36161800">next</a><span>|</span><label class="collapse" for="c-36162396">[-]</label><label class="expand" for="c-36162396">[1 more]</label></div><br/><div class="children"><div class="content">Pity that Apple didn&#x27;t push Dylan.</div><br/></div></div></div></div><div id="36161800" class="c"><input type="checkbox" id="c-36161800" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36155992">parent</a><span>|</span><a href="#36156683">prev</a><span>|</span><a href="#36156755">next</a><span>|</span><label class="collapse" for="c-36161800">[-]</label><label class="expand" for="c-36161800">[1 more]</label></div><br/><div class="children"><div class="content">I just don&#x27;t understand people who call von neumann style programming languages &quot;lisp-like&quot; or &quot;almost a lisp&quot;. I&#x27;ve heard people say this of python and haskell as well, and I just don&#x27;t see it, at all.</div><br/></div></div><div id="36156755" class="c"><input type="checkbox" id="c-36156755" checked=""/><div class="controls bullet"><span class="by">JanisErdmanis</span><span>|</span><a href="#36155992">parent</a><span>|</span><a href="#36161800">prev</a><span>|</span><a href="#36157033">next</a><span>|</span><label class="collapse" for="c-36156755">[-]</label><label class="expand" for="c-36156755">[2 more]</label></div><br/><div class="children"><div class="content">I agree that Julia satisfies the first two properties however, it&#x27;s not clear how it satisfies the third one (homonicity). In particular, how the argument with regard to Python does not apply to Julia as well?</div><br/><div id="36157047" class="c"><input type="checkbox" id="c-36157047" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#36155992">root</a><span>|</span><a href="#36156755">parent</a><span>|</span><a href="#36157033">next</a><span>|</span><label class="collapse" for="c-36157047">[-]</label><label class="expand" for="c-36157047">[1 more]</label></div><br/><div class="children"><div class="content">I think this answer <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;31734725&#x2F;5141328" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;31734725&#x2F;5141328</a> by one of Julia&#x27;s creators fits here. The TLDR is that homoiconicity is a mix of two separate things: how willing a language is to represent itself, and how close the syntax for code is to the syntax for the data-structure representing that code. Julia meets the first of these, but not the second. Whether this matters depends on why you care about homoiconicity. The biggest difference between Julia and Python here is that Julia has syntactic macros and python doesn&#x27;t (although see <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0638&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0638&#x2F;</a>)</div><br/></div></div></div></div></div></div><div id="36157033" class="c"><input type="checkbox" id="c-36157033" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36155992">prev</a><span>|</span><a href="#36155078">next</a><span>|</span><label class="collapse" for="c-36157033">[-]</label><label class="expand" for="c-36157033">[3 more]</label></div><br/><div class="children"><div class="content">- ~no syntax<p>- induction<p>- induction<p>- some taste for minimalism (although CL&#x2F;CLOS might feel different 
back in the days)<p>- human exploration oriented (repl, mop&#x2F;updates)<p>- open homoiconicity, as a programmer lisp is an open box, makes you 
grow more in depth<p>- understanding of high and low levels in one place<p>- radical taste for innovation.. do whatever, you&#x27;re near free</div><br/><div id="36158632" class="c"><input type="checkbox" id="c-36158632" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36157033">parent</a><span>|</span><a href="#36155078">next</a><span>|</span><label class="collapse" for="c-36158632">[-]</label><label class="expand" for="c-36158632">[2 more]</label></div><br/><div class="children"><div class="content">I think that Lisp taste for minimalism was very much a product of the world adjacent to Lisp and early Lispers: logic. Look at the lambda calculus itself. That whole golden era of metamathematics in the first half of the 20th century.</div><br/><div id="36161652" class="c"><input type="checkbox" id="c-36161652" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36157033">root</a><span>|</span><a href="#36158632">parent</a><span>|</span><a href="#36155078">next</a><span>|</span><label class="collapse" for="c-36161652">[-]</label><label class="expand" for="c-36161652">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, induction and minimalism are highly linked to mathematics and logic. They always try to find smallest expression of highest abstraction. Unlike hacking culture (like engineering, accepts compromises for the context at hand) or commercial ones (enjoy bloat for finance&#x2F;psychological reasons).</div><br/></div></div></div></div></div></div><div id="36155078" class="c"><input type="checkbox" id="c-36155078" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#36157033">prev</a><span>|</span><a href="#36156102">next</a><span>|</span><label class="collapse" for="c-36155078">[-]</label><label class="expand" for="c-36155078">[8 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;a.co&#x2F;d&#x2F;6NaRjQG" rel="nofollow">https:&#x2F;&#x2F;a.co&#x2F;d&#x2F;6NaRjQG</a><p>The &quot;condition system&quot; is niftier than i&#x27;ve seen elsewhere.</div><br/><div id="36156416" class="c"><input type="checkbox" id="c-36156416" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#36155078">parent</a><span>|</span><a href="#36156029">next</a><span>|</span><label class="collapse" for="c-36156416">[-]</label><label class="expand" for="c-36156416">[6 more]</label></div><br/><div class="children"><div class="content">Indeed. For those who aren&#x27;t familiar with the concept, you can consider them as the logical conclusion of exceptions.<p>Traditional error handling, as found in C for example, forces you to handle the error at the moment you detect it. Often, though, that&#x27;s deep in a library, and what to do about the error depends on the context.<p>Exceptions allow the a function to declare that when an error occurs in its dynamic scope, it should receive control to handle it. This is, in many ways, a major improvement.<p>However, consider a program that is parsing a data file. Halfway through the file, it encounters a malformed record. In an exception-based language it would throw an exception, unwinding the stack until you get to the main program logic. However, at that point you&#x27;ve closed the file, losing your position in it and any partially-parsed records. The only real recovery options are to abort reading that particular file or abort the load entirely.<p>Conditions allow the function that parses a record to declare that it can recover from a malformed record by replacing the binary data with something else, producing an error record, or producing some record that is given from the outside. Similarly, the code that loops over the records can declare a recovery path that skips the malformed record and continues with the next one. Then, when an error occurs, the main program logic can inspect the broken record (possibly by presenting it to the user) and instruct the condition system as to which recovery path to execute. Only <i>then</i> does the stack unwind, and only as much as necessary to get to that recovery path.<p>In short, exceptions separate detecting an error from handling it. Conditions add a third part, deciding <i>how</i> to handle the error.</div><br/><div id="36156631" class="c"><input type="checkbox" id="c-36156631" checked=""/><div class="controls bullet"><span class="by">pierrebai</span><span>|</span><a href="#36155078">root</a><span>|</span><a href="#36156416">parent</a><span>|</span><a href="#36156667">next</a><span>|</span><label class="collapse" for="c-36156631">[-]</label><label class="expand" for="c-36156631">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read the same, almost word-for-word claims repeatedly, which is annoying given how misleading it is.<p>Concretely...<p>To know the context of the conditions, the conditions must give the information. Otherwise, the handler would need to know intimately the implementation details to be able to retrieve the filename, line number, etc. If you can provide the information to the condition you call fill a throw exception with the exact same data. The exception can carry the filename, line numbers, token being parsed...<p>Second, the example itself is ludicrous. The caller of a file parser providing replacement data for a malformed file? In what world does that <i>ever</i> happens? How could it handle every possible ways a file might be malformed?<p>Third, in every language, the same can be implemented with a callback. In C++, the standard is now to use std::function for this, which supported free functions, members, lambdas... pretty much everything. The only advantage of List is that the declaration and registration of the callback is a language feature.</div><br/><div id="36157463" class="c"><input type="checkbox" id="c-36157463" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#36155078">root</a><span>|</span><a href="#36156631">parent</a><span>|</span><a href="#36158573">next</a><span>|</span><label class="collapse" for="c-36157463">[-]</label><label class="expand" for="c-36157463">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you can do this in ways other than conditions. However, I disagree with basically every objection you raise.<p>First, the decision made by the handler case doesn&#x27;t necessarily care which file the error was in, what the line number is, etc. All I&#x27;ve ever needed to decide what to do (details below) was the text content of the malformed record. From the perspective of my program, there were only a few possible cases:<p>1. The record is malformed in a way that I know how to recover from. In that case, I can just do so and invoke the `use-instead` recovery path.
2. The record is damaged in a new and exciting way. I can log it and try to muddle on, in hopes of catching all the new error cases while I&#x27;m off doing more interesting things than waiting on a 6-hour job.
3. The record is damaged irrecoverably and future records depend on it. (e.g., the file structure itself is damaged and this can&#x27;t be recovered from). This is the rarest case I&#x27;ve come across, but also the only one that&#x27;s convenient to handle with exceptions.<p>Further, if it was just a filename and byte offset that was needed to resume where I left off, you may have a point. However, suppose that there was an additional decompression step involved. You can&#x27;t, with most decompression libraries, pick up decompression in the middle of a stream, at least not without littering knowledge of the decompression through the entire process. Further, bundling everything necessary to pick up the computation where it left off forces you to structure your code in a certain way. For example, packing the state of the computation into a class with member functions doing each part, so that the file, current list of results, etc, are essentially scoped globals. I estimate that this would have been at least 5x more code than what was essentially wrapping a stream with a couple of transformers and iterating over it.<p>To your third point, I could have structured the parser to call a callback with the details of the problem, which could throw an appropriate exception to unwind to a suitable recovery point. This is, after all, how conditions are implemented. However, conditions as part of the language mean that <i>every</i> error can have recovery paths registered, not just ones that the developers thought to provide callbacks for.<p>And finally, to your second point. While I originally stole the example from Practical Common Lisp, I&#x27;ve since had exactly this situation come up. I had a ~150GiB file containing, essentially, lines of JSON. My parser validated that the incoming JSON fit a schema and processed it into a more compressed form such that I could fit the aspects of the dataset that I actually cared about into RAM. Now, this dataset had been through several migrations, between a number of different platforms, and not all of the migrations were bug-free. In some cases, it treated UTF-8 as CP-1251 and transcoded that into UTF-8. Others got double-escaped. Still others had parts of some fields duplicated in ways that were easy to detect and undo. Some records were just duplicated outright, and some were different versions of the same record. All of these <i>were</i> recoverable, but it was 150GiB of data. I couldn&#x27;t manually clean it first; I needed to run the program to see what it barfed on in order to fix it. Worse, being JSON, it compressed easily and this was at a time when 150GiB was more than half the disk space I had available to me. So of course the dataset was compressed on disk, and I was decompressing it as I read it.<p>Now, I&#x27;m sure that you can come up with a way that I could have packed the error recovery into the callback in the inner loop of the iterator, but why would I have? I had conditions at my disposal, and the way I actually did write it, I had the happy path in a perfectly clear straight line, and all of the various error cases and how to handle them lined up in a row next to it. The code was easy to read and work with, without any real efficiency cost. The fact that I <i>could</i> have made do with callbacks is no more relevant than that I could have made do using goto instead of loops and functions: we have these abstractions so that we can express what we want our programs to do at a higher level.</div><br/><div id="36159091" class="c"><input type="checkbox" id="c-36159091" checked=""/><div class="controls bullet"><span class="by">squirtlebonflow</span><span>|</span><a href="#36155078">root</a><span>|</span><a href="#36157463">parent</a><span>|</span><a href="#36158573">next</a><span>|</span><label class="collapse" for="c-36159091">[-]</label><label class="expand" for="c-36159091">[1 more]</label></div><br/><div class="children"><div class="content">What do you people DO that you are doing tasks like this?  I&#x27;ve always loved FP from college, but never ran into problems like this that would actually warrant using one</div><br/></div></div></div></div><div id="36158573" class="c"><input type="checkbox" id="c-36158573" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#36155078">root</a><span>|</span><a href="#36156631">parent</a><span>|</span><a href="#36157463">prev</a><span>|</span><a href="#36156667">next</a><span>|</span><label class="collapse" for="c-36158573">[-]</label><label class="expand" for="c-36158573">[1 more]</label></div><br/><div class="children"><div class="content">&gt; providing replacement data for a malformed file? In what world does that ever happens?<p>that sort of pattern happens in coding theory, error correcting codes for example.<p>&gt; In C++<p>i don&#x27;t claim to know the answer, but does it matter that the free variable allocation strategy for a Lisp lambda differs from what lambda means in C++?</div><br/></div></div></div></div><div id="36156667" class="c"><input type="checkbox" id="c-36156667" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36155078">root</a><span>|</span><a href="#36156416">parent</a><span>|</span><a href="#36156631">prev</a><span>|</span><a href="#36156029">next</a><span>|</span><label class="collapse" for="c-36156667">[-]</label><label class="expand" for="c-36156667">[1 more]</label></div><br/><div class="children"><div class="content">Lisp also has a distinction between kinds of conditions but using the same underlying mechanism. You can have a plain signal which is informational. For instance in a data processing task you can signal your progress, and <i>if</i> there is a handler above it might update some GUI rendering of your progress or print out something to a terminal. If there isn&#x27;t, nothing happens. For errors, you can have a handler which will select the restart option or otherwise handle the error, and if there is no handler you&#x27;ll be brought into the debugger (typically, some modes of execution might cause a program to simply crash&#x2F;terminate).</div><br/></div></div></div></div><div id="36156029" class="c"><input type="checkbox" id="c-36156029" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36155078">parent</a><span>|</span><a href="#36156416">prev</a><span>|</span><a href="#36156102">next</a><span>|</span><label class="collapse" for="c-36156029">[-]</label><label class="expand" for="c-36156029">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Common-Lisp-Condition-System-Mechanisms&#x2F;dp&#x2F;148426133X" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Common-Lisp-Condition-System-Mechanis...</a><p>Unshortened URL: <i>The Common Lisp Condition System</i> by Michał &quot;phoe&quot; Herda.</div><br/></div></div></div></div><div id="36156102" class="c"><input type="checkbox" id="c-36156102" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#36155078">prev</a><span>|</span><a href="#36157122">next</a><span>|</span><label class="collapse" for="c-36156102">[-]</label><label class="expand" for="c-36156102">[3 more]</label></div><br/><div class="children"><div class="content">Lisp was a very early, if not the first, case of a language where types are associated with values, not variables.  The evolution of implementations of Lisps showed that such languages could be implemented efficiently, even on stock hardware.  This last realization took a while (witness how lisp machines were being developed into the 1980s.)</div><br/><div id="36158681" class="c"><input type="checkbox" id="c-36158681" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36156102">parent</a><span>|</span><a href="#36157122">next</a><span>|</span><label class="collapse" for="c-36158681">[-]</label><label class="expand" for="c-36158681">[2 more]</label></div><br/><div class="children"><div class="content">What will be interesting to see is whether the idea of a Lisp Machine comes back as ASICS become more popular. Will hole machines be designed to optimize performance with a DSL created for some particular domain? In other words, architectures optimized for specific languages (because those languages are optimized for specific domains), not necessarily literally Lisp Machines.<p>That thought popped into my head because of the “enduring“ in the title. What endures depends entirely on the needs of, and approaches taken by, people in the present.</div><br/><div id="36162413" class="c"><input type="checkbox" id="c-36162413" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36156102">root</a><span>|</span><a href="#36158681">parent</a><span>|</span><a href="#36157122">next</a><span>|</span><label class="collapse" for="c-36162413">[-]</label><label class="expand" for="c-36162413">[1 more]</label></div><br/><div class="children"><div class="content">In a way, the ongoing adoption of hardware memory tagging to get rid of C memory corruption issues feels like Lisp Machine&#x27;s revenge.</div><br/></div></div></div></div></div></div><div id="36157122" class="c"><input type="checkbox" id="c-36157122" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36156102">prev</a><span>|</span><a href="#36158474">next</a><span>|</span><label class="collapse" for="c-36157122">[-]</label><label class="expand" for="c-36157122">[1 more]</label></div><br/><div class="children"><div class="content">The third point is a little convoluted to me and doesn’t seem to be a beneficial innovation so much as a design choice.<p>Really for most of these benefits you can reductively boil them down to “code is data” because serialization-of-code, first class functions, REPLs, etc all more or less follow from that single major innovation.<p>This single innovation has more far reaching effects than many people realize as once people figured out that code-is-data and AST serialization means little pieces of code (not full programs) could be transmitted and executed over a network, it has enabled massive improvements in data processing through things like MapReduce and distributed databases.</div><br/></div></div><div id="36158474" class="c"><input type="checkbox" id="c-36158474" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#36157122">prev</a><span>|</span><a href="#36157291">next</a><span>|</span><label class="collapse" for="c-36158474">[-]</label><label class="expand" for="c-36158474">[1 more]</label></div><br/><div class="children"><div class="content">In Clojure, thread macros. Allows very terse but powerful operations on data structures in a very readable way that’s easier to reason about than nested calls in C -style languages.</div><br/></div></div><div id="36157291" class="c"><input type="checkbox" id="c-36157291" checked=""/><div class="controls bullet"><span class="by">drcode</span><span>|</span><a href="#36158474">prev</a><span>|</span><a href="#36155906">next</a><span>|</span><label class="collapse" for="c-36157291">[-]</label><label class="expand" for="c-36157291">[2 more]</label></div><br/><div class="children"><div class="content">didn&#x27;t garbage collection originate with lisp?<p>if so, that should really be considered its most pervasive innovation</div><br/><div id="36157402" class="c"><input type="checkbox" id="c-36157402" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36157291">parent</a><span>|</span><a href="#36155906">next</a><span>|</span><label class="collapse" for="c-36157402">[-]</label><label class="expand" for="c-36157402">[1 more]</label></div><br/><div class="children"><div class="content">probably so, but surely the most <i>widely</i> used early garbage collector was in line-based BASIC.</div><br/></div></div></div></div><div id="36155906" class="c"><input type="checkbox" id="c-36155906" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#36157291">prev</a><span>|</span><a href="#36155068">next</a><span>|</span><label class="collapse" for="c-36155906">[-]</label><label class="expand" for="c-36155906">[4 more]</label></div><br/><div class="children"><div class="content">No, Lisp did not invent if statements. They&#x27;re in Fortran&#x27;s 1956 Programmer&#x27;s Reference Manual.<p><a href="http:&#x2F;&#x2F;bitsavers.informatik.uni-stuttgart.de&#x2F;pdf&#x2F;ibm&#x2F;704&#x2F;704_FortranProgRefMan_Oct56.pdf" rel="nofollow">http:&#x2F;&#x2F;bitsavers.informatik.uni-stuttgart.de&#x2F;pdf&#x2F;ibm&#x2F;704&#x2F;704...</a></div><br/><div id="36156205" class="c"><input type="checkbox" id="c-36156205" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#36155906">parent</a><span>|</span><a href="#36155068">next</a><span>|</span><label class="collapse" for="c-36156205">[-]</label><label class="expand" for="c-36156205">[3 more]</label></div><br/><div class="children"><div class="content">Fortran 56&#x27;s IF statement is <i>very</i> different from the Lisp if statement; the former is a conditional jump, and the latter is a structured control flow construct. Further, Fortran 56&#x27;s DO isn&#x27;t a do&#x2F;while loop as we know it today, but rather a conditional come from. The entire concept of structured control flow was invented by Lisp, and it was very controversial at the time.</div><br/><div id="36159858" class="c"><input type="checkbox" id="c-36159858" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#36155906">root</a><span>|</span><a href="#36156205">parent</a><span>|</span><a href="#36155068">next</a><span>|</span><label class="collapse" for="c-36159858">[-]</label><label class="expand" for="c-36159858">[2 more]</label></div><br/><div class="children"><div class="content">Did Lisp improve the IF statement? Certainly. But here&#x27;s John freakin&#x27; McCarthy citing Fortran&#x27;s IF statement which he had used. That means Lisp didn&#x27;t <i>invent</i> the IF statement. Lisp invented better syntax.<p><a href="http:&#x2F;&#x2F;jmc.stanford.edu&#x2F;articles&#x2F;lisp&#x2F;lisp.pdf" rel="nofollow">http:&#x2F;&#x2F;jmc.stanford.edu&#x2F;articles&#x2F;lisp&#x2F;lisp.pdf</a></div><br/><div id="36161481" class="c"><input type="checkbox" id="c-36161481" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36155906">root</a><span>|</span><a href="#36159858">parent</a><span>|</span><a href="#36155068">next</a><span>|</span><label class="collapse" for="c-36161481">[-]</label><label class="expand" for="c-36161481">[1 more]</label></div><br/><div class="children"><div class="content">He invented the conditional expression.<p><pre><code>  (print (cond ((&gt; a 10) &quot;a is larger than 10&quot;)
               ((&gt; a 20) &quot;a is larger than 20&quot;)
               (t &quot;a is smaller than or equal to 10&quot;)))
</code></pre>
COND takes zero or more conditional expressions and returns a value.</div><br/></div></div></div></div></div></div></div></div><div id="36155068" class="c"><input type="checkbox" id="c-36155068" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36155906">prev</a><span>|</span><a href="#36155900">next</a><span>|</span><label class="collapse" for="c-36155068">[-]</label><label class="expand" for="c-36155068">[8 more]</label></div><br/><div class="children"><div class="content">the innovation of lisp led to the innovations of scheme:<p>Lambda: The Ultimate Imperative<p>Lambda: The Ultimate Declarative<p>Lambda: The Ultimate GOTO (Procedure Call Implementations Considered Harmful)<p><a href="https:&#x2F;&#x2F;research.scheme.org&#x2F;lambda-papers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.scheme.org&#x2F;lambda-papers&#x2F;</a></div><br/><div id="36156490" class="c"><input type="checkbox" id="c-36156490" checked=""/><div class="controls bullet"><span class="by">bafe</span><span>|</span><a href="#36155068">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36156490">[-]</label><label class="expand" for="c-36156490">[6 more]</label></div><br/><div class="children"><div class="content">Indeed,from my understanding of history it seems that lisp brought the idea of homoiconicity through the use S-expressions. Scheme was the first to introduce lexical scoping and in general the idea of constructing the language on a small set of well thought out primitives (see the lambda papers)</div><br/><div id="36156739" class="c"><input type="checkbox" id="c-36156739" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36155068">root</a><span>|</span><a href="#36156490">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36156739">[-]</label><label class="expand" for="c-36156739">[5 more]</label></div><br/><div class="children"><div class="content">bafe, I vouched for your comment. You may want to reach out to the mods (hn@ycombinator.com) because your account appears to have been shadowbanned. You only have 4 comments and all were dead (not marked as [flagged] which is typically there with user flags). You may have triggered one of the system&#x27;s rules which sometimes catch up new users (for instance, creating an account through some VPNs, reportedly).</div><br/><div id="36157319" class="c"><input type="checkbox" id="c-36157319" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36155068">root</a><span>|</span><a href="#36156739">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36157319">[-]</label><label class="expand" for="c-36157319">[4 more]</label></div><br/><div class="children"><div class="content">Not banned - but yes, subject to extra restrictions because it&#x27;s a new account. I&#x27;ve marked the account legit now so this won&#x27;t happen again. Thanks for watching out for a fellow user!</div><br/><div id="36157361" class="c"><input type="checkbox" id="c-36157361" checked=""/><div class="controls bullet"><span class="by">bafe</span><span>|</span><a href="#36155068">root</a><span>|</span><a href="#36157319">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36157361">[-]</label><label class="expand" for="c-36157361">[3 more]</label></div><br/><div class="children"><div class="content">Thank you all! I&#x27;m a very new user, and perhaps not as good as a writer as most of you, but I am definitely a legit poster, not a spammer</div><br/><div id="36157724" class="c"><input type="checkbox" id="c-36157724" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36155068">root</a><span>|</span><a href="#36157361">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36157724">[-]</label><label class="expand" for="c-36157724">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s clear, and you&#x27;re most welcome here!<p>I&#x27;m sorry our software got it wrong in your case, but you should be good to go now.</div><br/><div id="36158481" class="c"><input type="checkbox" id="c-36158481" checked=""/><div class="controls bullet"><span class="by">bafe</span><span>|</span><a href="#36155068">root</a><span>|</span><a href="#36157724">parent</a><span>|</span><a href="#36155700">next</a><span>|</span><label class="collapse" for="c-36158481">[-]</label><label class="expand" for="c-36158481">[1 more]</label></div><br/><div class="children"><div class="content">Great, thanks! It&#x27;s really encouraging to see a community today were the moderators&#x2F;owners reach out to users directly.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36155700" class="c"><input type="checkbox" id="c-36155700" checked=""/><div class="controls bullet"><span class="by">mcdonje</span><span>|</span><a href="#36155068">parent</a><span>|</span><a href="#36156490">prev</a><span>|</span><a href="#36155900">next</a><span>|</span><label class="collapse" for="c-36155700">[-]</label><label class="expand" for="c-36155700">[1 more]</label></div><br/><div class="children"><div class="content">ΛΛΛ</div><br/></div></div></div></div><div id="36155900" class="c"><input type="checkbox" id="c-36155900" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#36155068">prev</a><span>|</span><a href="#36157071">next</a><span>|</span><label class="collapse" for="c-36155900">[-]</label><label class="expand" for="c-36155900">[12 more]</label></div><br/><div class="children"><div class="content">Which Lisp is the most practical and easy to pick up for a programmer? I already tried emacs lisp but the experience of running emacs was not great, so I gave up</div><br/><div id="36155964" class="c"><input type="checkbox" id="c-36155964" checked=""/><div class="controls bullet"><span class="by">Nihilartikel</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36157382">next</a><span>|</span><label class="collapse" for="c-36155964">[-]</label><label class="expand" for="c-36155964">[1 more]</label></div><br/><div class="children"><div class="content">Clojure is a serious contender.<p>To be sure, it&#x27;s still niche but it has a good ecosystem, piggybacks on mature java libs, and has an active community.<p>It&#x27;s thoughtfully opinionated, which I appreciate. Also clojurescript is almost the only front end dev experience I will tolerate.<p>The hot reloading is magic and it is gangsta as F to use the exact same logic on the fast jvm (or CLR if you&#x27;re nasty) backend as in the js front end.</div><br/></div></div><div id="36157382" class="c"><input type="checkbox" id="c-36157382" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36155964">prev</a><span>|</span><a href="#36155975">next</a><span>|</span><label class="collapse" for="c-36157382">[-]</label><label class="expand" for="c-36157382">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp was created and used by the DARPA and its community of public research labs and private companies to support all kinds of industrial and scientific projects, I don&#x27;t think there is more practical Lisp. It&#x27;s fast both in compile time and runtime, supports any programming paradigm you want, and it&#x27;s one of the most interactive programming environments ever. There are multiple open-source implementations, and there are at least two commercial implementations with paid support.<p>If you want to start, install the new IDE for Common Lisp called Lem [0] and follow the free online book Practical Common Lisp [1]. If you have any questions, the community can help you on Discord with the language itself [2] and the IDE [3].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;lem-project&#x2F;lem&#x2F;releases">https:&#x2F;&#x2F;github.com&#x2F;lem-project&#x2F;lem&#x2F;releases</a><p>[1] <a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;discord.gg&#x2F;cuVpwZXJ" rel="nofollow">https:&#x2F;&#x2F;discord.gg&#x2F;cuVpwZXJ</a><p>[3] <a href="https:&#x2F;&#x2F;discord.gg&#x2F;sBYyjyC6" rel="nofollow">https:&#x2F;&#x2F;discord.gg&#x2F;sBYyjyC6</a></div><br/></div></div><div id="36155975" class="c"><input type="checkbox" id="c-36155975" checked=""/><div class="controls bullet"><span class="by">mike_ivanov</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36157382">prev</a><span>|</span><a href="#36156375">next</a><span>|</span><label class="collapse" for="c-36155975">[-]</label><label class="expand" for="c-36155975">[3 more]</label></div><br/><div class="children"><div class="content">What is practical depends on your goals. Clojure can do pretty much everything, though it&#x27;s a bit less practical for things like high-FPS video games and desktop GUI.</div><br/><div id="36161035" class="c"><input type="checkbox" id="c-36161035" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#36155900">root</a><span>|</span><a href="#36155975">parent</a><span>|</span><a href="#36156843">prev</a><span>|</span><a href="#36156375">next</a><span>|</span><label class="collapse" for="c-36161035">[-]</label><label class="expand" for="c-36161035">[1 more]</label></div><br/><div class="children"><div class="content">Janet might be a good contender for games.  It is very easy to write C modules for the performance-critical bits.</div><br/></div></div></div></div><div id="36156375" class="c"><input type="checkbox" id="c-36156375" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36155975">prev</a><span>|</span><a href="#36156497">next</a><span>|</span><label class="collapse" for="c-36156375">[-]</label><label class="expand" for="c-36156375">[1 more]</label></div><br/><div class="children"><div class="content">My favourite right now is Chicken Scheme. Just the R7RS specification in general; the language is very minimal, yet has basically all you need. And Chicken has awesome C interop and a great little community on IRC in #chicken.</div><br/></div></div><div id="36156497" class="c"><input type="checkbox" id="c-36156497" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36156375">prev</a><span>|</span><a href="#36156214">next</a><span>|</span><label class="collapse" for="c-36156497">[-]</label><label class="expand" for="c-36156497">[2 more]</label></div><br/><div class="children"><div class="content">A Scheme, or Racket, which has the most packages of everything not Common Lisp.<p>I&#x27;d suggest Chez Scheme (the Racket fork if you&#x27;ve got an ARM Mac), that is fast and has (real) threads.</div><br/><div id="36161054" class="c"><input type="checkbox" id="c-36161054" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#36155900">root</a><span>|</span><a href="#36156497">parent</a><span>|</span><a href="#36156214">next</a><span>|</span><label class="collapse" for="c-36161054">[-]</label><label class="expand" for="c-36161054">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the Racket fork if you’ve got an ARM Max<p>Or if you have a PowerPC Mac!  <a href="https:&#x2F;&#x2F;leopard.sh&#x2F;leopardsh&#x2F;scripts&#x2F;install-chezscheme-9.5.9-racket-20230127.sh" rel="nofollow">https:&#x2F;&#x2F;leopard.sh&#x2F;leopardsh&#x2F;scripts&#x2F;install-chezscheme-9.5....</a></div><br/></div></div></div></div><div id="36156214" class="c"><input type="checkbox" id="c-36156214" checked=""/><div class="controls bullet"><span class="by">smegsicle</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36156497">prev</a><span>|</span><a href="#36156200">next</a><span>|</span><label class="collapse" for="c-36156214">[-]</label><label class="expand" for="c-36156214">[2 more]</label></div><br/><div class="children"><div class="content">common lisp is the most practical- its an industrial strength application language, gradually typed, very fast<p>it even includes the most complete oop system known to man which you can completely ignore if you want to and it&#x27;ll still be the best choice<p>not that complex either, maybe halfway between lua and python?<p>there are some rough edges, which comes from being powerful and unopinionated, but they are trivially papered over as you work</div><br/><div id="36159801" class="c"><input type="checkbox" id="c-36159801" checked=""/><div class="controls bullet"><span class="by">smegsicle</span><span>|</span><a href="#36155900">root</a><span>|</span><a href="#36156214">parent</a><span>|</span><a href="#36156200">next</a><span>|</span><label class="collapse" for="c-36159801">[-]</label><label class="expand" for="c-36159801">[1 more]</label></div><br/><div class="children"><div class="content">p.s. schemes are &#x27;lispy&#x27; but they are not &#x27;lisp&#x27; change my mind</div><br/></div></div></div></div><div id="36156200" class="c"><input type="checkbox" id="c-36156200" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#36155900">parent</a><span>|</span><a href="#36156214">prev</a><span>|</span><a href="#36157071">next</a><span>|</span><label class="collapse" for="c-36156200">[-]</label><label class="expand" for="c-36156200">[1 more]</label></div><br/><div class="children"><div class="content">Emacs lisp is one of the worst lisps for most things, though it&#x27;s a decent fit for its specific purpose.<p>People are suggesting clojure and clojure is great but it also has rigorous immutability semantics. If you&#x27;re not familiar with that model you&#x27;ll spend as much effort learning it as learning lisp, and it&#x27;ll be unclear which things come from lisp weirdness and which from immutable weirdness.<p>Someone will also probably suggest racket, which has its strengths as a learning language but is also very large and complex, with numerous extensions to the core language that make it kind of a disorienting ecosystem.<p>I like janet a lot. It uses &quot;normal&quot; data structures as its primitives rather than the traditional cons cells. So if you want to understand and be connected to historical lisp it will feel very different, and be a poor choice. This also applies to clojure though now that I think of it. otoh if you just want to use parens &amp; prefix notation and play with macros either will work.</div><br/></div></div></div></div><div id="36157071" class="c"><input type="checkbox" id="c-36157071" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36155900">prev</a><span>|</span><a href="#36156183">next</a><span>|</span><label class="collapse" for="c-36157071">[-]</label><label class="expand" for="c-36157071">[1 more]</label></div><br/><div class="children"><div class="content">solving frontend dev in a permanent way.<p><a href="https:&#x2F;&#x2F;reagent-project.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reagent-project.github.io&#x2F;</a></div><br/></div></div><div id="36156183" class="c"><input type="checkbox" id="c-36156183" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36157071">prev</a><span>|</span><a href="#36154867">next</a><span>|</span><label class="collapse" for="c-36156183">[-]</label><label class="expand" for="c-36156183">[1 more]</label></div><br/><div class="children"><div class="content">YAML.</div><br/></div></div><div id="36154867" class="c"><input type="checkbox" id="c-36154867" checked=""/><div class="controls bullet"><span class="by">smegsicle</span><span>|</span><a href="#36156183">prev</a><span>|</span><a href="#36157436">next</a><span>|</span><label class="collapse" for="c-36154867">[-]</label><label class="expand" for="c-36154867">[19 more]</label></div><br/><div class="children"><div class="content">notably not &#x27;lisp features that have been absorbed elsewhere&#x27; but instead the opposite, lisp features that still make it unique<p>tl;dr<p>1. no part of the system off limits<p>2. pervasive interactivity<p>3. homoiconicity</div><br/><div id="36155071" class="c"><input type="checkbox" id="c-36155071" checked=""/><div class="controls bullet"><span class="by">amock</span><span>|</span><a href="#36154867">parent</a><span>|</span><a href="#36154995">next</a><span>|</span><label class="collapse" for="c-36155071">[-]</label><label class="expand" for="c-36155071">[2 more]</label></div><br/><div class="children"><div class="content">The first two sound like core parts of Smalltalk as well.</div><br/><div id="36155260" class="c"><input type="checkbox" id="c-36155260" checked=""/><div class="controls bullet"><span class="by">SeanLuke</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155071">parent</a><span>|</span><a href="#36154995">next</a><span>|</span><label class="collapse" for="c-36155260">[-]</label><label class="expand" for="c-36155260">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk was proudly a descendent of Lisp.</div><br/></div></div></div></div><div id="36154995" class="c"><input type="checkbox" id="c-36154995" checked=""/><div class="controls bullet"><span class="by">Lyngbakr</span><span>|</span><a href="#36154867">parent</a><span>|</span><a href="#36155071">prev</a><span>|</span><a href="#36161246">next</a><span>|</span><label class="collapse" for="c-36154995">[-]</label><label class="expand" for="c-36154995">[15 more]</label></div><br/><div class="children"><div class="content">Perhaps I&#x27;ve misunderstood, but several languages have REPLs so  that isn&#x27;t unique to Lisps, is it?</div><br/><div id="36155141" class="c"><input type="checkbox" id="c-36155141" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36154995">parent</a><span>|</span><a href="#36155054">next</a><span>|</span><label class="collapse" for="c-36155141">[-]</label><label class="expand" for="c-36155141">[5 more]</label></div><br/><div class="children"><div class="content">This blog post explains the sort of workflow a Lisp&#x2F;Smalltalk-style REPL enables:<p><a href="https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;</a></div><br/><div id="36158395" class="c"><input type="checkbox" id="c-36158395" checked=""/><div class="controls bullet"><span class="by">askvictor</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155141">parent</a><span>|</span><a href="#36155170">next</a><span>|</span><label class="collapse" for="c-36158395">[-]</label><label class="expand" for="c-36158395">[3 more]</label></div><br/><div class="children"><div class="content">Interesting; when you define a function (or anything) in a breakloop, does it get saved to source? (or is there an option to?)<p>I&#x27;m trying to imagine using this style of programming in Python, but the type-redefinition problem is still there</div><br/><div id="36161563" class="c"><input type="checkbox" id="c-36161563" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36158395">parent</a><span>|</span><a href="#36159793">next</a><span>|</span><label class="collapse" for="c-36161563">[-]</label><label class="expand" for="c-36161563">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes a break-loop is all you have.<p>But usually there is something around it. Typically a Lisp system can run several REPLs at the same time, one might be a break loop. You can define a function in another REPL and use it in the break-loop. You can define the function by loading code in a break-loop.<p>An interaction might be (here in LispWorks):<p><pre><code>  CL-USER 6 &gt; (&gt; (sin-x2 3) 0)

  Error: Undefined operator SIN-X2 in form (SIN-X2 3).
    1 (continue) Try invoking SIN-X2 again.
    2 Return some values from the form (SIN-X2 3).
    3 Try invoking something other than SIN-X2 with the same arguments.
    4 Set the symbol-function of SIN-X2 to another function.
    5 Set the macro-function of SIN-X2 to another function.
    6 (abort) Return to top loop level 0.

  Type :b for backtrace or :c &lt;option number&gt; to proceed.
  Type :bug-form &quot;&lt;subject&gt;&quot; for a bug report template or :? for other options.

  CL-USER 7 : 1 &gt; (load &quot;~&#x2F;sin-x2.lisp&quot;)
  ; Loading text file &#x2F;Users&#x2F;foo&#x2F;sin-x2.lisp
  #P&quot;&#x2F;Users&#x2F;foo&#x2F;sin-x2.lisp&quot;

  CL-USER 8 : 1 &gt; :c 1
  T
</code></pre>
A function SIN-X2 does not exist. There is an error and we get a break-loop. The break-loop is one level deep. All of Lisp is available in a break-loop: the compiler, the code loader, the evaluator, ... Lisp stays with the break-loop in the context of the error.<p>I define&#x2F;write the function in a file and the load the file. Loading the makes the function available in the running Lisp.<p>Then I use the continue restart to try to find the function again -&gt; the error is gone</div><br/></div></div><div id="36159793" class="c"><input type="checkbox" id="c-36159793" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36158395">parent</a><span>|</span><a href="#36161563">prev</a><span>|</span><a href="#36155170">next</a><span>|</span><label class="collapse" for="c-36159793">[-]</label><label class="expand" for="c-36159793">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that you usually write the code in your editor and use an editor command to send the code directly to the Lisp process (that’s what I do, anyway). Or just copy-paste.<p>I’m not aware of a way to get code back out of the Lisp environment, but I’m fairly new to all this.</div><br/></div></div></div></div><div id="36155170" class="c"><input type="checkbox" id="c-36155170" checked=""/><div class="controls bullet"><span class="by">Lyngbakr</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155141">parent</a><span>|</span><a href="#36158395">prev</a><span>|</span><a href="#36155054">next</a><span>|</span><label class="collapse" for="c-36155170">[-]</label><label class="expand" for="c-36155170">[1 more]</label></div><br/><div class="children"><div class="content">That is <i>exactly</i> the clarification I needed. Thanks!</div><br/></div></div></div></div><div id="36155054" class="c"><input type="checkbox" id="c-36155054" checked=""/><div class="controls bullet"><span class="by">phyrex</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36154995">parent</a><span>|</span><a href="#36155141">prev</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36155054">[-]</label><label class="expand" for="c-36155054">[7 more]</label></div><br/><div class="children"><div class="content">There’s very rarely any where you can actually interact with the running program. At best you can usually load in a method and poke it, but that’s not the same.</div><br/><div id="36155120" class="c"><input type="checkbox" id="c-36155120" checked=""/><div class="controls bullet"><span class="by">Lyngbakr</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155054">parent</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36155120">[-]</label><label class="expand" for="c-36155120">[6 more]</label></div><br/><div class="children"><div class="content">So, the REPL mentioned in the article differs from, say, the Julia REPL[0]? Is it simply using the same term for slightly different things?<p>[0] <a href="https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;stdlib&#x2F;REPL&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;stdlib&#x2F;REPL&#x2F;</a></div><br/><div id="36156972" class="c"><input type="checkbox" id="c-36156972" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155120">parent</a><span>|</span><a href="#36155335">next</a><span>|</span><label class="collapse" for="c-36156972">[-]</label><label class="expand" for="c-36156972">[1 more]</label></div><br/><div class="children"><div class="content">One of the other comments in this thread links to: <a href="https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;</a> which makes a distinction between &quot;having a REPL&quot; and &quot;supporting repl-driven programming&quot;. Modern languages which have a REPL generally don&#x27;t support the sort of repl-driven programming they refer to. Julia&#x27;s Revise.jl [1] supports one way of repl-driven programming, and it is in fact the recommended way of doing Julia, but from my understanding it&#x27;s still very different from the Lisp ways.<p>[1] <a href="https:&#x2F;&#x2F;timholy.github.io&#x2F;Revise.jl&#x2F;stable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;timholy.github.io&#x2F;Revise.jl&#x2F;stable&#x2F;</a></div><br/></div></div><div id="36155335" class="c"><input type="checkbox" id="c-36155335" checked=""/><div class="controls bullet"><span class="by">selimthegrim</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155120">parent</a><span>|</span><a href="#36156972">prev</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36155335">[-]</label><label class="expand" for="c-36155335">[4 more]</label></div><br/><div class="children"><div class="content">The Julia REPL front end is written in Scheme IIRC</div><br/><div id="36157013" class="c"><input type="checkbox" id="c-36157013" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155335">parent</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36157013">[-]</label><label class="expand" for="c-36157013">[3 more]</label></div><br/><div class="children"><div class="content">I believe it&#x27;s Julia&#x27;s current default parser that&#x27;s written in a Scheme, the REPL is a normal Julia standard library written in Julia itself: <a href="https:&#x2F;&#x2F;github.com&#x2F;JuliaLang&#x2F;julia&#x2F;blob&#x2F;master&#x2F;stdlib&#x2F;REPL&#x2F;src&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;JuliaLang&#x2F;julia&#x2F;blob&#x2F;master&#x2F;stdlib&#x2F;REPL&#x2F;s...</a></div><br/><div id="36157065" class="c"><input type="checkbox" id="c-36157065" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36157013">parent</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36157065">[-]</label><label class="expand" for="c-36157065">[2 more]</label></div><br/><div class="children"><div class="content">also we are very close to moving Julia&#x27;s parsing (but not lowering) to pure Julia as well.</div><br/><div id="36157113" class="c"><input type="checkbox" id="c-36157113" checked=""/><div class="controls bullet"><span class="by">selimthegrim</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36157065">parent</a><span>|</span><a href="#36155032">next</a><span>|</span><label class="collapse" for="c-36157113">[-]</label><label class="expand" for="c-36157113">[1 more]</label></div><br/><div class="children"><div class="content">OK thanks for the correction!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36155032" class="c"><input type="checkbox" id="c-36155032" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36154995">parent</a><span>|</span><a href="#36155054">prev</a><span>|</span><a href="#36161246">next</a><span>|</span><label class="collapse" for="c-36155032">[-]</label><label class="expand" for="c-36155032">[2 more]</label></div><br/><div class="children"><div class="content">that would suggest it&#x27;s an &quot;enduring innovation&quot; as per the question</div><br/><div id="36155053" class="c"><input type="checkbox" id="c-36155053" checked=""/><div class="controls bullet"><span class="by">Lyngbakr</span><span>|</span><a href="#36154867">root</a><span>|</span><a href="#36155032">parent</a><span>|</span><a href="#36161246">next</a><span>|</span><label class="collapse" for="c-36155053">[-]</label><label class="expand" for="c-36155053">[1 more]</label></div><br/><div class="children"><div class="content">But the previous post argues that the article is about &quot;lisp features that still make it unique&quot;.</div><br/></div></div></div></div></div></div><div id="36161246" class="c"><input type="checkbox" id="c-36161246" checked=""/><div class="controls bullet"><span class="by">deckard1</span><span>|</span><a href="#36154867">parent</a><span>|</span><a href="#36154995">prev</a><span>|</span><a href="#36157436">next</a><span>|</span><label class="collapse" for="c-36161246">[-]</label><label class="expand" for="c-36161246">[1 more]</label></div><br/><div class="children"><div class="content">Forth.</div><br/></div></div></div></div><div id="36157436" class="c"><input type="checkbox" id="c-36157436" checked=""/><div class="controls bullet"><span class="by">sbjs</span><span>|</span><a href="#36154867">prev</a><span>|</span><a href="#36156483">next</a><span>|</span><label class="collapse" for="c-36157436">[-]</label><label class="expand" for="c-36157436">[4 more]</label></div><br/><div class="children"><div class="content">Everything worthwhile about Lisp has been integrated into TypeScript and JavaScript.</div><br/><div id="36157853" class="c"><input type="checkbox" id="c-36157853" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36157436">parent</a><span>|</span><a href="#36159193">next</a><span>|</span><label class="collapse" for="c-36157853">[-]</label><label class="expand" for="c-36157853">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the same way everything worthwhile about spring water can be found in mud.</div><br/></div></div><div id="36159193" class="c"><input type="checkbox" id="c-36159193" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36157436">parent</a><span>|</span><a href="#36157853">prev</a><span>|</span><a href="#36159918">next</a><span>|</span><label class="collapse" for="c-36159193">[-]</label><label class="expand" for="c-36159193">[1 more]</label></div><br/><div class="children"><div class="content">Extending the JavaScript grammar into a domain-specific language, and then generating conforming code to run, almost requires adding Babel.js to your build and then doing a lot more work than writing a Lisp macro. Most devs probably never will.</div><br/></div></div><div id="36159918" class="c"><input type="checkbox" id="c-36159918" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#36157436">parent</a><span>|</span><a href="#36159193">prev</a><span>|</span><a href="#36156483">next</a><span>|</span><label class="collapse" for="c-36159918">[-]</label><label class="expand" for="c-36159918">[1 more]</label></div><br/><div class="children"><div class="content">Not homoiconicity and macros. And in the case of TypeScript, not interactivity.<p>Besides that, Mrs. Lincoln, how did you enjoy the play?</div><br/></div></div></div></div><div id="36156483" class="c"><input type="checkbox" id="c-36156483" checked=""/><div class="controls bullet"><span class="by">AtNightWeCode</span><span>|</span><a href="#36157436">prev</a><span>|</span><label class="collapse" for="c-36156483">[-]</label><label class="expand" for="c-36156483">[9 more]</label></div><br/><div class="children"><div class="content">Useless parentheses?</div><br/><div id="36159352" class="c"><input type="checkbox" id="c-36159352" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#36156483">parent</a><span>|</span><a href="#36162619">next</a><span>|</span><label class="collapse" for="c-36159352">[-]</label><label class="expand" for="c-36159352">[2 more]</label></div><br/><div class="children"><div class="content">Sigh.
How many parentheses does this have:<p><pre><code>    myFn(x,y,z);
</code></pre>
vs.<p><pre><code>    (myFn x y z)</code></pre></div><br/><div id="36162292" class="c"><input type="checkbox" id="c-36162292" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36156483">root</a><span>|</span><a href="#36159352">parent</a><span>|</span><a href="#36162619">next</a><span>|</span><label class="collapse" for="c-36162292">[-]</label><label class="expand" for="c-36162292">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s strawmanning. Indeed, function calling needs the same amount of parentheses. But literally every popular languages (C&#x2F;C++&#x2F;Java&#x2F;Javascript) have syntactic clues for :<p><pre><code>     - assigning values to variables
     - function definitions
     - denoting elements of structures
     - if, for and while control flow
     - fields of structs or objects
     - etc
</code></pre>
Which also play a huge role in structured&#x2F;OOP programming. Less popular languages usually have syntactic clues for the important parts of their paradigm.<p>Once I transpiled the example code from the Janet site[0] to Python (I don&#x27;t speak Janet.) You can compare them, and count the parentheses, and the syntactic clues in general: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34846516" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34846516</a><p>[0] : <a href="https:&#x2F;&#x2F;janet-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;janet-lang.org&#x2F;</a></div><br/></div></div></div></div><div id="36162619" class="c"><input type="checkbox" id="c-36162619" checked=""/><div class="controls bullet"><span class="by">eimrine</span><span>|</span><a href="#36156483">parent</a><span>|</span><a href="#36159352">prev</a><span>|</span><a href="#36160235">next</a><span>|</span><label class="collapse" for="c-36162619">[-]</label><label class="expand" for="c-36162619">[1 more]</label></div><br/><div class="children"><div class="content">Try Programmer Dvorak if you are too bothered with pressing Shift.</div><br/></div></div><div id="36160235" class="c"><input type="checkbox" id="c-36160235" checked=""/><div class="controls bullet"><span class="by">sigjuice</span><span>|</span><a href="#36156483">parent</a><span>|</span><a href="#36162619">prev</a><span>|</span><a href="#36156712">next</a><span>|</span><label class="collapse" for="c-36160235">[-]</label><label class="expand" for="c-36160235">[1 more]</label></div><br/><div class="children"><div class="content">It is quite the opposite.  Every pair is meaningful.  Extra parenthesis cannot be added just for the heck of it without changing the meaning of the code.</div><br/></div></div><div id="36156712" class="c"><input type="checkbox" id="c-36156712" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#36156483">parent</a><span>|</span><a href="#36160235">prev</a><span>|</span><a href="#36158529">next</a><span>|</span><label class="collapse" for="c-36156712">[-]</label><label class="expand" for="c-36156712">[2 more]</label></div><br/><div class="children"><div class="content">There are many parentheses, but they&#x27;re hardly useless.</div><br/><div id="36156780" class="c"><input type="checkbox" id="c-36156780" checked=""/><div class="controls bullet"><span class="by">AtNightWeCode</span><span>|</span><a href="#36156483">root</a><span>|</span><a href="#36156712">parent</a><span>|</span><a href="#36158529">next</a><span>|</span><label class="collapse" for="c-36156780">[-]</label><label class="expand" for="c-36156780">[1 more]</label></div><br/><div class="children"><div class="content">Love to meet you at a party! ;) Cheers!</div><br/></div></div></div></div><div id="36158529" class="c"><input type="checkbox" id="c-36158529" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#36156483">parent</a><span>|</span><a href="#36156712">prev</a><span>|</span><label class="collapse" for="c-36158529">[-]</label><label class="expand" for="c-36158529">[2 more]</label></div><br/><div class="children"><div class="content">My nickname for Clojure&#x2F;Lisp is (parenthetical hell).</div><br/><div id="36159553" class="c"><input type="checkbox" id="c-36159553" checked=""/><div class="controls bullet"><span class="by">shaunxcode</span><span>|</span><a href="#36156483">root</a><span>|</span><a href="#36158529">parent</a><span>|</span><label class="collapse" for="c-36159553">[-]</label><label class="expand" for="c-36159553">[1 more]</label></div><br/><div class="children"><div class="content">(nirvana (in hand))</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>