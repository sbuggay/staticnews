<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687338073373" as="style"/><link rel="stylesheet" href="styles.css?v=1687338073373"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yotam.net/posts/linux-namespaces-are-a-poor-mans-plan9-namespaces/">Linux Namespaces Are a Poor Man&#x27;s Plan 9 Namespaces</a> <span class="domain">(<a href="https://yotam.net">yotam.net</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>74 comments</span></div><br/><div><div id="36415572" class="c"><input type="checkbox" id="c-36415572" checked=""/><div class="controls bullet"><span class="by">afr0ck</span><span>|</span><a href="#36414699">next</a><span>|</span><label class="collapse" for="c-36415572">[-]</label><label class="expand" for="c-36415572">[5 more]</label></div><br/><div class="children"><div class="content">The simple, everything is a file, model of Plan9 is what makes the namespaces API as clear and as general as it is. All the objects export the same file API. Every interaction with the OS objects is done through file open, create, read, write, etc. But it has it&#x27;s drawbacks.<p>First, it&#x27;s not always easy to map every object operation into either an open read or write. With time, we should have seen a lot of ugly interfaces resulting from this limitation.<p>Second, hardware progress, the web, etc., introduced a lot of heterogeneity and complexity. People could no more keep up with simple general designs. And to squeeze every bit of performance, everyone was doing things different based on the hardware and the workloads. They use whatever makes their software, drivers, and OS objects work as fast as they could.<p>And this is how we ended with the extreme fragmentation and heterogeneity we have in Linux, which explains the complex and less general implementation of its namespaces and its other features.<p>Edit: fix typos</div><br/><div id="36415853" class="c"><input type="checkbox" id="c-36415853" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#36415572">parent</a><span>|</span><a href="#36415797">next</a><span>|</span><label class="collapse" for="c-36415853">[-]</label><label class="expand" for="c-36415853">[2 more]</label></div><br/><div class="children"><div class="content">&gt; First, it&#x27;s not always easy to map every object operation into either an open read or write.<p>It doesn&#x27;t seem like it.  Linux has a habit of multiplexing alternate functions through a single handle with additional and somewhat scary methods like ioctl.  Plan9 manages this with servers, directories, and more than one path available for a single resource depending on what you&#x27;re trying to access.  This is far more sane.<p>&gt; With time, we should have seen a lot of ugly interfaces resulting from this limitation.<p>They don&#x27;t seem any more complicated than they need to be.  Compare implementing a fuse server vs implementing a plan9 server.  Yet I don&#x27;t see where all of this complication adds anything or enables implementation of technologies that couldn&#x27;t be implemented on plan9 with a few additional paths.<p>&gt; People could no more keep up with simple general designs. And to squeeze every bit of performance,<p>These are contrary goals,  and I&#x27;m not sure what you mean people can&#x27;t &quot;keep up&quot; with &quot;general designs.&quot;  What is there to &quot;keep up&quot; with?  And in exchange for that performance we got one of the most insane &#x2F;class&#x2F; of unfixable CPU bugs ever imagined.<p>&gt; And this is how we ended with the extreme fragmentation and heterogeneity we have in Linux,<p>And yet..  many of these systems are now being unified into generalized file descriptor based systems,  that have wacky open methods,  but boil down to allowing simpler interfaces through read(2) and write(2).</div><br/><div id="36416036" class="c"><input type="checkbox" id="c-36416036" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#36415572">root</a><span>|</span><a href="#36415853">parent</a><span>|</span><a href="#36415797">next</a><span>|</span><label class="collapse" for="c-36416036">[-]</label><label class="expand" for="c-36416036">[1 more]</label></div><br/><div class="children"><div class="content">For an example, most high performance devices expose functionality as memory locations mapped into the CPU address space. In many cases it&#x27;s necessary to allow userspace direct access to (part of) the memory the device exposes, such as with GPU&#x27;s, RDMA NIC&#x27;s and so forth. Not sure you could get high performance with a read&#x2F;write stream based interface, as conceptually elegant such an interface is.</div><br/></div></div></div></div><div id="36415797" class="c"><input type="checkbox" id="c-36415797" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36415572">parent</a><span>|</span><a href="#36415853">prev</a><span>|</span><a href="#36414699">next</a><span>|</span><label class="collapse" for="c-36415797">[-]</label><label class="expand" for="c-36415797">[2 more]</label></div><br/><div class="children"><div class="content">&gt; First, it&#x27;s not always easy to map every object operation into either an open read or write.<p>Heck, even for basic files on disk, and even more so for sockets, the traditional open&#x2F;read&#x2F;write&#x2F;close is starting to feel not so great. There is reason why iouring is hailed as the second coming, and it solves just part of the problems; stuff like fsync apocalypse comes to mind.<p>And ioctls are imho completely disgusting hack.<p>Ultimately IO is intrinsically complex topic, and trying to paper over that complexity with simple interfaces is disingenuous and falls flat on edge cases.</div><br/><div id="36416013" class="c"><input type="checkbox" id="c-36416013" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#36415572">root</a><span>|</span><a href="#36415797">parent</a><span>|</span><a href="#36414699">next</a><span>|</span><label class="collapse" for="c-36416013">[-]</label><label class="expand" for="c-36416013">[1 more]</label></div><br/><div class="children"><div class="content">io_uring is a more modern API to file access. Actually I think it would be great if everything was a file and the communication with the kernel was only with io_uring.</div><br/></div></div></div></div></div></div><div id="36414699" class="c"><input type="checkbox" id="c-36414699" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#36415572">prev</a><span>|</span><a href="#36416022">next</a><span>|</span><label class="collapse" for="c-36414699">[-]</label><label class="expand" for="c-36414699">[52 more]</label></div><br/><div class="children"><div class="content">As of someone who discovered Plan 9 far too late to do anything about it: everything is a poor man&#x27;s Plan 9 something. Everything. All of it.<p>Plan 9 lived in the goddamned future.</div><br/><div id="36416114" class="c"><input type="checkbox" id="c-36416114" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36414777">next</a><span>|</span><label class="collapse" for="c-36416114">[-]</label><label class="expand" for="c-36416114">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t everyone design a <i>better</i> OS than the current operating systems? More features, easier to use as a user, safer, easier to write programs for it, less bugs, more compatibility, etc. I am using operating systems for years, and I have ideas how they should work on the surface.<p>But it will be slower, and won&#x27;t have any useful software written for it, also you won&#x27;t be able to use internet or  your GPU. (To be fair several years ago I tried the HURD distribution ArchHurd. I just installed on it on my laptop, and by luck internet just worked, and had a firefox running so it was good.)</div><br/></div></div><div id="36414777" class="c"><input type="checkbox" id="c-36414777" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36416114">prev</a><span>|</span><a href="#36415189">next</a><span>|</span><label class="collapse" for="c-36414777">[-]</label><label class="expand" for="c-36414777">[33 more]</label></div><br/><div class="children"><div class="content">Looking at the Unix to Plan 9 translation [1] gives me a different opinion. To name one egregious example, omitting find(1) in favor of piping du(1) (what is supposed to be a disk usage analyzer) to grep(1) is not an improvement; it&#x27;s just user-unfriendliness in service of minimalist aesthetics. (Contrary to popular belief, find(1) is not a particularly &quot;bloated&quot; program; Rust&#x27;s &quot;fd&quot; implementation is under 7,000 lines of code [2], about a third of the size of Lua.)<p>[1]: <a href="https:&#x2F;&#x2F;9p.io&#x2F;wiki&#x2F;plan9&#x2F;Unix_to_Plan_9_command_translation&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;9p.io&#x2F;wiki&#x2F;plan9&#x2F;Unix_to_Plan_9_command_translation&#x2F;...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd">https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd</a></div><br/><div id="36414838" class="c"><input type="checkbox" id="c-36414838" checked=""/><div class="controls bullet"><span class="by">floren</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36415078">next</a><span>|</span><label class="collapse" for="c-36414838">[-]</label><label class="expand" for="c-36414838">[12 more]</label></div><br/><div class="children"><div class="content">I got used to `du | grep` after using Plan 9 a lot and still do it on Linux, but yeah really I think Plan 9 fans have had a tendency to ossify the pragmatic minimalism of the Bell Labs guys into a sort of cultishness... there&#x27;s no reason we couldn&#x27;t have find on Plan 9, but now it&#x27;s almost a religious point not to have it.<p>On the other hand, the lack of find is not a particularly good rebuttal to the original point. If I rolled up in a prototype personal transport which could go 1000 miles on a single AA battery, would you complain that the seats were poorly stitched?</div><br/><div id="36414870" class="c"><input type="checkbox" id="c-36414870" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414838">parent</a><span>|</span><a href="#36415441">next</a><span>|</span><label class="collapse" for="c-36414870">[-]</label><label class="expand" for="c-36414870">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If I rolled up in a prototype personal transport which could go 1000 miles on a single AA battery, would you complain that the seats were poorly stitched?<p>If the poor stitching were taken as a point of pride and the community refused to fix it, then yeah, I&#x27;d assume that that community values purity over practicality. Which is exactly how I feel about Plan 9: it had good ideas and was an improvement over Unix in many ways, but it was a regression in others, in large part due to choosing minimalist aesthetics over usability.</div><br/><div id="36414882" class="c"><input type="checkbox" id="c-36414882" checked=""/><div class="controls bullet"><span class="by">floren</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414870">parent</a><span>|</span><a href="#36415135">next</a><span>|</span><label class="collapse" for="c-36414882">[-]</label><label class="expand" for="c-36414882">[2 more]</label></div><br/><div class="children"><div class="content">But the fact is that you could get a decent find into Plan 9 in a day&#x27;s work. Hell, you could probably just compile some existing Go version of find without any changes. Trying to get Plan 9-style namespaces into Linux is not nearly so trivial.</div><br/><div id="36415061" class="c"><input type="checkbox" id="c-36415061" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414882">parent</a><span>|</span><a href="#36415135">next</a><span>|</span><label class="collapse" for="c-36415061">[-]</label><label class="expand" for="c-36415061">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about &quot;find&quot; in particular, that was just an example brought up to illustrate the general point. If &quot;find&quot; was the only thing missing to bring Plan9 up to Linux usability standards, that would indeed be easy to fix.</div><br/></div></div></div></div><div id="36415135" class="c"><input type="checkbox" id="c-36415135" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414870">parent</a><span>|</span><a href="#36414882">prev</a><span>|</span><a href="#36415441">next</a><span>|</span><label class="collapse" for="c-36415135">[-]</label><label class="expand" for="c-36415135">[1 more]</label></div><br/><div class="children"><div class="content">The big lesson Plan 9 seemed to have learned is that maintenance is a drag and a hinderance. find may be objectively better than du | grep for the user, but once introduced then the developers have to essentially maintain the same thing twice and carry that baggage forever into the future.<p>In a parallel universe where Unix did not take on so much baggage, perhaps it could have even naturally evolved towards Plan 9 and Plan 9 would have not been a necessary break. But then, like Plan 9, maybe Unix would have never rose up to see any widespread use to make that evolution significant.<p>Tradeoffs, as always.</div><br/></div></div></div></div><div id="36415441" class="c"><input type="checkbox" id="c-36415441" checked=""/><div class="controls bullet"><span class="by">amoss</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414838">parent</a><span>|</span><a href="#36414870">prev</a><span>|</span><a href="#36414860">next</a><span>|</span><label class="collapse" for="c-36415441">[-]</label><label class="expand" for="c-36415441">[4 more]</label></div><br/><div class="children"><div class="content">The thing that I use find for most commonly is to perform a hierarchical grep, i.e<p>find . -exec grep -Hn regex \{\} \;<p>How would you do that with the du | grep combo?</div><br/><div id="36415792" class="c"><input type="checkbox" id="c-36415792" checked=""/><div class="controls bullet"><span class="by">geosh</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415441">parent</a><span>|</span><a href="#36415906">next</a><span>|</span><label class="collapse" for="c-36415792">[-]</label><label class="expand" for="c-36415792">[2 more]</label></div><br/><div class="children"><div class="content">... | xargs grep -Hn regex<p>This will also be faster, because you fork less.</div><br/><div id="36416027" class="c"><input type="checkbox" id="c-36416027" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415792">parent</a><span>|</span><a href="#36415906">next</a><span>|</span><label class="collapse" for="c-36416027">[-]</label><label class="expand" for="c-36416027">[1 more]</label></div><br/><div class="children"><div class="content">Using \+ instead of \; will do the same (fork less).<p>du -a will need to do a stat to get the file size, which is comparatively expensive; I don&#x27;t think find will (not sure)?</div><br/></div></div></div></div><div id="36415906" class="c"><input type="checkbox" id="c-36415906" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415441">parent</a><span>|</span><a href="#36415792">prev</a><span>|</span><a href="#36414860">next</a><span>|</span><label class="collapse" for="c-36415906">[-]</label><label class="expand" for="c-36415906">[1 more]</label></div><br/><div class="children"><div class="content">grep -R</div><br/></div></div></div></div><div id="36414860" class="c"><input type="checkbox" id="c-36414860" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414838">parent</a><span>|</span><a href="#36415441">prev</a><span>|</span><a href="#36415078">next</a><span>|</span><label class="collapse" for="c-36414860">[-]</label><label class="expand" for="c-36414860">[3 more]</label></div><br/><div class="children"><div class="content">Realistically yes. But I would still use it.</div><br/><div id="36415196" class="c"><input type="checkbox" id="c-36415196" checked=""/><div class="controls bullet"><span class="by">thesuitonym</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414860">parent</a><span>|</span><a href="#36415078">next</a><span>|</span><label class="collapse" for="c-36415196">[-]</label><label class="expand" for="c-36415196">[2 more]</label></div><br/><div class="children"><div class="content">Would, but don&#x27;t?</div><br/><div id="36415791" class="c"><input type="checkbox" id="c-36415791" checked=""/><div class="controls bullet"><span class="by">deely3</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415196">parent</a><span>|</span><a href="#36415078">next</a><span>|</span><label class="collapse" for="c-36415791">[-]</label><label class="expand" for="c-36415791">[1 more]</label></div><br/><div class="children"><div class="content">Would complain, and would use it.</div><br/></div></div></div></div></div></div></div></div><div id="36415078" class="c"><input type="checkbox" id="c-36415078" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36414838">prev</a><span>|</span><a href="#36414800">next</a><span>|</span><label class="collapse" for="c-36415078">[-]</label><label class="expand" for="c-36415078">[1 more]</label></div><br/><div class="children"><div class="content">The new kid just learned to walk(1).<p><a href="http:&#x2F;&#x2F;git.9front.org&#x2F;plan9front&#x2F;plan9front&#x2F;HEAD&#x2F;sys&#x2F;src&#x2F;cmd&#x2F;walk.c&#x2F;f.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;git.9front.org&#x2F;plan9front&#x2F;plan9front&#x2F;HEAD&#x2F;sys&#x2F;src&#x2F;cmd...</a><p>329 lines of code.</div><br/></div></div><div id="36414800" class="c"><input type="checkbox" id="c-36414800" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36415078">prev</a><span>|</span><a href="#36415362">next</a><span>|</span><label class="collapse" for="c-36414800">[-]</label><label class="expand" for="c-36414800">[15 more]</label></div><br/><div class="children"><div class="content">The problem with find is that it tries to put an entire programing language into its arguments.</div><br/><div id="36414856" class="c"><input type="checkbox" id="c-36414856" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414800">parent</a><span>|</span><a href="#36415699">next</a><span>|</span><label class="collapse" for="c-36414856">[-]</label><label class="expand" for="c-36414856">[5 more]</label></div><br/><div class="children"><div class="content">Is that a problem?  A simple tool is good if it can solve complex problems, but a simple tool that can&#x27;t is just an underdeveloped tool.  Sometimes you need a complex tool to solve a complex problem.<p>I think a good mini language bridges the gap between interactive commands and programming.  Sometimes you need to spend an hour writing a program to do something complicated.  But because of various &quot;extraneous features&quot; built into UNIX commands, you rarely need to spend an hour manually poking at the filesystem.  The mini language gets you almost as productive as a full-fledged programming language, without feeling like you&#x27;re programming.  (How do you know you&#x27;re programming?  If you &quot;git init&quot; and start committing stuff, you&#x27;re probably programming.  If your carefully-crafted thing scrolls into .history obscurity, then you&#x27;re interacting.)</div><br/><div id="36415210" class="c"><input type="checkbox" id="c-36415210" checked=""/><div class="controls bullet"><span class="by">foul</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414856">parent</a><span>|</span><a href="#36415083">next</a><span>|</span><label class="collapse" for="c-36415210">[-]</label><label class="expand" for="c-36415210">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I think a good mini language bridges the gap between interactive commands and programming.<p>find(1) is a bad mini language. Its arguments are in a legacy format and its solution for composability is a hack, and an unstable one.</div><br/></div></div><div id="36415083" class="c"><input type="checkbox" id="c-36415083" checked=""/><div class="controls bullet"><span class="by">exitb</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414856">parent</a><span>|</span><a href="#36415210">prev</a><span>|</span><a href="#36415096">next</a><span>|</span><label class="collapse" for="c-36415083">[-]</label><label class="expand" for="c-36415083">[2 more]</label></div><br/><div class="children"><div class="content">Find is not simple - it&#x27;s easy, but internally complex. It&#x27;s fine to solve a complex problem with a complex tool, but it&#x27;s troublesome when people mostly use it to solve simple problems. And the trouble is that this kind of approach spreads to every single component in the system, which means that we&#x27;re using insane amount of code and cpu load to solve really simple problems on daily basis.<p>Plan 9 is not an answer to every problem, but it&#x27;s just impressive how much it can do with so little code.</div><br/><div id="36416120" class="c"><input type="checkbox" id="c-36416120" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415083">parent</a><span>|</span><a href="#36415096">next</a><span>|</span><label class="collapse" for="c-36416120">[-]</label><label class="expand" for="c-36416120">[1 more]</label></div><br/><div class="children"><div class="content"><i>…we&#x27;re using insane amount of code and cpu load to solve really simple problems on daily basis.</i><p>Piping programs together is almost always going to use significantly more resources than one program doing it all. More code doesn’t necessarily imply more resource usage.<p><i>Plan 9 is not an answer to every problem, but it&#x27;s just impressive how much it can do with so little code.</i><p>I don’t want to be all around negative about plan 9, but I don’t see it as really solving any interesting problems. Indeed it is far easier to write slim, elegant systems when forgoing feature parity and&#x2F;or competitive performance.</div><br/></div></div></div></div><div id="36415096" class="c"><input type="checkbox" id="c-36415096" checked=""/><div class="controls bullet"><span class="by">t0suj4</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414856">parent</a><span>|</span><a href="#36415083">prev</a><span>|</span><a href="#36415699">next</a><span>|</span><label class="collapse" for="c-36415096">[-]</label><label class="expand" for="c-36415096">[1 more]</label></div><br/><div class="children"><div class="content">After staring down find(1) on an AIX system I regret not going down the du | grep path. At least that way I wouldn&#x27;t be stuck trying to mash GNU&#x27;s parameters into completely incompatible version of find.</div><br/></div></div></div></div><div id="36415699" class="c"><input type="checkbox" id="c-36415699" checked=""/><div class="controls bullet"><span class="by">didntcheck</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414800">parent</a><span>|</span><a href="#36414856">prev</a><span>|</span><a href="#36414973">next</a><span>|</span><label class="collapse" for="c-36415699">[-]</label><label class="expand" for="c-36415699">[3 more]</label></div><br/><div class="children"><div class="content">Sure, which lends weight to the idea that the shell <i>should</i> be a more extensive programming language. Then you can pass an arbitrary Predicate&lt;File&gt; to the finder (which would likely just be a convenience function of about 5-20 lines), and receive a list of file objects for you to do what you want with<p>That&#x27;s the direction Powershell took, and to some extent was what other OSes were doing at the time of Unix. But Unix has become so ubiquitous and influential that we&#x27;ve forgotten that programs could pass more than ill-specified strings around, and that resources could implement richer interfaces rather than trying to force the file IO interface on every single one, regardless of how little sense that makes<p>Worse is Better may have been a useful expedience in the 20th century, but we&#x27;re long overdue repaying that technical dept, to get back some of the rich OS&#x2F;environment features that other camps had got working almost half a century ago. The first step would be to stop putting &quot;Unix philosophy&quot; on a throne</div><br/><div id="36416038" class="c"><input type="checkbox" id="c-36416038" checked=""/><div class="controls bullet"><span class="by">iopq</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415699">parent</a><span>|</span><a href="#36415860">next</a><span>|</span><label class="collapse" for="c-36416038">[-]</label><label class="expand" for="c-36416038">[1 more]</label></div><br/><div class="children"><div class="content">Unix being stringly-typed is a huge problem.<p>For example, I found a flatpak of a system monitor and thought it was portable. Turns out, it parses `ps` output directly, but it&#x27;s not compatible with BusyBox `ps` output<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hakandundar34coding&#x2F;system-monitoring-center&#x2F;issues&#x2F;168#">https:&#x2F;&#x2F;github.com&#x2F;hakandundar34coding&#x2F;system-monitoring-cen...</a><p>the author literally doesn&#x27;t care since it works with coreutils `ps`<p>it&#x27;s a culture problem</div><br/></div></div><div id="36415860" class="c"><input type="checkbox" id="c-36415860" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415699">parent</a><span>|</span><a href="#36416038">prev</a><span>|</span><a href="#36414973">next</a><span>|</span><label class="collapse" for="c-36415860">[-]</label><label class="expand" for="c-36415860">[1 more]</label></div><br/><div class="children"><div class="content">&quot;That&#x27;s the direction Powershell took, and to some extent was what other OSes were doing at the time of Unix. But Unix has become so ubiquitous and influential that we&#x27;ve forgotten that programs could pass more than ill-specified strings around ... The first step would be to stop putting &quot;Unix philosophy&quot; on a throne &quot;<p>Well yes, but I think it will be hard or rather impossible to convince the unix crowd of anything good coming from windows.</div><br/></div></div></div></div><div id="36414973" class="c"><input type="checkbox" id="c-36414973" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414800">parent</a><span>|</span><a href="#36415699">prev</a><span>|</span><a href="#36414832">next</a><span>|</span><label class="collapse" for="c-36414973">[-]</label><label class="expand" for="c-36414973">[2 more]</label></div><br/><div class="children"><div class="content">And it makes easy things hard.<p>All the time arguments and size parameters and rules about depth and boolean syntax and the print0 for pipeline integration ... it makes me long for DOS interfaces from the 80s. There has to be a way to do it with less intellectual lifting every time.<p>Maybe just a simple set of bash reads will help - that&#x27;s how I do ssh port forwarding - I was tired of getting confused.<p>Integration with &#x2F;etc&#x2F;mime would be nice as well so I can just search for, say, &quot;image&quot; or &quot;video&quot;. (This would be at the frontend in this (currently) fictional helper script)</div><br/><div id="36415358" class="c"><input type="checkbox" id="c-36415358" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414973">parent</a><span>|</span><a href="#36414832">next</a><span>|</span><label class="collapse" for="c-36415358">[-]</label><label class="expand" for="c-36415358">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and the print0 for pipeline integration<p>The existence of things like `-print0` is the downside of Unix&#x27;s &quot;all files&#x2F;pipes are byte streams&quot; design decision.<p>The IBM mainframe implementation of the pipeline idea – CMS Pipelines [0] – makes pipes record-based instead. Since the pipes are not streams of bytes, rather records with out-of-band boundaries, there is no need to reserve a special character (whether LF or NUL) to serve as a record separator.<p>&gt; Integration with &#x2F;etc&#x2F;mime would be nice as well so I can just search for, say, &quot;image&quot; or &quot;video&quot;<p>It is a pity that Unix never had a &quot;file type&quot; field in the filesystem, unlike classic MacOS, Acorn RISC OS, among others. I suppose both those systems had the limitation that the file type was just a number, subsequent experience has demonstrated it needs to be a much longer string (such as a MIME type or Apple UTI). The problem with file extensions is the same extension ends up being used by completely unrelated applications for completely unrelated file formats – e.g. nowadays .doc is normally assumed to be legacy binary Microsoft Word, but many older archives it is a plain text file instead, or sometimes even some other word processing format.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CMS_Pipelines" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CMS_Pipelines</a></div><br/></div></div></div></div><div id="36414832" class="c"><input type="checkbox" id="c-36414832" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414800">parent</a><span>|</span><a href="#36414973">prev</a><span>|</span><a href="#36414897">next</a><span>|</span><label class="collapse" for="c-36414832">[-]</label><label class="expand" for="c-36414832">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you to some extent, but the solution is fd: change the tool&#x27;s interface to make simple things easy. Deleting the tool entirely does nobody any favors. As bad as find(1) is for simple stuff, piping du(1) to grep(1) is worse.</div><br/><div id="36415306" class="c"><input type="checkbox" id="c-36415306" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414832">parent</a><span>|</span><a href="#36414897">next</a><span>|</span><label class="collapse" for="c-36415306">[-]</label><label class="expand" for="c-36415306">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s half of the solution.  The other half, I&#x27;m convinced, will be a tool that makes complex things possible.  After all, if I really need some complex filtering, find&#x27;s primitive logical operators probably wouldn&#x27;t even be sufficient.  To that end, I love how Nushell&#x27;s leading example on their home page is<p><pre><code>    ls | where size &gt; 10mb | sort-by modified
</code></pre>
It seems so elegant!  Down with strings!  …But it&#x27;s not my life yet, since last time I wanted to try Nushell they didn&#x27;t have scripting yet, and I have yet to circle back around to it.  There&#x27;s also Elvish and PowerShell and Oil Shell but they all have their own issues.</div><br/></div></div></div></div><div id="36414897" class="c"><input type="checkbox" id="c-36414897" checked=""/><div class="controls bullet"><span class="by">amstan</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414800">parent</a><span>|</span><a href="#36414832">prev</a><span>|</span><a href="#36415362">next</a><span>|</span><label class="collapse" for="c-36414897">[-]</label><label class="expand" for="c-36414897">[2 more]</label></div><br/><div class="children"><div class="content">Hear hear. When I use find I only use it for the recursive dir listing with no arguments. I always pipe it into grep because I know grep better.</div><br/><div id="36415440" class="c"><input type="checkbox" id="c-36415440" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414897">parent</a><span>|</span><a href="#36415362">next</a><span>|</span><label class="collapse" for="c-36415440">[-]</label><label class="expand" for="c-36415440">[1 more]</label></div><br/><div class="children"><div class="content">Hard to grep a list of path names for size or last modification date?<p>When I saw the start of this thread, I thought abusing &quot;du&quot; for &quot;find&quot; sounded insane - but after mulling it over - I guess du is just a recursive stat(1).<p>And I can see the logic; have a tool that builds a tree of metadata, filter with a tool that... filters.<p>However - as far as i can tell, du&#x2F;grep on plan9 can&#x27;t fill in for find(1) - but the <i>idea</i> (above) would probably fit with PowerShell or other &quot;typed&#x2F;rich streams&quot; kind of shell...<p><a href="https:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;grep" rel="nofollow noreferrer">https:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;grep</a><p><a href="https:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;du" rel="nofollow noreferrer">https:&#x2F;&#x2F;man.cat-v.org&#x2F;plan_9&#x2F;1&#x2F;du</a></div><br/></div></div></div></div></div></div><div id="36415362" class="c"><input type="checkbox" id="c-36415362" checked=""/><div class="controls bullet"><span class="by">foul</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36414800">prev</a><span>|</span><a href="#36415341">next</a><span>|</span><label class="collapse" for="c-36415362">[-]</label><label class="expand" for="c-36415362">[1 more]</label></div><br/><div class="children"><div class="content">Yeah find is a bad example for bloat, compared to GNU echo or GNU yes. find AFAIK is mentioned more for horror stories, Bernstein insults, as an example for alien parts of UNIX-like OSes which prevent from a streamlined, predictable-in-your-head experience. &quot;It isn&#x27;t windows server&quot;, a statement which devoids of meaning sometimes with powershell and with Azure cloud apis, but eh.</div><br/></div></div><div id="36415341" class="c"><input type="checkbox" id="c-36415341" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36415362">prev</a><span>|</span><a href="#36415226">next</a><span>|</span><label class="collapse" for="c-36415341">[-]</label><label class="expand" for="c-36415341">[1 more]</label></div><br/><div class="children"><div class="content">I would guess the minimalism was a practical choice at the time, given it was a pretty small team making an entire OS. Had Plan 9 ever become some kind of commercial (or even open source) success, I&#x27;m sure a find command would eventually have found its way in.</div><br/></div></div><div id="36415226" class="c"><input type="checkbox" id="c-36415226" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414777">parent</a><span>|</span><a href="#36415341">prev</a><span>|</span><a href="#36415189">next</a><span>|</span><label class="collapse" for="c-36415226">[-]</label><label class="expand" for="c-36415226">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps depends on your definition of “user friendly” - Find is certainly not going to be at the top of my own list. Half the time I use ls -lR | grep because I can’t be bothered to rediscover the right find option - which won’t even do what I want the first time I try it.</div><br/><div id="36415336" class="c"><input type="checkbox" id="c-36415336" checked=""/><div class="controls bullet"><span class="by">vbernat</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415226">parent</a><span>|</span><a href="#36415189">next</a><span>|</span><label class="collapse" for="c-36415336">[-]</label><label class="expand" for="c-36415336">[1 more]</label></div><br/><div class="children"><div class="content">Then you can use &quot;find | grep&quot;.</div><br/></div></div></div></div></div></div><div id="36415189" class="c"><input type="checkbox" id="c-36415189" checked=""/><div class="controls bullet"><span class="by">thesuitonym</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36414777">prev</a><span>|</span><a href="#36415378">next</a><span>|</span><label class="collapse" for="c-36415189">[-]</label><label class="expand" for="c-36415189">[1 more]</label></div><br/><div class="children"><div class="content">I once saw Plan 9 described as &quot;Imagine if all the stuff they told you about Unix was true.&quot;<p>Edit to add: I don&#x27;t know that this actually makes Plan 9 better, but I&#x27;m pretty sure it doesn&#x27;t make it worse (Although from our perspective in 2023, it&#x27;s definitely alien and difficult)</div><br/></div></div><div id="36415378" class="c"><input type="checkbox" id="c-36415378" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36415189">prev</a><span>|</span><a href="#36415455">next</a><span>|</span><label class="collapse" for="c-36415378">[-]</label><label class="expand" for="c-36415378">[2 more]</label></div><br/><div class="children"><div class="content">Plan 9 had many improvements over Unix of its times. It opened up too late to conquer the world though. Some good things from it were imported into Solaris and Linux later.<p>Technological progress likes to reinvent itself, looping back to the same idea that did not work last time, and maybe making it a hit finally. Two examples:<p>- Apple Newton, 1992 (a flop) -&gt; Palm Pilot, 1997 (niche success) -&gt; Apple iPhone, 2007 (world domination).<p>- Java Virtual Machine, 1994 (server-side world domination, a flop in the browser) -&gt; Inferno OS, from the makers of Unix and Plan9, 1996 (a flop) -&gt; WASM (prospects of world domination in the browser).</div><br/><div id="36415492" class="c"><input type="checkbox" id="c-36415492" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415378">parent</a><span>|</span><a href="#36415455">next</a><span>|</span><label class="collapse" for="c-36415492">[-]</label><label class="expand" for="c-36415492">[1 more]</label></div><br/><div class="children"><div class="content">I personally don&#x27;t like WASM. I think the Native Client (which is more than a decade old today) was a much better technical solution. It used actual cpu native assembly bundled with a verifier, and had actual good integration into low-level platform APIs like graphics, threading, etc. instead of using this weird Javascript bridge approach. Due to it being native code from the start, it also had none of the startup performance issues, that plague WebAssembly.<p>WASI also seems like a wrong approach, considering it inherits the limitations 
of WASM, like problems with memory, allocation and multithreading and hacks needed to overcome them.<p>VM-s are also kind of a wash for me too, since nowadays the most popular way to run software in a portable&#x2F;sandboxed manner is Docker, which is NOT cpu-agnostic, even if you ran a JVM app in it, the bundled JVM would be CPU arch dependent.</div><br/></div></div></div></div><div id="36415455" class="c"><input type="checkbox" id="c-36415455" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36415378">prev</a><span>|</span><a href="#36415008">next</a><span>|</span><label class="collapse" for="c-36415455">[-]</label><label class="expand" for="c-36415455">[1 more]</label></div><br/><div class="children"><div class="content">But what about security?<p>I haven&#x27;t really used it but from what I understood at first most of it is very elegant because at the time it was developped all nodes in a network could still be trusted.</div><br/></div></div><div id="36415008" class="c"><input type="checkbox" id="c-36415008" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36415455">prev</a><span>|</span><a href="#36415602">next</a><span>|</span><label class="collapse" for="c-36415008">[-]</label><label class="expand" for="c-36415008">[5 more]</label></div><br/><div class="children"><div class="content">Never tried but I remember reading it was very dependent on the mouse. I probably wouldn&#x27;t like it.</div><br/><div id="36415101" class="c"><input type="checkbox" id="c-36415101" checked=""/><div class="controls bullet"><span class="by">stefncb</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415008">parent</a><span>|</span><a href="#36415328">next</a><span>|</span><label class="collapse" for="c-36415101">[-]</label><label class="expand" for="c-36415101">[3 more]</label></div><br/><div class="children"><div class="content">It is, but for what it&#x27;s worth using the mouse is much more pleasant than what we&#x27;re used to ime. It&#x27;s weird at first, especially with the teleporting thing but it works really well.<p>Also, if you&#x27;re gonna try it do it either with a proper three-button mouse or with a large-ish and easy to press scroll wheel button. Otherwise it&#x27;s really frustrating.</div><br/><div id="36415411" class="c"><input type="checkbox" id="c-36415411" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415101">parent</a><span>|</span><a href="#36415328">next</a><span>|</span><label class="collapse" for="c-36415411">[-]</label><label class="expand" for="c-36415411">[2 more]</label></div><br/><div class="children"><div class="content">Just the idea of context switching from mouse to keyboard is so annoying to me outside of graphic editing. I installed vinium for firefox recently and it has been a game changer.</div><br/><div id="36415498" class="c"><input type="checkbox" id="c-36415498" checked=""/><div class="controls bullet"><span class="by">stefncb</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415411">parent</a><span>|</span><a href="#36415328">next</a><span>|</span><label class="collapse" for="c-36415498">[-]</label><label class="expand" for="c-36415498">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair and I share the sentiment to some degree, especially in &quot;regular&quot; systems. In the time period I used plan 9 I quickly got used to it though, and the method of interaction made me a bit slower and much more considerate. I liked it a lot. I still miss it. I&#x27;ll probably try it again some time.</div><br/></div></div></div></div></div></div><div id="36415328" class="c"><input type="checkbox" id="c-36415328" checked=""/><div class="controls bullet"><span class="by">Un1corn</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415008">parent</a><span>|</span><a href="#36415101">prev</a><span>|</span><a href="#36415602">next</a><span>|</span><label class="collapse" for="c-36415328">[-]</label><label class="expand" for="c-36415328">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Plan 9 made some bad choices in retrospect, at least in my opinion. The big dependency on the mouse is one of them but also assuming people will be in managed networks.</div><br/></div></div></div></div><div id="36415602" class="c"><input type="checkbox" id="c-36415602" checked=""/><div class="controls bullet"><span class="by">tsss</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36415008">prev</a><span>|</span><a href="#36414769">next</a><span>|</span><label class="collapse" for="c-36415602">[-]</label><label class="expand" for="c-36415602">[3 more]</label></div><br/><div class="children"><div class="content">The same person who is involved with Plan 9 also made Go. Taking one look at that programming language doesn&#x27;t leave me very optimistic about Plan 9.</div><br/><div id="36415973" class="c"><input type="checkbox" id="c-36415973" checked=""/><div class="controls bullet"><span class="by">rhabarba</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415602">parent</a><span>|</span><a href="#36415770">next</a><span>|</span><label class="collapse" for="c-36415973">[-]</label><label class="expand" for="c-36415973">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The same person<p>Go was designed by:<p>- Robert Griesemer, known for nothing else,<p>- Rob Pike, primarily known for sam(1), acme(1) and several other Plan 9 tools, the Blit (Unix&#x27;s own graphical terminal), UTF-8 (with Ken Thompson), Inferno and Limbo,<p>- and Ken Thompson, ancient god.</div><br/></div></div><div id="36415770" class="c"><input type="checkbox" id="c-36415770" checked=""/><div class="controls bullet"><span class="by">didntcheck</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415602">parent</a><span>|</span><a href="#36415973">prev</a><span>|</span><a href="#36414769">next</a><span>|</span><label class="collapse" for="c-36415770">[-]</label><label class="expand" for="c-36415770">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Go is a shining example of Unix philosophy - but I don&#x27;t mean that as a compliment. I mean it prioritizes ease of implementation over any other concerns and hence forces the user to reinvent many wheels. Forces round things into square holes, regardless of if that interface actually makes sense. And either completely ignores good ideas from other camps or goes sour grapes and claims they&#x27;re overcomplicated and bad (then quietly tries to hack them on later)<p>Worse is better than nothing, but when better has been demonstrated to exist, worse is just worse</div><br/></div></div></div></div><div id="36414769" class="c"><input type="checkbox" id="c-36414769" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36414699">parent</a><span>|</span><a href="#36415602">prev</a><span>|</span><a href="#36416022">next</a><span>|</span><label class="collapse" for="c-36414769">[-]</label><label class="expand" for="c-36414769">[5 more]</label></div><br/><div class="children"><div class="content">Did it live too far in the future for the time?</div><br/><div id="36414959" class="c"><input type="checkbox" id="c-36414959" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414769">parent</a><span>|</span><a href="#36416022">next</a><span>|</span><label class="collapse" for="c-36414959">[-]</label><label class="expand" for="c-36414959">[4 more]</label></div><br/><div class="children"><div class="content">Just as its sucessor, Inferno.<p>Which is what ChromeOS and Android are mostly today, leaving C to the kernel, or tiny special purpose libs, and everything else in a managed language, Limbo.</div><br/><div id="36415034" class="c"><input type="checkbox" id="c-36415034" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36414959">parent</a><span>|</span><a href="#36416022">next</a><span>|</span><label class="collapse" for="c-36415034">[-]</label><label class="expand" for="c-36415034">[3 more]</label></div><br/><div class="children"><div class="content">And how close is Go to Limbo?</div><br/><div id="36415472" class="c"><input type="checkbox" id="c-36415472" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415034">parent</a><span>|</span><a href="#36415340">next</a><span>|</span><label class="collapse" for="c-36415472">[-]</label><label class="expand" for="c-36415472">[1 more]</label></div><br/><div class="children"><div class="content">Quite close, unsafe package and method declaration come from Oberon-2 (thanks Robert Griesemer), everything else is somehow inspired from Limbo.<p><a href="https:&#x2F;&#x2F;www.vitanuova.com&#x2F;inferno&#x2F;limbo.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.vitanuova.com&#x2F;inferno&#x2F;limbo.html</a><p><a href="https:&#x2F;&#x2F;www.vitanuova.com&#x2F;inferno&#x2F;docs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.vitanuova.com&#x2F;inferno&#x2F;docs.html</a></div><br/></div></div><div id="36415340" class="c"><input type="checkbox" id="c-36415340" checked=""/><div class="controls bullet"><span class="by">afr0ck</span><span>|</span><a href="#36414699">root</a><span>|</span><a href="#36415034">parent</a><span>|</span><a href="#36415472">prev</a><span>|</span><a href="#36416022">next</a><span>|</span><label class="collapse" for="c-36415340">[-]</label><label class="expand" for="c-36415340">[1 more]</label></div><br/><div class="children"><div class="content">If I remember correctly, they have similar concurrency models. They were both written the same author as well, Rob Pike.<p>Edit: fixed a typo</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36416022" class="c"><input type="checkbox" id="c-36416022" checked=""/><div class="controls bullet"><span class="by">esjeon</span><span>|</span><a href="#36414699">prev</a><span>|</span><a href="#36415183">next</a><span>|</span><label class="collapse" for="c-36416022">[-]</label><label class="expand" for="c-36416022">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, even the namespace design of Plan 9 isn&#x27;t very elegant, because file-base API hits its own limit pretty quickly. Linux had to abuse `ioctl` to avoid that.<p>The best namespace design should come from the microkernel world, where isolation can be achieved by simply rerouting outgoing API calls to alternate servers. This will also allow injecting all kinds of crazy&#x2F;complicated policies in the middle.</div><br/></div></div><div id="36415183" class="c"><input type="checkbox" id="c-36415183" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36416022">prev</a><span>|</span><a href="#36414770">next</a><span>|</span><label class="collapse" for="c-36415183">[-]</label><label class="expand" for="c-36415183">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Plan 9 had two major ideas, that everything else was built on. The first was the idea that everything is a file. You might think that in Unix everything was already a file, but it was only partially true. In Plan 9 they took this idea to the extreme. Everything including the input and output of the system, process management and network connections were all accessed through the file system instead of the usual syscalls.<p>Historically, Unix has had two main APIs for establishing TCP&#x2F;IP connections - Berkeley sockets, and the AT&amp;T Streams-based TLI (which later evolved into XTI). In Berkeley sockets, although a socket is a file descriptor, you can&#x27;t create one just using `open()`, you have to use the `socket()` system call instead. Whereas in TLI, a network protocol such as TCP is actually a device file (e.g. `&#x2F;dev&#x2F;tcp`), and you create a socket by opening it – although instead of `open()` you have to use `t_open()`. Arguably, TLI is closer to &quot;everything is a file&quot; in this regard than Berkeley Sockets is. Alas, Berkeley Sockets won and TLI lost. TLI was more Unix-like because it was invented on Unix; Berkeley Sockets was copied from TOPS-20.<p>Originally with TLI, `&#x2F;dev&#x2F;tcp` was an actual device file on disk. In principle, you could have an alternative TCP stack using some other name, e.g. `&#x2F;dev&#x2F;tcp2`, although I&#x27;m not sure if any systems ever did that. The later XTI standard moved away from &quot;everything is a file&quot; by stating that `&#x2F;dev&#x2F;tcp` didn&#x27;t actually have to exist in the filesystem, instead the kernel could just interpret `&#x2F;dev&#x2F;tcp` as an opaque string requesting the TCP protocol.<p>`&#x2F;dev&#x2F;tcp` in bash is possibly inspired by TLI but uses Berkeley sockets, and I don&#x27;t think TLI ever let you do `&#x2F;dev&#x2F;tcp&#x2F;HOST&#x2F;PORT`, instead you had to use `t_bind()` to bind and `t_connect()` to connect. I wonder why Linux&#x2F;etc never added support for bash-style `&#x2F;dev&#x2F;tcp` (and `&#x2F;dev&#x2F;udp`) in the kernel so other programs could use it. Nowadays, I suspect many would object to that on the grounds that it could potentially be abused into a security vulnerability.<p>z&#x2F;OS is unusual in supporting multiple concurrent TCP&#x2F;IP stacks, and technically being a Unix (it is certified as one). If you have more than one TCP&#x2F;IP stack, you can control which one your application uses by setting the `_BPXK_SETIBMOPT_TRANSPORT` environment variable, or by calling the `setibmopt()` API on the socket. If you don&#x27;t do either, z&#x2F;OS extracts the routing table from each stack and uses that to forward requests to the appropriate stack by matching the IP address against those routing tables.</div><br/></div></div><div id="36414770" class="c"><input type="checkbox" id="c-36414770" checked=""/><div class="controls bullet"><span class="by">InTheArena</span><span>|</span><a href="#36415183">prev</a><span>|</span><a href="#36415093">next</a><span>|</span><label class="collapse" for="c-36414770">[-]</label><label class="expand" for="c-36414770">[1 more]</label></div><br/><div class="children"><div class="content">The pros argument seems a little disingenuous&#x2F;backwards  - plan 9 brought the future including things like &#x2F;proc - which was implemented in UNIX.<p>I loved a lot of the ideas on plan 9, but it really was unusable as a day to day environment.</div><br/></div></div><div id="36415093" class="c"><input type="checkbox" id="c-36415093" checked=""/><div class="controls bullet"><span class="by">asim</span><span>|</span><a href="#36414770">prev</a><span>|</span><a href="#36416010">next</a><span>|</span><label class="collapse" for="c-36415093">[-]</label><label class="expand" for="c-36415093">[4 more]</label></div><br/><div class="children"><div class="content">Everything as a file was an interesting architecture in the 70s. The whole system was dependent on that model so it made total sense. In the 00s and beyond I thought everything as a service was a better model. Called through an API. Basically RPC. But even that has failed. It&#x27;s very difficult to approach a new system from that perspective. I think you can design a protocol to say what the model of interaction should be for a resource but essentially demonstrate that with a single application rather than the whole operating system. Hard to convince an engineer otherwise but the pursuit of technical perfection is often what stops something from achieving it.</div><br/><div id="36415728" class="c"><input type="checkbox" id="c-36415728" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36415093">parent</a><span>|</span><a href="#36415660">next</a><span>|</span><label class="collapse" for="c-36415728">[-]</label><label class="expand" for="c-36415728">[1 more]</label></div><br/><div class="children"><div class="content">Everything as a service is what modern operating systems do actually use under the hood. Look at the Apple stack. macOS&#x2F;iOS are basically a large collection of RPC-driven microservices, wrapped behind some thin client libraries for convenience and abstraction.</div><br/></div></div><div id="36415660" class="c"><input type="checkbox" id="c-36415660" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36415093">parent</a><span>|</span><a href="#36415728">prev</a><span>|</span><a href="#36416010">next</a><span>|</span><label class="collapse" for="c-36415660">[-]</label><label class="expand" for="c-36415660">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Called through an API. Basically RPC<p>This doesn&#x27;t map well to hardware</div><br/><div id="36416086" class="c"><input type="checkbox" id="c-36416086" checked=""/><div class="controls bullet"><span class="by">asim</span><span>|</span><a href="#36415093">root</a><span>|</span><a href="#36415660">parent</a><span>|</span><a href="#36416010">next</a><span>|</span><label class="collapse" for="c-36416086">[-]</label><label class="expand" for="c-36416086">[1 more]</label></div><br/><div class="children"><div class="content">Realistically neither do files. I think it really comes down to our common abstractions. Everything is IO. For the most part shared memory maps are what drives the most performance and ease of use.</div><br/></div></div></div></div></div></div><div id="36416010" class="c"><input type="checkbox" id="c-36416010" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36415093">prev</a><span>|</span><a href="#36415931">next</a><span>|</span><label class="collapse" for="c-36416010">[-]</label><label class="expand" for="c-36416010">[1 more]</label></div><br/><div class="children"><div class="content">Did Plan 9 offer unprivileged networking virtualization the same way netns can in Linux, or userid namespaces?</div><br/></div></div><div id="36415931" class="c"><input type="checkbox" id="c-36415931" checked=""/><div class="controls bullet"><span class="by">rhabarba</span><span>|</span><a href="#36416010">prev</a><span>|</span><a href="#36415685">next</a><span>|</span><label class="collapse" for="c-36415931">[-]</label><label class="expand" for="c-36415931">[1 more]</label></div><br/><div class="children"><div class="content">Longhorn is poor man&#x27;s 9P2000. ed is poor man&#x27;s sam. (Can be continued.)</div><br/></div></div><div id="36415685" class="c"><input type="checkbox" id="c-36415685" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36415931">prev</a><span>|</span><a href="#36415829">next</a><span>|</span><label class="collapse" for="c-36415685">[-]</label><label class="expand" for="c-36415685">[2 more]</label></div><br/><div class="children"><div class="content">The three most used desktop operating systems look and feel archaic. They aren&#x27;t very different from the oses of two decades ago.<p>BeOS still looks more advanced in some aspects than Windows, Linux and MacOS.<p>I expected lots of advancements to take place in the OS space in 20 years.</div><br/><div id="36415696" class="c"><input type="checkbox" id="c-36415696" checked=""/><div class="controls bullet"><span class="by">NL807</span><span>|</span><a href="#36415685">parent</a><span>|</span><a href="#36415829">next</a><span>|</span><label class="collapse" for="c-36415696">[-]</label><label class="expand" for="c-36415696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; BeOS still looks more advanced in some aspects than Windows, Linux and MacOS.<p>In what ways?</div><br/></div></div></div></div><div id="36415829" class="c"><input type="checkbox" id="c-36415829" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36415685">prev</a><span>|</span><a href="#36414786">next</a><span>|</span><label class="collapse" for="c-36415829">[-]</label><label class="expand" for="c-36415829">[2 more]</label></div><br/><div class="children"><div class="content">The Plan 9 design wasn&#x27;t as great as people like to think and it wouldn&#x27;t have survived in the advertised form if Plan 9 actually had taken off. Actually it was already losing that aesthetic coherence quite early on in its lifetime.<p>Hierarchical nouns, a fixed collection of verbs and a stream of bytes is aesthetically pleasing and can be helpful for developers hacking around, but is too limited and low level a vocabulary to express many important APIs. An obvious example is the Plan 9 windowing&#x2F;graphics server, which in theory is just files but because that&#x27;s way too low level is actually accessed via a client library written in C. That&#x27;s how it would have always gone in the end: in theory it&#x27;d be files, in practice it&#x27;d be RPCs squashed and squeezed to look a bit like files as long as you don&#x27;t think too hard, with a C API wrapping it for convenience.<p>APIs and files are very different things. Every modern platform has a fairly sophisticated inter-process RPC system at its core for that reason. Windows has (D)COM, Apple has XPC, Linux has DBUS (but doesn&#x27;t use it as much), Android has the Binder, Chrome(OS) has Mojo. The designers of these platforms were all quite familiar with Plan 9 and yet none chose to implement the everything-is-a-file model, which I think is good evidence that this is a dead-end design wise. Fundamentally you don&#x27;t write complex programs in shell scripts but the Plan 9 design assumes you do.<p>One place this model does live on is HTTP, but HTTP isn&#x27;t enough and is thus always used with extensions, at minimum JSON or XML but also things like multipart, websockets, headers, CORS, maybe Swagger etc. And of course HTTP servers only look like a file system on the surface, in reality you can&#x27;t actually browse them or do most of the things you&#x27;d expect of a filing system, and you don&#x27;t use the filing system APIs to access them.<p>Networking and filesystems are an especially difficult combination because the UNIX APIs for file access (which Plan 9 largely also uses) are too impoverished to provide necessary  functionality. They all assume relatively reliable and low latency access, so even quite basic things like being able to get progress information from operations isn&#x27;t easy.<p>Still, the underlying ideas in Plan 9 are worth iterating on. My company has an internal Kotlin based scripting tool designed to bridge the world of shell scripting and &#x27;real&#x27; programming languages. It exposes a shell-like API with functions like mv, cp, wget, and so on which are all implemented internally. One of the things it does is expose progress events via a unified progress reporting API. You can assign a progress event handler and then do things like file copies or archival operations, and get information on what&#x27;s going on. By default it renders a nice animated progress bar on the terminal but you can also do things like serialize these events across network boundaries. The filesystem API is pluggable so you can do things like browse into zips, and there&#x27;s also an ssh function that lets you connect to the file system of a remote server: strings can be turned into path objects that remember their home filesystem and those can then be used to do things like copy&#x2F;browse&#x2F;execute things on remote systems:<p><pre><code>     val local = dir &#x2F; &quot;local-archive.tar.gz&quot;
     ssh(&quot;&#x2F;&#x2F;foo.com&#x2F;home&#x2F;bar&quot;) {
         cp(&quot;remote-archive.tar.gz&quot;, local)
     }
     extract(local)
     </code></pre>
... etc ...<p>It also acts as a sort of testbed for vaguely Plan9-ish ideas. For instance I want to experiment with how to adapt a regular POSIX-ish file API to allow nodes to be both files and directories simultaneously. But you don&#x27;t need an OS for this. It can all be done in userspace.</div><br/><div id="36416106" class="c"><input type="checkbox" id="c-36416106" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#36415829">parent</a><span>|</span><a href="#36414786">next</a><span>|</span><label class="collapse" for="c-36416106">[-]</label><label class="expand" for="c-36416106">[1 more]</label></div><br/><div class="children"><div class="content">A model need not be copied to be better.  IMO there are lots of reasons for people to pursue their own ideas or ideas that don&#x27;t require fundamental upgrades to their operating system.<p>I can also imagine doing the reverse of what you suggest in that libraries could implement fundamental mechanisms like RPCs and the file model would just be one form of interface to them.  This would enable all programs to work to a minimum level with a new source or sink of data.<p>So you wouldn&#x27;t need to rewrite code to be able to make it send data via your new RPC mechanism or dump data to your strange new distributed backup mechanism. That would be tremendously powerful.<p>If you had to do something very specific then the choice to access it via a more complex API would be there.<p>In fact if we forgot about files per se we could just look at models of access like:
1) sequential serial 
2) low latency random access
3) heirarchical namespace
4) search-based namespace
5) high latency request&#x2F;response<p>That way a file manager for example, could treat a namespace like my remote ssh drive differently from my local disk which offered low latency random access by not trying to generate thumbnails on it and not blocking while reading the names in it.<p>i.e. the file model is possibly too simple for its own good but that doesn&#x27;t mean we couldn&#x27;t make it better.</div><br/></div></div></div></div><div id="36414786" class="c"><input type="checkbox" id="c-36414786" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#36415829">prev</a><span>|</span><a href="#36415761">next</a><span>|</span><label class="collapse" for="c-36414786">[-]</label><label class="expand" for="c-36414786">[2 more]</label></div><br/><div class="children"><div class="content">Could you do this with some kind of eBPF approach?</div><br/><div id="36414868" class="c"><input type="checkbox" id="c-36414868" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#36414786">parent</a><span>|</span><a href="#36415761">next</a><span>|</span><label class="collapse" for="c-36414868">[-]</label><label class="expand" for="c-36414868">[1 more]</label></div><br/><div class="children"><div class="content">eBPF works because it only runs programs that pass its own static-analyzer - which basically means programs have to be specifically written for eBPF - you can&#x27;t just take an arbitrary C program and have it run as an eBPF program.<p>The restrictions on eBPF programs are... legion, just count all the &quot;No, you can&#x27;t&quot; answers in the FAQ: <a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;bpf&#x2F;bpf_design_QA.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;bpf&#x2F;bpf_design_QA.htm...</a></div><br/></div></div></div></div><div id="36415761" class="c"><input type="checkbox" id="c-36415761" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#36414786">prev</a><span>|</span><label class="collapse" for="c-36415761">[-]</label><label class="expand" for="c-36415761">[1 more]</label></div><br/><div class="children"><div class="content">I have used Plan 9, and found it is a poor man&#x27;s Linux.</div><br/></div></div></div></div></div></div></div></body></html>