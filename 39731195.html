<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710666065876" as="style"/><link rel="stylesheet" href="styles.css?v=1710666065876"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://registerspill.thorstenball.com/p/a-few-words-on-testing">Losing Faith on Testing</a> <span class="domain">(<a href="https://registerspill.thorstenball.com">registerspill.thorstenball.com</a>)</span></div><div class="subtext"><span>ben_s</span> | <span>79 comments</span></div><br/><div><div id="39732922" class="c"><input type="checkbox" id="c-39732922" checked=""/><div class="controls bullet"><span class="by">xiwenc</span><span>|</span><a href="#39732263">next</a><span>|</span><label class="collapse" for="c-39732922">[-]</label><label class="expand" for="c-39732922">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps the key with testing strategy is to define what to test.<p>As pointed out, code coverage is not a good metric when followed blindly.<p>I believe there are at minimum 2 levels that need testing. First is unit testing. It should ensure complex functions work as intended as a unit.<p>Second, for your core functionalities, have e2e test cases. This ensures your product actually works for the end user.<p>Unit testing should make up the biggest part of the test suites. E2e should be kept at minimum but yet satisfies the quality requirements.<p>Few years back i wrote a bit about this based on the AAA method: <a href="https:&#x2F;&#x2F;cinaq.com&#x2F;blog&#x2F;2019&#x2F;05&#x2F;05&#x2F;simple-high-value-tests-with-python-flask&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cinaq.com&#x2F;blog&#x2F;2019&#x2F;05&#x2F;05&#x2F;simple-high-value-tests-wi...</a><p>The core idea is to determine what are high value tests.</div><br/></div></div><div id="39732263" class="c"><input type="checkbox" id="c-39732263" checked=""/><div class="controls bullet"><span class="by">throwaway74432</span><span>|</span><a href="#39732922">prev</a><span>|</span><a href="#39731835">next</a><span>|</span><label class="collapse" for="c-39732263">[-]</label><label class="expand" for="c-39732263">[12 more]</label></div><br/><div class="children"><div class="content">&gt;I get paid for code that works, not for tests<p>A blog post could be written about just this statement and how it contributes to a low trust workplace where those who cut corners are favored by stakeholders and everyone else is left scrambling to clean up the messes left in their wake. If you&#x27;re writing code for yourself, sure, be targeted and conservative with your tests. But when you&#x27;re working with others, for goodness sake, put the safety nets in place for the next poor soul that has to work on your code.</div><br/><div id="39732544" class="c"><input type="checkbox" id="c-39732544" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#39732263">parent</a><span>|</span><a href="#39732815">next</a><span>|</span><label class="collapse" for="c-39732544">[-]</label><label class="expand" for="c-39732544">[6 more]</label></div><br/><div class="children"><div class="content">That quote is totally true though.<p>Ultimately, tests are there to make sure code works, not for tests&#x27; sake. The rest of the sentence you&#x27;re quoting being &quot;so my philosophy is to test as little as possible to reach a given level of confidence&quot;<p>Overall the approach in the OP looks to me like a decently balanced take, trying to aim for enough tests without excess.</div><br/><div id="39732579" class="c"><input type="checkbox" id="c-39732579" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732544">parent</a><span>|</span><a href="#39732815">next</a><span>|</span><label class="collapse" for="c-39732579">[-]</label><label class="expand" for="c-39732579">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s impossible to prove that code works. But tests are a strong indicator and at least put bounds on where the program does work.<p>If you&#x27;re paid to write code that works, you&#x27;re paid to write tests. This is fairly standard in every other engineering field.</div><br/><div id="39732811" class="c"><input type="checkbox" id="c-39732811" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732579">parent</a><span>|</span><a href="#39732709">next</a><span>|</span><label class="collapse" for="c-39732811">[-]</label><label class="expand" for="c-39732811">[1 more]</label></div><br/><div class="children"><div class="content">You can at least <i>try</i> to prove the code works, and you can get a lot further than people seem to bother. Hell: even just using a language with types--which many people don&#x27;t do--is a form of invariant that proves away a lot of potential bugs you would otherwise have to test.<p>And like, we absolutely have proof assistants and model checkers and more advanced languages with dependent types (even C++ can do a lot more than many languages due to how it can template over values, which includes stuff like the sizes of buffers on which it can do math at compile time, but we should be spending more time coding in the like of Coq&#x2F;Idris&#x2F;Lean)... let&#x27;s not normalize a world in which people entirely give up on formal correctness.<p>The problem with tests is that people use them as a crutch to not have to even just prove to themselves in their head -- much less to someone else or in a way that can be checked by a machine -- why their code does or doesn&#x27;t work... they just throw together a ton of tests and if they hammer the code and when the tests stop failing they proudly announce &quot;I guess it works now&quot; and move on.<p>My challenge: try to code for a while with the mentality that every every time you stop typing to test it or run and it doesn&#x27;t work (including &quot;my tests failed&quot;), that is a serious problem that should be avoided. Instead, try your best to make it so the first time you get around to testing your code it works because you are that confident in how it works.</div><br/></div></div><div id="39732709" class="c"><input type="checkbox" id="c-39732709" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732579">parent</a><span>|</span><a href="#39732811">prev</a><span>|</span><a href="#39732815">next</a><span>|</span><label class="collapse" for="c-39732709">[-]</label><label class="expand" for="c-39732709">[3 more]</label></div><br/><div class="children"><div class="content">This is the kind of shortcut that gets easily forgotten after a while IMHO.<p>Why you write tests is important, and for instance coverage numbers are not that. Most automated coverage assessments still won&#x27;t guarantee you&#x27;re testing all the critical patterns (you just need enough to touch all the paths) and a low number doesn&#x27;t always mean it&#x27;s not enough.<p>I understand the use as an heuristic&#x27;s, but as it gets widely adopted it also becomes more and more useless. I mean, today we see people eyeing at LLMs to boost their coverage numbers automatically, and that trend of writing low effort tests has been going all for a while IMO.</div><br/><div id="39732817" class="c"><input type="checkbox" id="c-39732817" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732709">parent</a><span>|</span><a href="#39732729">next</a><span>|</span><label class="collapse" for="c-39732817">[-]</label><label class="expand" for="c-39732817">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like that common misconception about the testing pyramid.<p>The reason it&#x27;s smaller at the top isn&#x27;t because you should have numerically more tests at the bottom then at the top. It just shows that if you&#x27;re doing a higher level test, you&#x27;re <i>also</i> testing the layers below this. 
As an unrealistic example: if you&#x27;d have 1 IT and 1 UT, you&#x27;d still have double coverage at the bottom. You&#x27;re probably still gonna create more UT then ITs though, as they&#x27;re easier to write... so this is probably more academic pedantry then anything insightful</div><br/></div></div><div id="39732729" class="c"><input type="checkbox" id="c-39732729" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732709">parent</a><span>|</span><a href="#39732817">prev</a><span>|</span><a href="#39732815">next</a><span>|</span><label class="collapse" for="c-39732729">[-]</label><label class="expand" for="c-39732729">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I understand the use as an heuristic&#x27;s, but as it gets widely adopted it also becomes more and more useless.<p>I too am a big fan of Goodhart&#x27;s Law. It seems many took this as advice and not a warning.</div><br/></div></div></div></div></div></div></div></div><div id="39732815" class="c"><input type="checkbox" id="c-39732815" checked=""/><div class="controls bullet"><span class="by">th3byrdm4n</span><span>|</span><a href="#39732263">parent</a><span>|</span><a href="#39732544">prev</a><span>|</span><a href="#39732712">next</a><span>|</span><label class="collapse" for="c-39732815">[-]</label><label class="expand" for="c-39732815">[2 more]</label></div><br/><div class="children"><div class="content">This assumes useful tests.<p>There&#x27;s a false equivalency drawn between writing tests means you wrote good code. In reality, those who can write good tests can also write good code.<p>My rules of thumb: 
&quot;Be a goldfish&quot; 
 - Forget everything you know about your project, <i>is it complicated, non-intuitive?  Tests + clear documentation.</i><p>But don&#x27;t test for stupid stuff.<p>AI&#x27;s already generate+test the stupid stuff for us anyway ... why are we writing it</div><br/><div id="39732910" class="c"><input type="checkbox" id="c-39732910" checked=""/><div class="controls bullet"><span class="by">kmac_</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732815">parent</a><span>|</span><a href="#39732712">next</a><span>|</span><label class="collapse" for="c-39732910">[-]</label><label class="expand" for="c-39732910">[1 more]</label></div><br/><div class="children"><div class="content">Exactly this. Most of the tests reimplement the implementation using mocks. Such tests are useless, as they always prove the code is correct. Worse, such tests make refactoring much slower. On a low level, only black-box interface tests make sense, and on a high level, use scenario testing. The implementation has to be tested indirectly, otherwise, it leaks.</div><br/></div></div></div></div><div id="39732712" class="c"><input type="checkbox" id="c-39732712" checked=""/><div class="controls bullet"><span class="by">mkl95</span><span>|</span><a href="#39732263">parent</a><span>|</span><a href="#39732815">prev</a><span>|</span><a href="#39732573">next</a><span>|</span><label class="collapse" for="c-39732712">[-]</label><label class="expand" for="c-39732712">[2 more]</label></div><br/><div class="children"><div class="content">At my current company we have pretty high test coverage. The test suite also happens to be full of mocks plus some cargoculted antipatterns that make many tests useless. The engineers who actually test their stuff can be counted with one hand.</div><br/><div id="39732855" class="c"><input type="checkbox" id="c-39732855" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#39732263">root</a><span>|</span><a href="#39732712">parent</a><span>|</span><a href="#39732573">next</a><span>|</span><label class="collapse" for="c-39732855">[-]</label><label class="expand" for="c-39732855">[1 more]</label></div><br/><div class="children"><div class="content">I see this so often.<p>Mocks and stubs get used all over the place because nobody understands what it means to write code that’s easily testable. They’re great when used correctly (e.g., remote services or inherently stateful APIs like time). But they almost never are.<p>You end up with tests that ensure one and only one thing: the code is written the way it’s currently written.<p>Tests should do two things: find unexpected out-of-spec behavior, and prevent regressions during the course of editing and refactoring. These overly-mocked tests by definition can’t do the first one and they <i>actively inhibit</i> the second. They have negative value insofar as they constantly trigger failure while making completely benign edits.</div><br/></div></div></div></div><div id="39732573" class="c"><input type="checkbox" id="c-39732573" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39732263">parent</a><span>|</span><a href="#39732712">prev</a><span>|</span><a href="#39731835">next</a><span>|</span><label class="collapse" for="c-39732573">[-]</label><label class="expand" for="c-39732573">[1 more]</label></div><br/><div class="children"><div class="content">I think another blog could be similarly written on &quot;don&#x27;t fix it if it ain&#x27;t broken.&quot; Fixing things before they are broken is substantially cheaper and takes far less time. But it is far easier to push off. Maintenance and fixing things BEFORE they are broken is key. Of course, not everything needs to be fixed. But many sayings are often taken too literally.</div><br/></div></div></div></div><div id="39731835" class="c"><input type="checkbox" id="c-39731835" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#39732263">prev</a><span>|</span><a href="#39731852">next</a><span>|</span><label class="collapse" for="c-39731835">[-]</label><label class="expand" for="c-39731835">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;m shocked by how many developers check in code that passes the tests but they have not actually tested to make sure it works.<p>Also, I&#x27;m tired of people not factoring in (and not honestly reporting) the time and frustration spent yak shaving to keep testing infrastructures working. I believe that it&#x27;s because folks convince themselves that to acknowledge time lost to the ritual preparation for testing is a kind of weakness because other people aren&#x27;t having those problems because surely you&#x27;d hear more about it.<p>In reality, you can only write tests to cover the cases you anticipate. Correlating test coverage with reliability can be deadly; instead of losing sleep, periodically make sure that you can restore your backups to a production state and maybe even run some drills to see how your team responds when an unanticipated problem arises.</div><br/><div id="39731876" class="c"><input type="checkbox" id="c-39731876" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39732521">next</a><span>|</span><label class="collapse" for="c-39731876">[-]</label><label class="expand" for="c-39731876">[7 more]</label></div><br/><div class="children"><div class="content">Tests are unbelievably useful for updating libraries. Every time I update rails I see a ton of specs fail all over the app highlighting breaking changes not mentioned in the docs. Stuff that is impossible to anticipate otherwise.</div><br/><div id="39732042" class="c"><input type="checkbox" id="c-39732042" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39731876">parent</a><span>|</span><a href="#39732521">next</a><span>|</span><label class="collapse" for="c-39732042">[-]</label><label class="expand" for="c-39732042">[6 more]</label></div><br/><div class="children"><div class="content">This is where a nice type system and compilation checks in CI are very useful to have.</div><br/><div id="39732086" class="c"><input type="checkbox" id="c-39732086" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732042">parent</a><span>|</span><a href="#39732128">next</a><span>|</span><label class="collapse" for="c-39732086">[-]</label><label class="expand" for="c-39732086">[1 more]</label></div><br/><div class="children"><div class="content">I agree a type system does wipe out 80% of the tests you need, but I still feel like the 20% is useful. You can just write tests that verify the output looks right without having to run every single line of code to make sure there are no typos or type issues.</div><br/></div></div><div id="39732128" class="c"><input type="checkbox" id="c-39732128" checked=""/><div class="controls bullet"><span class="by">1propionyl</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732042">parent</a><span>|</span><a href="#39732086">prev</a><span>|</span><a href="#39732521">next</a><span>|</span><label class="collapse" for="c-39732128">[-]</label><label class="expand" for="c-39732128">[4 more]</label></div><br/><div class="children"><div class="content">Types don&#x27;t replace tests.<p>Tests don&#x27;t replace types.<p>For either statement to be true, they would have to be entirely equivalent, at which point it would be a distinction without a difference to complain about.<p>And last I checked no type system automatically generates and minimizes failure cases.<p>And last I checked no test system can be used to formally prove anything about the behavior of code.</div><br/><div id="39732377" class="c"><input type="checkbox" id="c-39732377" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732128">parent</a><span>|</span><a href="#39732581">next</a><span>|</span><label class="collapse" for="c-39732377">[-]</label><label class="expand" for="c-39732377">[1 more]</label></div><br/><div class="children"><div class="content">The two are definitely not equivalent, but they overlap.<p>Types can replace tests - if an edge case exists but I can define it out of existence with my type system, then I no longer need tests for that case. And likewise, tests can replace types - I can use dependent type systems to define invariants in my system but at a certain point it becomes so unwieldy that it&#x27;s easier to use tests to define those invariants less formally.<p>In the end, they&#x27;re just two different tools that both serve the overall aim of software correctness. Demonstrating correctness with one tool may be easier but less thorough, or more complicated but more precise, or whatever else. In this context, if you can get the type system to help you, you&#x27;ll be able to get away with a lot fewer tests because you don&#x27;t need to test things like &quot;does this function call a method that actually exists?&quot; or &quot;what happens when this function is passed bad data?&quot;.</div><br/></div></div><div id="39732581" class="c"><input type="checkbox" id="c-39732581" checked=""/><div class="controls bullet"><span class="by">JoeyJoJoJr</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732128">parent</a><span>|</span><a href="#39732377">prev</a><span>|</span><a href="#39732521">next</a><span>|</span><label class="collapse" for="c-39732581">[-]</label><label class="expand" for="c-39732581">[2 more]</label></div><br/><div class="children"><div class="content">Why does the statement need to be either true or false, and why would tests versus a type system have to be entirely equivalent? The parent comment mentioned that 80% of tests can be eliminated with a good type system, not that a good type system can entirely replace tests.<p>IMO working with a good type system for a decent length of should absolutely make it apparent that a whole host basic but pervasive errors are practically eliminated, or at the very least heavily mitigated. Silly errors like thinking an array of numbers is just a number, or an Id is a string instead of an int. Every developer I have ever worked with makes these mistakes all the time, especially the developers that say they have never needed a type system or that type systems somehow limit the expressiveness of their code.<p>I would really like to know if there is an efficient way to write tests that can adequately cover these silly errors without over burdening the codebase with heaps of extra test code that causes rigidity and friction for refactoring.</div><br/><div id="39732677" class="c"><input type="checkbox" id="c-39732677" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732581">parent</a><span>|</span><a href="#39732521">next</a><span>|</span><label class="collapse" for="c-39732677">[-]</label><label class="expand" for="c-39732677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why does the statement need to be either true or false,<p>They never said that btw. They said for a logical system you&#x27;d need &quot;types replace tests &lt;=&gt; tests replace types.&quot; While I don&#x27;t agree from a mathematical point, their meaning is clear enough. It&#x27;s clear that you can have typed systems and still need tests and well... tests obviously don&#x27;t enforce types. Plus, how does everyone in CS not know that logic systems are not binary but tertiary?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39732521" class="c"><input type="checkbox" id="c-39732521" checked=""/><div class="controls bullet"><span class="by">misternugget</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39731876">prev</a><span>|</span><a href="#39732642">next</a><span>|</span><label class="collapse" for="c-39732521">[-]</label><label class="expand" for="c-39732521">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m shocked by how many developers check in code that passes the tests but they have not actually tested to make sure it works.<p>That&#x27;s actually one of the other topics I wanted to write about yesterday. Chose to write the article above instead.<p>Yes, 100%. I&#x27;ve seen it many times: manually testing reveals more in 1min than hours of previous discussions&#x2F;reviews&#x2F;test-writing.</div><br/></div></div><div id="39732642" class="c"><input type="checkbox" id="c-39732642" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39732521">prev</a><span>|</span><a href="#39732498">next</a><span>|</span><label class="collapse" for="c-39732642">[-]</label><label class="expand" for="c-39732642">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you in spirit but I&#x27;m not shocked given how many people say that they don&#x27;t need to write docs because their code is so well written that it is self documented. Which tells me your code is any combination of 1) spaghetti 2) highly unoptimized 3) a holy piece of text. What&#x27;s the saying? 30 years of improvements in programming has completely undone 30 years of improvements in hardware? Moving fast and breaking things is great to get going, but eventually someone has to come around and clean up all the mess.</div><br/><div id="39732750" class="c"><input type="checkbox" id="c-39732750" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732642">parent</a><span>|</span><a href="#39732498">next</a><span>|</span><label class="collapse" for="c-39732750">[-]</label><label class="expand" for="c-39732750">[1 more]</label></div><br/><div class="children"><div class="content">I never heard people say their code was well written (I wouldn&#x27;t personally), but many of us have stopped reading docs and comments outside of specifically added ones in surprising locations and vendor provided doc.<p>Many orgs have mandatory docs and comments, yet the devs find nothing specific to write about (they already wrote design documents), and deeply down in their heart don&#x27;t want to maintain it either. So you get bland and sometimes inane docs and comments, with a bunch of it going stale for a combination of reasons. To the point where you feel you lost your time reading that prose 9 times out of 10, when it wasn&#x27;t straight misleading&#x2F;factually wrong.<p>It takes real dedication, discipline and talent to have good documentation, and I wouldn&#x27;t expect any random dev org to be able to pull it off.</div><br/></div></div></div></div><div id="39732498" class="c"><input type="checkbox" id="c-39732498" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39732642">prev</a><span>|</span><a href="#39731993">next</a><span>|</span><label class="collapse" for="c-39732498">[-]</label><label class="expand" for="c-39732498">[3 more]</label></div><br/><div class="children"><div class="content">&gt; passes the tests but they have not actually tested<p>Surely this is a problem with the tests then? Whatever manual steps you&#x27;re referring to with &quot;actually tested&quot; should be automated and part of the test suite.<p>Much easier said than done in some cases obviously, but I&#x27;ve seen some cases where people were manually doing things to &quot;actually test&quot; their code that could obviously and easily be automated.</div><br/><div id="39732638" class="c"><input type="checkbox" id="c-39732638" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732498">parent</a><span>|</span><a href="#39732619">next</a><span>|</span><label class="collapse" for="c-39732638">[-]</label><label class="expand" for="c-39732638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Surely this is a problem with the tests then? Whatever manual steps you&#x27;re referring to with &quot;actually tested&quot; should be automated and part of the test suite.<p>As far as I know there is no real way to automate ensuring that the code being submitted is tested.<p>Coverage gates are the closest, and coverage is routinely decried on this here site. The only thing that actually comes close is a very strong type system obviating most tests… but not all, and we’re back to square one.<p>Then there’s the issue of tests testing something useful, yet not over-testing.</div><br/></div></div><div id="39732619" class="c"><input type="checkbox" id="c-39732619" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732498">parent</a><span>|</span><a href="#39732638">prev</a><span>|</span><a href="#39731993">next</a><span>|</span><label class="collapse" for="c-39732619">[-]</label><label class="expand" for="c-39732619">[1 more]</label></div><br/><div class="children"><div class="content">I can relate to the issue: tests work with specific check conditions, and there might other side effects that are not critical to the test but still impacting the user.<p>For instance a page that properly loads, but surprisingly slowly. If you had no requirement of speed and it still loads within the test timeouts, it will pass fine, but a manual check would have raised the issue and perhaps underlying well hidden bugs.</div><br/></div></div></div></div><div id="39731993" class="c"><input type="checkbox" id="c-39731993" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39732498">prev</a><span>|</span><a href="#39732318">next</a><span>|</span><label class="collapse" for="c-39731993">[-]</label><label class="expand" for="c-39731993">[1 more]</label></div><br/><div class="children"><div class="content">It amazed me when a dev on one of my teams put up a code review, no tests (to be added &quot;during the QE pass later&quot; (a practice that itself has issues but in this case was at least plausible)), but from my quick inspection couldn&#x27;t possibly work. So I download the patch, built it into my local app, test it.. and yeah, it doesn&#x27;t work. At that point it was faster for me to actually make it work and just submit the new diff instead of do the back-and-forth dance over code review.<p>My team did pretty good on reporting the time spent (sunk) to BS like infrastructure, flaky tests (especially those involving complex selenium automation which additionally suck for speed because they require the whole app to be running), and out-of-our-team&#x27;s-hands problems in the wider company. I think it helped that the most senior devs ran into the same problems and felt fine complaining about them as a way to explain why something is taking longer than might otherwise be expected. We also had interns every summer to run into problems that hadn&#x27;t been fixed and we had just grown accustomed to or found our own mitigations. Sometimes it&#x27;s just a knowledge issue, being honest about it means someone might be able to help. Even new members with &quot;lead engineer&quot; in their title can learn new things that were taught to the last crop of interns and be more productive. There is a downside risk in that the excuses can be taken advantage of and someone can get away with doing pretty much no code work for days. The excuses can also be taken advantage of to get some various work in that doesn&#x27;t nicely fit into its own work ticket, though... Some slack in orgs is important and comes in various forms.<p>Property testing helps cover some cases you don&#x27;t fully anticipate. It&#x27;s worth integrating a library (<a href="https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;quickcheck-in-every-language&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;quickcheck-in-every-langua...</a> is old but at least points to a bunch for different languages) into the automation infrastructure even if it&#x27;s not used all that often.</div><br/></div></div><div id="39732318" class="c"><input type="checkbox" id="c-39732318" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#39731835">parent</a><span>|</span><a href="#39731993">prev</a><span>|</span><a href="#39731852">next</a><span>|</span><label class="collapse" for="c-39732318">[-]</label><label class="expand" for="c-39732318">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;ve written tests, but not verified that the <i>tests</i> work. Specifically, not verified that the tests can detect the failure mode they claim to.</div><br/><div id="39732821" class="c"><input type="checkbox" id="c-39732821" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39731835">root</a><span>|</span><a href="#39732318">parent</a><span>|</span><a href="#39731852">next</a><span>|</span><label class="collapse" for="c-39732821">[-]</label><label class="expand" for="c-39732821">[1 more]</label></div><br/><div class="children"><div class="content">You must always verify the tests pick up whatever it is they&#x27;re testing, you do that by intentionally asserting a wrong value, or running tests before the bug was fixed, for example... it&#x27;s not hard.</div><br/></div></div></div></div></div></div><div id="39731852" class="c"><input type="checkbox" id="c-39731852" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#39731835">prev</a><span>|</span><a href="#39731552">next</a><span>|</span><label class="collapse" for="c-39731852">[-]</label><label class="expand" for="c-39731852">[10 more]</label></div><br/><div class="children"><div class="content">I have maintained a widely used (250-500k+ unique ip dl&#x2F;month consistently over the last 6 years) interactive terminal program that had essentially no tests of its interactive behavior. Building and restarting the program took a minimum 15 seconds no matter how trivial the change. It became an absolute nightmare to work with and I eventually stopped contributing because it was so frustrating to work with.<p>Writing good automated tests for interactive programs has to be done from the beginning or it will be almost impossible to effectively add later. To test an interactive program, you need to be able to simulate input and analyze the output stream. This can be done efficiently and effectively but again only if the program is designed this way from the beginning.<p>At some point, if they continue on this trajectory, I would expect zed will end up in a similar state to the program I described above. It will become extremely difficult to reason about the effects of ui changes and very painful to debug and troubleshoot. Regressions will happen because relatively common cases (say 1-5% of users) that the developers themselves don&#x27;t regularly use will not be noticed. Bug fixing becomes a game of whack a mole as manual changes to fix one case break another without your noticing.<p>I hope they&#x27;re able to avoid this fate because it was hellish for me.</div><br/><div id="39732869" class="c"><input type="checkbox" id="c-39732869" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#39731852">parent</a><span>|</span><a href="#39732140">next</a><span>|</span><label class="collapse" for="c-39732869">[-]</label><label class="expand" for="c-39732869">[1 more]</label></div><br/><div class="children"><div class="content">One of the scariest stories I&#x27;ve read on HN - the amount of technical debt must be staggering...<p>see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18442941">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18442941</a> - a day in the life of an Oracle DB developer.</div><br/></div></div><div id="39732140" class="c"><input type="checkbox" id="c-39732140" checked=""/><div class="controls bullet"><span class="by">Anon_451</span><span>|</span><a href="#39731852">parent</a><span>|</span><a href="#39732869">prev</a><span>|</span><a href="#39731905">next</a><span>|</span><label class="collapse" for="c-39732140">[-]</label><label class="expand" for="c-39732140">[3 more]</label></div><br/><div class="children"><div class="content">Ah, my sweet summer child.<p>I work for a division of a Fortune 500 company with a multi-billion dollar per year marketshare. A rebuild requires at least 15 minutes. A clean build takes up a full hour.<p>But it gets even better. Since it&#x27;s firmware we have two types of builds, a &quot;simulator&quot; build needed to run the unit tests and an &quot;emulator&#x2F;engine&quot; build to see what the change actually does. Any change requires testing both. The latter requires checking out a device (in the rare event one is available) (and entering one&#x27;s credentials for the 10th time for the day) and going through an arcane telnet ritual to get the firmware on the device, which easily eats up at least 10 minutes. Then one must connect to the device&#x27;s on-board HTTP server to verify the changes, but it takes a good while for the server to come up, requires another password and slowly chugs between page changes.<p>Once one has verified both builds, it&#x27;s time to create a PR, but before a human will look at it one must queue up a preintegration test which will build the changes on every single product and run every single unit test, a process which easily takes hours and will invariably come back with failures because nobody knows how to write correct multi-threaded code. After getting the results and human approval, then it&#x27;s off to integration, which again builds on every product and test, but with a handful of other peoples&#x27; PRs, so if somebody screws up you get to start again.<p>Gods how I wish I was on a codebase that took 15 seconds to build and run.</div><br/><div id="39732223" class="c"><input type="checkbox" id="c-39732223" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#39731852">root</a><span>|</span><a href="#39732140">parent</a><span>|</span><a href="#39731905">next</a><span>|</span><label class="collapse" for="c-39732223">[-]</label><label class="expand" for="c-39732223">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; multi-billion dollar per year marketshare</i><p>At some point you have to wonder if it&#x27;s worth it.</div><br/><div id="39732448" class="c"><input type="checkbox" id="c-39732448" checked=""/><div class="controls bullet"><span class="by">natmaka</span><span>|</span><a href="#39731852">root</a><span>|</span><a href="#39732223">parent</a><span>|</span><a href="#39731905">next</a><span>|</span><label class="collapse" for="c-39732448">[-]</label><label class="expand" for="c-39732448">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, as we usually focus on economy of scale and neglect the law of diminishing returns.</div><br/></div></div></div></div></div></div><div id="39731905" class="c"><input type="checkbox" id="c-39731905" checked=""/><div class="controls bullet"><span class="by">jonathankoren</span><span>|</span><a href="#39731852">parent</a><span>|</span><a href="#39732140">prev</a><span>|</span><a href="#39731552">next</a><span>|</span><label class="collapse" for="c-39731905">[-]</label><label class="expand" for="c-39731905">[5 more]</label></div><br/><div class="children"><div class="content">&gt;Building and restarting the program took a minimum 15 seconds no matter how trivial the change. It became an absolute nightmare to work with and I eventually stopped contributing because it was so frustrating to work with.<p>Wait. You’re complaining about a 15 second compilation and startup loop?<p>Don’t take this the wrong way, but I don’t think compiled languages are for you.</div><br/><div id="39732858" class="c"><input type="checkbox" id="c-39732858" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39731852">root</a><span>|</span><a href="#39731905">parent</a><span>|</span><a href="#39731982">next</a><span>|</span><label class="collapse" for="c-39732858">[-]</label><label class="expand" for="c-39732858">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Don’t take this the wrong way, but I don’t think compiled languages are for you.<p>You just need an adequate build system that can perform incremental compilation and does not run a whole lot of unnecessary steps on every build no matter what changes.<p>Where I work, our system is huge and includes code written in multiple languages. A change to a &quot;leaf module&quot; (one which is not depended on by many modules) takes a second or two. You only get into 10s of seconds if you change code that affects the external API of a module which triggers the re-build of many other modules (a &quot;core&quot; module) - because in such case there&#x27;s no escape and many LoC must be re-compiled to verify they still work.<p>To keep it this way is not easy: you must constantly fix mistakes people make often, like add a new build step which runs unconditionally - everything should run conditionally (normally on whether its inputs or outputs were touched), and optimise things that take too long (e.g. slow tests and moving code that changes often from core to a leaf module).</div><br/></div></div><div id="39731982" class="c"><input type="checkbox" id="c-39731982" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#39731852">root</a><span>|</span><a href="#39731905">parent</a><span>|</span><a href="#39732858">prev</a><span>|</span><a href="#39731552">next</a><span>|</span><label class="collapse" for="c-39731982">[-]</label><label class="expand" for="c-39731982">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very unhelpful.<p>I abhor long compile times and I exclusively use staticly typed, compiled&#x2F;transpiled languages. The solution isn&#x27;t to just shrug it off, but seriously evaluate how difficult it would be to refactor to smaller modules and if the benefits would be worth it. Sometimes, it&#x27;s not worth the hassle. But if it&#x27;s getting to a point where velocity is a concern, and a potential major version is on the horizon, a refactor to reduce code debt, and make things modular can be a real possibility if explained correctly to the right stakeholders.</div><br/><div id="39732591" class="c"><input type="checkbox" id="c-39732591" checked=""/><div class="controls bullet"><span class="by">jonathankoren</span><span>|</span><a href="#39731852">root</a><span>|</span><a href="#39731982">parent</a><span>|</span><a href="#39731552">next</a><span>|</span><label class="collapse" for="c-39732591">[-]</label><label class="expand" for="c-39732591">[1 more]</label></div><br/><div class="children"><div class="content">It’s not meant to be helpful. It’s simply the truth. They’re  literally talking about 15 seconds.<p>I’m sorry, but if you’re looking for subsecond compile times, you’re simply not going to get it in C, C++, Java, or really any statically typed compiled language for any project that isn’t trivial —- no matter how many dynamically linked libraries you break your project up into.<p>They want a REPL, and they’re just not going to get one while dealing with these technologies.<p>Even your idea of creating a million tiny libraries to achieve less than 15 second compilation and launch time is insane, because now you’ve just “solved” developer efficiency by creating a deployment and maintenance nightmare.<p>It’s not a serious solution.</div><br/></div></div></div></div></div></div></div></div><div id="39731552" class="c"><input type="checkbox" id="c-39731552" checked=""/><div class="controls bullet"><span class="by">tracerbulletx</span><span>|</span><a href="#39731852">prev</a><span>|</span><a href="#39731760">next</a><span>|</span><label class="collapse" for="c-39731552">[-]</label><label class="expand" for="c-39731552">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, writing a core system component that isn&#x27;t going to change and be called from thousands of different places? By all means heavily test and fuzz and cover the entire API surface. Writing some product feature that is probably going to be changed 1000 times and is at the edge of the system, waste of time. You&#x27;d be better off just having really good metrics and alerting for system degradation that measure actual business metrics, staggered canary roll outs, and easy rollbacks.</div><br/></div></div><div id="39731760" class="c"><input type="checkbox" id="c-39731760" checked=""/><div class="controls bullet"><span class="by">vegetablepotpie</span><span>|</span><a href="#39731552">prev</a><span>|</span><a href="#39732770">next</a><span>|</span><label class="collapse" for="c-39731760">[-]</label><label class="expand" for="c-39731760">[2 more]</label></div><br/><div class="children"><div class="content">There’s a flip side. A culture that thinks end-to-end testing is the only legitimate way to test a system and that TDD is an unnecessary expense that is neither necessary nor sufficient for success.<p>That culture is right, but it’s also wrong [1]. Although it is true that you can spend most of your time testing, providing little value, it’s equally true that with any software system, that by developing it, you will break it in subtle ways; ways in which you could spend weeks fixing bugs you introduced and fixed before, therefore creating little value.<p>Unfortunately there is no substitute for critical thinking when engineering. This piece says we need to practice critical thinking with tests and that having a test that moves a mouse and clicks to confirm functionality, with suites that take 40 minutes to run, is going too far. Ball cites two examples of projects that strike a balance in testing speed and coverage. But how do we achieve this?<p>I used “culture” in a specific way to describe working environments. Culture, not process, politics, or incentives, drives how you do testing. A culture is an environment that has preferences. A culture that will generate good tests is a culture that values technical rigor. Rigor is important for forging tests, but it’s also important for <i>removing</i> tests. To make these good test suites, we need to be comfortable with removing tests, but more importantly understand why a test is needed and remove it when we can’t explain it.<p>[1] I’m not going to say there’s a “balance” to be struck, because that’s the language of people who say we should not write any tests.</div><br/></div></div><div id="39732770" class="c"><input type="checkbox" id="c-39732770" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#39731760">prev</a><span>|</span><a href="#39732807">next</a><span>|</span><label class="collapse" for="c-39732770">[-]</label><label class="expand" for="c-39732770">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe there’s no correlation between software quality and tests<p>Bingo. The underlying assumption that tests are some god-given faultless spec is flawed. In fact, the tests themselves shouldn&#x27;t be considered to be of any higher quality than the poor code they test.<p>Good teams produce good software, regardless of the approach or ideology.</div><br/></div></div><div id="39732807" class="c"><input type="checkbox" id="c-39732807" checked=""/><div class="controls bullet"><span class="by">SPBS</span><span>|</span><a href="#39732770">prev</a><span>|</span><a href="#39732031">next</a><span>|</span><label class="collapse" for="c-39732807">[-]</label><label class="expand" for="c-39732807">[1 more]</label></div><br/><div class="children"><div class="content">Tests are very much a &quot;if you liked it then you shoulda put a test on it&quot; thing. If some end-user property is desirable to you, make sure a test covers it so that you can be sure it still works that way. This is a godsend when doing extensive refactors on the codebase, which lets you <i>move fast</i>.<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;simonw&#x2F;status&#x2F;1701764953114546664" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;simonw&#x2F;status&#x2F;1701764953114546664</a>:<p>&quot;The single biggest productivity enhancement I&#x27;ve ever found for my own personal projects is writing comprehensive tests for them. I don&#x27;t mean TDD - I rarely write tests first - I mean trying to never land a feature or fix a bug without a test that proves that it works&quot;<p>&gt; No tests that click through the UI and screenshot and compare and hit the network.<p>That&#x27;s fair, I think testing UI is just hard in general and it&#x27;s easier to rely on users to submit bug reports especially if the UI rarely breaks.</div><br/></div></div><div id="39732031" class="c"><input type="checkbox" id="c-39732031" checked=""/><div class="controls bullet"><span class="by">gavmor</span><span>|</span><a href="#39732807">prev</a><span>|</span><a href="#39731632">next</a><span>|</span><label class="collapse" for="c-39732031">[-]</label><label class="expand" for="c-39732031">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Both are among the highest-quality software I have ever used and hacked on.<p>&gt; Both have less tests than I expected.<p>Interesting bit of context: Zed&#x27;s Nathan Sobo and Max Brunsfeld are both alumni of Pivotal Labs, a firm _notorious_ for its zealous adherence to, among other things, TDD. I don&#x27;t, therefore, find it surprising that &quot;neither codebase has tests, for example, that take a long-ass time to run,&quot; because the more stringently one test-drives, the less patiently one tolerates slow test suites. Besides that, after a serious investment in test-driving, one starts to learn which sorts of tests have paltry or even negative ROI; &quot;tests that click through the UI and screenshot and compare&quot; were right there at the top of the chopping block for most Pivotal devs, and tests that &quot;hit the network&quot; were explicitly taboo!<p>I think that Kent Beck quote is great, but it&#x27;s good advice for <i>people who test too much</i>, rather than devs in general or, god forbid, junior developers!<p>The way I think about TDD, it&#x27;s just like how after a while, one gets tired of copy+pasting code into the terminal, and reluctantly writes it to a file. One gets tired of emailing files, and checks them into version control. One gets tired of manipulating state--of clicking through the UI, of newing up a bunch of collaborators in the REPL, of smashing tab while blanking on the name of the method one has only just written--and writes a test.<p>And maybe one who wakes up tired writes the test first. ;)</div><br/><div id="39732126" class="c"><input type="checkbox" id="c-39732126" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#39732031">parent</a><span>|</span><a href="#39731632">next</a><span>|</span><label class="collapse" for="c-39732126">[-]</label><label class="expand" for="c-39732126">[2 more]</label></div><br/><div class="children"><div class="content">I dunno, in my career I’ve found that UI e2e tests were the ones that <i>actually</i> found bugs. All the unit tests that I’ve written ware mostly ceremony, to increase code coverage, etc, and were the first to need refactoring after some code change. A lot of refactoring.<p>The tests that stayed true were the UI tests that almost always pointed to real problems with real code.<p>It took a while to figure out how to write them though - trying to rely as little as possible on the internal ids &#x2F; html &#x2F; css and write them with what the user sees - e.g. instead of clicking on the button with “testid=login” we would “click on the button with the text login in it”. Identifying fields by the labels to them or tables by their column headers. It was inspired by rails’ capibara testing lib.<p>And making sure the tests were not flaky, fast to execute and isolated took some time.<p>But it was so worth the investment - it’s surprising how little those tests would change, as it allowed us to fearlessly refactor stuff without changing any tests. They felt a lot more like a friendly QA helping out rather than an annoyance you had to deal with <i>after</i> you’ve finished writing your code.<p>And writing them was actually fun, since you didn’t have to understand how the app worked, fiddle with brittle css identifiers etc, you just wrote the steps you thought the user should do and saved it into a file.<p>Being UI tests kinda meant they tested the whole system with the various micro services involved, databases and other infra. And I think this is where most problems in software arise, at the edges of systems when they try to interact with each other.<p>Static types, immutability automatic API schemas and validators usually make sure the code one writes executes reasonably well, its where the code one writes starts interacting with all the other systems where people usually can’t anticipate things. And thats where the integration &#x2F; e2e &#x2F; UI tests help the most I think.</div><br/><div id="39732381" class="c"><input type="checkbox" id="c-39732381" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#39732031">root</a><span>|</span><a href="#39732126">parent</a><span>|</span><a href="#39731632">next</a><span>|</span><label class="collapse" for="c-39732381">[-]</label><label class="expand" for="c-39732381">[1 more]</label></div><br/><div class="children"><div class="content">I was a big fan of the unit testing done at JP Morgan. I found 1 exploitable bug when writing Unit Tests, for an untested swath of code that was of minor concern. Ofc this was one day out of a ticket that took a few days. After a year, when I left, it was the only bug that I found with a unit test, there. I wrote unit tests for everything during my time, and I found it to be a good practice. Do I always do it at other workplaces? No. Do I do it for my own projects? Yes. It&#x27;s not that I don&#x27;t care as much at work, but the time pressure is constant and I sometimes skip them if I can.</div><br/></div></div></div></div></div></div><div id="39731632" class="c"><input type="checkbox" id="c-39731632" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#39732031">prev</a><span>|</span><a href="#39731827">next</a><span>|</span><label class="collapse" for="c-39731632">[-]</label><label class="expand" for="c-39731632">[2 more]</label></div><br/><div class="children"><div class="content">1. There is no substitute for simplification and good design.  You cannot test yourself out of a mess.<p>2. What you actually want is confidence in the code, and your ability to make changes.  Sometimes tests are a good tool to achieve that, sometimes they are not.<p>3. The previous two points can and will be used to justify sloppy code by bad programmers, but it doesn&#x27;t make them less true.</div><br/><div id="39732410" class="c"><input type="checkbox" id="c-39732410" checked=""/><div class="controls bullet"><span class="by">rsyring</span><span>|</span><a href="#39731632">parent</a><span>|</span><a href="#39731827">next</a><span>|</span><label class="collapse" for="c-39732410">[-]</label><label class="expand" for="c-39732410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You cannot test yourself out of a mess.<p>My dev shop has taken over two dumpster fire web app projects, both many years old, passing through many unskilled&#x2F;inexperienced hands, atrocious architecture and implementation, and no tests.  But, actively being used and a full rewrite not being in the cards for some time.<p>The very first thing we did for both was start writing integration tests at the http (wsgi client) layer to cover the majority of client facing functionality.  We learned a lot about the apps in the process, fixed bugs where we could, documented and fixed lots of security issues, but generally didn&#x27;t refactor anything that wasn&#x27;t very broke.<p>Once that was done, we could start refactoring which, for one project, included a migration off Mongo to tabled Postgres.  The refactoring included significant unit and other testing so that we had very good and helpful test coverage when we were finished.<p>I do believe there are times when testing yourself out of a mess is the only reasonable option.</div><br/></div></div></div></div><div id="39731827" class="c"><input type="checkbox" id="c-39731827" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39731632">prev</a><span>|</span><a href="#39731576">next</a><span>|</span><label class="collapse" for="c-39731827">[-]</label><label class="expand" for="c-39731827">[7 more]</label></div><br/><div class="children"><div class="content">An interesting correlation that I have observed over the years is that the more one is &quot;religious&quot; about writing tests, the less actual understanding of the code one seems to have.<p>&quot;Beware of bugs in the above code; I have only proved it correct, not tried it.&quot; - Donald Knuth</div><br/><div id="39732064" class="c"><input type="checkbox" id="c-39732064" checked=""/><div class="controls bullet"><span class="by">hibikir</span><span>|</span><a href="#39731827">parent</a><span>|</span><a href="#39731976">next</a><span>|</span><label class="collapse" for="c-39732064">[-]</label><label class="expand" for="c-39732064">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve faced that problem before: Someone claimed their autoscaling algorithm had to be working correctly, as he had written a proof and had a working simulator behaving perfectly. And yes, the code matched the algorithm as written, and the proof was correct... as long as latency was zero. Once I added lags to the right places in the simulator, we got the exact same problems than in production.</div><br/></div></div><div id="39731976" class="c"><input type="checkbox" id="c-39731976" checked=""/><div class="controls bullet"><span class="by">1123581321</span><span>|</span><a href="#39731827">parent</a><span>|</span><a href="#39732064">prev</a><span>|</span><a href="#39731847">next</a><span>|</span><label class="collapse" for="c-39731976">[-]</label><label class="expand" for="c-39731976">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a correlation between caring about the application code and the test code. That makes sense because writing, reading and running specs help you think about what you&#x27;re intending to do and what you&#x27;ve accidentally done.</div><br/></div></div><div id="39731847" class="c"><input type="checkbox" id="c-39731847" checked=""/><div class="controls bullet"><span class="by">BurningFrog</span><span>|</span><a href="#39731827">parent</a><span>|</span><a href="#39731976">prev</a><span>|</span><a href="#39731576">next</a><span>|</span><label class="collapse" for="c-39731847">[-]</label><label class="expand" for="c-39731847">[4 more]</label></div><br/><div class="children"><div class="content">If you have good tests, you don&#x27;t <i>need</i> to know the code as well.</div><br/><div id="39731900" class="c"><input type="checkbox" id="c-39731900" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#39731827">root</a><span>|</span><a href="#39731847">parent</a><span>|</span><a href="#39731576">next</a><span>|</span><label class="collapse" for="c-39731900">[-]</label><label class="expand" for="c-39731900">[3 more]</label></div><br/><div class="children"><div class="content">The more I program the more I feel this way. Do I really care how the code looks like or does something? Not really, all I know is this set of specifications are held true as I make changes, as long as I&#x27;m happy with those specs, I&#x27;m happy with the code.</div><br/><div id="39732067" class="c"><input type="checkbox" id="c-39732067" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#39731827">root</a><span>|</span><a href="#39731900">parent</a><span>|</span><a href="#39731576">next</a><span>|</span><label class="collapse" for="c-39732067">[-]</label><label class="expand" for="c-39732067">[2 more]</label></div><br/><div class="children"><div class="content">On the small I wholly agree, like how much energy do some teams or even companies still waste on style document types of disagreements? But other aspects, I do often care how the code &quot;looks&quot; or more precisely &quot;does&quot; something. Like, it shouldn&#x27;t be needlessly wasteful of resources, but I don&#x27;t want to pigeonhole myself as &quot;the performance guy&quot;. It shouldn&#x27;t be using under-educated idioms that increase the likelihood that someone&#x27;s gotta come back to this later to fix something stupid like a null pointer exception. At the same time certain things that sometimes get derided as ivory tower complex (or just &quot;clever&quot;) code constructions, I don&#x27;t think should necessarily be avoided all the time, but should be tastefully balanced with an aim towards broader understanding and not showing off cleverness for the sake of cleverness. I&#x27;ve replaced so many hundreds of lines of code with some relatively simple tens of lines type theory constructions in plain old Java 8, just because a dev who stopped learning around Java 1.4&#x2F;5 doesn&#x27;t understand doesn&#x27;t make them &quot;complex&quot; or &quot;clever&quot;. I don&#x27;t even particularly like static typing, but a tool is a tool.<p>But often I just don&#x27;t care about even those details, and sometimes feel guilty about it. Carmack says to fill your products with give-a-damn, but I&#x27;m sorry, for so many things, a lot of the time I just don&#x27;t&#x2F;didn&#x27;t. Work must be done anyway though, and not just by me. So practices that are broader, like enforcing tests, do help deliver a good enough product even under the guidance of devs and management and management&#x27;s management etc. who seem to care even less than I do and don&#x27;t even feel bad about it. It&#x27;s particularly crazy when you talk to a customer who is gushing about something you know could have been even better with slightly different prioritization and tradeoffs; an important lesson is that many people are stoked merely that something exists.<p>It&#x27;s sad when tests catch something that really should have been caught, if not during code authoring time by an author who actually cares a bit more than just doing the job however and going home, then by code review time, but in large companies you sometimes have to just accept things for long periods and at least with more tests we can be more likely to catch things at all. (Not to mention they&#x27;re pretty valuable when the original author who best understood the code is long gone, they help you make minor tweaks without having to tradeoff new feature development time with time getting a deep enough understanding of that old code that still mostly works most of the time.)</div><br/><div id="39732856" class="c"><input type="checkbox" id="c-39732856" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39731827">root</a><span>|</span><a href="#39732067">parent</a><span>|</span><a href="#39731576">next</a><span>|</span><label class="collapse" for="c-39732856">[-]</label><label class="expand" for="c-39732856">[1 more]</label></div><br/><div class="children"><div class="content">&gt; have been caught, if not during code authoring time by an author who actually cares a bit more than just doing the job however and going home,<p>I have to ask, what&#x27;s the alternative type of author to one who does the job however and goes home?<p>Because doing the job properly takes more time, where does this extra time come from? In any agile setup the dev who goes slower but better is going to get dinged in every single standup and metric, so the only other alternative to doing the job however is unpaid overtime, which I think is even worse for a Dev team than shitty code.<p>IOW... Good, cheap, fast... Pick two and don&#x27;t judge those who don&#x27;t give you all three.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39731576" class="c"><input type="checkbox" id="c-39731576" checked=""/><div class="controls bullet"><span class="by">hvis</span><span>|</span><a href="#39731827">prev</a><span>|</span><a href="#39732547">next</a><span>|</span><label class="collapse" for="c-39731576">[-]</label><label class="expand" for="c-39731576">[1 more]</label></div><br/><div class="children"><div class="content">Speaking of text editors and tools like that, you can often avoid having tests (or postpone adding them for a long time), if the logic is on the main execution path, meaning you&#x27;ll execute it every time you run the program, and whatever failures that can happen, are reasonably easy to pinpoint (i.e. the program shows error backtraces or somehow traces problems otherwise).<p>This is from my experience hacking on Emacs, naturally.<p>At the same time, projects that you might ship for an employer or a client, are more critical to check for correctness before deploying, and are often more complex to run and check manually on the regular than writing at least one &quot;happy path&quot; integration test at least for the main scenario (or several).</div><br/></div></div><div id="39732547" class="c"><input type="checkbox" id="c-39732547" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#39731576">prev</a><span>|</span><a href="#39732630">next</a><span>|</span><label class="collapse" for="c-39732547">[-]</label><label class="expand" for="c-39732547">[2 more]</label></div><br/><div class="children"><div class="content">I was never a huge TDD believer and I’m not one today. It’s not about tests but about managing complexity.<p>When working with highly dynamic languages like JavaScript, Python, Ruby (at least couple years ago) tests were the only tools we had to handle it.<p>Today some of the most common issues are caught by popular static typed languages (Rust, TypeScript). There are some very smart tools like prop tests and if someone is really deep into modeling it’s also possible to test concepts with TLA+ (fun if you need to explore infinite possibilities of reality bending scenarios). Also qualities of certain languages also make code easier and stabler in domains - e.g. Erlang&#x2F;Elixir, Clojure or Haskell (and there are much more but those are in my monkey zone).<p>But in the end for me testing is just that: Managing ever growing complexity. And since tracking and maintaining change due to distributed development effort is hard the smallest common denominator I know is… write it twice.</div><br/><div id="39732590" class="c"><input type="checkbox" id="c-39732590" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39732547">parent</a><span>|</span><a href="#39732630">next</a><span>|</span><label class="collapse" for="c-39732590">[-]</label><label class="expand" for="c-39732590">[1 more]</label></div><br/><div class="children"><div class="content">This is a great post.  I feel the same on many topics.<p>&gt; I was never a huge TDD believer and I’m not one today.<p>I&#x27;ll never forget this savage takedown of TDD by Cedric Beust: <a href="https:&#x2F;&#x2F;www.beust.com&#x2F;weblog&#x2F;the-pitfalls-of-test-driven-development&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.beust.com&#x2F;weblog&#x2F;the-pitfalls-of-test-driven-dev...</a><p>The best rebuttal to TDD that I ever heard from a developer that I respected: &quot;I don&#x27;t care if you use TDD or whatever.  When you commit code, tests need to be included.&quot;  That&#x27;s it.  And yet, the TDD evangelicals are like the vegans of diet or calisthenicians of fitness -- always annoying, no matter what they say.  (Side note: I was a vegan for many years, and I still thought the loud ones were annoying!)<p>&gt; write it twice<p>This is what I hate so much about unit tests -- you chisel the statue once from stone, then, by writing unit tests, you essentially chisel the inverse to fit your new statue.  So exhausting.</div><br/></div></div></div></div><div id="39732630" class="c"><input type="checkbox" id="c-39732630" checked=""/><div class="controls bullet"><span class="by">mellutussa</span><span>|</span><a href="#39732547">prev</a><span>|</span><a href="#39731654">next</a><span>|</span><label class="collapse" for="c-39732630">[-]</label><label class="expand" for="c-39732630">[1 more]</label></div><br/><div class="children"><div class="content">There was this sailor who always did extra knots and shit on his ropes and lines. Because he wanted it to be extra safe.<p>Then in a storm the ship sank because he couldn&#x27;t undo that shit quickly enough.<p>I guess you can tank your software project too by too much or wrong testing.</div><br/></div></div><div id="39731654" class="c"><input type="checkbox" id="c-39731654" checked=""/><div class="controls bullet"><span class="by">wilkystyle</span><span>|</span><a href="#39732630">prev</a><span>|</span><a href="#39732206">next</a><span>|</span><label class="collapse" for="c-39731654">[-]</label><label class="expand" for="c-39731654">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not going to comment on unit tests (of which we have many), as that seems to be where the biggest divide is, but I will say that our integration tests are worth their weight in gold.</div><br/></div></div><div id="39732206" class="c"><input type="checkbox" id="c-39732206" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#39731654">prev</a><span>|</span><a href="#39731942">next</a><span>|</span><label class="collapse" for="c-39732206">[-]</label><label class="expand" for="c-39732206">[1 more]</label></div><br/><div class="children"><div class="content">Over the lifetime of a code base, most of the value of a test is not in verifying functionality. It&#x27;s keeping you or someone else from accidentally breaking it when you change something.</div><br/></div></div><div id="39731942" class="c"><input type="checkbox" id="c-39731942" checked=""/><div class="controls bullet"><span class="by">andrewl</span><span>|</span><a href="#39732206">prev</a><span>|</span><a href="#39732894">next</a><span>|</span><label class="collapse" for="c-39731942">[-]</label><label class="expand" for="c-39731942">[1 more]</label></div><br/><div class="children"><div class="content">Tests are valuable, but of course they’re never perfect. Certain kinds of programs require them more than others. And no development approach, method, or tool is the best in all cases.<p>The program with the most tests that I’m aware of is SQLite. I have a feeling Hipp and his team know their code extremely well and that they do a lot of thinking before they change anything. Then they run their massive test suite, which they built because they’re good enough to know that they’re not good enough to think everything through without making errors.<p>Tests have saved me from a few blunders over the years.</div><br/></div></div><div id="39732894" class="c"><input type="checkbox" id="c-39732894" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#39731942">prev</a><span>|</span><a href="#39732872">next</a><span>|</span><label class="collapse" for="c-39732894">[-]</label><label class="expand" for="c-39732894">[1 more]</label></div><br/><div class="children"><div class="content">tl;dr; be careful with your testing strategy, it might break your company. There&#x27;s some aspects that stand to gain from automated testing, it&#x27;s important that developers test their work, but in my opinion manual testing is super valuable especially for an early stage start-up.<p>I was working for a startup that first had the strategy of testing everything, at a point when we didn’t even start working on the product. We spent a horrible ammount of time getting the test system up and running (microservices, browser add-ons), with the UI testing being the most challenging.<p>But then they also wanted to &quot;move fast and break things&quot;, which we did, so we spent an annoying ammount of time fixing breaking tests. This is when the “let’s just delete the test” expression started popping up.<p>So we ended up with an unmaintained testing system that no one cared about anymore, keeping our build on red because we always had the testing system in the backlog so it was going to be done at one point.<p>Then, the quality of the codebase started degrading to the point where we’d wake up with features that have been broken for a while and no one noticed it, even though each individual developer was testing their own flows. We had no one &#x2F; nothing testing the entire system.<p>At this point, I suggested we hire 1 – 2 manual testers, as our testing strategies are obviously failing, the product is suffering in terms of quality and we could get them for relatively cheap compared to dev-time. I’ve had great success working with manual testers for very complex products with real world repercussions, compared to this tiny start up in dev tooling.<p>They refused. So they decided we’d do cross functional testing and then test the entire system whenever we’d do a merge. So developer velocity fell from a cliff because we became the manual testers. We still had no customers at this point. Runway got shorter and shorter. And the start-up became a statistic.</div><br/></div></div><div id="39732872" class="c"><input type="checkbox" id="c-39732872" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#39732894">prev</a><span>|</span><a href="#39732076">next</a><span>|</span><label class="collapse" for="c-39732872">[-]</label><label class="expand" for="c-39732872">[1 more]</label></div><br/><div class="children"><div class="content">The whole article can be boiled down to tests are an investment and you should make sure your investments have a return.<p>It sounds obvious but it&#x27;s a valid point. It&#x27;s more common for people to have a dogma based attitude to testing to an investing approach.</div><br/></div></div><div id="39732076" class="c"><input type="checkbox" id="c-39732076" checked=""/><div class="controls bullet"><span class="by">shcheklein</span><span>|</span><a href="#39732872">prev</a><span>|</span><a href="#39732063">next</a><span>|</span><label class="collapse" for="c-39732076">[-]</label><label class="expand" for="c-39732076">[1 more]</label></div><br/><div class="children"><div class="content">There was an interesting discussion recently on (somewhat) opposite perspective <a href="https:&#x2F;&#x2F;antithesis.com&#x2F;blog&#x2F;is_something_bugging_you&#x2F;" rel="nofollow">https:&#x2F;&#x2F;antithesis.com&#x2F;blog&#x2F;is_something_bugging_you&#x2F;</a> - how good testing systems makes everything way faster</div><br/></div></div><div id="39732063" class="c"><input type="checkbox" id="c-39732063" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#39732076">prev</a><span>|</span><a href="#39731563">next</a><span>|</span><label class="collapse" for="c-39732063">[-]</label><label class="expand" for="c-39732063">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Enter Ghostty and Zed.<p>You&#x27;re taking two desktop applications, written in Zig and Rust respectively, and extrapolating their lack of testing rigor as evidence that &quot;there’s no correlation between software quality and tests&quot;? Really?<p>Have you tried maintaining quality in enterprise software without tests? If you ever manage to do so, I&#x27;d be very interested to read about it.</div><br/><div id="39732508" class="c"><input type="checkbox" id="c-39732508" checked=""/><div class="controls bullet"><span class="by">misternugget</span><span>|</span><a href="#39732063">parent</a><span>|</span><a href="#39731563">next</a><span>|</span><label class="collapse" for="c-39732508">[-]</label><label class="expand" for="c-39732508">[1 more]</label></div><br/><div class="children"><div class="content">Hey, author here. Yeah, I worked at Sourcegraph and I do think we built some high-quality stuff and we did write tests. I also think a lot of them were necessary. But, like I wrote here, I think that maybe we&#x2F;I sometimes overdid it with tests and I&#x27;m not so sure about the use of &#x2F;some&#x2F; of them anymore.</div><br/></div></div></div></div><div id="39731563" class="c"><input type="checkbox" id="c-39731563" checked=""/><div class="controls bullet"><span class="by">gustavpaul</span><span>|</span><a href="#39732063">prev</a><span>|</span><a href="#39732085">next</a><span>|</span><label class="collapse" for="c-39731563">[-]</label><label class="expand" for="c-39731563">[1 more]</label></div><br/><div class="children"><div class="content">Write the tests you need to sleep at night and avoid you and others you care about burning out when everything starts falling apart and even the smallest changes inspire dread.</div><br/></div></div><div id="39732085" class="c"><input type="checkbox" id="c-39732085" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#39731563">prev</a><span>|</span><a href="#39731858">next</a><span>|</span><label class="collapse" for="c-39732085">[-]</label><label class="expand" for="c-39732085">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know. When working in an unfamiliar codebase, tests are very helpful (even when some percentage of them will always be annoying). The problem is, the industry has focused on having lots of tests instead of having good code.</div><br/></div></div><div id="39731858" class="c"><input type="checkbox" id="c-39731858" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#39732085">prev</a><span>|</span><a href="#39732027">next</a><span>|</span><label class="collapse" for="c-39731858">[-]</label><label class="expand" for="c-39731858">[2 more]</label></div><br/><div class="children"><div class="content">Rich Hickey once said something in the midst of my “TypeScript, Haskell, la la la la la” phase:<p>&gt; I like to ask this question, what&#x27;s true of every bug ever found in the field? (<i>It got written?</i>) Pff. It got written, yes. What&#x27;s a more interesting fact? (pause) It passed the type checker! What else did it do? (<i>the tests?</i>) It passed <i>all</i> the tests. So <i>now</i> what do you do?<p>The basic problem is that we really want tests to somehow specify the contract of the software, but when you are writing “given, when, then” the “givens” pin down too much of <i>how</i> it is done and the “when&#x2F;then” is scoped to distinct sub-contracts of different parts so it pins down how the work was broken-down...<p>It hits like a syllogism, right? All tests are software, all software has scope creep, scope creep in testing is contract creep.</div><br/><div id="39732859" class="c"><input type="checkbox" id="c-39732859" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#39731858">parent</a><span>|</span><a href="#39732027">next</a><span>|</span><label class="collapse" for="c-39732859">[-]</label><label class="expand" for="c-39732859">[1 more]</label></div><br/><div class="children"><div class="content">Bugs all passed the tests sounds like survior bias.
Like how all the fighter planes that returned with damage had damage to the wings.
Point is, damage anywhere else was fatal, the takeaway should not have been to armor the wings more, which was the first thing which was tried.
Likewise thinking about bugs this way discounts potential bugs that _were_ stopped by tests.</div><br/></div></div></div></div><div id="39732027" class="c"><input type="checkbox" id="c-39732027" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#39731858">prev</a><span>|</span><a href="#39731640">next</a><span>|</span><label class="collapse" for="c-39732027">[-]</label><label class="expand" for="c-39732027">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Maybe the tests are only a symptom. A symptom of something else that causes the quality.<p>Love this comment!</div><br/></div></div><div id="39731640" class="c"><input type="checkbox" id="c-39731640" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#39732027">prev</a><span>|</span><a href="#39731726">next</a><span>|</span><label class="collapse" for="c-39731640">[-]</label><label class="expand" for="c-39731640">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In both codebases I’ve merged PRs without any tests and frequently see others do the same.<p>I would never accept such PR. This kind of policies then end up biting you in the long run (experience talking)</div><br/></div></div><div id="39731726" class="c"><input type="checkbox" id="c-39731726" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39731640">prev</a><span>|</span><a href="#39732602">next</a><span>|</span><label class="collapse" for="c-39731726">[-]</label><label class="expand" for="c-39731726">[1 more]</label></div><br/><div class="children"><div class="content">Editorializing the title to something grammatically-incorrect? Please don&#x27;t.<p>I consider it significant that both of the examples he cited are interactive programs. Thorough testing is low-payoff for those, for two reasons: it&#x27;s common to tweak behaviors a bit, and if something is broken, you&#x27;ll notice in the process of using it. Not <i>no</i> tests, but fewer tests, makes sense.<p>At the opposite end, I&#x27;m working on a VM, and you better believe it&#x27;s got tests. Not enough, it needs more, it always needs more, but they&#x27;re a godsend. When I add an optimization to the compiler, I want confidence that it hasn&#x27;t broken other behaviors, which frequently it does at first. They&#x27;ve enabled several refactors, with at least one more big one on the roadmap. Change one end of the pipeline, change the middle, change the end: half the tests fail, figure out why, the tests are green, all is well.<p>It&#x27;s almost a tautology but: write tests for a reason. Good reasons change over the lifecycle of a program. Early on, fixing simple invariants and preventing regression is a good motive, but with the recognition that things are going to change. Dogmatic TDD can lock in a design too early, if literally everything has a test right from the beginning the effort of every change is multiplied.<p>For a mature systems program designed to be robust and load-bearing, complete coverage could be a good goal. For something like a text editor or terminal emulator, that&#x27;s probably overkill outside of the core components. Tests aren&#x27;t free, but no tests can get pretty expensive too.</div><br/></div></div><div id="39732602" class="c"><input type="checkbox" id="c-39732602" checked=""/><div class="controls bullet"><span class="by">mellutussa</span><span>|</span><a href="#39731726">prev</a><span>|</span><a href="#39732396">next</a><span>|</span><label class="collapse" for="c-39732602">[-]</label><label class="expand" for="c-39732602">[1 more]</label></div><br/><div class="children"><div class="content">&gt; was 100% sure that I know how the code works and that this can’t happen again.<p>No, no, no and nope.</div><br/></div></div></div></div></div></div></div></body></html>