<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://verdagon.dev/blog/vale-memory-safe-cpp">Making C++ safe without borrow checking, reference counting, or tracing GC</a> <span class="domain">(<a href="https://verdagon.dev">verdagon.dev</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>187 comments</span></div><br/><div><div id="36450627" class="c"><input type="checkbox" id="c-36450627" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#36456805">next</a><span>|</span><label class="collapse" for="c-36450627">[-]</label><label class="expand" for="c-36450627">[47 more]</label></div><br/><div class="children"><div class="content">&gt; Borrow checking is incompatible with some useful patterns and optimizations (described later on), and its infectious constraints can have trouble coexisting with non-borrow-checked code.<p>Not that this isn&#x27;t true, but the rest of the article introduces a system with a superset of those limitations, gradually decreasing over time but never becoming a subset. In fact the pattern described in the article is a common pattern in Rust and I make use of it all the time; the library for making use of it is `slotmap`.</div><br/><div id="36453803" class="c"><input type="checkbox" id="c-36453803" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36450627">parent</a><span>|</span><a href="#36451466">next</a><span>|</span><label class="collapse" for="c-36453803">[-]</label><label class="expand" for="c-36453803">[1 more]</label></div><br/><div class="children"><div class="content">Later on, it adds generational references and constraint references to relax the restrictions. These are both more flexible than SlotMap because they don&#x27;t require a new parameter to be passed in from the callers (and callers&#x27; callers etc), which can cause problems when an indirect caller&#x27;s signature can&#x27;t change (trait method override, public API, drop, etc.)</div><br/></div></div><div id="36451466" class="c"><input type="checkbox" id="c-36451466" checked=""/><div class="controls bullet"><span class="by">dxhdr</span><span>|</span><a href="#36450627">parent</a><span>|</span><a href="#36453803">prev</a><span>|</span><a href="#36456205">next</a><span>|</span><label class="collapse" for="c-36451466">[-]</label><label class="expand" for="c-36451466">[30 more]</label></div><br/><div class="children"><div class="content">&gt; In fact the pattern described in the article is a common pattern in Rust and I make use of it all the time; the library for making use of it is `slotmap`.<p>Slotmap uses unsafe everywhere, it&#x27;s a memory usage pattern not supported by the borrow checker. It&#x27;s basically hand-implementing use-after-free and double-free checks, which is what the borrow checker is supposed to do. Is that really a common pattern in Rust?</div><br/><div id="36451508" class="c"><input type="checkbox" id="c-36451508" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451466">parent</a><span>|</span><a href="#36453726">next</a><span>|</span><label class="collapse" for="c-36451508">[-]</label><label class="expand" for="c-36451508">[27 more]</label></div><br/><div class="children"><div class="content">&gt; Slotmap uses unsafe everywhere, it&#x27;s a memory usage pattern not supported by the borrow checker. Is disabling the borrow checker really a common pattern in Rust?<p>Wrapping &quot;unsafe&quot; code in a safe interface is a common pattern in Rust, yes. There is absolutely nothing wrong with using &quot;unsafe&quot; so long as you are diligent about checking invariants, and keep it contained as much as possible. Obviously the standard library uses some &quot;unsafe&quot; as well, for instance.<p>&quot;unsafe&quot; just means &quot;safe but the compiler cannot verify it&quot;.<p>Unsafe does not disable the borrow checker, though. All of the restrictions of safe Rust still apply.  All &quot;unsafe&quot; does is unlock the ability to use raw pointers and a few other constructs.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#unsafe-superpowers" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#unsa...</a></div><br/><div id="36453669" class="c"><input type="checkbox" id="c-36453669" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451508">parent</a><span>|</span><a href="#36456649">next</a><span>|</span><label class="collapse" for="c-36453669">[-]</label><label class="expand" for="c-36453669">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Obviously the standard library uses some &quot;unsafe&quot; as well, for instance.<p>Most beautifully, MaybeUninit&lt;T&gt;::assume_init() -&gt; T<p>This unsafe Rust method says &quot;I promise that I actually did initialize this MaybeUninit&lt;T&gt;, so give me the T&quot;.<p>In terms of the resulting program the machine is not going to do any work whatsoever, a MaybeUninit&lt;T&gt; and a T are the same size, they&#x27;re in the same place, your CPU doesn&#x27;t care that this is a T not a MaybeUninit&lt;T&gt; now.<p>But from a type safety point of view, there&#x27;s all the difference in the world.<p>Even though it won&#x27;t result in emitting any actual CPU instructions, MaybeUninit::assume_init has to be unsafe. Most of the rest of that API surface is not. Because that API call, the one which emitted no CPU instructions, is where you took responsibility for type correctness. If you were wrong, if you haven&#x27;t initialized T properly, everything may be about to go spectacularly wrong and there&#x27;s no-one else to blame but you.</div><br/><div id="36454699" class="c"><input type="checkbox" id="c-36454699" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453669">parent</a><span>|</span><a href="#36456649">next</a><span>|</span><label class="collapse" for="c-36454699">[-]</label><label class="expand" for="c-36454699">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. People miss this all the time when they write off Rust for &quot;needing unsafe to do real programming&quot; or whatever uninformed criticism they&#x27;re parroting (they&#x27;ve clearly never actually done this &quot;real programming&quot; in Rust). The whole point is to reduce the opportunity for unforced errors by marginalizing the cognitive load required for the programmer to ensure the program is correct. And a program with a few unsafe blocks to `assume_init` some memory that e.g. a driver initialized for you is still infinitely better in that regard than a program that&#x27;s littered with `void*` everywhere.</div><br/></div></div></div></div><div id="36456649" class="c"><input type="checkbox" id="c-36456649" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451508">parent</a><span>|</span><a href="#36453669">prev</a><span>|</span><a href="#36452332">next</a><span>|</span><label class="collapse" for="c-36456649">[-]</label><label class="expand" for="c-36456649">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;unsafe&quot; just means &quot;safe but the compiler cannot verify it&quot;.<p>&quot;unsafe&quot; means &quot;safe&quot;?<p>I would say &quot;unsafe&quot; means &quot;only safe if used in a manner that cannot be checked by the compiler&quot;.</div><br/><div id="36456755" class="c"><input type="checkbox" id="c-36456755" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36456649">parent</a><span>|</span><a href="#36452332">next</a><span>|</span><label class="collapse" for="c-36456755">[-]</label><label class="expand" for="c-36456755">[1 more]</label></div><br/><div class="children"><div class="content">There are two things here. The `unsafe` in an `unsafe { ... }` block is referring to the contents of the block. From the outside it is indeed safe to use as if it were safe code. No special requirements necessary. So, yes, from a certain point of view `safe` would have been a better name (albeit confusing in a different way).<p>An `unsafe fn` however does need to be used correctly (and should document those requirements). However, these can only be called within `unsafe` blocks, so see above.</div><br/></div></div></div></div><div id="36452332" class="c"><input type="checkbox" id="c-36452332" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451508">parent</a><span>|</span><a href="#36456649">prev</a><span>|</span><a href="#36451530">next</a><span>|</span><label class="collapse" for="c-36452332">[-]</label><label class="expand" for="c-36452332">[16 more]</label></div><br/><div class="children"><div class="content">If unsafe means “safe but the compiler cannot verify” then I guess just consider .cpp to mean “safe but the compiler cannot verify” and we have suddenly made C++ memory safe</div><br/><div id="36453847" class="c"><input type="checkbox" id="c-36453847" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452332">parent</a><span>|</span><a href="#36453048">next</a><span>|</span><label class="collapse" for="c-36453847">[-]</label><label class="expand" for="c-36453847">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a related idea in Haskell, usually considered a memory safe language.    You <i>can</i> write a program in Haskell that directly mutates memory, or does IO operations, freely, anywhere in the code.  This violates functional purity and the compiler cannot offer its usual promises; your program may very well segfault from a bug in such code.  But sometimes you just have to, perhaps to implement an algorithm efficiently.<p>Still, it is discouraged; both culturally in the language community, and discouraged through the subtle prodding of the language itself (such as everything being typed &quot;IO&quot;, or the slightly ominous &quot;unsafe&quot; in the &quot;unsafePerformIO&quot;.)  Very often, the amount of code that must truly live in IO can be reduced to a few dozen lines, if that.  That code is crucial to get right -- it&#x27;s where the actual sequence of computation and external effects are handled.  Such isolation allows the rest of the code to not have to worry about those matters.</div><br/></div></div><div id="36453048" class="c"><input type="checkbox" id="c-36453048" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452332">parent</a><span>|</span><a href="#36453847">prev</a><span>|</span><a href="#36453933">next</a><span>|</span><label class="collapse" for="c-36453048">[-]</label><label class="expand" for="c-36453048">[4 more]</label></div><br/><div class="children"><div class="content">Sure, and if a typical Rust program that I write has no unsafe in it directly, and 5% of its dependencies&#x27; code have unsafe in them, that&#x27;s also the same as writing a program in the &quot;not c++&quot; language directly, and using &quot;not c++&quot; dependencies for all but 5% of the dependency code.<p>Seems like a silly analogy to me, though.</div><br/><div id="36453292" class="c"><input type="checkbox" id="c-36453292" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453048">parent</a><span>|</span><a href="#36453933">next</a><span>|</span><label class="collapse" for="c-36453292">[-]</label><label class="expand" for="c-36453292">[3 more]</label></div><br/><div class="children"><div class="content">Right but it’s that 5% the origin comment is talking about.  The times when rust has to use unsafe for the type of program.</div><br/><div id="36453644" class="c"><input type="checkbox" id="c-36453644" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453292">parent</a><span>|</span><a href="#36453933">next</a><span>|</span><label class="collapse" for="c-36453644">[-]</label><label class="expand" for="c-36453644">[2 more]</label></div><br/><div class="children"><div class="content">Unsafe Rust is safer than C++, and even if it wasn&#x27;t, 5% unsafe in Rust programs (in well-marked locations) is vastly superior to 100% unsafe in C++ programs.<p>Any analogy that equates the two is silly.</div><br/><div id="36455962" class="c"><input type="checkbox" id="c-36455962" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453644">parent</a><span>|</span><a href="#36453933">next</a><span>|</span><label class="collapse" for="c-36455962">[-]</label><label class="expand" for="c-36455962">[1 more]</label></div><br/><div class="children"><div class="content">unsafe rust is less safe than C++ because of the provenance and aliasing semantics that unsafe rust must adhere to to avoid UB, which are generally tricker than those of C++</div><br/></div></div></div></div></div></div></div></div><div id="36453933" class="c"><input type="checkbox" id="c-36453933" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452332">parent</a><span>|</span><a href="#36453048">prev</a><span>|</span><a href="#36452519">next</a><span>|</span><label class="collapse" for="c-36453933">[-]</label><label class="expand" for="c-36453933">[2 more]</label></div><br/><div class="children"><div class="content">The core value proposition of rust is that it’s memory safe <i>by default</i>, and it’s possible to limit the set of code that needs to be manually checked for UB. This isn’t the case for C++, as any code anywhere can invoke undefined behavior.</div><br/><div id="36456646" class="c"><input type="checkbox" id="c-36456646" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453933">parent</a><span>|</span><a href="#36452519">next</a><span>|</span><label class="collapse" for="c-36456646">[-]</label><label class="expand" for="c-36456646">[1 more]</label></div><br/><div class="children"><div class="content">True, as long static analysers aren&#x27;t part of the build, at which time specific constructs can be made to break the CI&#x2F;CD build, forcing everyone to play by the rules if they want the PR to go through.<p>It isn&#x27;t perfect, but does improve a lot the security baseline.</div><br/></div></div></div></div><div id="36452519" class="c"><input type="checkbox" id="c-36452519" checked=""/><div class="controls bullet"><span class="by">ammar2</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452332">parent</a><span>|</span><a href="#36453933">prev</a><span>|</span><a href="#36453333">next</a><span>|</span><label class="collapse" for="c-36452519">[-]</label><label class="expand" for="c-36452519">[7 more]</label></div><br/><div class="children"><div class="content">Sure but you&#x27;re missing the<p>&gt; so long as you are diligent about checking invariants<p>part. Could you go through and check all the parts of a huge C++ codebase to make sure invariants are held as opposed to a few hundred lines of unsafe Rust code?</div><br/><div id="36452590" class="c"><input type="checkbox" id="c-36452590" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452519">parent</a><span>|</span><a href="#36453333">next</a><span>|</span><label class="collapse" for="c-36452590">[-]</label><label class="expand" for="c-36452590">[6 more]</label></div><br/><div class="children"><div class="content">Sure, but I think the point here is the degree.<p>Presumably if it takes a lot of unsafe rust lines to build something, it won’t matter if it’s 30% safe or whatever.<p>I just see the point of “unsafe is fine” a lot when the whole point of rust is that memory safety issues are never worth the cost.</div><br/><div id="36452778" class="c"><input type="checkbox" id="c-36452778" checked=""/><div class="controls bullet"><span class="by">ammar2</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452590">parent</a><span>|</span><a href="#36455574">next</a><span>|</span><label class="collapse" for="c-36452778">[-]</label><label class="expand" for="c-36452778">[3 more]</label></div><br/><div class="children"><div class="content">Right, I guess the question is what will that proportion be when Rust is used for things like operating systems and web browsers. 30% would be untenable but a few hundred&#x2F;thousand lines of unsafe code is fairly easy to put under a microscope.<p>For some current day research into this, there is the paper &quot;How Do Programmers Use Unsafe Rust?&quot;[1] which I&#x27;ll drop a quote from here:<p>&gt;  The majority of crates (76.4%) contain no unsafe features at all. Even in most crates that do contain unsafe blocks or functions, only a small fraction of the code is unsafe: for 92.3% of all crates, the unsafe statement ratio is at most 10%, i.e., up to 10% of the codebase consists of unsafe blocks and unsafe functions<p>That paper is definitely worth reading and goes into why programmers use unsafe. e.g 5% of the crates at that time were using it to perform FFI.<p>In writing &quot;RUDRA: Finding Memory Safety Bugs in Rust
at the Ecosystem Scale&quot; [2], I recreated this data and year-by-year the % of crates using unsafe is going down. And for what it&#x27;s worth, crates are probably a bad data-set for this. crates tend to be libraries which are exactly where we would expect to find unsafe code encapsulated to be used safely. There&#x27;s also plenty of experimental and hobby crates. A large dataset of actual binaries would be way more interesting to look at.<p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3428204" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3428204</a><p>[2] <a href="https:&#x2F;&#x2F;taesoo.kim&#x2F;pubs&#x2F;2021&#x2F;bae:rudra.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;taesoo.kim&#x2F;pubs&#x2F;2021&#x2F;bae:rudra.pdf</a></div><br/><div id="36453665" class="c"><input type="checkbox" id="c-36453665" checked=""/><div class="controls bullet"><span class="by">Gwypaas</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452778">parent</a><span>|</span><a href="#36453324">next</a><span>|</span><label class="collapse" for="c-36453665">[-]</label><label class="expand" for="c-36453665">[1 more]</label></div><br/><div class="children"><div class="content">Or Rust in Android, in this deep dice gaining two places of unsafe code which found a bug in the existing implementation due to the vetting triggered by being the only two places.<p><a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;12&#x2F;memory-safe-languages-in-android-13.html?m=1" rel="nofollow noreferrer">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;12&#x2F;memory-safe-language...</a></div><br/></div></div><div id="36453324" class="c"><input type="checkbox" id="c-36453324" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452778">parent</a><span>|</span><a href="#36453665">prev</a><span>|</span><a href="#36455574">next</a><span>|</span><label class="collapse" for="c-36453324">[-]</label><label class="expand" for="c-36453324">[1 more]</label></div><br/><div class="children"><div class="content">Ahh that is quite interesting, I’ll check those links out</div><br/></div></div></div></div><div id="36455574" class="c"><input type="checkbox" id="c-36455574" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452590">parent</a><span>|</span><a href="#36452778">prev</a><span>|</span><a href="#36453333">next</a><span>|</span><label class="collapse" for="c-36455574">[-]</label><label class="expand" for="c-36455574">[2 more]</label></div><br/><div class="children"><div class="content">Looking at a couple of programs I work on:<p>9,500 lines of code, 8 are unsafe.<p>7,000 lines of code, 22 are unsafe.<p>14,000 lines of code, 140 are unsafe.<p>As we follow the standard rust rule that &quot;safe code should not be able to use unsafe code to do unsafe things&quot;, those unsafe bits of code have been very carefully checked, to the best of our abilities, to ensure they don&#x27;t create memory safety issues. It is a lot easier to triple-check 170 lines of code than  30,000 lines.</div><br/><div id="36456120" class="c"><input type="checkbox" id="c-36456120" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36455574">parent</a><span>|</span><a href="#36453333">next</a><span>|</span><label class="collapse" for="c-36456120">[-]</label><label class="expand" for="c-36456120">[1 more]</label></div><br/><div class="children"><div class="content">Sharpview, my metaverse viewer: 36,000 lines, 0 are unsafe.<p>I use some published crates that have unsafe code, but my own programs start with<p><pre><code>    #![forbid(unsafe_code)]
</code></pre>
This is 60FPS 3D high-detail graphics stuff, where performance matters.</div><br/></div></div></div></div></div></div></div></div><div id="36453333" class="c"><input type="checkbox" id="c-36453333" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452332">parent</a><span>|</span><a href="#36452519">prev</a><span>|</span><a href="#36451530">next</a><span>|</span><label class="collapse" for="c-36453333">[-]</label><label class="expand" for="c-36453333">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not what unsafe means. Unsafe means this might cause UB for some invocations (accessing raw pointers, calling into another language, etc.). Safe means it will not cause UB for any invocations (it may panic or abort).</div><br/></div></div></div></div><div id="36451530" class="c"><input type="checkbox" id="c-36451530" checked=""/><div class="controls bullet"><span class="by">dxhdr</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451508">parent</a><span>|</span><a href="#36452332">prev</a><span>|</span><a href="#36453726">next</a><span>|</span><label class="collapse" for="c-36451530">[-]</label><label class="expand" for="c-36451530">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s essentially a &quot;user-space&quot; memory allocator with it&#x27;s own use-after-free and double-free checks, apparently because the language implementation isn&#x27;t adequate. If anything it just reinforces the articles point that &quot;borrow checking is incompatible with some useful patterns and optimizations.&quot;</div><br/><div id="36451568" class="c"><input type="checkbox" id="c-36451568" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451530">parent</a><span>|</span><a href="#36453726">next</a><span>|</span><label class="collapse" for="c-36451568">[-]</label><label class="expand" for="c-36451568">[5 more]</label></div><br/><div class="children"><div class="content">Eh? This is a wild take. How do you draw the conclusion the default implementation is inadequate?</div><br/><div id="36451857" class="c"><input type="checkbox" id="c-36451857" checked=""/><div class="controls bullet"><span class="by">dymk</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451568">parent</a><span>|</span><a href="#36453726">next</a><span>|</span><label class="collapse" for="c-36451857">[-]</label><label class="expand" for="c-36451857">[4 more]</label></div><br/><div class="children"><div class="content">Because something like slotmap has to use `unsafe` to get around the inadequacies of the borrow checker...</div><br/><div id="36453702" class="c"><input type="checkbox" id="c-36453702" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451857">parent</a><span>|</span><a href="#36452324">next</a><span>|</span><label class="collapse" for="c-36453702">[-]</label><label class="expand" for="c-36453702">[2 more]</label></div><br/><div class="children"><div class="content">Author of slotmap here.<p>There is absolutely no <i>need</i> for unsafe in slotmap. I chose to use unsafe (wrapped in a safe API) to reduce memory usage using intrusive linked freelists.
If done using safe Rust this would involve `enum`s that would take up extra space.</div><br/><div id="36456654" class="c"><input type="checkbox" id="c-36456654" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36453702">parent</a><span>|</span><a href="#36452324">next</a><span>|</span><label class="collapse" for="c-36456654">[-]</label><label class="expand" for="c-36456654">[1 more]</label></div><br/><div class="children"><div class="content">Thus not adequate for performance requirements.</div><br/></div></div></div></div><div id="36452324" class="c"><input type="checkbox" id="c-36452324" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451857">parent</a><span>|</span><a href="#36453702">prev</a><span>|</span><a href="#36453726">next</a><span>|</span><label class="collapse" for="c-36452324">[-]</label><label class="expand" for="c-36452324">[1 more]</label></div><br/><div class="children"><div class="content">A downside for sure, but one that, at least in this specific example, has limited downsides. If you can button it up into a safe abstraction that you can share with others, then I don&#x27;t really see what the huge problem is. The fact that you might need to write `unsafe` inside of a well optimized data structure isn&#x27;t a weakness of Rust, it&#x27;s the entire point: you use it to encapsulate an unsafe core within a safe interface. The standard library is full of these things.<p>Now if you&#x27;re trying to do something that you can&#x27;t button up into a safe abstraction for others to use, then that&#x27;s a different story.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36453726" class="c"><input type="checkbox" id="c-36453726" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451466">parent</a><span>|</span><a href="#36451508">prev</a><span>|</span><a href="#36454635">next</a><span>|</span><label class="collapse" for="c-36453726">[-]</label><label class="expand" for="c-36453726">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Slotmap uses unsafe everywhere, it&#x27;s a memory usage pattern not supported by the borrow checker.<p>Author of slotmap here. This is patently false.<p>Yes, the slotmap crate uses a lot of unsafe to squeeze out maximum performance. But it is not &#x27;a memory usage pattern not supported by the borrow checker&#x27;. You can absolutely write a crate with an API identical to slotmap without using unsafe.</div><br/></div></div><div id="36454635" class="c"><input type="checkbox" id="c-36454635" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451466">parent</a><span>|</span><a href="#36453726">prev</a><span>|</span><a href="#36456205">next</a><span>|</span><label class="collapse" for="c-36454635">[-]</label><label class="expand" for="c-36454635">[1 more]</label></div><br/><div class="children"><div class="content">I have implemented my own slotmap crate for a lisp interpreter that uses no unsafe code and provides exactly the same features as the &quot;standard&quot; slotmap crate.<p>There is nothing inherent to the slotmap that requires unsafe code! It&#x27;s only used for optimizations purposes.<p>Mine works in a similar way to the &quot;standard&quot; slotmap. It&#x27;s a vec of slots, slot is an enum that can be occupied or vacant, the occupied variant is a two tuple containing the value and generation, vacant holds just a generation. Inserting into the slotmap simply switches the variant of the slot from vacant to occupied, and popping does the reverse. If there is no currently vacant slots, we just use the underlying push method on the vec of slots which will handle resizing for us! I also store a stack of indexes to vacant slots to make insertion fast.<p>When you insert into the slotmap, it provides a opaque key, but the data inside is an index and a generation. When you attempt to retrieve a value with a key, the slotmap checks if the slot is occupied and if the generation matches, and if so returns the value, otherwise returns none.<p>There is also a indirect slotmap, that adds an extra layer of indirection, so rather than the key being an index directly into the underlying vec of slots, its an index into a vec of indexes, this allows moving the slots around without invaliding currently living keys.<p>The indirect slotmap has the advantage of faster iteration, since it doesn&#x27;t have to skip over empty &quot;holes&quot; of vacant slots in the vec of slots. The tradeoff is that insertion is slightly slower!<p>Anyways, no unsafe is required to implement a performant slotmap data structure! I have not uploaded my slotmap to crates.io because I didn&#x27;t think anyone would find it useful, but maybe I should reconsider this!</div><br/></div></div></div></div><div id="36456205" class="c"><input type="checkbox" id="c-36456205" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36450627">parent</a><span>|</span><a href="#36451466">prev</a><span>|</span><a href="#36450973">next</a><span>|</span><label class="collapse" for="c-36456205">[-]</label><label class="expand" for="c-36456205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Borrow checking is incompatible with some useful patterns.<p>The main problem is back references, as in doubly linked lists. In Rust, you can do that sort of thing using Rc and the weak&#x2F;strong reference mechanism. Forward references own, and are strong. Back references are weak.<p>I&#x27;ve been toying with the idea of some generic types which allow strong forward references which you can&#x27;t copy or clone, and weak back references which you can&#x27;t make strong outside a contained scope. This can be implemented with the existing Rc system, and potentially could be proven, with a static analyzer, to not require the reference counts. It&#x27;s worth a try to see if one can effectively program under those restrictions. If it&#x27;s not too much of a pain to use, this might be an effective way out of Rust&#x27;s back-reference problem.</div><br/></div></div><div id="36450973" class="c"><input type="checkbox" id="c-36450973" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36450627">parent</a><span>|</span><a href="#36456205">prev</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36450973">[-]</label><label class="expand" for="c-36450973">[13 more]</label></div><br/><div class="children"><div class="content">I would really love a definitive answer on whether the borrow checker and rust’s rules do really limit optimizations and such.<p>It seems like I see this opinion often and every time there are tons of people on both sides who seem sure they are correct.<p>What are the limitations for optimization? Does unsafe rust really force those?</div><br/><div id="36451043" class="c"><input type="checkbox" id="c-36451043" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36450973">parent</a><span>|</span><a href="#36451468">next</a><span>|</span><label class="collapse" for="c-36451043">[-]</label><label class="expand" for="c-36451043">[1 more]</label></div><br/><div class="children"><div class="content">The question is far too broad, and contextual. You&#x27;re never going to get an answer to that question.<p>Sometimes, the rules add more optimization potential. (like how restrict technically exists in C but is on every (okay <i>almost every</i>) reference in Rust) Sometimes, the rules let you be more confident that a trickier and faster design will be maintainable over time, so even if it is possible without these rules, you may not be able to do that in practice. (Stylo)<p>Sometimes, they may result in slower things. Maybe while you <i>could</i> use Rust&#x27;s type system to help you with a design, it&#x27;s too tough for you, or simply not worth the effort, so you make a copy instead of using a reference. Maybe the compiler isn&#x27;t fantastic at compiling away an abstraction, and you end up with slower code than you otherwise would.<p>And that&#x27;s before you get into complexities like &quot;I see Rc&lt;RefCell&lt;T&gt;&gt; all the time in Rust code&quot; &quot;that doesn&#x27;t make sense, I never see that pattern in code&quot;.</div><br/></div></div><div id="36451468" class="c"><input type="checkbox" id="c-36451468" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36450973">parent</a><span>|</span><a href="#36451043">prev</a><span>|</span><a href="#36451146">next</a><span>|</span><label class="collapse" for="c-36451468">[-]</label><label class="expand" for="c-36451468">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say it mostly applies to manual optimization, when we&#x27;re restructuring our program.<p>If the situation calls for a B-tree, the borrow checker loves that. If the situation calls for some sort of intrusive or self-referential data structure (like in <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;907876&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;907876&#x2F;</a>), then you might have to retreat to a different data structure which could incur more bounds checking, hasher costs, or expansion costs.<p>It&#x27;s probably not worth worrying about most the time, unless you&#x27;re in a <i>very</i> performance-sensitive situation.</div><br/></div></div><div id="36451146" class="c"><input type="checkbox" id="c-36451146" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36450973">parent</a><span>|</span><a href="#36451468">prev</a><span>|</span><a href="#36451027">next</a><span>|</span><label class="collapse" for="c-36451146">[-]</label><label class="expand" for="c-36451146">[1 more]</label></div><br/><div class="children"><div class="content">There can be no answer.  Research is ongoing, smart people are actively trying to make optimizer better, so even if I gave a 100% correct answer now (which would be pages long), a new commit 1 minute latter will change the rules.  Sometimes someone discovers what we thought was safe isn&#x27;t safe in some obscure case and so we are forced to no longer apply some optimization. sometimes optimization is a compromise and we decide that the using a couple extra CPU cycles is worth it because of some other gain (a CPU cycle is often impossible to measure in the real world as things like caches tend to dominate benchmarks, so you can make this comprise many times when suddenly the total adds up to something you can measure.).<p>The short answer for those who don&#x27;t want details: it is unlikely you can measure a difference in real world code assuming good clean code with the right algorithm.</div><br/></div></div><div id="36451027" class="c"><input type="checkbox" id="c-36451027" checked=""/><div class="controls bullet"><span class="by">apendleton</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36450973">parent</a><span>|</span><a href="#36451146">prev</a><span>|</span><a href="#36451354">next</a><span>|</span><label class="collapse" for="c-36451027">[-]</label><label class="expand" for="c-36451027">[1 more]</label></div><br/><div class="children"><div class="content">Without directly answering your question, it&#x27;s worth noting that there are also additional optimizations made available by Rust that are not easily accessible in C&#x2F;C++ (mostly around stronger guarantees the Rust compiler is able to make about aliasing).</div><br/></div></div><div id="36451354" class="c"><input type="checkbox" id="c-36451354" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36450973">parent</a><span>|</span><a href="#36451027">prev</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36451354">[-]</label><label class="expand" for="c-36451354">[8 more]</label></div><br/><div class="children"><div class="content">Difficult to answer.<p>However, what you can say is that the borrow-checker works like a straight-jacket for the programmer, making them less capable to focus on other things like performance issues, high-level data leaks (e.g. a map that is filled with values without removing them eventually), or high-level safety issues.</div><br/><div id="36451411" class="c"><input type="checkbox" id="c-36451411" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451354">parent</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36451411">[-]</label><label class="expand" for="c-36451411">[7 more]</label></div><br/><div class="children"><div class="content">You can also say that the borrow checker works like a helpful editor, double checking your work, so that you can focus on the important details of performance issues, safety issues, and such, without needing to waste brain power on the low-level details.</div><br/><div id="36451834" class="c"><input type="checkbox" id="c-36451834" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451411">parent</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36451834">[-]</label><label class="expand" for="c-36451834">[6 more]</label></div><br/><div class="children"><div class="content">This would be true if code using the borrow checker was easier to read than to write.</div><br/><div id="36452072" class="c"><input type="checkbox" id="c-36452072" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451834">parent</a><span>|</span><a href="#36452497">next</a><span>|</span><label class="collapse" for="c-36452072">[-]</label><label class="expand" for="c-36452072">[2 more]</label></div><br/><div class="children"><div class="content">The point is that the compiler helps you “read” it. This takes mental effort off of you.<p>I agree that not everyone thinks this is true, but this is my experience. I do not relate to the compiler as a straight jacket. I relate to it as a helpful assistant.</div><br/><div id="36453073" class="c"><input type="checkbox" id="c-36453073" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452072">parent</a><span>|</span><a href="#36452497">next</a><span>|</span><label class="collapse" for="c-36453073">[-]</label><label class="expand" for="c-36453073">[1 more]</label></div><br/><div class="children"><div class="content">This is my experience as well. I find it much easier to work faster when the compiler is helping me, and I don&#x27;t consider it a &quot;straitjacket&quot; at all.</div><br/></div></div></div></div><div id="36452497" class="c"><input type="checkbox" id="c-36452497" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36451834">parent</a><span>|</span><a href="#36452072">prev</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36452497">[-]</label><label class="expand" for="c-36452497">[3 more]</label></div><br/><div class="children"><div class="content">I think it’s generally accepted that writing code is nearly universally easier than reading code, in any language. That aside, getting a mechanical check on memory safety for the price of some extra language verbosity is obviously worth it IMO.<p>By the same token, it is common to see criticisms of the complexity of templates in C++, but templates are the cornerstone of “Modern C++” and many libraries could not exist without them.</div><br/><div id="36454790" class="c"><input type="checkbox" id="c-36454790" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36452497">parent</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36454790">[-]</label><label class="expand" for="c-36454790">[2 more]</label></div><br/><div class="children"><div class="content">&gt; getting a mechanical check on memory safety for the price of some extra language verbosity is obviously worth it IMO<p>But a GC&#x27;d language doesn&#x27;t require the extra verbosity.</div><br/><div id="36454978" class="c"><input type="checkbox" id="c-36454978" checked=""/><div class="controls bullet"><span class="by">buildartefact</span><span>|</span><a href="#36450627">root</a><span>|</span><a href="#36454790">parent</a><span>|</span><a href="#36451430">next</a><span>|</span><label class="collapse" for="c-36454978">[-]</label><label class="expand" for="c-36454978">[1 more]</label></div><br/><div class="children"><div class="content">And you pay for that in performance</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36456805" class="c"><input type="checkbox" id="c-36456805" checked=""/><div class="controls bullet"><span class="by">axilmar</span><span>|</span><a href="#36450627">prev</a><span>|</span><a href="#36456193">next</a><span>|</span><label class="collapse" for="c-36456805">[-]</label><label class="expand" for="c-36456805">[1 more]</label></div><br/><div class="children"><div class="content">My idea for C++ memory safety would be compile time reference counting.<p>I.e. the compiler&#x2F;tool to go through the code, as if it was executing, and apply reference counting to objects, revealing whether an object will be destroyed normally, prematurely or never.<p>This is what we actually do as humans by the way, when we are developing an algorithm in C++ with manual memory management. We do it implicitly though.</div><br/></div></div><div id="36456193" class="c"><input type="checkbox" id="c-36456193" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36456805">prev</a><span>|</span><a href="#36450815">next</a><span>|</span><label class="collapse" for="c-36456193">[-]</label><label class="expand" for="c-36456193">[2 more]</label></div><br/><div class="children"><div class="content">Well, what&#x27;s new here?<p><i>Generational References</i>, random or sequential<p>That&#x27;s an old idea. Goes back to at least the 1980s. It&#x27;s a useful way to detect use-after-free at run time, but doesn&#x27;t prevent it. &quot;To get access to an object, we first check (&quot;generation check&quot;) that the current generation number matches the remembered generation number. If not, we safely signal a segmentation fault.&quot; Um.<p><i>Rule 5: We can only read a field by taking ownership of it, by either swapping something into its place or destroying the containing struct.</i><p>Hm. This is single ownership with move semantics on steroids. There was once some enthusiasm for languages where you could only read a variable once. But that didn&#x27;t go very far. On the other hand, single <i>assignment</i>, where you can only write once, on the other hand, is now widely accepted and useful.<p>I doubt that any collection of hacks on top of C++ will make it safe. Too many people, including me, have tried. To increase safety, you have to take things out. This is unpopular and breaks backwards compatibility.</div><br/><div id="36456667" class="c"><input type="checkbox" id="c-36456667" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36456193">parent</a><span>|</span><a href="#36450815">next</a><span>|</span><label class="collapse" for="c-36456667">[-]</label><label class="expand" for="c-36456667">[1 more]</label></div><br/><div class="children"><div class="content">One way to take things out is to have something like Sonar on the CI&#x2F;CD pipeline, configured exactly to take specific patterns out, that break the PR builds and won&#x27;t get greelighted for merging.<p>Yeah, not everyone likes those of us that share development roles alongside security best practices enforcement.</div><br/></div></div></div></div><div id="36450815" class="c"><input type="checkbox" id="c-36450815" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36456193">prev</a><span>|</span><a href="#36450368">next</a><span>|</span><label class="collapse" for="c-36450815">[-]</label><label class="expand" for="c-36450815">[13 more]</label></div><br/><div class="children"><div class="content">Methods such as these for C and C++ are interesting, and needed, but only solve a part of the problem.<p>As others have noted before, they do little good because they&#x27;re opt-in. I think there&#x27;s a bit of nuance to that which needs to be explored though, as I think it&#x27;s less a problem that the extra checks are opt in, and more a problem of how we use and categorize libraries.<p>As long as we encourage dynamic and static library inclusion (and why wouldn&#x27;t we, it&#x27;s how we build upon the work of others), every language has a problem similar to how C and C++ are opt-in and you can&#x27;t easily control the code you include or link.  If you load openssl from Java or Rust or Go, you might have some benefit from a well defined API layer, but ultimately you are still beholden to the code openssl provides in their library.<p>Just as one of the real benefits of Rust or Java or Go is not necessarily that the code is completely safe, but that weird unsafe behavior usually requires special escape hatches which are easier to audit, what we need are ways to categorize the code we include, no matter the language it comes from, with appropriate labels that denote how strong the safeguard guarantees it was compiled with are and of which type, so we can make easier and better informed decisions on what to include and how to audit it easily when we do.<p>This applies to including something written in Rust as well. If someone is writing something in C++ and wants to include a library written in Rust, that it&#x27;s written in Rust is only part of the picture. It&#x27;s equally important to how often (as a total and as a percentage of code) the safety checks that language required (or that the developers opted into) where escaped in that library.<p>If the choice is a Rust library with 95% of the code in unsafe blocks or a C++ library that opted into multiple different safety checker systems and has almost no escapes from those requirements, Rust is not providing any real safety benefits in that situation, is it? What we need is better information exposed at a higher level to developers about what they&#x27;re opting into when they use third party code, because we can all control what safety mechanisms we use ourselves, so that&#x27;s mostly a solved problem.</div><br/><div id="36453131" class="c"><input type="checkbox" id="c-36453131" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36450815">parent</a><span>|</span><a href="#36454854">next</a><span>|</span><label class="collapse" for="c-36453131">[-]</label><label class="expand" for="c-36453131">[1 more]</label></div><br/><div class="children"><div class="content">I feel like a few languages are better than others in a related but not quite identical area:<p>Languages like Java and Go, while they CAN escape to native libraries, have cultures that tend to avoid that kind of thing. At least, in my projects, I have quite an easy time using zero native dependencies with those languages (except for the underlying kernel of course), and so I feel like there is a much lower chance of escape-hatch issues sneaking in.<p>They aren&#x27;t built on a foundation of legacy C and C++ libraries - not even the crypto - and I find that to be an advantage.</div><br/></div></div><div id="36454854" class="c"><input type="checkbox" id="c-36454854" checked=""/><div class="controls bullet"><span class="by">gridspy</span><span>|</span><a href="#36450815">parent</a><span>|</span><a href="#36453131">prev</a><span>|</span><a href="#36450884">next</a><span>|</span><label class="collapse" for="c-36454854">[-]</label><label class="expand" for="c-36454854">[3 more]</label></div><br/><div class="children"><div class="content">Often missed here is that the Rust library author is strongly protected from faulty code written by Users. The C&#x2F;C++ library author is not.<p>The most obvious examples of this are memory allocation. The C&#x2F;C++ user claimed the buffer was large enough to contain the result. The Rust user received back an object that protected the memory and returned it at the right time.<p>But it could also be a file handle or mutex that used the Rust ownership patterns to protect the underlying data.<p>If I am using a library and the author can put in features that prevent misuse, I don&#x27;t need to work so hard to use the library correctly. As soon as my safe code compiles I can be fairly sure with most rust libraries that I didn&#x27;t break some unenforced rule.</div><br/><div id="36456097" class="c"><input type="checkbox" id="c-36456097" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36454854">parent</a><span>|</span><a href="#36450884">next</a><span>|</span><label class="collapse" for="c-36456097">[-]</label><label class="expand" for="c-36456097">[2 more]</label></div><br/><div class="children"><div class="content">That may be true but it doesn&#x27;t help downstream users <i>know</i> what they&#x27;re opting into. Knowing that a rust library <i>can</i> use no unsafe code is not the same as knowing that that library <i>did</i> use no unsafe code, in a similar way to knowing that a C library <i>can</i> be coded with the help of various tools to provide additional safery (in some cases beyond what rust provides natively) is not the same as knowing they <i>did</i>.<p>In other words, that something was written in a specific language is far too coarse and blunt an assessment to really know what you&#x27;re getting into.<p>Rust libraries may be, in aggregate, far more likely to have additional safety than C libraries because of features rust provides that are generally used, but you can know <i>nothing</i> about the specific relative safety of a single rust library and C library without looking closer, at the code level. Having indicators of exactly that info surfaced in descriptions about libraries would be a major step forward IMO. I think it would also probably immediately benefit rust if it were to happen, as the info would cast many rust libraries in a beneficial light in comparison to others, but to me that&#x27;s far less important than promoting better practices overall regardless of language by allowing users to better choose between them, regardless of language.</div><br/><div id="36456679" class="c"><input type="checkbox" id="c-36456679" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36456097">parent</a><span>|</span><a href="#36450884">next</a><span>|</span><label class="collapse" for="c-36456679">[-]</label><label class="expand" for="c-36456679">[1 more]</label></div><br/><div class="children"><div class="content">If the cybersecurity guidelines keep being improved upon, I expect security assements to be a requirement for 3rd party libraries, regardless of the language, just like we already have to do legal checks before being allowed to add them into the internal package server.</div><br/></div></div></div></div></div></div><div id="36450884" class="c"><input type="checkbox" id="c-36450884" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36450815">parent</a><span>|</span><a href="#36454854">prev</a><span>|</span><a href="#36450891">next</a><span>|</span><label class="collapse" for="c-36450884">[-]</label><label class="expand" for="c-36450884">[1 more]</label></div><br/><div class="children"><div class="content">This is a great point, and one that doesn&#x27;t get enough attention. The article talks about using a static analysis tool, but usage of that tool is indeed opt-in, like you say.<p>I suspect a language could mitigate this with the ability to sandbox a library&#x27;s code. That could be pretty slow though, but we could compile it to wasm and then use wasm2c to convert it back into native code. I wrote a bit about this idea in [0], but I&#x27;d love to see someone make this work for C++.<p>[0] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;fearless-ffi" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;fearless-ffi</a></div><br/></div></div><div id="36450891" class="c"><input type="checkbox" id="c-36450891" checked=""/><div class="controls bullet"><span class="by">jackmott42</span><span>|</span><a href="#36450815">parent</a><span>|</span><a href="#36450884">prev</a><span>|</span><a href="#36454419">next</a><span>|</span><label class="collapse" for="c-36450891">[-]</label><label class="expand" for="c-36450891">[2 more]</label></div><br/><div class="children"><div class="content">If you were starting a new project you could put lints in place to make these things enforced. But at some point you have all these lints and customizations in place, and you can&#x27;t use old or 3rd party C++ code any more because of them, so you begin to ask, why not just use a new language where this stuff isn&#x27;t pasted together with glue and bailing wire?</div><br/><div id="36450996" class="c"><input type="checkbox" id="c-36450996" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36450891">parent</a><span>|</span><a href="#36454419">next</a><span>|</span><label class="collapse" for="c-36450996">[-]</label><label class="expand" for="c-36450996">[1 more]</label></div><br/><div class="children"><div class="content">My point is really not about the code you write yourself, but the code you need to include in your project. Rare is the professional programmer that always gets to finish their project using only code they wrote themselves, and for many projects that&#x27;s <i>highly inadvisable</i> (don&#x27;t roll your own crypt unless you have a very good reason).<p>So, given that at times we will have to use external libraries, and given that even very safe languages often have escape hatches meaning you can&#x27;t be <i>sure</i> the code of one language has more constraints than another, it would be great to have other indicators than the language it was written in that indicated what safety checks it uses.<p>If next year you&#x27;re writing a new program in a language that hasn&#x27;t even been invented as of now, and is viewed as safer than every language out today, what does that actually get you if one of your constraints is that you need to include and use openssl or one of a few forks for compatibility reasons? Wouldn&#x27;t you rather be able to look at the available options and see that come opt into specific safety constraints, and have been good about not them circumventing them, and do so <i>extremely easily</i>? Network effects and existing known projects seem to have an inordinate amount of staying power, so we might as well deal with that as a fact.<p>The world is a messy place, but the more information we have the better our chances of making order out of it, even if temporarily.</div><br/></div></div></div></div><div id="36454419" class="c"><input type="checkbox" id="c-36454419" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36450815">parent</a><span>|</span><a href="#36450891">prev</a><span>|</span><a href="#36450368">next</a><span>|</span><label class="collapse" for="c-36454419">[-]</label><label class="expand" for="c-36454419">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If the choice is a Rust library with 95% of the code in unsafe blocks, ... Rust is not providing any real safety benefits in that situation, is it?<p>If the choice is a C library with 95% of the code in inline assembly, ... C is not providing any benefits in that situation, is it?</div><br/><div id="36456640" class="c"><input type="checkbox" id="c-36456640" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36454419">parent</a><span>|</span><a href="#36454704">next</a><span>|</span><label class="collapse" for="c-36456640">[-]</label><label class="expand" for="c-36456640">[1 more]</label></div><br/><div class="children"><div class="content">People have this misconception that unsafe Rust is some other language. It&#x27;s not. All it does is allow the use of raw pointers. So, all other Rust feature (ie type system) still work as they always did. So, you can really minimia the surface are of unsafe code. Not to mention seeing unsafe just means that something really low level is happening, and signals caution to the reader (or anyone editing the code), as opose to C++ where it&#x27;s easy to forget you need to be alert, since you should be alert all the time really.</div><br/></div></div><div id="36454704" class="c"><input type="checkbox" id="c-36454704" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36454419">parent</a><span>|</span><a href="#36456640">prev</a><span>|</span><a href="#36450368">next</a><span>|</span><label class="collapse" for="c-36454704">[-]</label><label class="expand" for="c-36454704">[3 more]</label></div><br/><div class="children"><div class="content">Exactly.  Presumably there are some opt-in tools that are very strict about the inline assembly uses you have in C.  I don&#x27;t have any experience with them, but I&#x27;m sure they exist.<p>That&#x27;s the whole point, it&#x27;s less about the language, and more about the specifics of the code itself in a testable way. Saying something is written in C without accounting for a bunch of inline assembly is analogous to saying something is written in Rust and not accounting for a bunch of unsafe blocks.  Not in that they are equivalently safe or unsafe, but that that high level assumptions because of the language fail because of the practices done within.<p>If I had to choose between two libraries written in C and one was pure C and one was 50% inlined assembly, and I viewed security and safety as more important for my use case, I know which one I would choose if that information was surfaced to me easily.</div><br/><div id="36454750" class="c"><input type="checkbox" id="c-36454750" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36454704">parent</a><span>|</span><a href="#36450368">next</a><span>|</span><label class="collapse" for="c-36454750">[-]</label><label class="expand" for="c-36454750">[2 more]</label></div><br/><div class="children"><div class="content">There are no Rust crates with 95% unsafe code.</div><br/><div id="36456450" class="c"><input type="checkbox" id="c-36456450" checked=""/><div class="controls bullet"><span class="by">barsonme</span><span>|</span><a href="#36450815">root</a><span>|</span><a href="#36454750">parent</a><span>|</span><a href="#36450368">next</a><span>|</span><label class="collapse" for="c-36456450">[-]</label><label class="expand" for="c-36456450">[1 more]</label></div><br/><div class="children"><div class="content">Crates that only make FFI calls exist. I have written some. :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36450368" class="c"><input type="checkbox" id="c-36450368" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#36450815">prev</a><span>|</span><a href="#36449579">next</a><span>|</span><label class="collapse" for="c-36450368">[-]</label><label class="expand" for="c-36450368">[7 more]</label></div><br/><div class="children"><div class="content">RIP all the modern languages that haven&#x27;t made any improvements in memory management at all.<p>There is so much low hanging fruit in programming language design and nobody is picking it up and instead everyone produces marginal improvements over existing languages.</div><br/><div id="36450502" class="c"><input type="checkbox" id="c-36450502" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#36450368">parent</a><span>|</span><a href="#36453862">next</a><span>|</span><label class="collapse" for="c-36450502">[-]</label><label class="expand" for="c-36450502">[4 more]</label></div><br/><div class="children"><div class="content">Because implementing a new language and getting it to wide adoption is an enormously challenging task, with a much lower success rate than e.g. SV startups.<p>Languages that try to implement one new bright idea don&#x27;t go anywhere,  because that&#x27;s not enough to cause people to switch. At best they serve as examples for feature adoption in other languages.<p>Look at Rust for example: it seems to be succeeding and gaining adoption, but right now it&#x27;s still relatively niche (check the number of Rust job postings), and it&#x27;s taken 17 years to get to this point, with sponsorship from major organizations like Mozilla.<p>Given this, the idea that there&#x27;s much low-hanging fruit that&#x27;s being ignored, that could easily be exploited, seems dubious. What&#x27;s an example of what you have in mind?</div><br/><div id="36450604" class="c"><input type="checkbox" id="c-36450604" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36450368">root</a><span>|</span><a href="#36450502">parent</a><span>|</span><a href="#36453862">next</a><span>|</span><label class="collapse" for="c-36450604">[-]</label><label class="expand" for="c-36450604">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s taken 17 years to get to this point<p>Yes and no.  Rust went through quite a bit of changes early on, ro the point that it&#x27;s not really that similar of a language, and 1.0 was released in May 2015.<p>That&#x27;s still quite a while (8 years), but IMO doesn&#x27;t quite mean the same thing as a language that&#x27;s been around for 17 years with a similar level of adoption. My impression (from the outside) is that Rust usage is still increasing, at least in specific areas, and has not leveled off or tapered. It doesn&#x27;t seem to be exploding into lots of teams and places, but it does seem to be getting footholds still, like at Azure.</div><br/><div id="36451757" class="c"><input type="checkbox" id="c-36451757" checked=""/><div class="controls bullet"><span class="by">tcmart14</span><span>|</span><a href="#36450368">root</a><span>|</span><a href="#36450604">parent</a><span>|</span><a href="#36453862">next</a><span>|</span><label class="collapse" for="c-36451757">[-]</label><label class="expand" for="c-36451757">[2 more]</label></div><br/><div class="children"><div class="content">While that is true about Rust, most new languages are gonna have the same thing. It&#x27;ll be years before they get to 1.0. Look at Zig, just about every new language. So I don&#x27;t think it is valid to discount the 1.0 days because all languages are gonna need awhile to get to the 1.0 day. It still took 17 years of time investment to get Rust to where it is today.</div><br/><div id="36453708" class="c"><input type="checkbox" id="c-36453708" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#36450368">root</a><span>|</span><a href="#36451757">parent</a><span>|</span><a href="#36453862">next</a><span>|</span><label class="collapse" for="c-36453708">[-]</label><label class="expand" for="c-36453708">[1 more]</label></div><br/><div class="children"><div class="content">I discount the early days because I don&#x27;t think most professionals would rely on a language pre-1.0 that advertises it will stabilize at 1.0, so regardless of whether it spends 6 months or 10 years pre-1.0, with regard to wider adoption you&#x27;ll only be able to make limited inferences about what that period means.<p>For example, you say 17 years, but it was a side project for the first four of those, and was only publicly announced as Rust from 2010 on from what I can find (given there&#x27;s no way my memory is that good), but the following two announcements back that up.[1][2]  If it&#x27;s not really public or being advertised, I&#x27;m not sure how that can count towards adoption over time.  Additionally, if it&#x27;s advertised but with the caveat that it&#x27;s pre-release and just for playing with as a proof of concept, should that count towards the adoption timeline? Counting periods when people were specifically warded off in a project&#x27;s lifetime also seems odd to me, but your assessment would also use that as an indicator of what it&#x27;s achieved over time.<p>I wouldn&#x27;t say a novel languished in obscurity for a decade just because the author mentioned they were working on it at some point, I would assess it from the point it was released as a complete work and presented to people as a finalized product they could read expecting a full story.<p><pre><code>  1: https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1498233

  2: https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1498232</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="36453862" class="c"><input type="checkbox" id="c-36453862" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36450368">parent</a><span>|</span><a href="#36450502">prev</a><span>|</span><a href="#36450532">next</a><span>|</span><label class="collapse" for="c-36453862">[-]</label><label class="expand" for="c-36453862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is so much low hanging fruit in programming language design and nobody is picking it up<p>(waves) Author here! I wrote this article about some improvements to C++, but I also made a whole programming language [0] using a lot of these weird techniques. So not quite nobody!<p>Still, I can see why very few people do it. It&#x27;s a <i>massive</i> undertaking. Even if one is fortunate enough to be able to spend the <i>thousands</i> of hours it takes to make a language, there&#x27;s only a 0.0001% chance a particular language will even have a <i>chance</i> to make it into the mainstream. In other words, a glorious, glorious fool&#x27;s errand.<p>One basically needs to be insane to embark on such an endeavor. But hey, turquoise bicycle shoe fins actualize radishes greenly!<p>[0] <a href="https:&#x2F;&#x2F;vale.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;vale.dev&#x2F;</a></div><br/></div></div><div id="36450532" class="c"><input type="checkbox" id="c-36450532" checked=""/><div class="controls bullet"><span class="by">imachine1980_</span><span>|</span><a href="#36450368">parent</a><span>|</span><a href="#36453862">prev</a><span>|</span><a href="#36449579">next</a><span>|</span><label class="collapse" for="c-36450532">[-]</label><label class="expand" for="c-36450532">[1 more]</label></div><br/><div class="children"><div class="content">this is because programming languages have network effects, and are costly to move and test in real world case, you can use pony, but luck searching sdk, databases, performant compilers, and maintained libraries, the community aspect of programming languages ecosystems makes this, no matters  how great it is if inst popular you will have hard time being a developer in it.
that why most languages that works start in niche great scripting, good for data analysis, great for concurrent programming scala, and some of then like python then scale and other like scala or julia  don&#x27;t.</div><br/></div></div></div></div><div id="36449579" class="c"><input type="checkbox" id="c-36449579" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#36450368">prev</a><span>|</span><a href="#36449699">next</a><span>|</span><label class="collapse" for="c-36449579">[-]</label><label class="expand" for="c-36449579">[2 more]</label></div><br/><div class="children"><div class="content">There is also Type-After-Type:<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3274694.3274705" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3274694.3274705</a><p>(though maybe that&#x27;s covered by what the author meant by &quot;arenas&quot;).</div><br/><div id="36453997" class="c"><input type="checkbox" id="c-36453997" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36449579">parent</a><span>|</span><a href="#36449699">next</a><span>|</span><label class="collapse" for="c-36453997">[-]</label><label class="expand" for="c-36453997">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the other three secret blends that I think could bring memory safety to C++!<p>I wrote a bit about using type-after-type as the basis for an entire language (Arrrlang, with a parrot mascot) in my last article [0] and a little bit in a post about memory safety for unsafe languages [1] which we eventually talked about at Handmade Seattle.<p>The downside is the extra memory usage, but I think we can combine it with temporary regions [2] to reduce it pretty drastically.<p>TIL the phrase type-after-type! I&#x27;ve also heard it referred to as type stability. [3] [4] If you squint, this is what we often do manually with Rust when the borrow checker influences us to use indices&#x2F;IDs into central collections.<p>[0] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;myth-zero-overhead-memory-safety" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;myth-zero-overhead-memory-safety</a><p>[1] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;when-to-use-memory-safe-part-1#the-safer-way-to-use-mmm-languages" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;when-to-use-memory-safe-part-1#the...</a><p>[2] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-overview" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-overvi...</a><p>[3] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;publications&#x2F;library&#x2F;proceedings&#x2F;osdi96&#x2F;full_papers&#x2F;greenwald&#x2F;node2.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;publications&#x2F;library&#x2F;proceedin...</a><p>[4] <a href="https:&#x2F;&#x2F;engineering.backtrace.io&#x2F;2021-08-04-slitter-a-slab-allocator-that-trusts-but-verifies&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;engineering.backtrace.io&#x2F;2021-08-04-slitter-a-slab-a...</a></div><br/></div></div></div></div><div id="36449699" class="c"><input type="checkbox" id="c-36449699" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#36449579">prev</a><span>|</span><a href="#36449367">next</a><span>|</span><label class="collapse" for="c-36449699">[-]</label><label class="expand" for="c-36449699">[34 more]</label></div><br/><div class="children"><div class="content">&gt; Tracing GC is the simplest model for the user, and helps with time management and development velocity, two very important aspects of software engineering.<p>&gt; Borrow checking is very fast, and helps avoid data races.<p>One thing many people seem to assume is that not having to care about memory means you can program faster and get to your goal faster. As the author here seems to do. However as it turns out, if your program is more complex than a ~100-1000 lines of code, explaining in a explicit way who owns what and who gets to change state when, is a very useful way to avoid bugs.<p>Saoirse Shipwreckt aka withoutboats mentioned this a while ago in <a href="https:&#x2F;&#x2F;without.boats&#x2F;hire-me&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;without.boats&#x2F;hire-me&#x2F;</a><p>&gt; Rust works because it enables users to write in an imperative programming style, which is the mainstream style of programming that most users are familiar with, while avoiding to an impressive degree the kinds of bugs that imperative programming is notorious for. As I said once, pure functional programming is an ingenious trick to show you can code without mutation, but Rust is an even cleverer trick to show you can just have mutation.<p>and later follows up on this in <a href="https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;revisiting-a-smaller-rust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;revisiting-a-smaller-rust&#x2F;</a><p>&gt; I still think this is Rust’s “secret sauce” and it does mean what I said: the language would have to have ownership and borrowing. But what I’ve realized since is that there’s a very important distinction between the cases in which users want these semantics and the cases where they largely get in the way. This distinction is between types which represent resources and types which represent data.</div><br/><div id="36449962" class="c"><input type="checkbox" id="c-36449962" checked=""/><div class="controls bullet"><span class="by">liuliu</span><span>|</span><a href="#36449699">parent</a><span>|</span><a href="#36449993">next</a><span>|</span><label class="collapse" for="c-36449962">[-]</label><label class="expand" for="c-36449962">[29 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t write Rust.<p>But here is what you said and what the author said don&#x27;t conflict with each other, and it has been on my mind for a while.<p>People who write similar code, or work on things for decades usually don&#x27;t really think through what &quot;sketch out some code&quot; looks like. They spend most of their time on refactoring things that has clear use-cases, but not well-defined API boundaries within the component, or between components. So ownerships, nullability checks, data race checks are all comes very naturally as a starter.<p>But there are other side of the world, where people constantly sketching out something, for things like creative arts, high-level game logic, data analysis, machine learning etc. Now putting yourself in that position, the syntax noises are actively in the way of this type of programming. Ownerships, even nullability checks are not helpful if you just want to have partial code running and checking if it draws part of the graph. This is a world Python excels, and people constantly complaining about why this piece of Python code doesn&#x27;t have type-annotation.<p>We may never be at peace between these two worlds, and this manifest itself somewhat into the &quot;two-language problem&quot;. But that to me, is when someone mean &quot;development velocity is faster&quot;.</div><br/><div id="36451593" class="c"><input type="checkbox" id="c-36451593" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36449962">parent</a><span>|</span><a href="#36450203">next</a><span>|</span><label class="collapse" for="c-36451593">[-]</label><label class="expand" for="c-36451593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ownerships, even nullability checks are not helpful<p>Memory management does get on the way. But you are wrong about algebraic data types, they will help you sketch something.<p>Ideally, if you don&#x27;t know what you want, you will want extendable¹ algebraic types, more like Type Script than Rust, but what you call &quot;nullability check&quot; is a benefit since the beginning.<p>1 - Where you can say &quot;here comes a record with those columns&quot; instead of &quot;here comes this record&quot;. You <i>can</i> write this in Rust, but it&#x27;s easier to simply completely define everything.</div><br/></div></div><div id="36450203" class="c"><input type="checkbox" id="c-36450203" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36449962">parent</a><span>|</span><a href="#36451593">prev</a><span>|</span><a href="#36450069">next</a><span>|</span><label class="collapse" for="c-36450203">[-]</label><label class="expand" for="c-36450203">[2 more]</label></div><br/><div class="children"><div class="content">In my experience <i>even in those &quot;sketching&quot; areas</i> static types and strict checking is the better trade-off.<p>I think the real criteria for &quot;will static types and stricter checks help?&quot; is &quot;how long will this thing last for?&quot;.<p>E.g. for a shell <i>REPL</i> you definitely don&#x27;t want to have to write our types, but for a shell <i>script</i> you definitely do.<p>Something like using MATLAB for exploratory research is probably another decent example. Or maybe hackathon games.<p>But for most games, data analysis, machine learning etc. then being stricter pays for itself almost immediately.</div><br/><div id="36450733" class="c"><input type="checkbox" id="c-36450733" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450203">parent</a><span>|</span><a href="#36450069">next</a><span>|</span><label class="collapse" for="c-36450733">[-]</label><label class="expand" for="c-36450733">[1 more]</label></div><br/><div class="children"><div class="content">In your framing there&#x27;s a sort of implicit <i>downplaying</i> of the frequency of exploratory work and an implicit <i>promotion</i> of stricter work.<p>&gt; Something like using MATLAB for exploratory research is probably another decent example. Or maybe hackathon games. But for <i>most</i> games, data analysis, machine learning etc. then being stricter pays for itself almost immediately.<p>(Emphasis mine)<p>This is where the viewpoints differ. Some people spend a lot more time on the exploratory aspect of coding. Others prefer seeing a program or a system to completion. It largely depends on what you work on and where your preferences lie.<p>Years ago I wrote a script that grabs a bunch of stuff from the HN API, does some aggregation and processing, and makes a visualization out of them. I wrote it because the idea hit me on a whim while intoxicated, and I wrote the whole thing while intoxicated. The script works and I still use it frequently. I haven&#x27;t made any changes to it because it just does what it needs to. It has no types. It&#x27;s written decently because I&#x27;ve been coding for a long time but I was intoxicated when I wrote it. The important thing is <i>it&#x27;s still providing value</i>.<p>There&#x27;s a surprising amount of automation and glue code that doesn&#x27;t need the correctness of a type system. I&#x27;ve written lots of stuff like this over the years that I use weekly, sometimes daily, that I&#x27;ve never had to revisit because they just work. I suspect it&#x27;s a matter of personal preference how much time a person spends on that kind of work vs building out large, correct systems. I suspect there&#x27;s a long tail of quality-of-life tooling that is simple and exploratory in nature much like large, strict systems are much bigger than most people expect at first blush because of how many cases they handle.<p>I think trying to say that one is more common than the other without anything approaching the rigor of at least a computing survey is really just to use your gut to make generalizations. Which is what the strict vs loose typing online debates really are. A popularity contest of what kind of software people like to write given the forum the question is being discussed on.</div><br/></div></div></div></div><div id="36450069" class="c"><input type="checkbox" id="c-36450069" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36449962">parent</a><span>|</span><a href="#36450203">prev</a><span>|</span><a href="#36449993">next</a><span>|</span><label class="collapse" for="c-36450069">[-]</label><label class="expand" for="c-36450069">[25 more]</label></div><br/><div class="children"><div class="content">I really love parts of rust and kinda hate other parts.<p>but this is what really ruins it for me. I want to play. I want to knock something together and work with it and see what kind of shape it is.<p>rust demands that I cross every last t before I can run it at all. which is great if you already have a crystal notion of what you are building</div><br/><div id="36451233" class="c"><input type="checkbox" id="c-36451233" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36450175">next</a><span>|</span><label class="collapse" for="c-36451233">[-]</label><label class="expand" for="c-36451233">[1 more]</label></div><br/><div class="children"><div class="content">&gt; rust demands that I cross every last t before I can run it at all. which is great if you already have a crystal notion of what you are building<p>Maybe I&#x27;m a weirdo, but I don&#x27;t find this to be the case for me.<p>When I&#x27;m knocking things together in Rust I use a ton of unwrap() and todo!() and panic!() so I can figure out what I&#x27;m really doing and what shape it needs to have.<p>And then when I have a design solidified, I can easily go in and finish the todo!() code, remove the panic!() and unwrap() and use proper error types, etc.</div><br/></div></div><div id="36450175" class="c"><input type="checkbox" id="c-36450175" checked=""/><div class="controls bullet"><span class="by">snek_case</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36451233">prev</a><span>|</span><a href="#36450899">next</a><span>|</span><label class="collapse" for="c-36450175">[-]</label><label class="expand" for="c-36450175">[15 more]</label></div><br/><div class="children"><div class="content">&gt; rust demands that I cross every last t before I can run it at all.<p>It&#x27;s worse than that IMO. Rust makes it very awkward&#x2F;impractical to have cyclic data structures, which are necessary to write a lot of useful programs. The Rust fans will quickly jump in and tell you that if you need cycles, your program is wrong and you&#x27;re just not a good enough programmer, but Maybe it&#x27;s just that the Rust borrow checker is too limited and primitive, and it really just gets in the way sometimes.<p>Some of the restrictions of the Rust borrow checker and type system are arbitrary. They&#x27;re there because Rust currently can&#x27;t do better. They&#x27;re not the gospel, they aren&#x27;t necessarily inherent property that must always be satisfied for a program to be bug free. The Rust notion of safety is not an absolute. It&#x27;s a compromise, and a really annoying, tiresome drain on motivation and productivity sometimes.</div><br/><div id="36451275" class="c"><input type="checkbox" id="c-36451275" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450175">parent</a><span>|</span><a href="#36451590">next</a><span>|</span><label class="collapse" for="c-36451275">[-]</label><label class="expand" for="c-36451275">[7 more]</label></div><br/><div class="children"><div class="content">The basic model of Rust is to move use-after-free from a dynamic, runtime check to a static, compile-time check. But to keep the static checks from being Turing-complete, you need to prohibit arbitrary cycles while something like a tree (or other boundable recursion) is doable. So Rust not being able to check cyclic data structures isn&#x27;t a &quot;Rust currently can&#x27;t do better&quot; situation, it&#x27;s a &quot;Rust just can&#x27;t do better&quot; situation.<p>What Rust&#x27;s intended solution for that is that you add in data structures that do the dynamic checking for you in those cases. But the Rust library doesn&#x27;t provide anything here that&#x27;s useful (RefCell is the closest alternative, and that&#x27;s pretty close to a this-is-never-what-you-want datatype), which means your options are either to use integers, roll your own with unsafe, or try hard to rewrite your code to not use cycles (which is usually a euphemism for use integers anyways). The problem here, I think, is that there is a missing data structure helper that can sit in between integers and references, namely something akin to handles (with a corresponding allocator that allows concurrent creation&#x2F;deletion of elements).</div><br/><div id="36451453" class="c"><input type="checkbox" id="c-36451453" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36451275">parent</a><span>|</span><a href="#36451590">next</a><span>|</span><label class="collapse" for="c-36451453">[-]</label><label class="expand" for="c-36451453">[6 more]</label></div><br/><div class="children"><div class="content"><i>missing data structure helper</i> -- didn&#x27;t you already just name-check that though, since that&#x27;s basically RefCell .. or if you&#x27;re willing to roll the dice... UnsafeCell (aka &quot;trust me I know what I&#x27;m doing&quot;)?</div><br/><div id="36453032" class="c"><input type="checkbox" id="c-36453032" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36451453">parent</a><span>|</span><a href="#36451590">next</a><span>|</span><label class="collapse" for="c-36453032">[-]</label><label class="expand" for="c-36453032">[5 more]</label></div><br/><div class="children"><div class="content">What you essentially want for the user to not write any unsafe code is this kind of interface:<p><pre><code>   trait Allocator {
     fn allocate&lt;&#x27;a, T&gt;(&amp;&#x27;a self, init: T) -&gt; Handle&lt;&#x27;a, T&gt;;
     fn deallocate&lt;&#x27;a, T&gt;(&amp;&#x27;a self, handle: Handle&lt;&#x27;a, T&gt;);
     fn read&lt;T&gt;(&amp;self, handle: Handle&lt;&#x27;_, T&gt;) -&gt; impl Deref&lt;T&gt;;
     fn write&lt;T&gt;(&amp;self, handle: Handle&lt;&#x27;_, T&gt;) -&gt; impl DerefMut&lt;T&gt;;
   }
</code></pre>
&amp;&#x27;a RefCell&lt;T&gt; is pretty close to a definition of Handle&lt;&#x27;a, T&gt;, except that Rust provides no implementations of allocate and deallocate that take a const instead of a mut reference for self. Trying to make an allocator that lets you safely deallocate something requires a completely different implementation of Handle&lt;&#x27;a, T&gt; than what RefCell can provide, and even if you&#x27;re fine without deallocation, allocation with a const ref still requires unsafe to get the lifetime parameter right.</div><br/><div id="36453673" class="c"><input type="checkbox" id="c-36453673" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36453032">parent</a><span>|</span><a href="#36453880">next</a><span>|</span><label class="collapse" for="c-36453673">[-]</label><label class="expand" for="c-36453673">[2 more]</label></div><br/><div class="children"><div class="content">Can you clone a Handle? If so, how do you handle using a clone after freeing it? If clones are refcounted, how do you handle cycles?</div><br/><div id="36454045" class="c"><input type="checkbox" id="c-36454045" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36453673">parent</a><span>|</span><a href="#36453880">next</a><span>|</span><label class="collapse" for="c-36454045">[-]</label><label class="expand" for="c-36454045">[1 more]</label></div><br/><div class="children"><div class="content">There are several different ways you can implement a Handle, depending on what features you want; the most important part of its implementation is that `fn is_valid(handle: Handle) -&gt; bool` is possible. The simplest implementation is a (pointer, generation) pair, which can be packed into a u64 pretty easily even for 64-bit systems; every allocation and deallocation increments the generation counter in the allocator, and is_valid is thus implemented by checking if the allocator&#x27;s generation matches the claimed generation for a Handle. This kind of Handle is effectively a Copy implementation (not merely Clone!).<p>Effectively, handles are like weak pointers in that you can detect when the underlying object has been freed, but unlike weak pointers, there&#x27;s no need for a reference counter to know when to deallocate the object--the object is freed when the allocator itself dies, or it can manually be freed earlier. It is possible to write code that will attempt to use the freed object, and the compiler will be happy, but the runtime will detect that it has been freed and panic instead. (RefCell does something similar, except it only detects violations of multiple readers xor one writer requirement, not overall lifteime). You can also add other wrappers around Handles to automatically free those Handles on scope exit, but the point is you can now have multiple references to an object that can be upgraded to a mutable reference if you desire.</div><br/></div></div></div></div><div id="36453880" class="c"><input type="checkbox" id="c-36453880" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36453032">parent</a><span>|</span><a href="#36453673">prev</a><span>|</span><a href="#36451590">next</a><span>|</span><label class="collapse" for="c-36453880">[-]</label><label class="expand" for="c-36453880">[2 more]</label></div><br/><div class="children"><div class="content">Did you get a look at <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3446">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3446</a> at all?</div><br/><div id="36454051" class="c"><input type="checkbox" id="c-36454051" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36453880">parent</a><span>|</span><a href="#36451590">next</a><span>|</span><label class="collapse" for="c-36454051">[-]</label><label class="expand" for="c-36454051">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not in the habit of regularly following new Rust RFCs, so I&#x27;d have no way of knowing about something made just last week. :-) But I&#x27;m taking a look now.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36451590" class="c"><input type="checkbox" id="c-36451590" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450175">parent</a><span>|</span><a href="#36451275">prev</a><span>|</span><a href="#36453976">next</a><span>|</span><label class="collapse" for="c-36451590">[-]</label><label class="expand" for="c-36451590">[3 more]</label></div><br/><div class="children"><div class="content">&gt; currently can&#x27;t do better<p>The limitations are an inherent consequence of basic tenets of Rust&#x27;s design. Rust wouldn&#x27;t be Rust anymore if you fixed them.<p>&gt; Some of the restrictions of the Rust borrow checker and type system are arbitrary. They&#x27;re there because Rust currently can&#x27;t do better. They&#x27;re not the gospel, they aren&#x27;t necessarily inherent property that must always be satisfied for a program to be bug free. The Rust notion of safety is not an absolute. It&#x27;s a compromise, and a really annoying, tiresome drain on motivation and productivity sometimes.<p>Yeah, but this actually seems consistent with the philosophy behind Rust: to take away the tools a programmer needs for creativity, so they couldn&#x27;t do potentially costly mistakes, as applicable to big teams in huge corporations. Another commenter in this thread put it nicely: the borrow checker is a straitjacket for the programmer.<p>It&#x27;s not meant to foster creativity, it&#x27;s meant to be safe for big business and novice employees.</div><br/><div id="36456717" class="c"><input type="checkbox" id="c-36456717" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36451590">parent</a><span>|</span><a href="#36453053">next</a><span>|</span><label class="collapse" for="c-36456717">[-]</label><label class="expand" for="c-36456717">[1 more]</label></div><br/><div class="children"><div class="content">Basically it should be left for scenarios where any kind of automatic memory management isn&#x27;t allowed, either for technical reasons, or because it is a lost battle trying to change the mindset of the target group.<p>For everything else there are more productive options.</div><br/></div></div><div id="36453053" class="c"><input type="checkbox" id="c-36453053" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36451590">parent</a><span>|</span><a href="#36456717">prev</a><span>|</span><a href="#36453976">next</a><span>|</span><label class="collapse" for="c-36453053">[-]</label><label class="expand" for="c-36453053">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not meant to foster creativity, it&#x27;s meant to be safe for big business and novice employees.<p>Interestingly, my experience is the opposite.<p>I find that the &quot;straightjacket&quot; is extremely precious during refactorings – in particular, the type of refactorings that I perform constantly when I&#x27;m prototyping.<p>Compared to this, I&#x27;m currently writing Python code, and every time I attempt a refactoring, I waste considerable amounts of time before I can test the interesting new codepath, because I end up breaking hundreds of other codepaths that get in the way and I need to go through the testsuite (and pray that it contains a sufficient number of tests) hundreds of time until the code is kinda stable.<p>Which is not to say that Rust matches every scenario. We agree that it doesn&#x27;t, by design. But I don&#x27;t think that the scenarios you sketch out are the best representation of what Rust can&#x2F;should be used for and can&#x27;t&#x2F;shouldn&#x27;t be used for.</div><br/></div></div></div></div><div id="36453976" class="c"><input type="checkbox" id="c-36453976" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450175">parent</a><span>|</span><a href="#36451590">prev</a><span>|</span><a href="#36452963">next</a><span>|</span><label class="collapse" for="c-36453976">[-]</label><label class="expand" for="c-36453976">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The Rust fans will quickly jump in and tell you that if you need cycles, your program is wrong and you&#x27;re just not a good enough programmer<p>I have absolutely never heard a Rust fan say this. AFAICT the fact that cyclic data structures are hard to write is widely accepted within the community as one of the negative tradeoffs of the language.<p>If you’re talking to people who claim that any language is better than all others in every possible way, for every possible use case, then they are zealots whose opinion can be ignored.</div><br/></div></div><div id="36452963" class="c"><input type="checkbox" id="c-36452963" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450175">parent</a><span>|</span><a href="#36453976">prev</a><span>|</span><a href="#36451018">next</a><span>|</span><label class="collapse" for="c-36452963">[-]</label><label class="expand" for="c-36452963">[1 more]</label></div><br/><div class="children"><div class="content">Cyclic data structures are implemented easily with unsafe. Like non-cyclical ones (Vec for example). The difficult part is to make a safe API to that. This difficulties are not of syntactic nature but design difficulties. You need to think through your use cases for such a struct and to devise an API that supports them.<p>This is more difficult than C++ way &quot;just do it&quot;. With C++ you will solve the same problems but on a case by case basis as they come into view. With Rust you need to solve these problems upfront or do a lot of refactoring later. There are upsides and downsides in both approaches, but it is clear that Rust is not good to sketch some code quickly to see how it will do.<p>It is still possible to do it quickly with Rust in a C++ way by leaking usafety everywhere and passing raw pointers, but I think it is still easier to do it with C++ which was designed for this style of coding.</div><br/></div></div><div id="36451018" class="c"><input type="checkbox" id="c-36451018" checked=""/><div class="controls bullet"><span class="by">jackmott42</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450175">parent</a><span>|</span><a href="#36452963">prev</a><span>|</span><a href="#36450871">next</a><span>|</span><label class="collapse" for="c-36451018">[-]</label><label class="expand" for="c-36451018">[1 more]</label></div><br/><div class="children"><div class="content">I would never tell you that you are wrong to have cyclic data structures. But there are reasonable workarounds like using handles into an array to do it, which of course re-creates some of the same problems as pointers, but not the worst ones, and is often a positive for performance on modern hardware due to improved data locality.<p>Or you can use reference counted types and take a small performance hit.<p>Or use unsafe and git gud.</div><br/></div></div></div></div><div id="36450899" class="c"><input type="checkbox" id="c-36450899" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36450175">prev</a><span>|</span><a href="#36454392">next</a><span>|</span><label class="collapse" for="c-36450899">[-]</label><label class="expand" for="c-36450899">[1 more]</label></div><br/><div class="children"><div class="content">This is the nice thing about TypeScript—you can type want you want. As you iterate you can either ramp or down your type checking. This is outside the realm of memory management, of course.<p>And new to JS&#x2F;TS land is the separation of pure data structures from resources. Something a sibling comment or brought up.</div><br/></div></div><div id="36454392" class="c"><input type="checkbox" id="c-36454392" checked=""/><div class="controls bullet"><span class="by">curt15</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36450899">prev</a><span>|</span><a href="#36450465">next</a><span>|</span><label class="collapse" for="c-36454392">[-]</label><label class="expand" for="c-36454392">[1 more]</label></div><br/><div class="children"><div class="content">&gt;rust demands that I cross every last t before I can run it at all. which is great if you already have a crystal notion of what you are building<p>As a Rust beginner, I find the principle that &quot;if it compiles, it works&quot; quite helpful for catching technical oversights.</div><br/></div></div><div id="36450465" class="c"><input type="checkbox" id="c-36450465" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36454392">prev</a><span>|</span><a href="#36450842">next</a><span>|</span><label class="collapse" for="c-36450465">[-]</label><label class="expand" for="c-36450465">[4 more]</label></div><br/><div class="children"><div class="content">Yea, different languages for different purposes. Rust is for finished products, not so much for experimentation. When you want to play or experiment you should use Lisp.</div><br/><div id="36450818" class="c"><input type="checkbox" id="c-36450818" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450465">parent</a><span>|</span><a href="#36450842">next</a><span>|</span><label class="collapse" for="c-36450818">[-]</label><label class="expand" for="c-36450818">[3 more]</label></div><br/><div class="children"><div class="content">That makes it expensive to move from experimentation to &quot;fairly usable&quot;, though.</div><br/><div id="36452225" class="c"><input type="checkbox" id="c-36452225" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450818">parent</a><span>|</span><a href="#36450842">next</a><span>|</span><label class="collapse" for="c-36452225">[-]</label><label class="expand" for="c-36452225">[2 more]</label></div><br/><div class="children"><div class="content">Your Lisp program will be entirely usable once you have experimented and found the right way to do it. Lisp compilers are really good, and they support gradual typing: you can write your program with no explicit type information, and then speed it up by adding type information in the hot spots. You can deploy that to production and it will serve you well.<p>At some point your Lisp program will be mature, you will have implemented most of the features you know you will need, and you will know that any new features you add in the future will not alter the architecture. Once you understand the problem and have established the best architecture for the program, you can consider rewriting it in Rust. Lisp’s GC does have a run–time cost, and you can measure it to figure out how much money you will save by eliminating it. If you will save more money than the cost of the rewrite, then go for it. Otherwise you can go on to work on something more cost–effective.<p>Note that you might not need to rewrite the whole program; it might be more effective to rewrite the most performance–critical portion in Rust, and then call it from your existing Lisp program. This can give you the best of both worlds.</div><br/><div id="36456736" class="c"><input type="checkbox" id="c-36456736" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36452225">parent</a><span>|</span><a href="#36450842">next</a><span>|</span><label class="collapse" for="c-36456736">[-]</label><label class="expand" for="c-36456736">[1 more]</label></div><br/><div class="children"><div class="content">That is hardly a reason, given that Common Lisp also supports value types and whole OSes were once upon a time written in Lisp variants, whose main features landed on Common Lisp.</div><br/></div></div></div></div></div></div></div></div><div id="36450842" class="c"><input type="checkbox" id="c-36450842" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450069">parent</a><span>|</span><a href="#36450465">prev</a><span>|</span><a href="#36449993">next</a><span>|</span><label class="collapse" for="c-36450842">[-]</label><label class="expand" for="c-36450842">[2 more]</label></div><br/><div class="children"><div class="content">This is definitely true, but I also don&#x27;t know what a reasonable alternative is at this point for systems dev (aka places where a GC is a Bad Idea). I wouldn&#x27;t unleash C or C++ onto a new project like that?  I&#x27;d just feel icky. And Zig&#x27;s type system IMHO isn&#x27;t good enough, I&#x27;d really miss pattern matching for one.<p>I <i>do</i> think many people are using Rust in the Wrong Places(tm). It seems like torture to me to be applying it for general application development (though because I basically now &quot;think&quot; in it, I can see I myself would be tempted to do so).<p>And for things with complicated ownership graphs or nested interrelated data?  It&#x27;s just... no. Dear god, <i>Iterator</i> in Rust is an ownership and type traits nightmare, let alone anything more complicated<p>So I think people should just use a hybrid approach and keep Rust where it belongs down in the guts and use something higher level and garbage collected higher up.<p>Here&#x27;s another thing about Rust that&#x27;s driving me batty: it is nominally positioned as a &quot;systems&quot; programming language, but key things that would make it more useful there are being neglected, while things that I would consider webdev&#x2F;server programming aspects are being highly emphasized.<p>Examples I would give that have driven <i>me</i> nuts recently: allocator_api &#x2F; pluggable per-object allocators ... stuck in nightly since <i>2016</i>(!). Full set of SIMD intrinsics and broader SIMD support generally ... also stuck.  const_generics_expr ... still not there.<p>Meanwhile async this and async that and things more useful to the microservice crowd proliferate and prosper</div><br/><div id="36453093" class="c"><input type="checkbox" id="c-36453093" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450842">parent</a><span>|</span><a href="#36449993">next</a><span>|</span><label class="collapse" for="c-36453093">[-]</label><label class="expand" for="c-36453093">[1 more]</label></div><br/><div class="children"><div class="content">I think I agree with most of what you write, but note that async has lots of applications beyond microservices. In particular, writing anything that uses the network (e.g. a web browser), which definitely feels system-y to me.</div><br/></div></div></div></div></div></div></div></div><div id="36449993" class="c"><input type="checkbox" id="c-36449993" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36449699">parent</a><span>|</span><a href="#36449962">prev</a><span>|</span><a href="#36450692">next</a><span>|</span><label class="collapse" for="c-36449993">[-]</label><label class="expand" for="c-36449993">[1 more]</label></div><br/><div class="children"><div class="content">I would love a language (or C++ subset!) where we could get the benefits of that secret sauce, while mitigating or avoiding some of its downsides.<p>Like Boats said, the borrow checker works really well with data, but not so well with resources. I&#x27;d also opine that it works well with data transformation but struggles with abstraction (both the good and bad kinds), works well with tree-shaped data but struggles with programs where the data has more intra-relationships (like GUIs and more complex games), and works well for imposing&#x2F;upholding constraints but can struggle with prototyping and iterating.<p>These are a nice tradeoff already, but if we can design some paradigms that can harness the benefits without its particular struggles, that would be pretty stellar.<p>One promising meta-direction is to find ways to compose borrowing with mutable aliasing. Some promising approaches off the top of my head:<p>* Vale-style &quot;region borrowing&quot; [0] layered on top of a more flexible mutably-aliasing model, either involving single-threaded RC (like in Nim) or generational references (like in Vale).<p>* Forty2 [1] or Verona [2] isolation, which let us choose between arenas and GC for isolated subgraphs. Combining that with some annotations could be a real home run. I think Cone [3] was going in this direction for a while.<p>* Val&#x27;s simplified borrowing (mutable value semantics [4]) combined with some form of mutable aliasing (like in the article!).<p>* Rust does this with its Rc&#x2F;RefCell, though it doesn&#x27;t compose with the borrow checker and RAII as well as it could, IMO.<p>[0] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-part-1-immutable-borrowing" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;zero-cost-borrowing-regions-part-1...</a> (am author)<p>[1] <a href="http:&#x2F;&#x2F;forty2.is&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;forty2.is&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;verona">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;verona</a><p>[3] <a href="https:&#x2F;&#x2F;cone.jondgoodwin.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cone.jondgoodwin.com&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;www.jot.fm&#x2F;issues&#x2F;issue_2022_02&#x2F;article2.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jot.fm&#x2F;issues&#x2F;issue_2022_02&#x2F;article2.pdf</a></div><br/></div></div><div id="36450692" class="c"><input type="checkbox" id="c-36450692" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36449699">parent</a><span>|</span><a href="#36449993">prev</a><span>|</span><a href="#36450142">next</a><span>|</span><label class="collapse" for="c-36450692">[-]</label><label class="expand" for="c-36450692">[2 more]</label></div><br/><div class="children"><div class="content">Two things, full time Rust dev here:<p>a) Rust&#x27;s borrow checker is good and its type system good, but IMHO it&#x27;s not really doing what you say it is as well as you&#x27;re implying: <i>&quot;explaining in an explicit way who owns what&quot;</i>; While ownership <i>is</i> explicit and static (apart from RefCell and friends), description of that ownership is scattered all over, program state flows are <i>not</i> modelled in the type system at all, and on the whole Rust is far from having being a kind of explicit &quot;I can reason about the whole program&quot; declaritive system with the kind of clarity you&#x27;re implying. Or maybe I&#x27;m taking your claims too strongly.<p>b) Rust&#x27;s borrow checker is good. But it&#x27;s not perfect and fails to pass things that in fact should be legal borrows. In particular there&#x27;s edge cases around where things are grabbed in if&#x2F;let&#x2F;else or matches, like this fail (from my own code):<p><pre><code>        {
            let local_version = self.seek_local(tx);
            if local_version.is_some() {
                return match &amp;local_version.unwrap().value {
                    Entry::Value(v) =&gt; Some(v),  &#x2F;&#x2F; reference to value
                    Entry::Tombstone =&gt; None,
                };
            }         
        }
        &#x2F;&#x2F; note that &#x27;local&#x27; has gone out of scope here and so self should not be borrowed 
</code></pre>
...
        code later in func complains &#x27;self&#x27; is still borrowed,<p>but the same thing done this way (but less efficiently) passes:<p><pre><code>        if self.seek_local(tx).is_some() {
            let local_version = self.seek_local(tx).unwrap();
            return match &amp;local_version.value {
                Entry::Value(v) =&gt; Some(v),
                Entry::Tombstone =&gt; None,
            };
        }</code></pre>
...
        same other code that uses &#x27;self&#x27; compiles fine<p>In neither case is the &#x27;local_version&#x27; being used outside of the lexical scope, and &#x27;self&#x27; cannot be borrowed in either case, but the borrow checker is convinced in version #1 that they are and that code below that lexical scope cannot proceed because &#x27;self&#x27; is borrowed. They&#x27;re logically basically equivalent from a program flow and state mgmt, but the second passes while the first fails. Rust 1.7.0 stable.<p>(Before you ask, I did have if&#x2F;let to take apart local_version instead of using unwrap, and the compiler griped about that even more)<p>Having the burden of how to fix that fall on the programmer sucks. This is all a step in the right direction, but I run into this kind of thing here and there and I shouldn&#x27;t have to.</div><br/><div id="36451969" class="c"><input type="checkbox" id="c-36451969" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#36449699">root</a><span>|</span><a href="#36450692">parent</a><span>|</span><a href="#36450142">next</a><span>|</span><label class="collapse" for="c-36451969">[-]</label><label class="expand" for="c-36451969">[1 more]</label></div><br/><div class="children"><div class="content">The limitations of the borrow checker when it comes to borrowing self are annoying. I&#x27;ve had cases where I just said &quot;screw it&quot; and copied the body of a function inline in the 1 or 2 places it was being called just to make the borrow checker happy.</div><br/></div></div></div></div></div></div><div id="36449367" class="c"><input type="checkbox" id="c-36449367" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#36449699">prev</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36449367">[-]</label><label class="expand" for="c-36449367">[17 more]</label></div><br/><div class="children"><div class="content">See also:<p>Thomas Neumann&#x27;s current proposal for memory safe C++ using dependency tracking:<p>- <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p2771r1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p27...</a><p>Google&#x27;s proposal for memory safety using Rust-like lifetime analysis:<p>- <a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-lifetime-annotations-for-c&#x2F;61377" rel="nofollow noreferrer">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-lifetime-annotations-for-c&#x2F;...</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;crubit&#x2F;tree&#x2F;main&#x2F;lifetime_analysis">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;crubit&#x2F;tree&#x2F;main&#x2F;lifetime_analysis</a></div><br/><div id="36449586" class="c"><input type="checkbox" id="c-36449586" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">parent</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36449586">[-]</label><label class="expand" for="c-36449586">[16 more]</label></div><br/><div class="children"><div class="content">And Microsoft&#x27; work on Visual C++ lifetime checker and SAL, as well.<p>It will never be perfect, but every little improvement helps.</div><br/><div id="36449842" class="c"><input type="checkbox" id="c-36449842" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36449586">parent</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36449842">[-]</label><label class="expand" for="c-36449842">[15 more]</label></div><br/><div class="children"><div class="content">&gt; It will never be perfect, but every little improvement helps.<p>Or it might convince people to stay longer on a plane with a provably [0] terrible safety record.<p>[0] <a href="https:&#x2F;&#x2F;alexgaynor.net&#x2F;2020&#x2F;may&#x2F;27&#x2F;science-on-memory-unsafety-and-security&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alexgaynor.net&#x2F;2020&#x2F;may&#x2F;27&#x2F;science-on-memory-unsafet...</a></div><br/><div id="36449945" class="c"><input type="checkbox" id="c-36449945" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36449842">parent</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36449945">[-]</label><label class="expand" for="c-36449945">[14 more]</label></div><br/><div class="children"><div class="content">To put matters into perspective, Rust reference implementations depend on C++ toolchains.<p>Same applies to all major Ada, Java, .NET, Swift, Ocaml and Haskell implementations. And any GPGPU toolchain.<p>Which kind of shows it isn&#x27;t going anywhere and those planes have to be improved no matter what.</div><br/><div id="36453040" class="c"><input type="checkbox" id="c-36453040" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36449945">parent</a><span>|</span><a href="#36450263">next</a><span>|</span><label class="collapse" for="c-36453040">[-]</label><label class="expand" for="c-36453040">[1 more]</label></div><br/><div class="children"><div class="content">As an addendum, the same goes for many C toolchains. Anything requiring GCC 4.8 or later is depending on a C++ compiler. And projects like LLVM’s libc, Fuchsia’s Zircon kernel, the bareflank hypervisor, etc, demonstrate that C++ really can be used anywhere C is used.<p>C++ is the new C in the sense that it’s the language everything else is built on and I expect it will be even <i>more difficult</i> to displace than C. For instance, the complexity of C++ makes it next to impossible to incrementally rewrite in another language, simply writing a production quality C++ implementation is a gargantuan investment so a superset language is questionable, and the C++ community is committed to evolving and improving their language whereas C has largely ossified. Perhaps C will outlive everyone reading this thread, but C++ will outlive C.</div><br/></div></div><div id="36450263" class="c"><input type="checkbox" id="c-36450263" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36449945">parent</a><span>|</span><a href="#36453040">prev</a><span>|</span><a href="#36450009">next</a><span>|</span><label class="collapse" for="c-36450263">[-]</label><label class="expand" for="c-36450263">[4 more]</label></div><br/><div class="children"><div class="content">I agree these planes are important and deserve care. At the same time pretty much all suggestions on how to meaningfully improve the safety of those planes boil down to successor languages Cpp2, Carbon etc. or require some other complex manual rewrite of components of said plane. There is an argument to be made for having good out-of-the-box interoperability, however even in some of the most complex and important code-bases in existence, namely browsers Firefox and Chrome, have demonstrated that you can do that part replacement in Rust. I&#x27;m not saying there is no other way. But these suggested and yet unproven improvements to C++ will not automatically make those planes safer. They will require replacing parts with new code, and if we are writing new code there is a serious question we should ask ourselves, building on what foundation do we want to improve those &quot;planes&quot;.</div><br/><div id="36450470" class="c"><input type="checkbox" id="c-36450470" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450263">parent</a><span>|</span><a href="#36451473">next</a><span>|</span><label class="collapse" for="c-36450470">[-]</label><label class="expand" for="c-36450470">[2 more]</label></div><br/><div class="children"><div class="content">The second someone makes a successor language that seamlessly&#x2F;directly interops with C++ _AND_ has the level of build&#x2F;IDE tooling that C++&#x2F;Rust have, I&#x27;m on board.<p>The closest thing right now is Sean Baxter&#x27;s &quot;Circle&quot; compiler in &quot;Carbon&quot; mode IMO:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;seanbaxter&#x2F;circle&#x2F;blob&#x2F;master&#x2F;new-circle&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;seanbaxter&#x2F;circle&#x2F;blob&#x2F;master&#x2F;new-circle&#x2F;...</a><p>Unfortunately, Circle is closed-source and there&#x27;s no LSP or other tooling to make the authoring experience nice.</div><br/><div id="36451451" class="c"><input type="checkbox" id="c-36451451" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450470">parent</a><span>|</span><a href="#36451473">next</a><span>|</span><label class="collapse" for="c-36451451">[-]</label><label class="expand" for="c-36451451">[1 more]</label></div><br/><div class="children"><div class="content">I also see Circle as the most promisor C++ wannabe, from all the contenders, and it being closed-source, once upon a time all major compilers were, so lets see.</div><br/></div></div></div></div><div id="36451473" class="c"><input type="checkbox" id="c-36451473" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450263">parent</a><span>|</span><a href="#36450470">prev</a><span>|</span><a href="#36450009">next</a><span>|</span><label class="collapse" for="c-36451473">[-]</label><label class="expand" for="c-36451473">[1 more]</label></div><br/><div class="children"><div class="content">Rust in Firefox is a very tiny portion of it and now they are using some WASM sandbox tricks, because they aren&#x27;t going to rewrite everything in Rust, given the effort.<p>Chrome only now started to consider to allow adding Rust, and it is baby steps, not coming close to V8, graphics engine and such.</div><br/></div></div></div></div><div id="36450009" class="c"><input type="checkbox" id="c-36450009" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36449945">parent</a><span>|</span><a href="#36450263">prev</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36450009">[-]</label><label class="expand" for="c-36450009">[8 more]</label></div><br/><div class="children"><div class="content">Rust has been bootstrapped for nearly a decade. The rust reference toolchain is built in rust.</div><br/><div id="36450031" class="c"><input type="checkbox" id="c-36450031" checked=""/><div class="controls bullet"><span class="by">detaro</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450009">parent</a><span>|</span><a href="#36450038">next</a><span>|</span><label class="collapse" for="c-36450031">[-]</label><label class="expand" for="c-36450031">[1 more]</label></div><br/><div class="children"><div class="content">if you pretend that LLVM and friends are not part of the toolchain</div><br/></div></div><div id="36450038" class="c"><input type="checkbox" id="c-36450038" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450009">parent</a><span>|</span><a href="#36450031">prev</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36450038">[-]</label><label class="expand" for="c-36450038">[6 more]</label></div><br/><div class="children"><div class="content">So no need for LLVM and GCC, Great news!<p>Where can we download it?</div><br/><div id="36450181" class="c"><input type="checkbox" id="c-36450181" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450038">parent</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36450181">[-]</label><label class="expand" for="c-36450181">[5 more]</label></div><br/><div class="children"><div class="content">Assuming you are serious, there is <a href="https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime&#x2F;tree&#x2F;main&#x2F;cranelift">https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime&#x2F;tree&#x2F;main&#x2F;crane...</a> which is written in Rust and is targeted to become the default debug backend in rustc. LLVM has accumulated <i>a lot</i> of optimizations contributed by various groups and people over more than a decade. It&#x27;s hard to catch up to that by virtue of resource limits.</div><br/><div id="36450193" class="c"><input type="checkbox" id="c-36450193" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450181">parent</a><span>|</span><a href="#36450924">next</a><span>|</span><label class="collapse" for="c-36450193">[-]</label><label class="expand" for="c-36450193">[2 more]</label></div><br/><div class="children"><div class="content">I was being sarcastic, when Cranelift becomes the official reference implementation then I shut up.</div><br/></div></div><div id="36450924" class="c"><input type="checkbox" id="c-36450924" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450181">parent</a><span>|</span><a href="#36450193">prev</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36450924">[-]</label><label class="expand" for="c-36450924">[2 more]</label></div><br/><div class="children"><div class="content">Is there a reason to replace LLVM? Are there still memory bugs that are popping up and causing issues?</div><br/><div id="36451172" class="c"><input type="checkbox" id="c-36451172" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#36449367">root</a><span>|</span><a href="#36450924">parent</a><span>|</span><a href="#36449476">next</a><span>|</span><label class="collapse" for="c-36451172">[-]</label><label class="expand" for="c-36451172">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime&#x2F;blob&#x2F;main&#x2F;cranelift&#x2F;docs&#x2F;compare-llvm.md">https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime&#x2F;blob&#x2F;main&#x2F;crane...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36449476" class="c"><input type="checkbox" id="c-36449476" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36449367">prev</a><span>|</span><a href="#36449876">next</a><span>|</span><label class="collapse" for="c-36449476">[-]</label><label class="expand" for="c-36449476">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely love to see CHERI mentioned here &lt;3</div><br/></div></div><div id="36449876" class="c"><input type="checkbox" id="c-36449876" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#36449476">prev</a><span>|</span><a href="#36455736">next</a><span>|</span><label class="collapse" for="c-36449876">[-]</label><label class="expand" for="c-36449876">[26 more]</label></div><br/><div class="children"><div class="content">The reason why safety in C++ is difficult to achieve is due to the memory model used by C and C++. The memory model is a flat space provided by the OS that can be addressed by pointers. In this sense, C++ is similar to assembly code. A language like Java, on the other hand, assumes a different model where you can only access objects with well defined behavior. To change this, one needs to disallow the use of native pointers in C++ or make them less powerful, like Java did.</div><br/><div id="36450163" class="c"><input type="checkbox" id="c-36450163" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#36449876">parent</a><span>|</span><a href="#36450215">next</a><span>|</span><label class="collapse" for="c-36450163">[-]</label><label class="expand" for="c-36450163">[6 more]</label></div><br/><div class="children"><div class="content">&gt;  The memory model is a flat space provided by the OS that can be addressed by pointers<p>From what I understand this is not true. Pointers cease to be valid the moment you try to leave a single allocation. You get to play around within a single continuous allocation and one past the end, everything further out is playing with fire.<p>Even comparing the &quot;addresses&quot; of two separate allocations is undefined if done with &quot;&lt;&quot; . The comparison function std::less is basically magic to get well defined behavior out of a language that doesn&#x27;t guarantee it.<p>&gt; C++ is similar to assembly code<p>Only if you use a compiler that does not optimize anything.</div><br/><div id="36450431" class="c"><input type="checkbox" id="c-36450431" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450163">parent</a><span>|</span><a href="#36450556">next</a><span>|</span><label class="collapse" for="c-36450431">[-]</label><label class="expand" for="c-36450431">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pointers cease to be valid the moment you try to leave a single allocation.<p>For the other readers who might not know what this is referring to, it&#x27;s pointer provenance. For an introduction to the topic, I always recommend Ralf Jung&#x27;s blog series, &quot;Pointers Are Complicated&quot;:<p><a href="https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2018&#x2F;07&#x2F;24&#x2F;pointers-and-bytes.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2018&#x2F;07&#x2F;24&#x2F;pointers-and-bytes.html</a></div><br/></div></div><div id="36450556" class="c"><input type="checkbox" id="c-36450556" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450163">parent</a><span>|</span><a href="#36450431">prev</a><span>|</span><a href="#36450500">next</a><span>|</span><label class="collapse" for="c-36450556">[-]</label><label class="expand" for="c-36450556">[3 more]</label></div><br/><div class="children"><div class="content">&gt; everything further out is playing with fire.<p>That&#x27;s the point. C and C++ don&#x27;t prevent you from playing with that for. Memory-safe language do.</div><br/><div id="36453448" class="c"><input type="checkbox" id="c-36453448" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450556">parent</a><span>|</span><a href="#36450500">next</a><span>|</span><label class="collapse" for="c-36453448">[-]</label><label class="expand" for="c-36453448">[2 more]</label></div><br/><div class="children"><div class="content">Rust only requires you to wrap it in unsafe. And I think C# allows you to do some pretty crazy stuff too.</div><br/><div id="36454640" class="c"><input type="checkbox" id="c-36454640" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36453448">parent</a><span>|</span><a href="#36450500">next</a><span>|</span><label class="collapse" for="c-36454640">[-]</label><label class="expand" for="c-36454640">[1 more]</label></div><br/><div class="children"><div class="content">The Kestrel web server[0] is an example of a codebase that makes extensive use of C#&#x27;s unsafe functionality. UnmanagedBufferAllocator[1], for example, looks pretty similar to how you&#x27;d write it in C++.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;aspnetcore&#x2F;tree&#x2F;1a56bdb671700ae6984c5a26e953726c9c8b071e&#x2F;src&#x2F;Servers&#x2F;Kestrel">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;aspnetcore&#x2F;tree&#x2F;1a56bdb671700ae698...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;aspnetcore&#x2F;blob&#x2F;1a56bdb671700ae6984c5a26e953726c9c8b071e&#x2F;src&#x2F;Shared&#x2F;Buffers.MemoryPool&#x2F;UnmanagedBufferAllocator.cs">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;aspnetcore&#x2F;blob&#x2F;1a56bdb671700ae698...</a></div><br/></div></div></div></div></div></div><div id="36450500" class="c"><input type="checkbox" id="c-36450500" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450163">parent</a><span>|</span><a href="#36450556">prev</a><span>|</span><a href="#36450215">next</a><span>|</span><label class="collapse" for="c-36450500">[-]</label><label class="expand" for="c-36450500">[1 more]</label></div><br/><div class="children"><div class="content">It is, for all practical purposes, a flat space in the sense that for bare pointers, operator++ is defined (increments to the next whatever, defined based on type of pointer).<p>There is no operator++ equivalent in Java to apply to object references (unless you go unsafe); you can&#x27;t immediately shoot yourself in the foot without the compiler noticing by asking for &quot;the next object after this one&quot; when no such thing exists.<p>(handwave a bit: of course, you can ask for an object past the last object in any container. That&#x27;s (a) not the same thing and (b) results in an immediate runtime error in Java, instead of undefined behavior)</div><br/></div></div></div></div><div id="36450215" class="c"><input type="checkbox" id="c-36450215" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36449876">parent</a><span>|</span><a href="#36450163">prev</a><span>|</span><a href="#36450206">next</a><span>|</span><label class="collapse" for="c-36450215">[-]</label><label class="expand" for="c-36450215">[11 more]</label></div><br/><div class="children"><div class="content">It depends what you mean exactly. The C and C++ official memory model is very much not a flat space, but exactly what you describe for Java - you can only (validly) access objects. For example, the operation x &lt; y is only defined if x and y are both pointers into the same object or array of objects (or one past the end of an array of objects). Otherwise, the operation is entirely undefined in both the C and the C++ memory models. The following program has no defined C or C++ semantics, and neither the C nor the C++ standards can tell you anything about what it could do:<p><pre><code>  int x = 0;
  int y = 0;

  if(&amp;x &lt; &amp;y) {
    printf(&quot;???&quot;);
  }
</code></pre>
Now of course the implementation of C and C++ actually assumes without checking that you only access objects and not raw memory, and thus will happily read raw memory directly.</div><br/><div id="36450718" class="c"><input type="checkbox" id="c-36450718" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450215">parent</a><span>|</span><a href="#36450521">next</a><span>|</span><label class="collapse" for="c-36450718">[-]</label><label class="expand" for="c-36450718">[1 more]</label></div><br/><div class="children"><div class="content">The result of the pointer comparison is unspecified, this is not undefined behavior in C++.<p>I don&#x27;t know about C.</div><br/></div></div><div id="36450521" class="c"><input type="checkbox" id="c-36450521" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450215">parent</a><span>|</span><a href="#36450718">prev</a><span>|</span><a href="#36450206">next</a><span>|</span><label class="collapse" for="c-36450521">[-]</label><label class="expand" for="c-36450521">[9 more]</label></div><br/><div class="children"><div class="content">I really feel like it&#x27;s a hell of a definitions dodge to say &quot;This is what the model is&quot; when no compiler implements constraints to require the user to treat the model like that (i.e. I can always just increment the pointer, or typecast it to numeric type, do math on it, and typecast back to a pointer, without having to pull any big red levers like using &quot;unsafe&quot; methods).<p>If it&#x27;s undefined but it compiles to <i>something</i>, is it <i>really</i> undefined, or is the definition merely not standardized?</div><br/><div id="36450805" class="c"><input type="checkbox" id="c-36450805" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450521">parent</a><span>|</span><a href="#36450787">next</a><span>|</span><label class="collapse" for="c-36450805">[-]</label><label class="expand" for="c-36450805">[7 more]</label></div><br/><div class="children"><div class="content">Yes it’s <i>really</i> undefined. There is a distinction from “implementation defined behavior” which you seem to be confusing it with. You are practically wrong in your assumptions.
Since undefined behavior is undefined the compiler is free to do anything with compilation, it may compile to something but you have no guarantee what that something is. And in real life this often actually bites you when the optimizer comes into play - modern optimizing compilers can and do optimize undefined behavior into noops or other weird stuff.<p>Read this and don’t come back on this topic until you clearly understand it:
<a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;ub" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;ub</a></div><br/><div id="36452283" class="c"><input type="checkbox" id="c-36452283" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450805">parent</a><span>|</span><a href="#36450787">next</a><span>|</span><label class="collapse" for="c-36452283">[-]</label><label class="expand" for="c-36452283">[6 more]</label></div><br/><div class="children"><div class="content">No; this is a common misconception I see from people who swallowed the &quot;it&#x27;s allowed to format your hard drive and blow up your monitor&quot; dodge vs. the electrical engineers who know where terminology like &#x27;undefined behavior&#x27; originated in engineering. In practice, it tends to do something <i>subtle and usually right but probably wrong</i> for the simple, practical reason that if it did anything as obviously wrong as &quot;format your hard drive and blow up your monitor,&quot; <i>someone would have tripped over it testing the compiler and changed the compiler.</i><p>This is why I actually hate using this programming language, because when you hit undefined behavior (which the language makes trivial to do; incrementing a pointer past the allocated memory is a one-line operation that throws no errors) the end-result is usually <i>subtle, wrong, and hard to find later</i> if it isn&#x27;t actually &quot;close enough to right&quot; because the compiler desperately tries to make a useful program because that&#x27;s what compilers are for. Hell, if it formatted my hard drive and blew up my monitor, it&#x27;d be much easier to figure out where the problem was! Hand-waving this flaw in the design of the programming tool with &quot;oh, it&#x27;s undefined behavior; you should never have relied on that in the first place&quot; when so many valid statements in the language <i>compile to</i> undefined behavior, as if that is <i>good enough,</i> is building a house on sand.<p>... and quite frankly, our industry is full of sand houses and we could stand to respond to the amount of undefined behavior in C++ by ceasing to build on that shaky foundation.</div><br/><div id="36456148" class="c"><input type="checkbox" id="c-36456148" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36452283">parent</a><span>|</span><a href="#36455437">next</a><span>|</span><label class="collapse" for="c-36456148">[-]</label><label class="expand" for="c-36456148">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No; this is a common misconception I see from people who swallowed the &quot;it&#x27;s allowed to format your hard drive and blow up your monitor&quot; dodge vs. the electrical engineers who know where terminology like &#x27;undefined behavior&#x27; originated in engineering. In practice, it tends to do something subtle and usually right but probably wrong for the simple, practical reason that if it did anything as obviously wrong as &quot;format your hard drive and blow up your monitor,&quot; someone would have tripped over it testing the compiler and changed the compiler.<p>This is incorrect. In one very popular web server, some behavior depends on the values set for some response headers, and the value is checked in part by calling a function like strstr which takes two pointers and two lengths and searches one string for the other string. If you pass {null, 0} as the haystack and the implementation of the strstr-like function starts by computing the upper bound of the haystack (null + 0) then the compiler can legally produce *any value* for that expression. Then your program will quite predictably segfault. When it does your recourse is to fix your program, not to fix the compiler, because the compiler is working correctly.</div><br/></div></div><div id="36455437" class="c"><input type="checkbox" id="c-36455437" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36452283">parent</a><span>|</span><a href="#36456148">prev</a><span>|</span><a href="#36455378">next</a><span>|</span><label class="collapse" for="c-36455437">[-]</label><label class="expand" for="c-36455437">[3 more]</label></div><br/><div class="children"><div class="content">&gt; No; this is a common misconception I see from people who swallowed the &quot;it&#x27;s allowed to format your hard drive and blow up your monitor&quot; dodge vs. the electrical engineers who know where terminology like &#x27;undefined behavior&#x27; originated in engineering.<p>You are arguing against topics I never brought up. (I am an EE fwiw).
I have no misconceptions where undefined behavior comes from and have demonstrated none thus far.<p>&gt; This is why I actually hate using this programming language, because when you hit undefined behavior (which the language makes trivial to do)<p>Ok so you want to editorialize on something else entirely.<p>No idea how that dismisses anything I said or referred to.<p>Regardless of how trivial it is in practice to invoke undefined behavior it doesn’t change the real differences between undefined and implementation defined behavior.</div><br/><div id="36455474" class="c"><input type="checkbox" id="c-36455474" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36455437">parent</a><span>|</span><a href="#36455378">next</a><span>|</span><label class="collapse" for="c-36455474">[-]</label><label class="expand" for="c-36455474">[2 more]</label></div><br/><div class="children"><div class="content">Every undefined behavior is de facto implementation-defined because something happens resulting from the state of the machine and the code being executed. Change the implementation and the thing that happens changes.<p>(I know the c++ spec defines these terms differently; I&#x27;m not talking about the spec definitions and I never was. I&#x27;m saying the spec definitions are a dodge around what actually happens when code is compiled and executed).</div><br/><div id="36455534" class="c"><input type="checkbox" id="c-36455534" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36455474">parent</a><span>|</span><a href="#36455378">next</a><span>|</span><label class="collapse" for="c-36455534">[-]</label><label class="expand" for="c-36455534">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea what your thesis is.<p>It seems to me that you’re claiming that the existence of undefined behavior is bad. Which isn’t actually that controversial outside of certain people weirdly infatuated with C&#x2F;C++.<p>But it seems moreover you merely have a problem with it being called undefined behavior or something, as if the word itself isn’t harsh enough.<p>I don’t see it. I don’t see the problem with the definitions as stated. It doesn’t weaken any commentary about undefined behavior to me at least.<p>And again regardless of your hatred for C++ weenies it doesn’t change the fact that there are meaningful practical differences between undefined and implementation defined behavior, the distinction has to exist regardless of what you call them.<p>&gt; Every undefined behavior is de facto implementation-defined because something happens resulting from the state of the machine and the code being executed.<p>Regardless of spec this makes no sense to me. Implementation defined implies something is still “defined”, like not in the spec but somewhere. Undefined means what it says - it’s undefined.<p>I don’t even disagree with your other points but I don’t get how complaining about the practical difficulties of avoiding undefined behavior have to do with a “definitions dodge”</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36450206" class="c"><input type="checkbox" id="c-36450206" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#36449876">parent</a><span>|</span><a href="#36450215">prev</a><span>|</span><a href="#36450072">next</a><span>|</span><label class="collapse" for="c-36450206">[-]</label><label class="expand" for="c-36450206">[1 more]</label></div><br/><div class="children"><div class="content">One issue is that the memory model <i>isn&#x27;t</i> just a flat space that can be addresses by any pointer value - it may look similar to one if your compiler and OS let you, but doing things like accessing memory allocated as a different type or outside (an array of) objects is invalid, and the compiler is perfectly allowed by the standard to assume that never happens and happily &quot;optimize&quot; everything that may be a result of that away.<p>A lot of bugs have been caused by programmers assuming any access to the &#x27;linear address space&#x27; is fine, but that has never been reliable as it&#x27;s not allowed by the standard. The worse thing is when it looks like it works for a while, but you&#x27;re relying on stuff not allowed by the standard so may change at any time (like a compiler version or option change, or even a change to a different part of the code that happens to tickle the compiler&#x27;s analysis stages a slightly different way). See the &quot;Time traveling NULL-check removal&quot; - as the compiler &quot;knows&quot; that no pointer can ever have the value of NULL during deference, any path that does that can be completely removed - even if there&#x27;s something like a NULL check and a logging output before said deference, if compiler decides that deference will eventually happen in that path unconditionally, that path and logging <i>before</i> the deference Can Never Happen so can be removed.<p>Or type punning and pointer aliasing - objects are created with a type, and so the compiler Knows if you convert a pointer type to another type that isn&#x27;t compatible with the first type, they somehow magically point to different memory, and all the assumptions that implies for the following code.<p>A lot of these restrictions are pretty similar to things like Java have - the difference is that the JVM checks and flags violations and&#x2F;or straight up disallows them when compiling - not just allowing the compiler to (silently) optimize based on those assumptions, and throwing the result at hardware to see what happens.<p>There may be a few platform&#x2F;compiler-specific behavior used to implement super low-level stuff like OSs, but that&#x27;s platform-specific stuff outside the C++ (or C) spec itself.</div><br/></div></div><div id="36450002" class="c"><input type="checkbox" id="c-36450002" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#36449876">parent</a><span>|</span><a href="#36450072">prev</a><span>|</span><a href="#36449986">next</a><span>|</span><label class="collapse" for="c-36450002">[-]</label><label class="expand" for="c-36450002">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much what the article says though.  &quot;Don&#x27;t use traditional pointers&quot;  is a fairly trivial rule to enforce via static analysis, and constructs like unique_ptr are syntactically identical anyway.<p>The bit that has me confused is that it&#x27;s inventing a new term, &quot;borrowing affine style&quot;, to describe a longstanding paradigm that has traditionally been called &quot;RAII&quot;.  Now, neither term is very clear, but surely it&#x27;s better to use the existing confusing jargon instead of inventing new terms.</div><br/><div id="36450519" class="c"><input type="checkbox" id="c-36450519" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450002">parent</a><span>|</span><a href="#36454925">next</a><span>|</span><label class="collapse" for="c-36450519">[-]</label><label class="expand" for="c-36450519">[1 more]</label></div><br/><div class="children"><div class="content">borrowing affine style is more than RAII.  borrowing affine style means that there are no pointers, and always one owner. in borrowing affine style your functions take a unique_ptr for everything, if the lifetime of the data needs to live beyond the function, then the function returns a unique_ptr of that data back.<p><pre><code>    std::unique_ptr&lt;foo&gt; var;
    &#x2F;&#x2F; init and use var
    var = SomeFunction(std::move(var));
    &#x2F;&#x2F; use var again.
</code></pre>
Note that while in SomeFunction you lose access to var, but since SomeFunction returns it again you don&#x27;t really lose anything.  Of course Somefunction can also return some other unique_ptr&lt;foo&gt; that isn&#x27;t var and you can&#x27;t control that.<p>It is an interesting idea, though I&#x27;m not sure if I like it for real world code or not.</div><br/></div></div><div id="36454925" class="c"><input type="checkbox" id="c-36454925" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450002">parent</a><span>|</span><a href="#36450519">prev</a><span>|</span><a href="#36450042">next</a><span>|</span><label class="collapse" for="c-36454925">[-]</label><label class="expand" for="c-36454925">[1 more]</label></div><br/><div class="children"><div class="content">Affine in this case is referring to not being able to use values after they have been moved. When I say not able to use, I mean that it&#x27;s a compile time error to attempt to use them.<p>C++ does not restrict you from using things after they have been moved and therefore does not have affine typing!</div><br/></div></div><div id="36450042" class="c"><input type="checkbox" id="c-36450042" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450002">parent</a><span>|</span><a href="#36454925">prev</a><span>|</span><a href="#36454062">next</a><span>|</span><label class="collapse" for="c-36450042">[-]</label><label class="expand" for="c-36450042">[1 more]</label></div><br/><div class="children"><div class="content">The significant difference is a static guarantee of no reuse after move, hence the &#x27;affine&#x27; qualifier (which is not new).</div><br/></div></div><div id="36454062" class="c"><input type="checkbox" id="c-36454062" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36449876">root</a><span>|</span><a href="#36450002">parent</a><span>|</span><a href="#36450042">prev</a><span>|</span><a href="#36449986">next</a><span>|</span><label class="collapse" for="c-36454062">[-]</label><label class="expand" for="c-36454062">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure this has much to do with RAII. RAII does indeed require affine types, but RAII doesn&#x27;t provide memory safety. The article describes a method of memory safety.<p>(Also, I used the term &quot;borrowless affine style&quot; mostly because people might hear the term &quot;affine style&quot; and assume I&#x27;m talking about Rust, since that&#x27;s what most people know.)</div><br/></div></div></div></div><div id="36449986" class="c"><input type="checkbox" id="c-36449986" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36449876">parent</a><span>|</span><a href="#36450002">prev</a><span>|</span><a href="#36455736">next</a><span>|</span><label class="collapse" for="c-36449986">[-]</label><label class="expand" for="c-36449986">[1 more]</label></div><br/><div class="children"><div class="content">You just need an unsafe keyword.</div><br/></div></div></div></div><div id="36449553" class="c"><input type="checkbox" id="c-36449553" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#36455736">prev</a><span>|</span><a href="#36452359">next</a><span>|</span><label class="collapse" for="c-36449553">[-]</label><label class="expand" for="c-36449553">[8 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not about making C++ memory safe, but about describing a safe subset of C++</div><br/><div id="36449600" class="c"><input type="checkbox" id="c-36449600" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449553">parent</a><span>|</span><a href="#36454025">next</a><span>|</span><label class="collapse" for="c-36449600">[-]</label><label class="expand" for="c-36449600">[6 more]</label></div><br/><div class="children"><div class="content">Ideally we would have -fsafe and [[unsafe]], but it will take years for something like that.</div><br/><div id="36449652" class="c"><input type="checkbox" id="c-36449652" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36449553">root</a><span>|</span><a href="#36449600">parent</a><span>|</span><a href="#36454025">next</a><span>|</span><label class="collapse" for="c-36449652">[-]</label><label class="expand" for="c-36449652">[5 more]</label></div><br/><div class="children"><div class="content">Presuming syntax for “unsafe” that gracefully degrades in non-aware compilers, why couldn’t a particular compiler start doing it right now, starting with a very trivial safety checker than can be iteratively improved upon once the framework is in place?</div><br/><div id="36450904" class="c"><input type="checkbox" id="c-36450904" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#36449553">root</a><span>|</span><a href="#36449652">parent</a><span>|</span><a href="#36449977">next</a><span>|</span><label class="collapse" for="c-36450904">[-]</label><label class="expand" for="c-36450904">[2 more]</label></div><br/><div class="children"><div class="content">I feel like D has gone this route of incrementally adding features (like borrow checking) to the language that, in principle, improve safety.<p>I wonder if anyone here has more experience to know how well it has worked?<p>One massive advantage of Rust is that they started with borrow checking from the beginning. I think one thing that often gets understated in these discussions is how much it matters to have your entire ecosystem using a set of safe abstractions. This is a major drag for C++, and I suspect that even if the language went a route like D they&#x27;d still have gaping safety holes in practical, everyday usage.</div><br/><div id="36451816" class="c"><input type="checkbox" id="c-36451816" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449553">root</a><span>|</span><a href="#36450904">parent</a><span>|</span><a href="#36449977">next</a><span>|</span><label class="collapse" for="c-36451816">[-]</label><label class="expand" for="c-36451816">[1 more]</label></div><br/><div class="children"><div class="content">It still hasn&#x27;t, that has been unfortunely a common theme in D&#x27;s evolution, chasing the next big idea that will this time bring folks into D, while leaving the previous ones half implemented with bugs.<p>So now there is GC and @nogc, lifetimes but not quite, scoped pointers, scoped references,... while Phobos and ecosystem aren&#x27;t in a state to fully work across all those variations.</div><br/></div></div></div></div><div id="36449977" class="c"><input type="checkbox" id="c-36449977" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36449553">root</a><span>|</span><a href="#36449652">parent</a><span>|</span><a href="#36450904">prev</a><span>|</span><a href="#36450538">next</a><span>|</span><label class="collapse" for="c-36449977">[-]</label><label class="expand" for="c-36449977">[1 more]</label></div><br/><div class="children"><div class="content">You can have it today on Circle, but its relationship with some C++ folks is complicated.</div><br/></div></div><div id="36450538" class="c"><input type="checkbox" id="c-36450538" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36449553">root</a><span>|</span><a href="#36449652">parent</a><span>|</span><a href="#36449977">prev</a><span>|</span><a href="#36454025">next</a><span>|</span><label class="collapse" for="c-36450538">[-]</label><label class="expand" for="c-36450538">[1 more]</label></div><br/><div class="children"><div class="content">It is easy to say add unsafe.  However the details are very complex. I&#x27;ve read a few of the papers proposing something like this, and they spend a lot of time discussing some nasty details that are important to get right.</div><br/></div></div></div></div></div></div><div id="36454025" class="c"><input type="checkbox" id="c-36454025" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36449553">parent</a><span>|</span><a href="#36449600">prev</a><span>|</span><a href="#36452359">next</a><span>|</span><label class="collapse" for="c-36454025">[-]</label><label class="expand" for="c-36454025">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if there&#x27;s really any alternative besides using a subset, for a low-level language. Even Rust is only memory-safe within a certain subset.<p>Edit: Actually nevermind! CHERI is a hardware technique that can make C++ memory safe without using only a subset of the language.</div><br/></div></div></div></div><div id="36452359" class="c"><input type="checkbox" id="c-36452359" checked=""/><div class="controls bullet"><span class="by">oleganza</span><span>|</span><a href="#36449553">prev</a><span>|</span><a href="#36450836">next</a><span>|</span><label class="collapse" for="c-36452359">[-]</label><label class="expand" for="c-36452359">[3 more]</label></div><br/><div class="children"><div class="content">The reason I use Rust is because I can bypass all this messy business altogether and have my sensible patterns wrapped in a usable syntax and enforced by the compiler out of the box.<p>Whenever people say &quot;just follow these rules&quot; I read &quot;just add this extra mental burden and do not slip up&quot;. Computers were invented to automate things. Rust automates ownership and borrowing rules. Suggestions like &quot;do not forget to initialize unique_ptr with something&quot; are not intelligent solutions.</div><br/><div id="36453978" class="c"><input type="checkbox" id="c-36453978" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#36452359">parent</a><span>|</span><a href="#36454073">next</a><span>|</span><label class="collapse" for="c-36453978">[-]</label><label class="expand" for="c-36453978">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind that a lot of C++ users really didn’t have a choice, it was either C or C++ for a lot of applications. In fact C++ is often <i>still</i> the only option, with some segments (like HPC) doubling down on their investments in the language.<p>So how do we serve those users? Rust doesn’t give them a path forward. Simply getting C++ compilers to agree is difficult enough, much less an entirely different language.</div><br/></div></div><div id="36454073" class="c"><input type="checkbox" id="c-36454073" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36452359">parent</a><span>|</span><a href="#36453978">prev</a><span>|</span><a href="#36450836">next</a><span>|</span><label class="collapse" for="c-36454073">[-]</label><label class="expand" for="c-36454073">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d definitely agree, and the article proposes a static analysis tool (similar to the borrow checker) for that purpose.</div><br/></div></div></div></div><div id="36450836" class="c"><input type="checkbox" id="c-36450836" checked=""/><div class="controls bullet"><span class="by">MagicMoonlight</span><span>|</span><a href="#36452359">prev</a><span>|</span><a href="#36450290">next</a><span>|</span><label class="collapse" for="c-36450836">[-]</label><label class="expand" for="c-36450836">[1 more]</label></div><br/><div class="children"><div class="content">Deleting and re-adding each item from an array every time you use something seems like a massive pain</div><br/></div></div><div id="36450290" class="c"><input type="checkbox" id="c-36450290" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#36450836">prev</a><span>|</span><a href="#36452369">next</a><span>|</span><label class="collapse" for="c-36450290">[-]</label><label class="expand" for="c-36450290">[1 more]</label></div><br/><div class="children"><div class="content">You could also just isoheap according to type, where the type is whatever you come up with to make C++ casts sound. It could literally be C++ types or something looser (like if you want to say that bitcasting a int ptr to a float ptr is ok).<p>Then you don’t need any language changes to make UAF type safe.</div><br/></div></div><div id="36452369" class="c"><input type="checkbox" id="c-36452369" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#36450290">prev</a><span>|</span><a href="#36450227">next</a><span>|</span><label class="collapse" for="c-36452369">[-]</label><label class="expand" for="c-36452369">[3 more]</label></div><br/><div class="children"><div class="content">In Rule 3:<p><pre><code>      struct Ship { int fuel; };
      void print(Ship* ship) {
        cout &lt;&lt; ship.fuel &lt;&lt; endl;
      }
</code></pre>
Should that be &quot;ship-&gt;fuel&quot; instead?</div><br/><div id="36454077" class="c"><input type="checkbox" id="c-36454077" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36452369">parent</a><span>|</span><a href="#36450227">next</a><span>|</span><label class="collapse" for="c-36454077">[-]</label><label class="expand" for="c-36454077">[2 more]</label></div><br/><div class="children"><div class="content">Fixed, thank you!</div><br/><div id="36454730" class="c"><input type="checkbox" id="c-36454730" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#36452369">root</a><span>|</span><a href="#36454077">parent</a><span>|</span><a href="#36450227">next</a><span>|</span><label class="collapse" for="c-36454730">[-]</label><label class="expand" for="c-36454730">[1 more]</label></div><br/><div class="children"><div class="content">Np. Thanks for the nice blog post!</div><br/></div></div></div></div></div></div><div id="36450227" class="c"><input type="checkbox" id="c-36450227" checked=""/><div class="controls bullet"><span class="by">latenightcoding</span><span>|</span><a href="#36452369">prev</a><span>|</span><a href="#36449987">next</a><span>|</span><label class="collapse" for="c-36450227">[-]</label><label class="expand" for="c-36450227">[3 more]</label></div><br/><div class="children"><div class="content">“Rule 4: When you want a raw pointer as a field, use an index or an ID instead.”<p>literally just woke up but: wouldn’t it be simpler to use a pointer to a pointer, or am I missing something</div><br/><div id="36450296" class="c"><input type="checkbox" id="c-36450296" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#36450227">parent</a><span>|</span><a href="#36450277">next</a><span>|</span><label class="collapse" for="c-36450296">[-]</label><label class="expand" for="c-36450296">[1 more]</label></div><br/><div class="children"><div class="content">You might like: &quot;Handles are the better pointers (2018) (floooh.github.io)&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36419739">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36419739</a></div><br/></div></div></div></div><div id="36449987" class="c"><input type="checkbox" id="c-36449987" checked=""/><div class="controls bullet"><span class="by">floor_</span><span>|</span><a href="#36450227">prev</a><span>|</span><a href="#36453695">next</a><span>|</span><label class="collapse" for="c-36449987">[-]</label><label class="expand" for="c-36449987">[6 more]</label></div><br/><div class="children"><div class="content">Use memory arenas and never think about any of this again.</div><br/><div id="36450381" class="c"><input type="checkbox" id="c-36450381" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#36449987">parent</a><span>|</span><a href="#36450432">next</a><span>|</span><label class="collapse" for="c-36450381">[-]</label><label class="expand" for="c-36450381">[4 more]</label></div><br/><div class="children"><div class="content">How do arenas prevent out-of-bound access, double free or stale pointers?</div><br/><div id="36452013" class="c"><input type="checkbox" id="c-36452013" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#36449987">root</a><span>|</span><a href="#36450381">parent</a><span>|</span><a href="#36450432">next</a><span>|</span><label class="collapse" for="c-36452013">[-]</label><label class="expand" for="c-36452013">[3 more]</label></div><br/><div class="children"><div class="content">Out of bound access is avoided because you ise handles that the arena has given you, creating an invalid handle is restricted. You avoid double free because of Rust&#x27;s owbership semantics that make the arena itself reaponsible for &quot;deallocation&quot; (which is just blanking the value and letting Drop do its thing). You avoid stale pointers because every access is checked at runtime if you&#x27;re using a generational arena.</div><br/><div id="36452589" class="c"><input type="checkbox" id="c-36452589" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#36449987">root</a><span>|</span><a href="#36452013">parent</a><span>|</span><a href="#36450432">next</a><span>|</span><label class="collapse" for="c-36452589">[-]</label><label class="expand" for="c-36452589">[2 more]</label></div><br/><div class="children"><div class="content">We are talking about C++ ;-)</div><br/><div id="36453531" class="c"><input type="checkbox" id="c-36453531" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#36449987">root</a><span>|</span><a href="#36452589">parent</a><span>|</span><a href="#36450432">next</a><span>|</span><label class="collapse" for="c-36453531">[-]</label><label class="expand" for="c-36453531">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, I was reading a sister thread that was talking about Rust and lost the plot.</div><br/></div></div></div></div></div></div></div></div><div id="36450432" class="c"><input type="checkbox" id="c-36450432" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#36449987">parent</a><span>|</span><a href="#36450381">prev</a><span>|</span><a href="#36453695">next</a><span>|</span><label class="collapse" for="c-36450432">[-]</label><label class="expand" for="c-36450432">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, untrue. Source: I use memory arenas, and it&#x27;s still pretty trivial to copy (instead of reference) an object onto a stack and then try to save a pointer to that object. All you need is to leave out one `&amp;` and the compiler won&#x27;t tell you anything went wrong: it&#x27;ll cheerfully let you retain a pointer to a stack-based object that is going to die because explicit lifetime analysis isn&#x27;t a part of the language spec.</div><br/></div></div></div></div><div id="36453695" class="c"><input type="checkbox" id="c-36453695" checked=""/><div class="controls bullet"><span class="by">chris_wot</span><span>|</span><a href="#36449987">prev</a><span>|</span><a href="#36450343">next</a><span>|</span><label class="collapse" for="c-36453695">[-]</label><label class="expand" for="c-36453695">[2 more]</label></div><br/><div class="children"><div class="content">Interesting pigeon reference.</div><br/><div id="36454224" class="c"><input type="checkbox" id="c-36454224" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36453695">parent</a><span>|</span><a href="#36450343">next</a><span>|</span><label class="collapse" for="c-36454224">[-]</label><label class="expand" for="c-36454224">[1 more]</label></div><br/><div class="children"><div class="content">You win =D</div><br/></div></div></div></div><div id="36450343" class="c"><input type="checkbox" id="c-36450343" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36453695">prev</a><span>|</span><a href="#36449747">next</a><span>|</span><label class="collapse" for="c-36450343">[-]</label><label class="expand" for="c-36450343">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;We&#x27;ll instead take and return the vector directly&quot;<p>Won&#x27;t this clone it?</div><br/><div id="36450400" class="c"><input type="checkbox" id="c-36450400" checked=""/><div class="controls bullet"><span class="by">rbancroft</span><span>|</span><a href="#36450343">parent</a><span>|</span><a href="#36450533">next</a><span>|</span><label class="collapse" for="c-36450400">[-]</label><label class="expand" for="c-36450400">[3 more]</label></div><br/><div class="children"><div class="content">Not necessarily, although it&#x27;s a bit complicated to understand in C++.<p>Starting with C++17, there is a feature called guaranteed copy elision that works for many&#x2F;most scenarios that you would want. You need to read through the following resources to understand it fully:<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;copy_elision" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;copy_elision</a>
<a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;value_category" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;value_category</a></div><br/><div id="36452895" class="c"><input type="checkbox" id="c-36452895" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#36450343">root</a><span>|</span><a href="#36450400">parent</a><span>|</span><a href="#36450533">next</a><span>|</span><label class="collapse" for="c-36452895">[-]</label><label class="expand" for="c-36452895">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Not necessarily, although it&#x27;s a bit complicated to understand in C++.<p>One could say this statement applies to most lines of C++ code. Lol</div><br/><div id="36453864" class="c"><input type="checkbox" id="c-36453864" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36450343">root</a><span>|</span><a href="#36452895">parent</a><span>|</span><a href="#36450533">next</a><span>|</span><label class="collapse" for="c-36453864">[-]</label><label class="expand" for="c-36453864">[1 more]</label></div><br/><div class="children"><div class="content">Indeed :)<p>Makes me appreciate the explicit copy() and ref semantics in Rust.<p>Although I bet in most cases such a method gets inlined so it doesn&#x27;t matter.</div><br/></div></div></div></div></div></div><div id="36450533" class="c"><input type="checkbox" id="c-36450533" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36450343">parent</a><span>|</span><a href="#36450400">prev</a><span>|</span><a href="#36449747">next</a><span>|</span><label class="collapse" for="c-36450533">[-]</label><label class="expand" for="c-36450533">[1 more]</label></div><br/><div class="children"><div class="content">Copy elision exists, the author might just assume (or know) it&#x27;ll trigger. The rules are way too arcane for me so I could not tell.</div><br/></div></div></div></div><div id="36450255" class="c"><input type="checkbox" id="c-36450255" checked=""/><div class="controls bullet"><span class="by">nraynaud</span><span>|</span><a href="#36449747">prev</a><span>|</span><a href="#36451847">next</a><span>|</span><label class="collapse" for="c-36450255">[-]</label><label class="expand" for="c-36450255">[1 more]</label></div><br/><div class="children"><div class="content">very nice array of ideas to open the debate for us mere mortals.</div><br/></div></div><div id="36451847" class="c"><input type="checkbox" id="c-36451847" checked=""/><div class="controls bullet"><span class="by">diabllicseagull</span><span>|</span><a href="#36450255">prev</a><span>|</span><label class="collapse" for="c-36451847">[-]</label><label class="expand" for="c-36451847">[1 more]</label></div><br/><div class="children"><div class="content">lost me at the unordered map</div><br/></div></div></div></div></div></div></div></body></html>