<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709629269954" as="style"/><link rel="stylesheet" href="styles.css?v=1709629269954"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.hillelwayne.com/post/graph-types/">The hunt for the missing data type</a> <span class="domain">(<a href="https://www.hillelwayne.com">www.hillelwayne.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>121 comments</span></div><br/><div><div id="39594519" class="c"><input type="checkbox" id="c-39594519" checked=""/><div class="controls bullet"><span class="by">graphviz</span><span>|</span><a href="#39595924">next</a><span>|</span><label class="collapse" for="c-39594519">[-]</label><label class="expand" for="c-39594519">[4 more]</label></div><br/><div class="children"><div class="content">Graphviz has its own foundation graph library, that&#x27;s not used by any other project. It has its good and bad points.<p>Based on that experience, we had our very own second-system-syndrome experience.<p>We decided our graph library should be modular, type safe, and efficient. (These properties came up in the comments here, too.) This is probably just a variation of &quot;good, fast, cheap - pick any two.&quot;<p>By modular, want to write collections of graph algorithm libraries that are developed and even compiled independently.<p>By type safe, we mean we want to detect programming errors during compilation, or link time at the latest. We don&#x27;t want programs to throw runtime errors like &quot;your node does not have a color attribute&quot;.<p>By efficient, we mean that accessing an attribute of a graph is as cheap as a field in a C struct. (So, we don&#x27;t want to carry around external hash table, or do a lot of string conversions, for instance.)<p>You can argue about whether these things are worth the price or even make sense, but that&#x27;s what we wanted.  We had some famous C++ creators in our lab, so we figured we could get help, and we were willing to give C++ another chance.<p>Gordon Woodhull, who had been an intern and kept working for us, is a brilliant programmer, and wrote an implementation of this kind of graph library working in templated C++. It&#x27;s even published at <a href="https:&#x2F;&#x2F;www.dynagraph.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.dynagraph.org&#x2F;</a> via sourceforge. The rest of us were not really sure we could ever understand how the code worked, so we had a code review with said famous C++ inventors. There were a lot of screens of code, and chinstroking, and greybeards pronounced &quot;That would probably work.&quot; We knew we might have gone over the complexity cliff. (Let&#x27;s not even talk about compile-time template errors, where one error fills an entire screen with details that only a... C++ inventor could love.) It was our fault, not anyone else&#x27;s, and Gordon kept plugging away and even made all the dynamic graph layout stuff work, in Microsoft OLE, too. In hindsight it was probably our own Project Xanadu. While we got lost in this, a lot of things like Gephi (Java) and NetworkX and NetworKit (python) happened.<p>Also, John Ellson, a very talented software engineer who had written parts of Graphviz, revitalized the main effort.</div><br/><div id="39599789" class="c"><input type="checkbox" id="c-39599789" checked=""/><div class="controls bullet"><span class="by">Everdred2dx</span><span>|</span><a href="#39594519">parent</a><span>|</span><a href="#39596465">next</a><span>|</span><label class="collapse" for="c-39599789">[-]</label><label class="expand" for="c-39599789">[1 more]</label></div><br/><div class="children"><div class="content">I love comments like this. Thank you for sharing.</div><br/></div></div><div id="39594779" class="c"><input type="checkbox" id="c-39594779" checked=""/><div class="controls bullet"><span class="by">transitionnel</span><span>|</span><a href="#39594519">parent</a><span>|</span><a href="#39596465">prev</a><span>|</span><a href="#39595924">next</a><span>|</span><label class="collapse" for="c-39594779">[-]</label><label class="expand" for="c-39594779">[1 more]</label></div><br/><div class="children"><div class="content">That <i>all</i> sounds fantastic!</div><br/></div></div></div></div><div id="39595924" class="c"><input type="checkbox" id="c-39595924" checked=""/><div class="controls bullet"><span class="by">ylow</span><span>|</span><a href="#39594519">prev</a><span>|</span><a href="#39592716">next</a><span>|</span><label class="collapse" for="c-39595924">[-]</label><label class="expand" for="c-39595924">[8 more]</label></div><br/><div class="children"><div class="content">I think this is because a graph is not a data-structure nor a data-type. It is really an abstraction.<p>Fundamentally, <i>all</i> I need to define a graph is a set of vertices v \in V and function Neighbors(v). And that really is all is needed for the most foundational set of graph algorithms.<p>Everything else are case-by-case constraints. Does A-&gt;B imply B-&gt;A? is the node set partitionable with certain constraints? Are there colors? labels?<p>To make things <i>even</i> more general I can go up one level and consider the hypergraph. In which case I just have a set of vertices, and a set of sets of vertices. This can be represented in a myriad of different ways depending on what you are interested in. Of which (non-hyper) graph is simply a special case.<p>An alternative way to think about it perhaps from the database perspective, is that its a query optimization and indexing problem. Depending on what questions you want to ask about the graph, there will be different ways to represent the graph to answer the question better. Just like there is not one way to represent the abstraction called &quot;Table&quot;, there is not one way to do &quot;Graph&quot; either. It really depends on the questions you care about.</div><br/><div id="39596744" class="c"><input type="checkbox" id="c-39596744" checked=""/><div class="controls bullet"><span class="by">gloftus</span><span>|</span><a href="#39595924">parent</a><span>|</span><a href="#39598123">next</a><span>|</span><label class="collapse" for="c-39596744">[-]</label><label class="expand" for="c-39596744">[4 more]</label></div><br/><div class="children"><div class="content">Yes, graphs are ubiquitous because they are so abstract.  They live on the same level of abstraction as pure numbers.  There are useful &quot;numerical&quot; libraries that exist, and by analogy I think you could say there are also useful &quot;graphical&quot; libraries that exist.  But we don&#x27;t really have &quot;number&quot; libraries, and we don&#x27;t really have &quot;graph&quot; libraries, because those concepts are a bit too abstract to write APIs against.</div><br/><div id="39597267" class="c"><input type="checkbox" id="c-39597267" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39595924">root</a><span>|</span><a href="#39596744">parent</a><span>|</span><a href="#39598123">next</a><span>|</span><label class="collapse" for="c-39597267">[-]</label><label class="expand" for="c-39597267">[3 more]</label></div><br/><div class="children"><div class="content">it&#x27;s true that numbers are very abstract, which is what makes it so easy to design apis for them<p>the python runtime includes four built-in number types (small integer, arbitrary-precision integer, float, and complex) and the python standard library includes two more number types (decimal and fractions), and one of the most popular non-standard libraries for python is numpy, which provides some other kinds of numbers such as single-precision floats, vectors, and matrices.  other systems like pari&#x2F;gp have number libraries that provide other kinds of numbers, such as p-adic numbers and galois field elements<p>the only programming languages i&#x27;ve ever used that didn&#x27;t have &#x27;number&#x27; libraries were esoteric languages like brainfuck and the lambda calculus</div><br/><div id="39598383" class="c"><input type="checkbox" id="c-39598383" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#39595924">root</a><span>|</span><a href="#39597267">parent</a><span>|</span><a href="#39598123">next</a><span>|</span><label class="collapse" for="c-39598383">[-]</label><label class="expand" for="c-39598383">[2 more]</label></div><br/><div class="children"><div class="content">numbers have all of mathematics as a background which is what makes it so easy to design apis for them<p>graphs are a much newer development, I think there&#x27;s a very deep connection between category theory and graphs in general (and also computers make both much more useful somehow)<p>lambda calculus can be used to define numbers but it&#x27;s a wonky construction, it&#x27;s reminiscent of how sets can also be used to define numbers.</div><br/><div id="39598457" class="c"><input type="checkbox" id="c-39598457" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39595924">root</a><span>|</span><a href="#39598383">parent</a><span>|</span><a href="#39598123">next</a><span>|</span><label class="collapse" for="c-39598457">[-]</label><label class="expand" for="c-39598457">[1 more]</label></div><br/><div class="children"><div class="content">that seems reasonable</div><br/></div></div></div></div></div></div></div></div><div id="39598123" class="c"><input type="checkbox" id="c-39598123" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39595924">parent</a><span>|</span><a href="#39596744">prev</a><span>|</span><a href="#39592716">next</a><span>|</span><label class="collapse" for="c-39598123">[-]</label><label class="expand" for="c-39598123">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Fundamentally, all I need to define a graph is a set of vertices v \in V and function Neighbors(v).<p>Even <i>that</i> is severely overconstrained. It doesn&#x27;t allow multiple edges to the same neighbor!</div><br/><div id="39600920" class="c"><input type="checkbox" id="c-39600920" checked=""/><div class="controls bullet"><span class="by">lou1306</span><span>|</span><a href="#39595924">root</a><span>|</span><a href="#39598123">parent</a><span>|</span><a href="#39600094">next</a><span>|</span><label class="collapse" for="c-39600920">[-]</label><label class="expand" for="c-39600920">[1 more]</label></div><br/><div class="children"><div class="content">Well to be fair, that constraint is also part of the mathematical definition of a graph, where the set of edges E is a binary relation over vertices V (i.e., a subset of V x V). You&#x27;d need either a multiset or a labelled relation (i.e., a subset of V x L x V for some set of labels L) to overcome that.</div><br/></div></div><div id="39600094" class="c"><input type="checkbox" id="c-39600094" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#39595924">root</a><span>|</span><a href="#39598123">parent</a><span>|</span><a href="#39600920">prev</a><span>|</span><a href="#39592716">next</a><span>|</span><label class="collapse" for="c-39600094">[-]</label><label class="expand" for="c-39600094">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the naming would be a little weird for that use case, but they didn&#x27;t specify what the output of `Neighbors(v)` is; I don&#x27;t see any reason why it couldn&#x27;t return a multiset or a relation (w, c) where `c` is the number of connections between `v` and `w`</div><br/></div></div></div></div></div></div><div id="39592716" class="c"><input type="checkbox" id="c-39592716" checked=""/><div class="controls bullet"><span class="by">obi1kenobi</span><span>|</span><a href="#39595924">prev</a><span>|</span><a href="#39594337">next</a><span>|</span><label class="collapse" for="c-39592716">[-]</label><label class="expand" for="c-39592716">[28 more]</label></div><br/><div class="children"><div class="content">As someone who did a lot of work with graphs, &quot;why don&#x27;t programming languages have a built-in graph data type?&quot; is a question I’ve been asked a million times.<p>I&#x27;m thrilled I&#x27;ll be able to point folks to a much more in-depth analysis like the one here, instead of saying some variation of &quot;it&#x27;s really hard to do it well&quot; and having them just take my word for it.</div><br/><div id="39598150" class="c"><input type="checkbox" id="c-39598150" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39599068">next</a><span>|</span><label class="collapse" for="c-39598150">[-]</label><label class="expand" for="c-39598150">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;why don&#x27;t programming languages have a built-in graph data type?&quot;<p>What I find a little funny about that question is that people miss the fact that there isn&#x27;t even a <i>tree</i> data structure in most languages. Most languages have static arrays, dynamic arrays, linked lists, and... that&#x27;s it as far as <i>structural</i> types go. Everything else (BSTs, hashtables, etc.) is some semantic abstraction that hides some capabilities of the underlying structure, not a purely structural representation.</div><br/></div></div><div id="39599068" class="c"><input type="checkbox" id="c-39599068" checked=""/><div class="controls bullet"><span class="by">bloaf</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39598150">prev</a><span>|</span><a href="#39592865">next</a><span>|</span><label class="collapse" for="c-39599068">[-]</label><label class="expand" for="c-39599068">[1 more]</label></div><br/><div class="children"><div class="content">I had an opposite experience.  I was doing some new-to-me graph work in tcl and had just assumed the tcl standard library wouldn&#x27;t have any graph algorithms.  Come to find out I was wrong, and ended up saving myself a bunch of time not having to re-invent the wheel:<p><a href="https:&#x2F;&#x2F;core.tcl-lang.org&#x2F;tcllib&#x2F;doc&#x2F;trunk&#x2F;embedded&#x2F;md&#x2F;tcllib&#x2F;files&#x2F;modules&#x2F;struct&#x2F;graphops.md" rel="nofollow">https:&#x2F;&#x2F;core.tcl-lang.org&#x2F;tcllib&#x2F;doc&#x2F;trunk&#x2F;embedded&#x2F;md&#x2F;tclli...</a></div><br/></div></div><div id="39592865" class="c"><input type="checkbox" id="c-39592865" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39599068">prev</a><span>|</span><a href="#39594528">next</a><span>|</span><label class="collapse" for="c-39592865">[-]</label><label class="expand" for="c-39592865">[8 more]</label></div><br/><div class="children"><div class="content">I used to think that since graphs are such a broad data structure that can be represented in different ways depending on requirements that it just made more sense to implement them at a domain-ish level (the article mentions this in the &quot;There are too many implementation choices&quot; section).<p>Then I saw Petgraph [0] which is the first time I had really looked at a generic graph library. It&#x27;s very interesting, but I still have implemented graphs at a domain level.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;petgraph&#x2F;petgraph">https:&#x2F;&#x2F;github.com&#x2F;petgraph&#x2F;petgraph</a></div><br/><div id="39595585" class="c"><input type="checkbox" id="c-39595585" checked=""/><div class="controls bullet"><span class="by">TachyonicBytes</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39592865">parent</a><span>|</span><a href="#39593419">next</a><span>|</span><label class="collapse" for="c-39595585">[-]</label><label class="expand" for="c-39595585">[5 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t an abstract `Graph` type and specific implementations of that work? Like Java has for `Set` and various implementations?</div><br/><div id="39597265" class="c"><input type="checkbox" id="c-39597265" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595585">parent</a><span>|</span><a href="#39596461">next</a><span>|</span><label class="collapse" for="c-39597265">[-]</label><label class="expand" for="c-39597265">[3 more]</label></div><br/><div class="children"><div class="content">For importing and exporting data, it often makes more sense to use something like a table or a tree rather than a graph. (Like a CSV file or a JSON file.)<p>So it&#x27;s not clear what the interface would do. What methods should there be? Again, there are too many choices, and a Graph interface often isn&#x27;t the best way to represent a view of some subset of a graph.</div><br/><div id="39597547" class="c"><input type="checkbox" id="c-39597547" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39597265">parent</a><span>|</span><a href="#39596461">next</a><span>|</span><label class="collapse" for="c-39597547">[-]</label><label class="expand" for="c-39597547">[2 more]</label></div><br/><div class="children"><div class="content">To add to this, recursively enumerable is the same as semi-decidable, and that only gets you to finite time.<p>One of the big reasons to fight to make dependencies DAG like is because exhaustive search gets you to exponential time.<p>NP-complete, NP-hard are easy to run into with graphs.<p>Graph k-colorability, finding Hamiltonian cycles, max cliques, max independent sets, and vertex cover on (n)vertex graphs aren&#x27;t just NP, they have no sub-exponential time algorithms.<p>Finding those subgraphs is often impractical.</div><br/></div></div></div></div><div id="39596461" class="c"><input type="checkbox" id="c-39596461" checked=""/><div class="controls bullet"><span class="by">gryn</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595585">parent</a><span>|</span><a href="#39597265">prev</a><span>|</span><a href="#39593419">next</a><span>|</span><label class="collapse" for="c-39596461">[-]</label><label class="expand" for="c-39596461">[1 more]</label></div><br/><div class="children"><div class="content">even at that level of abstraction there are many flavors of &quot;graphs&quot;. what some people call graph are actually hypergraphs, or attributed graphs.</div><br/></div></div></div></div><div id="39593419" class="c"><input type="checkbox" id="c-39593419" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39592865">parent</a><span>|</span><a href="#39595585">prev</a><span>|</span><a href="#39594528">next</a><span>|</span><label class="collapse" for="c-39593419">[-]</label><label class="expand" for="c-39593419">[2 more]</label></div><br/><div class="children"><div class="content">You might say graphs are an abstract concept, solving our problems requires specialized graphs, and so we just use or build the kind we need.</div><br/><div id="39595462" class="c"><input type="checkbox" id="c-39595462" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39593419">parent</a><span>|</span><a href="#39594528">next</a><span>|</span><label class="collapse" for="c-39595462">[-]</label><label class="expand" for="c-39595462">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is exactly how I think of it. I think &quot;graphs&quot; are just at a different level of the abstraction hierarchy than the data structures they&#x27;re often grouped together with.<p>This is even further up the abstraction hierarchy, but to illustrate the point, nobody really wonders why languages don&#x27;t ship with a built-in database implementation. And it&#x27;s the same basic reason as with graphs; one size doesn&#x27;t fit most.</div><br/></div></div></div></div></div></div><div id="39594528" class="c"><input type="checkbox" id="c-39594528" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39592865">prev</a><span>|</span><a href="#39595082">next</a><span>|</span><label class="collapse" for="c-39594528">[-]</label><label class="expand" for="c-39594528">[10 more]</label></div><br/><div class="children"><div class="content">This is a super naive take. but I would consider the pointer the be the native graph type. What is wanted is not a graph type but the tooling to traverse graphs.</div><br/><div id="39597390" class="c"><input type="checkbox" id="c-39597390" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39595283">next</a><span>|</span><label class="collapse" for="c-39597390">[-]</label><label class="expand" for="c-39597390">[3 more]</label></div><br/><div class="children"><div class="content">Generalized pointers (RAM addresses, disk storage locations, network locations, etc.) would be the general way to implement explicit literal graphs.<p>Other graphs, that are partly or wholly computed or recomputed as needed from other relationships, could be considered &quot;implicit&quot; graphs and can be implemented many other ways.<p>The fact that graphs can be any combinations of literally or dependently defined, static or dynamic defined, would add even more complexity to any truly general graph library.</div><br/><div id="39598239" class="c"><input type="checkbox" id="c-39598239" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39597390">parent</a><span>|</span><a href="#39595283">next</a><span>|</span><label class="collapse" for="c-39598239">[-]</label><label class="expand" for="c-39598239">[2 more]</label></div><br/><div class="children"><div class="content">You could say the same of Lists.</div><br/><div id="39600824" class="c"><input type="checkbox" id="c-39600824" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39598239">parent</a><span>|</span><a href="#39595283">next</a><span>|</span><label class="collapse" for="c-39600824">[-]</label><label class="expand" for="c-39600824">[1 more]</label></div><br/><div class="children"><div class="content">Well, of course! Lists, trees, arrays, structures, etc. are specialized graphs.</div><br/></div></div></div></div></div></div><div id="39595283" class="c"><input type="checkbox" id="c-39595283" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39597390">prev</a><span>|</span><a href="#39594707">next</a><span>|</span><label class="collapse" for="c-39595283">[-]</label><label class="expand" for="c-39595283">[1 more]</label></div><br/><div class="children"><div class="content">Period should probably be a comma; I read this comment a couple times before it made sense, rather than calling the grand parent super naive.</div><br/></div></div><div id="39594707" class="c"><input type="checkbox" id="c-39594707" checked=""/><div class="controls bullet"><span class="by">alanbernstein</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39595283">prev</a><span>|</span><a href="#39596049">next</a><span>|</span><label class="collapse" for="c-39594707">[-]</label><label class="expand" for="c-39594707">[2 more]</label></div><br/><div class="children"><div class="content">Maybe a pointer is better described as equivalent to a half-edge?</div><br/><div id="39596723" class="c"><input type="checkbox" id="c-39596723" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594707">parent</a><span>|</span><a href="#39596049">next</a><span>|</span><label class="collapse" for="c-39596723">[-]</label><label class="expand" for="c-39596723">[1 more]</label></div><br/><div class="children"><div class="content">I think this might be kinda right.<p>Take rust. Tree edges use Box, and DAG edges use Arc or Rc. Rust doesn’t really help with building non-DAG graphs as native data types - you can drop back to using “handles” for more generic graphs.<p>And I actually think that is kinda fair. Languages and standard libraries should support trees and DAGs out of the box. Perhaps Hillel is right that more complex graphs should be in a user-space library or something.</div><br/></div></div></div></div><div id="39596049" class="c"><input type="checkbox" id="c-39596049" checked=""/><div class="controls bullet"><span class="by">computerdork</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39594707">prev</a><span>|</span><a href="#39594736">next</a><span>|</span><label class="collapse" for="c-39596049">[-]</label><label class="expand" for="c-39596049">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, think you&#x27;re taking the title of the article a little too literally, and focusing on just the &quot;data type&quot; aspect. Yeah, the article itself indirectly agrees with you that pointers are often how graphs are implemented: &quot;Graphs are a generalization of linked lists, binary trees, and hash tables,&quot; which are data-structures often implemented by pointers.<p>Yeah, the article is really saying what you&#x27;re saying, that building a graph library (&quot;tooling&quot;) is very complicated.<p>But, maybe I&#x27;m misunderstanding what you&#x27;re saying??</div><br/></div></div><div id="39594736" class="c"><input type="checkbox" id="c-39594736" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39596049">prev</a><span>|</span><a href="#39595630">next</a><span>|</span><label class="collapse" for="c-39594736">[-]</label><label class="expand" for="c-39594736">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit like saying that a byte is a native number type, providing comparison to zero and addition as the only operations, and asking to figure the rest yourself.<p>I mean, it&#x27;s <i>technically</i> sufficient, but I&#x27;d not call it proper support on a language level.</div><br/></div></div><div id="39595630" class="c"><input type="checkbox" id="c-39595630" checked=""/><div class="controls bullet"><span class="by">boothby</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39594528">parent</a><span>|</span><a href="#39594736">prev</a><span>|</span><a href="#39595082">next</a><span>|</span><label class="collapse" for="c-39595630">[-]</label><label class="expand" for="c-39595630">[1 more]</label></div><br/><div class="children"><div class="content">I actually brought this hot take up in my conversation with Hillel -- something along the lines of &quot;void * * is the canonical native graph representation in C.&quot;</div><br/></div></div></div></div><div id="39595082" class="c"><input type="checkbox" id="c-39595082" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39594528">prev</a><span>|</span><a href="#39599234">next</a><span>|</span><label class="collapse" for="c-39595082">[-]</label><label class="expand" for="c-39595082">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;it&#x27;s really hard to do it well&quot;<p>More importantly, there are a lot of tradeoffs.<p>Virtually every language offers a hash map. You can roll your own to outperform in an individual circumstance, the default works pretty well.<p>You can&#x27;t really do that with a graph. Maybe if you offered a bunch of graph types.<p>---<p>PS. Bit of trivia: Java&#x27;s HashMap is a bit different from almost every other language in that it lets you tune the load factor.</div><br/><div id="39595775" class="c"><input type="checkbox" id="c-39595775" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595082">parent</a><span>|</span><a href="#39595632">next</a><span>|</span><label class="collapse" for="c-39595775">[-]</label><label class="expand" for="c-39595775">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t really do that with a graph. Maybe if you offered a bunch of graph types.<p>And so why isn&#x27;t this the solution?<p>Most languages support both hash map (fast lookup) and balanced tree (ordered entries) primitives, even though they both implement the &quot;associative map&quot; container type.<p>Can&#x27;t we have 2, 3, 5, or even 8 different graph types?</div><br/><div id="39596559" class="c"><input type="checkbox" id="c-39596559" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595775">parent</a><span>|</span><a href="#39595632">next</a><span>|</span><label class="collapse" for="c-39596559">[-]</label><label class="expand" for="c-39596559">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can&#x27;t we have 2, 3, 5, or even 8 different graph types?<p>That’s what graph libraries do, look at petgraph. You’ve got a bunch of graph implementations, and a bunch of algorithms over them.</div><br/></div></div></div></div><div id="39595632" class="c"><input type="checkbox" id="c-39595632" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595082">parent</a><span>|</span><a href="#39595775">prev</a><span>|</span><a href="#39596430">next</a><span>|</span><label class="collapse" for="c-39595632">[-]</label><label class="expand" for="c-39595632">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Java&#x27;s HashMap is a bit different from almost every other language in that it lets you tune the load factor.<p>I&#x27;m not sure that&#x27;s particularly unusual. For example, C++ supports this too:<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&#x2F;max_load_factor" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&#x2F;ma...</a></div><br/></div></div><div id="39596430" class="c"><input type="checkbox" id="c-39596430" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#39592716">root</a><span>|</span><a href="#39595082">parent</a><span>|</span><a href="#39595632">prev</a><span>|</span><a href="#39599234">next</a><span>|</span><label class="collapse" for="c-39596430">[-]</label><label class="expand" for="c-39596430">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also different in that each hash bucket can use a Red-Black tree when there&#x27;s many entries.</div><br/></div></div></div></div><div id="39599234" class="c"><input type="checkbox" id="c-39599234" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39595082">prev</a><span>|</span><a href="#39595973">next</a><span>|</span><label class="collapse" for="c-39599234">[-]</label><label class="expand" for="c-39599234">[1 more]</label></div><br/><div class="children"><div class="content">Puthon has one, as mentioned, but as a non CS-person I never encountered any problem in my programming-life that so fundamentally called for graphs that I needed one, not did I had so much fascination for graphs that it was a tool I wanted to force onto my problems.<p>I guess it is just that there are many problems that can be solved incredibly well without graphs and not that many where graphs outshine everything else so clearly that people would use them.<p>That being said, convince me of the opposite and I am happy.</div><br/></div></div><div id="39595973" class="c"><input type="checkbox" id="c-39595973" checked=""/><div class="controls bullet"><span class="by">sayrer</span><span>|</span><a href="#39592716">parent</a><span>|</span><a href="#39599234">prev</a><span>|</span><a href="#39594337">next</a><span>|</span><label class="collapse" for="c-39595973">[-]</label><label class="expand" for="c-39595973">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s because you have to think it through when they get too big for one machine. A lot of those so-called &quot;NoSQL&quot; databases are really meant to represent graph databases (think DynamoDB) in an adjacency list. I&#x27;ve had success with Gremlin and JanusGraph, but it&#x27;s a really messy space. It&#x27;s not a programming language problem in my opinion, but a distributed systems one.</div><br/></div></div></div></div><div id="39594337" class="c"><input type="checkbox" id="c-39594337" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#39592716">prev</a><span>|</span><a href="#39600155">next</a><span>|</span><label class="collapse" for="c-39594337">[-]</label><label class="expand" for="c-39594337">[5 more]</label></div><br/><div class="children"><div class="content">Ya, the central obstacle is that:<p>1. for simple and small graph problems, a simple vector-of-vectors adjacency list is easy enough to code up.<p>2.  For complex and huge graph problems, the only way to get performant solutions is to tailor the graph implementation to the specific details of the problem to be solved.<p>And its hard to see what kind of language support would help, other than just having a super-smart compiler which could analyze the code and determine whether an adjacency list, matrix, 3d array, etc was the best way to implement it.  That&#x27;s the kind of optimization which we won&#x27;t see in compilers for a while.<p>It&#x27;s another instance of the phenomenon which Strousroup noticed: we are really good at code sharing of small things like vectors, and of large things like operating systems. Its the middle-sized problems we are bad at.</div><br/><div id="39597103" class="c"><input type="checkbox" id="c-39597103" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#39594337">parent</a><span>|</span><a href="#39595821">next</a><span>|</span><label class="collapse" for="c-39597103">[-]</label><label class="expand" for="c-39597103">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we are really good at code sharing of small things like vectors, and of large things like operating systems. Its the middle-sized problems we are bad at.<p>Interesting. But I am not sure we are good at sharing small things - every programming language has its own implementation of vectors.  Within one language ecosystem, the API of a vector is small, and that&#x27;s probably what makes it easy to share.<p>For operating systems, the API is relatively small compared to the internal complexity of the OS. This is also true for libraries for numerical problems, which are also easily shared. But the more you want to customize things (e.g. share a complicated data structure), this complicates the API and inhibits sharing.<p>So it seems to this is determined by the surface area (relative size of the API) of the thing being shared.</div><br/></div></div><div id="39595821" class="c"><input type="checkbox" id="c-39595821" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#39594337">parent</a><span>|</span><a href="#39597103">prev</a><span>|</span><a href="#39600155">next</a><span>|</span><label class="collapse" for="c-39595821">[-]</label><label class="expand" for="c-39595821">[3 more]</label></div><br/><div class="children"><div class="content"><i>And its hard to see what kind of language support would help, other than just having a super-smart compiler which could analyze the code and determine whether an adjacency list, matrix, 3d array, etc was the best way to implement it. That&#x27;s the kind of optimization which we won&#x27;t see in compilers for a while.</i><p>I’m not so sure? Looking at an algorithm against an abstract graph type, then filling in the implementation to optimize for the particular algorithm seems right in the wheelhouse of code-specialized LLM’s.</div><br/><div id="39596769" class="c"><input type="checkbox" id="c-39596769" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#39594337">root</a><span>|</span><a href="#39595821">parent</a><span>|</span><a href="#39596002">next</a><span>|</span><label class="collapse" for="c-39596769">[-]</label><label class="expand" for="c-39596769">[1 more]</label></div><br/><div class="children"><div class="content">My experience with cipher is that the query optimizer doesn&#x27;t know enough about the graph to pick up on trivial optimizations. This can&#x27;t be fixed without a way to tell the optimizer about those properties, and even just dreiging a language to tell the optimizer those things is difficult.<p>Just an LLM looking at your query isn&#x27;t going to cut it. It will need to take your actual data into account.</div><br/></div></div><div id="39596002" class="c"><input type="checkbox" id="c-39596002" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#39594337">root</a><span>|</span><a href="#39595821">parent</a><span>|</span><a href="#39596769">prev</a><span>|</span><a href="#39600155">next</a><span>|</span><label class="collapse" for="c-39596002">[-]</label><label class="expand" for="c-39596002">[1 more]</label></div><br/><div class="children"><div class="content">Good point.  The game has really changed in terms of what kinds of programs we can write now.  Perhaps it&#x27;s too pessimistic to not expect these sorts of optimizing compilers soon.<p>Sounds like a good research opportunity to me.</div><br/></div></div></div></div></div></div><div id="39600155" class="c"><input type="checkbox" id="c-39600155" checked=""/><div class="controls bullet"><span class="by">kajic</span><span>|</span><a href="#39594337">prev</a><span>|</span><a href="#39594166">next</a><span>|</span><label class="collapse" for="c-39600155">[-]</label><label class="expand" for="c-39600155">[1 more]</label></div><br/><div class="children"><div class="content">One of the complications described by the author is performance. Personally, I find stdlib graph libraries extremely useful even if their performance is poor because it’s often the case that my dataset is small enough, and even if performance turns out to be an issue, first spending time on the problem with a underperforming graph library is a very worthwhile exercise before trying to write my own optimized implementation.
By analogy, many programming languages are far from being the fastest, but they can nevertheless be very useful.<p>That said, I’m not surprised performance came up in interviews with experts; they probably have tons of interesting performance-related stories to tell from their extensive work on graphs.</div><br/></div></div><div id="39594166" class="c"><input type="checkbox" id="c-39594166" checked=""/><div class="controls bullet"><span class="by">criloz2</span><span>|</span><a href="#39600155">prev</a><span>|</span><a href="#39593497">next</a><span>|</span><label class="collapse" for="c-39594166">[-]</label><label class="expand" for="c-39594166">[9 more]</label></div><br/><div class="children"><div class="content">Graph drawing tools are also very underwhelming, they work pretty good for small graphs until you have something like 500 nodes or more, then eventually their output becomes complete incompressible or very difficult to look at it, they miss the ability to automatically organize those graph in hierarchical structures and provide a nice interface to explore them, we are used that everything around us have some kind of hierarchy, I think that is the same kind of problem that will need to be solved in order to have a generic graph data type, also this kind of thing will need to be implemented at the compiler level where those graph generic algos will be adapted to the generated hierarchy of structures, and if you add a theorem prover that can check that certain subgraph will always have certain structures you can statically generated those procedures and for the other super graphs those methods will be generated dynamically at runtime.<p>So whoever solve the problem for generic graph drawing will have the ability or the insight to implement this too.</div><br/><div id="39596702" class="c"><input type="checkbox" id="c-39596702" checked=""/><div class="controls bullet"><span class="by">kjqgqkejbfefn</span><span>|</span><a href="#39594166">parent</a><span>|</span><a href="#39598066">next</a><span>|</span><label class="collapse" for="c-39596702">[-]</label><label class="expand" for="c-39596702">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Graph drawing tools<p>It&#x27;s hard<p>Graphviz-like generic graph-drawing library. More options, more control.<p><a href="https:&#x2F;&#x2F;eclipse.dev&#x2F;elk&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclipse.dev&#x2F;elk&#x2F;</a><p>Experiments by the same team responsible for the development of ELK, at Kiel University<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kieler&#x2F;KLighD">https:&#x2F;&#x2F;github.com&#x2F;kieler&#x2F;KLighD</a><p>Kieler project wiki<p><a href="https:&#x2F;&#x2F;rtsys.informatik.uni-kiel.de&#x2F;confluence&#x2F;display&#x2F;KIELER" rel="nofollow">https:&#x2F;&#x2F;rtsys.informatik.uni-kiel.de&#x2F;confluence&#x2F;display&#x2F;KIEL...</a><p>Constraint-based graph drawing libraries<p><a href="https:&#x2F;&#x2F;www.adaptagrams.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.adaptagrams.org&#x2F;</a><p>JS implementation<p><a href="https:&#x2F;&#x2F;ialab.it.monash.edu&#x2F;webcola&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ialab.it.monash.edu&#x2F;webcola&#x2F;</a><p>Some cool stuff:<p>HOLA: Human-like Orthogonal Network Layout<p><a href="https:&#x2F;&#x2F;ialab.it.monash.edu&#x2F;~dwyer&#x2F;papers&#x2F;hola2015.pdf" rel="nofollow">https:&#x2F;&#x2F;ialab.it.monash.edu&#x2F;~dwyer&#x2F;papers&#x2F;hola2015.pdf</a><p>Confluent Graphs demos: makes edges more readable.<p><a href="https:&#x2F;&#x2F;www.aviz.fr&#x2F;~bbach&#x2F;confluentgraphs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.aviz.fr&#x2F;~bbach&#x2F;confluentgraphs&#x2F;</a><p>Stress-Minimizing Orthogonal Layout of Data Flow Diagrams with Ports<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1408.4626.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1408.4626.pdf</a><p>Improved Optimal and Approximate Power Graph Compression for Clearer Visualisation of Dense Graphs<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1311.6996v1.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1311.6996v1.pdf</a></div><br/></div></div><div id="39598066" class="c"><input type="checkbox" id="c-39598066" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39594166">parent</a><span>|</span><a href="#39596702">prev</a><span>|</span><a href="#39594814">next</a><span>|</span><label class="collapse" for="c-39598066">[-]</label><label class="expand" for="c-39598066">[1 more]</label></div><br/><div class="children"><div class="content">Some algorithms do better at this than others, but &quot;make a good diagram of a graph&quot; is an intelligence-complete problem in the general case. Two people might render structurally-identical graphs in very different ways, to emphasize different aspects of the data. This is in fact a similar problem to the &quot;generic graph algorithm&quot; and &quot;generic graph data structure&quot; problems.<p>Graphs straddle the line between code and data. For instance, any given program has a call graph, so in a real sense, the &quot;generic graph algorithm&quot; is just computation.</div><br/></div></div><div id="39594814" class="c"><input type="checkbox" id="c-39594814" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39594166">parent</a><span>|</span><a href="#39598066">prev</a><span>|</span><a href="#39594532">next</a><span>|</span><label class="collapse" for="c-39594814">[-]</label><label class="expand" for="c-39594814">[1 more]</label></div><br/><div class="children"><div class="content">Ideal things are often tree-like. Real-world structures are usually DAGs if they are nice and well-behaved.<p>Making things planar, or almost planar with few crossings and nice clustering of related nodes, is usually hard past a couple dozen nodes :(</div><br/></div></div><div id="39594532" class="c"><input type="checkbox" id="c-39594532" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#39594166">parent</a><span>|</span><a href="#39594814">prev</a><span>|</span><a href="#39596204">next</a><span>|</span><label class="collapse" for="c-39594532">[-]</label><label class="expand" for="c-39594532">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we are used that everything around us have some kind of hierarchy<p>I think the problem is more that we are used to the illusion&#x2F;delusion that everything is hierarchical. The problem that we then encouter is with graph drawing is that it has to try and reconcile the fact that things in practice are rarely really hierarchical, and it&#x27;s hard to draw those lines of where the hierarchies are with mathematical rigor. And that problem gets worse and worse the less properties you are allowed to assume about the underlying graph structure (connectedness, cyclic&#x2F;acyclic, sparse&#x2F;dense).<p>In practice when you want build a UI that interacts with graphs it&#x27;s often feasible to determine&#x2F;impose one or two levels of meta-hierarchy with which you can do clustering (allows for reducing layout destroying impact of hairball nodes + improves rendering performance by reducing node count) and layout with fCOSE (Cytoscape.js has an implementation of that).</div><br/></div></div><div id="39596204" class="c"><input type="checkbox" id="c-39596204" checked=""/><div class="controls bullet"><span class="by">swagasaurus-rex</span><span>|</span><a href="#39594166">parent</a><span>|</span><a href="#39594532">prev</a><span>|</span><a href="#39593497">next</a><span>|</span><label class="collapse" for="c-39596204">[-]</label><label class="expand" for="c-39596204">[4 more]</label></div><br/><div class="children"><div class="content">The illustrations I&#x27;ve seen of neural networks really highlights the sheet incomprehensibility of visualizing large graphs</div><br/><div id="39596746" class="c"><input type="checkbox" id="c-39596746" checked=""/><div class="controls bullet"><span class="by">kjqgqkejbfefn</span><span>|</span><a href="#39594166">root</a><span>|</span><a href="#39596204">parent</a><span>|</span><a href="#39593497">next</a><span>|</span><label class="collapse" for="c-39596746">[-]</label><label class="expand" for="c-39596746">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;12&#x2F;edgecompression_infovis2013.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a></div><br/><div id="39597621" class="c"><input type="checkbox" id="c-39597621" checked=""/><div class="controls bullet"><span class="by">cloogshicer</span><span>|</span><a href="#39594166">root</a><span>|</span><a href="#39596746">parent</a><span>|</span><a href="#39597822">next</a><span>|</span><label class="collapse" for="c-39597621">[-]</label><label class="expand" for="c-39597621">[1 more]</label></div><br/><div class="children"><div class="content">Super interesting paper on an alternative way to render graphs. Thanks for posting!</div><br/></div></div><div id="39597822" class="c"><input type="checkbox" id="c-39597822" checked=""/><div class="controls bullet"><span class="by">criloz2</span><span>|</span><a href="#39594166">root</a><span>|</span><a href="#39596746">parent</a><span>|</span><a href="#39597621">prev</a><span>|</span><a href="#39593497">next</a><span>|</span><label class="collapse" for="c-39597822">[-]</label><label class="expand" for="c-39597822">[1 more]</label></div><br/><div class="children"><div class="content">Wow, this is really amazing, thank you</div><br/></div></div></div></div></div></div></div></div><div id="39593497" class="c"><input type="checkbox" id="c-39593497" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#39594166">prev</a><span>|</span><a href="#39593120">next</a><span>|</span><label class="collapse" for="c-39593497">[-]</label><label class="expand" for="c-39593497">[3 more]</label></div><br/><div class="children"><div class="content">I think the post mostly answers the questions &quot;why are graph _algorithms_ not better supported in programming languages&quot;, with a focus that is much more on &quot;big data&quot; graph processing than graph support in general.<p>I think if you look at graph support in general you are also looking at wider questions, like &quot;why are OGMs (Object Graph Mappers) not as popular as ORMs&quot; and &quot;why is JSON so prevalent while RDF (or another low-level graph serialization) isn&#x27;t&quot;?<p>And I think in the end it comes down to historic reasons (RDF emerged a bit too early and never evolved and accrued an ecosystem of horrible academic standards and implementations), and a graphs having just a smidge more of inherent complexity in implementation and learning curve that just doesn&#x27;t scale well across many developers.<p>------<p>I also wouldn&#x27;t put too much weight on the &quot;Graph Querying Language&quot; part of the article. It sadly reads like exactly the marketing copy you would read from Neo4J or SPARQL enthusiasts that haven&#x27;t tried building a product on top of it.<p>&gt; The main difference between all GQLs and SQL is that the “joins” (relationships) are first-class entities.<p>Joins are first-class entities in SQL. They even have their own keyword (hint: it starts with J and ends with OIN) ;)<p>If you also go to the lower levels of any graph query language and look at it&#x27;s query plans you&#x27;ll notice that there isn&#x27;t any meaningful difference to that of one you&#x27;ll find in an SQL based query. The standardization of GQL[0] as an SQL extension is evidence for that.<p>&gt; In SPARQL relationships are just edges, making the same query easy.<p>SPARQL is easy if you need to do exact path traversals. If you try to do anything sophisticated with it (like you would in the backend of a webapp), you&#x27;ll quickly run into footguns like joins with unbound values and you accidently join your whole result set away.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_Query_Language" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_Query_Language</a></div><br/><div id="39596867" class="c"><input type="checkbox" id="c-39596867" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39593497">parent</a><span>|</span><a href="#39593120">next</a><span>|</span><label class="collapse" for="c-39596867">[-]</label><label class="expand" for="c-39596867">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Joins are first-class entities in SQL. They even have their own keyword (hint: it starts with J and ends with OIN) ;)<p>Having its own keyword is pretty strong evidence that something <i>isn&#x27;t</i> first-class (e.g. typeclasses are not first-class in Haskell; control flow is not first-class in most programming languages).</div><br/><div id="39598939" class="c"><input type="checkbox" id="c-39598939" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#39593497">root</a><span>|</span><a href="#39596867">parent</a><span>|</span><a href="#39593120">next</a><span>|</span><label class="collapse" for="c-39598939">[-]</label><label class="expand" for="c-39598939">[1 more]</label></div><br/><div class="children"><div class="content">I think OP is using “first class” as in “an explicit semantic affordance”, and you seem to be using “first class” as in “a supported operand” (or similar, feel free to correct me if I’m misunderstanding). In which case both points are right, albeit orthogonal.</div><br/></div></div></div></div></div></div><div id="39593120" class="c"><input type="checkbox" id="c-39593120" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#39593497">prev</a><span>|</span><a href="#39596097">next</a><span>|</span><label class="collapse" for="c-39593120">[-]</label><label class="expand" for="c-39593120">[1 more]</label></div><br/><div class="children"><div class="content">Electric Clojure uses Clojure itself (s-expressions) as a graph authoring syntax, using a macro to reify dataflow through a reactive client&#x2F;server system (here the use case is full stack user interfaces but the idea generalizes) <a href="https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric">https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric</a> (I&#x27;m the founder).<p>IMO, the answer to the question &quot;Where are all the graph types?&quot; is: the graph authoring DSL needs to express scope, control flow and abstraction, which essentially makes it isomorphic to a programming language, freed of its evaluation model. In Python and Typescript, embedding a complete programming language is something that&#x27;s rather hard to do!<p>Also see my blog post &quot;Four problems preventing visual flowchart programming from expressing web applications&quot; <a href="https:&#x2F;&#x2F;www.dustingetz.com&#x2F;#&#x2F;page&#x2F;four%20problems%20preventing%20visual%20flowchart%20programming%20from%20expressing%20web%20applications%20(2022)" rel="nofollow">https:&#x2F;&#x2F;www.dustingetz.com&#x2F;#&#x2F;page&#x2F;four%20problems%20preventi...</a></div><br/></div></div><div id="39596097" class="c"><input type="checkbox" id="c-39596097" checked=""/><div class="controls bullet"><span class="by">fatherzine</span><span>|</span><a href="#39593120">prev</a><span>|</span><a href="#39595544">next</a><span>|</span><label class="collapse" for="c-39596097">[-]</label><label class="expand" for="c-39596097">[2 more]</label></div><br/><div class="children"><div class="content">What an awesome article. Kudos to the author!<p>On the core observation &quot;there are too many implementation choices&quot;, that is not quite right. True, the author mentions 4, and there are further variations. In practice, a library can:<p>1. Implement <i>all</i> suitable graph representations.<p>2. Implement algorithms tailored to the representation(s) that offer the highest performance.<p>3. Provide <i>transformations</i> from one representation to another. This is O(#representations), trivial to implement and trivial to use. Quite fair workload for both maintainers and users.<p>4. Bonus, provide import &#x2F; export <i>transformations</i> from &#x2F; to common standard library datatypes and idioms.<p>Memory and transformations are cheap, 99% of use-cases would likely find the overhead of transforming data, both in RAM and CPU, negligible.<p>Edit: &quot;the harsh truth of working at Google is that in the end you are moving protobufs from one place to another.&quot; -- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20132880">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20132880</a></div><br/><div id="39596365" class="c"><input type="checkbox" id="c-39596365" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39596097">parent</a><span>|</span><a href="#39595544">next</a><span>|</span><label class="collapse" for="c-39596365">[-]</label><label class="expand" for="c-39596365">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like the makings of a huge library that I’m not sure I’d even use in my work. I use graphs <i>heavily</i> in my work, and my experience matches the people the author interviewed.<p>We always end up reimplementing graphs because:<p>- Performance matters, and no off the shelf graph library I’ve seen can take advantage of many of the regularities in our particular data set. (We have an append-only DAG which we can internally run-length encode because almost all nodes just have an edge pointing to the last added item).<p>- I haven’t seen any generic graph library which supports the specific queries I need to make on my graphs. The big one is a subgraph diffing function.<p>- Writing something custom just isn’t much work anyway! Graphs are way simpler to reimplement than btrees. You can have a simple graph implementation in tens of lines. Our highly optimised library - with all the supporting algorithms - is still only a few hundred lines of code.<p>I think it would be handy to have ways to export the data into some standard format. But eh. I think pulling a library in for our use case would add more problems than it would solve.</div><br/></div></div></div></div><div id="39595544" class="c"><input type="checkbox" id="c-39595544" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#39596097">prev</a><span>|</span><a href="#39592803">next</a><span>|</span><label class="collapse" for="c-39595544">[-]</label><label class="expand" for="c-39595544">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often wondered about a missing application: &quot;Excel for graphs&quot;.<p>Just like Excel for tabular data, it would support RAM-sized data (enough to require a computer, but not so much that you need a data center), implement lots of algorithms and visualizations &quot;well enough&quot;, and require no programming skill to operate.<p>As the article says, a lot of our real-world problems are <i>graph problems</i> - why are programmers the only ones who should have the tools to solve them?</div><br/><div id="39596506" class="c"><input type="checkbox" id="c-39596506" checked=""/><div class="controls bullet"><span class="by">empiko</span><span>|</span><a href="#39595544">parent</a><span>|</span><a href="#39598778">next</a><span>|</span><label class="collapse" for="c-39596506">[-]</label><label class="expand" for="c-39596506">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I feel like the article is too quick with its conclusions. Many other problems can be made arbitrary complex and difficult with additional requirements. But there are still data structure and standard libraries to provide good enough experience that fits most use-cases. And if you need something extra spicy you need to build a custom solution.<p>The article claims that graphs are often just too big, but yeah, if you ask people who are actively working on graph algorithms they might have that sort of experience. But most programmers and users probably only work with really small graphs.</div><br/></div></div><div id="39598778" class="c"><input type="checkbox" id="c-39598778" checked=""/><div class="controls bullet"><span class="by">jonahss</span><span>|</span><a href="#39595544">parent</a><span>|</span><a href="#39596506">prev</a><span>|</span><a href="#39592803">next</a><span>|</span><label class="collapse" for="c-39598778">[-]</label><label class="expand" for="c-39598778">[1 more]</label></div><br/><div class="children"><div class="content">I agree. And I think the key to this is VR.<p>Another comment in this thread is about how hard graphs are to visualize, but a 3D interface gives you a lot more room.<p>When VR hype began I thought &quot;well what&#x27;s the excel of VR?&quot;. Microsoft&#x27;s answer was &quot;2D spreadsheets floating in 3D space&quot;. What nonsense. I think graphs.<p>email my username at gmail.com if anyone is interested in exploring this together!</div><br/></div></div></div></div><div id="39592803" class="c"><input type="checkbox" id="c-39592803" checked=""/><div class="controls bullet"><span class="by">rb-2</span><span>|</span><a href="#39595544">prev</a><span>|</span><a href="#39595502">next</a><span>|</span><label class="collapse" for="c-39592803">[-]</label><label class="expand" for="c-39592803">[6 more]</label></div><br/><div class="children"><div class="content">I wonder if it would be possible to mathematically define (in a theorem proving language like Coq) a bunch of accessor methods as well as a bunch of implementation primitives and then &quot;compile&quot; a custom graph implementation with whatever properties you need for your application. Some accessor methods will be very efficient for some implementations and very inefficient for others, but every method will still be available for every implementation. Profiling your application performance can help adjust the implementation &quot;compiler&quot; settings.<p>Ironically, this is a graph problem.</div><br/><div id="39593817" class="c"><input type="checkbox" id="c-39593817" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#39592803">parent</a><span>|</span><a href="#39594278">next</a><span>|</span><label class="collapse" for="c-39593817">[-]</label><label class="expand" for="c-39593817">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like Partial Evaluation and the Futamura Projection.  The research around that shows that your interpreter determines the shape of the compiled output, so a formal proof of its application isn&#x27;t necessary, if the $mix$-equivalent has the appropriate syntax and semantics for graph processes in its design.<p>I know this has been done for procedural languages and for declarative logical languages but I&#x27;m not aware of something like this specifically for graph processing and highly specialized code generation of graph processing.  I wouldn&#x27;t be surprised if Mix has been extended for this already, even if it has I&#x27;m sure there is still value in it.</div><br/></div></div><div id="39594278" class="c"><input type="checkbox" id="c-39594278" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39592803">parent</a><span>|</span><a href="#39593817">prev</a><span>|</span><a href="#39594447">next</a><span>|</span><label class="collapse" for="c-39594278">[-]</label><label class="expand" for="c-39594278">[2 more]</label></div><br/><div class="children"><div class="content">I think this is a worthwhile direction.<p>For example, I&#x27;d like to program against a sequence abstraction. When sort is applied to it, I hope it&#x27;s a vector. When slice or splice, I hope it&#x27;s some sort of linked structure. Size is as cheap as empty for the vector but much more expensive for a linked list.<p>It should be possible to determine a reasonable data representation statically based on the operations and control flow graph, inserting conversions where the optimal choice is different.<p>The drawback of course is that people write different programs for different data structures. Knowing what things are cheap and what aren&#x27;t guides the design. There&#x27;s also a relinquishing of control implied by letting the compiler choose for you that people may dislike.<p>As an anecdote for the latter, clojure uses vectors for lambda arguments. I thought that was silly since it&#x27;s a lisp that mostly works in terms of seq abstractions, why not have the compiler choose based on what you do with the sequence? The professional clojure devs I was talking to really didn&#x27;t like that idea.</div><br/><div id="39597954" class="c"><input type="checkbox" id="c-39597954" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39592803">root</a><span>|</span><a href="#39594278">parent</a><span>|</span><a href="#39594447">next</a><span>|</span><label class="collapse" for="c-39597954">[-]</label><label class="expand" for="c-39597954">[1 more]</label></div><br/><div class="children"><div class="content">Clojure uses vector <i>syntax</i> for lambda arguments. `read` sees a vector. What comes out of eval is a lambda. Does a Vector get built in the process? You&#x27;d have to check, my bet would be that the argument list spends a little while as a Java Array, for performance reasons, but that a Clojure Vector is not actually constructed.</div><br/></div></div></div></div><div id="39594447" class="c"><input type="checkbox" id="c-39594447" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#39592803">parent</a><span>|</span><a href="#39594278">prev</a><span>|</span><a href="#39595502">next</a><span>|</span><label class="collapse" for="c-39594447">[-]</label><label class="expand" for="c-39594447">[2 more]</label></div><br/><div class="children"><div class="content">Ive been thinking about something like this. A mathematical definition of a function such that we can search it. Imagine we had something like &quot;Find a function that fits this signature -&gt; Input arr[numbers] out-&gt; for every x in arr, x2&gt;x1.</div><br/><div id="39595320" class="c"><input type="checkbox" id="c-39595320" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#39592803">root</a><span>|</span><a href="#39594447">parent</a><span>|</span><a href="#39595502">next</a><span>|</span><label class="collapse" for="c-39595320">[-]</label><label class="expand" for="c-39595320">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s <a href="https:&#x2F;&#x2F;hoogle.haskell.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hoogle.haskell.org&#x2F;</a> plus dependent types (data constraints).<p>Without human provided dependent typing, 
the search engine would be almost as hard to write as a system to directly generate the code you need.</div><br/></div></div></div></div></div></div><div id="39595502" class="c"><input type="checkbox" id="c-39595502" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#39592803">prev</a><span>|</span><a href="#39592985">next</a><span>|</span><label class="collapse" for="c-39595502">[-]</label><label class="expand" for="c-39595502">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There’s a gap between how often software engineers could use graphs and how little our programming ecosystems support them. Where are all the graph types?<p>They&#x27;ve been there for quite a while :-) <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;digraph.html" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;digraph.html</a> <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;digraph_utils" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;digraph_utils</a><p>And if you want to do some set theoretical stuff you&#x27;re covered as well: <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;sofs.html" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;sofs.html</a></div><br/><div id="39597340" class="c"><input type="checkbox" id="c-39597340" checked=""/><div class="controls bullet"><span class="by">DylanSp</span><span>|</span><a href="#39595502">parent</a><span>|</span><a href="#39592985">next</a><span>|</span><label class="collapse" for="c-39597340">[-]</label><label class="expand" for="c-39597340">[2 more]</label></div><br/><div class="children"><div class="content">Erlang&#x27;s briefly mentioned at the end of the article:<p>&gt; There are two other languages I found with graph types: Erlang and SWI-Prolog. I don’t know either language and cannot tell when they were added; with Erlang, at least, it was before 2008. I reached out to a person on the Erlang core language committee but did not hear back.</div><br/><div id="39597545" class="c"><input type="checkbox" id="c-39597545" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#39595502">root</a><span>|</span><a href="#39597340">parent</a><span>|</span><a href="#39592985">next</a><span>|</span><label class="collapse" for="c-39597545">[-]</label><label class="expand" for="c-39597545">[1 more]</label></div><br/><div class="children"><div class="content">Oh I did miss that. Thanks for pointing it out.</div><br/></div></div></div></div></div></div><div id="39592985" class="c"><input type="checkbox" id="c-39592985" checked=""/><div class="controls bullet"><span class="by">montmorency88</span><span>|</span><a href="#39595502">prev</a><span>|</span><a href="#39598624">next</a><span>|</span><label class="collapse" for="c-39592985">[-]</label><label class="expand" for="c-39592985">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;d highly recommend Erwigs FGL library in Haskell as a really nice example of a generally performant graph data structure that is easy to work with. The API feels like working with lists because you are essentially consing contexts(node, neighbours) into a list of contexts that form your graph. Many standard graph algorithms are then built up from depth or breadth first search and you can compose really succinct programs to manipulate the graph. Graphs are labelled with any Haskell data structure and there is a graphviz library complementary to FGL to generate dot files which can be rendered according to the data carried in the node labels. Often in an application you want to both perform computations on your graph and render a visualization simultaneously to the end user or for debugging and in FGL you minimise duplication of application and rendering logic.</div><br/><div id="39593832" class="c"><input type="checkbox" id="c-39593832" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#39592985">parent</a><span>|</span><a href="#39598100">next</a><span>|</span><label class="collapse" for="c-39593832">[-]</label><label class="expand" for="c-39593832">[5 more]</label></div><br/><div class="children"><div class="content">FGL is a great example of how to make a &quot;nice&quot; high-level graph interface suited for functional programming. I&#x27;m a big fan. But it&#x27;s orders of magnitude too slow and memory-inefficient for performance-sensitive graph computations—if you have even moderately sized graphs and graph algorithms are a bottleneck, you&#x27;ll need to use something else, and probably something domain-specific. Given the way the interface works, I don&#x27;t think you <i>could</i> have a high-performance version that would scale to large graphs.<p>In my experience this leaves FGL in an awkward spot: on the one hand, it isn&#x27;t sufficient for heavy-duty graph processing; on the other, if you <i>don&#x27;t</i> need fancy high-performance graph algorithms, chance are that encoding your problem as a graph is going to be more awkward than defining some domain-specific types for what you&#x27;re doing. Graphs are such a general structure that they&#x27;re usually the wrong level of abstraction for higher-level domain-specific logic.<p>Of course, sometimes you&#x27;re writing graph code specifically and you need a nice way to express your graph algorithms without worrying about performance. In that case, FGL is great. I wrote a tutorial about using it to [generate mazes][1] and it helped me express the algorithms better than I would have been able to do without it. But that still leaves it as too narrow for something to be &quot;the&quot; graph representation in a language&#x27;s standard library.<p>[1]: <a href="https:&#x2F;&#x2F;jelv.is&#x2F;blog&#x2F;Generating-Mazes-with-Inductive-Graphs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jelv.is&#x2F;blog&#x2F;Generating-Mazes-with-Inductive-Graphs&#x2F;</a></div><br/><div id="39595878" class="c"><input type="checkbox" id="c-39595878" checked=""/><div class="controls bullet"><span class="by">Chris_Newton</span><span>|</span><a href="#39592985">root</a><span>|</span><a href="#39593832">parent</a><span>|</span><a href="#39594607">next</a><span>|</span><label class="collapse" for="c-39595878">[-]</label><label class="expand" for="c-39595878">[2 more]</label></div><br/><div class="children"><div class="content"><i>But it&#x27;s orders of magnitude too slow and memory-inefficient for performance-sensitive graph computations—if you have even moderately sized graphs and graph algorithms are a bottleneck, you&#x27;ll need to use something else, and probably something domain-specific.</i><p>This seems a little pessimistic to me. There are plenty of application domains that can be conveniently represented using graphs where you might have thousands of nodes and edges — which is what I’d characterise as “moderately sized” — and your needs might only extend to relatively simple and efficient graph algorithms. FGL is excellent in this kind of scenario.<p>If you do need the kind of algorithms that explode in complexity then even a representation a couple of orders of magnitude more efficient won’t help you much either. Big-O is the thing that is going to spoil your day in this story, not the constant factor. Some problems simply don’t have convenient fast solutions and ideally with those you find a way to change the representation so the original problem doesn’t arise in the first place.<p>It’s true that there’s also a zone where you have significantly larger graphs but still only need computationally tractable algorithms, and in that case the overheads of a library like FGL become a factor in what is viable. I also don’t disagree with you (and Hillel in the original piece) that it would be difficult to define comprehensive graph functionality to include in a standard library when there are so many different trade-offs involved.<p>A good — and not entirely unconnected — analogy might be calculating with matrices. It’s convenient to have support for simple but widely useful cases like 3x3 and 4x4 built into your language or standard library. However, once you’re solving systems with hundreds or thousands of rows, you probably want more specialised tools like BLAS&#x2F;LAPACK, and the structure of your matrix and how you can decompose it start to matter a lot more.</div><br/><div id="39597224" class="c"><input type="checkbox" id="c-39597224" checked=""/><div class="controls bullet"><span class="by">michelpp</span><span>|</span><a href="#39592985">root</a><span>|</span><a href="#39595878">parent</a><span>|</span><a href="#39594607">next</a><span>|</span><label class="collapse" for="c-39597224">[-]</label><label class="expand" for="c-39597224">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  you probably want more specialised tools like BLAS&#x2F;LAPACK<p>The GraphBLAS and LAGraph are sparse matrix optimized libraries for this exact purpose:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;DrTimothyAldenDavis&#x2F;GraphBLAS">https:&#x2F;&#x2F;github.com&#x2F;DrTimothyAldenDavis&#x2F;GraphBLAS</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;GraphBLAS&#x2F;LAGraph&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;GraphBLAS&#x2F;LAGraph&#x2F;</a></div><br/></div></div></div></div><div id="39594607" class="c"><input type="checkbox" id="c-39594607" checked=""/><div class="controls bullet"><span class="by">montmorency88</span><span>|</span><a href="#39592985">root</a><span>|</span><a href="#39593832">parent</a><span>|</span><a href="#39595878">prev</a><span>|</span><a href="#39598100">next</a><span>|</span><label class="collapse" for="c-39594607">[-]</label><label class="expand" for="c-39594607">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. Under the hood FGL is mapping the graph to relatively efficient data structures like Patricia Trees as implemented in Data.IntMap so I would expect it to scale reasonably for inserting edges and mapping over nodes. I agree the memory inefficiency is definitely a limiting factor of the library. As you say I think it is best suited for expressing graph algorithms and if those calculations become the bottle neck a custom solution can be developed with the proof of concept already in place.
 Out of curiosity what number of nodes&#x2F;edges would you consider a &quot;moderately sized graph&quot;? My user cases are typically on the order of 500-1000 nodes with a similar number of edges that require bfs and topological sorting.</div><br/><div id="39595062" class="c"><input type="checkbox" id="c-39595062" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#39592985">root</a><span>|</span><a href="#39594607">parent</a><span>|</span><a href="#39598100">next</a><span>|</span><label class="collapse" for="c-39595062">[-]</label><label class="expand" for="c-39595062">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have an exact number in mind—I imagine it&#x27;s pretty context-specific—but 500–1000 nodes seems like it would qualify.<p>I&#x27;ve played around with IntMap before and it&#x27;s not a <i>great</i> data structure. It&#x27;s a <i>binary</i> Patricia trie, which means that you quickly get a relatively deep tree with lots of pointer traversals. Unless I&#x27;ve managed to confuse myself on how it works, you&#x27;d end up with, what, at least 10 traversals to look up a value from 1000 keys?</div><br/></div></div></div></div></div></div><div id="39598100" class="c"><input type="checkbox" id="c-39598100" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39592985">parent</a><span>|</span><a href="#39593832">prev</a><span>|</span><a href="#39598624">next</a><span>|</span><label class="collapse" for="c-39598100">[-]</label><label class="expand" for="c-39598100">[1 more]</label></div><br/><div class="children"><div class="content">In Haskell though I think Alga has an even nicer API. Don&#x27;t know about performance as I haven&#x27;t had a need to use Haskell to process enormous graphs. <a href="https:&#x2F;&#x2F;github.com&#x2F;snowleopard&#x2F;alga">https:&#x2F;&#x2F;github.com&#x2F;snowleopard&#x2F;alga</a></div><br/></div></div></div></div><div id="39598624" class="c"><input type="checkbox" id="c-39598624" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39592985">prev</a><span>|</span><a href="#39595038">next</a><span>|</span><label class="collapse" for="c-39598624">[-]</label><label class="expand" for="c-39598624">[1 more]</label></div><br/><div class="children"><div class="content">The C++ Standard Template Library is now 29 years old.  It doesn&#x27;t have a graph (or generic B-tree) data structure.  That says it all for me.  In my too many years of programming, I have only needed to program a graph structure once or twice.  Yes, the are &quot;ubiquitous in software engineering&quot;, but still incredibly rare in most enterprise programming projects.</div><br/></div></div><div id="39595038" class="c"><input type="checkbox" id="c-39595038" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39598624">prev</a><span>|</span><a href="#39597035">next</a><span>|</span><label class="collapse" for="c-39595038">[-]</label><label class="expand" for="c-39595038">[3 more]</label></div><br/><div class="children"><div class="content">I think most languages support representing many kinds of graphs very well, particularly directed graphs without data on the edges: with objects, lists, and object references (or pointers).<p>A tree is a graph. A typical Java-style object composing other objects composing other objects again, etc etc, often with cycles and parent backreferences and whatnot, is a graph. The html DOM is a graph.<p>I recognize that these are often very tree-like, which feels like cheating in the same way as saying “well a list is also a graph!” is. But given that cycles are common enough that serializers (eg JSON.stringify) need to special-case those, I think maybe this is simply not true, and they’re really just graphs. Very few tree-like class structures tend to remain pure trees.<p>The only thing missing from references&#x2F;pointers to be able to represent what the author is looking for, is having data on the edges. I think this is trivially solvable by putting nodes halfway the edge (= add a level of indirection, an operation so common that we don’t even think of it as “adding data to the edges”).<p>So I think the answer is that there’s no explicit data structure named “graph” because the basic building block of composition in nearly every language (reference&#x2F;pointer) is an edge, and the basic building block of data representation (objects&#x2F;structs&#x2F;records) is a node. So for most graphs, trying to pour it all into some fancy Graph&lt;V, E&gt; datastructure feels like needless complexity.</div><br/><div id="39596818" class="c"><input type="checkbox" id="c-39596818" checked=""/><div class="controls bullet"><span class="by">e_y_</span><span>|</span><a href="#39595038">parent</a><span>|</span><a href="#39597035">next</a><span>|</span><label class="collapse" for="c-39596818">[-]</label><label class="expand" for="c-39596818">[2 more]</label></div><br/><div class="children"><div class="content">Back in the C days, it was common to not use generic data structures like lists; instead you&#x27;d have a next_item pointer as a field in the struct. For linked lists, this would save you from needing another memory allocation or wrapper struct, and since C doesn&#x27;t have templates you&#x27;d either have to blindly cast the type or use macros or write a type-specific iterator anyways.<p>Lists eventually became a standard language feature in C++ and other languages, but it&#x27;s trickier for trees and graphs. Taking the DOM example, you might be searching through child elements (div, span, etc) or nodes (text nodes, comment nodes) and different operations might only work with a specific subset of the &quot;edges&quot;. There might be pointers to other objects, like from a DOM node to accessibility tree node. You might even have multiple parent node pointers, such as a pointer that takes you to the nearest shadow root or something.<p>Since there are multiple ways to traverse the same data structure, generic functions don&#x27;t work on it. You could create a separate tree&#x2F;graph for each thing you want to use it for, but that takes additional memory and has to be updated when the original struct changes. Or you could create some kind of adapter that has a get_edges() function, but this might not be very well optimized or might be clunky for many other reasons. So it usually just ends up being simpler rolling your own functions instead of using a library.</div><br/><div id="39597014" class="c"><input type="checkbox" id="c-39597014" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39595038">root</a><span>|</span><a href="#39596818">parent</a><span>|</span><a href="#39597035">next</a><span>|</span><label class="collapse" for="c-39597014">[-]</label><label class="expand" for="c-39597014">[1 more]</label></div><br/><div class="children"><div class="content">Bonus points for not allocating space for the next pointer if you didn’t plan to use it…</div><br/></div></div></div></div></div></div><div id="39597035" class="c"><input type="checkbox" id="c-39597035" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#39595038">prev</a><span>|</span><a href="#39593093">next</a><span>|</span><label class="collapse" for="c-39597035">[-]</label><label class="expand" for="c-39597035">[3 more]</label></div><br/><div class="children"><div class="content">Another data type that would be quite useful is a table (like in a database). For the same reasons, too many design choices.<p>Anyway, that being said, I have felt that progress will be made in programming languages if the compiler gets to choose an implementation of a data structure, kinda like when a database chooses an execution plan. So you just use an abstract structure (like sequence, map, set, table, graph) and based on the program profile, the compiler will pick the specific implementation. It will also transform the structure into another isomorphic one as needed. (Some programming languages already do something like this, for example, array of structs to struct of arrays conversion.)</div><br/><div id="39597911" class="c"><input type="checkbox" id="c-39597911" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#39597035">parent</a><span>|</span><a href="#39593093">next</a><span>|</span><label class="collapse" for="c-39597911">[-]</label><label class="expand" for="c-39597911">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So you just use an abstract structure (like sequence, map, set, table, graph) and based on the program profile, the compiler will pick the specific implementation. It will also transform the structure into another isomorphic one as needed.<p>I&#x27;m so not looking forward to having to debug a sudden change in perf characteristics when one additional usage of some feature tips a heuristic over the line and an implementation gets swapped out between builds.</div><br/><div id="39600321" class="c"><input type="checkbox" id="c-39600321" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#39597035">root</a><span>|</span><a href="#39597911">parent</a><span>|</span><a href="#39593093">next</a><span>|</span><label class="collapse" for="c-39600321">[-]</label><label class="expand" for="c-39600321">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a sudden change in perf characteristics when one additional usage of some feature tips a heuristic over<p>This already happens with humans, changing features will change how the product is used and thus performance characteristics changes.<p>The question is, do you trust the compiler to do a good job? Of course you won&#x27;t, till the late 90s, people didn&#x27;t trust compilers to do a better job than humans in assembler.<p>So it&#x27;s important to have a good UX for this feature, where the compiler communicates what data types is it using, and gives human option to override its decisions. So that users would gain trust in this feature.</div><br/></div></div></div></div></div></div><div id="39593093" class="c"><input type="checkbox" id="c-39593093" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#39597035">prev</a><span>|</span><a href="#39592864">next</a><span>|</span><label class="collapse" for="c-39593093">[-]</label><label class="expand" for="c-39593093">[1 more]</label></div><br/><div class="children"><div class="content">A graph, as presented in this article, is a model of something else.  That we have more than one way to implement this model is rather natural, all told.  The hope that we can have a singular syntax and data structure that represents a graph in code is almost exactly why the author of Java&#x27;s Linked List posted this gem: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;joshbloch&#x2F;status&#x2F;583813919019573248" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;joshbloch&#x2F;status&#x2F;583813919019573248</a><p>My favorite on the idea of having a linked list where the node is first class in your code, is almost precisely the problem.  You rarely want&#x2F;need to work at that level.  In a very real sense, objects that have other objects are already trees of data.  Many can back reference, such that then you have a graph.<p>And then there is the joy of trying to use matrix operations to work with graphs.  You can do some powerful things, but at that point, you almost certainly want the matrix to be the abstraction.<p>Excited to see someone come up with good things in this idea.  I retain very serious doubts that I want a singular model for my data.</div><br/></div></div><div id="39592864" class="c"><input type="checkbox" id="c-39592864" checked=""/><div class="controls bullet"><span class="by">andsens</span><span>|</span><a href="#39593093">prev</a><span>|</span><a href="#39600110">next</a><span>|</span><label class="collapse" for="c-39592864">[-]</label><label class="expand" for="c-39592864">[3 more]</label></div><br/><div class="children"><div class="content"><i>devils advocate</i>: Is this maybe a case of discarding an 80% solution because you can’t do the last 20%?<p>I understand the constraints, but imagine how legible you could make code by replacing some key parts with a graph type that everybody knows.  
I honestly think that having a type that supports a small subset of possibilities and only has the simplest algorithms implemented would go a long way.</div><br/><div id="39593342" class="c"><input type="checkbox" id="c-39593342" checked=""/><div class="controls bullet"><span class="by">boothby</span><span>|</span><a href="#39592864">parent</a><span>|</span><a href="#39595406">next</a><span>|</span><label class="collapse" for="c-39593342">[-]</label><label class="expand" for="c-39593342">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t just an 80&#x2F;20 problem.  Imagine that you replace every linked list, binary tree, trie, etc., with a generic directed graph datatype.  The resulting performance would be <i>abysmal</i>.  The resulting notation would be horrid, too.<p>Here&#x27;s our nice linked list:<p><pre><code>  def last_element(ll):
      last = ll
      while ll is not None:
          last = ll
          ll = ll.next
      return last
</code></pre>
And here&#x27;s an implementation with generic graph notation:<p><pre><code>  def last_element(g):
      for v, deg in g.out_degree:
          if deg == 0:
              return v
      return None
</code></pre>
There are several problems with this; most importantly, there can be silent failures when g is not a linked list.  But it also throws out a useful abstraction where a list is equivalent to a node, so I wrote a horrid implementation that takes O(n) regardless of the position in the list.  And then comes all the baggage of representation, because you can&#x27;t just represent a node with a pointer anymore.<p>When your data structure better reflects the, well, structure of your data, you can go faster and safer.  There&#x27;s a reason we teach undergrads about these specific datatypes and don&#x27;t just sweep it all under a rug with &quot;it&#x27;s a graph!&quot;</div><br/></div></div><div id="39595406" class="c"><input type="checkbox" id="c-39595406" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39592864">parent</a><span>|</span><a href="#39593342">prev</a><span>|</span><a href="#39600110">next</a><span>|</span><label class="collapse" for="c-39595406">[-]</label><label class="expand" for="c-39595406">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more like discarding a 20% solution that can&#x27;t do the last 80%.</div><br/></div></div></div></div><div id="39600110" class="c"><input type="checkbox" id="c-39600110" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#39592864">prev</a><span>|</span><a href="#39599969">next</a><span>|</span><label class="collapse" for="c-39600110">[-]</label><label class="expand" for="c-39600110">[1 more]</label></div><br/><div class="children"><div class="content">Well, we have many implementations for simpler abstractions like lists where it might be useful to have contiguous memory, or to have quick append&#x2F;pop, or maybe inserting at the front, or slicing.<p>I think that having clearly defined &quot;instances&quot; of these tailored lists, like vector, deque, linked list helps a bit, but graphs are a harder problem since there&#x27;s more ways of tailoring them to specific purposes. and with this comes more tradeoffs.</div><br/></div></div><div id="39599969" class="c"><input type="checkbox" id="c-39599969" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#39600110">prev</a><span>|</span><a href="#39597925">next</a><span>|</span><label class="collapse" for="c-39599969">[-]</label><label class="expand" for="c-39599969">[1 more]</label></div><br/><div class="children"><div class="content">Partly it’s just our beloved overthinking and rationalization of it. When I needed a graph to repesent and edit a structure of supply contracts, I just stored {who, to-who[]} and loaded these arrays into a graph library written in js. Performance, formats didn’t matter because there’s only so much contracts, 5-20 per single graph. If there was no graph library, that would <i>suck</i>, and no amount of rationalization would change that. Complexity of the area never offsets the value of having at least something useful in it.</div><br/></div></div><div id="39597925" class="c"><input type="checkbox" id="c-39597925" checked=""/><div class="controls bullet"><span class="by">Ptitselov</span><span>|</span><a href="#39599969">prev</a><span>|</span><a href="#39593017">next</a><span>|</span><label class="collapse" for="c-39597925">[-]</label><label class="expand" for="c-39597925">[1 more]</label></div><br/><div class="children"><div class="content">If you code in .NET, please try my graph library Arborescence [1]. It&#x27;s small and not very feature-rich. However, I believe it provides a good separation between abstractions [2], algorithms, and data structures.
Regarding the points mentioned in the article:
- you can use the edges with or without their own identity,
- you can use implicit graphs unfolded on the fly,
- you can use both adjacency (out-neighbors) and incidence (out-edges + head) interfaces,
- no edge type is emposed by the library, although it does provide the basic tail-head-pair structure as a utility.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;qbit86&#x2F;arborescence">https:&#x2F;&#x2F;github.com&#x2F;qbit86&#x2F;arborescence</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;qbit86&#x2F;arborescence&#x2F;tree&#x2F;develop&#x2F;src&#x2F;Arborescence.Abstractions">https:&#x2F;&#x2F;github.com&#x2F;qbit86&#x2F;arborescence&#x2F;tree&#x2F;develop&#x2F;src&#x2F;Arbo...</a></div><br/></div></div><div id="39593017" class="c"><input type="checkbox" id="c-39593017" checked=""/><div class="controls bullet"><span class="by">mizzlr_</span><span>|</span><a href="#39597925">prev</a><span>|</span><a href="#39592706">next</a><span>|</span><label class="collapse" for="c-39593017">[-]</label><label class="expand" for="c-39593017">[3 more]</label></div><br/><div class="children"><div class="content">graph is a data structure, not a data type. if you squint enough pointers are the building blocks (the data type is you please) for building graph data structure. a-&gt;b is pointer access, looks like an edge in the graph.<p>graph data structure is parent of tree, code execution&#x2F; function call stacks work like a tree, think flame graphs.<p>stacks and pointers are baked in assembly and cpu architecture. your claims can&#x27;t be farther from the truth.</div><br/><div id="39596277" class="c"><input type="checkbox" id="c-39596277" checked=""/><div class="controls bullet"><span class="by">Chris_Newton</span><span>|</span><a href="#39593017">parent</a><span>|</span><a href="#39593113">next</a><span>|</span><label class="collapse" for="c-39596277">[-]</label><label class="expand" for="c-39596277">[1 more]</label></div><br/><div class="children"><div class="content"><i>graph is a data structure, not a data type.</i><p>It can refer to either.<p>Any concrete data structure that uses indirection — which means pretty much anything more complicated than dense arrays and records — is indeed a form of graph.<p>But graphs, and more constrained forms like DAGs and trees, can also be abstract data types, implemented by a variety of concrete representations.<p>One of life’s little ironies is that implementing a general abstract graph using a general concrete graph whose records and pointers correspond (roughly) 1:1 with the nodes and edges in the abstract graph is often a poor choice.<p>Moreover, it’s not unusual to have an abstract graph implemented using a non-graph data structure (for example, a dense adjacency matrix) or to use a graph-like data structure to implement an abstract data type whose interface doesn’t look particularly graph-like (for example, a piece table).</div><br/></div></div><div id="39593113" class="c"><input type="checkbox" id="c-39593113" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#39593017">parent</a><span>|</span><a href="#39596277">prev</a><span>|</span><a href="#39592706">next</a><span>|</span><label class="collapse" for="c-39593113">[-]</label><label class="expand" for="c-39593113">[1 more]</label></div><br/><div class="children"><div class="content">Pointer-based graph structure will make matrix algos painful to implement. A graph is a concept. Article is quite meaningful about how it follows the various subtypes. Would recommend reading.</div><br/></div></div></div></div><div id="39592706" class="c"><input type="checkbox" id="c-39592706" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39593017">prev</a><span>|</span><a href="#39594016">next</a><span>|</span><label class="collapse" for="c-39592706">[-]</label><label class="expand" for="c-39592706">[10 more]</label></div><br/><div class="children"><div class="content">I would claim that object oriented languages are a syntax, semantics and type system for graphs.<p>Objects are nodes.<p>Fields are edges.<p>The object graph is the heap.<p>So your whole program state is a graph.</div><br/><div id="39592757" class="c"><input type="checkbox" id="c-39592757" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592806">next</a><span>|</span><label class="collapse" for="c-39592757">[-]</label><label class="expand" for="c-39592757">[2 more]</label></div><br/><div class="children"><div class="content">Graphs are such a general concept that if you squint everything is a graph. Your example works just as well with structs and member fields, we don&#x27;t even need the OO hypothesis.</div><br/><div id="39593186" class="c"><input type="checkbox" id="c-39593186" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39592706">root</a><span>|</span><a href="#39592757">parent</a><span>|</span><a href="#39592806">next</a><span>|</span><label class="collapse" for="c-39593186">[-]</label><label class="expand" for="c-39593186">[1 more]</label></div><br/><div class="children"><div class="content">C and structs let you write code using whatever paradigm you want. So you can do object graphs. And you can also do closures. And you can do many other things.<p>Lots of things are possible when you just treat memory as bytes and pointers are just integers.</div><br/></div></div></div></div><div id="39592806" class="c"><input type="checkbox" id="c-39592806" checked=""/><div class="controls bullet"><span class="by">tlb</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592757">prev</a><span>|</span><a href="#39592766">next</a><span>|</span><label class="collapse" for="c-39592806">[-]</label><label class="expand" for="c-39592806">[2 more]</label></div><br/><div class="children"><div class="content">A limitation is that you can only have one such graph in the program. So any graph algorithm that returns a graph, or uses another graph during the computation, doesn&#x27;t fit.</div><br/><div id="39593924" class="c"><input type="checkbox" id="c-39593924" checked=""/><div class="controls bullet"><span class="by">boothby</span><span>|</span><a href="#39592706">root</a><span>|</span><a href="#39592806">parent</a><span>|</span><a href="#39592766">next</a><span>|</span><label class="collapse" for="c-39593924">[-]</label><label class="expand" for="c-39593924">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t fall for the abstraction!  Mathematically speaking, if you have graphs G1 and G2; you can make another graph H with nodes {G1, G2} and edges {(G1, G2)} and nothing goes wrong.  You can definitely view your whole operating system as a graph; it doesn&#x27;t invalidate having a program running which processes graphs.</div><br/></div></div></div></div><div id="39592766" class="c"><input type="checkbox" id="c-39592766" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592806">prev</a><span>|</span><a href="#39592888">next</a><span>|</span><label class="collapse" for="c-39592766">[-]</label><label class="expand" for="c-39592766">[1 more]</label></div><br/><div class="children"><div class="content">Right, I think that&#x27;s just what I said the first time this came up: all languages with GC have graphs builtin.<p>(Though C has graphs too.  If every node shares the same lifetime, then it&#x27;s pretty easy to manage.  Otherwise it can be pretty painful)<p>And the good news is that you simply use the TYPE SYSTEM to categorize your nodes and edges.<p>Your edges are references to other objects, which are typed.  Node can be typed as well.<p>---<p>Although the original article does get at this -- there are many types of graphs, and some of them can be encoded in a typed object graph.<p>Some of them can&#x27;t -- you need the equivalent of void* for the edges.<p>Others would need a List[T] for the edges, if the out degree is not fixed.<p>And that only covers directed graphs, etc.<p>Also, it&#x27;s true that allocating all these tiny objects as GC objects can be very slow, so then you use other representations of graphs, like a list of pairs of node IDs.<p>I don&#x27;t really think of it as a &quot;missing&quot; data structure, but yeah now I do see how that framing can be useful.</div><br/></div></div><div id="39592888" class="c"><input type="checkbox" id="c-39592888" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592766">prev</a><span>|</span><a href="#39592738">next</a><span>|</span><label class="collapse" for="c-39592888">[-]</label><label class="expand" for="c-39592888">[1 more]</label></div><br/><div class="children"><div class="content">For that matter it&#x27;s true about a certain kind of C program.  In a civilized language you have run-time typing and introspection and have all the type information so that it is straightforward to look at the program&#x27;s data structures as a graph.<p>If you are looking at the debug symbols and a copy of the program you can usually figure this graph out but you might need to think about it sometimes.</div><br/></div></div><div id="39592738" class="c"><input type="checkbox" id="c-39592738" checked=""/><div class="controls bullet"><span class="by">reaperman</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592888">prev</a><span>|</span><a href="#39593703">next</a><span>|</span><label class="collapse" for="c-39592738">[-]</label><label class="expand" for="c-39592738">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a useful model for me personally, and don&#x27;t want to diminish its potential value to others; I often think of programs as graphs.<p>I think it&#x27;s interesting to add to the discussion that I&#x27;m wary to reduce anything to any particular &quot;Turing-complete concept&quot;. Because anything can be represented by anything.</div><br/></div></div><div id="39593703" class="c"><input type="checkbox" id="c-39593703" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39592738">prev</a><span>|</span><a href="#39592736">next</a><span>|</span><label class="collapse" for="c-39593703">[-]</label><label class="expand" for="c-39593703">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    let x = 1; &#x2F;&#x2F; edge named x
    let y = f(x); &#x2F;&#x2F; node named f with input edge x and output edge y</code></pre></div><br/></div></div><div id="39592736" class="c"><input type="checkbox" id="c-39592736" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#39592706">parent</a><span>|</span><a href="#39593703">prev</a><span>|</span><a href="#39594016">next</a><span>|</span><label class="collapse" for="c-39592736">[-]</label><label class="expand" for="c-39592736">[1 more]</label></div><br/><div class="children"><div class="content">I was about to post &quot;Data structures are graphs,&quot; but your explanation says it better.</div><br/></div></div></div></div><div id="39594016" class="c"><input type="checkbox" id="c-39594016" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39592706">prev</a><span>|</span><a href="#39592792">next</a><span>|</span><label class="collapse" for="c-39594016">[-]</label><label class="expand" for="c-39594016">[4 more]</label></div><br/><div class="children"><div class="content">This reminds me of my quest to find the proper method to model what I&#x27;ve termed &#x27;large types&#x27; in an ideal language.<p>As is well known, algebraic data types as commonly found, consist of sums of products, yet a great deal of useful types are larger than that; some hopefully illustrative examples include:<p>1) the type of subsets of another type would be 2^X (hopefully demonstrating what I mean by &#x27;large&#x27;ness);<p>2) in practical languages like TypeScript, the &#x27;Partial&#x27; of a product type A x B x C would be (1 + A) x (1 + B) x (1 + C);<p>3) data structures in general, as a term amenable to some certain set of operations, when needing to be represented for performance reasons e.g. a) union-find structures (quotients?); b) a list of words and their inverted indexes for searching; c) a sorted list<p>Reading more about type modelling, and learning of the disagreements in how even basic things like quotients ought to be represented as types, I&#x27;ve since resigned to an understanding of this as an unsolved problem, and relegated the modelling the kitchen sinks of types with <i>the</i> kitchen sink of types - i.e. the function type  (curbed with suitable type constraints upon the signature - from an index type to a suitable base type) - after all, its power and province being the irreducible kernel of type polymorphism, shadow over Church&#x27;s types, original sin against type decidability.</div><br/><div id="39594050" class="c"><input type="checkbox" id="c-39594050" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#39594016">parent</a><span>|</span><a href="#39594150">next</a><span>|</span><label class="collapse" for="c-39594050">[-]</label><label class="expand" for="c-39594050">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking about something like this for the last 3 years. However, I can&#x27;t find a practical reason for it, even though I am sure there are.</div><br/></div></div><div id="39594150" class="c"><input type="checkbox" id="c-39594150" checked=""/><div class="controls bullet"><span class="by">gue5t</span><span>|</span><a href="#39594016">parent</a><span>|</span><a href="#39594050">prev</a><span>|</span><a href="#39592792">next</a><span>|</span><label class="collapse" for="c-39594150">[-]</label><label class="expand" for="c-39594150">[2 more]</label></div><br/><div class="children"><div class="content">These types don&#x27;t seem to escape the scope of what can be described with algebraic types, but the relationships between them seem like you&#x27;re looking for a notion of type-level functions: subset ≡ X =&gt; 2^X, partial ≡ A×B =&gt; (A+1)×partial(B)</div><br/><div id="39594307" class="c"><input type="checkbox" id="c-39594307" checked=""/><div class="controls bullet"><span class="by">qazxcvbnm</span><span>|</span><a href="#39594016">root</a><span>|</span><a href="#39594150">parent</a><span>|</span><a href="#39592792">next</a><span>|</span><label class="collapse" for="c-39594307">[-]</label><label class="expand" for="c-39594307">[1 more]</label></div><br/><div class="children"><div class="content">Consider the case of Partials - we might like to restrict the Partials to different subsets of the fields for different purposes; consider the modelling of an inverted index.<p>Certainly it is possible to represent each specific case as some algebraic type; but beyond trivial cases, I find that when I need such of these types, quickly I discover that there are myriad ways to express them, none of them uniquely natural, unlike the way a sum of products type (and its terms) can be pretty much unambiguously drawn from a specification.<p>This matters especially when e.g. I need to evolve my types in a data migration.</div><br/></div></div></div></div></div></div><div id="39592792" class="c"><input type="checkbox" id="c-39592792" checked=""/><div class="controls bullet"><span class="by">gilleain</span><span>|</span><a href="#39594016">prev</a><span>|</span><a href="#39594440">next</a><span>|</span><label class="collapse" for="c-39592792">[-]</label><label class="expand" for="c-39592792">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And then for each of those types we have hypergraphs, where an edge can connect three or more nodes, and ubergraphs, where edges can point to other edges.<p>Huh, I&#x27;ve heard of hypergraphs (although never actually really used them) but never an &#x27;ubergraph&#x27;. Sounds tricky!<p>In practice, how often are there situations you definitely need hypergraphs? I had a particular situation where I needed graphs that were both vertex coloured (labelled) <i>and</i> edge coloured (labelled) - even then it was outside the normal situation for what I was doing (graph canonicalization).</div><br/><div id="39597536" class="c"><input type="checkbox" id="c-39597536" checked=""/><div class="controls bullet"><span class="by">ratmice</span><span>|</span><a href="#39592792">parent</a><span>|</span><a href="#39594440">next</a><span>|</span><label class="collapse" for="c-39597536">[-]</label><label class="expand" for="c-39597536">[1 more]</label></div><br/><div class="children"><div class="content">ubergraphs are pretty weird, i&#x27;ve never actually seen them really used anywhere.
Just a couple of papers pointing out their existence. They have some weird quirks like
every hypergraph and thus graph has a dual, but ubergraphs with uberedges do not appear to have one.</div><br/></div></div></div></div><div id="39594440" class="c"><input type="checkbox" id="c-39594440" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39592792">prev</a><span>|</span><a href="#39596386">next</a><span>|</span><label class="collapse" for="c-39594440">[-]</label><label class="expand" for="c-39594440">[1 more]</label></div><br/><div class="children"><div class="content">Maybe there could be some utility for a decently general Graph type that can be used for high-level testing and verification. Maybe you could implement your efficient graph per-problem and then validate it with a more high-level and declarative type. You would have to implement some isomorphism between the types though.</div><br/></div></div><div id="39596386" class="c"><input type="checkbox" id="c-39596386" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#39594440">prev</a><span>|</span><a href="#39597669">next</a><span>|</span><label class="collapse" for="c-39596386">[-]</label><label class="expand" for="c-39596386">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, despite its name being an abbreviation for LISt Processing, the fundamental datatype of lisp (the cons cell) is actually a vertice on a directed graph with the restriction that each vertice can only have two outgoing edges.</div><br/></div></div><div id="39597669" class="c"><input type="checkbox" id="c-39597669" checked=""/><div class="controls bullet"><span class="by">xLaszlo</span><span>|</span><a href="#39596386">prev</a><span>|</span><a href="#39596693">next</a><span>|</span><label class="collapse" for="c-39597669">[-]</label><label class="expand" for="c-39597669">[1 more]</label></div><br/><div class="children"><div class="content">I found that the best to think of graph implementation is sparse matrices of the adjacency matrix. CSR&#x2F;CSC format has fast lookup abilities, building and switching between formats is &quot;relative&quot; efficient. Most graph algorithms need primitives that can be built on top of this.<p>For distributed computing one can look int GraphLab or its smaller version, now largely abandoned GraphChi.</div><br/></div></div><div id="39596693" class="c"><input type="checkbox" id="c-39596693" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#39597669">prev</a><span>|</span><a href="#39592880">next</a><span>|</span><label class="collapse" for="c-39596693">[-]</label><label class="expand" for="c-39596693">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been building an interactive fiction platform built in C# with a world model contained within a bidirectional graph data structure.<p>Since IF stories are relatively small in graph terms, it’s a reasonable solution.<p>Locations and objects are nodes and movement and location of objects are edges. Nodes and edges both can have dynamic properties.<p>I’ve also noticed the lack of graph structures in programming languages, so this article was very enlightening.</div><br/><div id="39598809" class="c"><input type="checkbox" id="c-39598809" checked=""/><div class="controls bullet"><span class="by">jonahss</span><span>|</span><a href="#39596693">parent</a><span>|</span><a href="#39592880">next</a><span>|</span><label class="collapse" for="c-39598809">[-]</label><label class="expand" for="c-39598809">[1 more]</label></div><br/><div class="children"><div class="content">sounds neat. link?</div><br/></div></div></div></div><div id="39592880" class="c"><input type="checkbox" id="c-39592880" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39596693">prev</a><span>|</span><label class="collapse" for="c-39592880">[-]</label><label class="expand" for="c-39592880">[2 more]</label></div><br/><div class="children"><div class="content">This is a good article and I endorse it.<p>I would supplement it with the observation that when I was a younger programmer, like many people, I considered &quot;generic&quot; or &quot;flexible&quot; a positive when describing a library or framework. I have come to see it as generally negative, especially when the developer&#x27;s summary puts these adjectives or something similar front and center.<p>Let me show you the most flexible possible Javascript framework. This will look like a joke, but it&#x27;s not. It fits perfectly into an HN post. The most flexible possible JS framework is simply:<p><pre><code>    eval
</code></pre>
Similarly flexible frameworks exist for dynamic scripting languages. For static languages one must invoke the entire compiler as the framework. Of course, if you think about it hard enough, I&#x27;m doing that for dynamic languages here too, it just has a snappier representation for dynamic languages.<p>Frameworks and libraries provide their value precisely through limiting things, and then building on those limitations. Of course, the limitations must be well-chosen, to make what can be built on them interesting enough to pay for the limitations the framework chooses. But the essence of them are in their limitations. I start out from the get-go with the maximally flexible framework my language allows, which is itself the language, and the additional framework needs to make limitations on my code in order to do anything useful.<p>(A problem when framework designers don&#x27;t understand this is that they make a series of little incorrect design decisions that can often add up to a real pain. For instance, if I were to design a web framework that took over some amount of routing from the user, I would still leave you the ability to claim some bit of the URL space and route it entirely out of my framework, because I understand that my framework is based around limitations and you may need to expose a URL to something that can&#x27;t work under those limitations. But someone who doesn&#x27;t realize that frameworks intrinsically involve limitations might fail to give that callout because they can&#x27;t imagine that someone might have a problem that their framework is not &quot;flexible&quot; and &quot;generic&quot; enough to handle. Imagine a CRUD framework, even a very good one, but I need to offer an endpoint based on streaming server events in the same URL space, which is intrinsically foreign to the CRUD framework&#x27;s concept of page loads. This is just one example; real frameworks designed without this understanding will make dozens or hundreds of such little mistakes.)<p>Graphs have the same problem. It seems like they&#x27;re so flexible and generic that they ought to be more used and more useful. But that&#x27;s precisely what kills them. Even if you nail down the problem to exactly one representation, they still don&#x27;t fit. For instance I have a great need for data structures that don&#x27;t admit cycles, but if all I have is a graph, imposing that limitation from a coding perspective is a real challenge. Mathematically it&#x27;s trivial, I just say &quot;and this graph has no cycles&quot; <i>et voila</i> [1], there are no cycles, but in code I need to enforce that somehow and there&#x27;s no trivial solution to that.<p>Another way of viewing graphs is that we <i>do</i> work in graphs all the time, precisely because everything in RAM can be seen as a graph. GC algorithms even generally work by viewing everything in very raw graphy terms. It just turns out the API you&#x27;d expect to work over a graph just isn&#x27;t useful in the general sense when applied to everything in a programming language&#x27;s memory space. It seems like it ought to be, but it just isn&#x27;t. It may seem like it would be great to have a set of employees and extract their names and then look that up into another database etc. etc. with a general graph query language or something, but it turns out the special considerations at each layer make it so that what the general purpose programming language is already doing is actually generally better. The details at each layer matter.<p>I like the metaphor of architecture astronautics and have often discussed &quot;the 30,000 foot view&quot; versus the view on the ground here on HN, and to my mind the key to the metaphor isn&#x27;t the nerdery of being an astronaut or the difficulty. The key is that when you get high up, everything looks the same. It feels like graphs ought to be awesome when you&#x27;re looking down at the entire computing landscape from metaphorical low Earth orbit. But down in the trenches, the local concerns overwhelm that viewpoint... and this is real. This is not just because we all suck or we don&#x27;t try hard enough or we just Don&#x27;t Get It. It&#x27;s real. The architecture astronaut is just wrong in this case. It&#x27;s not even a beautiful vision this world isn&#x27;t good enough to manifest or any such conciliatory thing... it&#x27;s just wrong. It is good to write good code and reduce the amount of bespoke details to be considered. The programming community has made great progress there and there is still great opportunity to do more. But there are an awful, awful lot of details in the world, and the world being detailed is fundamental.<p>[1]: Or if you are, like me, kinda a fan of surprise stringed instrument attacks, <i>et viola</i>.</div><br/><div id="39595549" class="c"><input type="checkbox" id="c-39595549" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39592880">parent</a><span>|</span><label class="collapse" for="c-39595549">[-]</label><label class="expand" for="c-39595549">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  when I was a younger programmer, like many people, I considered &quot;generic&quot; or &quot;flexible&quot; a positive when describing a library or framework [...]<p>I&#x27;ve come to prefer what I call &quot;design for deletion&quot;: Most of those long-term &quot;flexibility someday&quot; needs are best-met by making sure the inflexible modules or flows can be clearly identified and ripped out for replacement. This leads to a certain kind of decoupling, although with a higher tolerance for coupling that can kept in check by static analysis.<p>This is a contrast to my days of youthful exuberance where I thought I could solve the problem by making my work <i>extensible</i> or <i>customizable</i>. No, I cannot make the immortal program, so I should focus on making a mortal one which can pass gracefully.</div><br/></div></div></div></div></div></div></div></div></div></body></html>