<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694509266329" as="style"/><link rel="stylesheet" href="styles.css?v=1694509266329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/unix/BourneShellObscureErrorRoots">The roots of an obscure Bourne shell error message</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>r4um</span> | <span>31 comments</span></div><br/><div><div id="37475496" class="c"><input type="checkbox" id="c-37475496" checked=""/><div class="controls bullet"><span class="by">pinusc</span><span>|</span><a href="#37475306">next</a><span>|</span><label class="collapse" for="c-37475496">[-]</label><label class="expand" for="c-37475496">[9 more]</label></div><br/><div class="children"><div class="content">Excellent explanation! However, I would disagree both that there isn&#x27;t an easy fix and that each of the decisions are sensible.<p>If the syntax to temporarily set variables was different, say using : instead of =, or requiring some delimiter between assignments and operations, or maybe enclosing the statement in braces (something like: {foo=bar; echo $foo}...) to delimit temporary assignments would have been reasonable alternatives, perhaps even more readable than this. Or having the sntax disallow `foo=`, requiring, say, `foo=null` or `foo=&#x27;&#x27;`, which are both more explicit, or even `unset foo`. These are more sensible individual choices, and that&#x27;s partly because they&#x27;re more explicit and partly because they avoid a (now) common error. I&#x27;d argue good language design needs to think slightly bigger picture than &quot;individually not catastrophic&quot; choices. Sh is littered with a myriad of small bad choices, which add up to a language that&#x27;s hard to code or script without bugs. Nowadays with shellcheck it&#x27;s easier, but it shouldn&#x27;t be necessary. The consensus is: it&#x27;s a scripting language, it shouldn&#x27;t be used for complex stuff. But if it was a slightly better scripting language, it _could_ be used more safely for larger or more complex scripts.<p>The truth is that it&#x27;s an ancient language, its (bad) syntax is set in stone, and there&#x27;s nothing we can do about it except slowly move to alternatives. Sad that there&#x27;s nothing established to take its place (Perl is read-only, python is not good enough as unix glue, everything else is too obscure).<p>I know how and love to write in bash. But oh god was it painful to learn</div><br/><div id="37476587" class="c"><input type="checkbox" id="c-37476587" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#37475496">parent</a><span>|</span><a href="#37476131">next</a><span>|</span><label class="collapse" for="c-37476587">[-]</label><label class="expand" for="c-37476587">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think your comment fairly represents the situation.<p>Bash is not _just_ a scripting language, it&#x27;s also (and primarily) a shell.<p>That means it needs to be good at both interactive REPL-style usage _and_ at simple scripting.<p>Being a shell implies that it has to be exceptionally succinct and flexible about executing programs and manipulating environment variables.<p>In that light, your comparison with Python and Perl don&#x27;t make much sense.<p>Would you enjoy replacing:<p><pre><code>    $ cd &#x2F;tmp
    $ ls -l
</code></pre>
with:<p><pre><code>    $ os.chdir(&#x27;&#x2F;tmp&#x27;)
    $ subprocess.run([&#x27;ls&#x27;, &#x27;-l&#x27;])
</code></pre>
I guess not.<p>Shells will always be a different breed of languages. Bash is maybe not the best at what it could be, but it&#x27;s not the end of the world either.<p>The example in the article is a bit silly to be honest. I think the result is kind of obvious for anyone half bash litterate.</div><br/><div id="37477025" class="c"><input type="checkbox" id="c-37477025" checked=""/><div class="controls bullet"><span class="by">pinusc</span><span>|</span><a href="#37475496">root</a><span>|</span><a href="#37476587">parent</a><span>|</span><a href="#37477467">next</a><span>|</span><label class="collapse" for="c-37477025">[-]</label><label class="expand" for="c-37477025">[1 more]</label></div><br/><div class="children"><div class="content">You are right to point out that in my comment I talk about bash in terms of a language rather than just a shell; but I did have its shell-nature in mind while writing it, and in fact your example is exactly what I meant when I said that python is not good enough unix glue... there&#x27;s a certain level of script complexity where python starts making more sense than bash, but because the ergonomics of calling other programs (unix glue!) or building pipelines are pretty poor, that threshold is pretty high.<p>Some of bash syntax makes perfect sense in the context of a shell-but-also-scripting-language. Some of it makes perfect sense in the context of &quot;everything is a string&quot;, which I think is an absolutely great abstraction---for example, unset variables being equivalent to empty strings. Other parts are just jargony, and might make the life of a few experienced shell-slingers slightly easier, while complicating many users&#x27; interactions with the shell.<p>I suppose part of my point is that succintness here comes at the cost of readability. A shell could very well be _slightly_ more verbose than bash (say, requiring assignment operators to have two sides, so `foo=&#x27;&#x27;` instead of `foo=`), still be plenty succint as a shell, but being slightly more explicit and readable in a scripting context. `foo=&#x27;&#x27;` is only _two_ characters longer than `foo=`, and is already-implemented behavior. But the `foo=` syntax has certainly confused generations of unix users... that&#x27;s just not a good tradeoff imo. I feel pretty comfortable calling this lack of foresight, or suboptimal design; that&#x27;s not bashing (!) the language or its creators, rather, merely noting that we can do better.<p>And if you don&#x27;t think so... check out fish shell! It&#x27;s a beloved and successful shell, and they forgo the use of = entirely (instead, you have to `set foo bar`, which is more verbose and a lot more explicit!)<p>Edit: fish does allow `foo=bar echo $foo` to override variables, so they actually manage to keep bash ergonomics while avoiding mistakes while scripting.</div><br/></div></div><div id="37477467" class="c"><input type="checkbox" id="c-37477467" checked=""/><div class="controls bullet"><span class="by">paddim8</span><span>|</span><a href="#37475496">root</a><span>|</span><a href="#37476587">parent</a><span>|</span><a href="#37477025">prev</a><span>|</span><a href="#37476937">next</a><span>|</span><label class="collapse" for="c-37477467">[-]</label><label class="expand" for="c-37477467">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m working on a shell language that combines these things.<p>You can write things like: let column = du -h | str::column 0
echo(column[1..3])</div><br/></div></div><div id="37476937" class="c"><input type="checkbox" id="c-37476937" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#37475496">root</a><span>|</span><a href="#37476587">parent</a><span>|</span><a href="#37477467">prev</a><span>|</span><a href="#37476131">next</a><span>|</span><label class="collapse" for="c-37476937">[-]</label><label class="expand" for="c-37476937">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That means it needs to be good at both interactive REPL-style usage _and_ at simple scripting.<p>The creators of powershell obviously were of a different opinion</div><br/><div id="37477438" class="c"><input type="checkbox" id="c-37477438" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#37475496">root</a><span>|</span><a href="#37476937">parent</a><span>|</span><a href="#37476131">next</a><span>|</span><label class="collapse" for="c-37477438">[-]</label><label class="expand" for="c-37477438">[1 more]</label></div><br/><div class="children"><div class="content">It is fairly good for interactive usage, there are aliases for common commands, case-insensitivity, tab completion etc.</div><br/></div></div></div></div></div></div><div id="37476131" class="c"><input type="checkbox" id="c-37476131" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37475496">parent</a><span>|</span><a href="#37476587">prev</a><span>|</span><a href="#37475898">next</a><span>|</span><label class="collapse" for="c-37476131">[-]</label><label class="expand" for="c-37476131">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or maybe enclosing the statement in braces (something like: {foo=bar; echo $foo}...) to delimit temporary assignments<p>As long as you don&#x27;t need to get anything out of it, it&#x27;s a bit heavy but dropping to a subshell works like that:<p><pre><code>  $ (foo=bar; echo $foo)
  bar
  $ echo $foo</code></pre></div><br/></div></div><div id="37475898" class="c"><input type="checkbox" id="c-37475898" checked=""/><div class="controls bullet"><span class="by">__float</span><span>|</span><a href="#37475496">parent</a><span>|</span><a href="#37476131">prev</a><span>|</span><a href="#37475306">next</a><span>|</span><label class="collapse" for="c-37475898">[-]</label><label class="expand" for="c-37475898">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I know how and love to write in bash. But oh god was it painful to learn<p>This is very well said :)<p>&gt; Sad that there&#x27;s nothing established to take its place (Perl is read-only, python is not good enough as unix glue, everything else is too obscure).<p>Is there anything notable? Either particularly well designed, or just popular? I think I&#x27;ve only ever heard of Oil (<a href="https:&#x2F;&#x2F;oilshell.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;oilshell.org</a>)</div><br/><div id="37476474" class="c"><input type="checkbox" id="c-37476474" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#37475496">root</a><span>|</span><a href="#37475898">parent</a><span>|</span><a href="#37475306">next</a><span>|</span><label class="collapse" for="c-37476474">[-]</label><label class="expand" for="c-37476474">[1 more]</label></div><br/><div class="children"><div class="content">Ruby has very ergonomic and pleasant UX for doing the sorts of things you typically want to do in bash scripts IMO.</div><br/></div></div></div></div></div></div><div id="37475306" class="c"><input type="checkbox" id="c-37475306" checked=""/><div class="controls bullet"><span class="by">bdamm</span><span>|</span><a href="#37475496">prev</a><span>|</span><a href="#37476694">next</a><span>|</span><label class="collapse" for="c-37475306">[-]</label><label class="expand" for="c-37475306">[1 more]</label></div><br/><div class="children"><div class="content">And today I learned about shellcheck.<p>Thank you for that fun and concise trip into shell evaluation :)</div><br/></div></div><div id="37476694" class="c"><input type="checkbox" id="c-37476694" checked=""/><div class="controls bullet"><span class="by">jlv2</span><span>|</span><a href="#37475306">prev</a><span>|</span><a href="#37477423">next</a><span>|</span><label class="collapse" for="c-37476694">[-]</label><label class="expand" for="c-37476694">[4 more]</label></div><br/><div class="children"><div class="content">Sorry, that&#x27;s not obscure!</div><br/><div id="37477369" class="c"><input type="checkbox" id="c-37477369" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37476694">parent</a><span>|</span><a href="#37477423">next</a><span>|</span><label class="collapse" for="c-37477369">[-]</label><label class="expand" for="c-37477369">[3 more]</label></div><br/><div class="children"><div class="content">...not if you live and breathe shell scripts, no. But most people coming from other programming languages first need to understand the concept of whitespace being significant, and even if they do, it&#x27;s easy to insert a space accidentally. In this case, if you get this error message, you would probably first look at the part in the &quot;$(...)&quot; (which, you think, is the only thing resembling a &quot;command&quot; on that line) and wonder why on earth it doesn&#x27;t work, overlooking the problem slightly to the left of it.</div><br/><div id="37477610" class="c"><input type="checkbox" id="c-37477610" checked=""/><div class="controls bullet"><span class="by">naniwaduni</span><span>|</span><a href="#37476694">root</a><span>|</span><a href="#37477369">parent</a><span>|</span><a href="#37477949">next</a><span>|</span><label class="collapse" for="c-37477610">[-]</label><label class="expand" for="c-37477610">[1 more]</label></div><br/><div class="children"><div class="content">I would expect to look at the part inside the $(), probably attempt to run it to confirm that it&#x27;s working at all, and be a bit curious as to why the error message implies I was trying to run the <i>output</i> of that command!</div><br/></div></div><div id="37477949" class="c"><input type="checkbox" id="c-37477949" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#37476694">root</a><span>|</span><a href="#37477369">parent</a><span>|</span><a href="#37477610">prev</a><span>|</span><a href="#37477423">next</a><span>|</span><label class="collapse" for="c-37477949">[-]</label><label class="expand" for="c-37477949">[1 more]</label></div><br/><div class="children"><div class="content">I remember yaml and python also having syntactically relevant whitespaces.</div><br/></div></div></div></div></div></div><div id="37477423" class="c"><input type="checkbox" id="c-37477423" checked=""/><div class="controls bullet"><span class="by">cmeacham98</span><span>|</span><a href="#37476694">prev</a><span>|</span><a href="#37475715">next</a><span>|</span><label class="collapse" for="c-37477423">[-]</label><label class="expand" for="c-37477423">[2 more]</label></div><br/><div class="children"><div class="content">Can I suggest a simple fix that doesn&#x27;t involve changing behavior at all but probably improves the lives of the many users who hit this?<p>Just add an additional line to the error message for lines that look like this pattern:<p><pre><code>    sh: 107: command not found
    Did you mean &quot;AVAR=$(... | wc -l)&quot;?</code></pre></div><br/><div id="37477787" class="c"><input type="checkbox" id="c-37477787" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#37477423">parent</a><span>|</span><a href="#37475715">next</a><span>|</span><label class="collapse" for="c-37477787">[-]</label><label class="expand" for="c-37477787">[1 more]</label></div><br/><div class="children"><div class="content">I feel like that approach would create much effort to do properly. I.e. to be consistent, you would add a lot of such messages, and that would add a lot of complexity to the overall code base.</div><br/></div></div></div></div><div id="37475715" class="c"><input type="checkbox" id="c-37475715" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37477423">prev</a><span>|</span><a href="#37476693">next</a><span>|</span><label class="collapse" for="c-37475715">[-]</label><label class="expand" for="c-37475715">[10 more]</label></div><br/><div class="children"><div class="content">This does not seem obscure to me at all.  Having learned about C from reading djb&#x27;s programs, I write programs that read their arguments from environmental variables.  (See djbdns for example.)  When I run one of these programs it&#x27;s common to set variables on the command line, e.g.,<p><pre><code>   echo https:&#x2F;&#x2F;example.com|Connection=keep-alive yy025|nc -vvn 127.127 80
</code></pre>
yy025 sets the HTTP Connection header according to the value of the corresponding environmental variable.  If I want to send a POST request I set the variable httpMethod to POST. The address 127.0.0.127 is a TLS forward proxy.  Original netcat allows one to type 127.127 without the zeros.<p>Using djb&#x27;s envdir utility, one can put a selection of different HTTP headers into a directory so that there&#x27;s no need to type them on the command line.<p><pre><code>    cd &#x2F;path&#x2F;to&#x2F;dir
    echo close &gt; connection
    echo aplication&#x2F;x-www-form-urlencoded &gt; content-type
    echo id=123\;key=xyz &gt; cookie
    echo 19 &gt; content-length
    echo POST &gt; httpMethod
    echo &#x2F;api&#x2F;whatever &gt; path
    echo &quot;{ \&quot;key\&quot;: \&quot;value\&quot; }&quot; &gt; post-data
    cd
    echo https:&#x2F;&#x2F;example.com \
    |if cd &#x2F;path&#x2F;to&#x2F;dir;envdir . yy025;then 
    cat post-data;fi \
    |nc -vvn 127.127 80
</code></pre>
It&#x27;s strange to me to see this author use printenv instead of set (a built-in) to display Bourne shell environmental variables.  As someone who uses Bourne shell every day and on a variety of computers, I never use printenv.  On the smaller systems I make, I do not include printenv in the userland.<p>The use of fgrep to match a single word in all caps is also strange.<p>Maybe I am just missing some UNIX wisdom here.  If so, please disregard this comment.<p>From the article<p><pre><code>  $ export FRED=value
  $ printenv | fgrep FRED
  FRED=value
  $ FRED=
  $ printenv | fgrep FRED
  FRED=
  $ unset FRED
  $ printenv | fgrep FRED
  $ # ie, no output from printenv
</code></pre>
Without using printenv or grep -F (in shell script &#x2F;bin&#x2F;fgrep)<p><pre><code>  $ export FRED=value
  $ set|grep FRED
  FRED=&#x27;value&#x27;
  FRED=
  $ set|grep FRED
  FRED=&#x27;&#x27;
  $ unset FRED
  $ set|grep FRED
  $ # ie, no output from set</code></pre></div><br/><div id="37476429" class="c"><input type="checkbox" id="c-37476429" checked=""/><div class="controls bullet"><span class="by">siebenmann</span><span>|</span><a href="#37475715">parent</a><span>|</span><a href="#37476509">next</a><span>|</span><label class="collapse" for="c-37476429">[-]</label><label class="expand" for="c-37476429">[4 more]</label></div><br/><div class="children"><div class="content">In this case, one reason to use printenv is that it is an external command, and so it is clearly and unambiguously seeing (and reporting) whatever the Bourne shell would export into the environment for a real command. In this specific case, it appears that set does not report such single-command variables (whether or not they have a value, eg &#x27;FRED=barney set | grep FRED&#x27;).<p>(I am the author of the linked-to entry.)</div><br/><div id="37476553" class="c"><input type="checkbox" id="c-37476553" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37475715">root</a><span>|</span><a href="#37476429">parent</a><span>|</span><a href="#37476509">next</a><span>|</span><label class="collapse" for="c-37476553">[-]</label><label class="expand" for="c-37476553">[3 more]</label></div><br/><div class="children"><div class="content">Missing semicolon.<p><pre><code>   FRED=barney; set | grep FRED
</code></pre>
Also there is no need for grep, nevermind grep -F (fgrep), if using printenv.<p><pre><code>   FRED=barney printenv FRED
</code></pre>
Without semicolon<p><pre><code>   sh -c &#x27;FRED=barney set|grep FRED&#x27;

   echo &#x27;FRED=barney set|grep ^FRED&#x27;|sh</code></pre></div><br/><div id="37476615" class="c"><input type="checkbox" id="c-37476615" checked=""/><div class="controls bullet"><span class="by">_TwoFinger</span><span>|</span><a href="#37475715">root</a><span>|</span><a href="#37476553">parent</a><span>|</span><a href="#37476632">next</a><span>|</span><label class="collapse" for="c-37476615">[-]</label><label class="expand" for="c-37476615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Missing semicolon.<p>It&#x27;s not missing. PP is making a point about &quot;single-command variables.&quot;</div><br/></div></div><div id="37476632" class="c"><input type="checkbox" id="c-37476632" checked=""/><div class="controls bullet"><span class="by">dcassett</span><span>|</span><a href="#37475715">root</a><span>|</span><a href="#37476553">parent</a><span>|</span><a href="#37476615">prev</a><span>|</span><a href="#37476509">next</a><span>|</span><label class="collapse" for="c-37476632">[-]</label><label class="expand" for="c-37476632">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Missing semicolon.<p>If you add a semicolon then FRED is no longer a single command variable (it persists)<p>&gt; on NetBSD, one can do this<p>Linux also does the expected thing:<p>$ FRED=barney printenv FRED<p>barney</div><br/></div></div></div></div></div></div><div id="37475899" class="c"><input type="checkbox" id="c-37475899" checked=""/><div class="controls bullet"><span class="by">zerocrates</span><span>|</span><a href="#37475715">parent</a><span>|</span><a href="#37476509">prev</a><span>|</span><a href="#37476088">next</a><span>|</span><label class="collapse" for="c-37475899">[-]</label><label class="expand" for="c-37475899">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people are probably just not familiar with the single-command envvar syntax, and of people that do know it some of them probably don&#x27;t know the syntax for unsetting.<p>So it&#x27;s just not immediately obvious to many why a simple extra space is a problem at all, and why it&#x27;s this specific error. It can also just generally be hard to see past what you <i>intended</i> to write to what you actually <i>did</i> and how that will be parsed.</div><br/></div></div><div id="37476088" class="c"><input type="checkbox" id="c-37476088" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37475715">parent</a><span>|</span><a href="#37475899">prev</a><span>|</span><a href="#37476089">next</a><span>|</span><label class="collapse" for="c-37476088">[-]</label><label class="expand" for="c-37476088">[2 more]</label></div><br/><div class="children"><div class="content">&quot;printenv&quot; (or just &quot;env&quot;, the one I habitually use) shows only environment variables, not all available functions and variables like &quot;set&quot; does.<p>But otherwise yeah, I also don&#x27;t see this as obscure at all.  Was expecting something confusing when, say, fiddling with arrays or something.</div><br/><div id="37476163" class="c"><input type="checkbox" id="c-37476163" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37475715">root</a><span>|</span><a href="#37476088">parent</a><span>|</span><a href="#37476089">next</a><span>|</span><label class="collapse" for="c-37476163">[-]</label><label class="expand" for="c-37476163">[1 more]</label></div><br/><div class="children"><div class="content">Good point about functions.  Normally it&#x27;s not something I notice because I&#x27;m not using Bash.  But every once a while I use set in Bash and I&#x27;m blasted with a slew of preloaded functions.</div><br/></div></div></div></div></div></div><div id="37476693" class="c"><input type="checkbox" id="c-37476693" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37475715">prev</a><span>|</span><a href="#37475998">next</a><span>|</span><label class="collapse" for="c-37476693">[-]</label><label class="expand" for="c-37476693">[3 more]</label></div><br/><div class="children"><div class="content">For what it’s worth, the explanation of the error was obvious to me after seeing the code for a few seconds. So maybe my point is… don’t worry if stuff like that in shell programming seems obscure to you; it becomes much less obscure with practice (and along the way you do learn genuine lessons about unix-like operating systems, not just shell programming details).</div><br/><div id="37477316" class="c"><input type="checkbox" id="c-37477316" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37476693">parent</a><span>|</span><a href="#37475998">next</a><span>|</span><label class="collapse" for="c-37477316">[-]</label><label class="expand" for="c-37477316">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that most people (me included) don&#x27;t <i>want</i> to become proficient in writing shell scripts, but they need to write a script (or, God forbid, extend and&#x2F;or debug a script someone else wrote) from time to time. At least I do it so rarely that I forget most things from one time to the next. I understand that Bash is the way it is because of historical reasons, but maybe some less obscure  error messages would be nice? ShellCheck is all nice and well, but Bash itself being more helpful would be better. Or, no, please don&#x27;t tell me that other tools rely on these error messages and therefore they can&#x27;t be changed?</div><br/><div id="37477455" class="c"><input type="checkbox" id="c-37477455" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37476693">root</a><span>|</span><a href="#37477316">parent</a><span>|</span><a href="#37475998">next</a><span>|</span><label class="collapse" for="c-37477455">[-]</label><label class="expand" for="c-37477455">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe some less obscure error messages would be nice?<p>Bear with me here! The error message is exactly what we’d expect in this situation. The author literally tried to use the string “107” as an executable name, and bash says ‘I can’t find an executable named “107”’.<p>It’s impossible to be a good software engineer in 2023 without understanding the basics of shell programming. And the absolute number one thing to understand about bash and related shell languages is that “everything is text”. I know one hears people saying that a lot, but you’ve got to really internalize what it means. bash is just constructing strings of text and doing stuff with it. It barely has any non-string data structures.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>