<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689757254306" as="style"/><link rel="stylesheet" href="styles.css?v=1689757254306"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://maciej.codes/2022-06-09-local-async.html">Local Async Executors and Why They Should be the Default (Rust)</a> <span class="domain">(<a href="https://maciej.codes">maciej.codes</a>)</span></div><div class="subtext"><span>rklaehn</span> | <span>47 comments</span></div><br/><div><div id="36783687" class="c"><input type="checkbox" id="c-36783687" checked=""/><div class="controls bullet"><span class="by">namjh</span><span>|</span><a href="#36783324">next</a><span>|</span><label class="collapse" for="c-36783687">[-]</label><label class="expand" for="c-36783687">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Making things thread safe for runtime-agnostic utilities like WebSocket is yet another price we pay for making everything multi-threaded by default. The standard way of doing what I&#x27;m doing in my code above would be to spawn one of the loops on a separate background task, which could land on a separate thread, meaning we must do all that synchronization to manage reading and writing to a socket from different threads for no good reason.<p>Why so? Libraries like quinn[1] define &quot;no IO&quot; crate to define runtime-agnostic protocol implementation. In this way we won&#x27;t suffer by forcing ourselves using synchronization primitives.<p>Also, IMO it&#x27;s relatively easy to use Send-bounded future in non-Send(i.o.w. single-threaded) runtime environment, but it&#x27;s almost impossible to do opposite. Ecosystem users can freely use single threaded async runtime, but ecosystem providers should not. If you want every users to only use single threaded runtime, it&#x27;s a major loss for the Rust ecosystem.<p>Typechecked Send&#x2F;Sync bounds are one of the holy grails that Rust provides. Albeit it&#x27;s overkill to use multithreaded async runtimes for most users, we should not abandon them because it opens an opportunity for high-end users who might seek Rust for their high-performance backends.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;quinn-rs&#x2F;quinn">https:&#x2F;&#x2F;github.com&#x2F;quinn-rs&#x2F;quinn</a></div><br/></div></div><div id="36783324" class="c"><input type="checkbox" id="c-36783324" checked=""/><div class="controls bullet"><span class="by">runiq</span><span>|</span><a href="#36783687">prev</a><span>|</span><a href="#36783522">next</a><span>|</span><label class="collapse" for="c-36783324">[-]</label><label class="expand" for="c-36783324">[6 more]</label></div><br/><div class="children"><div class="content">This is bad editorializing. You&#x27;re putting words in the author&#x27;s mouth that cannot even be found on that page.<p>Don&#x27;t do that.</div><br/><div id="36783386" class="c"><input type="checkbox" id="c-36783386" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#36783324">parent</a><span>|</span><a href="#36783405">prev</a><span>|</span><a href="#36783522">next</a><span>|</span><label class="collapse" for="c-36783386">[-]</label><label class="expand" for="c-36783386">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if HN should have a rule that prohibits editorializing.</div><br/><div id="36783443" class="c"><input type="checkbox" id="c-36783443" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36783324">root</a><span>|</span><a href="#36783386">parent</a><span>|</span><a href="#36783452">next</a><span>|</span><label class="collapse" for="c-36783443">[-]</label><label class="expand" for="c-36783443">[2 more]</label></div><br/><div class="children"><div class="content">Not sure if this is facetious, but HN <i>does</i> have a rule that prohibits editorializing. From the Guidelines: &quot;Otherwise please use the original title, unless it is misleading or linkbait; don&#x27;t editorialize.&quot;</div><br/><div id="36783697" class="c"><input type="checkbox" id="c-36783697" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#36783324">root</a><span>|</span><a href="#36783443">parent</a><span>|</span><a href="#36783452">next</a><span>|</span><label class="collapse" for="c-36783697">[-]</label><label class="expand" for="c-36783697">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div></div></div><div id="36783452" class="c"><input type="checkbox" id="c-36783452" checked=""/><div class="controls bullet"><span class="by">voxelghost</span><span>|</span><a href="#36783324">root</a><span>|</span><a href="#36783386">parent</a><span>|</span><a href="#36783443">prev</a><span>|</span><a href="#36783522">next</a><span>|</span><label class="collapse" for="c-36783452">[-]</label><label class="expand" for="c-36783452">[1 more]</label></div><br/><div class="children"><div class="content">Maybe HN should auto-pull title from URL, and then add the posters title as a form of &quot;subtitle&#x2F;comment&quot;</div><br/></div></div></div></div></div></div><div id="36783522" class="c"><input type="checkbox" id="c-36783522" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#36783324">prev</a><span>|</span><a href="#36783280">next</a><span>|</span><label class="collapse" for="c-36783522">[-]</label><label class="expand" for="c-36783522">[6 more]</label></div><br/><div class="children"><div class="content">I find all the async stuff in Rust incredibly ugly, cumbersome, and its one of the biggest reasons I prefer C++, still. C++ lets me just write single- or multithreaded code, because none of the dependencies force their `async` stuff on me. Yeah, its up to me to ensure things are synchronized, but I&#x27;d rather do that than try to figure out how to get some dependency that isnt meant to use async to work in some async move closure.</div><br/><div id="36783556" class="c"><input type="checkbox" id="c-36783556" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783522">parent</a><span>|</span><a href="#36783554">next</a><span>|</span><label class="collapse" for="c-36783556">[-]</label><label class="expand" for="c-36783556">[3 more]</label></div><br/><div class="children"><div class="content">I can see where you are coming from. But you can do most things purely in sync rust.<p>There are sync rust multithreading libs like rayon that are a joy to use, and there are even blocking versions of popular http libraries like reqwest: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;latest&#x2F;reqwest&#x2F;blocking&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;latest&#x2F;reqwest&#x2F;blocking&#x2F;index.html</a><p>They are usually doing some ugly stuff internally to make this work, but as a pure library user you don&#x27;t have to care.<p>If you want to write something small that e.g. pulls some data via http, performs some computation, then pushes the result, it is totally possible to do this fully in sync rust.<p>And if you are writing a highly concurrent web server, looking into async might not be the worst idea.</div><br/><div id="36783655" class="c"><input type="checkbox" id="c-36783655" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#36783522">root</a><span>|</span><a href="#36783556">parent</a><span>|</span><a href="#36783554">next</a><span>|</span><label class="collapse" for="c-36783655">[-]</label><label class="expand" for="c-36783655">[2 more]</label></div><br/><div class="children"><div class="content">Having written a lot of async and sync rust, and having both components interact with one another, calling async stuff from a sync context isn&#x27;t even that ugly these days. But maybe it&#x27;s stockholm syndrome.</div><br/><div id="36783698" class="c"><input type="checkbox" id="c-36783698" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783522">root</a><span>|</span><a href="#36783655">parent</a><span>|</span><a href="#36783554">next</a><span>|</span><label class="collapse" for="c-36783698">[-]</label><label class="expand" for="c-36783698">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s OK but not great.<p>Ideally library authors should provide a sync facade so people don&#x27;t have to deal with this, like reqwest does.</div><br/></div></div></div></div></div></div><div id="36783554" class="c"><input type="checkbox" id="c-36783554" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36783522">parent</a><span>|</span><a href="#36783556">prev</a><span>|</span><a href="#36783543">next</a><span>|</span><label class="collapse" for="c-36783554">[-]</label><label class="expand" for="c-36783554">[1 more]</label></div><br/><div class="children"><div class="content">Eh, in that case, you can also just write single or multithreaded Rust code, entirely ignoring async Rust. I do. And multithreaded Rust is much more pleasant experience than multithreaded C++.<p>Which dependency is forcing async Rust on you? Alternatives are usually available.</div><br/></div></div><div id="36783543" class="c"><input type="checkbox" id="c-36783543" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36783522">parent</a><span>|</span><a href="#36783554">prev</a><span>|</span><a href="#36783280">next</a><span>|</span><label class="collapse" for="c-36783543">[-]</label><label class="expand" for="c-36783543">[1 more]</label></div><br/><div class="children"><div class="content">Your dependencies are what you choose them to be, you are not forced to use async libraries if you don&#x27;t want to.</div><br/></div></div></div></div><div id="36783280" class="c"><input type="checkbox" id="c-36783280" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#36783522">prev</a><span>|</span><a href="#36783586">next</a><span>|</span><label class="collapse" for="c-36783280">[-]</label><label class="expand" for="c-36783280">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Yes the RwLock and mpsc comes from Tokio and lets you .await instead of blocking a thread, but these are not async primitives, these are multi-threading synchronization primitives.<p>The only reason all this async stuff even exists is because we want concurrency. We want to say &quot;while this one task waits for I&#x2F;O, this other task will do stuff&quot;. So it&#x27;s not too surprising to me that an intro to async would include synchronization primitives. Those primitives aren&#x27;t really &quot;thread&quot;-specific if by thread you mean OS thread. When you do async like this, you&#x27;re basically re-implementing OS threads in user space.</div><br/><div id="36783349" class="c"><input type="checkbox" id="c-36783349" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783280">parent</a><span>|</span><a href="#36783312">next</a><span>|</span><label class="collapse" for="c-36783349">[-]</label><label class="expand" for="c-36783349">[1 more]</label></div><br/><div class="children"><div class="content">Multi threading and concurrency are not the same. You can have a very high performance server that handles thousands of requests concurrently on a single thread. That&#x27;s how node&#x2F;deno do things.<p>But the way to do things in async rust is that if you want concurrency you also have to use multithreading. At least that is what you see in all the examples and docs.<p>As soon as you require your futures to be Send you have to use not just concurrency but full blown multithreading primitives.<p>So e.g. you have to use Arc&lt;RwLock&lt;...&gt;&gt; where a Rc&lt;RefCell&lt;...&gt;&gt; would suffice.<p>Now, to be fair, both futures and tokio support local futures. There is boxed_local (<a href="https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html#method.boxed_local" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;future&#x2F;trait.FutureEx...</a>) and tokio-util even comes with an optional local task pool (<a href="https:&#x2F;&#x2F;docs.rs&#x2F;tokio-util&#x2F;latest&#x2F;tokio_util&#x2F;task&#x2F;struct.LocalPoolHandle.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;tokio-util&#x2F;latest&#x2F;tokio_util&#x2F;task&#x2F;struct.Loc...</a>).<p>But these features are hidden and certainly not promoted in examples and documentation.</div><br/></div></div><div id="36783312" class="c"><input type="checkbox" id="c-36783312" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36783280">parent</a><span>|</span><a href="#36783349">prev</a><span>|</span><a href="#36783444">next</a><span>|</span><label class="collapse" for="c-36783312">[-]</label><label class="expand" for="c-36783312">[1 more]</label></div><br/><div class="children"><div class="content">Async&#x2F;await is green threads with better scoping and syntactic sugar.<p>Which lets be honest, is something green threads desperately needed.</div><br/></div></div><div id="36783480" class="c"><input type="checkbox" id="c-36783480" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36783280">parent</a><span>|</span><a href="#36783444">prev</a><span>|</span><a href="#36783347">next</a><span>|</span><label class="collapse" for="c-36783480">[-]</label><label class="expand" for="c-36783480">[1 more]</label></div><br/><div class="children"><div class="content">Waiting for I&#x2F;O does not require using multiple threads. You can have the same thread do other things until I&#x2F;O is ready.</div><br/></div></div><div id="36783347" class="c"><input type="checkbox" id="c-36783347" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#36783280">parent</a><span>|</span><a href="#36783480">prev</a><span>|</span><a href="#36783586">next</a><span>|</span><label class="collapse" for="c-36783347">[-]</label><label class="expand" for="c-36783347">[1 more]</label></div><br/><div class="children"><div class="content">I think the article&#x27;s point is that if you&#x27;re doing single-threaded concurrency then you don&#x27;t (or at least might not) need synchronization primitives. If you&#x27;re writing a Node script, for example, then you don&#x27;t have to worry about two callbacks trying to modify the same variable at the same time because you know that there is only one thread of execution.</div><br/></div></div></div></div><div id="36783586" class="c"><input type="checkbox" id="c-36783586" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36783280">prev</a><span>|</span><a href="#36783217">next</a><span>|</span><label class="collapse" for="c-36783586">[-]</label><label class="expand" for="c-36783586">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you know anything about asynchronous sockets it should be that multi-threading a socket doesn&#x27;t actually yield you more requests &#x2F; second, and it can actually lower it...<p>Re-read this a few times, and I&#x27;m fairly convinced it is not generally true. The author is also being a bit confusing about what exactly he means by &quot;socket&quot; here. Because while it&#x27;s true that multi-threading over a server socket (e.g. the one that binds to the port when you launch the server) will not yield performance gains, multi-threading clients (that have their <i>own</i> sockets, including file descriptors) definitely <i>will</i>. That&#x27;s the whole point of nginx thread pools[1]. Note that nginx does zero &quot;CPU-bound&quot; work, it literally just serves files.<p>Node&#x2F;Deno being single-threaded is purely a limitation of Javascript. Tomcat, Jetty, etc. are all multi-threaded. I&#x27;m a bit tired, so I can&#x27;t comment on the rest of the post in detail, but this was a bit of a red flag.<p>[1] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;denji&#x2F;8359866" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;denji&#x2F;8359866</a></div><br/></div></div><div id="36783217" class="c"><input type="checkbox" id="c-36783217" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36783586">prev</a><span>|</span><a href="#36783513">next</a><span>|</span><label class="collapse" for="c-36783217">[-]</label><label class="expand" for="c-36783217">[2 more]</label></div><br/><div class="children"><div class="content"><i>&quot;If you write regular synchronous Rust code, unless you have a really good reason, you don&#x27;t just start with a thread-pool. You write single-threaded code until you find a place where threads can help you, and then you parallelize it, [..]&quot;</i><p>I cannot agree more with that. As someone who&#x27;s done a good deal of Java in my day job, I can tell you a thing or two about spawning threads willy-nilly. At least it is easier to avoid in Rust, but I&#x27;d still prefer it the other way round: opt-in, instead of opt-out.</div><br/></div></div><div id="36783513" class="c"><input type="checkbox" id="c-36783513" checked=""/><div class="controls bullet"><span class="by">dpc_01234</span><span>|</span><a href="#36783217">prev</a><span>|</span><a href="#36783033">next</a><span>|</span><label class="collapse" for="c-36783513">[-]</label><label class="expand" for="c-36783513">[2 more]</label></div><br/><div class="children"><div class="content">Async is and probably will always be less usable than blocking Rust. It is a very, very useful mode of operating when you really need two of its biggest benefits: lightweight cooperative concurrency and task cancellation, but it comes at a big usability cost.<p>Rust software should use async tactically - in places where it is needed. Unfortunately handling http, which is a large part of many applications is actually a place where async has benefits. But if you plan to run your http behind nginx anyway (for TLS termination) even there using blocking http server might be a good idea.<p>&gt; If you write regular synchronous Rust code, unless you have a really good reason, you don&#x27;t just start with a thread-pool. You write single-threaded code until you find a place where threads can help you, and then you parallelize it,<p>I disagree with this one. When you work on a software project you should have the basic architecture figured out already, and main part of that is breaking your software into structurally parallel parts that can work independently. Adding ad-hoc parallelism after the fact works only for small scale things and will lead to rather accidental concurrency architecture.<p>Then for each part (groups of threads), figure out if it *needs* async. Between each part you&#x27;d communicate via channels or some shared data structures that rather easily can be made to work with both async&#x2F;blocking code.<p>So e.g. an async http server, benefits from lightweight async concurrency, makes rpc-like channel-based calls to blocking IO &#x2F; CPU&#x2F;bussiness-logic intense workers (that don&#x27;t benefit from async) where it makes sense. Each part is written in the best &quot;type of Rust for its use-case&quot;.<p>Or if you need ability to cancel certain computations inside the larger framework (e.g. simulating agents etc.) you might want to nest async executor inside a blocking code.<p>Note: there&#x27;s a lot of types of program archetypes out there (CRUD, ETL, data-intensive, embedded, frontent SPA, native mobile app) and I&#x27;ve noticed that many people are boxed in the type they happen to work on. CRUD applications (which are very common) are often 90% http handling-based and it might make sense to write them whole in async Rust.</div><br/><div id="36783614" class="c"><input type="checkbox" id="c-36783614" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36783513">parent</a><span>|</span><a href="#36783033">next</a><span>|</span><label class="collapse" for="c-36783614">[-]</label><label class="expand" for="c-36783614">[1 more]</label></div><br/><div class="children"><div class="content">Your CRUD web application server almost certainly doesn&#x27;t need async Rust. Using a blocking HTTP server is not &quot;might be a good idea&quot;, it simply is a good idea.<p>I recommend Rouille for this: <a href="https:&#x2F;&#x2F;github.com&#x2F;tomaka&#x2F;rouille">https:&#x2F;&#x2F;github.com&#x2F;tomaka&#x2F;rouille</a>. In case you are worried about performance, check the benchmark. Blocking Rouille is faster than builtin async server in Node.js.</div><br/></div></div></div></div><div id="36783033" class="c"><input type="checkbox" id="c-36783033" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36783513">prev</a><span>|</span><a href="#36783552">next</a><span>|</span><label class="collapse" for="c-36783033">[-]</label><label class="expand" for="c-36783033">[8 more]</label></div><br/><div class="children"><div class="content">Multithreading, why does everyone always do it wrong?<p>One of life&#x27;s big questions.</div><br/><div id="36783121" class="c"><input type="checkbox" id="c-36783121" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783033">parent</a><span>|</span><a href="#36783096">next</a><span>|</span><label class="collapse" for="c-36783121">[-]</label><label class="expand" for="c-36783121">[2 more]</label></div><br/><div class="children"><div class="content">I think rust does it right in many cases. Raw rust multithreading is a pleasure to use, and some libraries like rayon are extremely unobtrusive.<p>That is why I am somewhat unhappy with the state of async rust. It does not yet have the quality and unobtrusiveness of sync rust libraries like rayon.</div><br/><div id="36783206" class="c"><input type="checkbox" id="c-36783206" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#36783033">root</a><span>|</span><a href="#36783121">parent</a><span>|</span><a href="#36783096">next</a><span>|</span><label class="collapse" for="c-36783206">[-]</label><label class="expand" for="c-36783206">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I just recently picked up rust and rayon is so awesome. It is great to be able to instantly parallelize an iterator.</div><br/></div></div></div></div><div id="36783096" class="c"><input type="checkbox" id="c-36783096" checked=""/><div class="controls bullet"><span class="by">worldsavior</span><span>|</span><a href="#36783033">parent</a><span>|</span><a href="#36783121">prev</a><span>|</span><a href="#36783123">next</a><span>|</span><label class="collapse" for="c-36783096">[-]</label><label class="expand" for="c-36783096">[1 more]</label></div><br/><div class="children"><div class="content">Because there are no actual good sources to implement async&#x2F;multi threading programs.</div><br/></div></div><div id="36783123" class="c"><input type="checkbox" id="c-36783123" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36783033">parent</a><span>|</span><a href="#36783096">prev</a><span>|</span><a href="#36783231">next</a><span>|</span><label class="collapse" for="c-36783123">[-]</label><label class="expand" for="c-36783123">[3 more]</label></div><br/><div class="children"><div class="content">Pray tell, what&#x27;s the objective right way?</div><br/><div id="36783155" class="c"><input type="checkbox" id="c-36783155" checked=""/><div class="controls bullet"><span class="by">monsieurbanana</span><span>|</span><a href="#36783033">root</a><span>|</span><a href="#36783123">parent</a><span>|</span><a href="#36783233">next</a><span>|</span><label class="collapse" for="c-36783155">[-]</label><label class="expand" for="c-36783155">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s saying nobody has found it yet</div><br/></div></div><div id="36783233" class="c"><input type="checkbox" id="c-36783233" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#36783033">root</a><span>|</span><a href="#36783123">parent</a><span>|</span><a href="#36783155">prev</a><span>|</span><a href="#36783231">next</a><span>|</span><label class="collapse" for="c-36783233">[-]</label><label class="expand" for="c-36783233">[1 more]</label></div><br/><div class="children"><div class="content">99% of the cases: don&#x27;t. 1%: very carefully.</div><br/></div></div></div></div><div id="36783231" class="c"><input type="checkbox" id="c-36783231" checked=""/><div class="controls bullet"><span class="by">Thoeu388</span><span>|</span><a href="#36783033">parent</a><span>|</span><a href="#36783123">prev</a><span>|</span><a href="#36783552">next</a><span>|</span><label class="collapse" for="c-36783231">[-]</label><label class="expand" for="c-36783231">[1 more]</label></div><br/><div class="children"><div class="content">Redis nailed multithreading :)</div><br/></div></div></div></div><div id="36783552" class="c"><input type="checkbox" id="c-36783552" checked=""/><div class="controls bullet"><span class="by">distcs</span><span>|</span><a href="#36783033">prev</a><span>|</span><a href="#36783389">next</a><span>|</span><label class="collapse" for="c-36783552">[-]</label><label class="expand" for="c-36783552">[3 more]</label></div><br/><div class="children"><div class="content">Can a mod fix the title please? The poster of this story has editorialized the title so bad that it has no connection with the actual title.<p>Actual title: Local Async Executors and Why They Should be the Default<p>Posted title: Async rust – are we doing it all wrong?<p>Really? Why this kind of terrible editorializing?</div><br/><div id="36783575" class="c"><input type="checkbox" id="c-36783575" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#36783552">parent</a><span>|</span><a href="#36783389">next</a><span>|</span><label class="collapse" for="c-36783575">[-]</label><label class="expand" for="c-36783575">[2 more]</label></div><br/><div class="children"><div class="content">I agree that this could be less editorialized, but the actual title doesn&#x27;t include &#x27;Rust&#x27;, so that needs to be added at least.</div><br/><div id="36783631" class="c"><input type="checkbox" id="c-36783631" checked=""/><div class="controls bullet"><span class="by">distcs</span><span>|</span><a href="#36783552">root</a><span>|</span><a href="#36783575">parent</a><span>|</span><a href="#36783389">next</a><span>|</span><label class="collapse" for="c-36783631">[-]</label><label class="expand" for="c-36783631">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Perhaps we can have a syntax to declare what is editorialized. We already add &quot;(YEAR)&quot; and &quot;[pdf]&quot; and &quot;[video]&quot;. We could &quot;[Rust]&quot; or other keywords like that about the post missing from the title?</div><br/></div></div></div></div></div></div><div id="36783389" class="c"><input type="checkbox" id="c-36783389" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36783552">prev</a><span>|</span><a href="#36783373">next</a><span>|</span><label class="collapse" for="c-36783389">[-]</label><label class="expand" for="c-36783389">[1 more]</label></div><br/><div class="children"><div class="content">the title should be &quot;Local Async Executors and Why They Should be the Default (Rust)&quot;</div><br/></div></div><div id="36783373" class="c"><input type="checkbox" id="c-36783373" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#36783389">prev</a><span>|</span><a href="#36783418">next</a><span>|</span><label class="collapse" for="c-36783373">[-]</label><label class="expand" for="c-36783373">[1 more]</label></div><br/><div class="children"><div class="content">For me the biggest issue with Async is the management of multiple dependent async calls. It has some weird thing going on and I am not sure which pattern to use exactly. Some functions expect exactly same async fn signature some not and I am not sure why and which one to use.</div><br/></div></div><div id="36783418" class="c"><input type="checkbox" id="c-36783418" checked=""/><div class="controls bullet"><span class="by">ikekkdcjkfke</span><span>|</span><a href="#36783373">prev</a><span>|</span><a href="#36783281">next</a><span>|</span><label class="collapse" for="c-36783418">[-]</label><label class="expand" for="c-36783418">[2 more]</label></div><br/><div class="children"><div class="content">In C# i always wondered why they couldn&#x27;t hide the async&#x2F;await logic for most cases. I never need to fire off two IO futures at the same time, so just make the thread do other stuff if i&#x27;m waiting for IO feedback, don&#x27;t make me type out async&#x2F;await in all impacted functions, let the compiler figure out when it can process other stuff</div><br/><div id="36783510" class="c"><input type="checkbox" id="c-36783510" checked=""/><div class="controls bullet"><span class="by">peheje</span><span>|</span><a href="#36783418">parent</a><span>|</span><a href="#36783281">next</a><span>|</span><label class="collapse" for="c-36783510">[-]</label><label class="expand" for="c-36783510">[1 more]</label></div><br/><div class="children"><div class="content">the use of async and await is a design decision that requires knowledge of the program&#x27;s logic and desired behavior. It&#x27;s not just a matter of compiler optimization, and that&#x27;s why the compiler can&#x27;t automatically figure out where to use these keywords.<p>Suppose we have a service where users place orders, and we need to:<p>1. Save the order.
2. Deduct items from inventory.
3. Send a confirmation email.<p>If we perform these operations asynchronously but sequentially using `await`:<p>```csharp
public async Task PlaceOrder(Order order)
{
    await SaveOrder(order);
    await DeductItems(order);
    await SendConfirmationEmail(order);
}
```<p>They happen in the correct order, which is important.<p>But, if the compiler removed the `await`, causing all three operations to start at the same time:<p>```csharp
public async Task PlaceOrder(Order order)
{
    SaveOrder(order);
    DeductItems(order);
    SendConfirmationEmail(order);
}
```<p>This could lead to issues like sending the confirmation email before the order is saved, showing the importance of `await`. The compiler cannot optimize this without understanding the business logic.</div><br/></div></div></div></div><div id="36783281" class="c"><input type="checkbox" id="c-36783281" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36783418">prev</a><span>|</span><a href="#36783032">next</a><span>|</span><label class="collapse" for="c-36783281">[-]</label><label class="expand" for="c-36783281">[2 more]</label></div><br/><div class="children"><div class="content">While the article mostly focuses on the cognitive cost, which I deeply sympathize with, I do wonder about the runtime performance cost. Are there any good benchmarks actually quantifying the impact of all that extra thread-safety and the hoops that it adds? I&#x27;m not asking simply due personal interest in seeing the numbers, but also because if we want to steer the community towards this non-threadsafe direction it would help to have material to back the ideas and I suspect Rust community would be more responsive to complaints about perf than cognitive cost.</div><br/><div id="36783398" class="c"><input type="checkbox" id="c-36783398" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783281">parent</a><span>|</span><a href="#36783032">next</a><span>|</span><label class="collapse" for="c-36783398">[-]</label><label class="expand" for="c-36783398">[1 more]</label></div><br/><div class="children"><div class="content">Anecdotal evidence, but many large rust async code bases perform significantly better if you are using a single threaded runtime vs. a multithreaded runtime.<p>Here is an issue for the quinn crate that implements QUIC: <a href="https:&#x2F;&#x2F;github.com&#x2F;quinn-rs&#x2F;quinn&#x2F;issues&#x2F;1433">https:&#x2F;&#x2F;github.com&#x2F;quinn-rs&#x2F;quinn&#x2F;issues&#x2F;1433</a><p>We have had very similar experiences when developing <a href="https:&#x2F;&#x2F;github.com&#x2F;n0-computer&#x2F;iroh">https:&#x2F;&#x2F;github.com&#x2F;n0-computer&#x2F;iroh</a><p>And this is with quinn still carrying around the synchronization primitives to make everything Send.<p>Another piece of anecdotal evidence: the functional collection library <a href="https:&#x2F;&#x2F;github.com&#x2F;bodil&#x2F;im-rs">https:&#x2F;&#x2F;github.com&#x2F;bodil&#x2F;im-rs</a> comes in two flavours: one using Arc and one using Rc. The reason for this is that you get a significant performance increase by using Rc (where manipulating the refcount is just an integer inc&#x2F;dec) vs Arc where manipulating the refcount needs to be an atomic op.<p>Last but not least - often making futures Send requires you to box your futures. Send and lifetimes just does not play well together. Do something like this:<p><pre><code>  trait Foo {
    type OpFut&lt;&#x27;a&gt;: Future&lt;Output = ()&gt; + &#x27;a;
    fn op(&amp;self) -&gt; Self::OpFut&lt;&#x27;_&gt;
  }
</code></pre>
This is what eventually you would want something like async_trait to desugar to. Use the above in a Send context, and you get a completely undecipherable higher-ranked lifetime error. So you are back to boxing all futures.</div><br/></div></div></div></div><div id="36783032" class="c"><input type="checkbox" id="c-36783032" checked=""/><div class="controls bullet"><span class="by">evanrelf</span><span>|</span><a href="#36783281">prev</a><span>|</span><a href="#36783339">next</a><span>|</span><label class="collapse" for="c-36783032">[-]</label><label class="expand" for="c-36783032">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Posted on June 9, 2022</div><br/><div id="36783083" class="c"><input type="checkbox" id="c-36783083" checked=""/><div class="controls bullet"><span class="by">rklaehn</span><span>|</span><a href="#36783032">parent</a><span>|</span><a href="#36783339">next</a><span>|</span><label class="collapse" for="c-36783083">[-]</label><label class="expand" for="c-36783083">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, it is old. But I only found it recently and did not see a discussion of it yet.<p>I found this quite interesting. I love rust, but async rust always seems almost like a different language.<p>Lifetimes become much more complex and much less useful, you use Box and Arc way too much. It seems like you would be better off if everything was heap allocated.<p>Working with local futures brings back some of the things I love about rust, but it is certainly not prominently featured in libraries like tokio and the entire async ecosystem.</div><br/><div id="36783237" class="c"><input type="checkbox" id="c-36783237" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#36783032">root</a><span>|</span><a href="#36783083">parent</a><span>|</span><a href="#36783339">next</a><span>|</span><label class="collapse" for="c-36783237">[-]</label><label class="expand" for="c-36783237">[2 more]</label></div><br/><div class="children"><div class="content">&gt; posted on June 9, 2022<p>&gt; this is old<p>???</div><br/></div></div></div></div></div></div><div id="36783339" class="c"><input type="checkbox" id="c-36783339" checked=""/><div class="controls bullet"><span class="by">hoangnguyenvu</span><span>|</span><a href="#36783032">prev</a><span>|</span><label class="collapse" for="c-36783339">[-]</label><label class="expand" for="c-36783339">[1 more]</label></div><br/><div class="children"><div class="content">reason?</div><br/></div></div></div></div></div></div></div></body></html>