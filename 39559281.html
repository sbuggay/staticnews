<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709370077097" as="style"/><link rel="stylesheet" href="styles.css?v=1709370077097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cloudinary.com/blog/jpeg-xl-and-the-pareto-front">JPEG XL and the Pareto Front</a> <span class="domain">(<a href="https://cloudinary.com">cloudinary.com</a>)</span></div><div class="subtext"><span>botanical</span> | <span>281 comments</span></div><br/><div><div id="39560871" class="c"><input type="checkbox" id="c-39560871" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#39559647">next</a><span>|</span><label class="collapse" for="c-39560871">[-]</label><label class="expand" for="c-39560871">[43 more]</label></div><br/><div class="children"><div class="content">Pay attention to just how good WebP is at _lossless_ comparison though!<p>I&#x27;ve always thought that one as flying under the radar. Most get stuck on WebP not offering tangible enough benefits (or even worse) over MozJPEG encoding, but WebP _lossless_ is absolutely fantastic for performance&#x2F;speed! PNG or even OptiPNG is far worse. And very well supported online now, and leaving the horrible lossless AVIF in the dust too of course.</div><br/><div id="39560900" class="c"><input type="checkbox" id="c-39560900" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39561453">next</a><span>|</span><label class="collapse" for="c-39560900">[-]</label><label class="expand" for="c-39560900">[14 more]</label></div><br/><div class="children"><div class="content">Lossless WebP is very good indeed. The main problem is that it is not very future-proof since it only supports 8-bit. For SDR images that&#x27;s fine, but for HDR this is a fundamental limitation that is about as bad as GIF&#x27;s limitation to 256 colors.</div><br/><div id="39566305" class="c"><input type="checkbox" id="c-39566305" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39560900">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39566305">[-]</label><label class="expand" for="c-39566305">[6 more]</label></div><br/><div class="children"><div class="content">Lossless WebP is also stuck with a low axis limit of 16383.<p>It is a good format when you can use it, but JPEG XL almost always compresses better anyway, and lacks color space and dimension limits.</div><br/><div id="39569544" class="c"><input type="checkbox" id="c-39569544" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39566305">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39569544">[-]</label><label class="expand" for="c-39569544">[5 more]</label></div><br/><div class="children"><div class="content">This limit didn&#x27;t exist in my first version as well as the 4 GB limit. These were artificially introduced to &quot;match&quot; the properties of lossy WebP. We could have done better there.</div><br/><div id="39569735" class="c"><input type="checkbox" id="c-39569735" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39569544">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39569735">[-]</label><label class="expand" for="c-39569735">[4 more]</label></div><br/><div class="children"><div class="content">Were you involved in creating WebP? If so that&#x27;s super cool! Why would they want to match webp&#x27;s lossy compression though? To make it more uniform? And do you know why lossy WebP had such a limitation in the first place? Thank you!</div><br/><div id="39569861" class="c"><input type="checkbox" id="c-39569861" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39569735">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39569861">[-]</label><label class="expand" for="c-39569861">[3 more]</label></div><br/><div class="children"><div class="content">I designed the WebP lossless format, wrote the spec, and implemented the first encoder.<p>The constraint was in WebP lossy to facilitate exact compatibility with VP8 specification and hoping that it would allow hardware decoding and encoding of WebP images using VP8 hardware.<p>Hardware encoding and decoding were never used, but the limitation stuck.<p>There was no serious plan to do hardware lossless, but the constraint was copied for &quot;reducing confusion&quot;.<p>I didn&#x27;t and don&#x27;t like it that much as more PNG images couldn&#x27;t be represented as WebP lossless as a result of that.</div><br/><div id="39569943" class="c"><input type="checkbox" id="c-39569943" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39569861">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39569943">[-]</label><label class="expand" for="c-39569943">[2 more]</label></div><br/><div class="children"><div class="content">Wow, that really sucks. I appreciate the explanation as well as your frustration with it.<p>My desktop had a mixture of PNG and WebP files solely because of this limitation. I use the past tense because they&#x27;ve now all been converted to JPEG XL lossless.</div><br/><div id="39570275" class="c"><input type="checkbox" id="c-39570275" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39569943">parent</a><span>|</span><a href="#39561736">next</a><span>|</span><label class="collapse" for="c-39570275">[-]</label><label class="expand" for="c-39570275">[1 more]</label></div><br/><div class="children"><div class="content">Another group of incompatibility with PNG was 16 bit coding. I had a plan to add it as simply sending two 8 bit images where the second image containing the 8 least significant bits would be predicted to be the same as the first. That way it would not be perfect, but it would be 100x better than how PNG deals with it. WebP had another plan for layers and tiles that never realized, and as a consequence WebP is stuck at 8 bits.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39561736" class="c"><input type="checkbox" id="c-39561736" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39560900">parent</a><span>|</span><a href="#39566305">prev</a><span>|</span><a href="#39568997">next</a><span>|</span><label class="collapse" for="c-39561736">[-]</label><label class="expand" for="c-39561736">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I didn&#x27;t know this and I agree this is a fairly big issue and increasingly so over time. I think smartphones in particular hastened the demand for HDR quite a bit, what was once a premium&#x2F;enthusiast feature you only had to explicitly buy into.</div><br/><div id="39570125" class="c"><input type="checkbox" id="c-39570125" checked=""/><div class="controls bullet"><span class="by">fluidcruft</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561736">parent</a><span>|</span><a href="#39568997">next</a><span>|</span><label class="collapse" for="c-39570125">[-]</label><label class="expand" for="c-39570125">[1 more]</label></div><br/><div class="children"><div class="content">HDR is also important for medical imaging applications (which have been moving to web)</div><br/></div></div></div></div><div id="39568997" class="c"><input type="checkbox" id="c-39568997" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39560900">parent</a><span>|</span><a href="#39561736">prev</a><span>|</span><a href="#39564770">next</a><span>|</span><label class="collapse" for="c-39568997">[-]</label><label class="expand" for="c-39568997">[2 more]</label></div><br/><div class="children"><div class="content">For things where you actually care about lossless you probably also don&#x27;t care about HDR.<p>HDR is (or can be) good for video &amp; photography, but it&#x27;s absolutely ass for UI.<p>Besides, you can just throw a gainmap approach at it if you really care. Works great with jpeg, and gainmaps are being added to heif &amp; avif as well, no reason jpegxl couldn&#x27;t get the same treatment. The lack of &quot;true 10-bit&quot; is significantly less impactful at that point</div><br/><div id="39569588" class="c"><input type="checkbox" id="c-39569588" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39568997">parent</a><span>|</span><a href="#39564770">next</a><span>|</span><label class="collapse" for="c-39569588">[-]</label><label class="expand" for="c-39569588">[1 more]</label></div><br/><div class="children"><div class="content">Gainmaps don&#x27;t solve 8-bit mach banding. If anything you get more banding: two bandings, one banding from each of the two 8-bit fields multiplied together.<p>Gainmaps &quot;solve&quot; the problem of computing a local tone mapping by declaring that it needs to be done at server side or at image creation time rather than at viewing time.<p>My prediction: Gainmaps are going to be too complex of a solution for us as a community and we are going to find something else that is easier. Perhaps we could end up standardizing a small set of local tone mapping algorithms applied at viewing time.</div><br/></div></div></div></div><div id="39564770" class="c"><input type="checkbox" id="c-39564770" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39560900">parent</a><span>|</span><a href="#39568997">prev</a><span>|</span><a href="#39561453">next</a><span>|</span><label class="collapse" for="c-39564770">[-]</label><label class="expand" for="c-39564770">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t ran across websites that serves up HDR images, I am not sure I would notice the difference.  WebP seems appropriately named and optimized for image delivery on the web.<p>Maybe you are thinking of high bit depth for archival use?  I can see some use cases there where 8-bit is not sufficient, though personally I store high bit depth images in whatever raw format was produced by my camera (which is usually some variant of TIFF).</div><br/><div id="39565859" class="c"><input type="checkbox" id="c-39565859" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39564770">parent</a><span>|</span><a href="#39561453">next</a><span>|</span><label class="collapse" for="c-39565859">[-]</label><label class="expand" for="c-39565859">[2 more]</label></div><br/><div class="children"><div class="content">8-bit can have banding even without &quot;HDR&quot;. Definitely not enough. 10 bit HDR video is becoming more common, and popularity for images will follow. Adoption is hampered by the fact that Windows has bad HDR support, but it all works plenty well on macOS and mobile platforms.</div><br/><div id="39567544" class="c"><input type="checkbox" id="c-39567544" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39565859">parent</a><span>|</span><a href="#39561453">next</a><span>|</span><label class="collapse" for="c-39567544">[-]</label><label class="expand" for="c-39567544">[1 more]</label></div><br/><div class="children"><div class="content">unfortunately linux HDR is pretty much completely absent. That said, Wayland  slowly looks like it&#x27;s getting there.</div><br/></div></div></div></div></div></div></div></div><div id="39561453" class="c"><input type="checkbox" id="c-39561453" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39560900">prev</a><span>|</span><a href="#39561198">next</a><span>|</span><label class="collapse" for="c-39561453">[-]</label><label class="expand" for="c-39561453">[12 more]</label></div><br/><div class="children"><div class="content">An issue with lossless WebP is that it only supports (A)RGB and encodes grayscale via hacks that aren&#x27;t as good as simply supporting monochrome.<p>If you compress a whole manga, PNG (via oxipng, optipng is basically deprecated) is still the way to go.<p>Another something not mentioned in here is that lossless JPEG2000 can be surprisingly good and fast on photographic content.</div><br/><div id="39561776" class="c"><input type="checkbox" id="c-39561776" checked=""/><div class="controls bullet"><span class="by">out_of_protocol</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561453">parent</a><span>|</span><a href="#39561602">next</a><span>|</span><label class="collapse" for="c-39561776">[-]</label><label class="expand" for="c-39561776">[5 more]</label></div><br/><div class="children"><div class="content">Just tried it on random manga page<p>- OxiPNG - 730k<p>- webp lossless max effort - 702k<p>- avif lossless max effort - 2.54MB (yay!)<p>- jpegxl lossless max effort - 506k (winner!)</div><br/><div id="39562398" class="c"><input type="checkbox" id="c-39562398" checked=""/><div class="controls bullet"><span class="by">Andrex</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561776">parent</a><span>|</span><a href="#39561602">next</a><span>|</span><label class="collapse" for="c-39562398">[-]</label><label class="expand" for="c-39562398">[4 more]</label></div><br/><div class="children"><div class="content">Probably depends on the manga itself. Action manga probably don&#x27;t compress as well as more dialogue-heavy works.</div><br/><div id="39562982" class="c"><input type="checkbox" id="c-39562982" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562398">parent</a><span>|</span><a href="#39561602">next</a><span>|</span><label class="collapse" for="c-39562982">[-]</label><label class="expand" for="c-39562982">[3 more]</label></div><br/><div class="children"><div class="content">I would, at a first blush, disagree with that characterization? Dialogue equals more fine-grained strokes and more individual, independent “zones” to encode.</div><br/><div id="39566901" class="c"><input type="checkbox" id="c-39566901" checked=""/><div class="controls bullet"><span class="by">Andrex</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562982">parent</a><span>|</span><a href="#39564742">next</a><span>|</span><label class="collapse" for="c-39566901">[-]</label><label class="expand" for="c-39566901">[1 more]</label></div><br/><div class="children"><div class="content">Now I&#x27;m really curious. If anyone has more time than me they could do some sample compressions and I&#x27;d be interested in the results.</div><br/></div></div><div id="39564742" class="c"><input type="checkbox" id="c-39564742" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562982">parent</a><span>|</span><a href="#39566901">prev</a><span>|</span><a href="#39561602">next</a><span>|</span><label class="collapse" for="c-39564742">[-]</label><label class="expand" for="c-39564742">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if the text would be consistent enough for JXL&#x27;s &quot;patches&quot; feature to work well.</div><br/></div></div></div></div></div></div></div></div><div id="39561602" class="c"><input type="checkbox" id="c-39561602" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561453">parent</a><span>|</span><a href="#39561776">prev</a><span>|</span><a href="#39561198">next</a><span>|</span><label class="collapse" for="c-39561602">[-]</label><label class="expand" for="c-39561602">[6 more]</label></div><br/><div class="children"><div class="content">IIRC the way you encode grayscale in WebP is a SUBTRACT_GREEN transform that makes the red and blue channel 0 everywhere, and then use a 1-element prefix code for R and B, so the R and B for each pixel take zero bits. Same idea with A for opaque images. Do you know why that&#x27;s not good enough?</div><br/><div id="39561750" class="c"><input type="checkbox" id="c-39561750" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561602">parent</a><span>|</span><a href="#39562366">next</a><span>|</span><label class="collapse" for="c-39561750">[-]</label><label class="expand" for="c-39561750">[3 more]</label></div><br/><div class="children"><div class="content">I made a mistake there with subtract green.<p>If I had just added 128 to the residuals, all remaining prediction arithmetic would have worked better and it would have given 1 % more density.<p>This is because most related arithmetic for predicting pixels is done in unsigned 8 bit arithmetic. Subtract green moves such predictions to often cross the 0 -&gt; 255 boundary, and then averaging, deltas etc make little sense and add to the entropy.</div><br/><div id="39561772" class="c"><input type="checkbox" id="c-39561772" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561750">parent</a><span>|</span><a href="#39562366">next</a><span>|</span><label class="collapse" for="c-39561772">[-]</label><label class="expand" for="c-39561772">[2 more]</label></div><br/><div class="children"><div class="content">Can you explain why?</div><br/><div id="39561805" class="c"><input type="checkbox" id="c-39561805" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561772">parent</a><span>|</span><a href="#39562366">next</a><span>|</span><label class="collapse" for="c-39561805">[-]</label><label class="expand" for="c-39561805">[1 more]</label></div><br/><div class="children"><div class="content">I edited the answer into the previous message for better flow.</div><br/></div></div></div></div></div></div><div id="39562366" class="c"><input type="checkbox" id="c-39562366" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561602">parent</a><span>|</span><a href="#39561750">prev</a><span>|</span><a href="#39561198">next</a><span>|</span><label class="collapse" for="c-39562366">[-]</label><label class="expand" for="c-39562366">[2 more]</label></div><br/><div class="children"><div class="content">Thankfully the following comment explains more than I know, I was speaking purely from empiric experience.</div><br/><div id="39562415" class="c"><input type="checkbox" id="c-39562415" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562366">parent</a><span>|</span><a href="#39561198">next</a><span>|</span><label class="collapse" for="c-39562415">[-]</label><label class="expand" for="c-39562415">[1 more]</label></div><br/><div class="children"><div class="content">Then you can&#x27;t know that any difference you see is because of how WebP encodes grayscale.</div><br/></div></div></div></div></div></div></div></div><div id="39561198" class="c"><input type="checkbox" id="c-39561198" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39561453">prev</a><span>|</span><a href="#39570490">next</a><span>|</span><label class="collapse" for="c-39561198">[-]</label><label class="expand" for="c-39561198">[6 more]</label></div><br/><div class="children"><div class="content">Thank you! &lt;3<p>WebP also has a near-lossless encoding mode based on lossless WebP specification that is mostly unadvertised, but should be preferred over real lossless in almost every use case. Often you can half the size without additional visible loss.</div><br/><div id="39562703" class="c"><input type="checkbox" id="c-39562703" checked=""/><div class="controls bullet"><span class="by">netol</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561198">parent</a><span>|</span><a href="#39563650">next</a><span>|</span><label class="collapse" for="c-39562703">[-]</label><label class="expand" for="c-39562703">[3 more]</label></div><br/><div class="children"><div class="content">Is this mode picked automatically in &quot;mixed&quot; mode?<p>Unfortunately, that option doesn&#x27;t seem to be available in gif2webp (I mostly use WebP for GIF images - as animated AVIF support is poor on browsers and that has an impact in interoperability)</div><br/><div id="39569585" class="c"><input type="checkbox" id="c-39569585" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562703">parent</a><span>|</span><a href="#39562992">next</a><span>|</span><label class="collapse" for="c-39569585">[-]</label><label class="expand" for="c-39569585">[1 more]</label></div><br/><div class="children"><div class="content">Not in gif2webp, no. It is available in img2webp as a global (not per-frame) option. It looks like when you pass it, it will be used for all lossless encoding, including when &quot;-mixed&quot; tries the lossless mode.</div><br/></div></div><div id="39562992" class="c"><input type="checkbox" id="c-39562992" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39562703">parent</a><span>|</span><a href="#39569585">prev</a><span>|</span><a href="#39563650">next</a><span>|</span><label class="collapse" for="c-39562992">[-]</label><label class="expand" for="c-39562992">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know</div><br/></div></div></div></div><div id="39563650" class="c"><input type="checkbox" id="c-39563650" checked=""/><div class="controls bullet"><span class="by">kurtextrem</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561198">parent</a><span>|</span><a href="#39562703">prev</a><span>|</span><a href="#39570490">next</a><span>|</span><label class="collapse" for="c-39563650">[-]</label><label class="expand" for="c-39563650">[2 more]</label></div><br/><div class="children"><div class="content">do you know why Jon didn&#x27;t compare near-lossless in the &quot;visually lossless&quot; part?</div><br/><div id="39569626" class="c"><input type="checkbox" id="c-39569626" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39563650">parent</a><span>|</span><a href="#39570490">next</a><span>|</span><label class="collapse" for="c-39569626">[-]</label><label class="expand" for="c-39569626">[1 more]</label></div><br/><div class="children"><div class="content">WebP near-lossless is very far in compression density against that kind of visually lossless. Still 2-3x more bits I think. No reason to compare. The near-lossless (at settings 60 and 80) is closer to pixel perfect no matter how much you zoom, whereas Jon&#x27;s &quot;visually lossless&quot; is what I&#x27;d rather call usual very high quality lossy without pixel precision guarantees.</div><br/></div></div></div></div></div></div><div id="39570490" class="c"><input type="checkbox" id="c-39570490" checked=""/><div class="controls bullet"><span class="by">ummonk</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39561198">prev</a><span>|</span><a href="#39564404">next</a><span>|</span><label class="collapse" for="c-39570490">[-]</label><label class="expand" for="c-39570490">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually shocked by how poorly the lossless versions of new image formats (AVIF and HEIC) perform compared to the venerable png.</div><br/></div></div><div id="39564404" class="c"><input type="checkbox" id="c-39564404" checked=""/><div class="controls bullet"><span class="by">kodabbb</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39570490">prev</a><span>|</span><a href="#39564399">next</a><span>|</span><label class="collapse" for="c-39564404">[-]</label><label class="expand" for="c-39564404">[5 more]</label></div><br/><div class="children"><div class="content">Looks like there are more savings coming on lossless AVIF: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;AV1&#x2F;comments&#x2F;1b3lh08&#x2F;comment&#x2F;kstmbru&#x2F;?utm_source=reddit&amp;utm_medium=web2x&amp;context=3" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;AV1&#x2F;comments&#x2F;1b3lh08&#x2F;comment&#x2F;kstmbr...</a></div><br/><div id="39565946" class="c"><input type="checkbox" id="c-39565946" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39564404">parent</a><span>|</span><a href="#39564399">next</a><span>|</span><label class="collapse" for="c-39565946">[-]</label><label class="expand" for="c-39565946">[4 more]</label></div><br/><div class="children"><div class="content">Also more savings will come for JPEG XL soon.<p>Possibly mostly focused on medium and low quality.</div><br/><div id="39566060" class="c"><input type="checkbox" id="c-39566060" checked=""/><div class="controls bullet"><span class="by">kodabbb</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39565946">parent</a><span>|</span><a href="#39564399">next</a><span>|</span><label class="collapse" for="c-39566060">[-]</label><label class="expand" for="c-39566060">[3 more]</label></div><br/><div class="children"><div class="content">will those require a bitstream change too?</div><br/><div id="39569644" class="c"><input type="checkbox" id="c-39569644" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39566060">parent</a><span>|</span><a href="#39566351">next</a><span>|</span><label class="collapse" for="c-39569644">[-]</label><label class="expand" for="c-39569644">[1 more]</label></div><br/><div class="children"><div class="content">No bitstream changes. In JPEG XL we have a 3-bit control field for each 8x8 square to guide which pixels participate in smoothing.<p>The heuristics (here <a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;lib&#x2F;jxl&#x2F;enc_ar_control_field.cc#L37">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;lib&#x2F;jxl&#x2F;enc_ar_co...</a>) for choosing that value are quite primitive and produces only two values: no smoothing and some smoothing (values 0 and 4).<p>If we replace those heuristics with a search that tries out which of the values is closest to the original, we should get better quality, especially at the lowest bitrates where smoothing is important.</div><br/></div></div><div id="39566351" class="c"><input type="checkbox" id="c-39566351" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39566060">parent</a><span>|</span><a href="#39569644">prev</a><span>|</span><a href="#39564399">next</a><span>|</span><label class="collapse" for="c-39566351">[-]</label><label class="expand" for="c-39566351">[1 more]</label></div><br/><div class="children"><div class="content">It is unlikely that there will be any bitstream changes in JPEG XL. There is still a lot of potential for encoder improvements within the current bitstream, both for lossy and for lossless.</div><br/></div></div></div></div></div></div></div></div><div id="39561609" class="c"><input type="checkbox" id="c-39561609" checked=""/><div class="controls bullet"><span class="by">Akronymus</span><span>|</span><a href="#39560871">parent</a><span>|</span><a href="#39566934">prev</a><span>|</span><a href="#39559647">next</a><span>|</span><label class="collapse" for="c-39561609">[-]</label><label class="expand" for="c-39561609">[2 more]</label></div><br/><div class="children"><div class="content">I really like webp. Sadly there&#x27;s still a lot of applications that dont work with it (looking at discord)</div><br/><div id="39562543" class="c"><input type="checkbox" id="c-39562543" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#39560871">root</a><span>|</span><a href="#39561609">parent</a><span>|</span><a href="#39559647">next</a><span>|</span><label class="collapse" for="c-39562543">[-]</label><label class="expand" for="c-39562543">[1 more]</label></div><br/><div class="children"><div class="content">It is ironic you said this because when I disabled webp in my browser because it had a huge security vulnerability, Discord was the only site which broke and didn&#x27;t immediately just serving me more reasonable image formats.</div><br/></div></div></div></div></div></div><div id="39559647" class="c"><input type="checkbox" id="c-39559647" checked=""/><div class="controls bullet"><span class="by">Modified3019</span><span>|</span><a href="#39560871">prev</a><span>|</span><a href="#39559747">next</a><span>|</span><label class="collapse" for="c-39559647">[-]</label><label class="expand" for="c-39559647">[8 more]</label></div><br/><div class="children"><div class="content">At the very low quality settings, it&#x27;s kinda remarkable how jpeg manages to to keep a sharper approximation of detail that preserves the holistic quality of the image better in spite of the obvious artifacts making it look like a mess of cubism when examined close. It&#x27;s basically converting the image into some kind of abstract art style.<p>Whereas jxl and avif just become blurry.</div><br/><div id="39559736" class="c"><input type="checkbox" id="c-39559736" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559647">parent</a><span>|</span><a href="#39559925">next</a><span>|</span><label class="collapse" for="c-39559736">[-]</label><label class="expand" for="c-39559736">[1 more]</label></div><br/><div class="children"><div class="content">It is because JPEG is given 0.5 bits per pixel, where JPEG XL and AVIF are given around 0.22 and 0.2.<p>These images attempt to be at equal level of distortion, not at equal compression.<p>Bpps are reported beside the images.<p>In practice, use of quality 65 is rare in the internet and only used at the lowest quality tier sites. Quality 75 seems to be usual poor quality and quality 85 the average. I use quality 94 yuv444 or better when I need to compress.</div><br/></div></div><div id="39559925" class="c"><input type="checkbox" id="c-39559925" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#39559647">parent</a><span>|</span><a href="#39559736">prev</a><span>|</span><a href="#39562503">next</a><span>|</span><label class="collapse" for="c-39559925">[-]</label><label class="expand" for="c-39559925">[1 more]</label></div><br/><div class="children"><div class="content">You refer to this? <a href="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;jon&#x2F;qp-low.png" rel="nofollow">https:&#x2F;&#x2F;res.cloudinary.com&#x2F;jon&#x2F;qp-low.png</a><p>Bitrates are in the left column, jpg low quality is the same size as jxl&#x2F;avif med-low quality (0.4bpp), so you should compare the bottom left picture to the top mid and right pictures.</div><br/></div></div><div id="39562503" class="c"><input type="checkbox" id="c-39562503" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559647">parent</a><span>|</span><a href="#39559925">prev</a><span>|</span><a href="#39561618">next</a><span>|</span><label class="collapse" for="c-39562503">[-]</label><label class="expand" for="c-39562503">[1 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s because JPEG is still using about twice as many bits per pixel, making the output size significantly larger.<p>Don&#x27;t get swept away by false comparisons, JXL and AVIF look significantly better if you give them twice as much filesize to work with as well.</div><br/></div></div><div id="39561618" class="c"><input type="checkbox" id="c-39561618" checked=""/><div class="controls bullet"><span class="by">mrob</span><span>|</span><a href="#39559647">parent</a><span>|</span><a href="#39562503">prev</a><span>|</span><a href="#39559710">next</a><span>|</span><label class="collapse" for="c-39561618">[-]</label><label class="expand" for="c-39561618">[3 more]</label></div><br/><div class="children"><div class="content">JPEG bitrates are higher, so all it means is that SSIMULACRA2 is the wrong metric for this test. It seems that SSIMULACRA2 heavily penalizes blocking artifacts but doesn&#x27;t much care about blur. I agree that the JPEG versions look better at the same SSIMULACRA2 score.</div><br/><div id="39563214" class="c"><input type="checkbox" id="c-39563214" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559647">root</a><span>|</span><a href="#39561618">parent</a><span>|</span><a href="#39562148">next</a><span>|</span><label class="collapse" for="c-39563214">[-]</label><label class="expand" for="c-39563214">[1 more]</label></div><br/><div class="children"><div class="content">Humans generally tend to prefer smoothing over visible blocking artifacts. This is especially true when a direct comparison to the original image is not possible. Of course different humans have different tastes, and some do prefer blocking over blur. SSIMULACRA2 is based on the aggregated opinions of many thousands of people. It does care more about blur than metrics like PSNR, but maybe not as much as you do.</div><br/></div></div><div id="39562148" class="c"><input type="checkbox" id="c-39562148" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559647">root</a><span>|</span><a href="#39561618">parent</a><span>|</span><a href="#39563214">prev</a><span>|</span><a href="#39559710">next</a><span>|</span><label class="collapse" for="c-39562148">[-]</label><label class="expand" for="c-39562148">[1 more]</label></div><br/><div class="children"><div class="content">Ideally one would use human ratings.<p>The author of the blog post did exactly that in a previous blog post:<p><a href="https:&#x2F;&#x2F;cloudinary.com&#x2F;labs&#x2F;cid22&#x2F;plots" rel="nofollow">https:&#x2F;&#x2F;cloudinary.com&#x2F;labs&#x2F;cid22&#x2F;plots</a><p>Human ratings are expensive and clumsy so people often use computed aka objective metrics, too.<p>The best OSS metrics today are butteraugli, dssim and simulacra. The author is using one of them. None of the codecs was optimized for that metrics except jpegli partially.</div><br/></div></div></div></div><div id="39559710" class="c"><input type="checkbox" id="c-39559710" checked=""/><div class="controls bullet"><span class="by">porker</span><span>|</span><a href="#39559647">parent</a><span>|</span><a href="#39561618">prev</a><span>|</span><a href="#39559747">next</a><span>|</span><label class="collapse" for="c-39559710">[-]</label><label class="expand" for="c-39559710">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that was my takeaway from this that JPEG keeps edge sharpness really well (e.g. the eyelashes) while the jxl and avif smooth all detail out of the image.</div><br/></div></div></div></div><div id="39559747" class="c"><input type="checkbox" id="c-39559747" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#39559647">prev</a><span>|</span><a href="#39559989">next</a><span>|</span><label class="collapse" for="c-39559747">[-]</label><label class="expand" for="c-39559747">[25 more]</label></div><br/><div class="children"><div class="content">I do not understand why this article focuses so much on encode speed, but for decode, which I believe represents 99% of usage in this web-connected world, give a cursory...<p>&gt; <i>Decode speed is not really a significant problem on modern computers, but it is interesting to take a quick look at the numbers.</i></div><br/><div id="39559782" class="c"><input type="checkbox" id="c-39559782" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39565047">next</a><span>|</span><label class="collapse" for="c-39559782">[-]</label><label class="expand" for="c-39559782">[13 more]</label></div><br/><div class="children"><div class="content">Anything more than 100 MB&#x2F;s is considered &quot;enough&quot; for the internet because at that point your bottleneck is no longer decoding. Most modern compression algorithms are asymmetric, that is, you can spend much more time on compression without significantly affecting the decompression performance, so it is indeed less significant once the base performance is achieved.</div><br/><div id="39560093" class="c"><input type="checkbox" id="c-39560093" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39559782">parent</a><span>|</span><a href="#39560306">next</a><span>|</span><label class="collapse" for="c-39560093">[-]</label><label class="expand" for="c-39560093">[1 more]</label></div><br/><div class="children"><div class="content">During the design process of pik&#x2F;jpeg xl I experimented on decode speed as a personal experience to have an opinion about this. I tried a special version of chrome that artificially throttled the image decoding. Once the decoding speed gets into the 20 megapixels per second the feeling coming from the additional speed was difficult to notice. I tried 2, 20 and 200 megapixels per second throttlings. This naturally depends on image sizes and uses too.<p>There was a much more easy to notice impact from progressive images and even sequential images displayed in a streaming manner during the download. As a rule of thumb, sequential top-to-bottom streaming feels 2x faster as a waiting rendering, and progressive feels 2x faster than sequential streaming.</div><br/></div></div><div id="39560306" class="c"><input type="checkbox" id="c-39560306" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39559782">parent</a><span>|</span><a href="#39560093">prev</a><span>|</span><a href="#39559891">next</a><span>|</span><label class="collapse" for="c-39560306">[-]</label><label class="expand" for="c-39560306">[8 more]</label></div><br/><div class="children"><div class="content">Decoding speed is important for battery time.<p>If a new format drains battery twice as fast, users don&#x27;t want it.</div><br/><div id="39561081" class="c"><input type="checkbox" id="c-39561081" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560306">parent</a><span>|</span><a href="#39561110">next</a><span>|</span><label class="collapse" for="c-39561081">[-]</label><label class="expand" for="c-39561081">[6 more]</label></div><br/><div class="children"><div class="content">This matters way more for video (where you are decoding 30 images per second continuously) than it does for still images. For still images, the main thing that drains your battery is the display, not the image decoding :)<p>But in any case, there are no _major_ differences in decoding speed between the various image formats. The difference caused by reducing the transfer size (network activity) and loading time (user looking at a blank screen while the image loads) is more important for battery life than the decoding speed itself. Also the difference between streaming&#x2F;progressive decoding and non-streaming decoding probably has more impact than the decode speed itself, at least in the common scenario where the image is being loaded over a network.</div><br/><div id="39561741" class="c"><input type="checkbox" id="c-39561741" checked=""/><div class="controls bullet"><span class="by">caskstrength</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39561081">parent</a><span>|</span><a href="#39561141">next</a><span>|</span><label class="collapse" for="c-39561741">[-]</label><label class="expand" for="c-39561741">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This matters way more for video (where you are decoding 30 images per second continuously) than it does for still images.<p>OTOH video decoding is highly likely to be hardware accelerated on both laptops and smartphones.<p>&gt; For still images, the main thing that drains your battery is the display, not the image decoding :)<p>I wonder if it becomes noticeable on image-heavy sites like tumblr, 500px, etc.</div><br/><div id="39563347" class="c"><input type="checkbox" id="c-39563347" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39561741">parent</a><span>|</span><a href="#39561141">next</a><span>|</span><label class="collapse" for="c-39563347">[-]</label><label class="expand" for="c-39563347">[3 more]</label></div><br/><div class="children"><div class="content">Assuming the websites are using images of appropriate dimensions (that is, not using huge images and relying on browser downscaling, which is a bad practice in any case), you can quite easily do the math. A 1080p screen is about 2 megapixels, a 4K screen is about 8 megapixels. If your images decode at 50 Mpx&#x2F;s, that&#x27;s 25 full screens (or 6 full screens at 4K) per second. You need to scroll quite quickly and have a quite good internet connection before decode speed will become a major issue, whether for UX or for battery life. Much more likely, the main issue will be the transfer time of the images.</div><br/><div id="39565021" class="c"><input type="checkbox" id="c-39565021" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39563347">parent</a><span>|</span><a href="#39561141">next</a><span>|</span><label class="collapse" for="c-39565021">[-]</label><label class="expand" for="c-39565021">[2 more]</label></div><br/><div class="children"><div class="content">The parent was talking about battery life.<p>Mobile phone CPU can switch between different power state very quickly.
If the image decoding is fast, it can sleep more</div><br/><div id="39565901" class="c"><input type="checkbox" id="c-39565901" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39565021">parent</a><span>|</span><a href="#39561141">next</a><span>|</span><label class="collapse" for="c-39565901">[-]</label><label class="expand" for="c-39565901">[1 more]</label></div><br/><div class="children"><div class="content">And the one you&#x27;re replying to is also talking about battery life. The energy needed to display an image for a few seconds is probably higher than the energy needed to decode it.</div><br/></div></div></div></div></div></div></div></div><div id="39561141" class="c"><input type="checkbox" id="c-39561141" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39561081">parent</a><span>|</span><a href="#39561741">prev</a><span>|</span><a href="#39561110">next</a><span>|</span><label class="collapse" for="c-39561141">[-]</label><label class="expand" for="c-39561141">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. For web use they all decode fast enough. Any time difference might be in progression or streaming decoding, vs. waiting for all the data to arrive before starting to decode.<p>For image gallery use of camera resolution photographs (12-50 Mpixels) it can be more fun to have 100+ Mpixels&#x2F;s, even 300 Pixels&#x2F;s.</div><br/></div></div></div></div><div id="39561110" class="c"><input type="checkbox" id="c-39561110" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560306">parent</a><span>|</span><a href="#39561081">prev</a><span>|</span><a href="#39559891">next</a><span>|</span><label class="collapse" for="c-39561110">[-]</label><label class="expand" for="c-39561110">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t able to convince myself about that when approaching that question with with back-off-the-envelope calculation, published research and prototypes.<p>Very few applications are constantly decoding images. Today a single image is often decided in a few milliseconds, but watched 1000x longer. If you 10x or even 100x energy consumption of image decoding, it is still not going to compete with display, radio and video decoding as a battery drain.</div><br/></div></div></div></div><div id="39559891" class="c"><input type="checkbox" id="c-39559891" checked=""/><div class="controls bullet"><span class="by">oynqr</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39559782">parent</a><span>|</span><a href="#39560306">prev</a><span>|</span><a href="#39565047">next</a><span>|</span><label class="collapse" for="c-39559891">[-]</label><label class="expand" for="c-39559891">[3 more]</label></div><br/><div class="children"><div class="content">When you actually want good latency, using the throughput as a metric is a bit misguided.</div><br/><div id="39559912" class="c"><input type="checkbox" id="c-39559912" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39559891">parent</a><span>|</span><a href="#39560760">next</a><span>|</span><label class="collapse" for="c-39559912">[-]</label><label class="expand" for="c-39559912">[1 more]</label></div><br/><div class="children"><div class="content">As others pointed out, that&#x27;s why JPEG XL&#x27;s excellent support for progressive decoding is important. Other formats do not support progressive decoding at all or made it optional, so it cannot be even compared at this point. In the other words, the table can be regarded as an evidence that you can have both progressive decoding <i>and</i> performance at once.</div><br/></div></div><div id="39560760" class="c"><input type="checkbox" id="c-39560760" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39559891">parent</a><span>|</span><a href="#39559912">prev</a><span>|</span><a href="#39565047">next</a><span>|</span><label class="collapse" for="c-39560760">[-]</label><label class="expand" for="c-39560760">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t have progressive decoding, those metrics are essentially the same.</div><br/></div></div></div></div></div></div><div id="39565047" class="c"><input type="checkbox" id="c-39565047" checked=""/><div class="controls bullet"><span class="by">stusmall</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39559782">prev</a><span>|</span><a href="#39560499">next</a><span>|</span><label class="collapse" for="c-39565047">[-]</label><label class="expand" for="c-39565047">[2 more]</label></div><br/><div class="children"><div class="content">In some use cases the company is paying for the encoding, but the client is doing the decoding.  As long as the client can decode the handful of images on the page fast enough for the human to not notice, its fine.  Meanwhile any percentage improvement for encoding can save real money.</div><br/><div id="39570474" class="c"><input type="checkbox" id="c-39570474" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39565047">parent</a><span>|</span><a href="#39560499">next</a><span>|</span><label class="collapse" for="c-39570474">[-]</label><label class="expand" for="c-39570474">[1 more]</label></div><br/><div class="children"><div class="content">Companies and economies who optimize the cost of clients as if their own can see diffuse benefits from it. Even if they consider 0.01 % of that cost it can lead to better decisions. If that will make the website load faster or allow for more realistic product pictures, it can lead to faster growth or less returns etc.</div><br/></div></div></div></div><div id="39560499" class="c"><input type="checkbox" id="c-39560499" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39565047">prev</a><span>|</span><a href="#39560967">next</a><span>|</span><label class="collapse" for="c-39560499">[-]</label><label class="expand" for="c-39560499">[3 more]</label></div><br/><div class="children"><div class="content">Is it practical to use hardware video decoders to decode the image formats derived from video formats, like AVIF&#x2F;AV1 and HEIC&#x2F;H264? If so that could be a compelling reason to prefer them over a format like JPEG XL which has to be decoded in software on all of today&#x27;s hardware. Everything has H264 decode and AV1 decode is steadily becoming a standard feature as well.</div><br/><div id="39560685" class="c"><input type="checkbox" id="c-39560685" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560499">parent</a><span>|</span><a href="#39561541">next</a><span>|</span><label class="collapse" for="c-39560685">[-]</label><label class="expand" for="c-39560685">[1 more]</label></div><br/><div class="children"><div class="content">No browser bothers with hardware decode of WebP or AVIF even if it is available. It is not worth the trouble for still images. Software decode is fast enough, and can have advantages over hw decode, such as streaming&#x2F;progressive decoding. So this is not really a big issue.</div><br/></div></div><div id="39561541" class="c"><input type="checkbox" id="c-39561541" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560499">parent</a><span>|</span><a href="#39560685">prev</a><span>|</span><a href="#39560967">next</a><span>|</span><label class="collapse" for="c-39561541">[-]</label><label class="expand" for="c-39561541">[1 more]</label></div><br/><div class="children"><div class="content">No, not really - mostly because setup time and concurrent decode limitations of HW decoders across platforms tend so undermine any performance or battery gains from that approach. As far as I know, not even mobile platforms bother with it with native decoders for any format.</div><br/></div></div></div></div><div id="39560967" class="c"><input type="checkbox" id="c-39560967" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39560499">prev</a><span>|</span><a href="#39560529">next</a><span>|</span><label class="collapse" for="c-39560967">[-]</label><label class="expand" for="c-39560967">[1 more]</label></div><br/><div class="children"><div class="content">Real-time encoding is pretty popular, for which encoding speed is pretty important.</div><br/></div></div><div id="39560529" class="c"><input type="checkbox" id="c-39560529" checked=""/><div class="controls bullet"><span class="by">PetahNZ</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39560967">prev</a><span>|</span><a href="#39565085">next</a><span>|</span><label class="collapse" for="c-39560529">[-]</label><label class="expand" for="c-39560529">[4 more]</label></div><br/><div class="children"><div class="content">My server will encode 1,000,000 images itself, but each client will only decode like 10.</div><br/><div id="39562856" class="c"><input type="checkbox" id="c-39562856" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560529">parent</a><span>|</span><a href="#39561694">next</a><span>|</span><label class="collapse" for="c-39562856">[-]</label><label class="expand" for="c-39562856">[2 more]</label></div><br/><div class="children"><div class="content">But you may have fifty million clients, so the total &quot;CPU hours&quot; spend on decoding will outlast encoding.<p>But the person <i>encoding</i> is picking the format, not the decoder.</div><br/><div id="39566702" class="c"><input type="checkbox" id="c-39566702" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39562856">parent</a><span>|</span><a href="#39561694">next</a><span>|</span><label class="collapse" for="c-39566702">[-]</label><label class="expand" for="c-39566702">[1 more]</label></div><br/><div class="children"><div class="content">But the server doesn&#x27;t necessarily have unlimited time to encode those images. Each of those 1 million images needs to be encoded before it can be sent to a client.</div><br/></div></div></div></div><div id="39561694" class="c"><input type="checkbox" id="c-39561694" checked=""/><div class="controls bullet"><span class="by">okamiueru</span><span>|</span><a href="#39559747">root</a><span>|</span><a href="#39560529">parent</a><span>|</span><a href="#39562856">prev</a><span>|</span><a href="#39565085">next</a><span>|</span><label class="collapse" for="c-39561694">[-]</label><label class="expand" for="c-39561694">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t saying much or anything.</div><br/></div></div></div></div><div id="39565085" class="c"><input type="checkbox" id="c-39565085" checked=""/><div class="controls bullet"><span class="by">youngtaff</span><span>|</span><a href="#39559747">parent</a><span>|</span><a href="#39560529">prev</a><span>|</span><a href="#39559989">next</a><span>|</span><label class="collapse" for="c-39565085">[-]</label><label class="expand" for="c-39565085">[1 more]</label></div><br/><div class="children"><div class="content">Because that’s Cloudinary’s use case… they literally spend millions of dollars encoding images</div><br/></div></div></div></div><div id="39559989" class="c"><input type="checkbox" id="c-39559989" checked=""/><div class="controls bullet"><span class="by">gaazoh</span><span>|</span><a href="#39559747">prev</a><span>|</span><a href="#39566405">next</a><span>|</span><label class="collapse" for="c-39559989">[-]</label><label class="expand" for="c-39559989">[13 more]</label></div><br/><div class="children"><div class="content">The inclusion of QOI in the lossless benchmarks made me smile. It&#x27;s a basically irrelevant format, that isn&#x27;t supported by default by any general-public software, that aims to be just OK, not even good, yet it has a spot on one of these charts (non-photographic encoding). Neat.</div><br/><div id="39562558" class="c"><input type="checkbox" id="c-39562558" checked=""/><div class="controls bullet"><span class="by">shdon</span><span>|</span><a href="#39559989">parent</a><span>|</span><a href="#39560000">next</a><span>|</span><label class="collapse" for="c-39562558">[-]</label><label class="expand" for="c-39562558">[4 more]</label></div><br/><div class="children"><div class="content">GameMaker Studio has actually rather quickly jumped onto the QOI bandwagon, having 2 years ago replaced PNG textures with QOI (and added BZ2 compression on top) and found a 20% average reduction in size. So GameMaker Studio and all the games produced with it in the past 2 years or so do actually use QOI internally.<p>Not something a consumer <i>knowingly</i> uses, but also not quite irrelevant either.</div><br/><div id="39565526" class="c"><input type="checkbox" id="c-39565526" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39562558">parent</a><span>|</span><a href="#39569706">next</a><span>|</span><label class="collapse" for="c-39565526">[-]</label><label class="expand" for="c-39565526">[1 more]</label></div><br/><div class="children"><div class="content">Oof that looks like a confused mess of a format.<p>bz2 is obsolete. It’s very slow, and not that good at compressing. zstd and lzma beat it on both compression and speed at the same time.<p>QOI’s only selling point is simplicity of implementation that doesn’t require a complex decompressor. Addition of bz2 completely defeats that. QOI’s poorly compressed data inside another compressor may even make overall compression worse. It could heve been a raw bitmap or a PNG with gzip replaced with zstd.</div><br/></div></div><div id="39569706" class="c"><input type="checkbox" id="c-39569706" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39562558">parent</a><span>|</span><a href="#39565526">prev</a><span>|</span><a href="#39565819">next</a><span>|</span><label class="collapse" for="c-39569706">[-]</label><label class="expand" for="c-39569706">[1 more]</label></div><br/><div class="children"><div class="content">That feels a little sad. If qoi had anything good (fast single-threaded decoding speed for photographic content) adding bz2 most certainly removed it. They could have just used WebP lossless and it would have been faster and smaller.</div><br/></div></div></div></div><div id="39560000" class="c"><input type="checkbox" id="c-39560000" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559989">parent</a><span>|</span><a href="#39562558">prev</a><span>|</span><a href="#39566405">next</a><span>|</span><label class="collapse" for="c-39560000">[-]</label><label class="expand" for="c-39560000">[8 more]</label></div><br/><div class="children"><div class="content">And yet didn&#x27;t reach the Pareto frontier! It&#x27;s quite obvious in hindsight though---QOI decoding is inherently sequential and can&#x27;t be easily parallelized.</div><br/><div id="39560082" class="c"><input type="checkbox" id="c-39560082" checked=""/><div class="controls bullet"><span class="by">gaazoh</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39560000">parent</a><span>|</span><a href="#39566540">next</a><span>|</span><label class="collapse" for="c-39560082">[-]</label><label class="expand" for="c-39560082">[4 more]</label></div><br/><div class="children"><div class="content">Of course it didn&#x27;t, it wasn&#x27;t designed to be either the fastest nor the best. Just OK and simple. Yet in some cases it&#x27;s not completely overtaken by competition, and I think that&#x27;s cool.<p>I don&#x27;t believe QOI will ever have any sort of real-world practical use, but that&#x27;s quite OK and I love it for it has made me and plenty of others look into binary file formats and compression and demystify it, and look further into it. I wrote a fully functional streaming codec for QOI, and it has taught me many things, and started me on other projects, either working with more complex file formats or thinking about how to improve upon QOI. I would probably never have gotten to this point if I tried the same thing starting with any other format, as they are at least an order of magnitude more complex, even for the simple ones.</div><br/><div id="39561154" class="c"><input type="checkbox" id="c-39561154" checked=""/><div class="controls bullet"><span class="by">theon144</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39560082">parent</a><span>|</span><a href="#39560740">next</a><span>|</span><label class="collapse" for="c-39561154">[-]</label><label class="expand" for="c-39561154">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I don&#x27;t believe QOI will ever have any sort of real-world practical use<p>Prusa (the 3d printer maker) seems to think otherwise! <a href="https:&#x2F;&#x2F;github.com&#x2F;prusa3d&#x2F;Prusa-Firmware-Buddy&#x2F;releases&#x2F;tag&#x2F;v5.1.0">https:&#x2F;&#x2F;github.com&#x2F;prusa3d&#x2F;Prusa-Firmware-Buddy&#x2F;releases&#x2F;tag...</a></div><br/></div></div><div id="39560740" class="c"><input type="checkbox" id="c-39560740" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39560082">parent</a><span>|</span><a href="#39561154">prev</a><span>|</span><a href="#39561008">next</a><span>|</span><label class="collapse" for="c-39560740">[-]</label><label class="expand" for="c-39560740">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Of course it didn&#x27;t, it wasn&#x27;t designed to be either the fastest nor the best. Just OK and simple. Yet in some cases it&#x27;s not completely overtaken by competition, and I think that&#x27;s cool.<p>Actually, there was a big push to add QOI to stuff a few years ago, specifically due to it being &quot;fast&quot;. It was claimed that while it has worse compression, the speed can make it a worthy trade off.</div><br/></div></div><div id="39561008" class="c"><input type="checkbox" id="c-39561008" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39560082">parent</a><span>|</span><a href="#39560740">prev</a><span>|</span><a href="#39566540">next</a><span>|</span><label class="collapse" for="c-39561008">[-]</label><label class="expand" for="c-39561008">[1 more]</label></div><br/><div class="children"><div class="content">It can be interesting if you need fast decode on low complexity, and it&#x27;s an easy to improve format (-20 to -30%). Base QOI isn&#x27;t that great.</div><br/></div></div></div></div><div id="39566540" class="c"><input type="checkbox" id="c-39566540" checked=""/><div class="controls bullet"><span class="by">phoboslab</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39560000">parent</a><span>|</span><a href="#39560082">prev</a><span>|</span><a href="#39566405">next</a><span>|</span><label class="collapse" for="c-39566540">[-]</label><label class="expand" for="c-39566540">[3 more]</label></div><br/><div class="children"><div class="content">As far a I understand this benchmark JXL was using 8 CPU cores, while QOI naturally only used one. If you were to plot the graph with compute used (watts?) instead of Mpx&#x2F;s, QOI would compare much better.<p>Also, curious that they only benchmarked QOI for &quot;non-photographic images (manga)&quot;, where QOI fares quite badly because it doesn&#x27;t have palleted mode. QOI does much better with photos.</div><br/><div id="39566626" class="c"><input type="checkbox" id="c-39566626" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39566540">parent</a><span>|</span><a href="#39566405">next</a><span>|</span><label class="collapse" for="c-39566626">[-]</label><label class="expand" for="c-39566626">[2 more]</label></div><br/><div class="children"><div class="content">Actually, they did try QOI for the photographic images:<p>&gt; Not shown on the chart is QOI, which clocked in at 154 Mpx&#x2F;s to achieve 17 bpp, which may be “quite OK” but is quite far from Pareto-optimal, considering the lowest effort setting of libjxl compresses down to 11.5 bpp at 427 Mpx&#x2F;s (so it is 2.7 times as fast and the result is 32.5% smaller).<p>17 bpp is way outside the area shown in the graph. All the other results would&#x27;ve gotten squished and been harder to read, had QOI been shown.</div><br/><div id="39566991" class="c"><input type="checkbox" id="c-39566991" checked=""/><div class="controls bullet"><span class="by">phoboslab</span><span>|</span><a href="#39559989">root</a><span>|</span><a href="#39566626">parent</a><span>|</span><a href="#39566405">next</a><span>|</span><label class="collapse" for="c-39566991">[-]</label><label class="expand" for="c-39566991">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I missed that.<p>I just ran qoibench on the photos they used[1] and QOI does indeed fair pretty badly with a compression ratio of 71.1% vs. 49.3% for PNG.<p>The photos in the QOI benchmark suite[2] somehow compress a lot better (e.g. photo_kodak&#x2F;, photo_tecnick&#x2F; and photo_wikipedia&#x2F;). I guess it&#x27;s the film grain with the high resolution photos used in [1].<p>[1] <a href="https:&#x2F;&#x2F;imagecompression.info&#x2F;test_images&#x2F;" rel="nofollow">https:&#x2F;&#x2F;imagecompression.info&#x2F;test_images&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;qoiformat.org&#x2F;benchmark&#x2F;" rel="nofollow">https:&#x2F;&#x2F;qoiformat.org&#x2F;benchmark&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39566405" class="c"><input type="checkbox" id="c-39566405" checked=""/><div class="controls bullet"><span class="by">ImageXav</span><span>|</span><a href="#39559989">prev</a><span>|</span><a href="#39559648">next</a><span>|</span><label class="collapse" for="c-39566405">[-]</label><label class="expand" for="c-39566405">[2 more]</label></div><br/><div class="children"><div class="content">Maybe someone here will know of a website that describes each step of the jpeg xl format in detail? Unlike for traditional jpeg, I have found it hard to find a document providing clear instructions on the relevant steps, which is a shame as there are clearly tons of interesting innovations that have been compiled together to make this happen, and I&#x27;m sure the individual components are useful in their own right!</div><br/><div id="39568990" class="c"><input type="checkbox" id="c-39568990" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39566405">parent</a><span>|</span><a href="#39559648">next</a><span>|</span><label class="collapse" for="c-39568990">[-]</label><label class="expand" for="c-39568990">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;format_overview.md">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;format_overvi...</a> is a pretty detailed but good overview. The highlights are variable size DCT (up to 128x128), ANS entropy prediction, and chroma from luminance prediction. <a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;encode_effort.md">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;encode_effort...</a> also gives a good breakdown of features by effort level.</div><br/></div></div></div></div><div id="39559648" class="c"><input type="checkbox" id="c-39559648" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39566405">prev</a><span>|</span><a href="#39563453">next</a><span>|</span><label class="collapse" for="c-39559648">[-]</label><label class="expand" for="c-39559648">[13 more]</label></div><br/><div class="children"><div class="content">One does wonder how much of JXL&#x27;s awesomeness is the encoder vs. the format.  Its ability to make high quality, compact images just with &quot;-d 1.0&quot; is uncanny.  With other codecs, I had to pass different quality settings depending on the image type to get similar results.</div><br/><div id="39559838" class="c"><input type="checkbox" id="c-39559838" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559648">parent</a><span>|</span><a href="#39560228">next</a><span>|</span><label class="collapse" for="c-39559838">[-]</label><label class="expand" for="c-39559838">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very good point. At this rate of development I wouldn&#x27;t be surprised if libjxl becomes x264 of image encoders.<p>On the other hand, libvpx has always been a mediocre encoder  which I think might be the reason for disappointing performance (I mean in general, not just speed) of vp8&#x2F;vp9 formats, which inevitably also affected performance of lossy WebP. Dark Shikari even did a comparison of still image performances of x264 vs vp8 [0].<p>[0] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150419071902&#x2F;http:&#x2F;&#x2F;x264dev.multimedia.cx&#x2F;archives&#x2F;541" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150419071902&#x2F;http:&#x2F;&#x2F;x264dev.mu...</a></div><br/><div id="39560242" class="c"><input type="checkbox" id="c-39560242" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39559838">parent</a><span>|</span><a href="#39560228">next</a><span>|</span><label class="collapse" for="c-39560242">[-]</label><label class="expand" for="c-39560242">[3 more]</label></div><br/><div class="children"><div class="content">While WebP lossy still has image quality issues it has improved a lot over the years. One should not consider a comparison done with 2010-2015 implementations indicative of quality performance today.</div><br/><div id="39561557" class="c"><input type="checkbox" id="c-39561557" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560242">parent</a><span>|</span><a href="#39560228">next</a><span>|</span><label class="collapse" for="c-39561557">[-]</label><label class="expand" for="c-39561557">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure it&#x27;s better now than 13 years ago, but the conclusion I got from looking at very recent published benchmark results is that lossy webp is still only slightly better than mozjpeg at low bitrates and still has worse max. PQ ceiling compared to JPEG, which in my opinion makes it not worth using over plain old JPEG even in web settings.</div><br/><div id="39563313" class="c"><input type="checkbox" id="c-39563313" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39561557">parent</a><span>|</span><a href="#39560228">next</a><span>|</span><label class="collapse" for="c-39563313">[-]</label><label class="expand" for="c-39563313">[1 more]</label></div><br/><div class="children"><div class="content">That matches my observations. I believe that WebP lossy does not add value when Jpegli is an option and is having hard time to compete even with MozJPEG.</div><br/></div></div></div></div></div></div></div></div><div id="39560228" class="c"><input type="checkbox" id="c-39560228" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559648">parent</a><span>|</span><a href="#39559838">prev</a><span>|</span><a href="#39560216">next</a><span>|</span><label class="collapse" for="c-39560228">[-]</label><label class="expand" for="c-39560228">[1 more]</label></div><br/><div class="children"><div class="content">Pik was designed initially without quality options only to do the best there is to achieve distance 1.0.<p>We kept a lot of focus on visually lossless and I didn&#x27;t want to add format features which would add complexity but not help at high quality settings.<p>In addition to modeling features, the context modeling and efficiency of entropy coding is critical at high quality. I consider AVIFs entropy coding ill-suited for high quality or lossless photography.</div><br/></div></div><div id="39560216" class="c"><input type="checkbox" id="c-39560216" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39559648">parent</a><span>|</span><a href="#39560228">prev</a><span>|</span><a href="#39563453">next</a><span>|</span><label class="collapse" for="c-39560216">[-]</label><label class="expand" for="c-39560216">[7 more]</label></div><br/><div class="children"><div class="content">They&#x27;ve also made a JPEG encoder, cjpegli, with the same &quot;-d 1.0&quot; interface.</div><br/><div id="39560718" class="c"><input type="checkbox" id="c-39560718" checked=""/><div class="controls bullet"><span class="by">dingdingdang</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560216">parent</a><span>|</span><a href="#39563453">next</a><span>|</span><label class="collapse" for="c-39560718">[-]</label><label class="expand" for="c-39560718">[6 more]</label></div><br/><div class="children"><div class="content">Excellent run-through of jpegli encoder here: <a href="https:&#x2F;&#x2F;giannirosato.com&#x2F;blog&#x2F;post&#x2F;jpegli&#x2F;" rel="nofollow">https:&#x2F;&#x2F;giannirosato.com&#x2F;blog&#x2F;post&#x2F;jpegli&#x2F;</a> - wish I could find a pre-compiled terminal utility for cjpegli!</div><br/><div id="39561797" class="c"><input type="checkbox" id="c-39561797" checked=""/><div class="controls bullet"><span class="by">botanical</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560718">parent</a><span>|</span><a href="#39561743">next</a><span>|</span><label class="collapse" for="c-39561797">[-]</label><label class="expand" for="c-39561797">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the static github release files here: <a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;releases&#x2F;tag&#x2F;v0.10.1">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;releases&#x2F;tag&#x2F;v0.10.1</a></div><br/></div></div><div id="39561743" class="c"><input type="checkbox" id="c-39561743" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560718">parent</a><span>|</span><a href="#39561797">prev</a><span>|</span><a href="#39568721">next</a><span>|</span><label class="collapse" for="c-39561743">[-]</label><label class="expand" for="c-39561743">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re available at <a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;releases&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;releases&#x2F;</a> for linux and windows.</div><br/><div id="39566356" class="c"><input type="checkbox" id="c-39566356" checked=""/><div class="controls bullet"><span class="by">dingdingdang</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39561743">parent</a><span>|</span><a href="#39568721">next</a><span>|</span><label class="collapse" for="c-39566356">[-]</label><label class="expand" for="c-39566356">[1 more]</label></div><br/><div class="children"><div class="content">Dear lord.. despite browsing and using github on a daily basis I still miss releases section sometimes! Before I saw your reply I checked the Scoop repos and sure enough, on Windows this will get you latest cjpegli version installed and added to path in one go:<p>scoop install main&#x2F;libjxl<p>Note.. now that I tried it: that is really next level for an old format..!</div><br/></div></div></div></div><div id="39568721" class="c"><input type="checkbox" id="c-39568721" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560718">parent</a><span>|</span><a href="#39561743">prev</a><span>|</span><a href="#39560751">next</a><span>|</span><label class="collapse" for="c-39568721">[-]</label><label class="expand" for="c-39568721">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the unstable channel of nixpkgs.</div><br/></div></div><div id="39560751" class="c"><input type="checkbox" id="c-39560751" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559648">root</a><span>|</span><a href="#39560718">parent</a><span>|</span><a href="#39568721">prev</a><span>|</span><a href="#39563453">next</a><span>|</span><label class="collapse" for="c-39560751">[-]</label><label class="expand" for="c-39560751">[1 more]</label></div><br/><div class="children"><div class="content">I have heard that it will see a proper standalone release at some point this year, but I don&#x27;t know more than that.</div><br/></div></div></div></div></div></div></div></div><div id="39563453" class="c"><input type="checkbox" id="c-39563453" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559648">prev</a><span>|</span><a href="#39562455">next</a><span>|</span><label class="collapse" for="c-39563453">[-]</label><label class="expand" for="c-39563453">[3 more]</label></div><br/><div class="children"><div class="content">It is worth noting that the JPEG XL effort produced a nice new parallelism library called Highway. This library is powering not only JPEG XL but also Google&#x27;s latest Gemma AI models.</div><br/><div id="39565882" class="c"><input type="checkbox" id="c-39565882" checked=""/><div class="controls bullet"><span class="by">jhalstead</span><span>|</span><a href="#39563453">parent</a><span>|</span><a href="#39562455">next</a><span>|</span><label class="collapse" for="c-39565882">[-]</label><label class="expand" for="c-39565882">[2 more]</label></div><br/><div class="children"><div class="content">[0] for those interested in Highway.<p>It&#x27;s also mentioned in [1], which starts off<p>&gt; Today we&#x27;re sharing open source code that can sort arrays of numbers about ten times as fast as the C++ std::sort, and outperforms state of the art architecture-specific algorithms, while being portable across all modern CPU architectures. Below we discuss how we achieved this.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway</a><p>[1] <a href="https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2022&#x2F;06&#x2F;Vectorized%20and%20performance%20portable%20Quicksort.html" rel="nofollow">https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2022&#x2F;06&#x2F;Vectorized%20and%2...</a>, which has an associated paper at <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2205.05982.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2205.05982.pdf</a>.</div><br/><div id="39568174" class="c"><input type="checkbox" id="c-39568174" checked=""/><div class="controls bullet"><span class="by">janwas</span><span>|</span><a href="#39563453">root</a><span>|</span><a href="#39565882">parent</a><span>|</span><a href="#39562455">next</a><span>|</span><label class="collapse" for="c-39568174">[-]</label><label class="expand" for="c-39568174">[1 more]</label></div><br/><div class="children"><div class="content">:) Thanks for the mention. Highway&#x2F;vqsort TL here, happy to discuss.<p>PS: I used to work on JPEG XL. It is great to see these outstanding improvements, congrats to the team!</div><br/></div></div></div></div></div></div><div id="39562455" class="c"><input type="checkbox" id="c-39562455" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#39563453">prev</a><span>|</span><a href="#39559644">next</a><span>|</span><label class="collapse" for="c-39562455">[-]</label><label class="expand" for="c-39562455">[5 more]</label></div><br/><div class="children"><div class="content">Without taking into account whether JPEG XL shines on its own or not (which it may or may not), JPEG XL completely rocks for sure because it does this:<p><pre><code>    .. $  ls -l a.jpg &amp;&amp; shasum a.jpg
    ... 615504 ...  a.jpg
    716744d950ecf9e5757c565041143775a810e10f  a.jpg

    .. $  cjxl a.jpg a.jxl
    Read JPEG image with 615504 bytes.
    Compressed to 537339 bytes including container

    .. $  ls -l a.jxl
    ... 537339 ... a.jxl
</code></pre>
But, wait for it:<p><pre><code>    .. $  djxl a.jxl b.jpg
    Read 537339 compressed bytes.
    Reconstructed to JPEG.

    .. $  ls -l b.jpg &amp;&amp; shasum b.jpg
    ... 615504 ... b.jpg
    716744d950ecf9e5757c565041143775a810e10f  b.jpg
</code></pre>
Do you realize how many <i>billions</i> of JPEG files there are out there which people want to keep? If you recompress your old JPEG files using a lossy format, you lower its quality.<p>But with JPEG XL, you can save 15% to 30%  and still, if you want, get your original JPG 100% identical, bit for bit.<p>That&#x27;s wonderful.<p>P.S: I&#x27;m sadly on Debian stable (12 &#x2F; Bookworm) which is on ImageMagick 6.9 and my Emacs uses (AFAIK) ImageMagick to display pictures. And JPEG XL support was only added in ImageMagick 7. I haven&#x27;t looked more into that yet.</div><br/><div id="39562761" class="c"><input type="checkbox" id="c-39562761" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39562455">parent</a><span>|</span><a href="#39562470">next</a><span>|</span><label class="collapse" for="c-39562761">[-]</label><label class="expand" for="c-39562761">[1 more]</label></div><br/><div class="children"><div class="content">I managed to add that requirement to jpeg xl. I think it will be helpful to preserve our digital legacy intact without lossy re-encodings.</div><br/></div></div><div id="39562470" class="c"><input type="checkbox" id="c-39562470" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39562455">parent</a><span>|</span><a href="#39562761">prev</a><span>|</span><a href="#39559644">next</a><span>|</span><label class="collapse" for="c-39562470">[-]</label><label class="expand" for="c-39562470">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure that will be hugely cherished by users which take screenshots of JPEGs so they can resend them on WhatsApp :P</div><br/><div id="39562568" class="c"><input type="checkbox" id="c-39562568" checked=""/><div class="controls bullet"><span class="by">F3nd0</span><span>|</span><a href="#39562455">root</a><span>|</span><a href="#39562470">parent</a><span>|</span><a href="#39559644">next</a><span>|</span><label class="collapse" for="c-39562568">[-]</label><label class="expand" for="c-39562568">[2 more]</label></div><br/><div class="children"><div class="content">This particular feature might not, but if said screenshots are often compressed with JPEG XL, they will be spared the generation loss that becomes blatantly visible in some other formats: <a href="https:&#x2F;&#x2F;invidious.protokolla.fi&#x2F;watch?v=w7UDJUCMTng" rel="nofollow">https:&#x2F;&#x2F;invidious.protokolla.fi&#x2F;watch?v=w7UDJUCMTng</a></div><br/><div id="39564365" class="c"><input type="checkbox" id="c-39564365" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39562455">root</a><span>|</span><a href="#39562568">parent</a><span>|</span><a href="#39559644">next</a><span>|</span><label class="collapse" for="c-39564365">[-]</label><label class="expand" for="c-39564365">[1 more]</label></div><br/><div class="children"><div class="content">Maybe. But to know for sure you need to offset the image and change encoder settings.</div><br/></div></div></div></div></div></div></div></div><div id="39559644" class="c"><input type="checkbox" id="c-39559644" checked=""/><div class="controls bullet"><span class="by">Zamicol</span><span>|</span><a href="#39562455">prev</a><span>|</span><a href="#39560051">next</a><span>|</span><label class="collapse" for="c-39559644">[-]</label><label class="expand" for="c-39559644">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The new version of libjxl brings a very substantial reduction in memory consumption, by an order of magnitude, for both lossy and lossless compression. Also the speed is improved, especially for multi-threaded lossless encoding where the default effort setting is now an order of magnitude faster.<p>Very impressive!  The article too is well written.  Great work all around.</div><br/></div></div><div id="39560051" class="c"><input type="checkbox" id="c-39560051" checked=""/><div class="controls bullet"><span class="by">btdmaster</span><span>|</span><a href="#39559644">prev</a><span>|</span><a href="#39563206">next</a><span>|</span><label class="collapse" for="c-39560051">[-]</label><label class="expand" for="c-39560051">[6 more]</label></div><br/><div class="children"><div class="content">Missing from the article is rav1e, which encodes AV1, and hence AVIF, a lot faster than the reference implementation aom. I&#x27;ve had cases where aom would not finish converting an image in a minute of waiting what rav1e would do in less than 10 seconds.</div><br/><div id="39560200" class="c"><input type="checkbox" id="c-39560200" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560051">parent</a><span>|</span><a href="#39560719">next</a><span>|</span><label class="collapse" for="c-39560200">[-]</label><label class="expand" for="c-39560200">[4 more]</label></div><br/><div class="children"><div class="content">Is rav1e pareto-curve ahead of libaom pareto-curve?<p>Does fast rav1e look better than jpegli at high encode speeds?</div><br/><div id="39565698" class="c"><input type="checkbox" id="c-39565698" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#39560051">root</a><span>|</span><a href="#39560200">parent</a><span>|</span><a href="#39560591">next</a><span>|</span><label class="collapse" for="c-39565698">[-]</label><label class="expand" for="c-39565698">[1 more]</label></div><br/><div class="children"><div class="content">rav1e is generally head to head with libaom on static images, and which one wins on the speed&#x2F;quality&#x2F;size frontier depends a lot on the image and settings, as much as +&#x2F;- 20%. I suspect rav1e has an inefficient block size selection algorithm, so the particular shape of blocks is a make or break for it.<p>I’ve only compared rav1e to mozjpeg and libwebp, and at fastest speeds it’s only barely ahead.</div><br/></div></div><div id="39560591" class="c"><input type="checkbox" id="c-39560591" checked=""/><div class="controls bullet"><span class="by">btdmaster</span><span>|</span><a href="#39560051">root</a><span>|</span><a href="#39560200">parent</a><span>|</span><a href="#39565698">prev</a><span>|</span><a href="#39560719">next</a><span>|</span><label class="collapse" for="c-39560591">[-]</label><label class="expand" for="c-39560591">[2 more]</label></div><br/><div class="children"><div class="content">Difficult to know without reproduction steps from the article, but I would think it behaves better than libaom for the same quality setting.<p>Edit: found <a href="https:&#x2F;&#x2F;github.com&#x2F;xiph&#x2F;rav1e&#x2F;issues&#x2F;2759">https:&#x2F;&#x2F;github.com&#x2F;xiph&#x2F;rav1e&#x2F;issues&#x2F;2759</a></div><br/><div id="39563341" class="c"><input type="checkbox" id="c-39563341" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39560051">root</a><span>|</span><a href="#39560591">parent</a><span>|</span><a href="#39560719">next</a><span>|</span><label class="collapse" for="c-39563341">[-]</label><label class="expand" for="c-39563341">[1 more]</label></div><br/><div class="children"><div class="content">If Rav1e found better ways of encoding, why would the aom folks copy it in libaom?</div><br/></div></div></div></div></div></div><div id="39560719" class="c"><input type="checkbox" id="c-39560719" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39560051">parent</a><span>|</span><a href="#39560200">prev</a><span>|</span><a href="#39563206">next</a><span>|</span><label class="collapse" for="c-39560719">[-]</label><label class="expand" for="c-39560719">[1 more]</label></div><br/><div class="children"><div class="content">Both rav1e and libaom have a speed setting. At similar speeds, I have not observed huge differences in compression performance between the two.</div><br/></div></div></div></div><div id="39563206" class="c"><input type="checkbox" id="c-39563206" checked=""/><div class="controls bullet"><span class="by">kodabbb</span><span>|</span><a href="#39560051">prev</a><span>|</span><a href="#39559810">next</a><span>|</span><label class="collapse" for="c-39563206">[-]</label><label class="expand" for="c-39563206">[2 more]</label></div><br/><div class="children"><div class="content">Looks like there are more savings coming on lossless AVIF: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;AV1&#x2F;comments&#x2F;1b3lh08&#x2F;comment&#x2F;kstmbru&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;AV1&#x2F;comments&#x2F;1b3lh08&#x2F;comment&#x2F;kstmbr...</a></div><br/><div id="39565353" class="c"><input type="checkbox" id="c-39565353" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39563206">parent</a><span>|</span><a href="#39559810">next</a><span>|</span><label class="collapse" for="c-39565353">[-]</label><label class="expand" for="c-39565353">[1 more]</label></div><br/><div class="children"><div class="content">I plan to add 15–25 % more quality in the ugly lowest end quality in JPEG XL in the coming two months.</div><br/></div></div></div></div><div id="39559810" class="c"><input type="checkbox" id="c-39559810" checked=""/><div class="controls bullet"><span class="by">taylorius</span><span>|</span><a href="#39563206">prev</a><span>|</span><a href="#39562165">next</a><span>|</span><label class="collapse" for="c-39559810">[-]</label><label class="expand" for="c-39559810">[15 more]</label></div><br/><div class="children"><div class="content">The article mentions encoding speed as something to consider, alongside compression ratio. I would argue that decoding speed is also important. A lot of the more modern formats (webp, avif etc) can take significantly more CPU cycles to decode than a plain old jpg. This can slow things down noticeably,especially on mobile.</div><br/><div id="39559862" class="c"><input type="checkbox" id="c-39559862" checked=""/><div class="controls bullet"><span class="by">oynqr</span><span>|</span><a href="#39559810">parent</a><span>|</span><a href="#39559872">next</a><span>|</span><label class="collapse" for="c-39559862">[-]</label><label class="expand" for="c-39559862">[6 more]</label></div><br/><div class="children"><div class="content">JPEG and JXL have the benefit of (optional) progressive decoding, so even if the image is a little larger than AVIF, you may still see content faster.</div><br/><div id="39559929" class="c"><input type="checkbox" id="c-39559929" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39559862">parent</a><span>|</span><a href="#39561562">next</a><span>|</span><label class="collapse" for="c-39559929">[-]</label><label class="expand" for="c-39559929">[1 more]</label></div><br/><div class="children"><div class="content">Note that JPEG XL always supports progressive decoding, because the top-level format is structured in that way. The optional part is a finer-grained adjustment to make the output more suitable for specific cases.</div><br/></div></div><div id="39561562" class="c"><input type="checkbox" id="c-39561562" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39559862">parent</a><span>|</span><a href="#39559929">prev</a><span>|</span><a href="#39559872">next</a><span>|</span><label class="collapse" for="c-39561562">[-]</label><label class="expand" for="c-39561562">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great, are there any comparison graphs and benchmarks showing that in real life (similarly to this article)?</div><br/><div id="39569738" class="c"><input type="checkbox" id="c-39569738" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39561562">parent</a><span>|</span><a href="#39561677">next</a><span>|</span><label class="collapse" for="c-39569738">[-]</label><label class="expand" for="c-39569738">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2021&#x2F;09&#x2F;using-saliency-in-progressive-jpeg-xl-images.html" rel="nofollow">https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2021&#x2F;09&#x2F;using-saliency-in-...</a> can be interesting</div><br/></div></div><div id="39561677" class="c"><input type="checkbox" id="c-39561677" checked=""/><div class="controls bullet"><span class="by">149765</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39561562">parent</a><span>|</span><a href="#39569738">prev</a><span>|</span><a href="#39559872">next</a><span>|</span><label class="collapse" for="c-39561677">[-]</label><label class="expand" for="c-39561677">[2 more]</label></div><br/><div class="children"><div class="content">A couple of videos comparing progressive decoding of jpeg, jxl and avif:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UphN1_7nP8U" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UphN1_7nP8U</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=inQxEBn831w" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=inQxEBn831w</a><p>There&#x27;s more on the same channel, generation loss ones are really interesting.</div><br/><div id="39562508" class="c"><input type="checkbox" id="c-39562508" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39561677">parent</a><span>|</span><a href="#39559872">next</a><span>|</span><label class="collapse" for="c-39562508">[-]</label><label class="expand" for="c-39562508">[1 more]</label></div><br/><div class="children"><div class="content">Awesome, thanks.</div><br/></div></div></div></div></div></div></div></div><div id="39559872" class="c"><input type="checkbox" id="c-39559872" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559810">parent</a><span>|</span><a href="#39559862">prev</a><span>|</span><a href="#39562165">next</a><span>|</span><label class="collapse" for="c-39559872">[-]</label><label class="expand" for="c-39559872">[8 more]</label></div><br/><div class="children"><div class="content">Any computation-intensive media format on mobile is likely using a hardware decoder module anyway, and that most frequently includes JPEG. So that comparison is not adaquate.</div><br/><div id="39560022" class="c"><input type="checkbox" id="c-39560022" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39559872">parent</a><span>|</span><a href="#39561563">next</a><span>|</span><label class="collapse" for="c-39560022">[-]</label><label class="expand" for="c-39560022">[4 more]</label></div><br/><div class="children"><div class="content">&quot;computation-intensive media&quot; = videos<p>Seriously, when is the last time mobile phones used hardware decoding for showing images? Flip phones in 2005?<p>I know camera apps use hardware encoding but I doubt gallery apps or browsers bother with going through the hardware decoding pipeline for hundreds of JPEG images you scroll through in seconds. And when it comes to showing a single image they&#x27;ll still opt to software decoding because it&#x27;s more flexible when it comes to integration, implementation,  customization and format limits. So not surprisingly I&#x27;m not convinced when I repeatedly see this claim that mobile phones commonly use hardware decoding for image formats and software decoding speed doesn&#x27;t matter.</div><br/><div id="39560339" class="c"><input type="checkbox" id="c-39560339" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39560022">parent</a><span>|</span><a href="#39561563">next</a><span>|</span><label class="collapse" for="c-39560339">[-]</label><label class="expand" for="c-39560339">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the current status of web browsers, ut hardware encoding and decoding for image formats is alive and well. Not really relevant for showing a 32x32 GIF arrow like on HN, but very important when browsing high resolution images with any kind of smoothness.<p>If you don&#x27;t really care about your users&#x27; battery life you can opt to disable hardware acceleration within your applications, but it&#x27;s usually enabled by default, and for good reason.</div><br/><div id="39561634" class="c"><input type="checkbox" id="c-39561634" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39560339">parent</a><span>|</span><a href="#39560827">next</a><span>|</span><label class="collapse" for="c-39561634">[-]</label><label class="expand" for="c-39561634">[1 more]</label></div><br/><div class="children"><div class="content">&gt; hardware encoding and decoding for image formats is alive and well<p>I keep hearing and hearing this but nobody has ever yet provided a concrete real world example of smart phones using hw <i>decoding</i> for displaying images.</div><br/></div></div><div id="39560827" class="c"><input type="checkbox" id="c-39560827" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39560339">parent</a><span>|</span><a href="#39561634">prev</a><span>|</span><a href="#39561563">next</a><span>|</span><label class="collapse" for="c-39560827">[-]</label><label class="expand" for="c-39560827">[1 more]</label></div><br/><div class="children"><div class="content">Hardware acceleration of image decoding is very uncommon in most consumer applications.</div><br/></div></div></div></div></div></div><div id="39561563" class="c"><input type="checkbox" id="c-39561563" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39559872">parent</a><span>|</span><a href="#39560022">prev</a><span>|</span><a href="#39562165">next</a><span>|</span><label class="collapse" for="c-39561563">[-]</label><label class="expand" for="c-39561563">[3 more]</label></div><br/><div class="children"><div class="content">No, not a single mobile platform uses hardware decode modules for still image decoding as of 2024.<p>At best, the camera processors output encoded JPEG&#x2F;HEIF for taken pictures, but that&#x27;s about it.</div><br/><div id="39568669" class="c"><input type="checkbox" id="c-39568669" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39561563">parent</a><span>|</span><a href="#39562165">next</a><span>|</span><label class="collapse" for="c-39568669">[-]</label><label class="expand" for="c-39568669">[2 more]</label></div><br/><div class="children"><div class="content">That was quite contrary to my understanding, so I took some more time to verify both my and your claim. The reality turned out to be somewhere in the middle: modern mobile SoCs <i>do</i> ship with hardware JPEG decoding among others, but there is no direct API for that hardware decoding module in the mobile platform itself (Android 7 and onwards use libjpeg-turbo by default, for example). But mobile manufacturers can change the implementation details behind those APIs, so it is still true that some mobiles do use hardware JPEG decoding behind the scene. But it is hard to tell how common it is. So well, thank you for the counterpoint---that corrected my understanding.</div><br/><div id="39569101" class="c"><input type="checkbox" id="c-39569101" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#39559810">root</a><span>|</span><a href="#39568669">parent</a><span>|</span><a href="#39562165">next</a><span>|</span><label class="collapse" for="c-39569101">[-]</label><label class="expand" for="c-39569101">[1 more]</label></div><br/><div class="children"><div class="content">They ship with hardware jpeg decoders because they ship with hardware jpeg <i>encoders</i> for camera capture latency reasons and it turns out you can basically just run that hardware in reverse.<p>The SoCs aren&#x27;t investing more than a token amount of effort into those jpeg decoders, and from experience some of them claim to exist but produce the shittiest looking output imaginable and more slowly than jpeg-turbo at that.<p>Also you can trivially find out if your Android phone is doing this or not, just run some perf call sampling while decoding jpegs. If all you see is AOSP libraries &amp; libjpeg-turbo, well then they aren&#x27;t doing hardware decodes :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39562165" class="c"><input type="checkbox" id="c-39562165" checked=""/><div class="controls bullet"><span class="by">MikeCapone</span><span>|</span><a href="#39559810">prev</a><span>|</span><a href="#39559765">next</a><span>|</span><label class="collapse" for="c-39562165">[-]</label><label class="expand" for="c-39562165">[1 more]</label></div><br/><div class="children"><div class="content">I really hope this can become a new standard and be available everywhere (image tools, browsers, etc).<p>While in practice it won&#x27;t change my life much, I like the elegance of using a modern standard with this level of performance an efficiency.</div><br/></div></div><div id="39559765" class="c"><input type="checkbox" id="c-39559765" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#39562165">prev</a><span>|</span><a href="#39559716">next</a><span>|</span><label class="collapse" for="c-39559765">[-]</label><label class="expand" for="c-39559765">[3 more]</label></div><br/><div class="children"><div class="content">Does JPEG XL have patent issues?  I half remember something about that.  Regular JPG seems fine to me.  Better compression isn&#x27;t going to help anyone since they will find other ways to waste any bandwidth available.</div><br/><div id="39559841" class="c"><input type="checkbox" id="c-39559841" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559765">parent</a><span>|</span><a href="#39563545">next</a><span>|</span><label class="collapse" for="c-39559841">[-]</label><label class="expand" for="c-39559841">[1 more]</label></div><br/><div class="children"><div class="content">The main innovation claimed by Microsoft&#x27;s rANS patent is about the adaptive probability distribution, that is, you should be able to efficiently correct the distribution so that you can use less bits. While that alone is an absurd claim (that&#x27;s a benefit shared with arithmetic coding and its variants!) and there is a very clear prior art, JPEG XL doesn&#x27;t dynamically vary the distribution so is thought to be not related to the patent anyway.</div><br/></div></div><div id="39563545" class="c"><input type="checkbox" id="c-39563545" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559765">parent</a><span>|</span><a href="#39559841">prev</a><span>|</span><a href="#39559716">next</a><span>|</span><label class="collapse" for="c-39563545">[-]</label><label class="expand" for="c-39563545">[1 more]</label></div><br/><div class="children"><div class="content">No it doesn&#x27;t.<p>And yes, regular JPEG is still a fine format. That&#x27;s part of the point of the article. But for many use cases, better compression is always welcome. Also having features like alpha transparency, lossless, HDR etc can be quite desirable, and those things are not really possible in JPEG.</div><br/></div></div></div></div><div id="39559716" class="c"><input type="checkbox" id="c-39559716" checked=""/><div class="controls bullet"><span class="by">anewhnaccount2</span><span>|</span><a href="#39559765">prev</a><span>|</span><a href="#39568792">next</a><span>|</span><label class="collapse" for="c-39559716">[-]</label><label class="expand" for="c-39559716">[10 more]</label></div><br/><div class="children"><div class="content">Should the Pareto front not be drawn with line perpendicular to the axes rather than diagonal lines?</div><br/><div id="39563378" class="c"><input type="checkbox" id="c-39563378" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559716">parent</a><span>|</span><a href="#39559850">next</a><span>|</span><label class="collapse" for="c-39563378">[-]</label><label class="expand" for="c-39563378">[1 more]</label></div><br/><div class="children"><div class="content">Often with this kind of pareto it can be argued that even when continuous decisions are not available, a compression system could keep choosing every second at effort 7 and every second at effort 6 (or any ratio), leading, on the average interpolated results. Naturally such interpolation does not produce straight lines in log space.</div><br/></div></div><div id="39559850" class="c"><input type="checkbox" id="c-39559850" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#39559716">parent</a><span>|</span><a href="#39563378">prev</a><span>|</span><a href="#39560135">next</a><span>|</span><label class="collapse" for="c-39559850">[-]</label><label class="expand" for="c-39559850">[4 more]</label></div><br/><div class="children"><div class="content">Yes, it should, but it looks like they just added a line to the jxl 0.10 series of data on whatever they used to make the graph, and labelled it the Pareto front. Looking closely at the graphs, they actually miss some points where version 0.9 should be included in the frontier.</div><br/><div id="39560015" class="c"><input type="checkbox" id="c-39560015" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39559850">parent</a><span>|</span><a href="#39560135">next</a><span>|</span><label class="collapse" for="c-39560015">[-]</label><label class="expand" for="c-39560015">[3 more]</label></div><br/><div class="children"><div class="content">I think it can be understood as an expected Pareto frontier <i>if enough options are added to make it continuous</i>, which is often implied in this kind of discussions.</div><br/><div id="39560616" class="c"><input type="checkbox" id="c-39560616" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39560015">parent</a><span>|</span><a href="#39560135">next</a><span>|</span><label class="collapse" for="c-39560616">[-]</label><label class="expand" for="c-39560616">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that&#x27;s reasonable - The effort parameters are integers between 1 and 10, with behavior described here: <a href="https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;encode_effort.md">https:&#x2F;&#x2F;github.com&#x2F;libjxl&#x2F;libjxl&#x2F;blob&#x2F;main&#x2F;doc&#x2F;encode_effort...</a>, the intermediate options don&#x27;t exist as implemented programs. This is a comparison of concrete programs, not an attempt to analyze the best theoretically achievable.<p>Also, the frontier isn&#x27;t convex, so it&#x27;s unlikely that if intermediate options could be added then they would all be at least as good as the lines shown; and the use of log(speed) for the y-axis affects what a straight line on the graph means. It&#x27;s fine for giving a good view of the dataset, but if you&#x27;re going to make a guess about intermediate possibilities, &#x27;speed&#x27; or &#x27;time&#x27; should also be considered.</div><br/><div id="39561120" class="c"><input type="checkbox" id="c-39561120" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39560616">parent</a><span>|</span><a href="#39560135">next</a><span>|</span><label class="collapse" for="c-39561120">[-]</label><label class="expand" for="c-39561120">[1 more]</label></div><br/><div class="children"><div class="content">You are right, but that would make an uglier plot :)<p>Some of the intermediate options are available though, through various more fine-grained encoder settings than what is exposed via the overall effort setting. Of course they will not fall exactly on the line that was drawn, but as a first approximation, the line is probably closer to the truth than the staircase, which would be an underestimate of what can be done.</div><br/></div></div></div></div></div></div></div></div><div id="39560135" class="c"><input type="checkbox" id="c-39560135" checked=""/><div class="controls bullet"><span class="by">jamesthurley</span><span>|</span><a href="#39559716">parent</a><span>|</span><a href="#39559850">prev</a><span>|</span><a href="#39568792">next</a><span>|</span><label class="collapse" for="c-39560135">[-]</label><label class="expand" for="c-39560135">[4 more]</label></div><br/><div class="children"><div class="content">Perpendicular to which axis?</div><br/><div id="39560631" class="c"><input type="checkbox" id="c-39560631" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39560135">parent</a><span>|</span><a href="#39568792">next</a><span>|</span><label class="collapse" for="c-39560631">[-]</label><label class="expand" for="c-39560631">[3 more]</label></div><br/><div class="children"><div class="content">both - staircase style.</div><br/><div id="39563048" class="c"><input type="checkbox" id="c-39563048" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39560631">parent</a><span>|</span><a href="#39568792">next</a><span>|</span><label class="collapse" for="c-39563048">[-]</label><label class="expand" for="c-39563048">[2 more]</label></div><br/><div class="children"><div class="content">Good grief. A poorly phrased question, and an answer that doesn&#x27;t narrow the possibilities.<p><pre><code>        *
        |
        |
        |
  *-----+
</code></pre>
or<p><pre><code>  +-----*
  |
  |
  |
  *
</code></pre>
… and why?</div><br/><div id="39566005" class="c"><input type="checkbox" id="c-39566005" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559716">root</a><span>|</span><a href="#39563048">parent</a><span>|</span><a href="#39568792">next</a><span>|</span><label class="collapse" for="c-39566005">[-]</label><label class="expand" for="c-39566005">[1 more]</label></div><br/><div class="children"><div class="content">Whichever is more pessimistic. So for the axes in this article, the first one. If you have an option on the &quot;bad&quot; side of the Pareto curve, you can always find an option that is better in both axes. If a new option is discovered that falls on the good side of the curve, well, then the curve needs to be updated to pass thru that new option.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39568792" class="c"><input type="checkbox" id="c-39568792" checked=""/><div class="controls bullet"><span class="by">jshier</span><span>|</span><a href="#39559716">prev</a><span>|</span><a href="#39559882">next</a><span>|</span><label class="collapse" for="c-39568792">[-]</label><label class="expand" for="c-39568792">[4 more]</label></div><br/><div class="children"><div class="content">I have an existing workflow where I take JPEGs (giant PNGs) from designers and reencode them using mozjpeg. However, I can&#x27;t find a way to invoke jpegli tool in the same way, especially since it seems to just be part of the jpeg-xl tool? Is that right? Are there any sample invocations anywhere?</div><br/><div id="39568890" class="c"><input type="checkbox" id="c-39568890" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#39568792">parent</a><span>|</span><a href="#39559882">next</a><span>|</span><label class="collapse" for="c-39568890">[-]</label><label class="expand" for="c-39568890">[3 more]</label></div><br/><div class="children"><div class="content">You should be able to use the `cjpegli` command the same way you&#x27;d use cjxl.  The simplest invocation would be `cjpegli input.png output.jpg`</div><br/><div id="39570618" class="c"><input type="checkbox" id="c-39570618" checked=""/><div class="controls bullet"><span class="by">jshier</span><span>|</span><a href="#39568792">root</a><span>|</span><a href="#39568890">parent</a><span>|</span><a href="#39569756">next</a><span>|</span><label class="collapse" for="c-39570618">[-]</label><label class="expand" for="c-39570618">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. It seems the macOS release is a bit behind on brew (0.9.1) and doesn&#x27;t include the cjpegli tool yet.</div><br/></div></div><div id="39569756" class="c"><input type="checkbox" id="c-39569756" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39568792">root</a><span>|</span><a href="#39568890">parent</a><span>|</span><a href="#39570618">prev</a><span>|</span><a href="#39559882">next</a><span>|</span><label class="collapse" for="c-39569756">[-]</label><label class="expand" for="c-39569756">[1 more]</label></div><br/><div class="children"><div class="content">Or replace&#x2F;ldconfig the jpeg library with the jpegli library. It is API&#x2F;ABI compatible with libjpeg-turbo and mozjpeg.</div><br/></div></div></div></div></div></div><div id="39559882" class="c"><input type="checkbox" id="c-39559882" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39568792">prev</a><span>|</span><a href="#39559742">next</a><span>|</span><label class="collapse" for="c-39559882">[-]</label><label class="expand" for="c-39559882">[1 more]</label></div><br/><div class="children"><div class="content">Welcome efficiency improvements<p>And in general, Jon&#x27;s posts provide a pretty good overview on the topic of codec comparison<p>Pity such a great format is being held back by the much less rigorous reviews</div><br/></div></div><div id="39559742" class="c"><input type="checkbox" id="c-39559742" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559882">prev</a><span>|</span><a href="#39559759">next</a><span>|</span><label class="collapse" for="c-39559742">[-]</label><label class="expand" for="c-39559742">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised mozjpeg performed worse than libjpeg-turbo at high quality settings. I thought its aim was having better pq than libjpeg-turbo at the expense of speed.</div><br/><div id="39561992" class="c"><input type="checkbox" id="c-39561992" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559742">parent</a><span>|</span><a href="#39559759">next</a><span>|</span><label class="collapse" for="c-39561992">[-]</label><label class="expand" for="c-39561992">[1 more]</label></div><br/><div class="children"><div class="content">It is consistent to what I have seen. Both in metrics and in eyeballing. Mozjpeg gives good results around quality 75, but less good at 90+++</div><br/></div></div></div></div><div id="39559759" class="c"><input type="checkbox" id="c-39559759" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#39559742">prev</a><span>|</span><a href="#39564140">next</a><span>|</span><label class="collapse" for="c-39559759">[-]</label><label class="expand" for="c-39559759">[12 more]</label></div><br/><div class="children"><div class="content">This is really impressive even compared to WebP. And unlike WebP, it&#x27;s backwards compatible.<p>I have forever associated Webp with macroblocky, poor colors, and a general ungraceful degradation that doesn&#x27;t really happen the same way even with old JPEG.<p>I am gonna go look at the complexity of the JXL decoder vs WebP. Curious if it&#x27;s even practical to decode on embedded. JPEG is easily decodable, and you can do it in small pieces at a time to work within memory constraints.</div><br/><div id="39562895" class="c"><input type="checkbox" id="c-39562895" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559759">parent</a><span>|</span><a href="#39563168">next</a><span>|</span><label class="collapse" for="c-39562895">[-]</label><label class="expand" for="c-39562895">[9 more]</label></div><br/><div class="children"><div class="content">Everyone hates WebP because when you save it, nothing can open it.<p>That&#x27;s improved somewhat, but the formats that will have an easy time winning are the ones that people can use, even if that means a browser should &quot;save JPGXL as JPEG&quot; for awhile or something.</div><br/><div id="39563063" class="c"><input type="checkbox" id="c-39563063" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39562895">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39563063">[-]</label><label class="expand" for="c-39563063">[6 more]</label></div><br/><div class="children"><div class="content">Everyone hates webp for a different reason. I hate it because it can only do 4:2:0 chroma, except in lossless mode. Lossless WebP is better than PNG, but I will take the peace of mind of knowing PNG is always lossless over having a WebP and not knowing what was done to it.</div><br/><div id="39563258" class="c"><input type="checkbox" id="c-39563258" checked=""/><div class="controls bullet"><span class="by">149765</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39563063">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39563258">[-]</label><label class="expand" for="c-39563258">[5 more]</label></div><br/><div class="children"><div class="content">&gt; peace of mind of knowing PNG is always lossless<p>There is pngquant:<p>&gt; a command-line utility and a library for lossy compression of PNG images.</div><br/><div id="39563382" class="c"><input type="checkbox" id="c-39563382" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39563258">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39563382">[-]</label><label class="expand" for="c-39563382">[4 more]</label></div><br/><div class="children"><div class="content">You also have things like <a href="https:&#x2F;&#x2F;tinypng.com" rel="nofollow">https:&#x2F;&#x2F;tinypng.com</a> which do (basically) lossy PNG for you. Works pretty well.</div><br/><div id="39566543" class="c"><input type="checkbox" id="c-39566543" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39563382">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39566543">[-]</label><label class="expand" for="c-39566543">[3 more]</label></div><br/><div class="children"><div class="content">Neither of these are really what I&#x27;m referring to, as I view these as ~equivalent to converting a jpeg to png. What I mean is within a pipeline, once you have ingested a [png|webp|jpeg] and you need to now render it at various sizes or with various filters for $purposes. If you have a png, you know that you should always maintain losslessness. If you have a jpeg, you know you don&#x27;t. You don&#x27;t need to inspect the file or store additional metadata, the extension alone tells you what you need to know. But when you have a webp, the default assumption is that it&#x27;s lossy but it <i>can</i> sometimes be otherwise.</div><br/><div id="39566651" class="c"><input type="checkbox" id="c-39566651" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39566543">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39566651">[-]</label><label class="expand" for="c-39566651">[2 more]</label></div><br/><div class="children"><div class="content">Actually, if you already have loss, you should try as hard as possible to avoid further loss.</div><br/><div id="39566839" class="c"><input type="checkbox" id="c-39566839" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39566651">parent</a><span>|</span><a href="#39566525">next</a><span>|</span><label class="collapse" for="c-39566839">[-]</label><label class="expand" for="c-39566839">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, in principle. But if I have a lossy 28MP jpeg, I&#x27;m not going to encode it as a lossless thumbnail (or other scaled-down version).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39566525" class="c"><input type="checkbox" id="c-39566525" checked=""/><div class="controls bullet"><span class="by">mfkp</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39562895">parent</a><span>|</span><a href="#39563063">prev</a><span>|</span><a href="#39566020">next</a><span>|</span><label class="collapse" for="c-39566525">[-]</label><label class="expand" for="c-39566525">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed in chrome-based browsers, you can right click on a webp file and &quot;edit image&quot;. When you save it, it defaults to png download, which makes a simple conversion.<p>Mobile browsers seem to default to downloading in png as well.</div><br/></div></div><div id="39566020" class="c"><input type="checkbox" id="c-39566020" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39562895">parent</a><span>|</span><a href="#39566525">prev</a><span>|</span><a href="#39563168">next</a><span>|</span><label class="collapse" for="c-39566020">[-]</label><label class="expand" for="c-39566020">[1 more]</label></div><br/><div class="children"><div class="content">I think JXL has been seeing adoption by apps faster than Webp or AVIF.</div><br/></div></div></div></div><div id="39563168" class="c"><input type="checkbox" id="c-39563168" checked=""/><div class="controls bullet"><span class="by">CharlesW</span><span>|</span><a href="#39559759">parent</a><span>|</span><a href="#39562895">prev</a><span>|</span><a href="#39564140">next</a><span>|</span><label class="collapse" for="c-39563168">[-]</label><label class="expand" for="c-39563168">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>And unlike WebP, it&#x27;s backwards compatible.</i><p>No, JPEG XL files can&#x27;t be viewed&#x2F;decoded by software or devices that don&#x27;t have a JPEG XL decoder.</div><br/><div id="39563818" class="c"><input type="checkbox" id="c-39563818" checked=""/><div class="controls bullet"><span class="by">Zardoz84</span><span>|</span><a href="#39559759">root</a><span>|</span><a href="#39563168">parent</a><span>|</span><a href="#39564140">next</a><span>|</span><label class="collapse" for="c-39563818">[-]</label><label class="expand" for="c-39563818">[1 more]</label></div><br/><div class="children"><div class="content">JPEG XL can be converted to&#x2F;from JPEG without any loss of quality. See another commenter where shows a example where doing JPEG -&gt; JPEG XL -&gt; JPEG generates a binary exact copy of the original JPEG.<p>Yeah, this not means what usually we call backwards compatibility, but allows usage like storing the images as JPEG XL and, on the fly, send a JPEG to clients that can&#x27;t use it, without any loss of information. WebP can&#x27;t do that.</div><br/></div></div></div></div></div></div><div id="39564140" class="c"><input type="checkbox" id="c-39564140" checked=""/><div class="controls bullet"><span class="by">sandstrom</span><span>|</span><a href="#39559759">prev</a><span>|</span><a href="#39559908">next</a><span>|</span><label class="collapse" for="c-39564140">[-]</label><label class="expand" for="c-39564140">[1 more]</label></div><br/><div class="children"><div class="content">JPEG XL is awesome!<p>One thing I think would help with its adoption, is if they would work with e.g. the libvips team to better implement it.<p>For example, streaming encoder and streaming decoder would be the preferred integration method in libvips.</div><br/></div></div><div id="39559908" class="c"><input type="checkbox" id="c-39559908" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#39564140">prev</a><span>|</span><a href="#39560941">next</a><span>|</span><label class="collapse" for="c-39559908">[-]</label><label class="expand" for="c-39559908">[2 more]</label></div><br/><div class="children"><div class="content">Pretty good article, though I would have used oxipng instead of optipng in the lossless comparisons, it&#x27;s the new standard, there.</div><br/><div id="39566443" class="c"><input type="checkbox" id="c-39566443" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559908">parent</a><span>|</span><a href="#39560941">next</a><span>|</span><label class="collapse" for="c-39566443">[-]</label><label class="expand" for="c-39566443">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the suggestion, oxipng is indeed a better choice. Next time I will add it to the plots!</div><br/></div></div></div></div><div id="39560941" class="c"><input type="checkbox" id="c-39560941" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#39559908">prev</a><span>|</span><a href="#39559875">next</a><span>|</span><label class="collapse" for="c-39560941">[-]</label><label class="expand" for="c-39560941">[2 more]</label></div><br/><div class="children"><div class="content">Wow, that new jpegli encoder. Just wow. Look at those results. Haha, JPEG has many years left still.</div><br/><div id="39561660" class="c"><input type="checkbox" id="c-39561660" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39560941">parent</a><span>|</span><a href="#39559875">next</a><span>|</span><label class="collapse" for="c-39561660">[-]</label><label class="expand" for="c-39561660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; JPEG has many years left still<p>Such a shame arithmetic coding (which is already in the standard) isn&#x27;t widely supported in the real world. Because converting Huffman coded images losslessly to arithmetic coding provides an <i>easy</i> 5-10% size advantage in my tests.<p>Alien technology from the future indeed.</div><br/></div></div></div></div><div id="39559875" class="c"><input type="checkbox" id="c-39559875" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#39560941">prev</a><span>|</span><a href="#39567044">next</a><span>|</span><label class="collapse" for="c-39559875">[-]</label><label class="expand" for="c-39559875">[11 more]</label></div><br/><div class="children"><div class="content">How is lossless webp 0.6th of the size of lossless avif? I find it hard to believe that.</div><br/><div id="39560904" class="c"><input type="checkbox" id="c-39560904" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#39559875">parent</a><span>|</span><a href="#39560798">next</a><span>|</span><label class="collapse" for="c-39560904">[-]</label><label class="expand" for="c-39560904">[2 more]</label></div><br/><div class="children"><div class="content">WebP is awesome at lossless and way better than even PNG.<p>It&#x27;s because WebP has a special encoding pipeline for lossless pictures (just like PNG) while AVIF is basically just asking a lossy encoder originally designed for video content to stop losing detail. Since it&#x27;s not designed for that it&#x27;s terrible for the job, taking lots of time and resources to produce a worse result.</div><br/><div id="39569135" class="c"><input type="checkbox" id="c-39569135" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39560904">parent</a><span>|</span><a href="#39560798">next</a><span>|</span><label class="collapse" for="c-39569135">[-]</label><label class="expand" for="c-39569135">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and way better than even PNG.<p>I mean it&#x27;s kinda hard to be worse than just shoving a bitmap through zlib...</div><br/></div></div></div></div><div id="39560798" class="c"><input type="checkbox" id="c-39560798" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559875">parent</a><span>|</span><a href="#39560904">prev</a><span>|</span><a href="#39560277">next</a><span>|</span><label class="collapse" for="c-39560798">[-]</label><label class="expand" for="c-39560798">[6 more]</label></div><br/><div class="children"><div class="content">Lossless AVIF is just really quite bad. Notice that how for photographic content, it is barely better than PNG, and for non-photographic content, it is far worse than PNG.</div><br/><div id="39561088" class="c"><input type="checkbox" id="c-39561088" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39560798">parent</a><span>|</span><a href="#39560277">next</a><span>|</span><label class="collapse" for="c-39561088">[-]</label><label class="expand" for="c-39561088">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so bad you wonder why AV1 even has a lossless mode. Maybe lossy mode has some subimages it uses lossless mode on?</div><br/><div id="39561139" class="c"><input type="checkbox" id="c-39561139" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39561088">parent</a><span>|</span><a href="#39560277">next</a><span>|</span><label class="collapse" for="c-39561139">[-]</label><label class="expand" for="c-39561139">[4 more]</label></div><br/><div class="children"><div class="content">It has lossless just to check a box in terms of supported features. A bit like how JPEG XL supports animation just to have feature parity. But in most cases, you&#x27;ll be better off using a video codec for animation, and an image format for images.</div><br/><div id="39561709" class="c"><input type="checkbox" id="c-39561709" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39561139">parent</a><span>|</span><a href="#39561604">next</a><span>|</span><label class="collapse" for="c-39561709">[-]</label><label class="expand" for="c-39561709">[1 more]</label></div><br/><div class="children"><div class="content">I believe it is more fundamental. I like to think that AV1 entropy coding just becomes ineffective for large values. Large values are dominantly present in high quality photography and in lossless coding. Large values are repeatedly prefix coded and this makes effective adaptation of the statistics difficult for large integers. This is a fundamental difference and not a minor difference in focus.</div><br/></div></div><div id="39561604" class="c"><input type="checkbox" id="c-39561604" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39561139">parent</a><span>|</span><a href="#39561709">prev</a><span>|</span><a href="#39560277">next</a><span>|</span><label class="collapse" for="c-39561604">[-]</label><label class="expand" for="c-39561604">[2 more]</label></div><br/><div class="children"><div class="content">There are some user-level differences between an animated image and a video, which haven&#x27;t really been satisfactorily resolved since the abandonment of GIF-the-format. An animated image should pause when clicked, and start again on another click, with setting separate from video autoplay to control the default. It should <i>not</i> have visible controls of any sort, that&#x27;s the whole interface. It should save and display on the computer&#x2F;filesystem as an image, and degrade to the display frame when sent along a channel which supports images but not animated ones. It doesn&#x27;t need sound, or CC, or subtitles. I should be able to add it to the photo roll on my phone if I want.<p>There are a lot of little considerations like this, and it would be well if the industry consolidated around an animated-image standard, one which was an image, and not a video embedded in a way which looks like an image.</div><br/><div id="39561972" class="c"><input type="checkbox" id="c-39561972" checked=""/><div class="controls bullet"><span class="by">F3nd0</span><span>|</span><a href="#39559875">root</a><span>|</span><a href="#39561604">parent</a><span>|</span><a href="#39560277">next</a><span>|</span><label class="collapse" for="c-39561972">[-]</label><label class="expand" for="c-39561972">[1 more]</label></div><br/><div class="children"><div class="content">Hence why AVIF might come in handy after all!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39560277" class="c"><input type="checkbox" id="c-39560277" checked=""/><div class="controls bullet"><span class="by">149765</span><span>|</span><a href="#39559875">parent</a><span>|</span><a href="#39560798">prev</a><span>|</span><a href="#39561692">next</a><span>|</span><label class="collapse" for="c-39560277">[-]</label><label class="expand" for="c-39560277">[1 more]</label></div><br/><div class="children"><div class="content">Lossless webp is actually quite good, especially on text heavy images, e.g. screenshots of a terminal with `cwebp -z9` are usually smaller than `jxl -d 0 -e 9` in my experience.</div><br/></div></div><div id="39561692" class="c"><input type="checkbox" id="c-39561692" checked=""/><div class="controls bullet"><span class="by">derf_</span><span>|</span><a href="#39559875">parent</a><span>|</span><a href="#39560277">prev</a><span>|</span><a href="#39567044">next</a><span>|</span><label class="collapse" for="c-39561692">[-]</label><label class="expand" for="c-39561692">[1 more]</label></div><br/><div class="children"><div class="content">Usually the issue is not using the YCgCo-R colorspace. I do not see enough details in the article to know if that is the case here. There are politics around getting the codepoint included: <a href="https:&#x2F;&#x2F;github.com&#x2F;AOMediaCodec&#x2F;av1-avif&#x2F;issues&#x2F;129">https:&#x2F;&#x2F;github.com&#x2F;AOMediaCodec&#x2F;av1-avif&#x2F;issues&#x2F;129</a></div><br/></div></div></div></div><div id="39567044" class="c"><input type="checkbox" id="c-39567044" checked=""/><div class="controls bullet"><span class="by">redder23</span><span>|</span><a href="#39559875">prev</a><span>|</span><a href="#39567030">next</a><span>|</span><label class="collapse" for="c-39567044">[-]</label><label class="expand" for="c-39567044">[1 more]</label></div><br/><div class="children"><div class="content">AVIF looks better here: JPEG XL looks very blurred out on the bottom with high compression. AVIF preserves much more detail and sharpness.<p><a href="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;jon&#x2F;qp-low.png" rel="nofollow">https:&#x2F;&#x2F;res.cloudinary.com&#x2F;jon&#x2F;qp-low.png</a></div><br/></div></div><div id="39567030" class="c"><input type="checkbox" id="c-39567030" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39567044">prev</a><span>|</span><a href="#39561082">next</a><span>|</span><label class="collapse" for="c-39567030">[-]</label><label class="expand" for="c-39567030">[1 more]</label></div><br/><div class="children"><div class="content">The choice to represent the speed based on multithreaded encoding strikes me as somewhat arbitrary. If your software has a critical path dependent on minimal latency of a single image, then it makes some sense, but you still may have more or fewer than 8 cores. On the other hand if you have another source of parallelism, for example you are encoding a library of images, then it is quite irrelevant. I think the fine data in the article would be even more useful if the single threaded speed and the scalability of the codec were treated separately.</div><br/></div></div><div id="39561082" class="c"><input type="checkbox" id="c-39561082" checked=""/><div class="controls bullet"><span class="by">dancemethis</span><span>|</span><a href="#39567030">prev</a><span>|</span><a href="#39567420">next</a><span>|</span><label class="collapse" for="c-39561082">[-]</label><label class="expand" for="c-39561082">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Pareto&quot; being used outside the context of Brazil&#x27;s best prank call ever (Telerj Prank) will always confuse me. I keep thinking, &quot;what does the &#x27;thin-voiced lawyer&#x27; have to do with statistics?&quot;...</div><br/></div></div><div id="39567420" class="c"><input type="checkbox" id="c-39567420" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#39561082">prev</a><span>|</span><a href="#39559590">next</a><span>|</span><label class="collapse" for="c-39567420">[-]</label><label class="expand" for="c-39567420">[6 more]</label></div><br/><div class="children"><div class="content">The problem with JPEG XL is that it is written in an unsafe language and has already had several memory safety vulnerabilities found in it.<p>Image codecs are used in a wide range of attacker-controlled scenarios and need to be completely safe.<p>I know Rust advocates sound like a broken record, but this is the poster child for a library that should never have been even started in C++ in the first place.<p>It’s absolute insanity that we write codecs — pure functions — in an unsafe language that has a compiler that defaults to “anything goes” as an optimisation technique.</div><br/><div id="39567524" class="c"><input type="checkbox" id="c-39567524" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39567420">parent</a><span>|</span><a href="#39559590">next</a><span>|</span><label class="collapse" for="c-39567524">[-]</label><label class="expand" for="c-39567524">[5 more]</label></div><br/><div class="children"><div class="content">Pretty much every codec in every browser is written in an unsafe language, unfortunately. I don&#x27;t see why JXL should be singled out. On the other hand, there is a JXL decoder in Rust called jxl-oxide [1] which works quite well, and has been confirmed by JPEG as conformant. Hopefully it will be adopted for decode-only usecases.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;tirr-c&#x2F;jxl-oxide&#x2F;pull&#x2F;267">https:&#x2F;&#x2F;github.com&#x2F;tirr-c&#x2F;jxl-oxide&#x2F;pull&#x2F;267</a><p>&gt; It’s absolute insanity that we write codecs — pure functions — in an unsafe language that has a compiler that defaults to “anything goes” as an optimisation technique.<p>Rust and C++ are exactly the same in how they optimize, compilers for both assume that your code has zero UB. The difference is that Rust makes it much harder to accidentally have UB.</div><br/><div id="39568025" class="c"><input type="checkbox" id="c-39568025" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#39567420">root</a><span>|</span><a href="#39567524">parent</a><span>|</span><a href="#39559590">next</a><span>|</span><label class="collapse" for="c-39568025">[-]</label><label class="expand" for="c-39568025">[4 more]</label></div><br/><div class="children"><div class="content">&quot;We&#x27;ve never had to wear helmets before, why start now?&quot;<p>There are only a handful of image codecs that are widely accepted. Essentially just GIF, PNG, and JPG. There&#x27;s a smattering of support for more modern formats, but those three dominate.<p>Adding a <i>fourth</i> image format is increasing this attack surface by a substantial margin across a huge range of software. Not just web browsers, but chat apps, server software (thumbnail generators), editors, etc...<p>This is the kind of thing that gets baked into standard libraries, operating systems, and frameworks. It&#x27;s up there with JSON or XML.<p>You had better be <i>damned</i> sure what you&#x27;re doing is not going to cause a long list of CVEs!<p>JPEG XL is a <i>complex</i> codec, with a lot of code. This increases the chance of bugs and increases the attack surface.<p>A (surprisingly!) good metric for complexity is the size of the zip file of the code. Libjpeg is something like 360 kB, libpng is 350 kB, and giflib is 90 kB.<p>The JXL source is 1.4 MB zipped, making more than twice the size of the above three combined!<p>The other libraries use C&#x2F;C++ not because that&#x27;s a better choice, but because it was the <i>only</i> choice back in the ... <i>checks Wikipedia</i> ... 1980s and 90s!<p>We live in the future. We have memory-safe languages now. We&#x27;re allowed to use them. You won&#x27;t get in trouble from anyone, I promise.</div><br/><div id="39568287" class="c"><input type="checkbox" id="c-39568287" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39567420">root</a><span>|</span><a href="#39568025">parent</a><span>|</span><a href="#39569781">next</a><span>|</span><label class="collapse" for="c-39568287">[-]</label><label class="expand" for="c-39568287">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;We&#x27;ve never had to wear helmets before, why start now?&quot;<p>&gt; We live in the future. We have memory-safe languages now. We&#x27;re allowed to use them. You won&#x27;t get in trouble from anyone, I promise.<p>That&#x27;s why I specifically said that it&#x27;s unfortunate that C++ is still wide spread, and pointed to a fully conformant JXL decoder written in Rust :p<p>&gt; There are only a handful of image codecs that are widely accepted. Essentially just GIF, PNG, and JPG. There&#x27;s a smattering of support for more modern formats, but those three dominate.<p>Every browser ships libwebp and an AVIF decoder. Every reasonably recent Android phone does as well. And every iPhone. Every (regular) install of Windows has libwebp. Every Mac has libwebp and dav1d. That&#x27;s all C++. AVIF in particular is only a couple of years older than JXL, and yet I&#x27;ve never seen opposition to it on the grounds of memory safety. That is what I meant about JXL being singled out.<p>&gt; JPEG XL is a complex codec, with a lot of code. This increases the chance of bugs and increases the attack surface.<p>&gt; A (surprisingly!) good metric for complexity is the size of the zip file of the code. Libjpeg is something like 360 kB, libpng is 350 kB, and giflib is 90 kB.<p>&gt; The JXL source is 1.4 MB zipped, making it nearly twice the size than all of the above combined.<p>Which code exactly are you including in that? The libjxl repo has a lot of stuff in it, including an entire brand new JPEG encoder! Though jxl certainly is more complex than those three combined, since JXL is essentially a superset of all their functionality, plus new stuff.</div><br/><div id="39568484" class="c"><input type="checkbox" id="c-39568484" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#39567420">root</a><span>|</span><a href="#39568287">parent</a><span>|</span><a href="#39569781">next</a><span>|</span><label class="collapse" for="c-39568484">[-]</label><label class="expand" for="c-39568484">[1 more]</label></div><br/><div class="children"><div class="content">I revised my numbers a bit by filtering out the junk and focusing only on the code that most likely contributes to the runtime components (where the security risks lie). E.g.: Excluded the samples, test suites, doco, changelogs, etc... and kept mostly just the C&#x2F;C++ and assembly code.<p>I also recompressed all of the libraries with identical settings to make the numbers more consistent.</div><br/></div></div></div></div><div id="39569781" class="c"><input type="checkbox" id="c-39569781" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39567420">root</a><span>|</span><a href="#39568025">parent</a><span>|</span><a href="#39568287">prev</a><span>|</span><a href="#39559590">next</a><span>|</span><label class="collapse" for="c-39569781">[-]</label><label class="expand" for="c-39569781">[1 more]</label></div><br/><div class="children"><div class="content">I believe JPEG XL binary size is about one third of AVIF binary size. It is relatively compact. It is easy to write a small encoder: libjxl-tiny is just 7000 lines of code.</div><br/></div></div></div></div></div></div></div></div><div id="39559590" class="c"><input type="checkbox" id="c-39559590" checked=""/><div class="controls bullet"><span class="by">mikae1</span><span>|</span><a href="#39567420">prev</a><span>|</span><label class="collapse" for="c-39559590">[-]</label><label class="expand" for="c-39559590">[85 more]</label></div><br/><div class="children"><div class="content">If only Google could be convinced to adopt this marvelous codec... Not looking super positive at the moment:<p><a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40270698" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40270698</a><p><a href="https:&#x2F;&#x2F;bugs.chromium.org&#x2F;p&#x2F;chromium&#x2F;issues&#x2F;detail?id=1451807&amp;no_tracker_redirect=1" rel="nofollow">https:&#x2F;&#x2F;bugs.chromium.org&#x2F;p&#x2F;chromium&#x2F;issues&#x2F;detail?id=145180...</a></div><br/><div id="39559705" class="c"><input type="checkbox" id="c-39559705" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39559590">parent</a><span>|</span><a href="#39559703">next</a><span>|</span><label class="collapse" for="c-39559705">[-]</label><label class="expand" for="c-39559705">[40 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t &quot;lose interest&quot;, their lawyers pulled the emergency brakes. Blame patent holders, not Google. Like Microsoft: <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;17&#x2F;microsoft_ans_patent&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;17&#x2F;microsoft_ans_patent&#x2F;</a>.  Microsoft could probably be convinced to be reasonable. But there may be a few others. Google actually also holds some patents over this but they&#x27;ve done the right thing and license those patents along with their implementation.<p>To fix this, you&#x27;d need to convince Google, and other large companies that would be exposed to law suits related to these patents (Apple, Adobe, etc.), that these patent holders are not going to insist on being compensated.<p>Other formats are less risky; especially the older ones. Jpeg is fine because it&#x27;s been out there for so long that any patents applicable to it have long expired. Same with GIF, which once was held up by patents. Png is at this point also fine. If any patents applied at all they will soon have expired as the PNG standard dates back to 1997 and work on it depended on research from the seventies and eighties.</div><br/><div id="39560637" class="c"><input type="checkbox" id="c-39560637" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39559761">next</a><span>|</span><label class="collapse" for="c-39560637">[-]</label><label class="expand" for="c-39560637">[4 more]</label></div><br/><div class="children"><div class="content">There are no royalties to be paid on JPEG XL. Nobody but Cloudinary and Google is claiming to hold relevant patents, and Cloudinary and Google have provided a royalty free license. Of course the way the patent system works, anything less than 20 years old is theoretically risky. But so far, there is nobody claiming royalties need to be paid on JPEG XL, so it is similar to WebP in that regard.</div><br/><div id="39563244" class="c"><input type="checkbox" id="c-39563244" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560637">parent</a><span>|</span><a href="#39559761">next</a><span>|</span><label class="collapse" for="c-39563244">[-]</label><label class="expand" for="c-39563244">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Patent issues&quot; has become a (sometimes truthful) excuse for not doing something.<p>When the big boys <i>want</i> to do something, they find a way to get it done, patents or no, especially if there&#x27;s only &quot;fear of patents&quot; - see Apple and the whole watch fiasco.</div><br/><div id="39570219" class="c"><input type="checkbox" id="c-39570219" checked=""/><div class="controls bullet"><span class="by">mikae1</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39563244">parent</a><span>|</span><a href="#39559761">next</a><span>|</span><label class="collapse" for="c-39570219">[-]</label><label class="expand" for="c-39570219">[2 more]</label></div><br/><div class="children"><div class="content">Patents was not the latest excuse I heard from Google. Their explanation was security concerns.</div><br/><div id="39570677" class="c"><input type="checkbox" id="c-39570677" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39570219">parent</a><span>|</span><a href="#39559761">next</a><span>|</span><label class="collapse" for="c-39570677">[-]</label><label class="expand" for="c-39570677">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a link? Or was it a private communication?</div><br/></div></div></div></div></div></div></div></div><div id="39559761" class="c"><input type="checkbox" id="c-39559761" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39560637">prev</a><span>|</span><a href="#39560678">next</a><span>|</span><label class="collapse" for="c-39559761">[-]</label><label class="expand" for="c-39559761">[8 more]</label></div><br/><div class="children"><div class="content">&gt; [...] other large companies that would be exposed to law suits related to these patents (Apple, Adobe, etc.) [...]<p>Adobe included JPEG XL support to their products and also the DNG specification. So that argument is pretty much dead, no?</div><br/><div id="39560300" class="c"><input type="checkbox" id="c-39560300" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559761">parent</a><span>|</span><a href="#39559942">next</a><span>|</span><label class="collapse" for="c-39560300">[-]</label><label class="expand" for="c-39560300">[1 more]</label></div><br/><div class="children"><div class="content">Adobe also has an order of magnitude lower number of installed software than Chrome or Firefox which makes patent fees much cheaper. And their software is actually paid for by users.</div><br/></div></div><div id="39559942" class="c"><input type="checkbox" id="c-39559942" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559761">parent</a><span>|</span><a href="#39560300">prev</a><span>|</span><a href="#39561009">next</a><span>|</span><label class="collapse" for="c-39559942">[-]</label><label class="expand" for="c-39559942">[2 more]</label></div><br/><div class="children"><div class="content">Not that simple. Maybe they struck a deal with a few of the companies or they made a different risk calculation. And of course they have a pretty fierce patent portfolio themselves so there&#x27;s the notion of them being able to retaliate in kind to some of these companies.</div><br/><div id="39559979" class="c"><input type="checkbox" id="c-39559979" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559942">parent</a><span>|</span><a href="#39561009">next</a><span>|</span><label class="collapse" for="c-39559979">[-]</label><label class="expand" for="c-39559979">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s true (see my other comment for what the patent is really about), but even when it is, Adobe&#x27;s adoption means that JPEG XL is worth the supposed &quot;risk&quot;. And Google does ship a lot of technologies that are clearly patent-encumbered. If the patent is the main concern, they could have answered so because there are enough people wondering about the patent status, but the Chrome team&#x27;s main reason against JPEG XL was quite different.</div><br/></div></div></div></div><div id="39561009" class="c"><input type="checkbox" id="c-39561009" checked=""/><div class="controls bullet"><span class="by">luma</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559761">parent</a><span>|</span><a href="#39559942">prev</a><span>|</span><a href="#39560678">next</a><span>|</span><label class="collapse" for="c-39561009">[-]</label><label class="expand" for="c-39561009">[4 more]</label></div><br/><div class="children"><div class="content">Adobe sells paid products and can carve out a license fee for that, like they do with all the other codecs and libraries they bundle.  That&#x27;s part of the price you are paying.<p>Harder to do for users of Chrome.</div><br/><div id="39561071" class="c"><input type="checkbox" id="c-39561071" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561009">parent</a><span>|</span><a href="#39560678">next</a><span>|</span><label class="collapse" for="c-39561071">[-]</label><label class="expand" for="c-39561071">[3 more]</label></div><br/><div class="children"><div class="content">The same thing can be said with many patent-encumbered video codecs which Chrome does support nevertheless. That alone can&#x27;t be a major deciding factor, especially given that the rate of JPEG XL adoption has been remarkably faster than any recent media format.</div><br/><div id="39561240" class="c"><input type="checkbox" id="c-39561240" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561071">parent</a><span>|</span><a href="#39560678">next</a><span>|</span><label class="collapse" for="c-39561240">[-]</label><label class="expand" for="c-39561240">[2 more]</label></div><br/><div class="children"><div class="content">Is this not simply a risk vs reward calculation? Newer video codecs present a very notable bandwidth saving over old ones. JPEG XL presents minor benefits over WebP, AVIF, etc. So while the dangers are the same for both the calculation is different.</div><br/><div id="39561374" class="c"><input type="checkbox" id="c-39561374" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561240">parent</a><span>|</span><a href="#39560678">next</a><span>|</span><label class="collapse" for="c-39561374">[-]</label><label class="expand" for="c-39561374">[1 more]</label></div><br/><div class="children"><div class="content">Video = billions lower costs for Youtube.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39560678" class="c"><input type="checkbox" id="c-39560678" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39559761">prev</a><span>|</span><a href="#39560498">next</a><span>|</span><label class="collapse" for="c-39560678">[-]</label><label class="expand" for="c-39560678">[2 more]</label></div><br/><div class="children"><div class="content">The Microsoft patent doesn&#x27;t apply to JXL, and in any case, Microsoft has literally already affirmed that they will not use it to go after any open codec.</div><br/><div id="39563262" class="c"><input type="checkbox" id="c-39563262" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560678">parent</a><span>|</span><a href="#39560498">next</a><span>|</span><label class="collapse" for="c-39563262">[-]</label><label class="expand" for="c-39563262">[1 more]</label></div><br/><div class="children"><div class="content">How exactly is that done? I assume even an offhand comment by an official (like CEO, etc) that is not immediately walked back would at least protect people from damages associated with willful infringement.</div><br/></div></div></div></div><div id="39560498" class="c"><input type="checkbox" id="c-39560498" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39560678">prev</a><span>|</span><a href="#39559874">next</a><span>|</span><label class="collapse" for="c-39560498">[-]</label><label class="expand" for="c-39560498">[1 more]</label></div><br/><div class="children"><div class="content">That ANS patent supposedly relates to refining the coding tables based on symbols being decided.<p>It is slower for decoding and Jpeg xl does not do that for decoding speed reasons.<p>The specification doesn&#x27;t allow it. All coding tables need to be in final form.</div><br/></div></div><div id="39559874" class="c"><input type="checkbox" id="c-39559874" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39560498">prev</a><span>|</span><a href="#39560236">next</a><span>|</span><label class="collapse" for="c-39559874">[-]</label><label class="expand" for="c-39559874">[14 more]</label></div><br/><div class="children"><div class="content">&gt; their lawyers pulled the emergency brakes<p>Do you have source for that claim?</div><br/><div id="39559945" class="c"><input type="checkbox" id="c-39559945" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559874">parent</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39559945">[-]</label><label class="expand" for="c-39559945">[10 more]</label></div><br/><div class="children"><div class="content">Probably this: <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;17&#x2F;microsoft_ans_patent&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;17&#x2F;microsoft_ans_patent&#x2F;</a><p>I think it would be much better for everyone involved and humanity if Mr. Duda himself got the patent in the first place instead of praying no one else will.</div><br/><div id="39560757" class="c"><input type="checkbox" id="c-39560757" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559945">parent</a><span>|</span><a href="#39560803">next</a><span>|</span><label class="collapse" for="c-39560757">[-]</label><label class="expand" for="c-39560757">[1 more]</label></div><br/><div class="children"><div class="content">Duda published his ideas, that’s supposed to be it.</div><br/></div></div><div id="39560803" class="c"><input type="checkbox" id="c-39560803" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559945">parent</a><span>|</span><a href="#39560757">prev</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39560803">[-]</label><label class="expand" for="c-39560803">[8 more]</label></div><br/><div class="children"><div class="content">Prior art makes patents invalid anyway.</div><br/><div id="39560879" class="c"><input type="checkbox" id="c-39560879" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560803">parent</a><span>|</span><a href="#39561064">next</a><span>|</span><label class="collapse" for="c-39560879">[-]</label><label class="expand" for="c-39560879">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely.<p>And nothing advances your career quite like getting your employer into a multi-year legal battle and spending a few million on legal fees, to make some images 20% smaller and 100% less compatible.</div><br/><div id="39560944" class="c"><input type="checkbox" id="c-39560944" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560879">parent</a><span>|</span><a href="#39561064">next</a><span>|</span><label class="collapse" for="c-39560944">[-]</label><label class="expand" for="c-39560944">[1 more]</label></div><br/><div class="children"><div class="content">Well, lots of things other than JXL use ANS. If someone starts trying to claim ANS, you&#x27;ll have Apple, Disney, Facebook, and more, on your side :)</div><br/></div></div></div></div><div id="39561064" class="c"><input type="checkbox" id="c-39561064" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560803">parent</a><span>|</span><a href="#39560879">prev</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39561064">[-]</label><label class="expand" for="c-39561064">[5 more]</label></div><br/><div class="children"><div class="content">But that doesn&#x27;t matter. If a patent is granted, choosing to infringe on it is risky, even if you believe you could make a solid argument that it&#x27;s invalid given enough lawyer hours.</div><br/><div id="39561200" class="c"><input type="checkbox" id="c-39561200" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561064">parent</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39561200">[-]</label><label class="expand" for="c-39561200">[4 more]</label></div><br/><div class="children"><div class="content">The Microsoft patent is for an &quot;improvement&quot; that I don&#x27;t believe anyone is using, but Internet commentators seem to think it applies to ANS in general for some reason.<p>A few years earlier, Google was granted a patent for ANS in general, which made people very angry. Fortunately they never did anything with it.</div><br/><div id="39561347" class="c"><input type="checkbox" id="c-39561347" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561200">parent</a><span>|</span><a href="#39562153">next</a><span>|</span><label class="collapse" for="c-39561347">[-]</label><label class="expand" for="c-39561347">[1 more]</label></div><br/><div class="children"><div class="content">I believe that Google&#x27;s patent application dealt with interleaving non-compressed and ANS data in a manner that made streaming coding easy and fast in software, not a general ANS patent. I didn&#x27;t read it but discussed shortly about it with a capable engineer who had.</div><br/></div></div><div id="39562153" class="c"><input type="checkbox" id="c-39562153" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561200">parent</a><span>|</span><a href="#39561347">prev</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39562153">[-]</label><label class="expand" for="c-39562153">[2 more]</label></div><br/><div class="children"><div class="content">If the patent doesn&#x27;t apply to JXL then that&#x27;s a different story, then it doesn&#x27;t matter whether it&#x27;s valid or not.<p>...<p>The fact that Google <i>does</i> have a patent which covers JXL is worrying though. So JXL is patent encumbered after all.</div><br/><div id="39566292" class="c"><input type="checkbox" id="c-39566292" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39562153">parent</a><span>|</span><a href="#39559947">next</a><span>|</span><label class="collapse" for="c-39566292">[-]</label><label class="expand" for="c-39566292">[1 more]</label></div><br/><div class="children"><div class="content">I misrecalled. While the Google patent is a lot more general than the Microsoft one, it doesn&#x27;t apply to most uses of ANS.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39559947" class="c"><input type="checkbox" id="c-39559947" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559874">parent</a><span>|</span><a href="#39559945">prev</a><span>|</span><a href="#39560236">next</a><span>|</span><label class="collapse" for="c-39559947">[-]</label><label class="expand" for="c-39559947">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just inferring from the fact that MS got a patent and then this whole thing ground to a halt.</div><br/><div id="39561104" class="c"><input type="checkbox" id="c-39561104" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559947">parent</a><span>|</span><a href="#39560219">next</a><span>|</span><label class="collapse" for="c-39561104">[-]</label><label class="expand" for="c-39561104">[1 more]</label></div><br/><div class="children"><div class="content">Not only you have no source backing your claim, but there is a glaring counterexample. Chromium&#x27;s experimental JPEG XL support carried an expiry milestone, which was delayed multiple times and it was bumped last time on <i>June</i> 2022 [1] before the final removal on October, which was months later the patent was granted!<p>[1] <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40168998#comment52" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40168998#comment52</a></div><br/></div></div><div id="39560219" class="c"><input type="checkbox" id="c-39560219" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559947">parent</a><span>|</span><a href="#39561104">prev</a><span>|</span><a href="#39560236">next</a><span>|</span><label class="collapse" for="c-39560219">[-]</label><label class="expand" for="c-39560219">[1 more]</label></div><br/><div class="children"><div class="content">In other words, there&#x27;s no source.</div><br/></div></div></div></div></div></div><div id="39560236" class="c"><input type="checkbox" id="c-39560236" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39559874">prev</a><span>|</span><a href="#39560502">next</a><span>|</span><label class="collapse" for="c-39560236">[-]</label><label class="expand" for="c-39560236">[9 more]</label></div><br/><div class="children"><div class="content">&gt;To fix this, you&#x27;d need to convince Google, and other large companies that would be exposed to law suits related to these patents (Apple, Adobe, etc.), that these patent holders are not going to insist on being compensated.<p>Apple has implemented JPEG XL support in macOS and iOS. Adobe has also implemented support for JPEG XL in their products.<p>Also, if patents were the reason Google removed JXL from Chrome, why would they make up technical reasons for doing so?<p>Please don&#x27;t present unsourced conspiracy theories as if they were confirmed facts.</div><br/><div id="39560558" class="c"><input type="checkbox" id="c-39560558" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560236">parent</a><span>|</span><a href="#39560502">next</a><span>|</span><label class="collapse" for="c-39560558">[-]</label><label class="expand" for="c-39560558">[8 more]</label></div><br/><div class="children"><div class="content">You seem to be all over this. So, what&#x27;s your alternate theory?<p>I&#x27;ve not seen anything other than &quot;google is evil, boohoohoo&quot; in this thread. That&#x27;s a popular sentiment but it doesn&#x27;t make much sense in this context.<p>There must be a more rational reason than that. I&#x27;ve not heard anything better than legal reasons. But do correct me if I&#x27;m wrong. I&#x27;ve worked in big companies, and patents can be a show stopper. Seems like a plausible theory (i.e. not a conspiracy theory). We indeed don&#x27;t know what happened because Google is clearly not in a mood to share.</div><br/><div id="39560702" class="c"><input type="checkbox" id="c-39560702" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560558">parent</a><span>|</span><a href="#39560850">next</a><span>|</span><label class="collapse" for="c-39560702">[-]</label><label class="expand" for="c-39560702">[1 more]</label></div><br/><div class="children"><div class="content">Mate, you&#x27;re literally pulling something from your ass. Chrome engineers claim that they don&#x27;t want JXL because it isn&#x27;t good enough. Literally no one involved has said that it has anything to do with patents.</div><br/></div></div><div id="39560850" class="c"><input type="checkbox" id="c-39560850" checked=""/><div class="controls bullet"><span class="by">peppermint_gum</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560558">parent</a><span>|</span><a href="#39560702">prev</a><span>|</span><a href="#39560620">next</a><span>|</span><label class="collapse" for="c-39560850">[-]</label><label class="expand" for="c-39560850">[1 more]</label></div><br/><div class="children"><div class="content">&gt;There must be a more rational reason than that. I&#x27;ve not heard anything better than legal reasons. But do correct me if I&#x27;m wrong. I&#x27;ve worked in big companies, and patents can be a show stopper. Seems like a plausible theory (i.e. not a conspiracy theory)<p>In your first comment, you <i>stated as a fact</i> that &quot;lawyers pulled the emergency brakes&quot;. Despite literally no one from Google ever saying this, and Google giving very different reasons for the removal.<p>And now you act as if something you made up in your mind is the default theory and the burden of proof is on the people disagreeing with you.</div><br/></div></div><div id="39560620" class="c"><input type="checkbox" id="c-39560620" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560558">parent</a><span>|</span><a href="#39560850">prev</a><span>|</span><a href="#39565200">next</a><span>|</span><label class="collapse" for="c-39560620">[-]</label><label class="expand" for="c-39560620">[1 more]</label></div><br/><div class="children"><div class="content">If you want a simple conspiracy theory, how about this:<p>The person responsible for AVIF works on Chrome, and is responsible for choosing which codecs Chrome ships with. He obviously prefers his AVIF to a different team&#x27;s JPEG-XL.<p>It&#x27;s a case of simple selfish bias.</div><br/></div></div><div id="39565200" class="c"><input type="checkbox" id="c-39565200" checked=""/><div class="controls bullet"><span class="by">youngtaff</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560558">parent</a><span>|</span><a href="#39560620">prev</a><span>|</span><a href="#39560752">next</a><span>|</span><label class="collapse" for="c-39565200">[-]</label><label class="expand" for="c-39565200">[1 more]</label></div><br/><div class="children"><div class="content">People who look after Chrome’s media decoding are an awkward bunch, they point blank refuse to support &lt;img src=*.mp4 for example</div><br/></div></div><div id="39560752" class="c"><input type="checkbox" id="c-39560752" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560558">parent</a><span>|</span><a href="#39565200">prev</a><span>|</span><a href="#39560502">next</a><span>|</span><label class="collapse" for="c-39560752">[-]</label><label class="expand" for="c-39560752">[3 more]</label></div><br/><div class="children"><div class="content">Why not take Chrome&#x27;s word for it:<p>---cut---<p>Helping the web to evolve is challenging, and it requires us to make difficult choices. We&#x27;ve also heard from our browser and device partners that every additional format adds costs (monetary or hardware), and we’re very much aware that these costs are borne by those outside of Google. When we evaluate new media formats, the first question we have to ask is whether the format works best for the web. With respect to new image formats such as JPEG XL, that means we have to look comprehensively at many factors: compression performance across a broad range of images; is the decoder fast, allowing for speedy rendering of smaller images; are there fast encoders, ideally with hardware support, that keep encoding costs reasonable for large users; can we optimize existing formats to meet any new use-cases, rather than adding support for an additional format; do other browsers and OSes support it?<p>After weighing the data,  we’ve decided to stop Chrome’s JPEG XL experiment and remove the code associated with the experiment.  [...]<p>From: <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;blink-dev&#x2F;c&#x2F;WjCKcBw219k&#x2F;m&#x2F;xX-NnWtTBQAJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;blink-dev&#x2F;c&#x2F;WjCKc...</a></div><br/><div id="39561433" class="c"><input type="checkbox" id="c-39561433" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560752">parent</a><span>|</span><a href="#39560502">next</a><span>|</span><label class="collapse" for="c-39561433">[-]</label><label class="expand" for="c-39561433">[2 more]</label></div><br/><div class="children"><div class="content">I try to make a bulletin point list of the individual concerns, the original statement is written in a style that is a bit confusing for a non-native speaker such as me.<p>* Chrome&#x27;s browser partners say JPEG XL adds monetary or hardware costs.<p>* Chrome&#x27;s device partners say JPEG XL adds monetary or hardware costs.<p>* Does JPEG XL work best for the web?<p>* What is JPEG XL compression performance across a broad range of images?<p>* Is the decoder fast?<p>* Does it render small images fast?<p>* Is encoding fast?<p>* Hardware support keeping encoding costs reasonable for large users.<p>* Do we need it at all or just optimize existing formats to meet new use-cases?<p>* Do other browsers and OSes support JPEG XL?<p>* Can it be done sufficiently well with WASM?</div><br/><div id="39564252" class="c"><input type="checkbox" id="c-39564252" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561433">parent</a><span>|</span><a href="#39560502">next</a><span>|</span><label class="collapse" for="c-39564252">[-]</label><label class="expand" for="c-39564252">[1 more]</label></div><br/><div class="children"><div class="content">* [...] monetary or hardware costs.<p>We could perhaps create a GoFundMe page for making it cost neutral for Chrome&#x27;s partners. Perhaps some industry partners would chime in.<p>* Does JPEG XL work best for the web?<p>Yes.<p>* What is JPEG XL compression performance across a broad range of images?<p>All of them. The more difficult it is to compress, the better JPEG XL is. It is at its best at natural images with noisy textures.<p>* Is the decoder fast?<p>Yes. See blog post.<p>* Does it render small images fast?<p>Yes. I don&#x27;t have a link, but I tried it.<p>* Is encoding fast?<p>Yes. See blog post.<p>* Hardware support keeping encoding costs reasonable for large users.<p><a href="https:&#x2F;&#x2F;www.shikino.co.jp&#x2F;eng&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.shikino.co.jp&#x2F;eng&#x2F;</a> is building it based on libjxl-tiny.<p>* Do we need it at all or just optimize existing formats to meet new use-cases?<p>Jpegli is great. JPEG XL allows for 35 % more. It creates wealth of a few hundred billion in comparison to jpegli, in users&#x27; waiting times. So, it&#x27;s a yes.<p>* Do other browsers and OSes support JPEG XL?<p>Possibly. iOS and Safari support. DNG supports. Windows and some androids don&#x27;t support.<p>* Can it be done sufficiently well with WASM?<p>Wasm creates additional complexity, adds to load times, and possibly to computation times too.<p>Some more work is needed before all of Chrome&#x27;s questions can be answered.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39560502" class="c"><input type="checkbox" id="c-39560502" checked=""/><div class="controls bullet"><span class="by">bmicraft</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559705">parent</a><span>|</span><a href="#39560236">prev</a><span>|</span><a href="#39559703">next</a><span>|</span><label class="collapse" for="c-39560502">[-]</label><label class="expand" for="c-39560502">[1 more]</label></div><br/><div class="children"><div class="content">Safari supports jxl since version 17</div><br/></div></div></div></div><div id="39559703" class="c"><input type="checkbox" id="c-39559703" checked=""/><div class="controls bullet"><span class="by">sergioisidoro</span><span>|</span><a href="#39559590">parent</a><span>|</span><a href="#39559705">prev</a><span>|</span><a href="#39560126">next</a><span>|</span><label class="collapse" for="c-39559703">[-]</label><label class="expand" for="c-39559703">[14 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so frustrating how the chromium team is ending up as a gatekeeper of the Internet by pick and choosing what gets developed or not.<p>I recently come across another issue pertaining to the chromium team not budging on their decisions, despite pressure from the community and an RFC backing it up - in my case custom headers in WebSocket handshakes, that are supported by other Javascript runtimes like node and bun, but the chromium maintainer just disagrees with it - <a href="https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;websockets&#x2F;issues&#x2F;16#issuecomment-1961031987">https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;websockets&#x2F;issues&#x2F;16#issuecomment-...</a></div><br/><div id="39561895" class="c"><input type="checkbox" id="c-39561895" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559703">parent</a><span>|</span><a href="#39559932">next</a><span>|</span><label class="collapse" for="c-39561895">[-]</label><label class="expand" for="c-39561895">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s so frustrating how the chromium team is ending up as a gatekeeper of the Internet by pick and choosing what gets developed or not.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js">https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js</a> is based on Chromium tech (Squoosh from GoogleChromeLabs) and provides an opportunity to use JXL with no practical way for Chromium folks to intervene.<p>Even if that&#x27;s a suboptimal solution, JXL&#x27;s benefits supposedly should outweight the cost of integrating that, and yet I haven&#x27;t seen actual JXL users running to that in droves.<p>So JXL might not be a good support for your theory: where people could do they still don&#x27;t. Maybe the format isn&#x27;t actually that important, it&#x27;s just a popular meme to rehash.</div><br/><div id="39569701" class="c"><input type="checkbox" id="c-39569701" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561895">parent</a><span>|</span><a href="#39559932">next</a><span>|</span><label class="collapse" for="c-39569701">[-]</label><label class="expand" for="c-39569701">[2 more]</label></div><br/><div class="children"><div class="content">Why do you assume that the benefits would outweigh said costs? That&#x27;s a weird burden to set on the format. Using JavaScript on the browser to decode it is a huge hurdle, I don&#x27;t know of any format that ever got popular or got its initial usage from a similar approach. Avif was just added too, even if no one was using a js library to decode it beforehand<p>Fwiw I agree that there&#x27;s a weird narrative around jpegxl, at the end of the day it&#x27;s just a format, and I think it&#x27;s not very good for lower quality images as proven by the linked article in the OP. Avif looks better in that regard.<p>I think it would&#x27;ve made more sense than WebP though (which also doesn&#x27;t look good at all when not lossless), but that was like a decade ago and that ship has sailed. So avif fills a niche that WebP sucks at, while jpegxl doesn&#x27;t really do that. That alone is reason enough to not bother with including it.</div><br/><div id="39569920" class="c"><input type="checkbox" id="c-39569920" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39569701">parent</a><span>|</span><a href="#39559932">next</a><span>|</span><label class="collapse" for="c-39569920">[-]</label><label class="expand" for="c-39569920">[1 more]</label></div><br/><div class="children"><div class="content">People don&#x27;t use blurry low quality images in the web. These low qualities don&#x27;t matter outside of compression research.<p>Average&#x2F;median quality of images is between 85 to 90 depending how you calculate it.<p>There, users&#x27; waiting time is worth during image formats life time for about 3 trillion USD. If we can reduce 20 % of it we create wealth of 600 billion USD distributed to the users. More savings come from data transfer costs.</div><br/></div></div></div></div></div></div><div id="39559932" class="c"><input type="checkbox" id="c-39559932" checked=""/><div class="controls bullet"><span class="by">hwbunny</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559703">parent</a><span>|</span><a href="#39561895">prev</a><span>|</span><a href="#39560721">next</a><span>|</span><label class="collapse" for="c-39559932">[-]</label><label class="expand" for="c-39559932">[7 more]</label></div><br/><div class="children"><div class="content">Question is for how long. Time to slam the hammer on them.</div><br/><div id="39561872" class="c"><input type="checkbox" id="c-39561872" checked=""/><div class="controls bullet"><span class="by">caskstrength</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559932">parent</a><span>|</span><a href="#39559980">next</a><span>|</span><label class="collapse" for="c-39561872">[-]</label><label class="expand" for="c-39561872">[1 more]</label></div><br/><div class="children"><div class="content">What hammer? You want US president or supreme court to compel Chrome developers to implement every image format in existence and every JS API proposed by anyone anywhere?<p>Unless it is some kind of anti-competitive behavior like they intentionally stiffening adoption of standard competing with their proprietary patent-encumbered implementation that they expect to collect royalties for (doesn&#x27;t seem to be the case), then I don&#x27;t see the problem.</div><br/></div></div><div id="39559980" class="c"><input type="checkbox" id="c-39559980" checked=""/><div class="controls bullet"><span class="by">hhh</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559932">parent</a><span>|</span><a href="#39561872">prev</a><span>|</span><a href="#39560721">next</a><span>|</span><label class="collapse" for="c-39559980">[-]</label><label class="expand" for="c-39559980">[5 more]</label></div><br/><div class="children"><div class="content">Why not make a better product than slam some metaphorical hammer?</div><br/><div id="39560020" class="c"><input type="checkbox" id="c-39560020" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559980">parent</a><span>|</span><a href="#39560071">next</a><span>|</span><label class="collapse" for="c-39560020">[-]</label><label class="expand" for="c-39560020">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how this works. Firefox is the closest we have, and realistically the closest we will get to a &quot;better product&quot; than Chromium for the foreseeable future, and it&#x27;s clearly not enough.</div><br/><div id="39563337" class="c"><input type="checkbox" id="c-39563337" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560020">parent</a><span>|</span><a href="#39561389">next</a><span>|</span><label class="collapse" for="c-39563337">[-]</label><label class="expand" for="c-39563337">[1 more]</label></div><br/><div class="children"><div class="content">The <i>only</i> hammer <i>at all</i> left is Safari, basically on iPhones only.<p>That hammer is <i>very</i> close to going away; if the EU does force Apple to really open the browsers on the iPhone, everything will be Chrome as far as the eye can see in short order. And then we fully enter the chromE6 phase.</div><br/></div></div><div id="39561389" class="c"><input type="checkbox" id="c-39561389" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560020">parent</a><span>|</span><a href="#39563337">prev</a><span>|</span><a href="#39560071">next</a><span>|</span><label class="collapse" for="c-39561389">[-]</label><label class="expand" for="c-39561389">[1 more]</label></div><br/><div class="children"><div class="content">And Firefox does not support the format. Mozilla is the same political company as everyone else.</div><br/></div></div></div></div><div id="39560071" class="c"><input type="checkbox" id="c-39560071" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559980">parent</a><span>|</span><a href="#39560020">prev</a><span>|</span><a href="#39560721">next</a><span>|</span><label class="collapse" for="c-39560071">[-]</label><label class="expand" for="c-39560071">[1 more]</label></div><br/><div class="children"><div class="content">Because &quot;better&quot; products don&#x27;t magically win.</div><br/></div></div></div></div></div></div><div id="39560721" class="c"><input type="checkbox" id="c-39560721" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559703">parent</a><span>|</span><a href="#39559932">prev</a><span>|</span><a href="#39560126">next</a><span>|</span><label class="collapse" for="c-39560721">[-]</label><label class="expand" for="c-39560721">[3 more]</label></div><br/><div class="children"><div class="content">Where&#x27;s Firefox&#x27;s and Webkit&#x27;s position on the proposal?</div><br/><div id="39561001" class="c"><input type="checkbox" id="c-39561001" checked=""/><div class="controls bullet"><span class="by">jonsneyers</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560721">parent</a><span>|</span><a href="#39560126">next</a><span>|</span><label class="collapse" for="c-39561001">[-]</label><label class="expand" for="c-39561001">[2 more]</label></div><br/><div class="children"><div class="content">Safari&#x2F;Webkit has added JPEG XL support already.<p>Firefox is &quot;neutral&quot;, which I understand as meaning they&#x27;ll do whatever Chrome does.<p>All the code has been written, patches to add JPEG XL support to Firefox and Chromium are available and some of the forks (Waterfox, Pale Moon, Thorium, Cromite) do have JPEG XL support.</div><br/><div id="39561205" class="c"><input type="checkbox" id="c-39561205" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561001">parent</a><span>|</span><a href="#39560126">next</a><span>|</span><label class="collapse" for="c-39561205">[-]</label><label class="expand" for="c-39561205">[1 more]</label></div><br/><div class="children"><div class="content">I believe they were referring to that WebSocket issue, not JXL.</div><br/></div></div></div></div></div></div></div></div><div id="39560126" class="c"><input type="checkbox" id="c-39560126" checked=""/><div class="controls bullet"><span class="by">Pikamander2</span><span>|</span><a href="#39559590">parent</a><span>|</span><a href="#39559703">prev</a><span>|</span><a href="#39559675">next</a><span>|</span><label class="collapse" for="c-39560126">[-]</label><label class="expand" for="c-39560126">[7 more]</label></div><br/><div class="children"><div class="content">Mozilla effectively gave up on it before Google did.<p><a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1539075" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1539075</a><p>It&#x27;s a real shame, because this is one of those few areas where Firefox could have lead the charge instead of following in Chrome&#x27;s footsteps. I remember when they first added APNG support and it took Chrome years to catch up, but I guess those days are gone.<p>Oddly enough, Safari is the only major browser that currently supports it despite regularly falling behind on tons of other cutting-edge web standards.<p><a href="https:&#x2F;&#x2F;caniuse.com&#x2F;jpegxl" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;jpegxl</a></div><br/><div id="39560858" class="c"><input type="checkbox" id="c-39560858" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560126">parent</a><span>|</span><a href="#39562195">next</a><span>|</span><label class="collapse" for="c-39560858">[-]</label><label class="expand" for="c-39560858">[5 more]</label></div><br/><div class="children"><div class="content">I followed Mozilla&#x2F;Firefox integration closely. I was able to observe enthusiasm from their junior to staff level engineers (linkedin-assisted analysis of the related bugs ;-). However, an engineering director stepped in and locked the discussions because they were in &quot;no new information&quot; stage, and their position has been neutral on JPEG XL, and the integration has not progressed from the nightly builds to the next stage.<p>Ten years ago Mozilla used to have the most prominent image and video compression effort called Daala. They posted inspiring blog posts about their experiments. Some of their work was integrated with Cisco&#x27;s Thor and On2&#x27;s&#x2F;Chrome&#x27;s VP8&#x2F;9&#x2F;10, leading to AV1 and AVIF. Today, I believe, Mozilla has focused away from this research and the ex-Daala researchers have found new roles.</div><br/><div id="39560893" class="c"><input type="checkbox" id="c-39560893" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560858">parent</a><span>|</span><a href="#39562195">next</a><span>|</span><label class="collapse" for="c-39560893">[-]</label><label class="expand" for="c-39560893">[4 more]</label></div><br/><div class="children"><div class="content">Daala&#x27;s and Thor&#x27;s features were supposed to be integrated into AV1, but in the end, they wanted to finish AV1 as fast as possible, so very little that wasn&#x27;t in VP10 made it into AV1. I guess it will be in AV2, though.</div><br/><div id="39561436" class="c"><input type="checkbox" id="c-39561436" checked=""/><div class="controls bullet"><span class="by">derf_</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560893">parent</a><span>|</span><a href="#39561079">next</a><span>|</span><label class="collapse" for="c-39561436">[-]</label><label class="expand" for="c-39561436">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; ... very little that wasn&#x27;t in VP10 made it into AV1.</i><p>I am not sure I would say that is true.<p>The entire entropy coder, used by every tool, came from Daala (with changes in collaboration with others to reduce hardware complexity), as did some major tools like Chroma from Luma and the Constrained Directional Enhancement Filter (a merger of Daala&#x27;s deringing and Thor&#x27;s CLPF). There were also plenty of other improvements from the Daala team, such as structural things like pulling the entropy coder and other inter-frame state from reference frames instead of abstract &quot;slots&quot; like VP9 (important in real-time contexts where you can lose frames and not know what slots they would have updated) or better spatial prediction and coding for segment indices (important for block-level quantizer adjustments for better visual tuning). And that does not even touch on all of the contributions from other AOM members (scalable coding, the entire high-level syntax...).<p>Were there other things I wish we could have gotten in? Absolutely. But &quot;done&quot; is a feature.</div><br/><div id="39569078" class="c"><input type="checkbox" id="c-39569078" checked=""/><div class="controls bullet"><span class="by">tveita</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561436">parent</a><span>|</span><a href="#39561079">next</a><span>|</span><label class="collapse" for="c-39569078">[-]</label><label class="expand" for="c-39569078">[1 more]</label></div><br/><div class="children"><div class="content">Some &quot;didn&#x27;t make it in&quot; things that looked promising were the perceptual vector quantization[1], and a butterfly transform that Monty was working on, IIRC as an occasional spectator to the process.<p>[1] <a href="https:&#x2F;&#x2F;jmvalin.ca&#x2F;daala&#x2F;pvq_demo&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jmvalin.ca&#x2F;daala&#x2F;pvq_demo&#x2F;</a></div><br/></div></div></div></div><div id="39561079" class="c"><input type="checkbox" id="c-39561079" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560893">parent</a><span>|</span><a href="#39561436">prev</a><span>|</span><a href="#39562195">next</a><span>|</span><label class="collapse" for="c-39561079">[-]</label><label class="expand" for="c-39561079">[1 more]</label></div><br/><div class="children"><div class="content">I like to think that there might be an easy way to improve  AV2 today — drop the whole keyframe coding and replace it with JPEG XL images as keyframes.</div><br/></div></div></div></div></div></div><div id="39562195" class="c"><input type="checkbox" id="c-39562195" checked=""/><div class="controls bullet"><span class="by">miragecraft</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560126">parent</a><span>|</span><a href="#39560858">prev</a><span>|</span><a href="#39559675">next</a><span>|</span><label class="collapse" for="c-39562195">[-]</label><label class="expand" for="c-39562195">[1 more]</label></div><br/><div class="children"><div class="content">It feels like nowadays Mozilla is extremely shorthanded.<p>They probably gave up because they simply don’t have the money&#x2F;resources to pursue this.</div><br/></div></div></div></div><div id="39559675" class="c"><input type="checkbox" id="c-39559675" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">parent</a><span>|</span><a href="#39560126">prev</a><span>|</span><a href="#39561369">next</a><span>|</span><label class="collapse" for="c-39559675">[-]</label><label class="expand" for="c-39559675">[22 more]</label></div><br/><div class="children"><div class="content">All those requests to revert the removal are funny: you want Chrome to re-add jxl behind a feature flag? Doesn&#x27;t seem very useful.<p>Also, all those Chrome offshoots (Edge, Brave, Opera, etc) could easily add and enable it to distinguish themselves from Chrome (&quot;faster page load&quot;, &quot;less network use&quot;) and don&#x27;t. Makes me wonder what&#x27;s going on...</div><br/><div id="39560716" class="c"><input type="checkbox" id="c-39560716" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559675">parent</a><span>|</span><a href="#39559714">next</a><span>|</span><label class="collapse" for="c-39560716">[-]</label><label class="expand" for="c-39560716">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you want Chrome to re-add jxl behind a feature flag? Doesn&#x27;t seem very useful.<p>Chrome has a neat feature where some flags can be enabled by websites, so that websites can choose to cooperate in testing. They never did this for JXL, but if they re-added JXL behind a flag, they could do so but with such testing enabled. Then they could get real data from websites actually using it, without committing to supporting it if it isn&#x27;t useful.<p>&gt; Also, all those Chrome offshoots (Edge, Brave, Opera, etc) could easily add and enable it to distinguish themselves from Chrome (&quot;faster page load&quot;, &quot;less network use&quot;) and don&#x27;t. Makes me wonder what&#x27;s going on...<p>Edge doesn&#x27;t use Chrome&#x27;s own codec support. It uses Windows&#x27;s media framework. JXL is being added to it next year.</div><br/><div id="39567269" class="c"><input type="checkbox" id="c-39567269" checked=""/><div class="controls bullet"><span class="by">firsching</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560716">parent</a><span>|</span><a href="#39559714">next</a><span>|</span><label class="collapse" for="c-39567269">[-]</label><label class="expand" for="c-39567269">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Edge doesn&#x27;t use Chrome&#x27;s own codec support. It uses Windows&#x27;s media framework. JXL is being added to it next year.<p>Interesting!</div><br/></div></div></div></div><div id="39559714" class="c"><input type="checkbox" id="c-39559714" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559675">parent</a><span>|</span><a href="#39560716">prev</a><span>|</span><a href="#39559904">next</a><span>|</span><label class="collapse" for="c-39559714">[-]</label><label class="expand" for="c-39559714">[1 more]</label></div><br/><div class="children"><div class="content">Simply put these offshoots don&#x27;t really seem to do browser code, and realize how expensive it would be for them to diverge at the core.</div><br/></div></div><div id="39559904" class="c"><input type="checkbox" id="c-39559904" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559675">parent</a><span>|</span><a href="#39559714">prev</a><span>|</span><a href="#39560953">next</a><span>|</span><label class="collapse" for="c-39559904">[-]</label><label class="expand" for="c-39559904">[17 more]</label></div><br/><div class="children"><div class="content">No, obviously to re-add jxl without a flag</div><br/><div id="39559946" class="c"><input type="checkbox" id="c-39559946" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559904">parent</a><span>|</span><a href="#39560953">next</a><span>|</span><label class="collapse" for="c-39559946">[-]</label><label class="expand" for="c-39559946">[16 more]</label></div><br/><div class="children"><div class="content">&quot;jxl without a flag&quot; can&#x27;t be re-added because that was never a thing.</div><br/><div id="39560266" class="c"><input type="checkbox" id="c-39560266" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559946">parent</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39560266">[-]</label><label class="expand" for="c-39560266">[12 more]</label></div><br/><div class="children"><div class="content">It can, that&#x27;s why you didn&#x27;t say &quot;re-add jxl&quot;, but had to mention the flag, &#x27;re-add&#x27; has no flag implication, that pedantic attempt to constraint is somehing you&#x27;ve made up, that&#x27;s not what people want, just read those linked issues</div><br/><div id="39560380" class="c"><input type="checkbox" id="c-39560380" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560266">parent</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39560380">[-]</label><label class="expand" for="c-39560380">[11 more]</label></div><br/><div class="children"><div class="content">It has a flag implication because jpeg-xl never came without being hidden behind a flag. Nothing was taken away from ordinary users at any point in time.<p>And I suppose the Chrome folks have the telemetry to know how many people set that damn flag.</div><br/><div id="39560925" class="c"><input type="checkbox" id="c-39560925" checked=""/><div class="controls bullet"><span class="by">lonjil</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560380">parent</a><span>|</span><a href="#39560592">next</a><span>|</span><label class="collapse" for="c-39560925">[-]</label><label class="expand" for="c-39560925">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And I suppose the Chrome folks have the telemetry to know how many people set that damn flag.<p>How is that relevant? Flags are to allow testing, not to gauge interest from regular users.</div><br/></div></div><div id="39560592" class="c"><input type="checkbox" id="c-39560592" checked=""/><div class="controls bullet"><span class="by">jdiff</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560380">parent</a><span>|</span><a href="#39560925">prev</a><span>|</span><a href="#39560604">next</a><span>|</span><label class="collapse" for="c-39560592">[-]</label><label class="expand" for="c-39560592">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;But the plans were on display…”<p>&gt; “On display? I eventually had to go down to the cellar to find them.”<p>&gt; “That’s the display department.”<p>&gt; “With a flashlight.”<p>&gt; “Ah, well, the lights had probably gone.”<p>&gt; “So had the stairs.”<p>&gt; “But look, you found the notice, didn’t you?”<p>&gt; “Yes,” said Arthur, “yes I did. It was on display in the bottom of a locked filing cabinet stuck in a disused lavatory with a sign on the door saying ‘Beware of the Leopard.’”</div><br/><div id="39561773" class="c"><input type="checkbox" id="c-39561773" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560592">parent</a><span>|</span><a href="#39560604">next</a><span>|</span><label class="collapse" for="c-39561773">[-]</label><label class="expand" for="c-39561773">[2 more]</label></div><br/><div class="children"><div class="content">I guess you&#x27;re referring to the idea that the flag made the previous implementation practically non-existent for users. And I agree!<p>But &quot;implement something new!&quot; is a very different demand from &quot;you took that away from us, undo that!&quot;</div><br/><div id="39562074" class="c"><input type="checkbox" id="c-39562074" checked=""/><div class="controls bullet"><span class="by">jdiff</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561773">parent</a><span>|</span><a href="#39560604">next</a><span>|</span><label class="collapse" for="c-39562074">[-]</label><label class="expand" for="c-39562074">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No, obviously to re-add jxl without a flag<p>Is asking for the old thing to be re-added, but without the flag that sabotaged it. It is the same as &quot;you took that away from us, undo that!&quot; Removing a flag does not turn it into a magical, mystical new thing that has to be built from scratch. This is silly. The entire point of having flags is to provide a testing platform for code that may one day have the flag removed.</div><br/></div></div></div></div></div></div><div id="39560604" class="c"><input type="checkbox" id="c-39560604" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560380">parent</a><span>|</span><a href="#39560592">prev</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39560604">[-]</label><label class="expand" for="c-39560604">[6 more]</label></div><br/><div class="children"><div class="content">I suppose I&#x27;ll trust the reality of what actual users are expressly asking for vs. your imagination that something different is implied</div><br/><div id="39561761" class="c"><input type="checkbox" id="c-39561761" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39560604">parent</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39561761">[-]</label><label class="expand" for="c-39561761">[5 more]</label></div><br/><div class="children"><div class="content">Actual users, perhaps. Or maybe concern trolls paid by a patent holder who&#x27;s trying to prepare the ground for a patent-based extortion scheme. Or maybe Jon Sneyers with an army of sock puppets. These &quot;actual users&quot; are just as real to me as Chrome&#x27;s telemetry.<p>That said: these actual users didn&#x27;t demonstrate any hacker spirit or interest in using JXL in situations where they could. Where&#x27;s the wide-spread use of jxl.js (<a href="https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js">https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js</a>) to demonstrate that there are actual users desperate for native codec support? (aside: jxl.js is based on Squoosh, which is a product of GoogleChromeLabs) If JXL is sooo important, surely people would use whatever workaround they can employ, no matter if that convinces the Chrome team or not, simply because they benefit from using it, no?<p>Instead all I see is people _not_ exercising their freedom and initiative to support that best-thing-since-slices-bread-apparently format but whining that Chrome is oh-so-dominant and forces their choices of codecs upon everybody else.<p>Okay then...</div><br/><div id="39570012" class="c"><input type="checkbox" id="c-39570012" checked=""/><div class="controls bullet"><span class="by">JyrkiAlakuijala</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561761">parent</a><span>|</span><a href="#39561823">next</a><span>|</span><label class="collapse" for="c-39570012">[-]</label><label class="expand" for="c-39570012">[1 more]</label></div><br/><div class="children"><div class="content">We have been active on wasm implementations of jpeg xl but it doesn&#x27;t really work with progressive rendering, HDR canvas was still not supported, threadpools and simd had hickups etc. etc. Browser wasn&#x27;t and still isn&#x27;t ready for high quality codecs as modules. We are continually giving gentle guidance for these but in the heart our small team is an algorithm and data format research group, not a technology lobbyist organization — so we haven&#x27;t yet been successful there.<p>In the current scenario jpeg xl users are most likely to emerge outside of the web, in professional and prosumer photography, and then we will have — unnecessarily — two different format worlds. Jpeg xl for photography processing and a variety of web formats, each with their problems.</div><br/></div></div><div id="39561823" class="c"><input type="checkbox" id="c-39561823" checked=""/><div class="controls bullet"><span class="by">149765</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561761">parent</a><span>|</span><a href="#39570012">prev</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39561823">[-]</label><label class="expand" for="c-39561823">[3 more]</label></div><br/><div class="children"><div class="content">I tried jxl.js, it was very finicky on iPad, out of memory errors [0] and blurry images [1]. In the end I switched to a proxy server, that reencoded jxl images into png.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js&#x2F;issues&#x2F;6">https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js&#x2F;issues&#x2F;6</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js&#x2F;issues&#x2F;7">https:&#x2F;&#x2F;github.com&#x2F;niutech&#x2F;jxl.js&#x2F;issues&#x2F;7</a></div><br/><div id="39561930" class="c"><input type="checkbox" id="c-39561930" checked=""/><div class="controls bullet"><span class="by">pgeorgi</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561823">parent</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39561930">[-]</label><label class="expand" for="c-39561930">[2 more]</label></div><br/><div class="children"><div class="content">Both issues seem to have known workarounds that could have been integrated to support JXL on iOS properly earlier than by waiting on Apple (who integrated JXL in Safari 17 apparently), so if anything that&#x27;s a success story for &quot;provide polyfills to support features without relying on the browser vendor.&quot;</div><br/><div id="39562217" class="c"><input type="checkbox" id="c-39562217" checked=""/><div class="controls bullet"><span class="by">149765</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39561930">parent</a><span>|</span><a href="#39560056">next</a><span>|</span><label class="collapse" for="c-39562217">[-]</label><label class="expand" for="c-39562217">[1 more]</label></div><br/><div class="children"><div class="content">The blur issue is an easy fix, yes, but the memory one doesn&#x27;t help that much.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39560056" class="c"><input type="checkbox" id="c-39560056" checked=""/><div class="controls bullet"><span class="by">elygre</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559946">parent</a><span>|</span><a href="#39560266">prev</a><span>|</span><a href="#39559971">next</a><span>|</span><label class="collapse" for="c-39560056">[-]</label><label class="expand" for="c-39560056">[1 more]</label></div><br/><div class="children"><div class="content">Or (re-add jxl) (without a flag).</div><br/></div></div><div id="39559971" class="c"><input type="checkbox" id="c-39559971" checked=""/><div class="controls bullet"><span class="by">albert180</span><span>|</span><a href="#39559590">root</a><span>|</span><a href="#39559946">parent</a><span>|</span><a href="#39560056">prev</a><span>|</span><a href="#39560012">next</a><span>|</span><label class="collapse" for="c-39559971">[-]</label><label class="expand" for="c-39559971">[1 more]</label></div><br/><div class="children"><div class="content">What a stupid pedantry.
Feel better now?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>