<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dl.acm.org/doi/pdf/10.1145/3593856.3595903">Putting out the hardware dumpster fire</a> <span class="domain">(<a href="https://dl.acm.org">dl.acm.org</a>)</span></div><div class="subtext"><span>peter_d_sherman</span> | <span>99 comments</span></div><br/><div><div id="36449502" class="c"><input type="checkbox" id="c-36449502" checked=""/><div class="controls bullet"><span class="by">genmud</span><span>|</span><a href="#36448215">next</a><span>|</span><label class="collapse" for="c-36449502">[-]</label><label class="expand" for="c-36449502">[47 more]</label></div><br/><div class="children"><div class="content">I think one of the primary reasons that it is such a dumpster fire is there traditionally hasn&#x27;t been an &quot;open&quot; ecosystem in the hardware world, though now they are being forced towards that direction kicking and screaming.<p>Every part of the hardware ecosystem has traditionally been done in closed, NDA ridden environments and only over the last 5-10 years has that even started to change.<p>Designing chips has required NDA-based PDKs. Designing complex PCBs has required closed-source EDA tools. Interacting with any of the IC peripherals often requires binary or non-redistributable firmware.<p>Hell, even with the modern &quot;open&quot; switch architectures, like Trident3, you can&#x27;t get software or detailed datasheets from broadcom without an NDA. Same thing with some of the ARM based stuff like with the Raspberry Pi.</div><br/><div id="36451047" class="c"><input type="checkbox" id="c-36451047" checked=""/><div class="controls bullet"><span class="by">gchadwick</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36456357">next</a><span>|</span><label class="collapse" for="c-36451047">[-]</label><label class="expand" for="c-36451047">[5 more]</label></div><br/><div class="children"><div class="content">We&#x27;re aiming to push things in the other direction with OpenTitan: <a href="https:&#x2F;&#x2F;github.com&#x2F;lowRISC&#x2F;opentitan&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;lowRISC&#x2F;opentitan&#x2F;</a><p>It&#x27;s an Open Silicon root of trust, all RTL (the actual hardware design in SystemVerilog), firmware, documentation and verification environment is open source and in the repository I just linked.<p>We&#x27;re closing in on our first discrete chip (details here <a href="https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2023&#x2F;06&#x2F;opentitan-rtl-freeze.html.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;opensource.googleblog.com&#x2F;2023&#x2F;06&#x2F;opentitan-rtl-free...</a> and <a href="https:&#x2F;&#x2F;lowrisc.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;opentitans-rtl-freeze-leveraging-transparency-to-create-trustworthy-computing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lowrisc.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;opentitans-rtl-freeze-lever...</a>) and have lots more in the pipeline (our project director Dom Rizzo gave a keynote at the Barcelona RISC-V Europe summit recently with some details, sadly not available on video yet).<p>The hope is this will be a real proof point of the value of open source in hardware and, if as successful as we like it to be, can push the industry from a closed by default to people having to justify why they&#x27;re not using open technology.</div><br/><div id="36452397" class="c"><input type="checkbox" id="c-36452397" checked=""/><div class="controls bullet"><span class="by">hlandau</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36451047">parent</a><span>|</span><a href="#36453444">next</a><span>|</span><label class="collapse" for="c-36452397">[-]</label><label class="expand" for="c-36452397">[2 more]</label></div><br/><div class="children"><div class="content">Can you explain how the root of trust is configured? Is it efuses or some sort of onboard mutable nonvolatile storage? If I buy a system with one of these chips in, am I likely to be able to set my own root of trust, or will the OEM have irreversibly set the root of trust to their own key?</div><br/><div id="36456261" class="c"><input type="checkbox" id="c-36456261" checked=""/><div class="controls bullet"><span class="by">mkj</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452397">parent</a><span>|</span><a href="#36453444">next</a><span>|</span><label class="collapse" for="c-36456261">[-]</label><label class="expand" for="c-36456261">[1 more]</label></div><br/><div class="children"><div class="content">It looks like the chips themselves should support change of ownership. Whether an OEM ships them in an unlocked (transferrable) state is up to them.<p><a href="https:&#x2F;&#x2F;opentitan.org&#x2F;book&#x2F;doc&#x2F;security&#x2F;specs&#x2F;ownership_transfer&#x2F;#unlock-ownership" rel="nofollow noreferrer">https:&#x2F;&#x2F;opentitan.org&#x2F;book&#x2F;doc&#x2F;security&#x2F;specs&#x2F;ownership_tran...</a></div><br/></div></div></div></div><div id="36453444" class="c"><input type="checkbox" id="c-36453444" checked=""/><div class="controls bullet"><span class="by">genmud</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36451047">parent</a><span>|</span><a href="#36452397">prev</a><span>|</span><a href="#36452241">next</a><span>|</span><label class="collapse" for="c-36453444">[-]</label><label class="expand" for="c-36453444">[1 more]</label></div><br/><div class="children"><div class="content">If you ever need someone to test your stuff when it makes it into the physical world, would love to help :)<p>I really want to see an open motor control peripheral that could be used in robotics or UAVs, it&#x27;s amazing how ubiquitous they are, yet rarely are very integrated like other controllers.</div><br/></div></div><div id="36452241" class="c"><input type="checkbox" id="c-36452241" checked=""/><div class="controls bullet"><span class="by">tiffanyg</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36451047">parent</a><span>|</span><a href="#36453444">prev</a><span>|</span><a href="#36456357">next</a><span>|</span><label class="collapse" for="c-36452241">[-]</label><label class="expand" for="c-36452241">[1 more]</label></div><br/><div class="children"><div class="content">I like this approach, speaking from a very general perspective (very uneducated regarding hardware, comparatively). Absolutely brings back memories of the 90s and arguments regarding open vs closed source and &quot;security through obscurity&quot;.<p>Security through obscurity doesn&#x27;t work, ultimately. When economic stakes are &#x2F; were lower, it CAN have benefits. At this point, I suspect it&#x27;s likely that more eyes and openness is better.<p>That said, I do think that the best solution is likely to be based in a mixture of approaches, much as has been pursued (to my knowledge) and developed over time already. However, personally, I&#x27;m a big fan of &quot;formal methods&quot; and seeing more real-world deployment of such methods.<p>In practice, as has been done that I&#x27;ve seen, you start with small &amp; critical subsystems, trying to design for &quot;parsimony&quot; - making formal methods and everything else more realistic &#x2F; practical (e.g., &quot;microkernels&quot;, everyone&#x27;s favorite &#x27;solution&#x27; since the 80s, at least). But, it&#x27;s all very challenging because then it has to be balanced against performance, cost, etc.<p>Not sure this comment adds much, here - again, not an area I have much direct knowledge or experience in - but, your comment did bring some analogous areas and work I&#x27;m more familiar with to mind.</div><br/></div></div></div></div><div id="36456357" class="c"><input type="checkbox" id="c-36456357" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36451047">prev</a><span>|</span><a href="#36449803">next</a><span>|</span><label class="collapse" for="c-36456357">[-]</label><label class="expand" for="c-36456357">[1 more]</label></div><br/><div class="children"><div class="content">Traditionally there hasn&#x27;t been an &quot;open&quot; ecosystem in the hardware world only if the &quot;traditions&quot; are understood to be no older than three decades ago.<p>The IBM Personal Computer has been amazingly open and this has been tremendously important for the evolution of the computer industry, by creating de facto hardware standards.<p>Unfortunately many managers have been less impressed by the huge benefits for the entire society that this openness has caused, than by the fact that later IBM has failed to exploit as well as their competitors the open standards created by themselves, for increasing their profits.<p>Then, slowly after 1990 and more and more after 2000, the ugly fashion of secret documentation and NDAs designed to prevent competition on the markets, with the hope of enabling higher product prices, has spread everywhere.<p>It is impossible to estimate whether this secrecy has ever been profitable for the companies that practice it, because while it has prevented the apparition of competitors that would have lowered the prices, it has also limited the sizes of the markets in which their products are sold by limiting their customer list mostly to the already existing, because many of the potential customers cannot evaluate whether a product is suitable for their needs.<p>In order to accept the harassment of an NDA, you must be already convinced that you need that product. Before this annoying NDA practice, it was normal to evaluate a much greater number of products for any new project and it was much more frequent to decide for new suppliers.<p>The NDAs may be beneficial for those who strongly dominate a market, so they do not hope to grow, but only to retain their captive customers, but they prevent the growth of the smaller companies. Nevertheless, most small companies appear to stupidly imitate the behavior of the big ones and they are equally secretive about their products, which does not have any rational justification.</div><br/></div></div><div id="36449803" class="c"><input type="checkbox" id="c-36449803" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36456357">prev</a><span>|</span><a href="#36451587">next</a><span>|</span><label class="collapse" for="c-36449803">[-]</label><label class="expand" for="c-36449803">[35 more]</label></div><br/><div class="children"><div class="content">Most electrical components have traditionally had open datasheets. It is only a relatively recent phenomenon that mass market ICs are locked behind NDAs.</div><br/><div id="36450677" class="c"><input type="checkbox" id="c-36450677" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36449803">parent</a><span>|</span><a href="#36450012">next</a><span>|</span><label class="collapse" for="c-36450677">[-]</label><label class="expand" for="c-36450677">[9 more]</label></div><br/><div class="children"><div class="content">It really depends on the complexity.  Sure, 555 timers and even microcontrollers have datasheets.  CPUs that run Linux, Wifi chips supporting recent standards, etc.?  Rare.  This is why Linux in the 90s was a big pain; you get some random Ethernet chip and there is no documentation on how to talk to it, so you&#x27;re just dead in the water.  (I think Android was the turning point.  From then on, stuff had to support Linux, because Mobile was the future and Apple wasn&#x27;t going to buy your chip.  But of course, &quot;works on Linux&quot; means that it works in the hardware vendor&#x27;s 3-year-old version of Linux.  And &quot;works&quot; is always up in the air when hardware vendors start writing code.)<p>When I worked on embedded devices, we would report bugs and the vendor would send us new datasheets with updated known issues; updated to include the issue we reported.  Or we&#x27;d do something like &quot;the datasheet says it can handle a 100MHz clock but it&#x27;s very unreliable&quot; and they&#x27;d send back a datasheet saying it only supports 50MHz.  That&#x27;s the reason that datasheets are closed, every customer gets their own datasheet.<p>The more you get into higher margin stuff, be it hardware or software, the more you&#x27;ll run into datasheets or branches just for you.  It is weird and inefficient.  But cheaper than testing it yourself.</div><br/><div id="36456468" class="c"><input type="checkbox" id="c-36456468" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450677">parent</a><span>|</span><a href="#36451824">next</a><span>|</span><label class="collapse" for="c-36456468">[-]</label><label class="expand" for="c-36456468">[1 more]</label></div><br/><div class="children"><div class="content">Complex CPUs and peripherals up to around 1995, e.g. up to Pentium, had mostly open documentation, not much different than for a 555.<p>Only after that the public documentation has become progressively more and more restricted.<p>Some restrictions are quite recent, e.g. only since the first Zen AMD has stopped publishing the BIOS and Kernel Developer&#x27;s Guides and Intel has stopped publishing even summary datasheets for the mobile CPUs only a few product generations ago (summary datasheets are still published for desktop CPUs).</div><br/></div></div><div id="36451824" class="c"><input type="checkbox" id="c-36451824" checked=""/><div class="controls bullet"><span class="by">mfuzzey</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450677">parent</a><span>|</span><a href="#36456468">prev</a><span>|</span><a href="#36450971">next</a><span>|</span><label class="collapse" for="c-36451824">[-]</label><label class="expand" for="c-36451824">[1 more]</label></div><br/><div class="children"><div class="content">It seems to depend on the market.<p>For example CPUs that run Linux open reference manuals are still the norm in the industrial range (chips like the NXP i.MX series, the TI SAMA ones or the fairly new STM32MP1) whereas in the mobile market (Qualcomm, Exynos etc) you can&#x27;t get any information without a NDA and they&#x27;ll only sign one with you if you&#x27;re going to be buying millions.<p>The first category also tend to have good mainline support, the second stuck on ancient vendor kernels.</div><br/></div></div><div id="36450971" class="c"><input type="checkbox" id="c-36450971" checked=""/><div class="controls bullet"><span class="by">reaperman</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450677">parent</a><span>|</span><a href="#36451824">prev</a><span>|</span><a href="#36452526">next</a><span>|</span><label class="collapse" for="c-36450971">[-]</label><label class="expand" for="c-36450971">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But cheaper than testing it yourself.<p>It always felt like, IMO, that we end up testing it ourselves anyways. Obviously we don&#x27;t go through the whole spec, but like you, we implement what we need and find the relevant bugs&#x2F;errata ourselves. It&#x27;s very painful to run across these and I don&#x27;t recall an MCU that doesn&#x27;t have at least one that we run into and have to workaround because development is already deep enough that we&#x27;re economically locked it and it wouldn&#x27;t be worth the rework to switch to a different MCU. Sometimes the bugs are in the silicon, sometimes they&#x27;re in the middleware, but both are very painful to root-cause.</div><br/><div id="36453788" class="c"><input type="checkbox" id="c-36453788" checked=""/><div class="controls bullet"><span class="by">themaninthedark</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450971">parent</a><span>|</span><a href="#36452526">next</a><span>|</span><label class="collapse" for="c-36453788">[-]</label><label class="expand" for="c-36453788">[1 more]</label></div><br/><div class="children"><div class="content">I think that they were saying it was cheaper for the manufacturer to not test it and use their customers as bug testers and troubleshooters.</div><br/></div></div></div></div><div id="36452526" class="c"><input type="checkbox" id="c-36452526" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450677">parent</a><span>|</span><a href="#36450971">prev</a><span>|</span><a href="#36454345">next</a><span>|</span><label class="collapse" for="c-36452526">[-]</label><label class="expand" for="c-36452526">[3 more]</label></div><br/><div class="children"><div class="content"><i>CPUs that run Linux, Wifi chips supporting recent standards, etc.? Rare.</i><p>Intel was relatively open with its documentation (including reference schematics -- I think you can still find the 440BX ones on their site somewhere) until around the end of the P4 era, so that covers &quot;CPUs that run Linux&quot;. As for the wireless stuff, I suspect a lot of that has to do with regulatory issues.</div><br/><div id="36453216" class="c"><input type="checkbox" id="c-36453216" checked=""/><div class="controls bullet"><span class="by">genmud</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452526">parent</a><span>|</span><a href="#36453553">next</a><span>|</span><label class="collapse" for="c-36453216">[-]</label><label class="expand" for="c-36453216">[1 more]</label></div><br/><div class="children"><div class="content">I mean, sure, for certain x86 things... like 20 years ago, but IIRC their host controllers were not though, and that isn&#x27;t but a fraction of all CPUs.<p>Think about how many billions of devices there are where you can&#x27;t get simple a pinout diagram for the main CPU. I would argue only a tiny, <i>TINY</i>, percentage of any Linux devices actually have CPUs&#x2F;SOCs&#x2F;SOMs with sufficient documentation to look at from a hardware design standpoint.</div><br/></div></div><div id="36453553" class="c"><input type="checkbox" id="c-36453553" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452526">parent</a><span>|</span><a href="#36453216">prev</a><span>|</span><a href="#36454345">next</a><span>|</span><label class="collapse" for="c-36453553">[-]</label><label class="expand" for="c-36453553">[1 more]</label></div><br/><div class="children"><div class="content">StrongARM and followon ARM CPUs from Intel had good documentation too.</div><br/></div></div></div></div><div id="36454345" class="c"><input type="checkbox" id="c-36454345" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450677">parent</a><span>|</span><a href="#36452526">prev</a><span>|</span><a href="#36450012">next</a><span>|</span><label class="collapse" for="c-36454345">[-]</label><label class="expand" for="c-36454345">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Android was the turning point<p>&gt;vendor&#x27;s 3-year-old version of Linux<p>Android uses the latest LTS Linux kernel.</div><br/></div></div></div></div><div id="36450012" class="c"><input type="checkbox" id="c-36450012" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36449803">parent</a><span>|</span><a href="#36450677">prev</a><span>|</span><a href="#36451587">next</a><span>|</span><label class="collapse" for="c-36450012">[-]</label><label class="expand" for="c-36450012">[25 more]</label></div><br/><div class="children"><div class="content">i only hit NDA on secure element chips and similar things. 99% of my embedding work is plain ol mcus w reams of datasheets available. i do not do pc stuff tho</div><br/><div id="36450223" class="c"><input type="checkbox" id="c-36450223" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450012">parent</a><span>|</span><a href="#36450972">next</a><span>|</span><label class="collapse" for="c-36450223">[-]</label><label class="expand" for="c-36450223">[23 more]</label></div><br/><div class="children"><div class="content">One common component where things are really secretive is with flash storage. This is because the underlying physical components are pretty commodified, and the software&#x2F;firmware (like block virtual addressing) is where brands actually distinguish themselves. It&#x27;s kind of unfortunate since there&#x27;s a lot of really cool stuff you could do with more control over the hardware like reducing the size of a failing disk to extend its life instead of complex wear-leveling techniques.</div><br/><div id="36450700" class="c"><input type="checkbox" id="c-36450700" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450223">parent</a><span>|</span><a href="#36452583">next</a><span>|</span><label class="collapse" for="c-36450700">[-]</label><label class="expand" for="c-36450700">[21 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m ever going to get on the conspiracy theory bandwagon, it will be on two topics:<p>1) Return to office.<p>2) Why we need a dedicated CPU and DRAM attached to flash memory.  You can garbage collect and wear level in your OS if you want to.  Manufacturers say &quot;no, we have a super secret secret sauce that nobody else could possibly improve upon&quot;.  Uh huh, sure.</div><br/><div id="36452880" class="c"><input type="checkbox" id="c-36452880" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450700">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36452880">[-]</label><label class="expand" for="c-36452880">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Why we need a dedicated CPU and DRAM attached to flash memory. You can garbage collect and wear level in your OS if you want to.<p>The thing I don&#x27;t get is, the chips are all commodities, and it&#x27;s not like soldering them to a board is rocket science. Why isn&#x27;t one of the companies that makes fully-specified inexpensive RISC-V chips selling one attached to some commodity flash chips and an NVMe connector? Include some minimalist open source firmware that offloads most of the work to the host OS and let the Linux community figure out how to make it better.<p>At minimum it should allow you to undercut the existing competition on price because you&#x27;re using a less expensive controller and no DRAM, and in a few years the open source drivers could have enough advantages over black box devices that nobody wants to buy anything else.</div><br/><div id="36453169" class="c"><input type="checkbox" id="c-36453169" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452880">parent</a><span>|</span><a href="#36453583">next</a><span>|</span><label class="collapse" for="c-36453169">[-]</label><label class="expand" for="c-36453169">[2 more]</label></div><br/><div class="children"><div class="content">For starters, I doubt that acting as a NVMe device is something you can do with a off the self &quot;inexpensive RISC-V&quot; with any kind of acceptable performance. A NVME engine would almost certainly be something that the flash controller would have implemented in fixed function hardware.<p>Also NAND flash practically requires some sort of error correction system - another thing that fixed function logic in a custom ASIC is very well suited for. Using CPU time on the host CPU for that would probably suck.</div><br/><div id="36455600" class="c"><input type="checkbox" id="c-36455600" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36453169">parent</a><span>|</span><a href="#36453583">next</a><span>|</span><label class="collapse" for="c-36455600">[-]</label><label class="expand" for="c-36455600">[1 more]</label></div><br/><div class="children"><div class="content">The basic function of transferring data between the flash chips and the PCIe bus shouldn&#x27;t be a bottleneck.<p>Dedicated silicon for error correction might be more efficient, but when there are already fast idle CPU cores it may not matter, and ECC algorithms can already be accelerated by SIMD instructions. Or for high performance machines add the dedicated silicon to the host CPU.</div><br/></div></div></div></div><div id="36453583" class="c"><input type="checkbox" id="c-36453583" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452880">parent</a><span>|</span><a href="#36453169">prev</a><span>|</span><a href="#36455142">next</a><span>|</span><label class="collapse" for="c-36453583">[-]</label><label class="expand" for="c-36453583">[2 more]</label></div><br/><div class="children"><div class="content">Why offload it to the host? If the CPU on the NVMe card is well documented then run the flash software on that.<p>The same goes for network offload features in ethernet controllers, make it an open architecture that you can write your own firmware for.</div><br/><div id="36455347" class="c"><input type="checkbox" id="c-36455347" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36453583">parent</a><span>|</span><a href="#36455142">next</a><span>|</span><label class="collapse" for="c-36455347">[-]</label><label class="expand" for="c-36455347">[1 more]</label></div><br/><div class="children"><div class="content">The host CPU is faster, which lowers access latency, and modern machines have large numbers of generally idle cores. It also reduces the cost of the drive.<p>Meanwhile you could also have drives with offload engines, in the same way that some network cards have offload engines and some don&#x27;t. But the ones that do are more expensive.</div><br/></div></div></div></div><div id="36455142" class="c"><input type="checkbox" id="c-36455142" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452880">parent</a><span>|</span><a href="#36453583">prev</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36455142">[-]</label><label class="expand" for="c-36455142">[6 more]</label></div><br/><div class="children"><div class="content">My guess is because flash chips are quirky and not very interchangeable. The error correction, wear leveling, etc all probably needs to be configured and calibrated to the specific chips used in a way that only can really be done by the manufacturer or a really big OEM like Apple.</div><br/><div id="36455435" class="c"><input type="checkbox" id="c-36455435" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36455142">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36455435">[-]</label><label class="expand" for="c-36455435">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to imagine why wear leveling would depend on the chips. The number of writes you can get out of them would, but the optimal wear leveling algorithm should be to spread the writes around as much as possible regardless of that, shouldn&#x27;t it?<p>Likewise, some chips could require more error correction because they expect more errors. But the amount of error correction is a tunable in the algorithm; it&#x27;s a space vs. resilience trade off. Where to set the dial shouldn&#x27;t be hard to derive from the manufacturer&#x27;s specifications, or empirical testing if the spec is worthless.</div><br/><div id="36455606" class="c"><input type="checkbox" id="c-36455606" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36455435">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36455606">[-]</label><label class="expand" for="c-36455606">[4 more]</label></div><br/><div class="children"><div class="content">Wear leveling: Just search Google Scholar for &quot;wear leveling&quot; to get an idea for how deep that rabbit hole goes. At minimum think about the difference between placing an infrequently written logical sector vs a frequently written one, and what the optimal strategy would be given physical blocks with varying write life left on them. Then how do you partition between regions you treat as SLC vs MLC? And on and on and on.<p>Error correction: Not just amount. What block size? Interleaving? How do you trade overhead due to more ECC vs overhead due to more spare blocks (have to decide how many to allocate up front)? What is the behavior vs temperature and what are you running the thing at?<p>There has been an ongoing push to standardize NAND interfaces but the controller still needs to know a fair amount about the specific chips it&#x27;s talking to. I don&#x27;t know how it will resolve but hopefully the integration becomes more like DRAM where things are a bit more consistent. Then again, if you care a lot about reliability you qualify specific DRAM modules too...</div><br/><div id="36455720" class="c"><input type="checkbox" id="c-36455720" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36455606">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36455720">[-]</label><label class="expand" for="c-36455720">[3 more]</label></div><br/><div class="children"><div class="content">&gt; At minimum think about the difference between placing an infrequently written logical sector vs a frequently written one, and what the optimal strategy would be given physical blocks with varying write life left on them.<p>That&#x27;s not a simple answer but why would it depend on whose chips you have?<p>&gt; What is the behavior vs temperature and what are you running the thing at?<p>This is where you might start seeing differences between manufacturers. But this is also optimization. If you don&#x27;t have this information the chip should still meet a minimum spec and you can use a conservative value. If you do know it you can do something more efficient. And if this becomes popular the chip makers will start publishing what&#x27;s necessary to do the optimization.</div><br/><div id="36455836" class="c"><input type="checkbox" id="c-36455836" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36455720">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36455836">[-]</label><label class="expand" for="c-36455836">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s not a simple answer but why would it depend on whose chips you have?<p>How do you estimate how much life is left on any given part of the physical flash?<p>This is one of those areas where neglecting the optimizations qualitatively changes the result. It&#x27;s like Twitter without scalability, sure you can build it in a weekend but what problem does that solve?<p>Don&#x27;t get me wrong, I would like to see all of this stuff get better standardized, documented, and open source, but for the most part this is a cost-sensitive commodity and if you want to roll your own SSD qty 1 from bare chips it&#x27;s just going to be orders of magnitude more expensive than letting SanDisk or whoever do it. Maybe it will be possible to get the hyperscalers and cloud operators to push for the kind of standardization you describe, it would benefit them.</div><br/><div id="36456222" class="c"><input type="checkbox" id="c-36456222" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36455836">parent</a><span>|</span><a href="#36451037">next</a><span>|</span><label class="collapse" for="c-36456222">[-]</label><label class="expand" for="c-36456222">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How do you estimate how much life is left on any given part of the physical flash?<p>In proportion to how many times it&#x27;s been rewritten already, or by checking the error rate for what&#x27;s already written there.<p>&gt; This is one of those areas where neglecting the optimizations qualitatively changes the result.<p>It mostly changes how much error correction you have to use. But the nature of it also allows other optimizations.<p>Suppose you&#x27;re going to use multi-drive array. Now you could stripe the error correction across devices and use the same system to recover from device failures, which at the same level of total error correction is more resilient.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36451037" class="c"><input type="checkbox" id="c-36451037" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450700">parent</a><span>|</span><a href="#36452880">prev</a><span>|</span><a href="#36450879">next</a><span>|</span><label class="collapse" for="c-36451037">[-]</label><label class="expand" for="c-36451037">[1 more]</label></div><br/><div class="children"><div class="content">I think NAND controllers are fine. If erase is slow, especially at lower voltage levels, then buffer away. I also think internal controllers help mask and work around shitty yields on the arrays.</div><br/></div></div><div id="36450879" class="c"><input type="checkbox" id="c-36450879" checked=""/><div class="controls bullet"><span class="by">CrazyStat</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450700">parent</a><span>|</span><a href="#36451037">prev</a><span>|</span><a href="#36450943">next</a><span>|</span><label class="collapse" for="c-36450879">[-]</label><label class="expand" for="c-36450879">[7 more]</label></div><br/><div class="children"><div class="content">&gt; 1) Return to office.<p>In the spirit of unbridled conspiracy theory (i.e. I have no evidence for this and don&#x27;t believe it is generally true):<p>Landlords are paying CxOs kickbacks to push return to office in order to prop up commercial real estate.</div><br/><div id="36455932" class="c"><input type="checkbox" id="c-36455932" checked=""/><div class="controls bullet"><span class="by">Qwertious</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450879">parent</a><span>|</span><a href="#36451711">next</a><span>|</span><label class="collapse" for="c-36455932">[-]</label><label class="expand" for="c-36455932">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s basically true but it&#x27;s not a conspiracy - take Apple, for instance. They have a $5 billion HQ on their balance sheet. If everyone works from home, then their investors will ask the CEO &quot;why aren&#x27;t you using this asset that costs $5 billion? It&#x27;s inefficient - sell it off.&quot;<p>The problem here is that if the CEO sells off the HQ (in a market where everyone has a bunch of unused real estate) they&#x27;ll almost certainly take a loss (and potentially a loss of <i>billions of dollars</i>, if they e.g. can only sell it for $3B), whereas if they keep it then it&#x27;s technically valued at what it originally cost to build. The CEO&#x27;s job is to make the company (look) profitable, so the CEO wants to find any excuse to use the HQ, even if it loses a bit of money or doesn&#x27;t otherwise make much sense.<p>For companies that lease, it&#x27;s the same problem or even worse - corporate office leases tend to be e.g. 3 years, and they&#x27;re locked into paying actual dollars every quarter until the lease term ends, so if they can&#x27;t claim to be using the office space then they&#x27;re <i>directly losing cash</i>. Renegotiating the lease is a bad bet as the landlords have basically zero incentive to do so in the current environment. Thus, they want to <i>appear to</i> use their office space.<p>There are some other niche benefits too - forcing return to office is a great way to reduce employee count without needing to claim you&#x27;re downsizing (although if you <i>want</i> to downsize then you <i>can</i> totally make the claim), and it makes office perks more valuable.<p>There are also some tax breaks from local governments that are contingent on having X number of workers in the office, and WFH could potentially require reversing the tax break.<p>None of these are &quot;conspiracies&quot;, they&#x27;re just sparkling incentives.</div><br/></div></div><div id="36451711" class="c"><input type="checkbox" id="c-36451711" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450879">parent</a><span>|</span><a href="#36455932">prev</a><span>|</span><a href="#36451838">next</a><span>|</span><label class="collapse" for="c-36451711">[-]</label><label class="expand" for="c-36451711">[1 more]</label></div><br/><div class="children"><div class="content">Maybe.  The most compelling reason I have heard is it&#x27;s an easy way to get attrition.  You don&#x27;t have to do layoffs, which are expensive emotionally and financially.</div><br/></div></div><div id="36451838" class="c"><input type="checkbox" id="c-36451838" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450879">parent</a><span>|</span><a href="#36451711">prev</a><span>|</span><a href="#36450943">next</a><span>|</span><label class="collapse" for="c-36451838">[-]</label><label class="expand" for="c-36451838">[4 more]</label></div><br/><div class="children"><div class="content">In my city office buildings are being converted to residential housing. 3 buildings recently in an area of population size 250k.</div><br/><div id="36452076" class="c"><input type="checkbox" id="c-36452076" checked=""/><div class="controls bullet"><span class="by">hoosieree</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36451838">parent</a><span>|</span><a href="#36450943">next</a><span>|</span><label class="collapse" for="c-36452076">[-]</label><label class="expand" for="c-36452076">[3 more]</label></div><br/><div class="children"><div class="content">What part of the world? I&#x27;ve heard that the cost of converting office spaces to residential is more than building new.</div><br/><div id="36455282" class="c"><input type="checkbox" id="c-36455282" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452076">parent</a><span>|</span><a href="#36456139">next</a><span>|</span><label class="collapse" for="c-36455282">[-]</label><label class="expand" for="c-36455282">[1 more]</label></div><br/><div class="children"><div class="content">People keep telling me this too, so I’d be super interested to know if it wasn’t the case, because it really feels like a weak&#x2F;overinflated reason.</div><br/></div></div><div id="36456139" class="c"><input type="checkbox" id="c-36456139" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36452076">parent</a><span>|</span><a href="#36455282">prev</a><span>|</span><a href="#36450943">next</a><span>|</span><label class="collapse" for="c-36456139">[-]</label><label class="expand" for="c-36456139">[1 more]</label></div><br/><div class="children"><div class="content">Waterloo Canada</div><br/></div></div></div></div></div></div></div></div><div id="36450943" class="c"><input type="checkbox" id="c-36450943" checked=""/><div class="controls bullet"><span class="by">peoplearepeople</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450700">parent</a><span>|</span><a href="#36450879">prev</a><span>|</span><a href="#36452583">next</a><span>|</span><label class="collapse" for="c-36450943">[-]</label><label class="expand" for="c-36450943">[1 more]</label></div><br/><div class="children"><div class="content">(1) is really simple, managers want to lower the effort for themselves to interrupting people with sudden meetings</div><br/></div></div></div></div><div id="36452583" class="c"><input type="checkbox" id="c-36452583" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450223">parent</a><span>|</span><a href="#36450700">prev</a><span>|</span><a href="#36450972">next</a><span>|</span><label class="collapse" for="c-36452583">[-]</label><label class="expand" for="c-36452583">[1 more]</label></div><br/><div class="children"><div class="content">IMHO the secrecy is more because they don&#x27;t want people realising how incredibly unreliable NAND flash is becoming. 20 years of retention after 1M cycles? Advertise that proudly to everyone. 10 years after 100K cycles? Not too bad. 5 years after 10K cycles? OK. 3 months after 1K cycles? No, don&#x27;t tell anyone. The very few leaked TLC&#x2F;QLC flash datasheets out there don&#x27;t even have any clear endurance numbers anymore.</div><br/></div></div></div></div><div id="36450972" class="c"><input type="checkbox" id="c-36450972" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36450012">parent</a><span>|</span><a href="#36450223">prev</a><span>|</span><a href="#36451587">next</a><span>|</span><label class="collapse" for="c-36450972">[-]</label><label class="expand" for="c-36450972">[1 more]</label></div><br/><div class="children"><div class="content">That is my experience, for NDA, Atmel wouldn’t let you see a datasheet without it.<p>But, I’m starting to see fairly typical data sheets for micros being hidden away behind portals.</div><br/></div></div></div></div></div></div><div id="36451587" class="c"><input type="checkbox" id="c-36451587" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36449803">prev</a><span>|</span><a href="#36451124">next</a><span>|</span><label class="collapse" for="c-36451587">[-]</label><label class="expand" for="c-36451587">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I think one of the primary reasons that it is such a dumpster fire is there traditionally hasn&#x27;t been an &quot;open&quot; ecosystem in the hardware world</i><p>Is it, though? Software thrives because it has an open ecosystem. But it&#x27;s no less of a dumpster fire of complexity, being slowly buried under the technical debt. We literally have decades-old system designs wrapped into multiple layers of progressively newer systems, and openness doesn&#x27;t help here. Most software is <i>write-only</i>.<p>The overarching reason might be the lack of refactoring and feedback loops. It&#x27;s more related to the production cycles and incentives than to the second-order effects of openness.</div><br/></div></div><div id="36451124" class="c"><input type="checkbox" id="c-36451124" checked=""/><div class="controls bullet"><span class="by">mozman</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36451587">prev</a><span>|</span><a href="#36449996">next</a><span>|</span><label class="collapse" for="c-36451124">[-]</label><label class="expand" for="c-36451124">[1 more]</label></div><br/><div class="children"><div class="content">Having ran my own internal hw&#x2F;warranty service for many years hw management is a skill, there are a lot of traces and if you have a cold joint, zinc whiskers, etc it can wreak havoc and diagnostic skills are imperative.<p>Diagnosis is much more important than open, as to truly diagnose with open will require EE level skills and time which is not free.</div><br/></div></div><div id="36449996" class="c"><input type="checkbox" id="c-36449996" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#36449502">parent</a><span>|</span><a href="#36451124">prev</a><span>|</span><a href="#36448215">next</a><span>|</span><label class="collapse" for="c-36449996">[-]</label><label class="expand" for="c-36449996">[3 more]</label></div><br/><div class="children"><div class="content">What forces them toward an open ecosystem?</div><br/><div id="36453045" class="c"><input type="checkbox" id="c-36453045" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36449996">parent</a><span>|</span><a href="#36448215">next</a><span>|</span><label class="collapse" for="c-36453045">[-]</label><label class="expand" for="c-36453045">[2 more]</label></div><br/><div class="children"><div class="content">Customer demand. If you&#x27;re Google or AWS or any sufficiently large customer and the black box firmware is getting in your way, you have the resources to roll your own. Then the incumbents not only lose their business, they face the prospect of new competition when that company publishes the documentation and firmware because they&#x27;re more interested in commodifying their complement and getting bug reports on what they&#x27;re now using internally than in competing in that commodity market.<p>Then from the other end, RISC-V is starting to get good enough that relatively small companies can put the pieces together into useful open products that compete with closed incumbents.<p>The hardware vendors are better off to get in front of it and publish the same for their own hardware so they can gain some market share in the time before everybody is doing it.</div><br/><div id="36453092" class="c"><input type="checkbox" id="c-36453092" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#36449502">root</a><span>|</span><a href="#36453045">parent</a><span>|</span><a href="#36448215">next</a><span>|</span><label class="collapse" for="c-36453092">[-]</label><label class="expand" for="c-36453092">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, thanks!</div><br/></div></div></div></div></div></div></div></div><div id="36448215" class="c"><input type="checkbox" id="c-36448215" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#36449502">prev</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36448215">[-]</label><label class="expand" for="c-36448215">[9 more]</label></div><br/><div class="children"><div class="content">One long-term project I’m planning is actually a fully open source desktop computing platform. While originally meant as a learning project, I realized a few years ago Ben Eater[0] has done this in a way far superior to anything I could create myself, so I started focusing on very basic hardware, beginning with power supplies. My goal ultimately is to select a processor that is as close to open source as possible, design a motherboard around it, make it fast enough to be suitable for general purpose uses, design a PSU, daughter boards (hot swap SATA backplane, I&#x2F;O ports), a few PCIe x16 lanes, and ultimately a custom graphics card.<p>Designing the motherboard is surprisingly easy, the way PCIe is setup makes routing high speed connections fairly straightforward, and most I&#x2F;O chips are just some sort of bus input and the interface output. The hardest part is finding the ICs that actually have good documentation not locked behind an NDA, or have good alternatives as one of my criteria is that every chip I select must have a pin-for-pin drop in replacement available.
6gbs SATA is the hardest one to source. I suspect this problem only will compound if I ever get to creating a graphics card.<p>[0]: <a href="https:&#x2F;&#x2F;eater.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eater.net&#x2F;</a></div><br/><div id="36448435" class="c"><input type="checkbox" id="c-36448435" checked=""/><div class="controls bullet"><span class="by">jamesmunns</span><span>|</span><a href="#36448215">parent</a><span>|</span><a href="#36449256">next</a><span>|</span><label class="collapse" for="c-36448435">[-]</label><label class="expand" for="c-36448435">[2 more]</label></div><br/><div class="children"><div class="content">This is something I&#x27;m also working on, but using off the shelf hardware for now and working on the OS first[0]. I&#x27;m going for something lower spec and portable for now, mostly because there are a fair number of <i>relatively</i> well documented RISC-V processors these days (the single core, 1 GHz C906 CPU inside the SoC probably technically counts as open source!), where it seems feasible to write drivers. I&#x27;m not sure it would be a wonderful &quot;full desktop&quot; solution (it&#x27;s close to the original Pi Zero in terms of performance), but I hope to target larger chips as the OS gets more mature. The i.MX8 they mention in the research paper is actually one of the ones I&#x27;ve considered, it&#x27;s also used by the MNT Reform (definitely worth a look if you haven&#x27;t seen it before, and are designing your own larger scale computer!), and the Librem 5 (which I got after many years of waiting, and don&#x27;t have a ton of use for right now).<p>I actually would like to eventually play around with treating all the &quot;hardware bits&quot; inside of the computer, like the wifi chip, graphics card, etc., more like a distributed system than black boxes, but this generally comes down to writing a lot of the firmware myself (luckily this is a hobby&#x2F;research project, so &quot;non viable&quot; solutions are still on the table).<p>The more immediate goal for me is something portable, and comparable to a palm pilot&#x2F;blackberry in terms of performance and capabilities. The current hardware will likely have an ESP32C3 for wifi (32-bit RISC-V), the main D1 CPU (64-bit RISC-V), and an RP2040 (32-bit Arm Cortex-M) for keyboard and IO, so I&#x27;ll be able to test out some of my &quot;network of tiny computers that make one small computer&quot; ideas.<p>[0]: <a href="https:&#x2F;&#x2F;onevariable.com&#x2F;blog&#x2F;mnemos-moment-1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;onevariable.com&#x2F;blog&#x2F;mnemos-moment-1&#x2F;</a></div><br/><div id="36448623" class="c"><input type="checkbox" id="c-36448623" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36448435">parent</a><span>|</span><a href="#36449256">next</a><span>|</span><label class="collapse" for="c-36448623">[-]</label><label class="expand" for="c-36448623">[1 more]</label></div><br/><div class="children"><div class="content">I love this concept and is why my current designs are littered with E-keyed M.2 ports and the only real I&#x2F;O is on my board are USB-C and a few USB-As. The advantage is that I can supplement built-in peripherals with USB devices until I build them.</div><br/></div></div></div></div><div id="36449256" class="c"><input type="checkbox" id="c-36449256" checked=""/><div class="controls bullet"><span class="by">colineartheta</span><span>|</span><a href="#36448215">parent</a><span>|</span><a href="#36448435">prev</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36449256">[-]</label><label class="expand" for="c-36449256">[6 more]</label></div><br/><div class="children"><div class="content">Does the Talos II not fit this already?</div><br/><div id="36450034" class="c"><input type="checkbox" id="c-36450034" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36449256">parent</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36450034">[-]</label><label class="expand" for="c-36450034">[5 more]</label></div><br/><div class="children"><div class="content">Who wants to spend tens of thousands of dollars for <i>that</i>?</div><br/><div id="36451772" class="c"><input type="checkbox" id="c-36451772" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36450034">parent</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36451772">[-]</label><label class="expand" for="c-36451772">[4 more]</label></div><br/><div class="children"><div class="content">Right, I’m not quite sure where it fits within the market. It’s quite pricey for pro-sumer and not enterprise-y enough for larger companies to buy into it.</div><br/><div id="36453210" class="c"><input type="checkbox" id="c-36453210" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36451772">parent</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36453210">[-]</label><label class="expand" for="c-36453210">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about the fastest system you can get if you want open hardware. There are people willing to pay a premium for that. It&#x27;s obviously not going to find a mass market at that price.<p>But maybe they&#x27;ll make enough money to develop a lower-priced one that can reach more customers.</div><br/><div id="36453536" class="c"><input type="checkbox" id="c-36453536" checked=""/><div class="controls bullet"><span class="by">colineartheta</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36453210">parent</a><span>|</span><a href="#36454027">next</a><span>|</span><label class="collapse" for="c-36453536">[-]</label><label class="expand" for="c-36453536">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is their “Blackbird” model is meant to be the lower priced model, though Raptor acknowledges the whole line was never going to be mass market; rather, a well made and open computer for those who want full custody over a “modern”&#x2F;current desktop or server platform.</div><br/></div></div><div id="36454027" class="c"><input type="checkbox" id="c-36454027" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36448215">root</a><span>|</span><a href="#36453210">parent</a><span>|</span><a href="#36453536">prev</a><span>|</span><a href="#36448461">next</a><span>|</span><label class="collapse" for="c-36454027">[-]</label><label class="expand" for="c-36454027">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are people willing to pay a premium for that.<p>I wish this existed in the laptop space, where I can&#x27;t even buy what I want.<p>But the Talos II exists, where you can get 4 threads per core for the low price of... oh, just $8,000.<p>That&#x27;s almost one and a half MacBooks!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36448461" class="c"><input type="checkbox" id="c-36448461" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#36448215">prev</a><span>|</span><a href="#36448244">next</a><span>|</span><label class="collapse" for="c-36448461">[-]</label><label class="expand" for="c-36448461">[4 more]</label></div><br/><div class="children"><div class="content">I like the boldness of the title and the simple clarity of the writing.<p>Academic papers are frustrating to me in that they seem to use esoteric language in order to create a veneer of importance, sometimes above trivial real content.<p>This stands against that trend and harkens back to papers of old.</div><br/><div id="36451541" class="c"><input type="checkbox" id="c-36451541" checked=""/><div class="controls bullet"><span class="by">Hermitian909</span><span>|</span><a href="#36448461">parent</a><span>|</span><a href="#36449647">next</a><span>|</span><label class="collapse" for="c-36451541">[-]</label><label class="expand" for="c-36451541">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they seem to use esoteric language in order to create a veneer of importance,<p>It&#x27;s kind of true, but also I think the real answer is that you&#x27;re not the target audience.<p>A lot of time you use esoteric language because part of the problem being solved for in these conversations are:<p>1. what are useful and meaningful abstractions?<p>2. which abstractions are seeing uptake?<p>3. Who gets credit for the abstraction?<p>This mean papers are very often introducing new terminology as part of an exploratory conversation. Communication is optimized for the people engaging in that process.<p>As time passes most of these terms fall into disuse and the field circles around a few winners which then pass into the wider world. This stage is much more approachable and this content is what most of us are used to consuming.</div><br/></div></div><div id="36449647" class="c"><input type="checkbox" id="c-36449647" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#36448461">parent</a><span>|</span><a href="#36451541">prev</a><span>|</span><a href="#36448244">next</a><span>|</span><label class="collapse" for="c-36449647">[-]</label><label class="expand" for="c-36449647">[2 more]</label></div><br/><div class="children"><div class="content">I know it’s probably asking too much but I wonder what the world would look like if academic papers were actually fun to read.<p>Brian Greene is probably considered a pariah around here but I really enjoyed reading his book The Elegant Universe.</div><br/><div id="36451643" class="c"><input type="checkbox" id="c-36451643" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#36448461">root</a><span>|</span><a href="#36449647">parent</a><span>|</span><a href="#36448244">next</a><span>|</span><label class="collapse" for="c-36451643">[-]</label><label class="expand" for="c-36451643">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure. Imagine if life-critical safety documents were &quot;fun to read&quot;. Or material safety data sheets. Or assembly instructions for heavy machinery. Or even code.<p>All of this stuff needs to be extremely clear, precise, and readable by professionals. That&#x27;s not the same as being &quot;fun to read&quot;, and certainly not by laypeople. You can&#x27;t really know whether an academic paper is clear, precise, and readable unless you&#x27;re a professional in the sub-discipline the paper was written for.</div><br/></div></div></div></div></div></div><div id="36448244" class="c"><input type="checkbox" id="c-36448244" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#36448461">prev</a><span>|</span><a href="#36448087">next</a><span>|</span><label class="collapse" for="c-36448244">[-]</label><label class="expand" for="c-36448244">[6 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a Usenix presentation by the last author, Timothy Roscoe, from August, 2021 on YouTube. [1]<p>He makes a very compelling case for greatly expanding the concept of an operating system into <i>all</i> of the hardware in a given computing environment.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=36myc8wQhLo">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=36myc8wQhLo</a></div><br/><div id="36449459" class="c"><input type="checkbox" id="c-36449459" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#36448244">parent</a><span>|</span><a href="#36448087">next</a><span>|</span><label class="collapse" for="c-36449459">[-]</label><label class="expand" for="c-36449459">[5 more]</label></div><br/><div class="children"><div class="content">&gt; He makes a very compelling case for greatly expanding the concept of an operating system into <i>all</i> of the hardware in a given computing environment.<p>I haven&#x27;t watched the presentation, and just glanced at the paper, but while I see how this would be an improvement, I&#x27;m not sure if giving operating systems all that power would be an absolutely good idea.<p>While I certainly don&#x27;t trust the firmware that runs on my devices, in most cases it&#x27;s self-contained to the device itself. Modern operating systems are themselves a dumpster fire of security issues and spyware, built by corporations who realized they can also profit from their user&#x27;s data, and they take advantage of that in subtle and nefarious ways. Even Linux distros aren&#x27;t safe, and users need to be under constant vigilance that the software they&#x27;re running isn&#x27;t actively tracking or exfiltrating their data. These are  much larger and widespread threats than any ones caused by firmware.<p>I think the solution must involve a radical simplification of hardware, and a migration towards open source platforms. RISC-V looks very promising in this regard, and, coupled with a reasonably secure OS, is the best path towards safer computing.</div><br/><div id="36449972" class="c"><input type="checkbox" id="c-36449972" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#36448244">root</a><span>|</span><a href="#36449459">parent</a><span>|</span><a href="#36448087">next</a><span>|</span><label class="collapse" for="c-36449972">[-]</label><label class="expand" for="c-36449972">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Dumpster fire?&quot; You are too kind. It&#x27;s a cesspool, and a leaky one a that. Mostly Microsoft fault, and it has been now known to be getting worse.</div><br/><div id="36450226" class="c"><input type="checkbox" id="c-36450226" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#36448244">root</a><span>|</span><a href="#36449972">parent</a><span>|</span><a href="#36455459">next</a><span>|</span><label class="collapse" for="c-36450226">[-]</label><label class="expand" for="c-36450226">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Mostly Microsoft fault,<p>It&#x27;s the lack of capability based security, and a common tragic misunderstanding of what it is, that is the root cause of this dumpster fire. This effects <i>all operating systems in common use</i>, including all versions of Linux, Mac OS, Windows, etc.<p>Imagine if your only choice to buy an ice cream cone was to give the other person full access to your checking account, <i>forever</i>.  That&#x27;s what phones do, and as a result, we&#x27;ve learned to call that a &quot;capability&quot;<p>Imagine taking out a $5 and handing it over to pay for that ice cream... the most you can lose, ever, is $5. That is what capability based security does. You interactively chose what side effects you&#x27;ll allow (by picking bills out of your wallet), at the time of purchase.<p>For desktop apps, like an office suite, all you have to do to port code over is change the calls to file selection dialogs (which return a list of file names) to &quot;powerbox&quot; calls (which return handles), then use those handles instead of directly opening the files.  The user doesn&#x27;t see any difference in behavior, but they are now firmly in control of things, instead of your program.</div><br/><div id="36455945" class="c"><input type="checkbox" id="c-36455945" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#36448244">root</a><span>|</span><a href="#36450226">parent</a><span>|</span><a href="#36455459">next</a><span>|</span><label class="collapse" for="c-36455945">[-]</label><label class="expand" for="c-36455945">[1 more]</label></div><br/><div class="children"><div class="content">&gt; all you have to do to port code over is change the calls to file selection dialogs (which return a list of file names) to &quot;powerbox&quot; calls (which return handles),<p>Actually you don&#x27;t even necessarily need that. Assuming you have operating-system-provided file selection dialogs, you can just return &quot;&#x2F;app&#x2F;d41d8cd98f00b204e9800998ecf8427e&#x2F;spool&#x2F;whatever-the-fuck-it-is.ext&quot;, and only allow the app to read and write that directory. Although that&#x27;s a bit more balky in general, it can handle most use cases <i>without</i> even needing to modify the offending program.</div><br/></div></div></div></div><div id="36455459" class="c"><input type="checkbox" id="c-36455459" checked=""/><div class="controls bullet"><span class="by">BlueThoughts</span><span>|</span><a href="#36448244">root</a><span>|</span><a href="#36449972">parent</a><span>|</span><a href="#36450226">prev</a><span>|</span><a href="#36448087">next</a><span>|</span><label class="collapse" for="c-36455459">[-]</label><label class="expand" for="c-36455459">[1 more]</label></div><br/><div class="children"><div class="content">I asked a friend about why their company could not keep their devices up to date for more than two or three years.<p>Basically, they did not have long-term maintenance agreements in place for the underlying subcomponents.  The subcomponents were filled with vendor coded firmware blobs.  There was some desire to fix this going forward for marketing purposes, but little desire to go back in time to fix old devices that were short on support.</div><br/></div></div></div></div></div></div></div></div><div id="36448087" class="c"><input type="checkbox" id="c-36448087" checked=""/><div class="controls bullet"><span class="by">binkHN</span><span>|</span><a href="#36448244">prev</a><span>|</span><a href="#36453855">next</a><span>|</span><label class="collapse" for="c-36448087">[-]</label><label class="expand" for="c-36448087">[2 more]</label></div><br/><div class="children"><div class="content">From the abstract:<p>&gt; The immense hardware complexity of modern computers,
both mobile phones and datacenter servers, is a seemingly
endless source of bugs and vulnerabilities in system software.<p>&gt; Classical OSes cannot address this, since they only run
on a small subset of the machine. The issue is interactions
within the entire ensemble of firmware blobs, co-processors,
and CPUs that we term the de facto OS. The current “whac-a-mole” approach will not solve this problem, nor will clean-slate redesign: it is simply not possible to replace some firmware components and the engineering effort is too great.</div><br/></div></div><div id="36453855" class="c"><input type="checkbox" id="c-36453855" checked=""/><div class="controls bullet"><span class="by">RecycledEle</span><span>|</span><a href="#36448087">prev</a><span>|</span><a href="#36453353">next</a><span>|</span><label class="collapse" for="c-36453855">[-]</label><label class="expand" for="c-36453855">[1 more]</label></div><br/><div class="children"><div class="content">30 years ago, I said &quot;When Moore&#x27;s law finally stops, we will go back and clean up all the kludges we committed to over the decades.&quot; Then I realized that was how we would know that Moore&#x27;s law was dead - when we started cleaning up our mess.<p>I&#x27;m sorry to say we are there. Just after Mr. Moore himself died, his law died.</div><br/></div></div><div id="36453353" class="c"><input type="checkbox" id="c-36453353" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#36453855">prev</a><span>|</span><a href="#36450776">next</a><span>|</span><label class="collapse" for="c-36453353">[-]</label><label class="expand" for="c-36453353">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The immense hardware complexity of modern computers, both mobile phones and datacenter servers, is a seemingly endless source of bugs and vulnerabilities in system software.<p>I&#x27;m a bit torn here. On one side, I&#x27;d really love to have equipment that can be proven to be bug free in theory or in practice. On the other side, often enough the only thing allowing me as an user to actually use a computing device for things that have not been intended by the manufacturer - everything from running my own software over running pirated games to using ad and tracking blockers - are (serious) security bugs, or when one uses the manufacturer-provided options to load their own software, the device irrevocably bricks parts of itself like Samsung&#x27;s Knox environment does after rooting your phone, which breaks a ton of stuff - most notably Netflix DRM or Google Pay.</div><br/><div id="36453982" class="c"><input type="checkbox" id="c-36453982" checked=""/><div class="controls bullet"><span class="by">throwaway32908</span><span>|</span><a href="#36453353">parent</a><span>|</span><a href="#36450776">next</a><span>|</span><label class="collapse" for="c-36453982">[-]</label><label class="expand" for="c-36453982">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m basically on the &quot;other side&quot;, I know some people have genuine security concerns but still find it amusing when people complain about devices being &quot;obsolete&quot; once they no longer receive updates, when I avoid them like the plague because all they ever do is remove intended and unintended freedoms.<p>But maybe we&#x27;re in a trap, because we can use hacks to do what we need, it&#x27;s not worth the effort of switching from Android etc. But if these hacks were fully gone, alternatives would find it easier get off the ground.<p>Have to hope so because we&#x27;re going to find out, these systems are only getting more secure and locked-down with time.</div><br/></div></div></div></div><div id="36450776" class="c"><input type="checkbox" id="c-36450776" checked=""/><div class="controls bullet"><span class="by">yafbum</span><span>|</span><a href="#36453353">prev</a><span>|</span><a href="#36448402">next</a><span>|</span><label class="collapse" for="c-36450776">[-]</label><label class="expand" for="c-36450776">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what fire has been put out here. IMO, a more convincing proof for the usefulness of this approach would be that it allows to find whole new classes of exploitable vulnerabilities that can then be corrected ahead. That&#x27;s how static code analysis tools typically demonstrate their value. Without such proof, the description that they make of a hardware platform is mentally interesting but not clearly useful.</div><br/><div id="36451571" class="c"><input type="checkbox" id="c-36451571" checked=""/><div class="controls bullet"><span class="by">ThreeFx</span><span>|</span><a href="#36450776">parent</a><span>|</span><a href="#36448402">next</a><span>|</span><label class="collapse" for="c-36451571">[-]</label><label class="expand" for="c-36451571">[1 more]</label></div><br/><div class="children"><div class="content">I think there’s potential for a second-order effect here: generate enough vulnerabilities and SoC designers will start to put it out themselves.</div><br/></div></div></div></div><div id="36448402" class="c"><input type="checkbox" id="c-36448402" checked=""/><div class="controls bullet"><span class="by">acuozzo</span><span>|</span><a href="#36450776">prev</a><span>|</span><a href="#36452027">next</a><span>|</span><label class="collapse" for="c-36448402">[-]</label><label class="expand" for="c-36448402">[4 more]</label></div><br/><div class="children"><div class="content">I thought that when the Intel Management Engine implementation details (hidden Minix!) were released that it would only be a matter of time for a &quot;Full FOSS&quot; movement within enthusiast communities.<p>I was wrong, it seems.<p>There hasn&#x27;t even been a push for an affordable 802.3ab gigabit ethernet card with an FPGA.</div><br/><div id="36450383" class="c"><input type="checkbox" id="c-36450383" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#36448402">parent</a><span>|</span><a href="#36448700">next</a><span>|</span><label class="collapse" for="c-36450383">[-]</label><label class="expand" for="c-36450383">[2 more]</label></div><br/><div class="children"><div class="content">Ethernet card built from a FPGA or one with an FPGA on the side? Because in both questions your talking about the fact that there are basically three companies providing FPGAs and none of them seem particularly interested in killing their high margin markets. Worse the &quot;DPU&quot; crowd are largely selling about $100 worth of compute for $3k+ because it has an attached 100G port.<p>OTOH I assume the next step for the icestorm&#x2F;etc folks once they actually have a reasonable toolchain working on the lattice parts is to actually find a company willing to produce a low cost open FPGA and write the backend bits to work with the toolchain.<p>Similarly there are various open ethernet mac projects floating around, although AFAIK none of them actually have been fabbed into something a random consumer can buy.<p>So much of this is really just the broken VC model in the US, no one is interested in funding stable but low margin businesses when they can gamble on high risk&#x2F;reward ones. And banks won&#x27;t loan people money without some kind of collateral. I suspect you have to look to China&#x2F;etc at this point for to fill in the &quot;sell a crapload with little margin&quot; business (ex: lenovo). Making it sorta inevitable that they steamroll everyone, because if there is one truth in the tech field, its the guy with the most volume tends to win long term.<p>Along those lines, the Si consolation has really been a negative in may aspects of the market. If one could still buy current generation PCIe switches for less than the price of an entire computer it would still be possible to find motherboards that have shared device bandwidths (aka a half dozen x4 m.2 slots, or three x16 slots that aren&#x27;t electrically just x4s) all hung off a x16 gen4&#x2F;5 slot. Which is really the scam here, at least in my case I have a number of Gen3 parts which would all work great behind a single Gen4 x16 port with a switch port but instead I have to waste gen4 slots on gen3 devices.</div><br/><div id="36454166" class="c"><input type="checkbox" id="c-36454166" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#36448402">root</a><span>|</span><a href="#36450383">parent</a><span>|</span><a href="#36448700">next</a><span>|</span><label class="collapse" for="c-36454166">[-]</label><label class="expand" for="c-36454166">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I assume the next step for the icestorm&#x2F;etc folks once they actually have a reasonable toolchain working on the lattice parts</i><p>Wait, they don’t? What’s missing?</div><br/></div></div></div></div><div id="36448700" class="c"><input type="checkbox" id="c-36448700" checked=""/><div class="controls bullet"><span class="by">mistrial9</span><span>|</span><a href="#36448402">parent</a><span>|</span><a href="#36450383">prev</a><span>|</span><a href="#36452027">next</a><span>|</span><label class="collapse" for="c-36448700">[-]</label><label class="expand" for="c-36448700">[1 more]</label></div><br/><div class="children"><div class="content">its not a democracy -- you discovered the implementation that is convenient to the towers of executive authority; there is no change just because it is more widely known, in fact, increased boldness in tracking activity in real-time and building dossiers on users for &quot;ads&quot; is growing, along with the stockpile of money available to implement that.</div><br/></div></div></div></div><div id="36452027" class="c"><input type="checkbox" id="c-36452027" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#36448402">prev</a><span>|</span><a href="#36449741">next</a><span>|</span><label class="collapse" for="c-36452027">[-]</label><label class="expand" for="c-36452027">[1 more]</label></div><br/><div class="children"><div class="content"><i>On an Android phone, Linux is effectively an application runtime.</i><p>This is a good way of putting it, and it’s sad<p>Our OS is no longer open source -- they built the real one underneath</div><br/></div></div><div id="36449741" class="c"><input type="checkbox" id="c-36449741" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36452027">prev</a><span>|</span><a href="#36448194">next</a><span>|</span><label class="collapse" for="c-36449741">[-]</label><label class="expand" for="c-36449741">[7 more]</label></div><br/><div class="children"><div class="content">Are vertically-integrated SoCs (Apple Silicon, NVIDIA Tegra, etc.) subject to the “OS only controls part of the hardware” problem?<p>I always figured that in these systems, there would be power-efficiency and BOM-cost pressure to “de-vendor” the SoC by replicating IP-core functionality with logic merged into firmware or a few larger service cores — or even kernel daemons run on the efficiency cores of the application processor. I would expect e.g. the fan controllers on these systems to be a part of the PCH’s event-loop logic, rather than its own little microcontroller with its own little firmware.<p>If this doesn’t happen—why doesn’t it?</div><br/><div id="36450673" class="c"><input type="checkbox" id="c-36450673" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#36449741">parent</a><span>|</span><a href="#36448194">next</a><span>|</span><label class="collapse" for="c-36450673">[-]</label><label class="expand" for="c-36450673">[6 more]</label></div><br/><div class="children"><div class="content">&gt; or even kernel daemons run on the efficiency cores<p>When (not if) the kernel scheduler locks up while the fans are slow&#x2F;stopped at the same moment some scheduled user process begins driving 250W+ through a CPU the isolated fan controller (not to mention isolated thermal throttling logic, also independent of the OS) has great value.<p>&gt; If this doesn’t happen—why doesn’t it?<p>Hardware evolves faster than operating systems and has complex requirements of which operating systems are oblivious, and there is no world where device manufacturers and consumers will tolerate being gated on operating system evolution.  These complications have to run somewhere so independent processing elements appear and grow.  This pattern delivers ever crucial compatibility by hiding new complications from legacy operating system interfaces.<p>The only path I can imagine that would change this paradigm requires a.) greatly increasing the reliability and security of operating systems to the point where they can be trusted not to fail and damage hardware or corrupt things and b.) generalizing all known <i>and future</i> hardware and operating system interfaces such that hardware drivers (which, due to the more rapid evolution of hardware, do not enjoy the long term maintenance cycle of operating systems) can be highly portable, both across platforms and forward.  Both of these requirements are &quot;Hard&quot; as in we have only begun to achieve this in primordial ways.</div><br/><div id="36453940" class="c"><input type="checkbox" id="c-36453940" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36449741">root</a><span>|</span><a href="#36450673">parent</a><span>|</span><a href="#36451784">next</a><span>|</span><label class="collapse" for="c-36453940">[-]</label><label class="expand" for="c-36453940">[1 more]</label></div><br/><div class="children"><div class="content">The M1 mac laptops have gone partway in this direction, though they still have a great deal running as firmware: the speaker drivers can drive a lot of power into the speakers in order to get better and louder sound, but this opens up the possibility of a particularly aggressive waveform damaging the speakers from overheating. The OS is responsible for ensuring that this doesn&#x27;t happen by modelling the power dissipated in the speakers and limiting the power when they are likely to be getting too hot.</div><br/></div></div><div id="36451784" class="c"><input type="checkbox" id="c-36451784" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#36449741">root</a><span>|</span><a href="#36450673">parent</a><span>|</span><a href="#36453940">prev</a><span>|</span><a href="#36448194">next</a><span>|</span><label class="collapse" for="c-36451784">[-]</label><label class="expand" for="c-36451784">[4 more]</label></div><br/><div class="children"><div class="content">You don’t seem to be paying attention to the words “vertically integrated” in my question — which were the whole point of my question.<p>Apple creates both the OS and the hardware for their phones. So why shouldn’t the hardware microcontroller firmware for the hardware <i>they</i> create (or commission and constrain the design of), run as one or several RTOS blobs that ship as part of the OS on one or several shared MCUs?<p>Let me put it this way: in x86, the motherboard has a power controller, but the CPU also has its <i>own</i> power controller. But on a vertically-integrated SoC system, I would expect there to be only one power controller, that controls power for the CPU, the other cores on the SoC die, <i>and</i> the various other components on the logic board. And I would expect that power controller, whether standalone or integrated into the CPU, to be running first-party code written by the system integrator (who is also the designer of the logic board, the SoC, the CPU <i>in</i> the SoC, and the power controller itself) rather than running code written by some vendor who was writing it in a “this chip could be used in many different builds, so it must be designed defensively for badly-integrated systems” manner.</div><br/><div id="36453953" class="c"><input type="checkbox" id="c-36453953" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36449741">root</a><span>|</span><a href="#36451784">parent</a><span>|</span><a href="#36452398">prev</a><span>|</span><a href="#36454476">next</a><span>|</span><label class="collapse" for="c-36453953">[-]</label><label class="expand" for="c-36453953">[1 more]</label></div><br/><div class="children"><div class="content">One thing is that even in a vertically integrated company you don&#x27;t necessarily have great communication between the teams responsible for one part or another. And so if there&#x27;s not a great technical push for it, it can still make sense to have a bunch of silos to simplify the interfaces between different parts of the system.</div><br/></div></div><div id="36454476" class="c"><input type="checkbox" id="c-36454476" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#36449741">root</a><span>|</span><a href="#36451784">parent</a><span>|</span><a href="#36453953">prev</a><span>|</span><a href="#36448194">next</a><span>|</span><label class="collapse" for="c-36454476">[-]</label><label class="expand" for="c-36454476">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You don’t seem to be paying attention to the words “vertically integrated” in my question<p>That&#x27;s because vertical integration doesn&#x27;t actually solve the core problems.</div><br/></div></div></div></div></div></div></div></div><div id="36455318" class="c"><input type="checkbox" id="c-36455318" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#36448194">prev</a><span>|</span><a href="#36450745">next</a><span>|</span><label class="collapse" for="c-36455318">[-]</label><label class="expand" for="c-36455318">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Indeed, these cores and their
firmware usually explicitly sandbox Linux on a corner of the chip (the “application cores”), preventing it taking any meaningful role in managing and securing the platform. On an Android phone, Linux is effectively an application runtime.<p>The reason Linux is sandboxed into a corner of the system on an Android phone is because the phone is more interested in not trusting <i>you</i> than it is not trusting the SIM chip&#x27;s processor, cellular radio, etc.<p>Google don&#x27;t want you:<p>* getting unrestricted access to digital content they or others sell and make available on the platform. Hollywood won&#x27;t let them sell movies on Play Store if Google can&#x27;t guarantee you won&#x27;t be able to make a copy of the files on the device, or output HDMI to a recording device. Ditto for Netflix. Ditto for record companies&#x2F;RIAA. Ditto for magazines and newspapers. The list goes on. Your smartphone, no matter what anyone tells you otherwise, is primarily designed as a media consumption device. Its secondary purpose is a cloud services consumption device (Google or Apple) and last on the list is &quot;a device for you to use however you want.&quot; For example, on iOS, the Files app and any file save dialog always defaulting to your iCloud folder, and the inability to set a default save location, is not even remotely an accident. Apple forces you to, every single time, select somewhere else if you don&#x27;t want to save to iCloud.<p>* disabling the methods they use to track you or opting out of the data collection they perform wholescale and continuously.<p>* disabling the methods application publishers use to track and collect data about you.</div><br/></div></div><div id="36450745" class="c"><input type="checkbox" id="c-36450745" checked=""/><div class="controls bullet"><span class="by">mitchbob</span><span>|</span><a href="#36455318">prev</a><span>|</span><a href="#36450211">next</a><span>|</span><label class="collapse" for="c-36450745">[-]</label><label class="expand" for="c-36450745">[1 more]</label></div><br/><div class="children"><div class="content">[pdf]</div><br/></div></div><div id="36450211" class="c"><input type="checkbox" id="c-36450211" checked=""/><div class="controls bullet"><span class="by">zackmorris</span><span>|</span><a href="#36450745">prev</a><span>|</span><a href="#36453430">next</a><span>|</span><label class="collapse" for="c-36450211">[-]</label><label class="expand" for="c-36450211">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed the trend of ever-increasingly complex hardware with little or no change in performance since the 90s, and ranted about it extensively since I joined HN. I think we&#x27;re past considering the problem from a technical perspective and need to look at the conspiratorial forces involved.<p>To me, the problem is one of monopoly and corporate thinking. When Intel and AMD make most of the chips, we end up with a Coke vs Pepsi mentality. There may be a hundred other hungry manufacturers, but without access to capital they&#x27;ll never get enough traction to scale.<p>Around 2000, FPGAs were set to go mainstream and let us design CPUs of our own, but Xilinx chose to keep them proprietary so they never evolved. It&#x27;s unfortunate that the company most capable of thwarting the status quo is the one propping it up. But they were trendsetters, that&#x27;s how it&#x27;s going with all things tech now.<p>Then Nvidia mostly monopolized the GPU industry and sent us down the SIMD rabbit hole. So we can process large vector buffers at great personal effort ..and that&#x27;s about it.<p>What I and I think a lot of people probably want is a return to big dumb processors. Something like a large array of RISC-V cores with local memories connected via content-addressable memory and copy-on-write that presents a symmetric, unified address space that can be driven with traditional desktop programming languages. Had a CPU like this kept up with Moore&#x27;s law, we would have had a 10 core machine in 2000, a 1,000 core machine around 2010 and a 100,000 core machine today, reaching between 1 million and 10 million cores by 2030. Which shows just how incredibly slow CPUs are vs what they could be.<p>The situation is so bad that I&#x27;ve all but given up on things ever improving. I mostly think about getting out of programming now and going back to living a normal life in the time I have left. Because the writing is on the wall: SIMD will deliver a narrowly conceived notion of neural network AI that&#x27;s &quot;good enough&quot; and will stop all further evolution of CPUs. We&#x27;ll miss out on the dozen or so other approaches like genetic algorithms and be forever separated from simple brute-force methods that &quot;just work&quot;. The AI will soon be like Mrs. Davis and the vast majority of people will be face-down in their phones, then connected neurologically. The arrival of WALL-E and Idiocracy will coincide with the destruction of the natural world by 2100 and that will be that.<p>The argument really comes down to centralized control vs distributed resilience and freedom. It&#x27;s pretty obvious which one we have right now, and that it&#x27;s getting worse each year. Now I look on each headline with growing weariness, picking up on which mistakes will be doubled down on, which kool-aid they want us to drink this time. Because without the intervention of at least one successful internet lottery winner, or a concerted effort by thousands of hobbyists, there&#x27;s simple no viable path from where we are now to where we could be, making the vast majority of the work we do a waste of time in the face of the potential we might have had.<p>It&#x27;s hard to write anymore without sounding like a fringe lunatic projecting frustration on a world that is blissfully unaware that anything&#x27;s even wrong. I&#x27;m probably wrong for doing so. Just another reason to probably get out of this business.</div><br/><div id="36451119" class="c"><input type="checkbox" id="c-36451119" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#36450211">parent</a><span>|</span><a href="#36453884">next</a><span>|</span><label class="collapse" for="c-36451119">[-]</label><label class="expand" for="c-36451119">[4 more]</label></div><br/><div class="children"><div class="content">What do you mean &quot;little or no change in performance since the 90s&quot;? Computers now are hundreds if not thousands of times faster than in the 90s.<p>Also, if anything, modern desktop hardware is so complex not because of centralization, but because of <i>de</i>centralization. If your computer was made by a single manufacturer, that manufacturer could optimize the final product as much as it wanted, because it&#x27;d have control not only of each component, but of the communication between each pair of components. It&#x27;d only need to make sure that the programming interface remained the same, so that the software could still function. Because different companies make your CPU, your motherboard, your storage, your memory, etc. and they all have to agree on some protocol so the parts can talk to each other, each manufacturer focuses their optimization efforts on the part that they manufacture, irrespective of what the rest of the system is doing. That&#x27;s how you get SSDs running garbage collectors, GPUs with little operating systems, motherboards with little operating systems, etc.</div><br/><div id="36451913" class="c"><input type="checkbox" id="c-36451913" checked=""/><div class="controls bullet"><span class="by">interroboink</span><span>|</span><a href="#36450211">root</a><span>|</span><a href="#36451119">parent</a><span>|</span><a href="#36453624">next</a><span>|</span><label class="collapse" for="c-36451913">[-]</label><label class="expand" for="c-36451913">[1 more]</label></div><br/><div class="children"><div class="content">They might be referring to the fact that, eg, opening Microsoft Word today can take significantly longer than Word 2003 on Windows XP (or similar). See also Wirth&#x27;s Law[1] and such.<p>EDIT: though they focus on the hardware-could-be-better side, rather than the software-could-be-less-awful side (:<p>There have been some good outspoken critics of how software bloat has canceled out (or more) modern hardware gains. Casey Muratori, Jonathan Blow, and Mike Acton come to mind — they have some good material on the subject [2][3][4]. Some of the issues you mention, w.r.t. the hardware being discombobulated, are addressed in that first blog&#x2F;video. No big surprise these people come from a video games background; video game hardware is traditionally much more tightly-bound-together.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wirth%27s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wirth%27s_law</a><p>[2] <a href="https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0031" rel="nofollow noreferrer">https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0031</a><p>[3] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pW-SOdj4Kkk">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pW-SOdj4Kkk</a><p>[4] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;rX0ItVEVjHc?t=4211" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;rX0ItVEVjHc?t=4211</a>  (timestamp, but the whole talk is good)</div><br/></div></div><div id="36453624" class="c"><input type="checkbox" id="c-36453624" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#36450211">root</a><span>|</span><a href="#36451119">parent</a><span>|</span><a href="#36451913">prev</a><span>|</span><a href="#36453884">next</a><span>|</span><label class="collapse" for="c-36453624">[-]</label><label class="expand" for="c-36453624">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What do you mean &quot;little or no change in performance since the 90s&quot;? Computers now are hundreds if not thousands of times faster than in the 90s.<p>Do you seriously think the person you’re replying to didn’t know this?</div><br/><div id="36453827" class="c"><input type="checkbox" id="c-36453827" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36450211">root</a><span>|</span><a href="#36453624">parent</a><span>|</span><a href="#36453884">next</a><span>|</span><label class="collapse" for="c-36453827">[-]</label><label class="expand" for="c-36453827">[1 more]</label></div><br/><div class="children"><div class="content">well, it&#x27;s quite hard to interpret that statement any other way, so I can understand the request for clarification including a direct contradiction of the obvious interpretation.</div><br/></div></div></div></div></div></div><div id="36453884" class="c"><input type="checkbox" id="c-36453884" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36450211">parent</a><span>|</span><a href="#36451119">prev</a><span>|</span><a href="#36453430">next</a><span>|</span><label class="collapse" for="c-36453884">[-]</label><label class="expand" for="c-36453884">[2 more]</label></div><br/><div class="children"><div class="content">FPGAs will never be mainstream for replacing CPUs or GPUs: the performance overhead of an FPGA compared to dedicated silicon is huge and not going down, regardless of how open or closed they are. FPGAs have their uses in niches, but I don&#x27;t think they&#x27;ll ever be something the average user has in their device, and certainly they won&#x27;t be the only thing in there. Anyone wishing to disrupt the way mainstream compute is done will need to make silicon, and competitive silicon (thankfully, this is more accessable than it ever has been thanks to the fabs no longer being vertically integrated with chip design companies, but it&#x27;s still a very large barrier to entry). Someone with the resources to do it making a 100,000 core machine would be interesting, but I doubt the results will be very good (see greenarrays).<p>similarly, genetic algorithms are not actually very good. The only advantage of them is they can kinda work for a wide variety of wonky problems, but there&#x27;s almost always a better option, usually one which is way better than a GA.</div><br/><div id="36454378" class="c"><input type="checkbox" id="c-36454378" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#36450211">root</a><span>|</span><a href="#36453884">parent</a><span>|</span><a href="#36453430">next</a><span>|</span><label class="collapse" for="c-36454378">[-]</label><label class="expand" for="c-36454378">[1 more]</label></div><br/><div class="children"><div class="content">The point of FPGA is not to make competitive CPUs. It’s to _prototype_ them. Give wide access to that, and more people will be able to design cores, and experiment with different design trade-offs, or even computing models.<p>Granted, a softcore on FPGA is at high volumes much more expensive and much less capable than a corresponding ASIC. At low volumes however it’s the only affordable alternative, and that’s make them the gateway to hardware design by the people (and increasingly, <i>for</i> the people as well).<p>By the way I recently purchased a Tillitis key¹, a security dongle with a RISC-V soft core (PicoRV32) running on the iCE40 Ultra Plus FPGA. I absolutely <i>love</i> their approach, where you can run arbitrary programs on that key, and each program gets an independent secret seed (derived from the key’s secret and a hash of the program). Sure this FPGA soft core is much less powerful than an equivalently priced hard core would have been, but I’m not sure they could have done such an open design without it.<p>Especially the upcoming unlocked version, which will allow customers to customise the &quot;hardware&quot; itself. I personally can’t wait, I’d like to experiment a couple optimisations.<p>[1]: <a href="https:&#x2F;&#x2F;tillitis.se&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tillitis.se&#x2F;</a></div><br/></div></div></div></div></div></div><div id="36453430" class="c"><input type="checkbox" id="c-36453430" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#36450211">prev</a><span>|</span><a href="#36452939">next</a><span>|</span><label class="collapse" for="c-36453430">[-]</label><label class="expand" for="c-36453430">[1 more]</label></div><br/><div class="children"><div class="content">I’ll go as far as to say <i>this</i> approach is also doomed to fail. We gotta standardize and rewrite from scratch <i>everything</i>, both hardware and software otherwise the current mess will never be tidied up.</div><br/></div></div><div id="36452939" class="c"><input type="checkbox" id="c-36452939" checked=""/><div class="controls bullet"><span class="by">haskellandchill</span><span>|</span><a href="#36453430">prev</a><span>|</span><a href="#36448071">next</a><span>|</span><label class="collapse" for="c-36452939">[-]</label><label class="expand" for="c-36452939">[1 more]</label></div><br/><div class="children"><div class="content">&quot;A key result of this work as applied to existing hardware will be whether it is possible to assign less-than-complete trust to any of the black-box components in an SoC, or whether current HW design practices are incompatible with building secure, correct systems.&quot;<p>Having been exploring this research area for a while I fear it is the latter and there is no clean formal model that will apply to real hardware as currently construed.</div><br/></div></div></div></div></div></div></div></body></html>