<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700038872302" as="style"/><link rel="stylesheet" href="styles.css?v=1700038872302"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yorickpeterse.com/articles/a-decade-of-developing-a-programming-language/">A decade of developing a programming language</a> <span class="domain">(<a href="https://yorickpeterse.com">yorickpeterse.com</a>)</span></div><div class="subtext"><span>YorickPeterse</span> | <span>113 comments</span></div><br/><div><div id="38273635" class="c"><input type="checkbox" id="c-38273635" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#38270210">next</a><span>|</span><label class="collapse" for="c-38273635">[-]</label><label class="expand" for="c-38273635">[3 more]</label></div><br/><div class="children"><div class="content">Your mileage may vary. I think It&#x27;s a good article. But sometimes a PL has to go down an unconventional path to make something new. If you follow a best practice &quot;rulebook&quot;, your PL will be like every other PL.<p>I think the most important part is figuring out <i>who</i> is going to use the PL and <i>what</i> problems they are solving. As precisely as possible, best with a list of concrete Personas and Projects. This creates a &quot;value system&quot;, which makes it easier to answer all questions during implementation.</div><br/><div id="38274041" class="c"><input type="checkbox" id="c-38274041" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38273635">parent</a><span>|</span><a href="#38270210">next</a><span>|</span><label class="collapse" for="c-38274041">[-]</label><label class="expand" for="c-38274041">[2 more]</label></div><br/><div class="children"><div class="content">&gt; sometimes a PL has to go down an unconventional path to make something new.<p>Absolutely, just look at Haskell as an example.<p>&gt; most important part is figuring out who is going to use the PL and what problems they are solving.<p>Completely agree. Rust and Go have received a lot of criticism over the years, but I think that is often down to them not being as general purpose as many people try to claim. The creators had particular users and use cases in mind.</div><br/><div id="38274679" class="c"><input type="checkbox" id="c-38274679" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#38273635">root</a><span>|</span><a href="#38274041">parent</a><span>|</span><a href="#38270210">next</a><span>|</span><label class="collapse" for="c-38274679">[-]</label><label class="expand" for="c-38274679">[1 more]</label></div><br/><div class="children"><div class="content">Maybe people just like to use general purpose languages. It should not be too hard to marry the good parts of major language families</div><br/></div></div></div></div></div></div><div id="38270210" class="c"><input type="checkbox" id="c-38270210" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#38273635">prev</a><span>|</span><a href="#38273919">next</a><span>|</span><label class="collapse" for="c-38270210">[-]</label><label class="expand" for="c-38270210">[26 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Oh, and good luck finding a book that explains how to write a type-checker, let alone one that covers more practical topics such as supporting sub-typing, generics, and so on&quot;<p>I bought _Practical Foundations for Programming Languages_ by Harper and _Types and Programming Languages_ by Pierce and I just can&#x27;t get through the first few pages of either of them. I would love to see a book as gentle and fun as _Crafting Interpreters_ but about making a static ML like language without starting with hardcore theory. (Bob, if you&#x27;re listening, please make a sequel!)</div><br/><div id="38270753" class="c"><input type="checkbox" id="c-38270753" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38274186">next</a><span>|</span><label class="collapse" for="c-38270753">[-]</label><label class="expand" for="c-38270753">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the same boat as you -- here are the two best resources I found:<p><a href="https:&#x2F;&#x2F;mukulrathi.com&#x2F;create-your-own-programming-language&#x2F;intro-to-type-checking&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mukulrathi.com&#x2F;create-your-own-programming-language&#x2F;...</a><p><a href="https:&#x2F;&#x2F;jaked.org&#x2F;blog&#x2F;2021-09-07-Reconstructing-TypeScript-part-0" rel="nofollow noreferrer">https:&#x2F;&#x2F;jaked.org&#x2F;blog&#x2F;2021-09-07-Reconstructing-TypeScript-...</a><p>I read through the first 10 chapters of TAPL, and skimmed the rest.  The first 10 chapters were good to remind myself of the framing.  But as far as I can tell, all the stuff I care about is stuffed into one chapter (chapter 11 I think), and the rest isn&#x27;t that relevant (type inference stuff that is not mainstream AFAIK)<p>This is also good:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;example&#x2F;blob&#x2F;master&#x2F;gotypes&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;example&#x2F;blob&#x2F;master&#x2F;gotypes&#x2F;README...</a><p>And yeah some of us had the same conversation on Reddit -- somebody needs to make a Crafting Interpreters for type checking :)  Preferably with OOP and functional and nominal&#x2F;structural systems.<p>---<p>Also, it dawned on me that what makes TAPL incredibly difficult to read is that it lacks example PROGRAMS.<p>It has the type checkers for languages, but no programs that pass and fail the type checker.  You are left to kind of imagine what the language looks like from the definition of its type checker !!  Look at chapter 10 for example.<p>I mean I get that this is a math book, but there does seem to be a big hole in PL textbooks &#x2F; literature.<p>Also I was kinda shocked that the Dragon Book doesn&#x27;t contain a type checker.  For some reason I thought it would -- doesn&#x27;t everyone say it&#x27;s the authoritative compiler textbook?  And IIRC there are like 10 pages on type checking out of ~500 or more.</div><br/><div id="38272560" class="c"><input type="checkbox" id="c-38272560" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270753">parent</a><span>|</span><a href="#38271039">next</a><span>|</span><label class="collapse" for="c-38272560">[-]</label><label class="expand" for="c-38272560">[4 more]</label></div><br/><div class="children"><div class="content">Are we looking at the same Dragon book?  Chapter 6 the whole chapter is about type checking.  6.2 spells out a type checker for a sample language, admittedly in pseudo code.<p>It might not have the same lingo as the modern type checking specification but most of the ideas are there.  It talks about type systems, type expressions, type rules, constructed types like array&#x2F;struct, type variables for unknown types, etc.  It puts the type rules in the grammar productions.  It stores the type info in the AST nodes.  It uses the chained symbol tables as the type environments.<p>It has sections on type conversion, operator&#x2F;function overloading, polymorphic functions (parameterized types), and type unification.<p>It has all the pieces and steps to build a type checker.</div><br/><div id="38272870" class="c"><input type="checkbox" id="c-38272870" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38272560">parent</a><span>|</span><a href="#38271039">next</a><span>|</span><label class="collapse" for="c-38272870">[-]</label><label class="expand" for="c-38272870">[3 more]</label></div><br/><div class="children"><div class="content">I have the second edition, copyright 2007, and chapter 6 is &quot;intermediate code generation&quot;.  The whole chapter is definitely not about type checking -- is yours?<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Compilers-Principles-Techniques-Tools-2nd&#x2F;dp&#x2F;0321486811" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;Compilers-Principles-Techniques-Tools...</a><p>It has 11 sub-sections, 2 of which are about type checking<p>6.3 - Types and Declarations, pages 370-378<p>6.5 - Type Checking - pages 386 - 398<p>So that&#x27;s about 20 pages out of 993 pages.  A fraction of a chapter!<p>---<p>What I was referring to is the appendix &quot;A Complete Front End&quot;, which contains a lexer and parser, but not a type checker!  Doesn&#x27;t sound complete to me.<p>I guess they have a pass to create the three-address code, and type checking is only in service of that.  But they don&#x27;t give you the source code!<p>---<p>Also weirdly, when you look at the intro chapter &quot;The structure of a compiler&quot;, it goes<p>1.2.2 Syntax Analysis<p>1.2.3 Semantic Analysis (3 paragraphs that mentions type checking and coercions)<p>1.2.4 Intermediate Code Generation<p>But when you look at the chapters, there&#x27;s NO semantic analysis chapter!  It goes from (4) Syntax analysis, (5) Syntax-directed translation, to (6) intermediate code generation.<p>I think there&#x27;s a missing chapter!  (or two)</div><br/><div id="38273316" class="c"><input type="checkbox" id="c-38273316" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38272870">parent</a><span>|</span><a href="#38271039">next</a><span>|</span><label class="collapse" for="c-38273316">[-]</label><label class="expand" for="c-38273316">[2 more]</label></div><br/><div class="children"><div class="content">I have the 1st edition printed 1988.  Chapter 6 is Type Checking, chapter 7 is Runtime Environments, and chapter 8 is Intermediate Code Generation.<p>WTF. The 2nd edition is really butchered.</div><br/><div id="38273415" class="c"><input type="checkbox" id="c-38273415" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38273316">parent</a><span>|</span><a href="#38271039">next</a><span>|</span><label class="collapse" for="c-38273415">[-]</label><label class="expand" for="c-38273415">[1 more]</label></div><br/><div class="children"><div class="content">Wow yeah.  So in the first edition pages 343 to 388  is a full chapter on type checking.  It looks much more coherent.<p>What the heck happened ...</div><br/></div></div></div></div></div></div></div></div><div id="38271039" class="c"><input type="checkbox" id="c-38271039" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270753">parent</a><span>|</span><a href="#38272560">prev</a><span>|</span><a href="#38274186">next</a><span>|</span><label class="collapse" for="c-38271039">[-]</label><label class="expand" for="c-38271039">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much! This looks like some good morning-with-coffee reading!</div><br/></div></div></div></div><div id="38274186" class="c"><input type="checkbox" id="c-38274186" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38270753">prev</a><span>|</span><a href="#38274178">next</a><span>|</span><label class="collapse" for="c-38274186">[-]</label><label class="expand" for="c-38274186">[1 more]</label></div><br/><div class="children"><div class="content">&gt; about making a static ML like language without starting with hardcore theory.<p>The book <i>Applicative Order Programming: The Standard ML Perspective</i> has you implement an ML-like language at the end (the book is mostly about programming in Standard ML itself). Chapter 10 covers type checking and type inference. Chapter 11 covers interpretation via graph reduction. Chapter 12 covers compilation of the ML-like language to an abstract stack machine. The code is all in Standard ML. It&#x27;s very direct and practical without getting bogged down in theory, although it does talk about theory, and it&#x27;s not as gentle and fun as Crafting Interpreters.<p>It was published in 1991. It&#x27;s on libgen; I&#x27;d recommend downloading a PDF and reading those chapters in order to judge for yourself.</div><br/></div></div><div id="38274178" class="c"><input type="checkbox" id="c-38274178" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38274186">prev</a><span>|</span><a href="#38274138">next</a><span>|</span><label class="collapse" for="c-38274178">[-]</label><label class="expand" for="c-38274178">[1 more]</label></div><br/><div class="children"><div class="content">The bigger challenge is doing the pattern matching and mainly the exhaustiveness checking of patterns which aren&#x27;t constructors of a sum type, but for example integer intervals.<p>Simon Peyton Jones together with others wrote a relatively easy to read book about the writing of Miranda (Haskell), which even includes a simple explanation of lambda calculus, so it includes everything you need to know about the theory, more or less: &quot;The Implementation of Functional Programming Languages&quot; 1987, <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;1987&#x2F;01&#x2F;slpj-book-1987-small.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a></div><br/></div></div><div id="38274138" class="c"><input type="checkbox" id="c-38274138" checked=""/><div class="controls bullet"><span class="by">gilmi</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38274178">prev</a><span>|</span><a href="#38272924">next</a><span>|</span><label class="collapse" for="c-38274138">[-]</label><label class="expand" for="c-38274138">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve mentioned this in a different comment, but I&#x27;ve written several articles on type inference, trying to make the topic more approachable:<p><a href="https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;tags&#x2F;type%20inference" rel="nofollow noreferrer">https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;tags&#x2F;type%20inference</a><p>If you find that helpful, I&#x27;ve made more content on compilers (including live coding a compiler, without narration) which should be easily reachable from my website.</div><br/></div></div><div id="38272924" class="c"><input type="checkbox" id="c-38272924" checked=""/><div class="controls bullet"><span class="by">andrewcobby</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38274138">prev</a><span>|</span><a href="#38273927">next</a><span>|</span><label class="collapse" for="c-38272924">[-]</label><label class="expand" for="c-38272924">[2 more]</label></div><br/><div class="children"><div class="content">I had a similar experience this year as I’m working on an ML-cousin to Golang. I actually found that ChatGPT (gpt4) was really good and breaking down the step of implementing a Hindley-Milner type system in a language I could understand. It could also provide follow up clarifications to my questions too. I then implemented it a small bit at a time and as the complexity grew I started to better understand the algorithm.<p>EDIT: ChatGPT could actually demonstrate the whole process for type checking small chunks of code, including: assigning them type variables, collecting constraints and then unification. It would even then point out if there was a type error in the code snippet!</div><br/><div id="38273298" class="c"><input type="checkbox" id="c-38273298" checked=""/><div class="controls bullet"><span class="by">chewxy</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38272924">parent</a><span>|</span><a href="#38273927">next</a><span>|</span><label class="collapse" for="c-38273298">[-]</label><label class="expand" for="c-38273298">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how you went. Here&#x27;s my attempt: <a href="https:&#x2F;&#x2F;github.com&#x2F;chewxy&#x2F;hm">https:&#x2F;&#x2F;github.com&#x2F;chewxy&#x2F;hm</a> , the core of which (i.e. the interface type) is what powers most of the languages I wrote (different languages I wrote have different unification schemes)</div><br/></div></div></div></div><div id="38273927" class="c"><input type="checkbox" id="c-38273927" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38272924">prev</a><span>|</span><a href="#38272462">next</a><span>|</span><label class="collapse" for="c-38273927">[-]</label><label class="expand" for="c-38273927">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written a type checker or two. My experience: <a href="https:&#x2F;&#x2F;lambdaland.org&#x2F;posts&#x2F;2022-07-27_how_to_write_a_type_checker&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lambdaland.org&#x2F;posts&#x2F;2022-07-27_how_to_write_a_type_...</a><p>I left some links&#x2F;references to books that helped me out.</div><br/></div></div><div id="38272462" class="c"><input type="checkbox" id="c-38272462" checked=""/><div class="controls bullet"><span class="by">efnx</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38273927">prev</a><span>|</span><a href="#38270357">next</a><span>|</span><label class="collapse" for="c-38272462">[-]</label><label class="expand" for="c-38272462">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend <a href="https:&#x2F;&#x2F;github.com&#x2F;sdiehl&#x2F;write-you-a-haskell">https:&#x2F;&#x2F;github.com&#x2F;sdiehl&#x2F;write-you-a-haskell</a> as it is very developer friendly. It’s not complete, but it really gets the gears turning and will set you up for writing your own Hendley-Milner style type checker.</div><br/></div></div><div id="38270357" class="c"><input type="checkbox" id="c-38270357" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38272462">prev</a><span>|</span><a href="#38271424">next</a><span>|</span><label class="collapse" for="c-38270357">[-]</label><label class="expand" for="c-38270357">[11 more]</label></div><br/><div class="children"><div class="content">I would love to know more about what the author found difficult regarding type checking. As long as you don&#x27;t screw up your semantics to the point of needing a full blown constraint solver there should be no issues.<p>Edit: by &quot;screwing up semantics&quot; I mostly mean the combination of overloading and implicit conversions, which is known to cause issues in Java, C++, etc.</div><br/><div id="38270490" class="c"><input type="checkbox" id="c-38270490" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270357">parent</a><span>|</span><a href="#38271350">next</a><span>|</span><label class="collapse" for="c-38270490">[-]</label><label class="expand" for="c-38270490">[5 more]</label></div><br/><div class="children"><div class="content">The problem for me was that I had a rough idea of how to implement (essentially it&#x27;s similar to a recursive-descent parser), but I had a difficult time finding appropriate resources to confirm or deny whether my idea was solid, as well as tips and what not.<p>Basically, the existing material is a bunch of existing incredibly complicated implementations, the odd blog post that just throws a bunch of code your way without really explaining the why&#x2F;thought process behind it, and books that aren&#x27;t worth the money.<p>The result is that you can of course piece things together (as I did), but it leaves you forever wondering whether you did it in a sensible way, or if you constructed some weird monstrosity.<p>To put it differently: you can probably build a garden by digging some holes and throwing a few plants around, but without the right resources it can be difficult to determine what the impact of your approach may be, and whether there are better ways of going about it. Oh and I&#x27;m aware there are resources on gardening, it&#x27;s just a metaphor :)</div><br/><div id="38270597" class="c"><input type="checkbox" id="c-38270597" checked=""/><div class="controls bullet"><span class="by">Q6T46nT668w6i3m</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270490">parent</a><span>|</span><a href="#38270621">next</a><span>|</span><label class="collapse" for="c-38270597">[-]</label><label class="expand" for="c-38270597">[1 more]</label></div><br/><div class="children"><div class="content">As someone who has written many compilers and type checkers, I agree. There’s very little information online about the subject. I think part of the issue, for me, was psychological: I felt like I was missing some implementation theory that was presented alongside other compiler subjects (e.g., LALR) when the reality is that you’re mostly implementing very simple Boolean operations.</div><br/></div></div><div id="38270621" class="c"><input type="checkbox" id="c-38270621" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270490">parent</a><span>|</span><a href="#38270597">prev</a><span>|</span><a href="#38270688">next</a><span>|</span><label class="collapse" for="c-38270621">[-]</label><label class="expand" for="c-38270621">[1 more]</label></div><br/><div class="children"><div class="content">While helping a bit, it&#x27;s difficult to learn or reverse engineer from existing type checking code because a lot of them are mundane repetitive code implementing some high level theory and algorithms.  The actual code is too far remote from the theory.  You really want to start from the theory and the overall picture.<p>The Dragon book has a chapter on type checking.  It gives explanations on many topics. It has plenty of examples.  It has type treatments on different areas of a language, like expression, array, struct, function, pointer, etc.<p>Despite being really old, its ideas and explanation on the topic are still relevant.</div><br/></div></div><div id="38270688" class="c"><input type="checkbox" id="c-38270688" checked=""/><div class="controls bullet"><span class="by">mabster</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270490">parent</a><span>|</span><a href="#38270621">prev</a><span>|</span><a href="#38271350">next</a><span>|</span><label class="collapse" for="c-38270688">[-]</label><label class="expand" for="c-38270688">[2 more]</label></div><br/><div class="children"><div class="content">I think the larger writings like books are generally going to be written by academics so they&#x27;ll be rigorous and hard to read.<p>So that leaves blog posts for most developers actually implementing this stuff.<p>But the solution here is that when you finally figure out a good strategy to deal with something muddy like this is to write that better blog post :)</div><br/><div id="38270875" class="c"><input type="checkbox" id="c-38270875" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270688">parent</a><span>|</span><a href="#38271350">next</a><span>|</span><label class="collapse" for="c-38270875">[-]</label><label class="expand" for="c-38270875">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m planning on doing something similar to what I did for pattern matching [1]: basically building something entirely standalone that fits in 2k LOC or so, and explains the basics (i.e. nominal typing plus basic sub-typing), hopefully such that people can then take that and extend it.<p>As for _when_ I&#x27;ll do that, that depends on when I can convince my inner critic to actually commit to the idea :)<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;yorickpeterse&#x2F;pattern-matching-in-rust">https:&#x2F;&#x2F;github.com&#x2F;yorickpeterse&#x2F;pattern-matching-in-rust</a></div><br/></div></div></div></div></div></div><div id="38271350" class="c"><input type="checkbox" id="c-38271350" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270357">parent</a><span>|</span><a href="#38270490">prev</a><span>|</span><a href="#38271790">next</a><span>|</span><label class="collapse" for="c-38271350">[-]</label><label class="expand" for="c-38271350">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been implementing a language with a TypeScript-like type system, and while the core system is pretty intuitive (values combining with other values, determining whether basic value types fit into others), some of the fringes have been challenging:<p>- Generics, especially inferring generic type params<p>- Recursive types<p>- Deeply mutable vs immutable types<p>- Type refinement based on checks&#x2F;usage<p>- Giving good error messages for deep type mismatches (though I&#x27;m not sure TypeScript itself has figured this one out yet, lol)<p>etc. And even the stuff I&#x27;ve figured out, I figured out almost all from scratch (sometimes having to bail and take a totally new approach midway through). I would <i>love</i> to read a book giving me a proper bottom-up walkthrough of the current landscape of type system implementation</div><br/></div></div><div id="38271790" class="c"><input type="checkbox" id="c-38271790" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270357">parent</a><span>|</span><a href="#38271350">prev</a><span>|</span><a href="#38270554">next</a><span>|</span><label class="collapse" for="c-38271790">[-]</label><label class="expand" for="c-38271790">[2 more]</label></div><br/><div class="children"><div class="content">Would type-inference also &quot;screw up the semantics&quot;? My understanding is that this generally operates via some kind of constraints solving.</div><br/><div id="38274462" class="c"><input type="checkbox" id="c-38274462" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38271790">parent</a><span>|</span><a href="#38270554">next</a><span>|</span><label class="collapse" for="c-38274462">[-]</label><label class="expand" for="c-38274462">[1 more]</label></div><br/><div class="children"><div class="content">Depends on how much type inference you want.<p>If you want ML-style total type inference when you expect the compiler to deduce the parameter and the return types of your functions, then yes.<p>Local variable type inference isn&#x27;t hard at all, unless you want to do stuff like Rust: declare a variable without an initial value and infer its type from the first assignment downcode.</div><br/></div></div></div></div><div id="38270554" class="c"><input type="checkbox" id="c-38270554" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270357">parent</a><span>|</span><a href="#38271790">prev</a><span>|</span><a href="#38270575">next</a><span>|</span><label class="collapse" for="c-38270554">[-]</label><label class="expand" for="c-38270554">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript type-checking is quite complicated. I&#x27;m sure no human being on earth could pass a test of &quot;does this compile&quot;<p>But that&#x27;s an exception, and deliberately decided to be complex.</div><br/></div></div><div id="38270575" class="c"><input type="checkbox" id="c-38270575" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38270210">root</a><span>|</span><a href="#38270357">parent</a><span>|</span><a href="#38270554">prev</a><span>|</span><a href="#38271424">next</a><span>|</span><label class="collapse" for="c-38270575">[-]</label><label class="expand" for="c-38270575">[1 more]</label></div><br/><div class="children"><div class="content">I know nothing about how one would make a type checker, but it sort of feels like your comment is &quot;As long as you don&#x27;t encounter any issues, there won&#x27;t be any issues&quot;, no?</div><br/></div></div></div></div><div id="38271424" class="c"><input type="checkbox" id="c-38271424" checked=""/><div class="controls bullet"><span class="by">azdavis</span><span>|</span><a href="#38270210">parent</a><span>|</span><a href="#38270357">prev</a><span>|</span><a href="#38273919">next</a><span>|</span><label class="collapse" for="c-38271424">[-]</label><label class="expand" for="c-38271424">[1 more]</label></div><br/><div class="children"><div class="content">Might this help? I wrote it: <a href="https:&#x2F;&#x2F;azdavis.net&#x2F;posts&#x2F;define-pl-01&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;azdavis.net&#x2F;posts&#x2F;define-pl-01&#x2F;</a></div><br/></div></div></div></div><div id="38273919" class="c"><input type="checkbox" id="c-38273919" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38270210">prev</a><span>|</span><a href="#38270146">next</a><span>|</span><label class="collapse" for="c-38273919">[-]</label><label class="expand" for="c-38273919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In reality, gradual typing ends up giving you the worst of both dynamic and static typing: you get the uncertainty and lack of safety (in dynamically typed contexts) of dynamic typing, and the cost of trying to fit your ideas into a statically typed type system.<p>Depends on how you implement gradual typing. There&#x27;s a spectrum [1] of gradual languages, and the differences between, say TypeScript and Reticulated Python matter a great deal.<p>It is true that you can have some serious performance hits on the migration from dynamically typed -&gt; fully typed code; my advisor Ben Greenman is doing work examining that space of performance en route to fully-typed systems.<p>In practice, there are several gradually typed languages that give you very good performance when all the code is typed—i.e. you don&#x27;t have to pay a cost just for having dynamic in your language. You might have to pay a cost when you use it, and the cost can vary dramatically.<p>Note that&#x27;s just performance—sometimes performance matters less than being able to prototype something fast in a language, which is a feature I find valuable.<p>&gt; In fact, the few places where dynamic typing was used in the standard library was due to the type system not being powerful enough to provide a better alternative.<p>Hey, that sounds like either a win for gradual typing, or a sign that your type system needs some serious work! ;-)<p>[1]: <a href="https:&#x2F;&#x2F;prl.khoury.northeastern.edu&#x2F;blog&#x2F;2018&#x2F;10&#x2F;06&#x2F;a-spectrum-of-type-soundness-and-performance&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;prl.khoury.northeastern.edu&#x2F;blog&#x2F;2018&#x2F;10&#x2F;06&#x2F;a-spectr...</a></div><br/></div></div><div id="38270146" class="c"><input type="checkbox" id="c-38270146" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#38273919">prev</a><span>|</span><a href="#38270472">next</a><span>|</span><label class="collapse" for="c-38270146">[-]</label><label class="expand" for="c-38270146">[8 more]</label></div><br/><div class="children"><div class="content">Looking at the table in the end of the article: notice how Scala and Elixir both took only 3 years, because they were targeting an existing platform. Clojure took only 2 years and was developed by a single person.</div><br/><div id="38270754" class="c"><input type="checkbox" id="c-38270754" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38270146">parent</a><span>|</span><a href="#38270472">next</a><span>|</span><label class="collapse" for="c-38270754">[-]</label><label class="expand" for="c-38270754">[7 more]</label></div><br/><div class="children"><div class="content">&gt; only 3 years, because they were targeting an existing platform. Clojure took only 2 years and was d̶e̶v̶e̶l̶o̶p̶e̶d̶ ̶b̶y̶ <i>targeting</i> a single person.</div><br/><div id="38271207" class="c"><input type="checkbox" id="c-38271207" checked=""/><div class="controls bullet"><span class="by">cactusfrog</span><span>|</span><a href="#38270146">root</a><span>|</span><a href="#38270754">parent</a><span>|</span><a href="#38271084">next</a><span>|</span><label class="collapse" for="c-38271207">[-]</label><label class="expand" for="c-38271207">[5 more]</label></div><br/><div class="children"><div class="content">What do you think about clojure?</div><br/><div id="38271491" class="c"><input type="checkbox" id="c-38271491" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38270146">root</a><span>|</span><a href="#38271207">parent</a><span>|</span><a href="#38271084">next</a><span>|</span><label class="collapse" for="c-38271491">[-]</label><label class="expand" for="c-38271491">[4 more]</label></div><br/><div class="children"><div class="content">I like it, and certainly much more than java which I just can&#x27;t. I have trouble committing to clojure fully for larger projects because it&#x27;s still a bit niche in terms of the size of the community but nice that it interfaces with java, and for smaller one-off things I just use scheme.<p>oh, clojure also is a little bit weird being a sort of grab-bag collection of data structures that it inherits from java and then turns lisp-ish. doesn&#x27;t make it bad, each thing they add is nice, just feels a little motley<p>also, i refuse to call it &quot;closure&quot;, i pronounce the j</div><br/><div id="38274485" class="c"><input type="checkbox" id="c-38274485" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#38270146">root</a><span>|</span><a href="#38271491">parent</a><span>|</span><a href="#38273905">next</a><span>|</span><label class="collapse" for="c-38274485">[-]</label><label class="expand" for="c-38274485">[1 more]</label></div><br/><div class="children"><div class="content">&gt; also, i refuse to call it &quot;closure&quot;, i pronounce the j<p>Wait, it&#x27;s <i>not</i> &quot;clodger&quot;?</div><br/></div></div><div id="38273905" class="c"><input type="checkbox" id="c-38273905" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#38270146">root</a><span>|</span><a href="#38271491">parent</a><span>|</span><a href="#38274485">prev</a><span>|</span><a href="#38273437">next</a><span>|</span><label class="collapse" for="c-38273905">[-]</label><label class="expand" for="c-38273905">[1 more]</label></div><br/><div class="children"><div class="content"><i>also, i refuse to call it &quot;closure&quot;, i pronounce the j</i><p>Wow so edgy</div><br/></div></div><div id="38273437" class="c"><input type="checkbox" id="c-38273437" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38270146">root</a><span>|</span><a href="#38271491">parent</a><span>|</span><a href="#38273905">prev</a><span>|</span><a href="#38271084">next</a><span>|</span><label class="collapse" for="c-38273437">[-]</label><label class="expand" for="c-38273437">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a bit niche in terms of the size of the community<p>i say it&#x27;s the largest lisp like community out there tbh.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38270472" class="c"><input type="checkbox" id="c-38270472" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#38270146">prev</a><span>|</span><a href="#38274087">next</a><span>|</span><label class="collapse" for="c-38270472">[-]</label><label class="expand" for="c-38270472">[17 more]</label></div><br/><div class="children"><div class="content">As someone who has worked with massive typed Python codebases, I 100% agree with the author on Gradual Typing. It&#x27;s literally the <i>worst</i> of both worlds. It&#x27;s actually even worse than that because it gives the <i>illusion</i> of some safety when there isn&#x27;t any, especially in Python where most of the tooling &quot;fails open&quot; by default and won&#x27;t tell you something is wrong despite having annotations.</div><br/><div id="38270665" class="c"><input type="checkbox" id="c-38270665" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38274531">next</a><span>|</span><label class="collapse" for="c-38270665">[-]</label><label class="expand" for="c-38270665">[6 more]</label></div><br/><div class="children"><div class="content">I disagree, as somebody who has also worked with tons of type-hinted Python code.  Gradual typing is obviously worse than real static typing, but it&#x27;s a step up from full dynamic typing.  It has caught many bugs for me before hitting them in runtime, and provides good documentation about what I can expect a function to accept and return without forcing me to read prose.<p>Type hints don&#x27;t provide any safety, though.  That was never the goal, given that they&#x27;re strictly optional and don&#x27;t really exist at runtime anyway (though I have written some experimental monstrosities that used annotations for code generation at runtime).  They&#x27;re documentation in a standard form that static analysis tools can leverage.<p>I really can&#x27;t imagine a situation where having type hints in Python is worse than simply not having them.  They&#x27;re not the worst of both worlds, they&#x27;re a compromise with some of the benefits and drawbacks of each.</div><br/><div id="38271688" class="c"><input type="checkbox" id="c-38271688" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38270665">parent</a><span>|</span><a href="#38274531">next</a><span>|</span><label class="collapse" for="c-38271688">[-]</label><label class="expand" for="c-38271688">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I really can&#x27;t imagine a situation where having type hints in Python is worse than simply not having them.<p>Can’t they lie &#x2F; go out of sync with what’s actually happening? IMO, an unenforced type hint is very dangerous because of this - it can give you a false sense of confidence in a scenario where you would otherwise write more defensive code.</div><br/><div id="38272889" class="c"><input type="checkbox" id="c-38272889" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38271688">parent</a><span>|</span><a href="#38272461">next</a><span>|</span><label class="collapse" for="c-38272889">[-]</label><label class="expand" for="c-38272889">[1 more]</label></div><br/><div class="children"><div class="content">I suppose, if you&#x27;re relying on type stubs. Ordinary in-line type hints won&#x27;t lie or go out of sync without complaining somewhere though.<p>Defensive code is good, but I&#x27;m absolutely sick of writing code that has to be defensive about the type of absolutely every variable everywhere. It&#x27;s ridiculous, verbose, and nearly impossible to do universally. THAT is the worst of both worlds. Having to manually fret about the types that every variable may hold. At the point that you&#x27;re having to write defensive code due to dynamic types, you&#x27;ve already lost the advantages of dynamic types entirely.<p>I use type hints to say &quot;use and expect these types or get Undefined Behavior&quot;, and that contract is good enough for me.</div><br/></div></div><div id="38272461" class="c"><input type="checkbox" id="c-38272461" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38271688">parent</a><span>|</span><a href="#38272889">prev</a><span>|</span><a href="#38271811">next</a><span>|</span><label class="collapse" for="c-38272461">[-]</label><label class="expand" for="c-38272461">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is my whole point. Mypy by default will silently <i>allow</i> blatantly incorrect typing which is worse than no types IMO.</div><br/></div></div><div id="38271811" class="c"><input type="checkbox" id="c-38271811" checked=""/><div class="controls bullet"><span class="by">actuallyalys</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38271688">parent</a><span>|</span><a href="#38272461">prev</a><span>|</span><a href="#38271816">next</a><span>|</span><label class="collapse" for="c-38271811">[-]</label><label class="expand" for="c-38271811">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if you don’t run the type-checker regularly and just run the code itself, there’s nothing preventing them from going out of sync. Type hints are similar to tests in that way.</div><br/></div></div><div id="38271816" class="c"><input type="checkbox" id="c-38271816" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38271688">parent</a><span>|</span><a href="#38271811">prev</a><span>|</span><a href="#38274531">next</a><span>|</span><label class="collapse" for="c-38271816">[-]</label><label class="expand" for="c-38271816">[1 more]</label></div><br/><div class="children"><div class="content">I suspect Python is particularly bad in this regard. For example, PHP&#x27;s gradual typing is enforced with runtime assertions.</div><br/></div></div></div></div></div></div><div id="38274531" class="c"><input type="checkbox" id="c-38274531" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38270665">prev</a><span>|</span><a href="#38270560">next</a><span>|</span><label class="collapse" for="c-38274531">[-]</label><label class="expand" for="c-38274531">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the gradual typing. It&#x27;s that static typing gives you the illusion of some safety where there isn&#x27;t any.</div><br/></div></div><div id="38270560" class="c"><input type="checkbox" id="c-38270560" checked=""/><div class="controls bullet"><span class="by">Q6T46nT668w6i3m</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38274531">prev</a><span>|</span><a href="#38272196">next</a><span>|</span><label class="collapse" for="c-38270560">[-]</label><label class="expand" for="c-38270560">[4 more]</label></div><br/><div class="children"><div class="content">Any? I regularly find bugs. I don’t find every bug, but finding some bugs is better than none. Especially for the minimal cost of writing annotations.</div><br/><div id="38270712" class="c"><input type="checkbox" id="c-38270712" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38270560">parent</a><span>|</span><a href="#38272196">next</a><span>|</span><label class="collapse" for="c-38270712">[-]</label><label class="expand" for="c-38270712">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t find every bug, but finding some bugs is better than none.<p>I used to think this, but based on experience I&#x27;m now less convinced. Finding most bugs, like real static typing does, is great; you can significantly reduce your test coverage and iterate with more confidence. Finding a few bugs is pretty useless if you&#x27;re not finding enough to actually change your workflow.</div><br/><div id="38270790" class="c"><input type="checkbox" id="c-38270790" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38270712">parent</a><span>|</span><a href="#38272196">next</a><span>|</span><label class="collapse" for="c-38270790">[-]</label><label class="expand" for="c-38270790">[2 more]</label></div><br/><div class="children"><div class="content">Finding a few bugs is very useful if they&#x27;re the kind of bugs that can cause problems in production but usually not in development or testing, like not checking an optional that is very rarely null.<p>It&#x27;s not about workflow or finding enough bugs, but finding bugs that you might not have otherwise seen can be monumentally beneficial.</div><br/><div id="38270947" class="c"><input type="checkbox" id="c-38270947" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38270472">root</a><span>|</span><a href="#38270790">parent</a><span>|</span><a href="#38272196">next</a><span>|</span><label class="collapse" for="c-38270947">[-]</label><label class="expand" for="c-38270947">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Finding a few bugs is very useful if they&#x27;re the kind of bugs that can cause problems in production but usually not in development or testing, like not checking an optional that is very rarely null.<p>There&#x27;s a kind of excluded middle here though. Either that kind of bug hits production often enough to matter - in which case a checker that catches it sometimes isn&#x27;t good enough, you need a checker that eliminates it completely. Or it doesn&#x27;t hit production often enough to matter, in which case a checker is of limited use.</div><br/></div></div></div></div></div></div></div></div><div id="38272196" class="c"><input type="checkbox" id="c-38272196" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38270560">prev</a><span>|</span><a href="#38270690">next</a><span>|</span><label class="collapse" for="c-38272196">[-]</label><label class="expand" for="c-38272196">[1 more]</label></div><br/><div class="children"><div class="content">Gradual typing is great. The parts you want precision on are statically typed, the parts that don&#x27;t matter dynamic, and they fit together sanely at the language level.<p>Writing type annotations in comments for an optional preprocessor to pass judgement on before the actual implementation ignores them is a bad thing. But that&#x27;s on python, not on gradual typing.<p>(An any type + static is also fine if you have a way to retrieve type information at runtime, and there&#x27;s a sense in which template instantiations of a generic function and a function taking arguments of type any are the same thing as each other)</div><br/></div></div><div id="38270690" class="c"><input type="checkbox" id="c-38270690" checked=""/><div class="controls bullet"><span class="by">ric2b</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38272196">prev</a><span>|</span><a href="#38271170">next</a><span>|</span><label class="collapse" for="c-38270690">[-]</label><label class="expand" for="c-38270690">[1 more]</label></div><br/><div class="children"><div class="content">How is it worse than no typing? If you&#x27;re not testing adequately because you think type safety is enough, you done f&#x27;d up.</div><br/></div></div><div id="38271501" class="c"><input type="checkbox" id="c-38271501" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38271170">prev</a><span>|</span><a href="#38272563">next</a><span>|</span><label class="collapse" for="c-38271501">[-]</label><label class="expand" for="c-38271501">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s type hints are just that, hints. They aren&#x27;t static type annotations. Cython uses gradual typing, but the mainstream Python implementation does not actually offer gradual typing. It&#x27;s still dynamically typed, but with an annotation mechanism that lets other tools do some analysis for you.</div><br/></div></div><div id="38272563" class="c"><input type="checkbox" id="c-38272563" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#38270472">parent</a><span>|</span><a href="#38271501">prev</a><span>|</span><a href="#38274087">next</a><span>|</span><label class="collapse" for="c-38272563">[-]</label><label class="expand" for="c-38272563">[1 more]</label></div><br/><div class="children"><div class="content">I know someone that was on the Dart team and they say the same thing.</div><br/></div></div></div></div><div id="38274087" class="c"><input type="checkbox" id="c-38274087" checked=""/><div class="controls bullet"><span class="by">gilmi</span><span>|</span><a href="#38270472">prev</a><span>|</span><a href="#38270294">next</a><span>|</span><label class="collapse" for="c-38274087">[-]</label><label class="expand" for="c-38274087">[1 more]</label></div><br/><div class="children"><div class="content">I really enjoyed the article.<p>I think one way to simplify language creation is to use an existing language with somewhat similar operational semantics as a compilation target. This simplifies the backend a lot and leaves more time to explore what the language (frontend) should look like. The backend can always be rewritten at a later time. My personal choice is usually JavaScript[1].<p>Regarding type checkers&#x2F;type inference, I&#x27;ve also ran into difficulties with this topic, and I&#x27;ve written several articles trying to make it more approachable[2].<p>[1]: <a href="https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;post&#x2F;2023&#x2F;07&#x2F;08&#x2F;js-as-a-target" rel="nofollow noreferrer">https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;post&#x2F;2023&#x2F;07&#x2F;08&#x2F;js-as-a-target</a><p>[2]: <a href="https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;tags&#x2F;type%20inference" rel="nofollow noreferrer">https:&#x2F;&#x2F;gilmi.me&#x2F;blog&#x2F;tags&#x2F;type%20inference</a></div><br/></div></div><div id="38270294" class="c"><input type="checkbox" id="c-38270294" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#38274087">prev</a><span>|</span><a href="#38272806">next</a><span>|</span><label class="collapse" for="c-38270294">[-]</label><label class="expand" for="c-38270294">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Avoid writing your own code generator, linker, etc&quot;<p>There&#x27;s a certain dearth of pluggable code generators and linkers. Well, not on GNU&#x2F;Linux, where you get both as(1) and ld(1) practically out of the box, but making your compiler emit a PE&#x2F;COFF on Windows is a pain. You either bring your own homemade codegen and linker or use LLVM, using Microsoft&#x27;s ml64.exe and link.exe is incredibly impractical.</div><br/></div></div><div id="38272806" class="c"><input type="checkbox" id="c-38272806" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38270294">prev</a><span>|</span><a href="#38268523">next</a><span>|</span><label class="collapse" for="c-38272806">[-]</label><label class="expand" for="c-38272806">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I used an S-expression syntax, instead of designing my own syntax and writing a parser for it.<p>&gt; This meant I was able to experiment with the semantics and virtual machine of the language, instead of worrying over what keyword to use for function definitions.<p>Yeah. I see a lot of people asking why people are so fascinated by lisp and why there are so many lisps out there. I think this is a huge reason. It certainly was for me.<p>I just wanted to get some ideas working as soon as possible. Lisp is the easiest language to parse that I&#x27;ve ever seen, managed to write a parser by hand. And yet it&#x27;s a fully featured programming language. It just gives you huge power for very low effort. It took a single bit to add metaprogramming to my lisp:<p><pre><code>  if (function.flags.evaluate_arguments) {
    arguments = evaluate_all(interpreter, environment, arguments);
  }
</code></pre>
I see it as a little frontend for my data structures. I get to work on them endlessly and everything I do improves something.</div><br/><div id="38273721" class="c"><input type="checkbox" id="c-38273721" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38272806">parent</a><span>|</span><a href="#38273502">next</a><span>|</span><label class="collapse" for="c-38273721">[-]</label><label class="expand" for="c-38273721">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Lisp is the easiest language to parse that I&#x27;ve ever seen, managed to write a parser by hand.<p>I&#x27;ve written a dozen or so parsers for different languages by hand: the parser is easy <i>regardless</i> of the syntax you choose. The complicated bit is always compilation&#x2F;interpretation.<p>The biggest value I see to using S-expressions isn&#x27;t the time saved in writing a parser, it&#x27;s reducing the amount of bikeshedding you&#x27;ll be tempted to do fiddling with syntax.</div><br/><div id="38274224" class="c"><input type="checkbox" id="c-38274224" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38272806">root</a><span>|</span><a href="#38273721">parent</a><span>|</span><a href="#38273984">next</a><span>|</span><label class="collapse" for="c-38274224">[-]</label><label class="expand" for="c-38274224">[1 more]</label></div><br/><div class="children"><div class="content">That rings untrue in the face of how John MacCarthy specified Lisp interpretation, on paper, in Lisp itself, quite briefly, and didn&#x27;t even suspect it would be executable. Then Steve Russel comes along, and bootstraps it by hand-translating it to code.</div><br/></div></div><div id="38273984" class="c"><input type="checkbox" id="c-38273984" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38272806">root</a><span>|</span><a href="#38273721">parent</a><span>|</span><a href="#38274224">prev</a><span>|</span><a href="#38273502">next</a><span>|</span><label class="collapse" for="c-38273984">[-]</label><label class="expand" for="c-38273984">[3 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t languages like C notoriously difficult to parse? I&#x27;ve read that they&#x27;re actually context sensitive. IIRC much of Go&#x27;s syntax was designed to avoid parsing complexity.</div><br/><div id="38274312" class="c"><input type="checkbox" id="c-38274312" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38272806">root</a><span>|</span><a href="#38273984">parent</a><span>|</span><a href="#38274220">next</a><span>|</span><label class="collapse" for="c-38274312">[-]</label><label class="expand" for="c-38274312">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that the interpretation of C cannot be specified in a brief page of C code. For one thing, the language doesn&#x27;t supply the data structures for representing any aspec of itself; the code will have to invent those: declarations, definitions, statements, types. Then handle a ton of cases.<p>It will not be obvious that what the C code is doing is C interpretation, because all those data structures don&#x27;t resemble the C syntax.<p>The Lisp meta-circular interpreter side-steps that; the issue is settled elsewhere. It exists against a backdrop where the easy correspondence between the printed syntax and the data structure being handled by the interpreter is taken for granted.<p>The C would need the same kind of backdrop; and that would be a lot of documentation.</div><br/></div></div><div id="38274220" class="c"><input type="checkbox" id="c-38274220" checked=""/><div class="controls bullet"><span class="by">shaftoe444</span><span>|</span><a href="#38272806">root</a><span>|</span><a href="#38273984">parent</a><span>|</span><a href="#38274312">prev</a><span>|</span><a href="#38273502">next</a><span>|</span><label class="collapse" for="c-38274220">[-]</label><label class="expand" for="c-38274220">[1 more]</label></div><br/><div class="children"><div class="content">See the clockwise&#x2F;spiral rule!</div><br/></div></div></div></div></div></div><div id="38273502" class="c"><input type="checkbox" id="c-38273502" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38272806">parent</a><span>|</span><a href="#38273721">prev</a><span>|</span><a href="#38273600">next</a><span>|</span><label class="collapse" for="c-38273502">[-]</label><label class="expand" for="c-38273502">[2 more]</label></div><br/><div class="children"><div class="content">I found that a naive frontend for a language is not that big of a deal with something like ANTLR. The benefit is that you have a formal grammar syntax description, and you can iterate on that endlessly without too many code changes down the line.</div><br/><div id="38274350" class="c"><input type="checkbox" id="c-38274350" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38272806">root</a><span>|</span><a href="#38273502">parent</a><span>|</span><a href="#38273600">next</a><span>|</span><label class="collapse" for="c-38274350">[-]</label><label class="expand" for="c-38274350">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t with a handwritten lexer&#x2F;parser either, the real work starts after the parsing is complete. Of course, there are two possibilities: often changing them can either result in a cleaner, more readable result or a _real_ mess ;)
But you have to rewrite it by hand anyways if you want to get better (or usable) error messages and incremental parsing for a LSP.</div><br/></div></div></div></div><div id="38273600" class="c"><input type="checkbox" id="c-38273600" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#38272806">parent</a><span>|</span><a href="#38273502">prev</a><span>|</span><a href="#38268523">next</a><span>|</span><label class="collapse" for="c-38273600">[-]</label><label class="expand" for="c-38273600">[1 more]</label></div><br/><div class="children"><div class="content">I see lisp as sort of &quot;no syntax&quot;. It&#x27;s basically the AST. Which is a good thing, you can concentrate on the compiler and add syntax later.
If you are working on a compiler for a non lisp PL, it makes sense to log the AST after parsing, as a lisp, as a readable AST.</div><br/></div></div></div></div><div id="38268523" class="c"><input type="checkbox" id="c-38268523" checked=""/><div class="controls bullet"><span class="by">otoburb</span><span>|</span><a href="#38272806">prev</a><span>|</span><a href="#38271469">next</a><span>|</span><label class="collapse" for="c-38268523">[-]</label><label class="expand" for="c-38268523">[24 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;<i>&quot;In reality, gradual typing ends up giving you the worst of both dynamic and static typing: you get the uncertainty and lack of safety (in dynamically typed contexts) of dynamic typing, and the cost of trying to fit your ideas into a statically typed type system. I also found that the use of gradual typing didn&#x27;t actually make me more productive compared to using static typing.&quot;</i><p>The Elixir team didn’t get that memo because they are actively in the process of researching and working on a gradual type implementation.[1]<p>[1] <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradual-typing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2023&#x2F;09&#x2F;20&#x2F;strong-arrows-gradua...</a></div><br/><div id="38269148" class="c"><input type="checkbox" id="c-38269148" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#38268523">parent</a><span>|</span><a href="#38269677">next</a><span>|</span><label class="collapse" for="c-38269148">[-]</label><label class="expand" for="c-38269148">[5 more]</label></div><br/><div class="children"><div class="content">Pursuing gradual typing makes sense when you&#x27;ve got an established dynamic language and want to incorporate typing into it (forget Elixir, let&#x27;s just look at the massive success of TypeScript). But as OP&#x27;s recommendation says - &quot;for new languages&quot;, gradual typing has lots of costs and fewer benefits.<p>To put it in other terms: my informal impression is that the dynamic &quot;features&quot; of TypeScript are used grudgingly; the community strongly pushes towards strictness, eliminating anys, preferring well-typed libraries, and so on. There&#x27;s little appetite to - in a single project, unless absolutely required - mix-and-match dynamism with staticness, which is the thing that gradual typing gets you. Rather, it feels like we&#x27;re migrating from dynamic to static and gradual typing is just how we&#x27;re doing the migration. But in the case of a new language, why not just start at the destination?</div><br/><div id="38270605" class="c"><input type="checkbox" id="c-38270605" checked=""/><div class="controls bullet"><span class="by">galdor</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269148">parent</a><span>|</span><a href="#38269963">next</a><span>|</span><label class="collapse" for="c-38270605">[-]</label><label class="expand" for="c-38270605">[3 more]</label></div><br/><div class="children"><div class="content">I might be missing something, but the appeal of gradual typing to me is that I can mostly type functions, providing safe input&#x2F;output boundaries, and avoid having to type every single variable (unless I have to do so for performance reasons, as I do in Common Lisp).<p>This approach is comfortable to me both in Erlang and in Common Lisp, I see it as a balance between safety&#x2F;performances and development speed (and I&#x27;m saying that as someone using Go for all professional development and being really happy with its full static typing).</div><br/><div id="38270724" class="c"><input type="checkbox" id="c-38270724" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270605">parent</a><span>|</span><a href="#38272535">next</a><span>|</span><label class="collapse" for="c-38270724">[-]</label><label class="expand" for="c-38270724">[1 more]</label></div><br/><div class="children"><div class="content">&gt; avoid having to type every single variable<p>Most static languages don&#x27;t make you type every single variable anymore.  Java, C++, Rust, C#, and many others let you make the compiler infer types where reasonably possible.  That&#x27;s still full static typing.<p>My Python and Rust have about the same kinds of explicit type annotations in roughly the same places.  My C++ has a little bit more, just because `Foo obj{a}` is more idiomatic than `auto foo = Foo{a}`.</div><br/></div></div><div id="38272535" class="c"><input type="checkbox" id="c-38272535" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270605">parent</a><span>|</span><a href="#38270724">prev</a><span>|</span><a href="#38269963">next</a><span>|</span><label class="collapse" for="c-38272535">[-]</label><label class="expand" for="c-38272535">[1 more]</label></div><br/><div class="children"><div class="content">You can do that with type inference and a strong, static type system.</div><br/></div></div></div></div><div id="38269963" class="c"><input type="checkbox" id="c-38269963" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269148">parent</a><span>|</span><a href="#38270605">prev</a><span>|</span><a href="#38269677">next</a><span>|</span><label class="collapse" for="c-38269963">[-]</label><label class="expand" for="c-38269963">[1 more]</label></div><br/><div class="children"><div class="content">I wish Python was further down this path— I experimented with adding annotations and the mypy checker to a bunch of code at my company, and it seemed hopeless. Most libraries didn&#x27;t have annotations at all, or there were annotations being maintained by a third party in a separate pypi package, but the annotations were out of sync with the main project and thus blew up in weird ways.<p>I feel for the people trying to develop these gradual systems but it&#x27;s truly a herculean task, especially in the Python community that is now understandably so <i>extremely</i> shy about major breaking changes.</div><br/></div></div></div></div><div id="38269677" class="c"><input type="checkbox" id="c-38269677" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#38268523">parent</a><span>|</span><a href="#38269148">prev</a><span>|</span><a href="#38270149">next</a><span>|</span><label class="collapse" for="c-38269677">[-]</label><label class="expand" for="c-38269677">[8 more]</label></div><br/><div class="children"><div class="content">I think the author&#x27;s recommendation has some needed context:<p><i>&gt; Recommendation: either make your language statically typed or dynamically typed (preferably statically typed, but that&#x27;s a different topic), as gradual typing just doesn&#x27;t make sense for new languages.</i><p>The &quot;for new languages&quot; part is really important. Gradual typing makes a lot of sense when you are trying to retrofit some amount of static checking onto an existing enormous corpus of dynamically typed code. That&#x27;s the case for TypeScript with JavaScript and Elixir with Elixir and Erlang.</div><br/><div id="38270034" class="c"><input type="checkbox" id="c-38270034" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269677">parent</a><span>|</span><a href="#38270494">next</a><span>|</span><label class="collapse" for="c-38270034">[-]</label><label class="expand" for="c-38270034">[3 more]</label></div><br/><div class="children"><div class="content">Raku (formerly known as Perl 6 and a radically different language than Perl 5) uses gradual typing on purpose. It&#x27;s a cool language that has a lot of advanced ideas, but has basically been in either the design or beta stage for like two decades.</div><br/><div id="38270880" class="c"><input type="checkbox" id="c-38270880" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270034">parent</a><span>|</span><a href="#38270494">next</a><span>|</span><label class="collapse" for="c-38270880">[-]</label><label class="expand" for="c-38270880">[2 more]</label></div><br/><div class="children"><div class="content">&gt;for like two decades.<p>IOW, Raku is a gradual type of language.</div><br/><div id="38271832" class="c"><input type="checkbox" id="c-38271832" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270880">parent</a><span>|</span><a href="#38270494">next</a><span>|</span><label class="collapse" for="c-38271832">[-]</label><label class="expand" for="c-38271832">[1 more]</label></div><br/><div class="children"><div class="content">Other puns are not as good as this pun</div><br/></div></div></div></div></div></div><div id="38270494" class="c"><input type="checkbox" id="c-38270494" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269677">parent</a><span>|</span><a href="#38270034">prev</a><span>|</span><a href="#38269781">next</a><span>|</span><label class="collapse" for="c-38270494">[-]</label><label class="expand" for="c-38270494">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right about this applying to new languages. I&#x27;ve added a note to the article to (hopefully) make this more clear.</div><br/></div></div><div id="38269781" class="c"><input type="checkbox" id="c-38269781" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269677">parent</a><span>|</span><a href="#38270494">prev</a><span>|</span><a href="#38269695">next</a><span>|</span><label class="collapse" for="c-38269781">[-]</label><label class="expand" for="c-38269781">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, as far as I know Elixir has a lot of calling back and forth with Erlang code.  So that makes for a super tricky type system problem.<p>I think the macros make it even harder.  Elixir appears to be done almost all with macros -- there are lots of little &quot;compilers&quot; to Erlang&#x2F;BEAM.</div><br/></div></div><div id="38269695" class="c"><input type="checkbox" id="c-38269695" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269677">parent</a><span>|</span><a href="#38269781">prev</a><span>|</span><a href="#38270149">next</a><span>|</span><label class="collapse" for="c-38269695">[-]</label><label class="expand" for="c-38269695">[2 more]</label></div><br/><div class="children"><div class="content">What about Julia?</div><br/><div id="38272209" class="c"><input type="checkbox" id="c-38272209" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38269695">parent</a><span>|</span><a href="#38270149">next</a><span>|</span><label class="collapse" for="c-38272209">[-]</label><label class="expand" for="c-38272209">[1 more]</label></div><br/><div class="children"><div class="content">Julia isn&#x27;t gradually typed. It&#x27;s strongly but dynamically typed.</div><br/></div></div></div></div></div></div><div id="38270149" class="c"><input type="checkbox" id="c-38270149" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38268523">parent</a><span>|</span><a href="#38269677">prev</a><span>|</span><a href="#38271524">next</a><span>|</span><label class="collapse" for="c-38270149">[-]</label><label class="expand" for="c-38270149">[2 more]</label></div><br/><div class="children"><div class="content">What you can do is the opposite, integrate a “dynamic” type into a statically-types language, like C# does: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;advanced-topics&#x2F;interop&#x2F;using-type-dynamic" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;advanced-top...</a><p>This lets you use dynamic typing when you want, and enables more seamless interoperability with dynamically-typed languages.</div><br/><div id="38273661" class="c"><input type="checkbox" id="c-38273661" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270149">parent</a><span>|</span><a href="#38271524">next</a><span>|</span><label class="collapse" for="c-38273661">[-]</label><label class="expand" for="c-38273661">[1 more]</label></div><br/><div class="children"><div class="content">Is it not literally the same on a type system level? Of course it could be very different from a user-perspective, as the ratio of `dynamic` will be <i>very</i> low in case of C#.</div><br/></div></div></div></div><div id="38271524" class="c"><input type="checkbox" id="c-38271524" checked=""/><div class="controls bullet"><span class="by">ralmidani</span><span>|</span><a href="#38268523">parent</a><span>|</span><a href="#38270149">prev</a><span>|</span><a href="#38270258">next</a><span>|</span><label class="collapse" for="c-38271524">[-]</label><label class="expand" for="c-38271524">[1 more]</label></div><br/><div class="children"><div class="content">A sibling addresses the nuance expressed in “for new languages”. But even if the original author’s opinion was that gradual typing is always bad, why does that mean we should dismiss the Elixir team’s efforts?<p>I have opinions about Elixir, mostly around aesthetics (for context, I started programming in Python, not Ruby), but that doesn’t mean my opinions are objectively more valid than those of a genius like José Valim.<p>I’ve actually found Elixir to be very well-designed and internally consistent, and after two years using it, it’s obvious to me that José and team are very thoughtful and deliberative. I don’t think they want to introduce gradual typing because it’s trendy.</div><br/></div></div><div id="38270258" class="c"><input type="checkbox" id="c-38270258" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38268523">parent</a><span>|</span><a href="#38271524">prev</a><span>|</span><a href="#38272424">next</a><span>|</span><label class="collapse" for="c-38270258">[-]</label><label class="expand" for="c-38270258">[5 more]</label></div><br/><div class="children"><div class="content">Well, there&#x27;s no memo (real or as a manner of speaking). It&#x27;s just this person&#x27;s preference.<p>I think gradual typing is a nice concept, and his arguments against it amount to &quot;gradual typing is not stating typing&quot;, which is like the whole point. E.g. he goes on how the compiler can&#x27;t do some optimizations on functions using gradual typing, but, well, it isn&#x27;t supposed to anyway.<p>The benefit of gradual typing is that you can make your program fully dynamic (e.g. for quick exploration), and if you want more assurances and optimizations make it fully static, or if you just want that for specific parts, do them static. And you have the option to go for any of those 3 things from the start.</div><br/><div id="38270556" class="c"><input type="checkbox" id="c-38270556" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270258">parent</a><span>|</span><a href="#38272424">next</a><span>|</span><label class="collapse" for="c-38270556">[-]</label><label class="expand" for="c-38270556">[4 more]</label></div><br/><div class="children"><div class="content">The problem about the whole &quot;it&#x27;s faster (productivity wise) than static typing&quot; has, as far as I know, never actually been proven (certainly not through repeated studies).<p>Having worked with both dynamically and statically typed languages extensively, I never felt I was _more_ productive in a dynamically (or gradually) typed language compared to one that was just statically typed. For very basic programs you may spend a bit more time typing in a statically typed language due to having to add type annotations, but typing isn&#x27;t what I spend most of my time on, so it&#x27;s not a big deal.<p>In addition, that work you need to (potentially) pay upfront will help you a lot in the long term, so I suspect that for anything but the most basic programs static typing leads to better productivity over time.</div><br/><div id="38271127" class="c"><input type="checkbox" id="c-38271127" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270556">parent</a><span>|</span><a href="#38270889">next</a><span>|</span><label class="collapse" for="c-38271127">[-]</label><label class="expand" for="c-38271127">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>The problem about the whole &quot;it&#x27;s faster (productivity wise) than static typing&quot; has, as far as I know, never actually been proven (certainly not through repeated studies).</i><p>Neither has the opposite, so there&#x27;s that.<p>There&#x27;s an ACM paper too (&quot;An Experiment About Static and Dynamic Type Systems&quot;, 2010) which found higher productivity for the same code quality with dynamic typing. Of course a few papers here and there, pro or against, are as good as none. It&#x27;s hardly a well studied area.<p>Besides, one or the other proven better doesn&#x27;t mean much, just like you liking eggs over easy vs scrambled eggs doesn&#x27;t depend on some study. If it works for you, and you&#x27;re more productive with dynamic typing or static typing, use that.<p>Even if a study &quot;proved&quot; that one kind is &quot;more productive&quot; based on some statistics from measuring some group, or that it has &quot;less bugs&quot; most people when given a choice would still use what they prefer and makes them, as individuals, more productive and happy coding.<p>&gt;<i>Having worked with both dynamically and statically typed languages extensively, I never felt I was _more_ productive in a dynamically (or gradually) typed language compared to one that was just statically typed.</i><p>Depends on the type of program, the type of programming (e.g. imperative&#x2F;declarive&#x2F;functional&#x2F;logical&#x2F;OO or some combination and so on), the program&#x27;s scale, the team size, and other aspects, including individual aptitude and preference, not to mention the language and its semantics beyond dynamic&#x2F;static (and the ecosystem too). I&#x27;d certainly be way more producting using dynamic numpy than some C equivalent, even if as a lib it had feature parity.<p>&gt;<i>In addition, that work you need to (potentially) pay upfront will help you a lot in the long term, so I suspect that for anything but the most basic programs static typing leads to better productivity over time.</i><p>There are problems where upfront work is not a benefit, e.g. if it means getting behind in building your MVP or getting behind a competitor adding new features faster while you &quot;perfect it&quot;, and your early stage startup loses steam. Also for things where the overhead of upfront might put you off from even attempting them. It can also be a problem to have big upfront costs for exploratory programming and searching into the problem space for your design&#x2F;solution.</div><br/></div></div><div id="38270889" class="c"><input type="checkbox" id="c-38270889" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270556">parent</a><span>|</span><a href="#38271127">prev</a><span>|</span><a href="#38272424">next</a><span>|</span><label class="collapse" for="c-38270889">[-]</label><label class="expand" for="c-38270889">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s unfair to criticise the lack of studies for that specific question without acknowledging that there are exceedingly few studies that show a benefit for static typing despite the fact that a huge number of people <i>feel</i> that there must be an effect.</div><br/><div id="38271166" class="c"><input type="checkbox" id="c-38271166" checked=""/><div class="controls bullet"><span class="by">mjhay</span><span>|</span><a href="#38268523">root</a><span>|</span><a href="#38270889">parent</a><span>|</span><a href="#38272424">next</a><span>|</span><label class="collapse" for="c-38271166">[-]</label><label class="expand" for="c-38271166">[1 more]</label></div><br/><div class="children"><div class="content">IIRC there was a study that looked at the proportion of Github issues labeled as bugs, by language. Clojure came in with the lowest proportion. I <i>overall</i> prefer static typing, depending on what I&#x27;m doing, but I think avoiding ubiquitous mutable state is a lot more important than typing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38271469" class="c"><input type="checkbox" id="c-38271469" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38268523">prev</a><span>|</span><a href="#38272299">next</a><span>|</span><label class="collapse" for="c-38271469">[-]</label><label class="expand" for="c-38271469">[1 more]</label></div><br/><div class="children"><div class="content">Related post &quot;Inko Programming Language&quot; which might get some interesting comments.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38270265">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38270265</a><p><a href="https:&#x2F;&#x2F;inko-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;inko-lang.org&#x2F;</a></div><br/></div></div><div id="38272299" class="c"><input type="checkbox" id="c-38272299" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#38271469">prev</a><span>|</span><a href="#38271029">next</a><span>|</span><label class="collapse" for="c-38272299">[-]</label><label class="expand" for="c-38272299">[1 more]</label></div><br/><div class="children"><div class="content">Related discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38270265">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38270265</a></div><br/></div></div><div id="38271029" class="c"><input type="checkbox" id="c-38271029" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38272299">prev</a><span>|</span><a href="#38270515">next</a><span>|</span><label class="collapse" for="c-38271029">[-]</label><label class="expand" for="c-38271029">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Avoid self-hosting your compiler<p>Not sure this is so problematic anymore.<p>The Zig folks targeted WASM so that they can bootstrap without needing a second compiler implementation.  Compilers don&#x27;t need a lot of POSIX in order to be functional.</div><br/><div id="38271068" class="c"><input type="checkbox" id="c-38271068" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#38271029">parent</a><span>|</span><a href="#38270515">next</a><span>|</span><label class="collapse" for="c-38271068">[-]</label><label class="expand" for="c-38271068">[2 more]</label></div><br/><div class="children"><div class="content">Oh that&#x27;s a great point! Didn&#x27;t someone give a talk about that too?</div><br/><div id="38271140" class="c"><input type="checkbox" id="c-38271140" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38271029">root</a><span>|</span><a href="#38271068">parent</a><span>|</span><a href="#38270515">next</a><span>|</span><label class="collapse" for="c-38271140">[-]</label><label class="expand" for="c-38271140">[1 more]</label></div><br/><div class="children"><div class="content">No video here, but discussion: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;</a><p>Welp, video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MCfD7aIl-_E">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MCfD7aIl-_E</a></div><br/></div></div></div></div></div></div><div id="38270515" class="c"><input type="checkbox" id="c-38270515" checked=""/><div class="controls bullet"><span class="by">tabtab</span><span>|</span><a href="#38271029">prev</a><span>|</span><a href="#38269223">next</a><span>|</span><label class="collapse" for="c-38270515">[-]</label><label class="expand" for="c-38270515">[2 more]</label></div><br/><div class="children"><div class="content">The only &quot;good&quot; programming language is the language I make! Everybody thinks different and wants to optimize for different things. There is no existing language I&#x27;ve found that I &quot;love&quot;; they each have features I like but none have all the features together.<p>I&#x27;ve drafted up a language called &quot;Moth&quot; that has a lot of &quot;meta power&quot; to program block scope any way you want, as most languages hard-wire scoping rules, which I  find limiting. Things like &quot;classes&quot;, &quot;functions&quot;, while-loops etc. would be defined by libraries, NOT the language. It&#x27;s like lambda&#x27;s on steroids and without bloated arrow syntax. But it may run slow as molasses, as scoping meta power adds lots of compiler&#x2F;interpreter indirection.<p>However, it may turn out that only a few scoping rules are practical in most cases, and the compiler could then optimize for those. It would then only be slow if you are doing something &quot;weird&quot; with scope. Stick to a fixed known set, and things zip along. But finding that set requires R&amp;D and road testing.</div><br/><div id="38272617" class="c"><input type="checkbox" id="c-38272617" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38270515">parent</a><span>|</span><a href="#38269223">next</a><span>|</span><label class="collapse" for="c-38272617">[-]</label><label class="expand" for="c-38272617">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only &quot;good&quot; programming language is the language I make! Everybody thinks different<p>Yeah. There&#x27;s always one little thing or another that bothers me in every language I&#x27;ve learned. Guess I&#x27;ve just come full circle now that I&#x27;ve finally made my own. No doubt it will bother someone else too. If anyone ever uses it.</div><br/></div></div></div></div><div id="38269223" class="c"><input type="checkbox" id="c-38269223" checked=""/><div class="controls bullet"><span class="by">lylejantzi3rd</span><span>|</span><a href="#38270515">prev</a><span>|</span><a href="#38271916">next</a><span>|</span><label class="collapse" for="c-38269223">[-]</label><label class="expand" for="c-38269223">[7 more]</label></div><br/><div class="children"><div class="content"><i>&quot;either make your language statically typed or dynamically typed (preferably statically typed, but that&#x27;s a different topic), as gradual typing just doesn&#x27;t make sense for new languages.&quot;</i><p>Is that because of type inference?</div><br/><div id="38270627" class="c"><input type="checkbox" id="c-38270627" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38269223">parent</a><span>|</span><a href="#38270054">next</a><span>|</span><label class="collapse" for="c-38270627">[-]</label><label class="expand" for="c-38270627">[5 more]</label></div><br/><div class="children"><div class="content">Your question doesn&#x27;t make a lot of sense. The entirety of gradual typing works by type inference, as does the static typing on any new language.</div><br/><div id="38271020" class="c"><input type="checkbox" id="c-38271020" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38269223">root</a><span>|</span><a href="#38270627">parent</a><span>|</span><a href="#38270054">next</a><span>|</span><label class="collapse" for="c-38271020">[-]</label><label class="expand" for="c-38271020">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The entirety of gradual typing works by type inference<p>Is not a correct statement. You can use gradual typing with explicit type annotations or via inference, it makes no difference to the concept of gradual typing. Gradual typing itself is a way of handling the case of a language being <i>both</i> statically and dynamically typed and handling the interaction between the two portions.</div><br/><div id="38271156" class="c"><input type="checkbox" id="c-38271156" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38269223">root</a><span>|</span><a href="#38271020">parent</a><span>|</span><a href="#38270054">next</a><span>|</span><label class="collapse" for="c-38271156">[-]</label><label class="expand" for="c-38271156">[3 more]</label></div><br/><div class="children"><div class="content">Well, technically you can have gradual typing without inference. But you&#x27;ll need to annotate every single value to get any matching out of it. If you do any language like that, the types will be only useful for documentation purposes.</div><br/><div id="38271362" class="c"><input type="checkbox" id="c-38271362" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38269223">root</a><span>|</span><a href="#38271156">parent</a><span>|</span><a href="#38271833">next</a><span>|</span><label class="collapse" for="c-38271362">[-]</label><label class="expand" for="c-38271362">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But you&#x27;ll need to annotate every single value to get any matching out of it.<p>Ok, if we&#x27;re taking &quot;1 is an int&quot; as type inferencing then, yes, every statically typed language, at least every mainstream one, has at least a small amount of type inference since we don&#x27;t, in C for instance, have to annotate values. But C does not infer the types of its variables or functions, nor do you have to annotate them in every location where they are used. But that&#x27;s not <i>inference</i> either, that&#x27;s using the information determined by annotating the <i>variables</i>.<p>----------<p>My main point was that it&#x27;s weird to say the <i>entirety</i> of gradual typing works by type inference. It works by permitting mixing statically typed and dynamically typed code together in one language. Whether the statically typed portion uses type inference or more &quot;classical&quot; type annotations is orthogonal to the way it works under the hood.</div><br/></div></div><div id="38271833" class="c"><input type="checkbox" id="c-38271833" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38269223">root</a><span>|</span><a href="#38271156">parent</a><span>|</span><a href="#38271362">prev</a><span>|</span><a href="#38270054">next</a><span>|</span><label class="collapse" for="c-38271833">[-]</label><label class="expand" for="c-38271833">[1 more]</label></div><br/><div class="children"><div class="content">You can have an explicit &quot;any&quot; or &quot;dynamic&quot; type that can be used in place of a static type where you want dynamism. C# actually has this.</div><br/></div></div></div></div></div></div></div></div><div id="38270054" class="c"><input type="checkbox" id="c-38270054" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#38269223">parent</a><span>|</span><a href="#38270627">prev</a><span>|</span><a href="#38271916">next</a><span>|</span><label class="collapse" for="c-38270054">[-]</label><label class="expand" for="c-38270054">[1 more]</label></div><br/><div class="children"><div class="content">What part of the statement &quot;is&quot; because of type inference?</div><br/></div></div></div></div><div id="38271916" class="c"><input type="checkbox" id="c-38271916" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#38269223">prev</a><span>|</span><a href="#38270588">next</a><span>|</span><label class="collapse" for="c-38271916">[-]</label><label class="expand" for="c-38271916">[5 more]</label></div><br/><div class="children"><div class="content">Most fringe languages are vanity projects that address a limited number of use-cases.<p>There are always language specific features that may reduce a given problems implementation complexity, but it often depends how much time people are willing to commit to &quot;reinventing the wheel&quot;.  If you find yourself struggling with support scaffolding issues instead of the core challenge, than chances are you are using the wrong tool.<p><a href="https:&#x2F;&#x2F;m.xkcd.com&#x2F;927&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;m.xkcd.com&#x2F;927&#x2F;</a><p>I am not suggesting Erlang&#x2F;Elixir, Lisp and Julia are perfect... but at least one is not trying to build a castle out of grains of sand,  The only groups I  see freeing themselves of C&#x2F;C++ library inertia is the Go and Julia communities to a lesser extent.<p>Have a wonderful day, =)</div><br/><div id="38272703" class="c"><input type="checkbox" id="c-38272703" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38271916">parent</a><span>|</span><a href="#38270588">next</a><span>|</span><label class="collapse" for="c-38272703">[-]</label><label class="expand" for="c-38272703">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a vanity project until it isn&#x27;t. I don&#x27;t know what makes a language succeed but it&#x27;s clearly possible. I&#x27;ve seen quite a few languages rise from small to widely used. Zig is a prominent example but there are others.</div><br/><div id="38273785" class="c"><input type="checkbox" id="c-38273785" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38271916">root</a><span>|</span><a href="#38272703">parent</a><span>|</span><a href="#38273233">next</a><span>|</span><label class="collapse" for="c-38273785">[-]</label><label class="expand" for="c-38273785">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn’t call Zig widely used just yet. It is definitely not in the same camp as hobby languages, but it is still incredibly small.<p>Nonetheless, it is a very welcome addition to the low-level landscape with some cool ideas.</div><br/><div id="38273960" class="c"><input type="checkbox" id="c-38273960" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38271916">root</a><span>|</span><a href="#38273785">parent</a><span>|</span><a href="#38273233">next</a><span>|</span><label class="collapse" for="c-38273960">[-]</label><label class="expand" for="c-38273960">[1 more]</label></div><br/><div class="children"><div class="content">I can only hope my own language will become &quot;incredibly small&quot; like that one day. :)<p>Even if a language doesn&#x27;t take off, its ideas can make a difference and influence future designs. The creator of Zig certainly made an impression on me with this talk:<p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?t=120&amp;v=Gv2I7qTux7g">https:&#x2F;&#x2F;youtube.com&#x2F;watch?t=120&amp;v=Gv2I7qTux7g</a><p>Even if Zig hadn&#x27;t been successful, the ideas it represents would&#x27;ve enriched the world. Gives me hope I&#x27;ll be able to make something out of my own ideas too one day.</div><br/></div></div></div></div><div id="38273233" class="c"><input type="checkbox" id="c-38273233" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#38271916">root</a><span>|</span><a href="#38272703">parent</a><span>|</span><a href="#38273785">prev</a><span>|</span><a href="#38270588">next</a><span>|</span><label class="collapse" for="c-38273233">[-]</label><label class="expand" for="c-38273233">[1 more]</label></div><br/><div class="children"><div class="content">I often ponder if it is a function of the breadth of language use-cases within a problem domain, and or developer effort minimization.<p>C&#x2F;C++ tend to be CPU bound languages that are tightly coupled to the Von Neumann architectures. Anything that is not directly isomorphic tends to not survive very long unless its for a VM, and supports wrapper libraries.<p>Best of luck, =)</div><br/></div></div></div></div></div></div><div id="38270218" class="c"><input type="checkbox" id="c-38270218" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38270588">prev</a><span>|</span><label class="collapse" for="c-38270218">[-]</label><label class="expand" for="c-38270218">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>&quot;In reality, gradual typing ends up giving you the worst of both dynamic and static typing: you get the uncertainty and lack of safety (in dynamically typed contexts) of dynamic typing, and the cost of trying to fit your ideas into a statically typed type system. I also found that the use of gradual typing didn&#x27;t actually make me more productive compared to using static typing.</i><p>Well, that&#x27;s like, your opinion, man...</div><br/></div></div></div></div></div></div></div></body></html>