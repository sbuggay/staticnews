<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697014864179" as="style"/><link rel="stylesheet" href="styles.css?v=1697014864179"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://voidstar.tech/code_duplication/">Going faster by duplicating code</a> <span class="domain">(<a href="https://voidstar.tech">voidstar.tech</a>)</span></div><div class="subtext"><span>voidstarcpp</span> | <span>23 comments</span></div><br/><div><div id="37841441" class="c"><input type="checkbox" id="c-37841441" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37839958">next</a><span>|</span><label class="collapse" for="c-37841441">[-]</label><label class="expand" for="c-37841441">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compilers try to hoist constant conditions outside of loops but they&#x27;re bad at it. Even in the trivial example above, on -O2 gcc does a redundant check with every loop iteration.<p>GCC is actually good at that, -O3 has no issue recognizing it. In fact there even is a very explicit option (-funswitch-loops) responsible for extracting loop invariants. It is not enabled on -O2 because it has a space-speed tradeoff. If this optimization is truly desirable even on -O2, `#pragma GCC optimize(&quot;-funswitch-loops&quot;)` can be used to force it.</div><br/></div></div><div id="37839958" class="c"><input type="checkbox" id="c-37839958" checked=""/><div class="controls bullet"><span class="by">drmikeando</span><span>|</span><a href="#37841441">prev</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37839958">[-]</label><label class="expand" for="c-37839958">[8 more]</label></div><br/><div class="children"><div class="content">IMO the reason the compiler doesn&#x27;t add special cases for the simplest version is that it doesn&#x27;t know which of its _many_ special cases to use. If you actually use the unoptimised version of the code like<p><pre><code>    void withSwitch(vector&lt;int&gt;&amp; Values, bool v) {
      if (v) {
        multiply1(Values, 2.0);
      } else {
        multiply1(Values, 3.0);
      }
    }
</code></pre>
Then it actually inlines the code and optimises each one correctly, as it has context about which special cases are available. (Doesn&#x27;t even need the `inline` keyword for this at `-O2`)<p>You can see the code here: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5beeYe77a" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5beeYe77a</a></div><br/><div id="37840057" class="c"><input type="checkbox" id="c-37840057" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840823">next</a><span>|</span><label class="collapse" for="c-37840057">[-]</label><label class="expand" for="c-37840057">[4 more]</label></div><br/><div class="children"><div class="content">This is possible if the call site can see the implementation, but you can&#x27;t count on it for separate translation units or larger functions.<p>My goal was to not rely on site-specific optimization and instead have one separately compiled function body that can be improved for common cases. Certainly, once the compiler has a full view of everything it can take advantage of information as it pleases but this is less controllable. If I were really picky about optimizing for each use I would make it a template.<p>&gt;Doesn&#x27;t even need the `inline` keyword for this at `-O2`<p>The inline keyword means little in terms of actually causing inlining to happen. I would expect the majority of inlining compilers do happens automatically on functions that lack the &quot;inline&quot; keyword. Conversely, programmers probably add &quot;inline&quot; as an incantation all over the place not knowing that compilers often ignore it.</div><br/><div id="37840571" class="c"><input type="checkbox" id="c-37840571" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840057">parent</a><span>|</span><a href="#37840290">next</a><span>|</span><label class="collapse" for="c-37840571">[-]</label><label class="expand" for="c-37840571">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Conversely, programmers probably add &quot;inline&quot; as an incantation all over the place not knowing that compilers often ignore it.<p>Funnily, the inline keyword actually has a use, but that use isn&#x27;t to tell the compiler to inline a function. The use is to allow a function (or variable) to be defined in multiple translations units without being an ODR violation.</div><br/><div id="37842056" class="c"><input type="checkbox" id="c-37842056" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840571">parent</a><span>|</span><a href="#37840290">next</a><span>|</span><label class="collapse" for="c-37842056">[-]</label><label class="expand" for="c-37842056">[1 more]</label></div><br/><div class="children"><div class="content">Msvc treats inline as a hint [0] , GCC is ambiguous [1] but I read it as utilising the hint. My under of clang [2] is that it tries to match GCC.<p>[0] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;ob-inline-function-expansion?view=msvc-170" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;ob-inl...</a><p>[1] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Inline.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Inline.html</a><p>[2] <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;compatibility.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;clang.llvm.org&#x2F;compatibility.html</a></div><br/></div></div></div></div><div id="37840290" class="c"><input type="checkbox" id="c-37840290" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840057">parent</a><span>|</span><a href="#37840571">prev</a><span>|</span><a href="#37840823">next</a><span>|</span><label class="collapse" for="c-37840290">[-]</label><label class="expand" for="c-37840290">[1 more]</label></div><br/><div class="children"><div class="content">would it have made a difference if the function was static? The compiler would then be able to deduce that it isn&#x27;t used anywhere else, and thus could do this inline optimization.</div><br/></div></div></div></div><div id="37840823" class="c"><input type="checkbox" id="c-37840823" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840057">prev</a><span>|</span><a href="#37841008">next</a><span>|</span><label class="collapse" for="c-37840823">[-]</label><label class="expand" for="c-37840823">[1 more]</label></div><br/><div class="children"><div class="content">You can also force it by using extensions like `[[gnu::always_inline]]` or `__forceinline`. I&#x27;ve actually used this technique to generate an auto-vectorizable function whenever it&#x27;s possible, without any code duplication [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lifthrasiir&#x2F;j40&#x2F;blob&#x2F;252e7987d36d50f617f29e94eeeb741198adc617&#x2F;j40.h#L5764-L5856">https:&#x2F;&#x2F;github.com&#x2F;lifthrasiir&#x2F;j40&#x2F;blob&#x2F;252e7987d36d50f617f2...</a></div><br/></div></div><div id="37841008" class="c"><input type="checkbox" id="c-37841008" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840823">prev</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37841008">[-]</label><label class="expand" for="c-37841008">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the reason the compiler doesn&#x27;t add special cases for the simplest version is that it doesn&#x27;t know which of its _many_ special cases to use<p>This is a fact claim.  I&#x27;m having trouble parsing the &quot;IMO&quot; that&#x27;s a preface to your comment.</div><br/><div id="37841459" class="c"><input type="checkbox" id="c-37841459" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37841008">parent</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37841459">[-]</label><label class="expand" for="c-37841459">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;IMO&quot; here is used instead of &quot;I think&quot; or &quot;I believe&quot; to indicate that this is not a fact claim but a (presumably educated) guess. Not a very correct use of &quot;IMO&quot;, technically, but a fairly common one nonetheless.</div><br/></div></div></div></div></div></div><div id="37840054" class="c"><input type="checkbox" id="c-37840054" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#37839958">prev</a><span>|</span><a href="#37839327">next</a><span>|</span><label class="collapse" for="c-37840054">[-]</label><label class="expand" for="c-37840054">[2 more]</label></div><br/><div class="children"><div class="content">OP — If this comp_nearest is still a hot path for you or if you want to generate more articles, consider testing:<p>1. using `restrict` to tell that compiler that src and dest are sure not to overlap<p>2. Converting your two increment and test blocks to add+mod to allow for uninterrupted pipelining<p>Neither might make a difference, but either could.</div><br/><div id="37840112" class="c"><input type="checkbox" id="c-37840112" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37840054">parent</a><span>|</span><a href="#37839327">next</a><span>|</span><label class="collapse" for="c-37840112">[-]</label><label class="expand" for="c-37840112">[1 more]</label></div><br/><div class="children"><div class="content">Addressing the aliasing concern would be the easiest improvement. I observed in the assembly that the source pixel is being re-read all four times it is used, which could be fixed.<p>Writing an optimal composite function is of course not really the goal, nor of much educational&#x2F;entertainment value. For any additional speed I already have a function which slices up compositing tasks into chunks and puts them on a thread pool.</div><br/></div></div></div></div><div id="37839327" class="c"><input type="checkbox" id="c-37839327" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37840054">prev</a><span>|</span><a href="#37840419">next</a><span>|</span><label class="collapse" for="c-37839327">[-]</label><label class="expand" for="c-37839327">[7 more]</label></div><br/><div class="children"><div class="content">TL;DR: If you copy paste the same implementation code in different branches, you give the compiler opportunities to generate faster code for each case it wouldn&#x27;t have otherwise generated, without you having to do any manual optimization work.</div><br/><div id="37841705" class="c"><input type="checkbox" id="c-37841705" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37839756">next</a><span>|</span><label class="collapse" for="c-37841705">[-]</label><label class="expand" for="c-37841705">[1 more]</label></div><br/><div class="children"><div class="content">This is really an excellent programming technique article.<p>I think what makes it so great is that your examples hit a sweet spot of simplicity while still being motivating and you show how to get a &quot;good enough&quot; solution very quickly.</div><br/></div></div><div id="37839756" class="c"><input type="checkbox" id="c-37839756" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37841705">prev</a><span>|</span><a href="#37839689">next</a><span>|</span><label class="collapse" for="c-37839756">[-]</label><label class="expand" for="c-37839756">[4 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s the case, then I imagine the inline keyword would have the same effect?</div><br/><div id="37839994" class="c"><input type="checkbox" id="c-37839994" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839976">next</a><span>|</span><label class="collapse" for="c-37839994">[-]</label><label class="expand" for="c-37839994">[1 more]</label></div><br/><div class="children"><div class="content">You need to use a compiler specific &quot;always inline&quot; directive if you want macro-like functionality of actually inlining code.<p>On its own, the C++ &quot;inline&quot; keyword does not cause inlining to happen, although compilers may treat it like a hint depending on optimization level. GCC does not inline an &quot;inline&quot; function on O0.<p>&quot;Inline&quot; in the C++ standard means &quot;multiple definitions permitted&quot; so the same entity can exist in multiple translation units without upsetting the linker. This is why C++17 added &quot;inline&quot; variables, which can be initialized in a header that&#x27;s included in multiple places, even though the inlining concept has no applicability to a variable. The keyword was adopted for this purpose because of the primary association with affecting linkage behavior.</div><br/></div></div><div id="37839976" class="c"><input type="checkbox" id="c-37839976" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839994">prev</a><span>|</span><a href="#37839773">next</a><span>|</span><label class="collapse" for="c-37839976">[-]</label><label class="expand" for="c-37839976">[1 more]</label></div><br/><div class="children"><div class="content">This isn’t an optimization you should consider without insight into your <i>actual</i> bottlenecks, but compilers <i>can be</i> even more aggressive with code that’s strictly local to one translation unit (i.e. inside an anonymous namespace in a cpp file) than they <i>typically</i> would be when seeing an inline hint elsewhere.<p>It’s not <i>quite</i> the same.<p>Plus, another benefit of duplication is that you can more freely hand-tune your implementation once you’ve decided its private. Memory alignment, pointer aliasing hints, clever loop structures, SSE stuff, etc can all be used more freely when you know nothing else needs to use this version.<p>The article is a good teaser around how unintuitive optimization can be, but it only scratches the surface.</div><br/></div></div><div id="37839773" class="c"><input type="checkbox" id="c-37839773" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839976">prev</a><span>|</span><a href="#37839689">next</a><span>|</span><label class="collapse" for="c-37839773">[-]</label><label class="expand" for="c-37839773">[1 more]</label></div><br/><div class="children"><div class="content">yeah, languages which can do inking optimizations do this for you, sometimes even without you knowing.</div><br/></div></div></div></div><div id="37839689" class="c"><input type="checkbox" id="c-37839689" checked=""/><div class="controls bullet"><span class="by">spiritplumber</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37839756">prev</a><span>|</span><a href="#37840419">next</a><span>|</span><label class="collapse" for="c-37839689">[-]</label><label class="expand" for="c-37839689">[1 more]</label></div><br/><div class="children"><div class="content">thank you</div><br/></div></div></div></div><div id="37840419" class="c"><input type="checkbox" id="c-37840419" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#37839327">prev</a><span>|</span><label class="collapse" for="c-37840419">[-]</label><label class="expand" for="c-37840419">[4 more]</label></div><br/><div class="children"><div class="content">Honest question, would `V *= Factor` be faster?</div><br/><div id="37840609" class="c"><input type="checkbox" id="c-37840609" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#37840419">parent</a><span>|</span><label class="collapse" for="c-37840609">[-]</label><label class="expand" for="c-37840609">[3 more]</label></div><br/><div class="children"><div class="content">In almost all cases: no.<p>&quot;A compound assignment of the form E1 op= E2 differs from the simple assignment expression E1 = E1 op (E2) only in that the lvalue E1 is evaluated only once.&quot; (C99, 6.5.16.2p3)<p>It only matters when evaluating E1 has side effects. For example, `a[i++] += 1;` which is equivalent to `a[i] = a[i] + 1; i++;` rather than `a[i++] = a[i++] + 1;`.</div><br/><div id="37841534" class="c"><input type="checkbox" id="c-37841534" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#37840419">root</a><span>|</span><a href="#37840609">parent</a><span>|</span><label class="collapse" for="c-37841534">[-]</label><label class="expand" for="c-37841534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; `a[i++] = a[i++] + 1;`<p>This is probably not what you want, as &quot;i&quot; is increased twice.</div><br/><div id="37841650" class="c"><input type="checkbox" id="c-37841650" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#37840419">root</a><span>|</span><a href="#37841534">parent</a><span>|</span><label class="collapse" for="c-37841650">[-]</label><label class="expand" for="c-37841650">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why it matters in that situation, because it changes what actually happens (not just the performance).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>