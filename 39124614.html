<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706173267814" as="style"/><link rel="stylesheet" href="styles.css?v=1706173267814"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/billziss-gh/imap">Show HN: Integer Map Data Structure</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>billziss</span> | <span>19 comments</span></div><br/><div><div id="39126691" class="c"><input type="checkbox" id="c-39126691" checked=""/><div class="controls bullet"><span class="by">jemfinch</span><span>|</span><a href="#39127408">next</a><span>|</span><label class="collapse" for="c-39126691">[-]</label><label class="expand" for="c-39126691">[4 more]</label></div><br/><div class="children"><div class="content">This really doesn&#x27;t seem to be comparing to comparable data structures.  For int map specializations like this, the optimized alternatives are things like Judy (which is looking quite aged these days) or roaring bitmaps, not to mention that any C++ developer using &quot;ordinary&quot; maps will be using absl&#x27;s SwissTable (flat_hash_map) or folly&#x27;s F14 (F14FastMap) or perhaps absl::btree_map if order is important.  Comparisons to std::map and std::unordered_map are simply too naive to make the case for this data structure.</div><br/><div id="39127289" class="c"><input type="checkbox" id="c-39127289" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#39126691">parent</a><span>|</span><a href="#39127408">next</a><span>|</span><label class="collapse" for="c-39127289">[-]</label><label class="expand" for="c-39127289">[3 more]</label></div><br/><div class="children"><div class="content">Oh come on.  Don&#x27;t be too harsh.  This is an ordered map.  Most of the mentioned ones are unordered maps.  They might be fast but they are unordered.  The only comparables are absl::btree_map and Judy Array.  Without benchmarking, my gut feeling is this will beat absl::btree_map.  Trie usually beats BTree.</div><br/><div id="39127435" class="c"><input type="checkbox" id="c-39127435" checked=""/><div class="controls bullet"><span class="by">jemfinch</span><span>|</span><a href="#39126691">root</a><span>|</span><a href="#39127289">parent</a><span>|</span><a href="#39127408">next</a><span>|</span><label class="collapse" for="c-39127435">[-]</label><label class="expand" for="c-39127435">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written a lot of high performance&#x2F;scale C++ code using a lot of data structures over the years, and ordered iteration has been very rarely needed; unordered data structures still rule the day in performance the vast majority of the time, and their lower constant factors very frequently outperform more specialized data structures.  They&#x27;re absolutely worth benchmarking against if the goal is actual uptake in the actual world.<p>In my experience, practically every single time I&#x27;ve used absl::btree_map, I&#x27;ve ended up reverting for performance reasons to either a flat hash map or, in some relatively rare cases, a sorted vector map (despite its O(n) insert&#x2F;erase) because the constant factors are _so doggone low_.  The experience remains: btree_map (or SkipLists, or whatever) has (in my experience) essentially <i>never</i>, in over a half million lines of C++, actually remained in the code.<p>Also, I presume (based on the implementation details, not based on actual use) that roaring bitmaps have some reasonable iteration API that would make them relevant even to the ordered comparison.<p>The important thing here is that if anyone wants to contend that someone should use their new data structure because it&#x27;s better or faster or more optimal for some particular use case, it&#x27;s important for them to demonstrate that they&#x27;ve <i>thoroughly investigated</i> the data structure space around their proposal.  Comparison against std::map and std::unordered_map simply doesn&#x27;t demonstrate the kind of comprehensive knowledge that I would expect from someone who claims that I should use their optimized integer map in my own code.</div><br/><div id="39127555" class="c"><input type="checkbox" id="c-39127555" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#39126691">root</a><span>|</span><a href="#39127435">parent</a><span>|</span><a href="#39127408">next</a><span>|</span><label class="collapse" for="c-39127555">[-]</label><label class="expand" for="c-39127555">[1 more]</label></div><br/><div class="children"><div class="content">That just means you never have the need for implementing a querying or search functionality.  Range query and search are used everywhere and need ordered maps.</div><br/></div></div></div></div></div></div></div></div><div id="39127408" class="c"><input type="checkbox" id="c-39127408" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#39126691">prev</a><span>|</span><a href="#39124816">next</a><span>|</span><label class="collapse" for="c-39127408">[-]</label><label class="expand" for="c-39127408">[2 more]</label></div><br/><div class="children"><div class="content">This looks very good.  The idea of using a subnet-mask style to compute the prefix of a node is pretty novel.  I haven&#x27;t seen anything like it.  The choice of span factor of 16 is a good compromise between node size and tree depth.  The node slot packing is amazing.  Actually if you relax the restriction on 64-byte node to 128-byte node, you can get 64 bits per slot and will get a much higher limit for the item count.  Newer CPU&#x27;s are starting to support 128-byte cache line.</div><br/><div id="39127529" class="c"><input type="checkbox" id="c-39127529" checked=""/><div class="controls bullet"><span class="by">mrazomor</span><span>|</span><a href="#39127408">parent</a><span>|</span><a href="#39124816">next</a><span>|</span><label class="collapse" for="c-39127529">[-]</label><label class="expand" for="c-39127529">[1 more]</label></div><br/><div class="children"><div class="content">If I understood it correctly, it&#x27;s not much different from what `absl::flat_hash_map` does.<p>Look for &quot;Metadata information&quot;&#x2F;control bits at <a href="https:&#x2F;&#x2F;abseil.io&#x2F;about&#x2F;design&#x2F;swisstables" rel="nofollow">https:&#x2F;&#x2F;abseil.io&#x2F;about&#x2F;design&#x2F;swisstables</a></div><br/></div></div></div></div><div id="39124816" class="c"><input type="checkbox" id="c-39124816" checked=""/><div class="controls bullet"><span class="by">bts</span><span>|</span><a href="#39127408">prev</a><span>|</span><a href="#39127233">next</a><span>|</span><label class="collapse" for="c-39124816">[-]</label><label class="expand" for="c-39124816">[3 more]</label></div><br/><div class="children"><div class="content">FWIW there is prior art here. e.g. see IntMap in Haskell: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;containers-0.7&#x2F;docs&#x2F;Data-IntMap-Strict.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;containers-0.7&#x2F;docs&#x2F;Data...</a></div><br/><div id="39127312" class="c"><input type="checkbox" id="c-39127312" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#39124816">parent</a><span>|</span><a href="#39126161">next</a><span>|</span><label class="collapse" for="c-39127312">[-]</label><label class="expand" for="c-39127312">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s similar but not quite.  IntMap in Haskell uses bit as the prefix unit with a span factor of 2.  This uses nibble as the prefix unit with a span factor of 16.  Also IntMap uses a bitmask for the range of prefix units in a node while this uses a subnet-mask style to get the prefix of a node.</div><br/></div></div><div id="39126161" class="c"><input type="checkbox" id="c-39126161" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39124816">parent</a><span>|</span><a href="#39127312">prev</a><span>|</span><a href="#39127233">next</a><span>|</span><label class="collapse" for="c-39126161">[-]</label><label class="expand" for="c-39126161">[1 more]</label></div><br/><div class="children"><div class="content">It hardly seems comparable given that this Haskell data structure must necessarily be persistent.</div><br/></div></div></div></div><div id="39127233" class="c"><input type="checkbox" id="c-39127233" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#39124816">prev</a><span>|</span><a href="#39125533">next</a><span>|</span><label class="collapse" for="c-39127233">[-]</label><label class="expand" for="c-39127233">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! Reminds me a great deal of Judy Arrays: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Judy_array" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Judy_array</a><p>Judy Arrays are a radix trie with branching and a few node types designed to be cache line width optimized.</div><br/></div></div><div id="39125533" class="c"><input type="checkbox" id="c-39125533" checked=""/><div class="controls bullet"><span class="by">NWoodsman</span><span>|</span><a href="#39127233">prev</a><span>|</span><a href="#39127113">next</a><span>|</span><label class="collapse" for="c-39125533">[-]</label><label class="expand" for="c-39125533">[1 more]</label></div><br/><div class="children"><div class="content">Also will throw in to the mix, in C#:<p><a href="https:&#x2F;&#x2F;julesjacobs.com&#x2F;2014&#x2F;11&#x2F;11&#x2F;immutable-vectors-csharp.html" rel="nofollow">https:&#x2F;&#x2F;julesjacobs.com&#x2F;2014&#x2F;11&#x2F;11&#x2F;immutable-vectors-csharp....</a><p>His implementation uses buffers of capacity 32, generics, and bit shifting to do lookups.</div><br/></div></div><div id="39127113" class="c"><input type="checkbox" id="c-39127113" checked=""/><div class="controls bullet"><span class="by">ursusmaritimus</span><span>|</span><a href="#39125533">prev</a><span>|</span><a href="#39125513">next</a><span>|</span><label class="collapse" for="c-39127113">[-]</label><label class="expand" for="c-39127113">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, but the summary does not mention an important fact: the data structure can contain at most 67108864 items, which is a quite low limit.</div><br/><div id="39127180" class="c"><input type="checkbox" id="c-39127180" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#39127113">parent</a><span>|</span><a href="#39125513">next</a><span>|</span><label class="collapse" for="c-39127180">[-]</label><label class="expand" for="c-39127180">[1 more]</label></div><br/><div class="children"><div class="content">It is mentioned prominently enough in the readme, I would say. 2²⁶ is plenty enough for many applications. I currently use a persistent intmap to label continuations in a toy CPS compiler, and with my current approach there is no chance whatsoever that any conceivable program would compile to use that many continuation labels.</div><br/></div></div></div></div><div id="39125513" class="c"><input type="checkbox" id="c-39125513" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39127113">prev</a><span>|</span><a href="#39126644">next</a><span>|</span><label class="collapse" for="c-39125513">[-]</label><label class="expand" for="c-39125513">[3 more]</label></div><br/><div class="children"><div class="content">Neat, thank you! I&#x27;d love to see how it compares to the libgdx IntMap[0].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;libgdx&#x2F;libgdx&#x2F;blob&#x2F;master&#x2F;gdx&#x2F;src&#x2F;com&#x2F;badlogic&#x2F;gdx&#x2F;utils&#x2F;IntMap.java">https:&#x2F;&#x2F;github.com&#x2F;libgdx&#x2F;libgdx&#x2F;blob&#x2F;master&#x2F;gdx&#x2F;src&#x2F;com&#x2F;bad...</a></div><br/><div id="39125543" class="c"><input type="checkbox" id="c-39125543" checked=""/><div class="controls bullet"><span class="by">repsilat</span><span>|</span><a href="#39125513">parent</a><span>|</span><a href="#39126644">next</a><span>|</span><label class="collapse" for="c-39125543">[-]</label><label class="expand" for="c-39125543">[2 more]</label></div><br/><div class="children"><div class="content">This is a radix tree (ordered, does more allocations), that is a hash table. Also TFA is C&#x2F;C++, libgdx looks like Java.</div><br/><div id="39126153" class="c"><input type="checkbox" id="c-39126153" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39125513">root</a><span>|</span><a href="#39125543">parent</a><span>|</span><a href="#39126644">next</a><span>|</span><label class="collapse" for="c-39126153">[-]</label><label class="expand" for="c-39126153">[1 more]</label></div><br/><div class="children"><div class="content">yeah, just thought it&#x27;d be fun to compare :) ordered is a big difference.</div><br/></div></div></div></div></div></div><div id="39126644" class="c"><input type="checkbox" id="c-39126644" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39125513">prev</a><span>|</span><a href="#39125575">next</a><span>|</span><label class="collapse" for="c-39126644">[-]</label><label class="expand" for="c-39126644">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be nice to include djb&#x27;s crit-bit tree implementation (linked to from the intro) in the benchmarks (&quot;Performance Test&quot; section).</div><br/></div></div><div id="39125575" class="c"><input type="checkbox" id="c-39125575" checked=""/><div class="controls bullet"><span class="by">repsilat</span><span>|</span><a href="#39126644">prev</a><span>|</span><label class="collapse" for="c-39125575">[-]</label><label class="expand" for="c-39125575">[1 more]</label></div><br/><div class="children"><div class="content">Looks rad, I was going to look into some b-trees for a use-case where I need an ordered map of things similar to integers and this might be better.<p>I couldn&#x27;t immediately see, is there mention of whether insertions invalidate iterators? Maybe not strictly needed for my use-case but good to know.</div><br/></div></div></div></div></div></div></div></body></html>