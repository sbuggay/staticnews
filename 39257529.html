<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707123658250" as="style"/><link rel="stylesheet" href="styles.css?v=1707123658250"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://observablehq.com/@chaosalchemist/wasm-playground">WebAssembly Playground</a> <span class="domain">(<a href="https://observablehq.com">observablehq.com</a>)</span></div><div class="subtext"><span>ifree</span> | <span>31 comments</span></div><br/><div><div id="39258030" class="c"><input type="checkbox" id="c-39258030" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#39258595">next</a><span>|</span><label class="collapse" for="c-39258030">[-]</label><label class="expand" for="c-39258030">[28 more]</label></div><br/><div class="children"><div class="content">Question from someone knew very little in this domain: what stops mass adoption of WebAssembly?<p>A few years ago, I used a WASM demo website which can use a WASM version of ffmpeg to mux audio and video into a file (transcoding obviously wasn&#x27;t practical, at least not at that time), and I was very impressed. I can see lots of potential of it.<p>But I still haven&#x27;t see much usage of it even today.<p>(To be totally honest -- i&#x27;d rather it&#x27;s <i>not</i> popular because it would make debugging websites&#x2F;web applications close to impossible; but that&#x27;s besides the point.)</div><br/><div id="39258147" class="c"><input type="checkbox" id="c-39258147" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258514">next</a><span>|</span><label class="collapse" for="c-39258147">[-]</label><label class="expand" for="c-39258147">[1 more]</label></div><br/><div class="children"><div class="content"><i>shrug</i> It finds its uses. It&#x27;s just not that overstated.<p>sandspiel is quite popular and is built using WASM: <a href="https:&#x2F;&#x2F;sandspiel.club&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sandspiel.club&#x2F;</a><p>Google Earth - <a href="https:&#x2F;&#x2F;blog.chromium.org&#x2F;2019&#x2F;06&#x2F;webassembly-brings-google-earth-to-more.html" rel="nofollow">https:&#x2F;&#x2F;blog.chromium.org&#x2F;2019&#x2F;06&#x2F;webassembly-brings-google-...</a><p>Ruffle (the &quot;make Flash run safely&quot; tool) - <a href="https:&#x2F;&#x2F;ruffle.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ruffle.rs&#x2F;</a><p>Ableton&#x27;s Learning Synths - <a href="https:&#x2F;&#x2F;learningsynths.ableton.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learningsynths.ableton.com&#x2F;</a><p>etc etc. It&#x27;s just hard to tell when something is using WASM when it &quot;just works&quot; and is indistinguishable from optimized JavaScript<p>(<i>cough</i> also my WIP game is being built in WASM.Rust, <a href="https:&#x2F;&#x2F;ant.care&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ant.care&#x2F;</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants</a> I&#x27;ve been enjoying the experience!)</div><br/></div></div><div id="39258514" class="c"><input type="checkbox" id="c-39258514" checked=""/><div class="controls bullet"><span class="by">lewisjoe</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258147">prev</a><span>|</span><a href="#39258334">next</a><span>|</span><label class="collapse" for="c-39258514">[-]</label><label class="expand" for="c-39258514">[1 more]</label></div><br/><div class="children"><div class="content">By mass adoption, do you mean why not all existing softwares are ported to webassembly so that they can be run on browsers?<p>Most websites are just that - &quot;sites&quot;. 
Complicated softwares that _need_ to be run on the web are already leveraging WebAssembly to an extent.<p>1. Figma (Design tool) uses Webassembly underneath for graphics operations.<p>2. Zoho Writer (word processor) uses WebAssembly for leveraging ICU capabilities (grapheme splitting, sentence splitting, core algorithms, etc)<p>3. Google Docs (word processor) uses WASM for offline proofing<p>These are just examples. If you look at the pattern the transition isn&#x27;t happening  in a way that all softwares are entirely targetted for webassembly. It&#x27;s happening in little steps leveraging webassembly to parts of the product where it makes sense. This I believe is how the transition should be as opposed to jumping all the way to webassembly just because it&#x27;s shiny.</div><br/></div></div><div id="39258334" class="c"><input type="checkbox" id="c-39258334" checked=""/><div class="controls bullet"><span class="by">emnudge</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258514">prev</a><span>|</span><a href="#39258152">next</a><span>|</span><label class="collapse" for="c-39258334">[-]</label><label class="expand" for="c-39258334">[2 more]</label></div><br/><div class="children"><div class="content">I sunk a decent amount of time into WebAssembly over the past few months (I am the author of &quot;watlings&quot;).<p>From my understanding, there are 3 answers here.<p>1. Most spaces do not need WASM. You don&#x27;t necessarily see speed improvements since usually your JS and WASM (in the browser) are compiled into the same thing.<p>2. WASM is very good at bringing tools to new spaces. The biggest limitation here is in both tooling and education. It is not trivial to compile something like FFMPEG for the browser. Improvements to the WASI standard are helping here.<p>3. WASM is starting to see use in different spaces. For example, as a containerization format for efficient sandboxing.</div><br/><div id="39258723" class="c"><input type="checkbox" id="c-39258723" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258334">parent</a><span>|</span><a href="#39258152">next</a><span>|</span><label class="collapse" for="c-39258723">[-]</label><label class="expand" for="c-39258723">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2. WASM is very good at bringing tools to new spaces.<p>Yeah, I agree with this. I have a few ongoing fresh-start projects that are being built with WASM as the primary build target. And like you said, the tooling is definitely not great. Plus the load times for some wasm binaries are pretty slow.</div><br/></div></div></div></div><div id="39258152" class="c"><input type="checkbox" id="c-39258152" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258334">prev</a><span>|</span><a href="#39258304">next</a><span>|</span><label class="collapse" for="c-39258152">[-]</label><label class="expand" for="c-39258152">[1 more]</label></div><br/><div class="children"><div class="content">I bet it is used in a lot of ways people don&#x27;t notice. In my site[1] I use wasm to run an ancient piece of code called SGP4 to propagate satellite orbits, but it&#x27;s totally invisible to the user. Someone actually ported SGP4 to JavaScript but it&#x27;s slower and the results don&#x27;t perfectly match the original, so it&#x27;s great to have the option to run the real C version (actually the original is Fortran but the C port is the standard these days).<p>[1] <a href="https:&#x2F;&#x2F;james.darpinian.com&#x2F;satellites&#x2F;" rel="nofollow">https:&#x2F;&#x2F;james.darpinian.com&#x2F;satellites&#x2F;</a></div><br/></div></div><div id="39258304" class="c"><input type="checkbox" id="c-39258304" checked=""/><div class="controls bullet"><span class="by">srvaroa</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258152">prev</a><span>|</span><a href="#39258467">next</a><span>|</span><label class="collapse" for="c-39258304">[-]</label><label class="expand" for="c-39258304">[2 more]</label></div><br/><div class="children"><div class="content">There are usages outside of the browser too. We are using wasm as a runtime for applications and modules deployed in small IoT device. Wasm helps overcome the typical limitations of those devices giving platform independence,  sandboxed environments, ability to verify and sign modules ahead of deployment, allows developers to program in dominant languages and compile to wasm, and still retain a low footprint which is critical in this context.<p>There is a more detailed overview here: <a href="https:&#x2F;&#x2F;www.midokura.com&#x2F;why-webassembly-is-perfect-for-tiny-iot-devices&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.midokura.com&#x2F;why-webassembly-is-perfect-for-tiny...</a></div><br/><div id="39258547" class="c"><input type="checkbox" id="c-39258547" checked=""/><div class="controls bullet"><span class="by">anoopelias</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258304">parent</a><span>|</span><a href="#39258467">next</a><span>|</span><label class="collapse" for="c-39258547">[-]</label><label class="expand" for="c-39258547">[1 more]</label></div><br/><div class="children"><div class="content">Sometime back I did some experiments with WASM over ESP32 board[1]. It was fairly easy to get a simple WASM program to work, though there was a fair amount of (ongoing) work left to bring it into usable shape.<p>[1] <a href="https:&#x2F;&#x2F;anoopelias.github.io&#x2F;posts&#x2F;wasm-micro-runtime-with-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;anoopelias.github.io&#x2F;posts&#x2F;wasm-micro-runtime-with-r...</a></div><br/></div></div></div></div><div id="39258467" class="c"><input type="checkbox" id="c-39258467" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258304">prev</a><span>|</span><a href="#39258144">next</a><span>|</span><label class="collapse" for="c-39258467">[-]</label><label class="expand" for="c-39258467">[1 more]</label></div><br/><div class="children"><div class="content">No direct DOM access means it will continue to remain a second class citizen on the web</div><br/></div></div><div id="39258144" class="c"><input type="checkbox" id="c-39258144" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258467">prev</a><span>|</span><a href="#39258537">next</a><span>|</span><label class="collapse" for="c-39258144">[-]</label><label class="expand" for="c-39258144">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a lot of inertia with the JavaScript-based systems and WASM represents a certain  upheaval to that model. I have been toying with Blazor WASM recently though and to be honest, so far my experience has been very good, including debugging. I think WASM will grow quiet adoption over time, particularly for business apps.</div><br/></div></div><div id="39258537" class="c"><input type="checkbox" id="c-39258537" checked=""/><div class="controls bullet"><span class="by">lioeters</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258144">prev</a><span>|</span><a href="#39258115">next</a><span>|</span><label class="collapse" for="c-39258537">[-]</label><label class="expand" for="c-39258537">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the use cases other comments have listed, Firefox uses WASM internally as a sandbox environment.<p>WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox - <a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again...</a><p>Neural Machine Translation Engine for Firefox Translations - <a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2022&#x2F;06&#x2F;neural-machine-translation-engine-for-firefox-translations-add-on&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2022&#x2F;06&#x2F;neural-machine-translation...</a></div><br/></div></div><div id="39258115" class="c"><input type="checkbox" id="c-39258115" checked=""/><div class="controls bullet"><span class="by">iamcreasy</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258537">prev</a><span>|</span><a href="#39258116">next</a><span>|</span><label class="collapse" for="c-39258115">[-]</label><label class="expand" for="c-39258115">[2 more]</label></div><br/><div class="children"><div class="content">To piggyback this question - do developers have to find another way to access&#x2F;update DOM update if using webassembly for web development?</div><br/><div id="39258232" class="c"><input type="checkbox" id="c-39258232" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258115">parent</a><span>|</span><a href="#39258116">next</a><span>|</span><label class="collapse" for="c-39258232">[-]</label><label class="expand" for="c-39258232">[1 more]</label></div><br/><div class="children"><div class="content">At the moment you need to send state between WebAssembly and JS contexts in order to manipulate the DOM.<p>&gt; By itself, WebAssembly cannot currently directly access the DOM; it can only call JavaScript, passing in integer and floating point primitive data types. Thus, to access any Web API, WebAssembly needs to call out to JavaScript, which then makes the Web API call. Emscripten therefore creates the HTML and JavaScript glue code needed to achieve this.<p>&gt; Note: There are future plans to allow WebAssembly to call Web APIs directly.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;WebAssembly&#x2F;Concepts" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;WebAssembly&#x2F;Concept...</a></div><br/></div></div></div></div><div id="39258116" class="c"><input type="checkbox" id="c-39258116" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258115">prev</a><span>|</span><a href="#39258058">next</a><span>|</span><label class="collapse" for="c-39258116">[-]</label><label class="expand" for="c-39258116">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any stats from which you know that adoption is limited? The thing is, you won&#x27;t necessarily know if an app is using it unless you&#x27;re deliberately checking the sources in the dev console, so there could be a lot of sites that you&#x27;re using that have wasm running in your browser without your knowledge.<p>That being said, one thing that&#x27;s potentially holding back developer adoption is that, in its current state, wasm is best suited to low-overhead languages like C, C++ and Rust. And then there&#x27;s the fact that most of the code that runs in the browser is UI code, and it&#x27;d be hard to justify writing your frontend in Ruby or Python, which would mean that the browser download a big wasm blob just to write your code, worse performance than JS once it starts running, and a much less stable ecosystem.</div><br/></div></div><div id="39258058" class="c"><input type="checkbox" id="c-39258058" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258116">prev</a><span>|</span><a href="#39258159">next</a><span>|</span><label class="collapse" for="c-39258058">[-]</label><label class="expand" for="c-39258058">[11 more]</label></div><br/><div class="children"><div class="content">Mass adoption in what way? What benefit does the average CRUD web app gain from using some form of WebAssembly?</div><br/><div id="39258201" class="c"><input type="checkbox" id="c-39258201" checked=""/><div class="controls bullet"><span class="by">anoopelias</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258058">parent</a><span>|</span><a href="#39258094">next</a><span>|</span><label class="collapse" for="c-39258201">[-]</label><label class="expand" for="c-39258201">[3 more]</label></div><br/><div class="children"><div class="content">Not sure if WASM is there yet, but maybe the crud app can be built using a programming language that the developer prefers? Like Java, C#, Go, Rust, C++, whatever instead of JavaScript&#x2F;TypeScript?</div><br/><div id="39258261" class="c"><input type="checkbox" id="c-39258261" checked=""/><div class="controls bullet"><span class="by">billti</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258201">parent</a><span>|</span><a href="#39258094">next</a><span>|</span><label class="collapse" for="c-39258261">[-]</label><label class="expand" for="c-39258261">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, we took a bet that writing our compiler, simulator, etc. in Rust and architecting correctly so it could compile to native and WASM would let us run native and in the browser too, and we’re pretty thrilled with how it turned out.<p>We just shipped 1.0, but this slightly older blog post goes into the architecture a bit more: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;qsharp&#x2F;introducing-the-azure-quantum-development-kit-preview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;qsharp&#x2F;introducing-the-azure-...</a></div><br/><div id="39258351" class="c"><input type="checkbox" id="c-39258351" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258261">parent</a><span>|</span><a href="#39258094">next</a><span>|</span><label class="collapse" for="c-39258351">[-]</label><label class="expand" for="c-39258351">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently taking the same route with my compiler. It&#x27;s written with extreme efficiency in mind, so I&#x27;m planning to expose a client-side WASM binary on the main site, that will let you interactively explore the language with low latency.</div><br/></div></div></div></div></div></div><div id="39258094" class="c"><input type="checkbox" id="c-39258094" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258058">parent</a><span>|</span><a href="#39258201">prev</a><span>|</span><a href="#39258159">next</a><span>|</span><label class="collapse" for="c-39258094">[-]</label><label class="expand" for="c-39258094">[7 more]</label></div><br/><div class="children"><div class="content">To incorporate something currently is only available in &quot;native&quot; program form is what I am thinking; like ffmpeg example above.</div><br/><div id="39258143" class="c"><input type="checkbox" id="c-39258143" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258094">parent</a><span>|</span><a href="#39258506">next</a><span>|</span><label class="collapse" for="c-39258143">[-]</label><label class="expand" for="c-39258143">[1 more]</label></div><br/><div class="children"><div class="content">I think most web pages do not need such features. WebAssembly has seen lots of adoption on the websites that do, like Figma and Photoshop for design, Zoom and Meet for interactive video, Unity for games, etc. etc. But most web pages are just text, and that&#x27;s fine.<p>Wasm was never intended to be used on every web page, just like the Video element wasn&#x27;t.</div><br/></div></div><div id="39258506" class="c"><input type="checkbox" id="c-39258506" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258094">parent</a><span>|</span><a href="#39258143">prev</a><span>|</span><a href="#39258160">next</a><span>|</span><label class="collapse" for="c-39258506">[-]</label><label class="expand" for="c-39258506">[3 more]</label></div><br/><div class="children"><div class="content">Which could have been done with WebAudio and WebGL&#x2F;WebGPU as well, without the pain of dealing with WebAssembly tooling.</div><br/><div id="39258726" class="c"><input type="checkbox" id="c-39258726" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258506">parent</a><span>|</span><a href="#39258160">next</a><span>|</span><label class="collapse" for="c-39258726">[-]</label><label class="expand" for="c-39258726">[2 more]</label></div><br/><div class="children"><div class="content">Surely you mean WebCodecs rather than WebGL&#x2F;WebGPU? AFAIK no encoding primitives are exposed by WebGL&#x2F;WebGPU.<p>The advantage of shipping an encoder in WebAssembly for is that you don’t have to rely on the browser supporting the specific codec you want. e.g. Safari and Firefox don’t yet support WebCodecs at all, but do support WebAssembly.</div><br/><div id="39258865" class="c"><input type="checkbox" id="c-39258865" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258726">parent</a><span>|</span><a href="#39258160">next</a><span>|</span><label class="collapse" for="c-39258865">[-]</label><label class="expand" for="c-39258865">[1 more]</label></div><br/><div class="children"><div class="content">I really mean WebGL&#x2F;WebGPU and using shaders instead of C and C++, while being GPU accelerated.<p>For a small taste,<p>&quot;Meet Leon - superfast GPU-accelerated (WebGL) mpeg1-like video decoder in JavaScript&quot;<p><a href="https:&#x2F;&#x2F;www.easy-bits.com&#x2F;mpeg1video-decoder-webgl-gpu" rel="nofollow">https:&#x2F;&#x2F;www.easy-bits.com&#x2F;mpeg1video-decoder-webgl-gpu</a></div><br/></div></div></div></div></div></div><div id="39258160" class="c"><input type="checkbox" id="c-39258160" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258094">parent</a><span>|</span><a href="#39258506">prev</a><span>|</span><a href="#39258108">next</a><span>|</span><label class="collapse" for="c-39258160">[-]</label><label class="expand" for="c-39258160">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but WASM does not solve a problém which (many) people have. Of course there are some applications, like online image or video editors.</div><br/></div></div><div id="39258108" class="c"><input type="checkbox" id="c-39258108" checked=""/><div class="controls bullet"><span class="by">adrusi</span><span>|</span><a href="#39258030">root</a><span>|</span><a href="#39258094">parent</a><span>|</span><a href="#39258160">prev</a><span>|</span><a href="#39258159">next</a><span>|</span><label class="collapse" for="c-39258108">[-]</label><label class="expand" for="c-39258108">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s maybe negligible compared to the code-size bloat of web applications, but delivering large libraries over the network with only limited caching is less than ideal</div><br/></div></div></div></div></div></div><div id="39258159" class="c"><input type="checkbox" id="c-39258159" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258058">prev</a><span>|</span><a href="#39258242">next</a><span>|</span><label class="collapse" for="c-39258159">[-]</label><label class="expand" for="c-39258159">[1 more]</label></div><br/><div class="children"><div class="content">From what I understand, it’s still pretty clunky to do multithreading with it. So people who want the speed of near native execution often also want extra threads.</div><br/></div></div><div id="39258242" class="c"><input type="checkbox" id="c-39258242" checked=""/><div class="controls bullet"><span class="by">baudaux</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258159">prev</a><span>|</span><a href="#39258125">next</a><span>|</span><label class="collapse" for="c-39258242">[-]</label><label class="expand" for="c-39258242">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of projects around WebAssembly. But technology is hidden from external view. (Some self promotion, I am creating <a href="https:&#x2F;&#x2F;exaequos.com" rel="nofollow">https:&#x2F;&#x2F;exaequos.com</a>, a new Unix like OS running in a web browser)</div><br/></div></div><div id="39258125" class="c"><input type="checkbox" id="c-39258125" checked=""/><div class="controls bullet"><span class="by">aredox</span><span>|</span><a href="#39258030">parent</a><span>|</span><a href="#39258242">prev</a><span>|</span><a href="#39258595">next</a><span>|</span><label class="collapse" for="c-39258125">[-]</label><label class="expand" for="c-39258125">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Mozilla and the Chrome team were pushing a lot for it, and spent a lot of engineering effort on it. So far it seems a strategic failure, both for Mozilla which couldn&#x27;t afford such diversion of ressources, and for the Chrome team after NaCl&#x27;s retirement.</div><br/></div></div></div></div><div id="39258595" class="c"><input type="checkbox" id="c-39258595" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39258030">prev</a><span>|</span><label class="collapse" for="c-39258595">[-]</label><label class="expand" for="c-39258595">[2 more]</label></div><br/><div class="children"><div class="content">&gt; lib&#x2F;wasm32-wasi&#x2F;crt1.o: undefined symbol: main<p>Oops.</div><br/><div id="39258718" class="c"><input type="checkbox" id="c-39258718" checked=""/><div class="controls bullet"><span class="by">ifree</span><span>|</span><a href="#39258595">parent</a><span>|</span><label class="collapse" for="c-39258718">[-]</label><label class="expand" for="c-39258718">[1 more]</label></div><br/><div class="children"><div class="content">Looks like a race condition between disassembly and linking, re-evaluate the code block may help</div><br/></div></div></div></div></div></div></div></div></div></body></html>