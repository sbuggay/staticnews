<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709370077097" as="style"/><link rel="stylesheet" href="styles.css?v=1709370077097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wizardzines.com/comics/bash-debugging/">Bash Debugging</a> <span class="domain">(<a href="https://wizardzines.com">wizardzines.com</a>)</span></div><div class="subtext"><span>ColinWright</span> | <span>34 comments</span></div><br/><div><div id="39569939" class="c"><input type="checkbox" id="c-39569939" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#39569479">next</a><span>|</span><label class="collapse" for="c-39569939">[-]</label><label class="expand" for="c-39569939">[1 more]</label></div><br/><div class="children"><div class="content">We use a couple nice home-grown functions in ZFSBootMenu to help debug things. We have a zdebug logging function that&#x27;s peppered liberally throughout the code base - <a href="https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootmenu&#x2F;lib&#x2F;kmsg-log-lib.sh#L16-L38">https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootme...</a><p>Hitting ctrl-t on our main menu will, when booting with debug logging enabled, show a screen like this: <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;Ge75zkP.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;Ge75zkP.png</a><p>We also have a flamegraph profiling mechanism that can be enabled with <a href="https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootmenu&#x2F;profiling&#x2F;profiling-lib.sh">https:&#x2F;&#x2F;github.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;blob&#x2F;master&#x2F;zfsbootme...</a> . That will dump data to a serial port, which when re-assembled, can be used to produce a graph like <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;master&#x2F;media&#x2F;flamechart-v1.12.svg" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zbm-dev&#x2F;zfsbootmenu&#x2F;master...</a><p>Bash is suprisingly flexible.</div><br/></div></div><div id="39569479" class="c"><input type="checkbox" id="c-39569479" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#39569939">prev</a><span>|</span><a href="#39569816">next</a><span>|</span><label class="collapse" for="c-39569479">[-]</label><label class="expand" for="c-39569479">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually possible to produce a stack trace of sorts, if you use a lot of bash functions.  One possible implementation is: <a href="https:&#x2F;&#x2F;github.com&#x2F;TritonDataCenter&#x2F;sdc-headnode&#x2F;blob&#x2F;master&#x2F;buildtools&#x2F;lib&#x2F;error_handler.sh">https:&#x2F;&#x2F;github.com&#x2F;TritonDataCenter&#x2F;sdc-headnode&#x2F;blob&#x2F;master...</a></div><br/><div id="39569842" class="c"><input type="checkbox" id="c-39569842" checked=""/><div class="controls bullet"><span class="by">drizzleword</span><span>|</span><a href="#39569479">parent</a><span>|</span><a href="#39569816">next</a><span>|</span><label class="collapse" for="c-39569842">[-]</label><label class="expand" for="c-39569842">[1 more]</label></div><br/><div class="children"><div class="content">Another stack trace implementation [1] that allows you to write:<p><pre><code>  some-command || fail &quot;message&quot;
</code></pre>
to produce a stack trace and exit the shell in case of non-zero exit status from some-command, or write<p><pre><code>  some-command || softfail &quot;message&quot; || return $?
</code></pre>
in case you want to produce a stack trace and return from the function.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;runag&#x2F;runag&#x2F;blob&#x2F;main&#x2F;lib&#x2F;fail.sh">https:&#x2F;&#x2F;github.com&#x2F;runag&#x2F;runag&#x2F;blob&#x2F;main&#x2F;lib&#x2F;fail.sh</a></div><br/></div></div></div></div><div id="39569816" class="c"><input type="checkbox" id="c-39569816" checked=""/><div class="controls bullet"><span class="by">jph</span><span>|</span><a href="#39569479">prev</a><span>|</span><a href="#39569325">next</a><span>|</span><label class="collapse" for="c-39569816">[-]</label><label class="expand" for="c-39569816">[2 more]</label></div><br/><div class="children"><div class="content">Good info. You can improve your debugging by using exit codes like this:<p><pre><code>    # die: print error message to stderr, then exit with error code.
    # example: die 69 &quot;Service unavailable.&quot;
    die() {
            n=&quot;$1&quot; ; shift ; &gt;&amp;2 printf %s\\n &quot;$*&quot; ; exit &quot;$n&quot;
    }
</code></pre>
Many more shell script exit codes and helper functions:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;SixArm&#x2F;unix-shell-script-kit&#x2F;blob&#x2F;main&#x2F;unix-shell-script-kit">https:&#x2F;&#x2F;github.com&#x2F;SixArm&#x2F;unix-shell-script-kit&#x2F;blob&#x2F;main&#x2F;un...</a></div><br/><div id="39570781" class="c"><input type="checkbox" id="c-39570781" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569816">parent</a><span>|</span><a href="#39569325">next</a><span>|</span><label class="collapse" for="c-39570781">[-]</label><label class="expand" for="c-39570781">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a nice list; I guess every experienced user has their helper functions.  However, I have a small criticism for the philosophy of that `die`: `die` functions should pass by default the exit code of the failed command, and not silence its error output.  If I want to give my own meaning to the command failure in a large script for instance, I will use a different, more specialized `die`.  My own die is roughly as follows:<p><pre><code>    __errex() {
     printf &#x27;Fatal error [%s] on line %s in &#x27;&quot;&#x27;&quot;&#x27;%s&#x27;&quot;&#x27;&quot;&#x27;: %s\n&#x27; \
            &quot;${1:-&quot;?&quot;}&quot;                                         \
            &quot;${2:-&quot;?&quot;}&quot;                                         \
            &quot;${3:-&quot;unknown script&quot;}&quot;                            \
            &quot;${4:-&quot;unknown error&quot;}&quot; &gt;&amp;2                         ;
     exit &quot;${1:-1}&quot;
    }
    alias die=&#x27;__errex &quot;$?&quot; &quot;${LINENO}&quot; &quot;$0&quot;&#x27;</code></pre></div><br/></div></div></div></div><div id="39569325" class="c"><input type="checkbox" id="c-39569325" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39569816">prev</a><span>|</span><a href="#39570833">next</a><span>|</span><label class="collapse" for="c-39569325">[-]</label><label class="expand" for="c-39569325">[2 more]</label></div><br/><div class="children"><div class="content">I always put<p>set -euxo pipefail<p>at the top of my bash scripts. It makes some conditional testing more difficult but it has paid for itself many times over just because of pipefail</div><br/><div id="39569397" class="c"><input type="checkbox" id="c-39569397" checked=""/><div class="controls bullet"><span class="by">ddlsmurf</span><span>|</span><a href="#39569325">parent</a><span>|</span><a href="#39570833">next</a><span>|</span><label class="collapse" for="c-39569397">[-]</label><label class="expand" for="c-39569397">[1 more]</label></div><br/><div class="children"><div class="content">You can also set it for a bunch of lines then deactivate it with `set +x`. It gets rather tedious otherwise...</div><br/></div></div></div></div><div id="39570833" class="c"><input type="checkbox" id="c-39570833" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569325">prev</a><span>|</span><a href="#39569941">next</a><span>|</span><label class="collapse" for="c-39570833">[-]</label><label class="expand" for="c-39570833">[1 more]</label></div><br/><div class="children"><div class="content">The `trap DEBUG` thing is pretty interesting; I almost always write POSIX code, so I don&#x27;t get to play with such tricks.  Does anybody know of some wizardry that could mimic this in arbitrary POSIX compliant shells?</div><br/></div></div><div id="39569941" class="c"><input type="checkbox" id="c-39569941" checked=""/><div class="controls bullet"><span class="by">thaumaturgy</span><span>|</span><a href="#39570833">prev</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39569941">[-]</label><label class="expand" for="c-39569941">[3 more]</label></div><br/><div class="children"><div class="content">The `die()` trick is good, but bash has an annoying quirk: if you try to `exit` while you&#x27;re inside a subshell, then the subshell exits but the rest of the script continues. Example:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    
    die() { echo &quot;$1&quot; &gt;&amp;2; exit 1; }
    
    cat myfile | while read line; do
        if [[ &quot;$line&quot; =~ &quot;information&quot; ]]; then
            die &quot;Found match&quot;
        fi
    done
    echo &quot;I don&#x27;t want this line&quot;
</code></pre>
...&quot;I don&#x27;t want this line&quot; will be printed.<p>You can often avoid subshells (and in this specific example, shellcheck is absolutely right to complain about UUOC, and fixing that will also fix the die-from-a-subshell problem).<p>But, sometimes you can&#x27;t, or avoiding a subshell really complicates the script. For those occasions, you can grab the script&#x27;s PID at the top of the script and then use that to kill it dead:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    
    MYPID=$$
    
    die() { echo &quot;$1&quot; &gt;&amp;2; kill -9 $MYPID; exit 1;  }
    
    cat myfile | while read line; do
        if [[ &quot;$line&quot; =~ &quot;information&quot; ]]; then
            die &quot;Found match&quot;
        fi
    done
    echo &quot;I don&#x27;t want this line&quot;
</code></pre>
...but, of course, there are tradeoffs here too; killing it this way is a little bit brutal, and I&#x27;ve found that (for reasons I don&#x27;t understand) it&#x27;s not entirely reliable either.</div><br/><div id="39570221" class="c"><input type="checkbox" id="c-39570221" checked=""/><div class="controls bullet"><span class="by">whatindaheck</span><span>|</span><a href="#39569941">parent</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39570221">[-]</label><label class="expand" for="c-39570221">[2 more]</label></div><br/><div class="children"><div class="content">Could killing the PID like that create zombies?</div><br/><div id="39570525" class="c"><input type="checkbox" id="c-39570525" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569941">root</a><span>|</span><a href="#39570221">parent</a><span>|</span><a href="#39569837">next</a><span>|</span><label class="collapse" for="c-39570525">[-]</label><label class="expand" for="c-39570525">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but in any case I would never write code like this.<p>First of all, sending sigkill is literally overkill and perpetuates a bad practice.  Send `TERM`.  If it doesn&#x27;t work, figure out why.<p>Secondly, subshells should be made as clear as possible and not hidden in pipes.  Related, looping over `read` is essentially never the right thing to do.  If you really need to do that, don&#x27;t use pipes; use heredocs or herestrings.<p>Fourth, if you cannot avoid subshells and you want to terminate the full script on some condition, exit with a specific exit code from the subshell, check for it outside and terminate appropriately.</div><br/></div></div></div></div></div></div><div id="39569837" class="c"><input type="checkbox" id="c-39569837" checked=""/><div class="controls bullet"><span class="by">bewuethr</span><span>|</span><a href="#39569941">prev</a><span>|</span><a href="#39569489">next</a><span>|</span><label class="collapse" for="c-39569837">[-]</label><label class="expand" for="c-39569837">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also a fairly powerful gdb style actual debugger: <a href="https:&#x2F;&#x2F;bashdb.sourceforge.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bashdb.sourceforge.net&#x2F;</a></div><br/></div></div><div id="39569489" class="c"><input type="checkbox" id="c-39569489" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#39569837">prev</a><span>|</span><a href="#39569454">next</a><span>|</span><label class="collapse" for="c-39569489">[-]</label><label class="expand" for="c-39569489">[1 more]</label></div><br/><div class="children"><div class="content">See also:<p>Why doesn&#x27;t set -e (or set -o errexit, or trap ERR) do what I expected?
 <a href="https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;105" rel="nofollow">https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;105</a><p>What are the advantages and disadvantages of using set -u (or set -o nounset)?
 <a href="https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;112" rel="nofollow">https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;112</a><p>Safe ways to do things in bash <a href="https:&#x2F;&#x2F;github.com&#x2F;anordal&#x2F;shellharden&#x2F;blob&#x2F;master&#x2F;how_to_do_things_safely_in_bash.md">https:&#x2F;&#x2F;github.com&#x2F;anordal&#x2F;shellharden&#x2F;blob&#x2F;master&#x2F;how_to_do...</a><p>Better Bash Scripting in 15 Minutes <a href="https:&#x2F;&#x2F;robertmuth.blogspot.com&#x2F;2012&#x2F;08&#x2F;better-bash-scripting-in-15-minutes.html" rel="nofollow">https:&#x2F;&#x2F;robertmuth.blogspot.com&#x2F;2012&#x2F;08&#x2F;better-bash-scriptin...</a><p>Writing Robust Bash Shell Scripts <a href="https:&#x2F;&#x2F;www.davidpashley.com&#x2F;articles&#x2F;writing-robust-shell-scripts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.davidpashley.com&#x2F;articles&#x2F;writing-robust-shell-s...</a></div><br/></div></div><div id="39569454" class="c"><input type="checkbox" id="c-39569454" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#39569489">prev</a><span>|</span><a href="#39569268">next</a><span>|</span><label class="collapse" for="c-39569454">[-]</label><label class="expand" for="c-39569454">[1 more]</label></div><br/><div class="children"><div class="content">I have almost that same die() in every script, except I call it abrt(). Maybe I&#x27;ll switch to die() since it&#x27;s shorter. Mine also prepends $0 and sometimes I use printf or echo -e so I can pass larger more complex messages with linefeeds and escape codes etc.</div><br/></div></div><div id="39569268" class="c"><input type="checkbox" id="c-39569268" checked=""/><div class="controls bullet"><span class="by">memco</span><span>|</span><a href="#39569454">prev</a><span>|</span><a href="#39569555">next</a><span>|</span><label class="collapse" for="c-39569268">[-]</label><label class="expand" for="c-39569268">[6 more]</label></div><br/><div class="children"><div class="content">Good stuff! I use set-x frequently and have used a similar thing to die (but Julia’s version is nicer). I’ll consider using the debugger thing but stepping through a bash script line by line sounds a bit tedious. Perhaps less so than having to reread a log and rerun the script a bunch.</div><br/><div id="39569455" class="c"><input type="checkbox" id="c-39569455" checked=""/><div class="controls bullet"><span class="by">halostatue</span><span>|</span><a href="#39569268">parent</a><span>|</span><a href="#39569305">next</a><span>|</span><label class="collapse" for="c-39569455">[-]</label><label class="expand" for="c-39569455">[4 more]</label></div><br/><div class="children"><div class="content">I often add a fail-unless function:<p><pre><code>    fail-unless() {
      local result
      &quot;$@&quot;
      result=$?

      if ((result != 0)); then
        echo &gt;2&amp;1 &quot;Failed  ${result} with command &#x27;$*&#x27;.&quot;
        exit ${result}
      fi
    }
</code></pre>
That way, I know exactly what failed in the script.</div><br/><div id="39570253" class="c"><input type="checkbox" id="c-39570253" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39569455">parent</a><span>|</span><a href="#39569784">next</a><span>|</span><label class="collapse" for="c-39570253">[-]</label><label class="expand" for="c-39570253">[2 more]</label></div><br/><div class="children"><div class="content">You do e.g. `fail-unless somecommand`. The result (exit&#x2F;return code) is captured in the function and based on that, the function logs and exits or not.</div><br/><div id="39570537" class="c"><input type="checkbox" id="c-39570537" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39570253">parent</a><span>|</span><a href="#39569784">next</a><span>|</span><label class="collapse" for="c-39570537">[-]</label><label class="expand" for="c-39570537">[1 more]</label></div><br/><div class="children"><div class="content">You probably meant to reply to BeefySwain, right?</div><br/></div></div></div></div><div id="39569784" class="c"><input type="checkbox" id="c-39569784" checked=""/><div class="controls bullet"><span class="by">BeefySwain</span><span>|</span><a href="#39569268">root</a><span>|</span><a href="#39569455">parent</a><span>|</span><a href="#39570253">prev</a><span>|</span><a href="#39569305">next</a><span>|</span><label class="collapse" for="c-39569784">[-]</label><label class="expand" for="c-39569784">[1 more]</label></div><br/><div class="children"><div class="content">How does this work exactly? What calls that function and when?</div><br/></div></div></div></div><div id="39569305" class="c"><input type="checkbox" id="c-39569305" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#39569268">parent</a><span>|</span><a href="#39569455">prev</a><span>|</span><a href="#39569555">next</a><span>|</span><label class="collapse" for="c-39569305">[-]</label><label class="expand" for="c-39569305">[1 more]</label></div><br/><div class="children"><div class="content">The line-by-line debugging would probably only be useful for a particular section of your script that you&#x27;re trying to fix. In that case, you can remove the trap at the end of it with `trap - DEBUG`</div><br/></div></div></div></div><div id="39569555" class="c"><input type="checkbox" id="c-39569555" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#39569268">prev</a><span>|</span><a href="#39570051">next</a><span>|</span><label class="collapse" for="c-39569555">[-]</label><label class="expand" for="c-39569555">[8 more]</label></div><br/><div class="children"><div class="content">Is there a reason bash is still the de facto shell scripting language other than sheer momentum of legacy? I&#x27;m able to get what I need done in it, but it&#x27;s clunky and the syntax is horrid. I guess it forces you to move to a proper language once scripts grow to a certain size&#x2F;complexity, so perhaps it&#x27;s by design?</div><br/><div id="39570201" class="c"><input type="checkbox" id="c-39570201" checked=""/><div class="controls bullet"><span class="by">theonemind</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569846">next</a><span>|</span><label class="collapse" for="c-39570201">[-]</label><label class="expand" for="c-39570201">[1 more]</label></div><br/><div class="children"><div class="content">bourne shell scripting is good enough, which makes it nearly impossible to replace. Plan9&#x27;s rc is a bit cleaner, and no one is going to switch for &#x27;more of the same, but cleaner&#x27;. You haven&#x27;t switched to something similar but better even though you could literally do it right now <a href="https:&#x2F;&#x2F;pkgsrc.se&#x2F;shells" rel="nofollow">https:&#x2F;&#x2F;pkgsrc.se&#x2F;shells</a> , and it doesn&#x27;t run any different for anyone else.   It usually takes something several times better in some crucial aspect to replace an entrenched technology. For example, Plan 9 is better than UNIX-like systems, but not good enough to replace them. I don&#x27;t think it&#x27;s possible to make something good enough to replace bourne shell scripting in its niche because before you have something several times better, good enough to actually replace it, you&#x27;re in a different ecological niche or problem domain, for real scripting languages like Perl, Python, and Ruby. It&#x27;s a local maximum solution that sucks the air out of the room for potential competition closer to the theoretical global maximum solution for the narrow problem domain.</div><br/></div></div><div id="39569846" class="c"><input type="checkbox" id="c-39569846" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39570201">prev</a><span>|</span><a href="#39569574">next</a><span>|</span><label class="collapse" for="c-39569846">[-]</label><label class="expand" for="c-39569846">[1 more]</label></div><br/><div class="children"><div class="content">It really is just legacy and momentum. Recent additions build on sh&#x2F;bash really well but in the end shell scripting is a means to an end that need to evolve much slower than standard programming languages.<p>I think bash&#x2F;sh’s key feature is that they are anti-entropy, there’s no development or evolution so there’s no chance you need to mess with dependencies or new features, the stuff that worked 20 years ago will continue to be the “bread and butter”. By design, this results in a system that’s averse to change and incentivizes people to reach outside of its limits when they are met.</div><br/></div></div><div id="39569574" class="c"><input type="checkbox" id="c-39569574" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569846">prev</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39569574">[-]</label><label class="expand" for="c-39569574">[4 more]</label></div><br/><div class="children"><div class="content">Are you sure it&#x27;s bash? Most scripts on FreeBSD&#x27;s are written for sh, which I feel is much more widely supported due to being part of the POSIX standard. Bash is just popular I think.</div><br/><div id="39570276" class="c"><input type="checkbox" id="c-39570276" checked=""/><div class="controls bullet"><span class="by">HankB99</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39569574">parent</a><span>|</span><a href="#39570464">next</a><span>|</span><label class="collapse" for="c-39570276">[-]</label><label class="expand" for="c-39570276">[1 more]</label></div><br/><div class="children"><div class="content">Bash is pretty much expected to be installed on any Linux distro. On FreeBSD (and likely other BSDs) it is an optional install. If you want a script to run on either, use sh. If strictly Linux, bash is probably safe.<p>Bash&#x2F;sh is good for when you need to combine some commands and what needs to be done can be accomplished mostly by CLI commands with a little glue to tie them together. Some times it is surprising what can be accomplished. I wrote a program to import pictures from an SD card on Windows using C#, copying pictures to C:\Pictures\YYYY\MM\DD according to the EXIF data or failing that, file time stamp. I tried to port it to Linux but ran into problems trying to connect to the EXIF library. After struggling with that, I rewrote it using sh, some EXIF tool and various file utilities. It took 31 lines, about half of which were actual commands and the rest comments or white space.<p>A much bigger project is a script to install Debian with root on ZFS. It&#x27;s mostly a series of CLI commands with some variable substitution and conditionals depending on stuff like encrypted or not.</div><br/></div></div><div id="39570464" class="c"><input type="checkbox" id="c-39570464" checked=""/><div class="controls bullet"><span class="by">xp84</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39569574">parent</a><span>|</span><a href="#39570276">prev</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39570464">[-]</label><label class="expand" for="c-39570464">[2 more]</label></div><br/><div class="children"><div class="content">I suppose it’s an ambiguous designation.<p>I feel like when I see a shell script in my work, which is not in operating systems development of course, people are targeting bash. I agree many things are careful to target sh for certain reasons (e.g. a script that runs in a container where the base image doesn’t have bash installed) but i still think GP’s question is interesting because it’s not common to see, say, a zsh shell script, but seeing #!&#x2F;bin&#x2F;bash is super common.</div><br/><div id="39570584" class="c"><input type="checkbox" id="c-39570584" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39569555">root</a><span>|</span><a href="#39570464">parent</a><span>|</span><a href="#39570906">next</a><span>|</span><label class="collapse" for="c-39570584">[-]</label><label class="expand" for="c-39570584">[1 more]</label></div><br/><div class="children"><div class="content">I have done some delightful stuff in `zsh`, but I always lament how slow its numerical array traversal is.  Frustratingly, experts told me it really doesn&#x27;t have to be slow, the devs just don&#x27;t seem to be bothering to revamp the underlying data structure because they are focusing more on associative arrays.</div><br/></div></div></div></div></div></div><div id="39570906" class="c"><input type="checkbox" id="c-39570906" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39569555">parent</a><span>|</span><a href="#39569574">prev</a><span>|</span><a href="#39570051">next</a><span>|</span><label class="collapse" for="c-39570906">[-]</label><label class="expand" for="c-39570906">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ubiquitous.<p>But bash is so bad I wrote a ton of namespace shortened utils for using groovy scripts.<p>Sooooooooooooooooo much better. use IDEs for dev, save library system, groovy smoothed almost all Java annoyances</div><br/></div></div></div></div><div id="39570051" class="c"><input type="checkbox" id="c-39570051" checked=""/><div class="controls bullet"><span class="by">mmmpetrichor</span><span>|</span><a href="#39569555">prev</a><span>|</span><label class="collapse" for="c-39570051">[-]</label><label class="expand" for="c-39570051">[5 more]</label></div><br/><div class="children"><div class="content">If I ever have to debug anything in bash. I stop using bash hah.</div><br/><div id="39570668" class="c"><input type="checkbox" id="c-39570668" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39570051">parent</a><span>|</span><a href="#39570165">next</a><span>|</span><label class="collapse" for="c-39570668">[-]</label><label class="expand" for="c-39570668">[2 more]</label></div><br/><div class="children"><div class="content">I find such reasoning backwards.  Indeed, shell scripting is not friendly to debugging.  But ensuring correctness of shell scripts is essential: usually, they touch part of your &quot;$HOME&quot; or system folders and do tons of I&#x2F;O, some of it destructive.  I find it baffling to see people write careless scripts; sometimes using `rm` for cleanup with unquoted parameters, or much worse, dangerous uses of `mv`.</div><br/><div id="39571106" class="c"><input type="checkbox" id="c-39571106" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#39570051">root</a><span>|</span><a href="#39570668">parent</a><span>|</span><a href="#39570165">next</a><span>|</span><label class="collapse" for="c-39571106">[-]</label><label class="expand" for="c-39571106">[1 more]</label></div><br/><div class="children"><div class="content">I believe OP&#x27;s point was that any shell script complex enough to require debugging should not be a shell script any more.</div><br/></div></div></div></div><div id="39570165" class="c"><input type="checkbox" id="c-39570165" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#39570051">parent</a><span>|</span><a href="#39570668">prev</a><span>|</span><label class="collapse" for="c-39570165">[-]</label><label class="expand" for="c-39570165">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t make sense. What if you get a script someone else wrote? Printing every command and confirming as you run every command is a great idea.<p>And, unfortunately shell has become the norm in CI&#x2F;CD environments, pipelines etc. Can be convenient at times but can also be inconvenient and confusing as these scripts don&#x27;t run in interactive shells.</div><br/><div id="39571097" class="c"><input type="checkbox" id="c-39571097" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#39570051">root</a><span>|</span><a href="#39570165">parent</a><span>|</span><label class="collapse" for="c-39571097">[-]</label><label class="expand" for="c-39571097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And, unfortunately shell has become the norm in CI&#x2F;CD environments, pipelines etc.<p>A pipeline which relies on shell is not worth using, tbh. That&#x27;s how much shell sucks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>