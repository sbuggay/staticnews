<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702890066737" as="style"/><link rel="stylesheet" href="styles.css?v=1702890066737"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/">Tracking Java native memory with JDK flight recorder</a> <span class="domain">(<a href="https://www.morling.dev">www.morling.dev</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>16 comments</span></div><br/><div><div id="38680355" class="c"><input type="checkbox" id="c-38680355" checked=""/><div class="controls bullet"><span class="by">gunnarmorling</span><span>|</span><a href="#38677863">next</a><span>|</span><label class="collapse" for="c-38680355">[-]</label><label class="expand" for="c-38680355">[1 more]</label></div><br/><div class="children"><div class="content">Author of the post here, so nice to see it being discussed here. For folks interested to learn more about JFR, here are a few other post on that topic:<p>* <a href="https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;finding-java-thread-leaks-with-jdk-flight-recorder-and-bit-of-sql&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;finding-java-thread-leaks-with-...</a>: Discusses how to find thread likes with JFR and JFR Analytics, a project I&#x27;ve created for querying recordings with SQL<p>* <a href="https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;towards-continuous-performance-regression-testing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;towards-continuous-performance-...</a>: Discusses how to use JFR for continuous performance testing, by means of asserting &quot;proxy metrics&quot; such as allocation rates and IO<p>* <a href="https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;rest-api-monitoring-with-custom-jdk-flight-recorder-events&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.morling.dev&#x2F;blog&#x2F;rest-api-monitoring-with-custom...</a>: Discusses how to create your own application-specific JFR events</div><br/></div></div><div id="38677863" class="c"><input type="checkbox" id="c-38677863" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#38680355">prev</a><span>|</span><a href="#38679578">next</a><span>|</span><label class="collapse" for="c-38677863">[-]</label><label class="expand" for="c-38677863">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the one thing which NMT does not report, despite what the name might suggest, is any memory allocated by native libraries, for instance invoked via JNI<p>If you&#x27;re using glibc, then malloc does have information about that, and provides ways to read it, so it&#x27;s a shame this isn&#x27;t exposed. It would be quite helpful in the face of suspected native library memory leaks.</div><br/><div id="38678045" class="c"><input type="checkbox" id="c-38678045" checked=""/><div class="controls bullet"><span class="by">strangemonad</span><span>|</span><a href="#38677863">parent</a><span>|</span><a href="#38679578">next</a><span>|</span><label class="collapse" for="c-38678045">[-]</label><label class="expand" for="c-38678045">[1 more]</label></div><br/><div class="children"><div class="content">jemalloc + memleak and perf work pretty well in that case. I think you could do something similar with tcmalloc</div><br/></div></div></div></div><div id="38679578" class="c"><input type="checkbox" id="c-38679578" checked=""/><div class="controls bullet"><span class="by">kkcorps</span><span>|</span><a href="#38677863">prev</a><span>|</span><a href="#38677812">next</a><span>|</span><label class="collapse" for="c-38679578">[-]</label><label class="expand" for="c-38679578">[2 more]</label></div><br/><div class="children"><div class="content">debugging native calls in itself is also painful. I have switched to using async-profiler (<a href="https:&#x2F;&#x2F;github.com&#x2F;async-profiler&#x2F;async-profiler">https:&#x2F;&#x2F;github.com&#x2F;async-profiler&#x2F;async-profiler</a>) instead of JFR for most of my usecases.<p>A. it tracks native calls by default
B. it can track wall time as well
C. you can have neat interactive flamegraphs</div><br/><div id="38680195" class="c"><input type="checkbox" id="c-38680195" checked=""/><div class="controls bullet"><span class="by">Sarkie</span><span>|</span><a href="#38679578">parent</a><span>|</span><a href="#38677812">next</a><span>|</span><label class="collapse" for="c-38680195">[-]</label><label class="expand" for="c-38680195">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t believe we need to use async profiler tbh.<p>It should all be in jfc&#x2F;jmc</div><br/></div></div></div></div><div id="38677812" class="c"><input type="checkbox" id="c-38677812" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#38679578">prev</a><span>|</span><a href="#38678094">next</a><span>|</span><label class="collapse" for="c-38677812">[-]</label><label class="expand" for="c-38677812">[1 more]</label></div><br/><div class="children"><div class="content">For summary views:<p><pre><code>    $ jfr view native-memory-reserved rec.jfr
</code></pre>
and<p><pre><code>    $ jfr view native-memory-committed rec.jfr
</code></pre>
<a href="https:&#x2F;&#x2F;x.com&#x2F;ErikGahlin&#x2F;status&#x2F;1736530559231201484" rel="nofollow noreferrer">https:&#x2F;&#x2F;x.com&#x2F;ErikGahlin&#x2F;status&#x2F;1736530559231201484</a></div><br/></div></div><div id="38678094" class="c"><input type="checkbox" id="c-38678094" checked=""/><div class="controls bullet"><span class="by">vanillax</span><span>|</span><a href="#38677812">prev</a><span>|</span><a href="#38678044">next</a><span>|</span><label class="collapse" for="c-38678094">[-]</label><label class="expand" for="c-38678094">[7 more]</label></div><br/><div class="children"><div class="content">whats a real world use case for this? Been doing big enterprise java for a decade and never ran into a scenario where I would need this. Don&#x27;t get me wrong, I think theres most certainly value for this, but usually doing plain ole Spring Boot or the dreaded Adobe Experience manager, things just &quot;work&quot;. So just honestly curious what problem this would help me solve? Im guessing if you develop a platform you need performance and need to find weak points in your platform? Or is this for building out tools like Dynatrace &#x2F; New Relic.</div><br/><div id="38680332" class="c"><input type="checkbox" id="c-38680332" checked=""/><div class="controls bullet"><span class="by">syntacticbs</span><span>|</span><a href="#38678094">parent</a><span>|</span><a href="#38680338">next</a><span>|</span><label class="collapse" for="c-38680332">[-]</label><label class="expand" for="c-38680332">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked in applications where a lot of IO is required. If performance is something your application cares about then you&#x27;ll probably end up using direct ByteBuffers which are off heap and you&#x27;ll likely want to set a sensible value for: -XX:MaxDirectMemorySize<p>However if this value ever does get exceeded, you need some way of tracking down what allocations happened prior to your OutOfMemory exception.<p>Though the above article implies the sampling rate is once a second (I guess there&#x27;s some cost to increasing that rate). Usually you won&#x27;t be allocating direct memory on the reg since it&#x27;s expensive to allocate and deallocate relative to heap memory so you kind of want to capture ALL allocations and deallocations. As such a sample based approach is not ideal due to possibly missing some data between samples.</div><br/></div></div><div id="38680338" class="c"><input type="checkbox" id="c-38680338" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#38678094">parent</a><span>|</span><a href="#38680332">prev</a><span>|</span><a href="#38680109">next</a><span>|</span><label class="collapse" for="c-38680338">[-]</label><label class="expand" for="c-38680338">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good question. I can&#x27;t imagine that you&#x27;d need to use this to track normal garbage collected memory. There were pretty good tools already in place for that.<p>I guess what you&#x27;d want to use this for, is when your application is directly allocating memory, e.g. via direct byte buffers. That&#x27;s not something you&#x27;d do in an enterprise application, it&#x27;s more something you&#x27;d need for high performance image processing, or maybe for some extremely high performance web server.</div><br/></div></div><div id="38680109" class="c"><input type="checkbox" id="c-38680109" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38678094">parent</a><span>|</span><a href="#38680338">prev</a><span>|</span><a href="#38679759">next</a><span>|</span><label class="collapse" for="c-38680109">[-]</label><label class="expand" for="c-38680109">[3 more]</label></div><br/><div class="children"><div class="content">Using offheap memory allocation in Java is generally a bad idea.
Java is a GC&#x27;d language. If you need to manage memory manually, use a language designed for that. The lengths people go to NOT learn another language (while having to learn stuff like this and do primitive memory management in your application code - which itself may use the GC if you&#x27;re not careful) amazes me.</div><br/><div id="38680399" class="c"><input type="checkbox" id="c-38680399" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38678094">root</a><span>|</span><a href="#38680109">parent</a><span>|</span><a href="#38680324">next</a><span>|</span><label class="collapse" for="c-38680399">[-]</label><label class="expand" for="c-38680399">[1 more]</label></div><br/><div class="children"><div class="content">It is called taking your cake and eating it too, in terms of productivity, IDE tooling and library ecosystem, for the same reasons ML frameworks use Python with bindings to C++ libraries, instead of being 100% written in C++.</div><br/></div></div><div id="38680324" class="c"><input type="checkbox" id="c-38680324" checked=""/><div class="controls bullet"><span class="by">bzzzt</span><span>|</span><a href="#38678094">root</a><span>|</span><a href="#38680109">parent</a><span>|</span><a href="#38680399">prev</a><span>|</span><a href="#38679759">next</a><span>|</span><label class="collapse" for="c-38680324">[-]</label><label class="expand" for="c-38680324">[1 more]</label></div><br/><div class="children"><div class="content">While I fully agree as a rule you shouldn&#x27;t have to do manual memory management in Java, the functionality is there and useful in exceptional situations. 
I&#x27;ve seen integrations where there&#x27;s no &#x27;100% pure Java&#x27; implementation available, so you have to choose between picking a battle-tested native library or reimplementing from scratch in Java (which sometimes isn&#x27;t even possible with closed source systems)</div><br/></div></div></div></div><div id="38679759" class="c"><input type="checkbox" id="c-38679759" checked=""/><div class="controls bullet"><span class="by">bzzzt</span><span>|</span><a href="#38678094">parent</a><span>|</span><a href="#38680109">prev</a><span>|</span><a href="#38678044">next</a><span>|</span><label class="collapse" for="c-38679759">[-]</label><label class="expand" for="c-38679759">[1 more]</label></div><br/><div class="children"><div class="content">I’ve encountered native memory issues in those “enterprise” apps. Lots a frameworks set an upper bound and if you load one library too much you can run out of JIT compiler cache leading to constant compilation which tanks performance.
More ways to get insights can’t hurt.</div><br/></div></div></div></div><div id="38678044" class="c"><input type="checkbox" id="c-38678044" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#38678094">prev</a><span>|</span><a href="#38677943">next</a><span>|</span><label class="collapse" for="c-38678044">[-]</label><label class="expand" for="c-38678044">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s some more NMT usage without flight recorder: <a href="https:&#x2F;&#x2F;blog.arkey.fr&#x2F;2020&#x2F;11&#x2F;30&#x2F;off-heap-reconnaissance&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.arkey.fr&#x2F;2020&#x2F;11&#x2F;30&#x2F;off-heap-reconnaissance&#x2F;</a></div><br/></div></div><div id="38677943" class="c"><input type="checkbox" id="c-38677943" checked=""/><div class="controls bullet"><span class="by">DarkmSparks</span><span>|</span><a href="#38678044">prev</a><span>|</span><label class="collapse" for="c-38677943">[-]</label><label class="expand" for="c-38677943">[1 more]</label></div><br/><div class="children"><div class="content">been a big fan of flight recorder since it was part of jrocket &amp; mission control iirc. great to see it making something of a come back.</div><br/></div></div></div></div></div></div></div></body></html>