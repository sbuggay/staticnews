<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710234066489" as="style"/><link rel="stylesheet" href="styles.css?v=1710234066489"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://copyninja.in/blog/clone_laptop_nvmet.html">Cloning a Laptop over NVMe TCP</a> <span class="domain">(<a href="https://copyninja.in">copyninja.in</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>52 comments</span></div><br/><div><div id="39676881" class="c"><input type="checkbox" id="c-39676881" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#39676905">next</a><span>|</span><label class="collapse" for="c-39676881">[-]</label><label class="expand" for="c-39676881">[18 more]</label></div><br/><div class="children"><div class="content">In the author&#x27;s scenario, there are zero benefits in using NVMe&#x2F;TCP, as he just ends up doing a serial block copy using dd(1) so he&#x27;s not leveraging concurrent I&#x2F;O. All the complex commands can be replaced by a simple netcat.<p>On the destination laptop:<p><pre><code>  $ nc -l -p 1234 | dd of=&#x2F;dev&#x2F;nvme0nX bs=1M
</code></pre>
On the source laptop:<p><pre><code>  $ nc x.x.x.x 1234 &lt;&#x2F;dev&#x2F;nvme0nX
</code></pre>
The dd on the destination is just to buffer writes so they are faster&#x2F;more efficient. Add a gzip&#x2F;gunzip on the source&#x2F;destination and the whole operation is a lot faster if your disk isn&#x27;t full, ie. if you have many zero blocks. This is by far my favorite way to image a PC over the network. I have done this many times. Be sure to pass &quot;--fast&quot; to gzip as the compression is typically a bottleneck on GigE. Or better: replace gzip&#x2F;gunzip with lz4&#x2F;unlz4 as it&#x27;s even faster. Last time I did this was to image a brand new Windows laptop with a 1TB NVMe. Took 20 min (IIRC?) over GigE and the resulting image was 20GB as the empty disk space compresses to practically nothing. I typically back up that lz4 image and years later when I donate the laptop I restore the image with unlz4 | dd. Super convenient.<p>That said I didn&#x27;t know about that Linux kernel module nvme-tcp. We learn new things every day :) I see that its utility is more for mounting a filesystem over a remote NVMe, rather than accessing it raw with dd.<p>Edit: on Linux the maximum pipe buffer size is 64kB so the dd bs=X argument doesn&#x27;t technically need to be larger than that. But bs=1M doesn&#x27;t hurt (it buffers the 64kB reads until 1MB has been received) and it&#x27;s future-proof if the pipe sizes is ever increased :) Some versions of netcat have options to control the input and output block size which would alleviate the need to use dd bs=X but on rescue discs the netcat binary is usually a version without these options.</div><br/><div id="39677137" class="c"><input type="checkbox" id="c-39677137" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39676881">parent</a><span>|</span><a href="#39677059">next</a><span>|</span><label class="collapse" for="c-39677137">[-]</label><label class="expand" for="c-39677137">[7 more]</label></div><br/><div class="children"><div class="content">As a sysadmin, I&#x27;d rather use NVMe TCP or Clonezilla to do a slow write rather than trying to go 5% faster with more moving parts and chance to corrupt my drive in the process.<p>Plus, a it&#x27;d be well deserved coffee break.<p>Considering I&#x27;d be going at GigE speeds at best, I&#x27;d add &quot;oflag=direct&quot; to bypass caching on the target. A bog standard NVMe can write &gt;300MBps unhindered, so trying to cache is moot.<p>Lastly, parted can do partition resizing, but given the user is not a power user to begin with, it&#x27;s just me nitpicking. Nice post otherwise.</div><br/><div id="39677308" class="c"><input type="checkbox" id="c-39677308" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677137">parent</a><span>|</span><a href="#39677193">next</a><span>|</span><label class="collapse" for="c-39677308">[-]</label><label class="expand" for="c-39677308">[3 more]</label></div><br/><div class="children"><div class="content">NVMe&#x2F;TCP or Clonezilla are vastly more moving parts and chances to mess up the options, compared to dd. In fact, the author&#x27;s solution exposes his NVMe to unauthenticated remote write access by any number of clients(!) By comparison, the dd on the source is read-only, and the dd on the destination only accepts the first connection (yours) and no one else on the network can write to the disk.<p>I strongly recommend <i>against</i> oflag=direct as in this specific use case it will always degrade performance. Read the O_DIRECT section in open(2). Or try it. Basically using oflag=direct locks the buffer so dd will have to wait for the block to be written by the kernel to disk until it can start reading the data again to fill the buffer with the next block, thereby reducing performance.</div><br/><div id="39677365" class="c"><input type="checkbox" id="c-39677365" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677308">parent</a><span>|</span><a href="#39677193">next</a><span>|</span><label class="collapse" for="c-39677365">[-]</label><label class="expand" for="c-39677365">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  the author&#x27;s solution exposes his NVMe to unauthenticated remote write access by any number of clients(!)<p>I won&#x27;t be bothered in a home network.<p>&gt; Clonezilla are vastly more moving parts<p>...and one of these moving parts is image integrity and write integrity verification, allowing byte-by-byte integrity during imaging and after write.<p>&gt; I strongly recommend against oflag=direct as in this... [snipped for brevity]<p>Unless you&#x27;re getting a bottom of the barrel NVMe, all of them have DRAM caches and do their own write caching independent of O_DIRECT, which only bypasses OS caches. Unless the pipe you have has higher throughput than your drive, caching in the storage device&#x27;s controller ensures optimal write speeds.<p>I can hit theoretical maximum write speeds of all my SSDs (internal or external) with O_DIRECT. When the pipe is fatter or the device can&#x27;t sustain that speeds, things go south, but this is why we have knobs.<p>When you don&#x27;t use O_DIRECT in these cases, you see initial speed surge maybe, but total time doesn&#x27;t reduce.<p>TL;DR: When you&#x27;re getting your data at 100MBps at most, using O_DIRECT on an SSD with 1GBps write speeds doesn&#x27;t affect anything. You&#x27;re not saturating anything on the pipe.<p>Just did a small test:<p><pre><code>    dd if=&#x2F;dev&#x2F;zero of=test.file bs=1024kB count=3072 oflag=direct status=progress 
    2821120000 bytes (2.8 GB, 2.6 GiB) copied, 7 s, 403 MB&#x2F;s
    3072+0 records in
    3072+0 records out
    3145728000 bytes (3.1 GB, 2.9 GiB) copied, 7.79274 s, 404 MB&#x2F;s
</code></pre>
Target is a Samsung T7 Shield 2TB, with 1050MB&#x2F;sec sustained write speed. Bus is USB 3.0 with 500MBps top speed (so I can go %50 of drive speeds). Result is 404MBps, which is fair for the bus.<p>If the drive didn&#x27;t have its own cache, caching on the OS side would have more profound effect since I can queue more writes to device and pool them at RAM.</div><br/><div id="39677466" class="c"><input type="checkbox" id="c-39677466" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677365">parent</a><span>|</span><a href="#39677193">next</a><span>|</span><label class="collapse" for="c-39677466">[-]</label><label class="expand" for="c-39677466">[1 more]</label></div><br/><div class="children"><div class="content">Your example proves me right. Your drive should be capable of 1000 MB&#x2F;s but O_DIRECT reduces performance to 400 MB&#x2F;s.<p>This matters in the specific use case of &quot;netcat | gunzip | dd&quot; as the compressed data rate on GigE will indeed be around 120 MB&#x2F;s but when gunzip is decompressing unused parts of the filesystem, it will attempt to write 1+ GB&#x2F;s or more to the pipe to dd and it would not be able to keep up with O_DIRECT.<p>Another thing you are doing wrong: benchmarking with &#x2F;dev&#x2F;zero. Many NVMe do transparent compression so writing zeroes is faster than writing random data.</div><br/></div></div></div></div></div></div><div id="39677193" class="c"><input type="checkbox" id="c-39677193" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677137">parent</a><span>|</span><a href="#39677308">prev</a><span>|</span><a href="#39677059">next</a><span>|</span><label class="collapse" for="c-39677193">[-]</label><label class="expand" for="c-39677193">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how you can consider the nvme over tcp version less moving parts.<p>dd is installed on every system, and if you don&#x27;t have nc you can still use ssh and sacrifice a bit of performance.<p><pre><code>  dd if=&#x2F;dev&#x2F;foo | ssh dest@bar &quot;cat &gt; &#x2F;dev&#x2F;moo&quot;</code></pre></div><br/><div id="39677205" class="c"><input type="checkbox" id="c-39677205" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677193">parent</a><span>|</span><a href="#39677059">next</a><span>|</span><label class="collapse" for="c-39677205">[-]</label><label class="expand" for="c-39677205">[2 more]</label></div><br/><div class="children"><div class="content">NVMe over TCP encapsulates and shows me the remote device as is. Just a block device.<p>I just copy that block device with &quot;dd&quot;, that&#x27;s all. It&#x27;s just a dumb pipe encapsulated with TCP, which is already battle tested enough.<p>Moreover, if I have fatter pipe, I can tune dd for better performance with a single command.</div><br/><div id="39677339" class="c"><input type="checkbox" id="c-39677339" checked=""/><div class="controls bullet"><span class="by">darkwater</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677205">parent</a><span>|</span><a href="#39677059">next</a><span>|</span><label class="collapse" for="c-39677339">[-]</label><label class="expand" for="c-39677339">[1 more]</label></div><br/><div class="children"><div class="content">netcat encapsulates data just the same (although in a different manner), and it&#x27;s even more battle-tested.
NVMe over TCP use case is to actually <i>use</i> the remote disk over the network as it were local. If you just need to dump a whole disk like in the article, dd+netcat (or even just netcat, as someone pointed out) will work just the same.</div><br/></div></div></div></div></div></div></div></div><div id="39677059" class="c"><input type="checkbox" id="c-39677059" checked=""/><div class="controls bullet"><span class="by">tripflag</span><span>|</span><a href="#39676881">parent</a><span>|</span><a href="#39677137">prev</a><span>|</span><a href="#39677381">next</a><span>|</span><label class="collapse" for="c-39677059">[-]</label><label class="expand" for="c-39677059">[8 more]</label></div><br/><div class="children"><div class="content">This use of dd may cause corruption! You need iflag=fullblock to ensure it doesn&#x27;t truncate any blocks, and (at the risk of cargo-culting) conv=sync doesn&#x27;t hurt as well. I prefer to just nc -l -p 1234 &gt; &#x2F;dev&#x2F;nvme0nX.</div><br/><div id="39677207" class="c"><input type="checkbox" id="c-39677207" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677059">parent</a><span>|</span><a href="#39677219">next</a><span>|</span><label class="collapse" for="c-39677207">[-]</label><label class="expand" for="c-39677207">[1 more]</label></div><br/><div class="children"><div class="content">Partial reads won&#x27;t corrupt the data. Dd will issue other read() until 1MB of data is buffered. The iflag=fullblock is only useful when counting or skipping bytes or doing direct I&#x2F;O. See line 1647: <a href="https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;dd.c#L1647">https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;dd.c#...</a></div><br/></div></div><div id="39677219" class="c"><input type="checkbox" id="c-39677219" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677059">parent</a><span>|</span><a href="#39677207">prev</a><span>|</span><a href="#39677264">next</a><span>|</span><label class="collapse" for="c-39677219">[-]</label><label class="expand" for="c-39677219">[2 more]</label></div><br/><div class="children"><div class="content">According to the documentation of dd, &quot;iflag=fullblock&quot; is required only when dd is used with the &quot;count=&quot; option.<p>Otherwise, i.e. when dd has to read the entire input file because there is no &quot;count=&quot; option, &quot;iflag=fullblock&quot; does not have any documented effect.<p>From &quot;info dd&quot;:<p>&quot;If short reads occur, as could be the case when reading from a pipe for example, ‘iflag=fullblock’ ensures that ‘count=’ counts complete input blocks rather than input read operations.&quot;</div><br/><div id="39677342" class="c"><input type="checkbox" id="c-39677342" checked=""/><div class="controls bullet"><span class="by">tripflag</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677219">parent</a><span>|</span><a href="#39677264">next</a><span>|</span><label class="collapse" for="c-39677342">[-]</label><label class="expand" for="c-39677342">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the correction -- it is likely that I did use count= when I ran into this some 10 years ago (and been paranoid about ever since). I thought a chunk of data was missing in the middle of the output file, causing everything after that to be shifted over, but I&#x27;m probably misremembering.</div><br/></div></div></div></div><div id="39677264" class="c"><input type="checkbox" id="c-39677264" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677059">parent</a><span>|</span><a href="#39677219">prev</a><span>|</span><a href="#39677363">next</a><span>|</span><label class="collapse" for="c-39677264">[-]</label><label class="expand" for="c-39677264">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t `nc -l -p 1234 &gt; &#x2F;dev&#x2F;nvme0nX` working by accident (relying on that netcat is buffering its output in multiples of disk block size)?</div><br/><div id="39677430" class="c"><input type="checkbox" id="c-39677430" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677264">parent</a><span>|</span><a href="#39677392">next</a><span>|</span><label class="collapse" for="c-39677430">[-]</label><label class="expand" for="c-39677430">[1 more]</label></div><br/><div class="children"><div class="content">No — the kernel buffers non-O_DIRECT writes to block devices to ensure correctness.<p>While not necessary when writing an appropriately-blocked disk image, even partial block overwrites work fine:<p><pre><code>  # yes | head -c 512 &gt; foo
  # losetup &#x2F;dev&#x2F;loop0 foo
  # echo foo &gt; &#x2F;dev&#x2F;loop0
  # hexdump -C &#x2F;dev&#x2F;loop0
  00000000  66 6f 6f 0a 79 0a 79 0a  79 0a 79 0a 79 0a 79 0a  |foo.y.y.y.y.y.y.|
  00000010  79 0a 79 0a 79 0a 79 0a  79 0a 79 0a 79 0a 79 0a  |y.y.y.y.y.y.y.y.|
  *
  00000200
</code></pre>
Larger writes will be more efficient, however, if only due to reduced system call overhead.</div><br/></div></div><div id="39677392" class="c"><input type="checkbox" id="c-39677392" checked=""/><div class="controls bullet"><span class="by">mrb</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677264">parent</a><span>|</span><a href="#39677430">prev</a><span>|</span><a href="#39677363">next</a><span>|</span><label class="collapse" for="c-39677392">[-]</label><label class="expand" for="c-39677392">[1 more]</label></div><br/><div class="children"><div class="content">This works reliably but is inefficient. For starters, the default block size in most netcat implementations is tiny like 4 kB or less. So there is a higher CPU and I&#x2F;O overhead. And if netcat does a partial or small read less than 4 kB, when it writes the partial block to the nvme disk, the kernel would take care of reading a full 4kB block from the nvme disk, updating it with the partial data block, and rewriting the full 4kB block to the disk. Very inefficient.</div><br/></div></div></div></div><div id="39677363" class="c"><input type="checkbox" id="c-39677363" checked=""/><div class="controls bullet"><span class="by">M95D</span><span>|</span><a href="#39676881">root</a><span>|</span><a href="#39677059">parent</a><span>|</span><a href="#39677264">prev</a><span>|</span><a href="#39677381">next</a><span>|</span><label class="collapse" for="c-39677363">[-]</label><label class="expand" for="c-39677363">[1 more]</label></div><br/><div class="children"><div class="content">I would include bs=1M and oflag=direct for some extra speed.</div><br/></div></div></div></div><div id="39677141" class="c"><input type="checkbox" id="c-39677141" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#39676881">parent</a><span>|</span><a href="#39677381">prev</a><span>|</span><a href="#39676905">next</a><span>|</span><label class="collapse" for="c-39677141">[-]</label><label class="expand" for="c-39677141">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there are zero benefits in using NVMe&#x2F;TCP, as he just ends up doing a serial block copy using dd(1) so he&#x27;s not leveraging concurrent I&#x2F;O<p>I guess most people don&#x27;t have faster local network than an SSD can transfer.<p>I wonder though, for those people who do, does a concurrent I&#x2F;O block device replicator tool exist?<p>Btw, you might want also use pv in the pipeline to see an ETA, although it might have a small impact on performance.</div><br/></div></div></div></div><div id="39676905" class="c"><input type="checkbox" id="c-39676905" checked=""/><div class="controls bullet"><span class="by">roomey</span><span>|</span><a href="#39676881">prev</a><span>|</span><a href="#39677387">next</a><span>|</span><label class="collapse" for="c-39676905">[-]</label><label class="expand" for="c-39676905">[3 more]</label></div><br/><div class="children"><div class="content">I recently had to set up a new laptop (xubuntu).<p>Previously I cloned but I this time I wanted to refresh some of the configs.<p>Using a usb-c cable to transfer at 10gb&#x2F;s is so useful (as my only other option was WiFi).<p>When you plug the computers together they form an ad-hoc network and you can just rsync across. As far as I could tell the link was saturated so using anything else (other protocols) would be pointless. Well not pointless, it&#x27;s really good to learn new stuff, maybe just not when you are cloning your laptop (joke)!</div><br/><div id="39677192" class="c"><input type="checkbox" id="c-39677192" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#39676905">parent</a><span>|</span><a href="#39677387">next</a><span>|</span><label class="collapse" for="c-39677192">[-]</label><label class="expand" for="c-39677192">[2 more]</label></div><br/><div class="children"><div class="content">Did it ‘just work’?<p>Serious question since last time I tried a direct non-Ethernet connection was sometime in the 90s ;)</div><br/><div id="39677262" class="c"><input type="checkbox" id="c-39677262" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39676905">root</a><span>|</span><a href="#39677192">parent</a><span>|</span><a href="#39677387">next</a><span>|</span><label class="collapse" for="c-39677262">[-]</label><label class="expand" for="c-39677262">[1 more]</label></div><br/><div class="children"><div class="content">I assume that those USB-C connectors were USB 4 or Thunderbolt, not USB 3.<p>With Thunderbolt and operating systems that support Ethernet over Thunderbolt, a virtual network adapter is automatically configured for any Thunderbolt connector, so connecting a USB C cable between 2 such computers should just work, as if they had Ethernet 10 Gb&#x2F;s connectors.<p>With USB 3 USB C connectors, you must use USB network adapters (up to 2.5 Gb&#x2F;s Ethernet).</div><br/></div></div></div></div></div></div><div id="39677387" class="c"><input type="checkbox" id="c-39677387" checked=""/><div class="controls bullet"><span class="by">M95D</span><span>|</span><a href="#39676905">prev</a><span>|</span><a href="#39677226">next</a><span>|</span><label class="collapse" for="c-39677387">[-]</label><label class="expand" for="c-39677387">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why he didn&#x27;t pipe btrfs through network. Do a btrfs snapshot first, then btrfs send =&gt; nc =&gt; network =&gt; nc =&gt; brtfs receive. That way only blocks in use are sent.</div><br/></div></div><div id="39677226" class="c"><input type="checkbox" id="c-39677226" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39677387">prev</a><span>|</span><a href="#39676912">next</a><span>|</span><label class="collapse" for="c-39677226">[-]</label><label class="expand" for="c-39677226">[1 more]</label></div><br/><div class="children"><div class="content">A lot of hassle compared to:<p><pre><code>  nbdkit file &#x2F;dev&#x2F;nvme0n1
  nbdcopy nbd:&#x2F;&#x2F;otherlaptop localfile</code></pre></div><br/></div></div><div id="39676912" class="c"><input type="checkbox" id="c-39676912" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#39677226">prev</a><span>|</span><a href="#39677462">next</a><span>|</span><label class="collapse" for="c-39676912">[-]</label><label class="expand" for="c-39676912">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure there are benefits to this approach, but I&#x27;ve transferred laptops before by launching an installer on both and then combining dd and nc on both ends. If I recall correctly, I also added gzip to the mix to make transferring large null sections faster.<p>With the author not having access to an ethernet port on the new laptop, I think my hacky approach might&#x27;ve even been faster because of the slight boost compression would&#x27;ve provided, given that the network speed is nowhere near the speed limit compression would add to a fast network link.</div><br/><div id="39677001" class="c"><input type="checkbox" id="c-39677001" checked=""/><div class="controls bullet"><span class="by">rincebrain</span><span>|</span><a href="#39676912">parent</a><span>|</span><a href="#39676923">next</a><span>|</span><label class="collapse" for="c-39677001">[-]</label><label class="expand" for="c-39677001">[1 more]</label></div><br/><div class="children"><div class="content">Well, if it&#x27;s whole-disk encrypted, unless they told LUKS to pass TRIM through, you&#x27;d not be getting anything but essentially random data for the way the author described it.</div><br/></div></div><div id="39676923" class="c"><input type="checkbox" id="c-39676923" checked=""/><div class="controls bullet"><span class="by">Moneysac</span><span>|</span><a href="#39676912">parent</a><span>|</span><a href="#39677001">prev</a><span>|</span><a href="#39677462">next</a><span>|</span><label class="collapse" for="c-39676923">[-]</label><label class="expand" for="c-39676923">[2 more]</label></div><br/><div class="children"><div class="content">could you explain how you do that exactly?</div><br/><div id="39676993" class="c"><input type="checkbox" id="c-39676993" checked=""/><div class="controls bullet"><span class="by">gouggoug</span><span>|</span><a href="#39676912">root</a><span>|</span><a href="#39676923">parent</a><span>|</span><a href="#39677462">next</a><span>|</span><label class="collapse" for="c-39676993">[-]</label><label class="expand" for="c-39676993">[1 more]</label></div><br/><div class="children"><div class="content">This comment explains it: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39676881">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39676881</a></div><br/></div></div></div></div></div></div><div id="39677462" class="c"><input type="checkbox" id="c-39677462" checked=""/><div class="controls bullet"><span class="by">ptman</span><span>|</span><a href="#39676912">prev</a><span>|</span><a href="#39676845">next</a><span>|</span><label class="collapse" for="c-39677462">[-]</label><label class="expand" for="c-39677462">[1 more]</label></div><br/><div class="children"><div class="content">Pipe with zstd (or similar)!</div><br/></div></div><div id="39676845" class="c"><input type="checkbox" id="c-39676845" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#39677462">prev</a><span>|</span><a href="#39677112">next</a><span>|</span><label class="collapse" for="c-39676845">[-]</label><label class="expand" for="c-39676845">[1 more]</label></div><br/><div class="children"><div class="content">Thanks AWS&#x2F;Annapurna&#x2F;Nitro&#x2F;Lightbits for bringing NVMe-over-TCP to Linux.<p><a href="https:&#x2F;&#x2F;www.techtarget.com&#x2F;searchstorage&#x2F;news&#x2F;252459311&#x2F;Lightbits-Labs-launches-TCP-based-NVMe-over-fabrics-storage" rel="nofollow">https:&#x2F;&#x2F;www.techtarget.com&#x2F;searchstorage&#x2F;news&#x2F;252459311&#x2F;Ligh...</a><p><i>&gt; The NVM Express consortium ratified NVMe&#x2F;TCP as a binding transport layer in November 2018. The standard evolved from a code base originally submitted to NVM Express by Lightbits&#x27; engineering team.</i><p><a href="https:&#x2F;&#x2F;www.lightbitslabs.com&#x2F;blog&#x2F;linux-distributions-nvme-support&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.lightbitslabs.com&#x2F;blog&#x2F;linux-distributions-nvme-...</a><p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id=3f2304f8c6d6ed97849057bd16fee99e434ca796" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div><div id="39677112" class="c"><input type="checkbox" id="c-39677112" checked=""/><div class="controls bullet"><span class="by">dmos62</span><span>|</span><a href="#39676845">prev</a><span>|</span><a href="#39676915">next</a><span>|</span><label class="collapse" for="c-39677112">[-]</label><label class="expand" for="c-39677112">[1 more]</label></div><br/><div class="children"><div class="content">I recently had to copy around 200gb of files over wifi. I used rsync to make sure a connection failure doesn&#x27;t mean I have to start over and so that nothing is lost, but it took at least 6 hours. I wonder what could I have done better.<p>Btw, what kinds of guarantees do you get with the dd method? Do you have to compare md5s of the resulting block level devices after?</div><br/></div></div><div id="39676906" class="c"><input type="checkbox" id="c-39676906" checked=""/><div class="controls bullet"><span class="by">Gabrys1</span><span>|</span><a href="#39676915">prev</a><span>|</span><a href="#39677076">next</a><span>|</span><label class="collapse" for="c-39676906">[-]</label><label class="expand" for="c-39676906">[1 more]</label></div><br/><div class="children"><div class="content">I usually set up an initial distro and then copy over my &#x2F;home. Later, I just need to install the debs I&#x27;m missing, but this has the benefit of not installing stuff I don&#x27;t need anymore.<p>That said, I didn&#x27;t know you could export NVMe over TCP like that, so still a nice read!</div><br/></div></div><div id="39677076" class="c"><input type="checkbox" id="c-39677076" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#39676906">prev</a><span>|</span><a href="#39677186">next</a><span>|</span><label class="collapse" for="c-39677076">[-]</label><label class="expand" for="c-39677076">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and I&#x27;m not so familiar with resizing LUKS.<p>LUKS2 does not care about the size of the disk. If it&#x27;s JSON header is present, it will by default treat the entire underlying block device as the LUKS encrypted volume&#x2F;partition (sans the header), unless specified otherwise on the commandline.</div><br/></div></div><div id="39677186" class="c"><input type="checkbox" id="c-39677186" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#39677076">prev</a><span>|</span><a href="#39676885">next</a><span>|</span><label class="collapse" for="c-39677186">[-]</label><label class="expand" for="c-39677186">[1 more]</label></div><br/><div class="children"><div class="content">If you directly connect devices over WiFi without an intermediate AP you should be able to double your transfer speed. In this scenario it might have been worth it.</div><br/></div></div><div id="39676885" class="c"><input type="checkbox" id="c-39676885" checked=""/><div class="controls bullet"><span class="by">wjnc</span><span>|</span><a href="#39677186">prev</a><span>|</span><a href="#39676895">next</a><span>|</span><label class="collapse" for="c-39676885">[-]</label><label class="expand" for="c-39676885">[8 more]</label></div><br/><div class="children"><div class="content">So this just bit for bit dumps a NVMe device to another location. That’s clear. So all encryption just is transferred and not touched. But doesn’t the next machine go into panic when you boot? There are probably many changes in the underlying machine? (Okay, now I read the other post. The author really knows the way. This is at least intermediate Linux.)</div><br/><div id="39676929" class="c"><input type="checkbox" id="c-39676929" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#39676885">parent</a><span>|</span><a href="#39676895">next</a><span>|</span><label class="collapse" for="c-39676929">[-]</label><label class="expand" for="c-39676929">[7 more]</label></div><br/><div class="children"><div class="content">A Linux install is often remarkably hardware agnostic.<p>Windows would panic, certainly (because so much drivers &amp; other state is persisted &amp; expected), but the Linux kernel when it boots kind of figures out afresh what the world is every time. That&#x27;s fine.<p>The main thing you ought to do is generate a new systemd&#x2F;dbus machine-id. But past this, I fairly frequently instantiate new systems by taking a btrfs snapshot of my current machine &amp; send that snapshot over to a new drive. Chroot onto that drive, and use bootctl to install systemd-boot, and then I have a second Linux is ready to go.</div><br/><div id="39676976" class="c"><input type="checkbox" id="c-39676976" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39676929">parent</a><span>|</span><a href="#39677140">next</a><span>|</span><label class="collapse" for="c-39676976">[-]</label><label class="expand" for="c-39676976">[2 more]</label></div><br/><div class="children"><div class="content">I expected Windows to panic as well but Win 10 handles it relatively gracefully. It says Windows detected a change to your hardware and does a relatively decent job.</div><br/><div id="39677018" class="c"><input type="checkbox" id="c-39677018" checked=""/><div class="controls bullet"><span class="by">netsharc</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39676976">parent</a><span>|</span><a href="#39677140">next</a><span>|</span><label class="collapse" for="c-39677018">[-]</label><label class="expand" for="c-39677018">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve done several such transplants of disks onto different hardware.. maybe even from an AMD to an Intel system once (different mainboard chipsets), and of Windows 7. As you say, it will say new hardware detected and a lot of the times will get the drivers for them from Windows Update. There are also 3rd party tools to remove no-longer existing devices from the registry, to clean the system up a bit.</div><br/></div></div></div></div><div id="39677140" class="c"><input type="checkbox" id="c-39677140" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39676929">parent</a><span>|</span><a href="#39676976">prev</a><span>|</span><a href="#39677021">next</a><span>|</span><label class="collapse" for="c-39677140">[-]</label><label class="expand" for="c-39677140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Windows would panic, certainly (because so much drivers &amp; other state is persisted &amp; expected)<p>Nope.<p>7B is because back in WinNT days it made sense to disable the drivers <i>for which there are no devices in the system</i>. Because memory and because people can&#x27;t write drivers.<p>Nowadays it&#x27;s AHCI or NVMe, which are pretty vendor agnostic, so you have 95% chance of successful boot. And if you boot is successful then Windows is fine and yes, it can grab the remaining drivers from the WU.</div><br/></div></div><div id="39677021" class="c"><input type="checkbox" id="c-39677021" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39676929">parent</a><span>|</span><a href="#39677140">prev</a><span>|</span><a href="#39676895">next</a><span>|</span><label class="collapse" for="c-39677021">[-]</label><label class="expand" for="c-39677021">[3 more]</label></div><br/><div class="children"><div class="content">If you moved the wrong stuff Linux would give you a bad time too, try &#x2F;proc, &#x2F;dev</div><br/><div id="39677198" class="c"><input type="checkbox" id="c-39677198" checked=""/><div class="controls bullet"><span class="by">fellerts</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39677021">parent</a><span>|</span><a href="#39676895">next</a><span>|</span><label class="collapse" for="c-39677198">[-]</label><label class="expand" for="c-39677198">[2 more]</label></div><br/><div class="children"><div class="content">Those are pseudo-filesystems though, they aren&#x27;t part of the install.</div><br/><div id="39677324" class="c"><input type="checkbox" id="c-39677324" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#39676885">root</a><span>|</span><a href="#39677198">parent</a><span>|</span><a href="#39676895">next</a><span>|</span><label class="collapse" for="c-39677324">[-]</label><label class="expand" for="c-39677324">[1 more]</label></div><br/><div class="children"><div class="content">Not sure where I said they were part of the install, but I meant that if you don’t exclude them bad things would happen to the cloning process<p>Edit: or backup process</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39677156" class="c"><input type="checkbox" id="c-39677156" checked=""/><div class="controls bullet"><span class="by">coretx</span><span>|</span><a href="#39676895">prev</a><span>|</span><a href="#39676909">next</a><span>|</span><label class="collapse" for="c-39677156">[-]</label><label class="expand" for="c-39677156">[2 more]</label></div><br/><div class="children"><div class="content">Doing this without systemd or directly from the netboot environment would be interesting.</div><br/><div id="39677168" class="c"><input type="checkbox" id="c-39677168" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39677156">parent</a><span>|</span><a href="#39676909">next</a><span>|</span><label class="collapse" for="c-39677168">[-]</label><label class="expand" for="c-39677168">[1 more]</label></div><br/><div class="children"><div class="content">The user didn&#x27;t do it from systemd actually. Instead they booted GRML, which is not very different from a netboot environment, and hand-exported the device themselves.</div><br/></div></div></div></div><div id="39676909" class="c"><input type="checkbox" id="c-39676909" checked=""/><div class="controls bullet"><span class="by">MeteorMarc</span><span>|</span><a href="#39677156">prev</a><span>|</span><a href="#39677169">next</a><span>|</span><label class="collapse" for="c-39676909">[-]</label><label class="expand" for="c-39676909">[3 more]</label></div><br/><div class="children"><div class="content">How can this
 work if the laptops have different hardware, cq different requirements on device drivers?</div><br/><div id="39677446" class="c"><input type="checkbox" id="c-39677446" checked=""/><div class="controls bullet"><span class="by">AndroTux</span><span>|</span><a href="#39676909">parent</a><span>|</span><a href="#39677013">next</a><span>|</span><label class="collapse" for="c-39677446">[-]</label><label class="expand" for="c-39677446">[1 more]</label></div><br/><div class="children"><div class="content">With modern systems this rarely is a problem. Like Andy said, Linux comes with most drivers in the kernel. Windows just installs the appropriate drivers as soon as you boot it up with new hardware. Sometimes it takes a minute or two for it to boot up after the initial swap, but then it should be fine.</div><br/></div></div><div id="39677013" class="c"><input type="checkbox" id="c-39677013" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#39676909">parent</a><span>|</span><a href="#39677446">prev</a><span>|</span><a href="#39677169">next</a><span>|</span><label class="collapse" for="c-39677013">[-]</label><label class="expand" for="c-39677013">[1 more]</label></div><br/><div class="children"><div class="content">Linux ships with all the drivers installed (for a fairly high value of &quot;all&quot;) (typically)</div><br/></div></div></div></div><div id="39677169" class="c"><input type="checkbox" id="c-39677169" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#39676909">prev</a><span>|</span><a href="#39676850">next</a><span>|</span><label class="collapse" for="c-39677169">[-]</label><label class="expand" for="c-39677169">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Since the new laptop didn&#x27;t have an Ethernet port, I had to rely only on WiFi, and it took about 7 and a half hours to copy the entire 512GB<p>That&#x27;s because bs=40M and no status=progress.</div><br/></div></div><div id="39676850" class="c"><input type="checkbox" id="c-39676850" checked=""/><div class="controls bullet"><span class="by">hcfman</span><span>|</span><a href="#39677169">prev</a><span>|</span><label class="collapse" for="c-39676850">[-]</label><label class="expand" for="c-39676850">[2 more]</label></div><br/><div class="children"><div class="content">Very nice read! I didn&#x27;t know it existed. Love it.</div><br/><div id="39676872" class="c"><input type="checkbox" id="c-39676872" checked=""/><div class="controls bullet"><span class="by">hcfman</span><span>|</span><a href="#39676850">parent</a><span>|</span><label class="collapse" for="c-39676872">[-]</label><label class="expand" for="c-39676872">[1 more]</label></div><br/><div class="children"><div class="content">I love your explanation of your disk install with cryptsetup etc. I do a manual install as well as I always install with both mirrored and encrypted disks. The combination of the two I didn&#x27;t find as easy install options (I think not at all) on the Ubuntu&#x27;s I installed. Good to see a lot of this low level OS talk here.</div><br/></div></div></div></div></div></div></div></div></div></body></html>