<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686733268785" as="style"/><link rel="stylesheet" href="styles.css?v=1686733268785"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://raphlinus.github.io/gpu/2023/06/12/shader-converter.html">Metal shader converter and the missing device-scoped barrier</a> <span class="domain">(<a href="https://raphlinus.github.io">raphlinus.github.io</a>)</span></div><div class="subtext"><span>raphlinus</span> | <span>19 comments</span></div><br/><div><div id="36322905" class="c"><input type="checkbox" id="c-36322905" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36317797">next</a><span>|</span><label class="collapse" for="c-36322905">[-]</label><label class="expand" for="c-36322905">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The Vulkan ecosystem is notorious for this: the extension list at vulkan.gpuinfo.org currently lists 146 extensions.<p>Proudly following up OpenGL spaghetti extension developer experience.<p>As mentioned at Vulkanised 2023, Khronos keeps pouring extensions at a rate no one is able to catch up with.<p>No wonder proprietary APIs keep being prefered by game studios, with their developer first tooling approach.</div><br/><div id="36323022" class="c"><input type="checkbox" id="c-36323022" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#36322905">parent</a><span>|</span><a href="#36317797">next</a><span>|</span><label class="collapse" for="c-36323022">[-]</label><label class="expand" for="c-36323022">[1 more]</label></div><br/><div class="children"><div class="content">Kronos can&#x27;t really do anything else since it is a consortium where hardware vendors take part in, who can block or outright ignore anything they don&#x27;t like. It&#x27;s Microsoft who can impose APIs and &quot;standards&quot; thanks to their market dominance.<p>Many extensions eventually become parts of a core profile. Some of then are clarifications or improvements to existing extensions. Many are APIs for proprietary features that never become part of any core profiles.</div><br/></div></div></div></div><div id="36317797" class="c"><input type="checkbox" id="c-36317797" checked=""/><div class="controls bullet"><span class="by">bronxbomber92</span><span>|</span><a href="#36322905">prev</a><span>|</span><a href="#36316988">next</a><span>|</span><label class="collapse" for="c-36317797">[-]</label><label class="expand" for="c-36317797">[3 more]</label></div><br/><div class="children"><div class="content">I believe this post is referring to device-scoped <i>memory</i> barriers - also sometimes called fences - as opposed to <i>execution</i> barriers.<p>The former being a mechanism to ensure memory accesses follow a well defined order (e.g. it&#x27;d be bad if the memory accesses executed inside a critical section could be reordered before or after the lock and unlock calls).<p>The latter being a mechanism that ensures all threads (within some scope, perhaps all threads running on the &quot;device&quot;) reach the same point in the program before any are allowed to proceed.</div><br/><div id="36323088" class="c"><input type="checkbox" id="c-36323088" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#36317797">parent</a><span>|</span><a href="#36317874">next</a><span>|</span><label class="collapse" for="c-36323088">[-]</label><label class="expand" for="c-36323088">[1 more]</label></div><br/><div class="children"><div class="content">The post also mentions unspecified behavior (mixing atomic and non-atomic memory accesses) where everybody has to cross their fingers and hope that the hardware designers had the same idea about how it should work. Which is almost fine with enough test coverage, but a shader translation layer adds uncomfortable complexity on top of it.</div><br/></div></div><div id="36317874" class="c"><input type="checkbox" id="c-36317874" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#36317797">parent</a><span>|</span><a href="#36323088">prev</a><span>|</span><a href="#36316988">next</a><span>|</span><label class="collapse" for="c-36317874">[-]</label><label class="expand" for="c-36317874">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s correct, it&#x27;s the <i>memory scope</i> that I expect to be device-scoped. GPUs tend not to have execution barriers in the shader language beyond workgroup scope; generally the next coarser granularity for synchronization is a separate dispatch. However, single-pass prefix sum algorithms, including decoupled look-back, can function just fine with device-scoped memory barriers, and do not require execution barriers with coarser scope than workgroup.</div><br/></div></div></div></div><div id="36316988" class="c"><input type="checkbox" id="c-36316988" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36317797">prev</a><span>|</span><a href="#36299207">next</a><span>|</span><label class="collapse" for="c-36316988">[-]</label><label class="expand" for="c-36316988">[4 more]</label></div><br/><div class="children"><div class="content">So how [well] does MoltenVK work? The prevailing attitude I&#x27;ve seen is basically &quot;just target vulkan for everything because it just works&quot; but I&#x27;m not sure how much experience is reflected in such claims.</div><br/><div id="36317836" class="c"><input type="checkbox" id="c-36317836" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#36316988">parent</a><span>|</span><a href="#36299207">next</a><span>|</span><label class="collapse" for="c-36317836">[-]</label><label class="expand" for="c-36317836">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re doing advanced compute work (including lock-free data structures), then it&#x27;s best effort.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;linebender&#x2F;vello&#x2F;issues&#x2F;42">https:&#x2F;&#x2F;github.com&#x2F;linebender&#x2F;vello&#x2F;issues&#x2F;42</a> is an issue from when Vello (then piet-gpu) had a single-pass prefix sum algorithm. Looking back, I&#x27;m fairly confident that it&#x27;s a shader translation issue and that it wouldn&#x27;t work with MoltenVK either, but we stopped investigating when we moved to a more robustly portable approach.</div><br/><div id="36320534" class="c"><input type="checkbox" id="c-36320534" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#36316988">root</a><span>|</span><a href="#36317836">parent</a><span>|</span><a href="#36299207">next</a><span>|</span><label class="collapse" for="c-36320534">[-]</label><label class="expand" for="c-36320534">[2 more]</label></div><br/><div class="children"><div class="content">So in general, am I right in assuming that any advanced compute work would be a no-go on Apple Silicon?<p>I am working on a 3D SDF renderer for games (fully compute driven), and my older PC is starting to croak. I was thinking of going Mac Studio 2, but if their GPU doesn&#x27;t support memory barriers and such (even though I am not using them yet), I guess it&#x27;s not worth the risk?</div><br/><div id="36320853" class="c"><input type="checkbox" id="c-36320853" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#36316988">root</a><span>|</span><a href="#36320534">parent</a><span>|</span><a href="#36299207">next</a><span>|</span><label class="collapse" for="c-36320853">[-]</label><label class="expand" for="c-36320853">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on your workload. Prefix sum is pretty important, but you can also work around the missing barrier by doing extra dispatches. You&#x27;ll want to do that if your goal is portable code. Metal also has some nice things, including real pointers (available in Vulkan 1.3 but not earlier versions, and not in HLSL).</div><br/></div></div></div></div></div></div></div></div><div id="36299207" class="c"><input type="checkbox" id="c-36299207" checked=""/><div class="controls bullet"><span class="by">richdodd</span><span>|</span><a href="#36316988">prev</a><span>|</span><a href="#36318368">next</a><span>|</span><label class="collapse" for="c-36299207">[-]</label><label class="expand" for="c-36299207">[5 more]</label></div><br/><div class="children"><div class="content">Does the M1&#x2F;M2 use ARM designs in the GPU as well as the CPU? If so, it might be possible to work out what could be implemented by looking at the [arm docs](<a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;102203&#x2F;0100&#x2F;Valhall-shader-core?lang=en" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;102203&#x2F;0100&#x2F;Valhall-...</a>).</div><br/><div id="36316838" class="c"><input type="checkbox" id="c-36316838" checked=""/><div class="controls bullet"><span class="by">DeRock</span><span>|</span><a href="#36299207">parent</a><span>|</span><a href="#36299409">next</a><span>|</span><label class="collapse" for="c-36316838">[-]</label><label class="expand" for="c-36316838">[1 more]</label></div><br/><div class="children"><div class="content">Apple doesn’t use ARM IP for either, and hasn’t for many years.</div><br/></div></div><div id="36299409" class="c"><input type="checkbox" id="c-36299409" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#36299207">parent</a><span>|</span><a href="#36316838">prev</a><span>|</span><a href="#36318576">next</a><span>|</span><label class="collapse" for="c-36299409">[-]</label><label class="expand" for="c-36299409">[1 more]</label></div><br/><div class="children"><div class="content">The most complete documentation is in the applegpu repo[1] by dougallj showing a great deal of recent activity (including by alyssarosenzweig). Last I checked, the documentation of barrier instructions wasn&#x27;t complete enough to tell whether these device-scoped barriers are possible. (Note: on RDNA2, they&#x27;re accomplished by DLC and GLC flags on memory accesses, combined with cache flush instructions such as S_GL1_INV).<p>There&#x27;s also a lot of great material, accessibly written, on Alyssa&#x27;s blog[2], see in particular the posts titled &quot;Dissecting the Apple M1 GPU, part ${I}&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dougallj&#x2F;applegpu">https:&#x2F;&#x2F;github.com&#x2F;dougallj&#x2F;applegpu</a><p>[2]: <a href="https:&#x2F;&#x2F;rosenzweig.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rosenzweig.io&#x2F;</a></div><br/></div></div><div id="36318576" class="c"><input type="checkbox" id="c-36318576" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#36299207">parent</a><span>|</span><a href="#36299409">prev</a><span>|</span><a href="#36299326">next</a><span>|</span><label class="collapse" for="c-36318576">[-]</label><label class="expand" for="c-36318576">[1 more]</label></div><br/><div class="children"><div class="content">No, they have a custom GPU design originally derived from Imagination Technologies PowerVR GPUs.</div><br/></div></div><div id="36299326" class="c"><input type="checkbox" id="c-36299326" checked=""/><div class="controls bullet"><span class="by">richdodd</span><span>|</span><a href="#36299207">parent</a><span>|</span><a href="#36318576">prev</a><span>|</span><a href="#36318368">next</a><span>|</span><label class="collapse" for="c-36299326">[-]</label><label class="expand" for="c-36299326">[1 more]</label></div><br/><div class="children"><div class="content">Hmm OK according to the doucmentation they designed the GPU themselves, so there&#x27;s no public information on them.</div><br/></div></div></div></div><div id="36318368" class="c"><input type="checkbox" id="c-36318368" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36299207">prev</a><span>|</span><a href="#36319530">next</a><span>|</span><label class="collapse" for="c-36318368">[-]</label><label class="expand" for="c-36318368">[2 more]</label></div><br/><div class="children"><div class="content">Apple having to Think Different mean we need about two more layers in portable games.</div><br/><div id="36322930" class="c"><input type="checkbox" id="c-36322930" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36318368">parent</a><span>|</span><a href="#36319530">next</a><span>|</span><label class="collapse" for="c-36322930">[-]</label><label class="expand" for="c-36322930">[1 more]</label></div><br/><div class="children"><div class="content">And Sony, Nintendo, Microsoft,...</div><br/></div></div></div></div><div id="36319530" class="c"><input type="checkbox" id="c-36319530" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36318368">prev</a><span>|</span><label class="collapse" for="c-36319530">[-]</label><label class="expand" for="c-36319530">[2 more]</label></div><br/><div class="children"><div class="content">While you&#x27;re here, I should ask: what do you think of my middle-ground proposal (<a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxzs1q&#x2F;note_on_metal_shader_converter" rel="nofollow noreferrer">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxzs1q&#x2F;note_on_metal_shader_converter</a>) that the interface contain a black-box scan primitive, rather than stronger low-level guarantees?</div><br/><div id="36320305" class="c"><input type="checkbox" id="c-36320305" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#36319530">parent</a><span>|</span><label class="collapse" for="c-36320305">[-]</label><label class="expand" for="c-36320305">[1 more]</label></div><br/><div class="children"><div class="content">My personal feeling is that higher level layers should be built on top of strong lower level layers, and we don&#x27;t have that yet. Scan is of course useful, and there are a ton of them in Vello, but there are other things that are somewhat scan-like but use low-level primitives in a different way, like my stack monoid work.<p>Out of scope for this blog post, but I also believe there is tremendous potential for hardware that broadly resembles existing GPUs (same register layout, instruction scheduling, memory hierarchy) but with fewer limitations and performance problems. For example, the queue that&#x27;s currently hardcoded between vertex and fragment shaders could be exposed as a general purpose queue primitive, allowing more dynamic scheduling of multiple different kernels in parallel. I haven&#x27;t done a deep enough dive into hardware to make concrete proposals, but as I explore, I get more and more indications that what we have access to is a fairly limited subset of what&#x27;s possible.</div><br/></div></div></div></div></div></div></div></div></div></body></html>