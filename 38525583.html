<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701766854762" as="style"/><link rel="stylesheet" href="styles.css?v=1701766854762"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions (2020)</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nic_wilson</span> | <span>63 comments</span></div><br/><div><div id="38525972" class="c"><input type="checkbox" id="c-38525972" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#38526167">next</a><span>|</span><label class="collapse" for="c-38525972">[-]</label><label class="expand" for="c-38525972">[25 more]</label></div><br/><div class="children"><div class="content">How I bail myself out of Rust lifetime problems as somebody who probably learned Rust the wrong way (by just trying to build stuff as if it were C&#x2F;node.js and run into problems instead of slowing down + reading):<p>1. .clone() &#x2F; .to_owned()<p>1. String -&gt; vs &amp;String&#x2F;&amp;str with &amp; borrow<p>1. lazy_static &#x2F; OnceCell + Lazy &#x2F; OnceLock<p>1. Arc&lt;Mutex&lt;T&gt;&gt; with lots of .lock(). What would start off as like NULL in Java&#x2F;C is Arc&lt;Mutex&lt;Option&lt;T&gt;&gt;&gt; and you have to check if it is .is_none()<p>I think that&#x27;s about it. I rarely introduce a lifetime to a struct&#x2F;impl. I try to avoid it honestly (probably for worse). Arc kind of bails you out of a lot (whether that&#x27;s for good or not I don&#x27;t know).<p>edit: Remembered another. I think it&#x27;s kind of weird&#x2F;too verbose from the compiler &#x2F; borrow checker when you have a primitive like u32 and it&#x27;s borrowed and you had to dereference it or clone it.</div><br/><div id="38527383" class="c"><input type="checkbox" id="c-38527383" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526089">next</a><span>|</span><label class="collapse" for="c-38527383">[-]</label><label class="expand" for="c-38527383">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  who probably learned Rust the wrong way (by just trying to build stuff as if it were C&#x2F;node.js and run into problems instead of slowing down + reading):<p>This is the right way to learn. I&#x27;m quite familiar with lifetimes and whatnot, but when I didn&#x27;t bother with them much at all when learning - I just &quot;clone&quot;&#x27;d.<p>This allowed me to learn 95% of the language, and then once I did that, learn the last 5% (lifetimes).<p>Highly recommend.</div><br/></div></div><div id="38526089" class="c"><input type="checkbox" id="c-38526089" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38527383">prev</a><span>|</span><a href="#38526149">next</a><span>|</span><label class="collapse" for="c-38526089">[-]</label><label class="expand" for="c-38526089">[2 more]</label></div><br/><div class="children"><div class="content">This is how my team writes production Rust code. Knowing which one to use and when is important, but there&#x27;s nothing wrong with using the tools available to you.<p>Non-lexical lifetimes are, in my experience, pretty uncommon in most non-library code. You don&#x27;t really need them until you <i>really</i> need them.</div><br/><div id="38527366" class="c"><input type="checkbox" id="c-38527366" checked=""/><div class="controls bullet"><span class="by">inejge</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526089">parent</a><span>|</span><a href="#38526149">next</a><span>|</span><label class="collapse" for="c-38527366">[-]</label><label class="expand" for="c-38527366">[1 more]</label></div><br/><div class="children"><div class="content"><i>Non-lexical lifetimes are, in my experience, pretty uncommon in most non-library code.</i><p>To avoid confusing the newcomers: lifetimes are <i>always</i> non-lexical (see [1] for the pedantic details.) I suppose you meant that explicit lifetime <i>annotations</i> are pretty uncommon, which is not wrong.<p>[1] <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2022&#x2F;08&#x2F;05&#x2F;nll-by-default.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2022&#x2F;08&#x2F;05&#x2F;nll-by-default.html</a></div><br/></div></div></div></div><div id="38526149" class="c"><input type="checkbox" id="c-38526149" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526089">prev</a><span>|</span><a href="#38526117">next</a><span>|</span><label class="collapse" for="c-38526149">[-]</label><label class="expand" for="c-38526149">[8 more]</label></div><br/><div class="children"><div class="content">Good advice, though I&#x27;d recommend Rc&lt;RefCell&lt;T&gt;&gt; instead of Arc&lt;Mutex&lt;T&gt;&gt; if you&#x27;re not sharing the data between threads, to avoid synchronization overhead. I use Arc pretty rarely.</div><br/><div id="38527275" class="c"><input type="checkbox" id="c-38527275" checked=""/><div class="controls bullet"><span class="by">gnulinux</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526149">parent</a><span>|</span><a href="#38526288">next</a><span>|</span><label class="collapse" for="c-38527275">[-]</label><label class="expand" for="c-38527275">[4 more]</label></div><br/><div class="children"><div class="content">The overhead of an uncontested lock is not much more than a memory operation but it allows you to be able to use the same code in threaded context in tokio async which is a huge benefit. Unless you need the optimization (i.e. you profiled and determined that Arc in a hot loop is slowing you down) I think it&#x27;s <i>fine</i> to use Arc in general.</div><br/><div id="38527830" class="c"><input type="checkbox" id="c-38527830" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527275">parent</a><span>|</span><a href="#38527324">next</a><span>|</span><label class="collapse" for="c-38527830">[-]</label><label class="expand" for="c-38527830">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The overhead of an uncontested lock is not much more than a memory operation<p>An <i>atomic</i> memory operation! These can be orders of magnitude slower than regular memory operations.</div><br/><div id="38528148" class="c"><input type="checkbox" id="c-38528148" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527830">parent</a><span>|</span><a href="#38527324">next</a><span>|</span><label class="collapse" for="c-38528148">[-]</label><label class="expand" for="c-38528148">[1 more]</label></div><br/><div class="children"><div class="content">An <i>atomic read-modify-write</i>. Atomic non-seq-cst load&#x2F;stores can be cheap.<p>&#x2F;Overly pedantic</div><br/></div></div></div></div><div id="38527324" class="c"><input type="checkbox" id="c-38527324" checked=""/><div class="controls bullet"><span class="by">afdbcreid</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527275">parent</a><span>|</span><a href="#38527830">prev</a><span>|</span><a href="#38526288">next</a><span>|</span><label class="collapse" for="c-38527324">[-]</label><label class="expand" for="c-38527324">[1 more]</label></div><br/><div class="children"><div class="content">`RefCell` does have one big advantage, though: it&#x27;ll panic instead of deadlock for reentrant borrow.</div><br/></div></div></div></div><div id="38526288" class="c"><input type="checkbox" id="c-38526288" checked=""/><div class="controls bullet"><span class="by">jlffwoymasdf</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526149">parent</a><span>|</span><a href="#38527275">prev</a><span>|</span><a href="#38526372">next</a><span>|</span><label class="collapse" for="c-38526288">[-]</label><label class="expand" for="c-38526288">[2 more]</label></div><br/><div class="children"><div class="content">tokio is so wide spread now such that Arc&lt;Mutex&lt;T&gt;&gt; is coincidentally the right choice.<p>I&#x27;m not saying that&#x27;s a good thing.</div><br/><div id="38528298" class="c"><input type="checkbox" id="c-38528298" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526288">parent</a><span>|</span><a href="#38526372">next</a><span>|</span><label class="collapse" for="c-38528298">[-]</label><label class="expand" for="c-38528298">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t tokio have a single-threaded runtime where that&#x27;s not needed?</div><br/></div></div></div></div><div id="38526372" class="c"><input type="checkbox" id="c-38526372" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526149">parent</a><span>|</span><a href="#38526288">prev</a><span>|</span><a href="#38526117">next</a><span>|</span><label class="collapse" for="c-38526372">[-]</label><label class="expand" for="c-38526372">[1 more]</label></div><br/><div class="children"><div class="content">Eh, I don&#x27;t think the overhead of an uncontested lock acquire is all that much.</div><br/></div></div></div></div><div id="38526117" class="c"><input type="checkbox" id="c-38526117" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526149">prev</a><span>|</span><a href="#38527017">next</a><span>|</span><label class="collapse" for="c-38526117">[-]</label><label class="expand" for="c-38526117">[4 more]</label></div><br/><div class="children"><div class="content">Using `clone` etc when it&#x27;s easier is actually common advice, it&#x27;s perfectly OK to not have borrowing everywhere if you don&#x27;t need it. My usual starting point &#x2F; default &#x2F; rule of thumb is to take references as parameters and return owned values (for example, take `&amp;str` as an argument, return an owned `String`).</div><br/><div id="38526377" class="c"><input type="checkbox" id="c-38526377" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526117">parent</a><span>|</span><a href="#38527017">next</a><span>|</span><label class="collapse" for="c-38526377">[-]</label><label class="expand" for="c-38526377">[3 more]</label></div><br/><div class="children"><div class="content">IMO stringy data is a good example of where you should think about what you&#x27;re returning in part because common APIs (e.g. regex) will take a more nuanced approach.<p>If you&#x27;re creating a new string, then sure return String.  But if you have a path where you could just return the original input, consider returning a Cow&lt;str&gt;.</div><br/><div id="38527057" class="c"><input type="checkbox" id="c-38527057" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526377">parent</a><span>|</span><a href="#38527017">next</a><span>|</span><label class="collapse" for="c-38527057">[-]</label><label class="expand" for="c-38527057">[2 more]</label></div><br/><div class="children"><div class="content">burntsushi actually regrets making regex replace return a Cow&lt;str&gt;: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;regex&#x2F;issues&#x2F;676#issuecomment-626825009">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;regex&#x2F;issues&#x2F;676#issuecomment-6...</a>. I’m glad it does, and wish it <i>took</i> an impl Into&lt;Cow&lt;str&gt;&gt; there, for the reasons discussed in the issue, but burntsushi has a lot more experience of the <i>practical outcomes</i> of this. Just something more to think about.</div><br/><div id="38527574" class="c"><input type="checkbox" id="c-38527574" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527057">parent</a><span>|</span><a href="#38527017">next</a><span>|</span><label class="collapse" for="c-38527574">[-]</label><label class="expand" for="c-38527574">[1 more]</label></div><br/><div class="children"><div class="content">So from reading those comments, I&#x27;d come to the opposite conclusion: Cow&lt;str&gt; is absolutely the right choice and perhaps String should really have been Cow&lt;str&gt;.<p>Insofar as taking an impl into, burntsushi linked to a rust playground demonstrating where that approach falls down.  In general (heh) taking arguments , especially options or stringy ones, that are generalized over an into impl is one of those things that seems real nice at first but gets real unpleasant pretty quick IMO.</div><br/></div></div></div></div></div></div></div></div><div id="38527017" class="c"><input type="checkbox" id="c-38527017" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526117">prev</a><span>|</span><a href="#38526558">next</a><span>|</span><label class="collapse" for="c-38527017">[-]</label><label class="expand" for="c-38527017">[2 more]</label></div><br/><div class="children"><div class="content">I know there was a thread involving a rust team member saying that clone &#x2F; to_owned is ok to start with
The memory copying just nags and distracts me from moving on</div><br/><div id="38527090" class="c"><input type="checkbox" id="c-38527090" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527017">parent</a><span>|</span><a href="#38526558">next</a><span>|</span><label class="collapse" for="c-38527090">[-]</label><label class="expand" for="c-38527090">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure everyone in the teams would endorse that statement :)</div><br/></div></div></div></div><div id="38526558" class="c"><input type="checkbox" id="c-38526558" checked=""/><div class="controls bullet"><span class="by">farmeroy</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38527017">prev</a><span>|</span><a href="#38526330">next</a><span>|</span><label class="collapse" for="c-38526558">[-]</label><label class="expand" for="c-38526558">[1 more]</label></div><br/><div class="children"><div class="content">Once I started taking this advice, Rust became manageable to me! Currently, Trait Implementations have been more of a stumbling block for me than the borrow checker</div><br/></div></div><div id="38526330" class="c"><input type="checkbox" id="c-38526330" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526558">prev</a><span>|</span><a href="#38526125">next</a><span>|</span><label class="collapse" for="c-38526330">[-]</label><label class="expand" for="c-38526330">[4 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a lot to be gained by <i>not</i> writing Rust like C, to the extent that it might be worth taking some time to pick up another language (maybe a lisp variant?) first.<p>2.) Be careful because &amp;String is not &amp;str, although in many cases you can pretend thanks to magic of AsRef&#x2F;AsDeref.<p>4.) If you find yourself calling is_none, rethink things a bit.  Pattern matching and the various destructuring (e.g. if let) features are some of the most powerful tools at your disposal with Rust.  This is where experience with something else first (e.g. Elixir) can be helpful.<p><pre><code>  I rarely introduce a lifetime to a struct&#x2F;impl.
</code></pre>
IMO the big use case here is &amp;str.<p><pre><code>  Arc kind of bails you out of a lot
</code></pre>
While that&#x27;s totally reasonable it&#x27;s good to remember that you&#x27;re essentially trading compile time guarantees for runtime ones.  If you can figure out how to beat the borrow checker into submission that&#x27;s one less thing to debug at runtime.<p><pre><code>  primitive like u32 and it&#x27;s borrowed and you had to dereference it or clone it.
</code></pre>
The primitive types should all implement Copy which means you should (almost?) never have to explicitly clone them.  Dereferencing is another story tho.</div><br/><div id="38526526" class="c"><input type="checkbox" id="c-38526526" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526330">parent</a><span>|</span><a href="#38526125">next</a><span>|</span><label class="collapse" for="c-38526526">[-]</label><label class="expand" for="c-38526526">[3 more]</label></div><br/><div class="children"><div class="content">&gt; maybe a lisp variant?<p>Nah, go with an ML-family language. Maybe even Standard ML, because it will nudge you away from writing &quot;C in ML&quot; and encourage you to pick up the idiomatic way of doing things. (Laurence Paulson&#x27;s book has an online version available for free on his homepage).</div><br/><div id="38527405" class="c"><input type="checkbox" id="c-38527405" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38526526">parent</a><span>|</span><a href="#38526125">next</a><span>|</span><label class="collapse" for="c-38527405">[-]</label><label class="expand" for="c-38527405">[2 more]</label></div><br/><div class="children"><div class="content">SML is great, but I always suggest OCaml. Still my favourite language that I never get to write these days!</div><br/><div id="38527802" class="c"><input type="checkbox" id="c-38527802" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38525972">root</a><span>|</span><a href="#38527405">parent</a><span>|</span><a href="#38526125">next</a><span>|</span><label class="collapse" for="c-38527802">[-]</label><label class="expand" for="c-38527802">[1 more]</label></div><br/><div class="children"><div class="content">For practical programming I&#x27;d probably agree, but if the point is to learn a non-Algol way of thinking then I think SML is a better way to go; OCaml makes it easier to write imperative-style code, for better and for worse.</div><br/></div></div></div></div></div></div></div></div><div id="38526125" class="c"><input type="checkbox" id="c-38526125" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526330">prev</a><span>|</span><a href="#38527303">next</a><span>|</span><label class="collapse" for="c-38526125">[-]</label><label class="expand" for="c-38526125">[1 more]</label></div><br/><div class="children"><div class="content">For the edit: if you have an idea what the output should look like instead, please file a ticket.</div><br/></div></div><div id="38527303" class="c"><input type="checkbox" id="c-38527303" checked=""/><div class="controls bullet"><span class="by">outside1234</span><span>|</span><a href="#38525972">parent</a><span>|</span><a href="#38526125">prev</a><span>|</span><a href="#38526167">next</a><span>|</span><label class="collapse" for="c-38527303">[-]</label><label class="expand" for="c-38527303">[1 more]</label></div><br/><div class="children"><div class="content">This is the way.  The real misconception of lifetimes is that people have to use them often.  You don’t unless your are writing libraries or system code.</div><br/></div></div></div></div><div id="38526167" class="c"><input type="checkbox" id="c-38526167" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38525972">prev</a><span>|</span><a href="#38526029">next</a><span>|</span><label class="collapse" for="c-38526167">[-]</label><label class="expand" for="c-38526167">[5 more]</label></div><br/><div class="children"><div class="content">I just clone everywhere and write Rust like a high level language. Then, once I need to optimize more, if I ever do (as Rust is many times faster than other languages even with liberal cloning), then I simply go through and remove the clone where needed.</div><br/><div id="38527996" class="c"><input type="checkbox" id="c-38527996" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38526167">parent</a><span>|</span><a href="#38526593">next</a><span>|</span><label class="collapse" for="c-38527996">[-]</label><label class="expand" for="c-38527996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as Rust is many times faster than other languages even with liberal cloning<p>Have you really compared? I have. Rust was faster for &quot;small input&quot;, but quickly got beaten by Java and other languages I tried because the cost of doing things this way grows exponentially. I suggest you run benchmarks before you make your mind up and start throwing opinions around.</div><br/></div></div><div id="38526593" class="c"><input type="checkbox" id="c-38526593" checked=""/><div class="controls bullet"><span class="by">farmeroy</span><span>|</span><a href="#38526167">parent</a><span>|</span><a href="#38527996">prev</a><span>|</span><a href="#38526318">next</a><span>|</span><label class="collapse" for="c-38526593">[-]</label><label class="expand" for="c-38526593">[2 more]</label></div><br/><div class="children"><div class="content">Me too. I also do this with .unwrap() - when I&#x27;m pretty sure of the happy path - while I&#x27;m prototyping. It&#x27;s pretty easy afterwards to run back through and replace .unwrap() calls with better error handling. But as I improve, I&#x27;m getting more in the habit of using matching directly. Understanding lifetimes is probably really helpful for understanding library errors though and I need to go deeper there for sure</div><br/><div id="38527679" class="c"><input type="checkbox" id="c-38527679" checked=""/><div class="controls bullet"><span class="by">gruelsandwich</span><span>|</span><a href="#38526167">root</a><span>|</span><a href="#38526593">parent</a><span>|</span><a href="#38526318">next</a><span>|</span><label class="collapse" for="c-38527679">[-]</label><label class="expand" for="c-38527679">[1 more]</label></div><br/><div class="children"><div class="content">This is what I love about Rust, and other languages with these kinds of constructs. You <i>have to</i> acknowledge that something might e.g. fail. You can choose to do &quot;nothing&quot; (e.g. unwrap), but it must be done explicitly, which makes the ignored cases simple to identify later</div><br/></div></div></div></div><div id="38526318" class="c"><input type="checkbox" id="c-38526318" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#38526167">parent</a><span>|</span><a href="#38526593">prev</a><span>|</span><a href="#38526029">next</a><span>|</span><label class="collapse" for="c-38526318">[-]</label><label class="expand" for="c-38526318">[1 more]</label></div><br/><div class="children"><div class="content">Another technique for dodging [manual] lifetimes is not store references in struct fields etc.</div><br/></div></div></div></div><div id="38526029" class="c"><input type="checkbox" id="c-38526029" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38526167">prev</a><span>|</span><a href="#38526436">next</a><span>|</span><label class="collapse" for="c-38526029">[-]</label><label class="expand" for="c-38526029">[1 more]</label></div><br/><div class="children"><div class="content">Other tips for understanding Rust lifetime issues:<p>- Enable rust-analyzer inlay hints for elided lifetimes, reborrows, etc<p>- Enable the `elided_lifetimes_in_paths` lint<p>Together, these should ensure that all lifetimes in your code are clearly visible on the screen.</div><br/></div></div><div id="38526436" class="c"><input type="checkbox" id="c-38526436" checked=""/><div class="controls bullet"><span class="by">gadmm</span><span>|</span><a href="#38526029">prev</a><span>|</span><a href="#38525987">next</a><span>|</span><label class="collapse" for="c-38526436">[-]</label><label class="expand" for="c-38526436">[1 more]</label></div><br/><div class="children"><div class="content">#9 (downgrading mut refs to shared refs) is a big one. It makes things quite a bit more complicated in the context of our work on the OCaml-Rust interface (more precisely the safe interface for the GC). As I understand it, this is not a sacrifice we make at the &quot;Altar of Memory Safety&quot;, but one we make at the Altar of Mutex::get_mut and Cell::get_mut, which is a much smaller altar (how often do you find yourself in possession precisely of a mutable borrow of a Mutex or of a Cell?).</div><br/></div></div><div id="38525987" class="c"><input type="checkbox" id="c-38525987" checked=""/><div class="controls bullet"><span class="by">almost_usual</span><span>|</span><a href="#38526436">prev</a><span>|</span><a href="#38526736">next</a><span>|</span><label class="collapse" for="c-38525987">[-]</label><label class="expand" for="c-38525987">[10 more]</label></div><br/><div class="children"><div class="content">Once I discovered ‘static was the subtype of all lifetimes rather than the super things began clicking for me.</div><br/><div id="38526649" class="c"><input type="checkbox" id="c-38526649" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#38525987">parent</a><span>|</span><a href="#38526599">next</a><span>|</span><label class="collapse" for="c-38526649">[-]</label><label class="expand" for="c-38526649">[6 more]</label></div><br/><div class="children"><div class="content">`static is actually the superlifetime of all lifetimes, but &amp; is contravariant in its lifetime parameter (and covariant in its type parameter).</div><br/><div id="38526903" class="c"><input type="checkbox" id="c-38526903" checked=""/><div class="controls bullet"><span class="by">almost_usual</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526649">parent</a><span>|</span><a href="#38527451">next</a><span>|</span><label class="collapse" for="c-38526903">[-]</label><label class="expand" for="c-38526903">[4 more]</label></div><br/><div class="children"><div class="content">Mind expanding on this? The nomicon describes &amp;’a T where both ‘a’ and ‘T’ are covariant. I thought I had a clear picture but now I’m confused.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;subtyping.html#variance" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;subtyping.html#variance</a></div><br/><div id="38526991" class="c"><input type="checkbox" id="c-38526991" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526903">parent</a><span>|</span><a href="#38527462">next</a><span>|</span><label class="collapse" for="c-38526991">[-]</label><label class="expand" for="c-38526991">[2 more]</label></div><br/><div class="children"><div class="content">Here is the original GitHub issue on the question:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;15699">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;15699</a><p>And an RFC by some people that felt frustrated by this arguably implementation-centric view that kind of lost steam:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;391">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;391</a><p>Intuitively, the bottom lifetime should the one that is uninhabited, which would be a lifetime with no extent rather than &#x27;static.</div><br/><div id="38527292" class="c"><input type="checkbox" id="c-38527292" checked=""/><div class="controls bullet"><span class="by">almost_usual</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526991">parent</a><span>|</span><a href="#38527462">next</a><span>|</span><label class="collapse" for="c-38527292">[-]</label><label class="expand" for="c-38527292">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, thanks for sharing!</div><br/></div></div></div></div><div id="38527462" class="c"><input type="checkbox" id="c-38527462" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526903">parent</a><span>|</span><a href="#38526991">prev</a><span>|</span><a href="#38527451">next</a><span>|</span><label class="collapse" for="c-38527462">[-]</label><label class="expand" for="c-38527462">[1 more]</label></div><br/><div class="children"><div class="content">`rustc` used to use different terminology than the nomicom, but this is no longer the case: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;107339">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;107339</a></div><br/></div></div></div></div><div id="38527451" class="c"><input type="checkbox" id="c-38527451" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526649">parent</a><span>|</span><a href="#38526903">prev</a><span>|</span><a href="#38526599">next</a><span>|</span><label class="collapse" for="c-38527451">[-]</label><label class="expand" for="c-38527451">[1 more]</label></div><br/><div class="children"><div class="content">This is not true anymore: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;107339">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;107339</a></div><br/></div></div></div></div><div id="38526599" class="c"><input type="checkbox" id="c-38526599" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#38525987">parent</a><span>|</span><a href="#38526649">prev</a><span>|</span><a href="#38526736">next</a><span>|</span><label class="collapse" for="c-38526599">[-]</label><label class="expand" for="c-38526599">[3 more]</label></div><br/><div class="children"><div class="content">Could you elaborate? I find this unintuitive.</div><br/><div id="38526638" class="c"><input type="checkbox" id="c-38526638" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526599">parent</a><span>|</span><a href="#38527246">next</a><span>|</span><label class="collapse" for="c-38526638">[-]</label><label class="expand" for="c-38526638">[1 more]</label></div><br/><div class="children"><div class="content">Since static lifetimes last for the entirety of the program, it can sub in for any other lifetime (as it is guaranteed to exist until the end of the other lifetime)</div><br/></div></div><div id="38527246" class="c"><input type="checkbox" id="c-38527246" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#38525987">root</a><span>|</span><a href="#38526599">parent</a><span>|</span><a href="#38526638">prev</a><span>|</span><a href="#38526736">next</a><span>|</span><label class="collapse" for="c-38527246">[-]</label><label class="expand" for="c-38527246">[1 more]</label></div><br/><div class="children"><div class="content">I am not familiar with the formal type theory, but this one is intuitive if you view it this way:<p>1. When A is a subtype of B, it means A can be used as B (a Teacher can be used by any function that accepts a Human).<p>2. static lifetime lives longer any other lifetimes, so it can be used as other lifetimes.</div><br/></div></div></div></div></div></div><div id="38526736" class="c"><input type="checkbox" id="c-38526736" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#38525987">prev</a><span>|</span><a href="#38527414">next</a><span>|</span><label class="collapse" for="c-38526736">[-]</label><label class="expand" for="c-38526736">[4 more]</label></div><br/><div class="children"><div class="content">Incredible. I never held the quoted misconception about `T: &#x27;*`, but I didn&#x27;t understand it. It was a known unknown - I simply applied it when told to do so. This is the first time someone has explained it an understandable way, I guess the implications (it&#x27;s a ref of that lifetime or an owned) are a better explanation than the technical (T is bounded by the lifetime).</div><br/><div id="38526755" class="c"><input type="checkbox" id="c-38526755" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#38526736">parent</a><span>|</span><a href="#38527249">next</a><span>|</span><label class="collapse" for="c-38526755">[-]</label><label class="expand" for="c-38526755">[2 more]</label></div><br/><div class="children"><div class="content">“Applied it when told to do so.”<p>This is my beginner-level experience with Rust. It’s amazing that the compiler can be so specific about what’s wrong. But taking the error and getting explanations that even I can understand has been tricky.</div><br/><div id="38526811" class="c"><input type="checkbox" id="c-38526811" checked=""/><div class="controls bullet"><span class="by">qup</span><span>|</span><a href="#38526736">root</a><span>|</span><a href="#38526755">parent</a><span>|</span><a href="#38527249">next</a><span>|</span><label class="collapse" for="c-38526811">[-]</label><label class="expand" for="c-38526811">[1 more]</label></div><br/><div class="children"><div class="content">This is the kind of thing I like to ask GPT4. It can usually explain what&#x27;s going on.<p>Asking different ways usually leads me to understanding it well.</div><br/></div></div></div></div><div id="38527249" class="c"><input type="checkbox" id="c-38527249" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#38526736">parent</a><span>|</span><a href="#38526755">prev</a><span>|</span><a href="#38527414">next</a><span>|</span><label class="collapse" for="c-38527249">[-]</label><label class="expand" for="c-38527249">[1 more]</label></div><br/><div class="children"><div class="content">Same. I wrote a lot of Rust, even some open source libraries that are being used and generally feel comfortable using it but I learned a lot out of this very nice write-up.</div><br/></div></div></div></div><div id="38527414" class="c"><input type="checkbox" id="c-38527414" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38526736">prev</a><span>|</span><a href="#38526186">next</a><span>|</span><label class="collapse" for="c-38527414">[-]</label><label class="expand" for="c-38527414">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>Common Rust Lifetime Misconceptions</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23279731">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23279731</a> - May 2020 (43 comments)</div><br/></div></div><div id="38526186" class="c"><input type="checkbox" id="c-38526186" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#38527414">prev</a><span>|</span><a href="#38526154">next</a><span>|</span><label class="collapse" for="c-38526186">[-]</label><label class="expand" for="c-38526186">[8 more]</label></div><br/><div class="children"><div class="content">About #10:<p>&gt; because to unify them at this point would be a breaking change<p>Couldn&#x27;t they change this in a future edition without breaking older editions?</div><br/><div id="38526448" class="c"><input type="checkbox" id="c-38526448" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#38526186">parent</a><span>|</span><a href="#38526429">next</a><span>|</span><label class="collapse" for="c-38526448">[-]</label><label class="expand" for="c-38526448">[1 more]</label></div><br/><div class="children"><div class="content">A new edition is not a free pass to break source compatibility; it&#x27;s more like a fire axe hidden behind breakable glass. You really, really want to avoid breaking changes because your users will now have to know about the difference between the compiler editions used by each of their projects.<p>In short, yes, but be very wary.</div><br/></div></div><div id="38526429" class="c"><input type="checkbox" id="c-38526429" checked=""/><div class="controls bullet"><span class="by">BD103</span><span>|</span><a href="#38526186">parent</a><span>|</span><a href="#38526448">prev</a><span>|</span><a href="#38527207">next</a><span>|</span><label class="collapse" for="c-38526429">[-]</label><label class="expand" for="c-38526429">[2 more]</label></div><br/><div class="children"><div class="content">Technically yes, but editions are more like different &quot;flavors&quot; of Rust than actual breaking changes. A 2021 crate is supposed to be able to import a 2018 crate, likewise for 2015 and 2024. Because they all need to work together, edition changes still need to be somewhat compatible with older versions.<p>Because you can pass closures into functions across crate boundaries, which requires consistent lifetime semantics, I find it unlikely that this will be implemented.</div><br/><div id="38527371" class="c"><input type="checkbox" id="c-38527371" checked=""/><div class="controls bullet"><span class="by">afdbcreid</span><span>|</span><a href="#38526186">root</a><span>|</span><a href="#38526429">parent</a><span>|</span><a href="#38527207">next</a><span>|</span><label class="collapse" for="c-38527371">[-]</label><label class="expand" for="c-38527371">[1 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, this change is compatible with other editions. Closures can already be higher-ranked, and changing closures to be higher-ranked will work with existing editions.<p>A more problematic thing is that `cargo fix --edition` should be able to transform existing code to the same meaning in a new edition, so there should be a way to opt-in for the old behavior.</div><br/></div></div></div></div><div id="38527207" class="c"><input type="checkbox" id="c-38527207" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#38526186">parent</a><span>|</span><a href="#38526429">prev</a><span>|</span><a href="#38526646">next</a><span>|</span><label class="collapse" for="c-38527207">[-]</label><label class="expand" for="c-38527207">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t fixing 10 just mean allowing things that were previously not allowed? That&#x27;s not a breaking change. What am I missing?</div><br/><div id="38527399" class="c"><input type="checkbox" id="c-38527399" checked=""/><div class="controls bullet"><span class="by">afdbcreid</span><span>|</span><a href="#38526186">root</a><span>|</span><a href="#38527207">parent</a><span>|</span><a href="#38526646">next</a><span>|</span><label class="collapse" for="c-38527399">[-]</label><label class="expand" for="c-38527399">[2 more]</label></div><br/><div class="children"><div class="content">No it will not:<p><pre><code>    fn requires_static(_: &amp;&#x27;static str) {}
    
    let long_lifetime: &amp;&#x27;static str = &quot;&quot;;
    let closure = |_input: &amp;str| -&gt; &amp;str { long_lifetime };
    let short_lifetime = &amp;String::new();
    requires_static(closure(short_lifetime));
</code></pre>
This code compiles currently as the returned `&amp;str` is inferred to be `&amp;&#x27;static str` because this is what it actually returns, but with #10 fixed it will not because lifetime elision rules say that the lifetime of the output is the same as the lifetime of the input.</div><br/><div id="38528023" class="c"><input type="checkbox" id="c-38528023" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38526186">root</a><span>|</span><a href="#38527399">parent</a><span>|</span><a href="#38526646">next</a><span>|</span><label class="collapse" for="c-38528023">[-]</label><label class="expand" for="c-38528023">[1 more]</label></div><br/><div class="children"><div class="content">Hm, in this case it&#x27;s actually nice that this works because there&#x27;s nothing unsafe or unexpected going on.</div><br/></div></div></div></div></div></div><div id="38526646" class="c"><input type="checkbox" id="c-38526646" checked=""/><div class="controls bullet"><span class="by">drewtato</span><span>|</span><a href="#38526186">parent</a><span>|</span><a href="#38527207">prev</a><span>|</span><a href="#38526154">next</a><span>|</span><label class="collapse" for="c-38526646">[-]</label><label class="expand" for="c-38526646">[1 more]</label></div><br/><div class="children"><div class="content">Most likely yes.<p>However, if you don&#x27;t specify the argument type, it compiles fine. It&#x27;s rare that you need to specify argument or return types on a closure, so it&#x27;s not actually a large issue.</div><br/></div></div></div></div><div id="38526154" class="c"><input type="checkbox" id="c-38526154" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38526186">prev</a><span>|</span><a href="#38527537">next</a><span>|</span><label class="collapse" for="c-38526154">[-]</label><label class="expand" for="c-38526154">[1 more]</label></div><br/><div class="children"><div class="content">This is a nice writeup. (5) and (10) are particularly good to know IMO -- (5) makes it pretty easy to design correct-looking APIs that only fail to compile when actually called (versus when defined), and (10) is a significant roadbump in Rust&#x27;s otherwise relatively smooth (IMO) learning curve.</div><br/></div></div><div id="38527537" class="c"><input type="checkbox" id="c-38527537" checked=""/><div class="controls bullet"><span class="by">perfopt</span><span>|</span><a href="#38526154">prev</a><span>|</span><a href="#38526173">next</a><span>|</span><label class="collapse" for="c-38527537">[-]</label><label class="expand" for="c-38527537">[1 more]</label></div><br/><div class="children"><div class="content">I use ChatGPT to ask questions about my code - including rust lifetimes - and usually get pretty good detailed answers. More recently I started using diesel ORM and was pleasantly surprised that the bot can answer questions about diesel usage.</div><br/></div></div><div id="38526173" class="c"><input type="checkbox" id="c-38526173" checked=""/><div class="controls bullet"><span class="by">bfrog</span><span>|</span><a href="#38527537">prev</a><span>|</span><a href="#38526020">next</a><span>|</span><label class="collapse" for="c-38526173">[-]</label><label class="expand" for="c-38526173">[1 more]</label></div><br/><div class="children"><div class="content">This is fantastic and definitely hits a few points that confused me when I first started as well. I remember definitively pounding the keyboard in frustration over at least one of these</div><br/></div></div><div id="38526020" class="c"><input type="checkbox" id="c-38526020" checked=""/><div class="controls bullet"><span class="by">ttymck</span><span>|</span><a href="#38526173">prev</a><span>|</span><label class="collapse" for="c-38526020">[-]</label><label class="expand" for="c-38526020">[4 more]</label></div><br/><div class="children"><div class="content">This is very helpful. But I find it cumbersome to mix &quot;misconceptions&quot; with &quot;clarifications&quot;.<p>To elaborate, stating &quot;Foo is bar&quot; as a misconception to be clarified, and then following it up with &quot;Baz is quux&quot;, makes it very hard to follow and clearly identify what bits of information should be ingrained. In my opinion, information should only be conveyed &quot;in the affirmative&quot;.<p>For example, don&#x27;t write &quot;Foo is bar is not true&quot;, write &quot;Foo is NOT bar&quot;. Or have some consistent and unmistakable typography for the &quot;false statements&quot; (highlighting or color, etc)</div><br/><div id="38526169" class="c"><input type="checkbox" id="c-38526169" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#38526020">parent</a><span>|</span><a href="#38526912">next</a><span>|</span><label class="collapse" for="c-38526169">[-]</label><label class="expand" for="c-38526169">[1 more]</label></div><br/><div class="children"><div class="content">I wholeheartedly agree and also extend this to software I write. I try very hard to have booleans never be called e.g. disableFoo. It isn&#x27;t always easy, but you glue enough logic together and then try to say it becomes very difficult. This becomes even more true when you have a language that has unset or null type values and then configurations for those settings where the logic gets even nastier because usually you want unset to be false. If you have a negatively declared variable in this case, you have to check if it is true OR it is unset, whereas if it is a positively named thing, simply checking for a truthy value is adequate, more concise, and less error prone.</div><br/></div></div><div id="38526912" class="c"><input type="checkbox" id="c-38526912" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#38526020">parent</a><span>|</span><a href="#38526169">prev</a><span>|</span><a href="#38526181">next</a><span>|</span><label class="collapse" for="c-38526912">[-]</label><label class="expand" for="c-38526912">[1 more]</label></div><br/><div class="children"><div class="content">&gt; have some consistent and unmistakable typography for the &quot;false statements&quot; (highlighting or color, etc)<p>THIS ^^<p>I stopped reading after about paragraph two, when I realized that it was very unclear that the code <i>and table</i> that I was reading was in the &quot;this is a false belief&quot; part of the explanation.<p>Don&#x27;t do that.<p>Communicate more clearly and the article will be useful to more people, longer.</div><br/></div></div></div></div></div></div></div></div></div></body></html>