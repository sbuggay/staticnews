<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700989258610" as="style"/><link rel="stylesheet" href="styles.css?v=1700989258610"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.det.life/why-you-shouldnt-invest-in-vector-databases-c0cd3f59d23c?gi=6b9cfcb2e477">Investing in new vector database development vs enhancing existing databases</a> <span class="domain">(<a href="https://blog.det.life">blog.det.life</a>)</span></div><div class="subtext"><span>mnming</span> | <span>39 comments</span></div><br/><div><div id="38420134" class="c"><input type="checkbox" id="c-38420134" checked=""/><div class="controls bullet"><span class="by">jakozaur</span><span>|</span><a href="#38419086">next</a><span>|</span><label class="collapse" for="c-38420134">[-]</label><label class="expand" for="c-38420134">[1 more]</label></div><br/><div class="children"><div class="content">Most devs would be better off upgrading their database and using vectors there. They need to change the schema, but it&#x27;s way easier than introducing a new database.<p>A specialized vector database would be needed in just a few relatively rare use cases.</div><br/></div></div><div id="38419086" class="c"><input type="checkbox" id="c-38419086" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38420134">prev</a><span>|</span><a href="#38417688">next</a><span>|</span><label class="collapse" for="c-38419086">[-]</label><label class="expand" for="c-38419086">[2 more]</label></div><br/><div class="children"><div class="content">Why is this flagged? Is there a problem with the content of the article?<p>I don&#x27;t see this reflected in the comments here</div><br/><div id="38419995" class="c"><input type="checkbox" id="c-38419995" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#38419086">parent</a><span>|</span><a href="#38417688">next</a><span>|</span><label class="collapse" for="c-38419995">[-]</label><label class="expand" for="c-38419995">[1 more]</label></div><br/><div class="children"><div class="content">as of midnight Saturday pacific time i do not see it flagged:</div><br/></div></div></div></div><div id="38417688" class="c"><input type="checkbox" id="c-38417688" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38419086">prev</a><span>|</span><a href="#38419033">next</a><span>|</span><label class="collapse" for="c-38417688">[-]</label><label class="expand" for="c-38417688">[16 more]</label></div><br/><div class="children"><div class="content">Has anyone seen a convincing argument for why you would want a dedicated vector database in place of a normal database with a good, fast vector index implementation?<p>The existing DB + vector index option seems so obvious to me that I&#x27;m worried I&#x27;m missing something.</div><br/><div id="38419173" class="c"><input type="checkbox" id="c-38419173" checked=""/><div class="controls bullet"><span class="by">jhj</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38418323">next</a><span>|</span><label class="collapse" for="c-38419173">[-]</label><label class="expand" for="c-38419173">[1 more]</label></div><br/><div class="children"><div class="content">The two main classes of approximate k-NN algorithms om high dimensional data would involve either (1) linear table scans (e.g., IVF &#x2F; cell-probe indexes; brute-force exact indexing or the coarse quantizer for an IVF index) or (2) graph walking (HNSW, NN-Descent, CAGRA, etc). Some other approaches like LSH (depending on how it&#x27;s represented as a data structure) can be in between the two.<p>For (1), all of the indexing features of a typical RDBMS are overkill for IVF, where the only indexing you need is by IVF bucket, and then you simply sequentially scan and evaluate distances for everything in those buckets.<p>However, if you want to perform filtering based on other criteria (e.g., filtering based on metadata associated with each vector), then multiple column indexes could be useful with a RDBMS, as you can more efficiently extract just the vectors that meet criteria prior to a sequential scan (e.g., give me all vectors which have a date in the range between X and Y and whose name contains the string &quot;red&quot;).<p>For (2), these algorithms would be inefficient to express in a typical RDBMS. While you can easily encode a graph in a RDBMS, walking the graph sequentially based on criteria is another matter, because each time you&#x27;d have to hit the disk (or in-memory cache) to find the next row to look at, then repeat. Latency could be an issue unless it&#x27;s all in memory, and if it&#x27;s all in memory, a RDBMS-type representation is overkill versus more simple pointer chasing in memory.<p>I guess it also depends upon latency &#x2F; throughput needs (caching in memory on front of a database could help, but a pure in-memory vector index would be faster), persistence &#x2F; fault tolerance &#x2F; replication needs (in memory databases would need some kind of persistent store), or update needs (adding&#x2F;removing vectors, though adding&#x2F;removing vectors from an IVF or graph-based index becomes non-trivial if you add or remove too many vectors). Traditional databbases that have been around for a while might provide better guarantees on reliability.<p>(I&#x27;m the author of the GPU half of the Faiss library)</div><br/></div></div><div id="38418323" class="c"><input type="checkbox" id="c-38418323" checked=""/><div class="controls bullet"><span class="by">tveita</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38419173">prev</a><span>|</span><a href="#38418343">next</a><span>|</span><label class="collapse" for="c-38418323">[-]</label><label class="expand" for="c-38418323">[1 more]</label></div><br/><div class="children"><div class="content">There are good reasons to split embeddings off from your regular DB load. Embeddings can be quite large (kilobytes per item), and querying is CPU and IO intensive, so they are good candidate for scaling separately.<p>The embeddings are not primary data, they&#x27;re derived from other content and can be recreated if necessary. The vectors will probably be fed or read in bulk by your ML pipeline at times.<p>I&#x27;d say you probably want the primary storage of your embeddings to be file storage like S3 or similar, and then feed them directly into a search engine like Vespa or Elasticsearch.</div><br/></div></div><div id="38418343" class="c"><input type="checkbox" id="c-38418343" checked=""/><div class="controls bullet"><span class="by">icyfox</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38418323">prev</a><span>|</span><a href="#38419298">next</a><span>|</span><label class="collapse" for="c-38418343">[-]</label><label class="expand" for="c-38418343">[1 more]</label></div><br/><div class="children"><div class="content">The only production case I&#x27;ve seen of someone switching to a vector database totally in-lieu of a RDBMS is when their raw data lives in parquet &#x2F; arrow files and they need fast read-only searches in production. Then a periodic indexing daemon with some additional metadata bolted onto the vector definitions worked well and saved them from having to dip their toes into classic database optimization.<p>Every place where I&#x27;m deploying vector databases, though, I&#x27;m using them as an alternative index just for searches (indexing embedding&#x2F;id only) and doing the full object value lookup in the RDBMS. It&#x27;s easier to optimize their vector clustering &#x2F; sort performance outside the constraints of postgres - which is perhaps why pgvector suffers more under higher load.</div><br/></div></div><div id="38419298" class="c"><input type="checkbox" id="c-38419298" checked=""/><div class="controls bullet"><span class="by">dmezzetti</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38418343">prev</a><span>|</span><a href="#38417778">next</a><span>|</span><label class="collapse" for="c-38419298">[-]</label><label class="expand" for="c-38419298">[1 more]</label></div><br/><div class="children"><div class="content">txtai can use Postgres as a data store and combine that with a vector index like Faiss or Hnswlib.<p>In this case, you get the robustness of Postgres (which has been around a while) and Faiss (which is one of the most mature vector indexes).<p><a href="https:&#x2F;&#x2F;neuml.hashnode.dev&#x2F;external-database-integration" rel="nofollow noreferrer">https:&#x2F;&#x2F;neuml.hashnode.dev&#x2F;external-database-integration</a></div><br/></div></div><div id="38417778" class="c"><input type="checkbox" id="c-38417778" checked=""/><div class="controls bullet"><span class="by">dylanjcastillo</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38419298">prev</a><span>|</span><a href="#38417703">next</a><span>|</span><label class="collapse" for="c-38417778">[-]</label><label class="expand" for="c-38417778">[4 more]</label></div><br/><div class="children"><div class="content">I guess that at a big enough scale it starts making sense. But not sure what “big” really is.<p>Pgvector seems to perform very poorly compared to Qdrant: <a href="https:&#x2F;&#x2F;nirantk.com&#x2F;writing&#x2F;pgvector-vs-qdrant&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nirantk.com&#x2F;writing&#x2F;pgvector-vs-qdrant&#x2F;</a></div><br/><div id="38420009" class="c"><input type="checkbox" id="c-38420009" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417778">parent</a><span>|</span><a href="#38417836">next</a><span>|</span><label class="collapse" for="c-38420009">[-]</label><label class="expand" for="c-38420009">[1 more]</label></div><br/><div class="children"><div class="content">i wish nirantk would add an addendum noting the pgvector issue was fixed or people like me will have to put up the counter response every single time <a href="https:&#x2F;&#x2F;youtu.be&#x2F;MDxEXKkxf2Q?si=eUhNtghbiLRJ7yHB" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;MDxEXKkxf2Q?si=eUhNtghbiLRJ7yHB</a></div><br/></div></div><div id="38417836" class="c"><input type="checkbox" id="c-38417836" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417778">parent</a><span>|</span><a href="#38420009">prev</a><span>|</span><a href="#38417703">next</a><span>|</span><label class="collapse" for="c-38417836">[-]</label><label class="expand" for="c-38417836">[2 more]</label></div><br/><div class="children"><div class="content">I absolutely believe that at the moment - Qdrant is clearly a fantastic piece of technology.<p>But if I was using Qdrant myself I&#x27;d treat it like ElasticSearch - I&#x27;d denormalize some of my data into it, but I&#x27;d still do most of my work in the relational database and treat Qdrant as effectively an external index for my stuff.<p>Maybe I&#x27;m getting hung up on the world &quot;database&quot; here as indicating that you use that instead of an RDBMS, when actually everyone selling a vector database expects you to use it as effectively an external indexing mechanism instead.</div><br/><div id="38419036" class="c"><input type="checkbox" id="c-38419036" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417836">parent</a><span>|</span><a href="#38417703">next</a><span>|</span><label class="collapse" for="c-38419036">[-]</label><label class="expand" for="c-38419036">[1 more]</label></div><br/><div class="children"><div class="content">I personally read it as “vector cache”, because you can use it to, eg, store a phrasing to repeat later.</div><br/></div></div></div></div></div></div><div id="38417703" class="c"><input type="checkbox" id="c-38417703" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38417778">prev</a><span>|</span><a href="#38419445">next</a><span>|</span><label class="collapse" for="c-38417703">[-]</label><label class="expand" for="c-38417703">[6 more]</label></div><br/><div class="children"><div class="content">why do companies use databases like elastic search when they could just use inverted indexes in postgres?<p>Performance, features, and scalability</div><br/><div id="38417844" class="c"><input type="checkbox" id="c-38417844" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417703">parent</a><span>|</span><a href="#38419118">next</a><span>|</span><label class="collapse" for="c-38417844">[-]</label><label class="expand" for="c-38417844">[2 more]</label></div><br/><div class="children"><div class="content">I use Elasticsearch along with PostgreSQL, but I don&#x27;t think of Elasticsearch as a database. It&#x27;s an external index that I denormalize some of my data into.</div><br/><div id="38419335" class="c"><input type="checkbox" id="c-38419335" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417844">parent</a><span>|</span><a href="#38419118">next</a><span>|</span><label class="collapse" for="c-38419335">[-]</label><label class="expand" for="c-38419335">[1 more]</label></div><br/><div class="children"><div class="content">ES is a good parallel to a vector database.<p>run a search against ES =&gt; hydrate records from postgres<p>run a search against a vector database =&gt; hydrate LLM context from documents<p>Neither is a primary canonical datastore. Postgres is for ES and S3 is for documents.</div><br/></div></div></div></div><div id="38419118" class="c"><input type="checkbox" id="c-38419118" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38417703">parent</a><span>|</span><a href="#38417844">prev</a><span>|</span><a href="#38419445">next</a><span>|</span><label class="collapse" for="c-38419118">[-]</label><label class="expand" for="c-38419118">[3 more]</label></div><br/><div class="children"><div class="content">so, its just happened that there is no good implementation of full text search in postgres, but fundamentally nothing prevents from implementing such search, except horizontal scalability if it is needed.</div><br/><div id="38419218" class="c"><input type="checkbox" id="c-38419218" checked=""/><div class="controls bullet"><span class="by">johnthescott</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38419118">parent</a><span>|</span><a href="#38419445">next</a><span>|</span><label class="collapse" for="c-38419218">[-]</label><label class="expand" for="c-38419218">[2 more]</label></div><br/><div class="children"><div class="content">the pg extension called &quot;rum&quot; is very performant on millions of pdfs.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;postgrespro&#x2F;rum">https:&#x2F;&#x2F;github.com&#x2F;postgrespro&#x2F;rum</a></div><br/><div id="38419334" class="c"><input type="checkbox" id="c-38419334" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#38417688">root</a><span>|</span><a href="#38419218">parent</a><span>|</span><a href="#38419445">next</a><span>|</span><label class="collapse" for="c-38419334">[-]</label><label class="expand" for="c-38419334">[1 more]</label></div><br/><div class="children"><div class="content">my case is tens of billions of short docs, and default search is fine except index creation is single threaded, so it takes multiple days to build index, and github page says rum is even slower..</div><br/></div></div></div></div></div></div></div></div><div id="38419445" class="c"><input type="checkbox" id="c-38419445" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#38417688">parent</a><span>|</span><a href="#38417703">prev</a><span>|</span><a href="#38419033">next</a><span>|</span><label class="collapse" for="c-38419445">[-]</label><label class="expand" for="c-38419445">[1 more]</label></div><br/><div class="children"><div class="content">Nah you nailed it. Beyond the tech even, I don&#x27;t much understand why there&#x27;s a cottage industry for it. Either you&#x27;re touching people&#x27;s personal documents and should be doing it locally and preferably in-memory, or you&#x27;re touching people&#x27;s personal documents and you should own where the data is stored.</div><br/></div></div></div></div><div id="38419033" class="c"><input type="checkbox" id="c-38419033" checked=""/><div class="controls bullet"><span class="by">utopcell</span><span>|</span><a href="#38417688">prev</a><span>|</span><a href="#38418335">next</a><span>|</span><label class="collapse" for="c-38419033">[-]</label><label class="expand" for="c-38419033">[1 more]</label></div><br/><div class="children"><div class="content">ANN-benchmarks [1] compares 30 OSS libraries. pgvector comes up dead last.<p>[1] <a href="https:&#x2F;&#x2F;ann-benchmarks.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ann-benchmarks.com&#x2F;</a></div><br/></div></div><div id="38418335" class="c"><input type="checkbox" id="c-38418335" checked=""/><div class="controls bullet"><span class="by">dmezzetti</span><span>|</span><a href="#38419033">prev</a><span>|</span><a href="#38417692">next</a><span>|</span><label class="collapse" for="c-38418335">[-]</label><label class="expand" for="c-38418335">[3 more]</label></div><br/><div class="children"><div class="content">Adding txtai to the list <a href="https:&#x2F;&#x2F;github.com&#x2F;neuml&#x2F;txtai">https:&#x2F;&#x2F;github.com&#x2F;neuml&#x2F;txtai</a><p>txtai is an all-in-one embeddings database for semantic search, LLM orchestration and language model workflows. txtai can satisfy most vector database use cases such as being a knowledge source for retrieval augmented generation (RAG).<p>txtai is independently developed (not VC-backed) and released under an Apache 2.0 license.</div><br/><div id="38419052" class="c"><input type="checkbox" id="c-38419052" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#38418335">parent</a><span>|</span><a href="#38417692">next</a><span>|</span><label class="collapse" for="c-38419052">[-]</label><label class="expand" for="c-38419052">[2 more]</label></div><br/><div class="children"><div class="content">it is just a python lib right? not db like qdrant.</div><br/><div id="38419256" class="c"><input type="checkbox" id="c-38419256" checked=""/><div class="controls bullet"><span class="by">dmezzetti</span><span>|</span><a href="#38418335">root</a><span>|</span><a href="#38419052">parent</a><span>|</span><a href="#38417692">next</a><span>|</span><label class="collapse" for="c-38419256">[-]</label><label class="expand" for="c-38419256">[1 more]</label></div><br/><div class="children"><div class="content">Yes, txtai is written in Python as others in that article are (such as Chroma). We don&#x27;t know what closed source options behind an API service are written in.<p>I consider txtai to be a vector database and satisfy many of the vector database use cases.</div><br/></div></div></div></div></div></div><div id="38417692" class="c"><input type="checkbox" id="c-38417692" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38418335">prev</a><span>|</span><a href="#38419509">next</a><span>|</span><label class="collapse" for="c-38417692">[-]</label><label class="expand" for="c-38417692">[8 more]</label></div><br/><div class="children"><div class="content">pgvector is &quot;only&quot; at v 0.5 but does look interesting to me.  Any HNers tried it?</div><br/><div id="38420110" class="c"><input type="checkbox" id="c-38420110" checked=""/><div class="controls bullet"><span class="by">alex_suzuki</span><span>|</span><a href="#38417692">parent</a><span>|</span><a href="#38418228">next</a><span>|</span><label class="collapse" for="c-38420110">[-]</label><label class="expand" for="c-38420110">[1 more]</label></div><br/><div class="children"><div class="content">I am using it successfully for doing semantic search in a database of ~1M video clips. The CLIP embeddings of key frames are stored in Postgres&#x2F;pgvector and it has worked well so far.</div><br/></div></div><div id="38418228" class="c"><input type="checkbox" id="c-38418228" checked=""/><div class="controls bullet"><span class="by">Arson9416</span><span>|</span><a href="#38417692">parent</a><span>|</span><a href="#38420110">prev</a><span>|</span><a href="#38417738">next</a><span>|</span><label class="collapse" for="c-38418228">[-]</label><label class="expand" for="c-38418228">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good enough and only going to get better. The postgres community only has to improve a vector index extension. These vector databases have to improve everything else (all of the really hard stuff) about a database. My money is on postgres.<p>EDIT&gt;&gt; Plus pgvector is enabled by default on AWS RDS databases. Huge bonus.</div><br/><div id="38419271" class="c"><input type="checkbox" id="c-38419271" checked=""/><div class="controls bullet"><span class="by">dmezzetti</span><span>|</span><a href="#38417692">root</a><span>|</span><a href="#38418228">parent</a><span>|</span><a href="#38419328">next</a><span>|</span><label class="collapse" for="c-38419271">[-]</label><label class="expand" for="c-38419271">[1 more]</label></div><br/><div class="children"><div class="content">There are other approaches that could work too. For example, txtai can use Postgres as a data store and combine that with a vector index like Faiss or Hnswlib.<p>In this case, you get the robustness of Postgres (which has been around a while) and Faiss (which is one of the most mature vector indexes).<p><a href="https:&#x2F;&#x2F;neuml.hashnode.dev&#x2F;external-database-integration" rel="nofollow noreferrer">https:&#x2F;&#x2F;neuml.hashnode.dev&#x2F;external-database-integration</a></div><br/></div></div><div id="38419328" class="c"><input type="checkbox" id="c-38419328" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#38417692">root</a><span>|</span><a href="#38418228">parent</a><span>|</span><a href="#38419271">prev</a><span>|</span><a href="#38419446">next</a><span>|</span><label class="collapse" for="c-38419328">[-]</label><label class="expand" for="c-38419328">[2 more]</label></div><br/><div class="children"><div class="content">&gt; These vector databases have to improve everything else<p>No they don&#x27;t. Because they aren&#x27;t trying to build general purpose databases.<p>And often trying to jam everything into one product just makes it worse not better.</div><br/><div id="38419538" class="c"><input type="checkbox" id="c-38419538" checked=""/><div class="controls bullet"><span class="by">richardw</span><span>|</span><a href="#38417692">root</a><span>|</span><a href="#38419328">parent</a><span>|</span><a href="#38419446">next</a><span>|</span><label class="collapse" for="c-38419538">[-]</label><label class="expand" for="c-38419538">[1 more]</label></div><br/><div class="children"><div class="content">User management, documentation, distribution, UI’s, upgrades, high availability and clustering, backups, libraries, skills required to administer and therefore hire for.<p>I’ve worked in companies where we grabbed any tech we want, and I’ve worked in companies with one default DB unless you had an excellent reason. The latter meant a much simpler universe where entire teams knew how to fix things that broke at 2am. You just hire one type of DBA. It also meant dev teams really knew how to squeeze the one DB platform rather than learn a little about 10 database types.</div><br/></div></div></div></div><div id="38419446" class="c"><input type="checkbox" id="c-38419446" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#38417692">root</a><span>|</span><a href="#38418228">parent</a><span>|</span><a href="#38419328">prev</a><span>|</span><a href="#38417738">next</a><span>|</span><label class="collapse" for="c-38419446">[-]</label><label class="expand" for="c-38419446">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s good enough […]<p>«Good enough» is not a quantative metric by any conceivable measure. Furthermore, people in surrounding threads have reported inadequate performance of the pg_vector PgSQL extension (which, indubitably, can and will be fixed at some point).<p>An example of a useful <i>quantative</i> metric would: «compared to alternative vector processing&#x2F;indexing engines&#x2F;databases A, B and C and a dataset comprising N inputs and a total size of S Mb&#x2F;Gb&#x2F;Tb and using the M, N and P use cases in the performance testing scenario and pg_vector being the performance baseline, the following results have been obtained: X, Y and Z» – do you have anything similar to that you could share? Not only the comparison results would be insightful, they could also feed into someone&#x27;s decision making process of whether X should be favoured over Y.<p>&gt; […] and only going to get better.<p>Beyond doubt, it will. In the future. But people need to solve problems in the present.</div><br/></div></div></div></div><div id="38417738" class="c"><input type="checkbox" id="c-38417738" checked=""/><div class="controls bullet"><span class="by">sberens</span><span>|</span><a href="#38417692">parent</a><span>|</span><a href="#38418228">prev</a><span>|</span><a href="#38419509">next</a><span>|</span><label class="collapse" for="c-38417738">[-]</label><label class="expand" for="c-38417738">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s significantly slower than dedicated vector dbs at &gt;100k vectors</div><br/></div></div></div></div><div id="38419509" class="c"><input type="checkbox" id="c-38419509" checked=""/><div class="controls bullet"><span class="by">outside1234</span><span>|</span><a href="#38417692">prev</a><span>|</span><a href="#38417610">next</a><span>|</span><label class="collapse" for="c-38419509">[-]</label><label class="expand" for="c-38419509">[1 more]</label></div><br/><div class="children"><div class="content">Just use PostgreSQL and pgvector</div><br/></div></div><div id="38417610" class="c"><input type="checkbox" id="c-38417610" checked=""/><div class="controls bullet"><span class="by">DemocracyFTW2</span><span>|</span><a href="#38419509">prev</a><span>|</span><a href="#38417724">next</a><span>|</span><label class="collapse" for="c-38417610">[-]</label><label class="expand" for="c-38417610">[3 more]</label></div><br/><div class="children"><div class="content">from the article: &quot;Instead of investing in new vector database products, it would be better to focus on existing databases and explore how they can be enhanced by incorporating vector search functionalities to become more powerful.&quot;<p>Didn&#x27;t read the rest but this looks like sound advice; same would go for graph DBs.</div><br/><div id="38417637" class="c"><input type="checkbox" id="c-38417637" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#38417610">parent</a><span>|</span><a href="#38417669">next</a><span>|</span><label class="collapse" for="c-38417637">[-]</label><label class="expand" for="c-38417637">[1 more]</label></div><br/><div class="children"><div class="content">With due respect to the author, its pretty bog-standard advice. Why &quot;build&quot; when cheaper to integrate a &quot;buy.&quot; There is a reason most development isn&#x27;t in raw Assembly anymore!</div><br/></div></div></div></div><div id="38417724" class="c"><input type="checkbox" id="c-38417724" checked=""/><div class="controls bullet"><span class="by">lexandstuff</span><span>|</span><a href="#38417610">prev</a><span>|</span><label class="collapse" for="c-38417724">[-]</label><label class="expand" for="c-38417724">[3 more]</label></div><br/><div class="children"><div class="content">This article is about why you shouldn&#x27;t enter the vector database field, and it&#x27;s reasonable.<p>But I want to comment on another thing I often hear: &quot;You don&#x27;t need a vector database - just use Postgres or Numpy, etc&quot;. As someone who moved to Pinecone from a Numpy-based solution, I have to disagree.<p>Using a hosted vector database is straightforward. Get an API key from Pinecone, send them your vectors, and then query it with new vectors. It&#x27;s fast, supports metadata filtering, and scales horizontally.<p>On the other hand, setting up pgvector is a hassle - especially since none of the Cloud vendors support it natively, and a Numpy-based solution, while great for a POC, quickly becomes a hassle when trying to append to it and scale it horizontally.<p>If you need a vector database, use a vector database. You won&#x27;t regret it.</div><br/><div id="38417827" class="c"><input type="checkbox" id="c-38417827" checked=""/><div class="controls bullet"><span class="by">rstocker99</span><span>|</span><a href="#38417724">parent</a><span>|</span><label class="collapse" for="c-38417827">[-]</label><label class="expand" for="c-38417827">[2 more]</label></div><br/><div class="children"><div class="content">Postgres RDS has version 0.5 of the pgvector extension installed by default.<p>Adding vector support to our app was as easy as enabling the extension and created a table with vector columns. No additional database required and trivial to do mixed queries. Maybe Pinecone and friends have better scalability, but if you need basic vector support, you can do it easily on RDS.<p>See here for details:<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;about-aws&#x2F;whats-new&#x2F;2023&#x2F;10&#x2F;amazon-rds-postgresql-pgvector-hnsw-indexing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;about-aws&#x2F;whats-new&#x2F;2023&#x2F;10&#x2F;amazon-rd...</a></div><br/><div id="38418349" class="c"><input type="checkbox" id="c-38418349" checked=""/><div class="controls bullet"><span class="by">lexandstuff</span><span>|</span><a href="#38417724">root</a><span>|</span><a href="#38417827">parent</a><span>|</span><label class="collapse" for="c-38418349">[-]</label><label class="expand" for="c-38418349">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough. I researched it earlier in the year and it wasn&#x27;t available.<p>I stand by my point: we often hear that adding a new tool to your stack is introducing unnecessary complexity, when more often not using the right tool is the path of most complexity.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>