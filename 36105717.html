<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685350863662" as="style"/><link rel="stylesheet" href="styles.css?v=1685350863662"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://projecteuclid.org/journals/notre-dame-journal-of-formal-logic/volume-47/issue-4/The-Halting-Problem-Is-Decidable-on-a-Set-of-Asymptotic/10.1305/ndjfl/1168352664.full">The halting problem is decidable on a set of asymptotic probability one (2006)</a> <span class="domain">(<a href="https://projecteuclid.org">projecteuclid.org</a>)</span></div><div class="subtext"><span>Schiphol</span> | <span>101 comments</span></div><br/><div><div id="36106632" class="c"><input type="checkbox" id="c-36106632" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#36106698">next</a><span>|</span><label class="collapse" for="c-36106632">[-]</label><label class="expand" for="c-36106632">[17 more]</label></div><br/><div class="children"><div class="content">A few years ago I had an idea to try and solve halting problem for as many Brainfuck problems as possible, using a few simple heuristics. (To make things easier I picked a dialect with 1 byte cells that weren&#x27;t allowed to over- or underflow.)<p>I managed to solve all BF programs up to length 12. The longest running but stopping short program that I&#x27;ve found was this: &gt;+[&gt;++&gt;+++[-&lt;]&gt;&gt;], it stopped after 9212 steps.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;eterevsky&#x2F;beaver">https:&#x2F;&#x2F;github.com&#x2F;eterevsky&#x2F;beaver</a></div><br/><div id="36106993" class="c"><input type="checkbox" id="c-36106993" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106632">parent</a><span>|</span><a href="#36107781">next</a><span>|</span><label class="collapse" for="c-36106993">[-]</label><label class="expand" for="c-36106993">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I managed to solve all BF programs up to length 12.<p>With 8 possible instructions, that is equivalent to all programs up to 12 * log 8 = 36 bits. Curiously, that <i>exactly</i> matches how far we were able to analyze the behaviour of a functional busy beaver [1].<p>&gt; it stopped after 9212 steps.<p>The largest output of a 36 bit lambda term is a whopping 578960446186580977117854925043439539266349923328202820197287920039565648199686 bits long though...<p>[1] <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A333479" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A333479</a></div><br/></div></div><div id="36107781" class="c"><input type="checkbox" id="c-36107781" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36106632">parent</a><span>|</span><a href="#36106993">prev</a><span>|</span><a href="#36106698">next</a><span>|</span><label class="collapse" for="c-36107781">[-]</label><label class="expand" for="c-36107781">[14 more]</label></div><br/><div class="children"><div class="content">From what I recall, the &quot;undecidable&quot; part of the halting problem isn&#x27;t determining that something halts, but determining that it _doesn&#x27;t_ halt (i.e. the halting problem is verifiable, as opposed to the inverse &quot;non-halting&quot; problem, which isn&#x27;t verifiable, which is always the case for the inverse of a verifiable problem).\<p>I&#x27;ve never properly learned brainfuck, so the answer to this might be trivial without needing to write a solver, but what&#x27;s the shortest non-halting program you found?</div><br/><div id="36108328" class="c"><input type="checkbox" id="c-36108328" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36107781">parent</a><span>|</span><a href="#36108333">next</a><span>|</span><label class="collapse" for="c-36108328">[-]</label><label class="expand" for="c-36108328">[4 more]</label></div><br/><div class="children"><div class="content">The shortest non-halting brainfuck program will have exactly three instructions. Here is one them: `+[]`   here is another one: `-[]`.<p>Brainfuck&#x27;s state consists of an array of integers, an index into that array, a program counter, and some bookkeeping required to track which &quot;[&quot; corresponds to which &quot;]&quot;.<p>Let&#x27;s assume the array a[:] is zeroed and the index i is set to 0 before the program begins executing.<p>Then `+` increments the cell in the array a at index i, i.e. `a[i] += 1`; `[` begins a while loop, equivalent to `while a[i] != 0 {`; and `]` ends the while loop: `}` .<p>So the program `+[]` is equivalent to something like<p><pre><code>  a := (allocate a length N array of bytes, set to zero)
  i := 0
  a[i] += 1
  while a[i] != 0 {
  }
</code></pre>
which will not terminate.<p>Why is this the shortest?<p>`]` is the only instruction that might decrease the program counter, otherwise the program counter always increases by one or more. Therefore, a non-halting brainfuck program must include at least one `]`. Brainfuck programs are syntactically incorrect unless there is exactly one `]` occurring somewhere in the program after each `[`. So the shortest non-halting brainfuck program must have at least two instructions.<p>There is only one syntactically valid brainfuck program with two instructions that might not halt: `[]`.  But this will halt, assuming that the array `a` is initialised to zero before execution begins. So the shortest non-halting brainfuck program contains three instructions.</div><br/><div id="36108360" class="c"><input type="checkbox" id="c-36108360" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108328">parent</a><span>|</span><a href="#36109374">next</a><span>|</span><label class="collapse" for="c-36108360">[-]</label><label class="expand" for="c-36108360">[2 more]</label></div><br/><div class="children"><div class="content">To add to this, there is also the `,[]` program, which reads a single input byte, halts iff it is zero, and loops infinitely otherwise.</div><br/><div id="36108374" class="c"><input type="checkbox" id="c-36108374" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108360">parent</a><span>|</span><a href="#36109374">next</a><span>|</span><label class="collapse" for="c-36108374">[-]</label><label class="expand" for="c-36108374">[1 more]</label></div><br/><div class="children"><div class="content">Fair point! Arguably the program `,` might not halt if a user never provides a byte of input to read! I&#x27;ve never seen a brainfuck machine with a read timeout.</div><br/></div></div></div></div></div></div><div id="36108333" class="c"><input type="checkbox" id="c-36108333" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36107781">parent</a><span>|</span><a href="#36108328">prev</a><span>|</span><a href="#36108351">next</a><span>|</span><label class="collapse" for="c-36108333">[-]</label><label class="expand" for="c-36108333">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never properly learned brainfuck, so the answer to this might be trivial without needing to write a solver, but what&#x27;s the shortest non-halting program you found?<p>It&#x27;s a pretty trivial question in any language, it tends to just be while(true); or similar in that language.</div><br/><div id="36110325" class="c"><input type="checkbox" id="c-36110325" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108333">parent</a><span>|</span><a href="#36108616">next</a><span>|</span><label class="collapse" for="c-36110325">[-]</label><label class="expand" for="c-36110325">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re being pedantic, it&#x27;s pretty trivial in any Turing complete language (which I imagine Brainfuck is in, since I think it&#x27;s supposed to be essentially just syntax over the idea of a Turing machine); there are definitely languages that aren&#x27;t able to express non-halting programs by design (like Coq, which I think is primitive recursive).</div><br/></div></div><div id="36108616" class="c"><input type="checkbox" id="c-36108616" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108333">parent</a><span>|</span><a href="#36110325">prev</a><span>|</span><a href="#36108351">next</a><span>|</span><label class="collapse" for="c-36108616">[-]</label><label class="expand" for="c-36108616">[6 more]</label></div><br/><div class="children"><div class="content">What is it in the lambda calculus?</div><br/><div id="36108656" class="c"><input type="checkbox" id="c-36108656" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108616">parent</a><span>|</span><a href="#36108979">next</a><span>|</span><label class="collapse" for="c-36108656">[-]</label><label class="expand" for="c-36108656">[2 more]</label></div><br/><div class="children"><div class="content">(Lx.xx)(Lx.xx) is the most famous&#x2F;well-known one.</div><br/><div id="36111416" class="c"><input type="checkbox" id="c-36111416" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108656">parent</a><span>|</span><a href="#36108979">next</a><span>|</span><label class="collapse" for="c-36111416">[-]</label><label class="expand" for="c-36111416">[1 more]</label></div><br/><div class="children"><div class="content">And as it turns out, the smallest one too.<p>For combinatory logic with the usual {S,K} basis, it&#x27;s S S K (S (S S K).</div><br/></div></div></div></div><div id="36108979" class="c"><input type="checkbox" id="c-36108979" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108616">parent</a><span>|</span><a href="#36108656">prev</a><span>|</span><a href="#36108351">next</a><span>|</span><label class="collapse" for="c-36108979">[-]</label><label class="expand" for="c-36108979">[3 more]</label></div><br/><div class="children"><div class="content">What does &#x27;lambda calculus&#x27; mean? I read that lambda refers to binding to variables - so is &#x27;calculus&#x27; really just a way to refer to calculating generally? I suppose I only know the word contextually from the math class that shares the name.</div><br/><div id="36110585" class="c"><input type="checkbox" id="c-36110585" checked=""/><div class="controls bullet"><span class="by">sam_bristow</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36108979">parent</a><span>|</span><a href="#36108351">next</a><span>|</span><label class="collapse" for="c-36110585">[-]</label><label class="expand" for="c-36110585">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Lambda calculus is a notation for describing mathematical functions and programs. It is a mathematical system for studying the interaction of functional abstraction and functional application. It captures some of the essential, common features of a wide variety of programming languages.&quot;<p>- <a href="https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;courses&#x2F;cs3110&#x2F;2008fa&#x2F;recitations&#x2F;rec26.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;courses&#x2F;cs3110&#x2F;2008fa&#x2F;recitations...</a></div><br/><div id="36111439" class="c"><input type="checkbox" id="c-36111439" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#36106632">root</a><span>|</span><a href="#36110585">parent</a><span>|</span><a href="#36108351">next</a><span>|</span><label class="collapse" for="c-36111439">[-]</label><label class="expand" for="c-36111439">[1 more]</label></div><br/><div class="children"><div class="content">And the name of this very website we are talking on is derived from lambda calculus. The y combinator is a fixed point combinator in lambda calculus.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36106698" class="c"><input type="checkbox" id="c-36106698" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106632">prev</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36106698">[-]</label><label class="expand" for="c-36106698">[7 more]</label></div><br/><div class="children"><div class="content">The meat of the paper is this short<p>&gt; Proof of the Main Theorem Using the standard model<p>&gt; let B be the set of programs that on input 0 either halt before repeating a state or fall off the tape before repeating a state. Clearly, B is polynomial time decidable, since we need only run a program p for at most n steps, where n is the number of states in p, to determine whether or not it is in B. It is equally clear that the halting problem is polynomial time decidable for programs p in B, since again we need only simulate p for n steps to know whether it halted or fell off. What remains is to prove that this behavior occurs with asymptotic probability one.<p>The proof also makes use of this<p>&gt; Lemma 2.5 (Polya [2], see also, e.g., [1])<p>&gt; In the random walk with equal likelihood
of moving left or right on a semi-infinite tape, beginning on the left-most cell, the
probability of eventually falling off the left edge is 1.<p>This suggests that the result crucially depends on having a one-sided infinite tape rather than the two-sided infinite tape that&#x27;s used in the Turing Machine busy beaver.<p>It would be interesting to determine whether the result also holds for that other computational model, i.e. what about the set of lambda calculus terms with or without a normal form?</div><br/><div id="36109785" class="c"><input type="checkbox" id="c-36109785" checked=""/><div class="controls bullet"><span class="by">calf</span><span>|</span><a href="#36106698">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36109785">[-]</label><label class="expand" for="c-36109785">[6 more]</label></div><br/><div class="children"><div class="content">I got confused here:<p>&gt; Clearly, B is polynomial time decidable, since we need only run a program p for at most n steps, where n is the number of states in p, to determine whether or not it is in B.<p>Couldn&#x27;t program p have an exponential number of states, e.g. 2^|p| distinct program states? Then running the program for O(2^|p|) steps is clearly not polynomial time decidable in the size of the instance. I thought polynomial time, for the decision algorithm, meant O(|p|^c) for some c. Am I mistaken about something?</div><br/><div id="36111453" class="c"><input type="checkbox" id="c-36111453" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106698">root</a><span>|</span><a href="#36109785">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36111453">[-]</label><label class="expand" for="c-36111453">[5 more]</label></div><br/><div class="children"><div class="content">In this case p is the standard encoding of a Turing Machine with n states, so |p| = n * 2 * (1 + 1 + log(n+1)), so necessarily n &lt; |p|.</div><br/><div id="36111609" class="c"><input type="checkbox" id="c-36111609" checked=""/><div class="controls bullet"><span class="by">calf</span><span>|</span><a href="#36106698">root</a><span>|</span><a href="#36111453">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36111609">[-]</label><label class="expand" for="c-36111609">[4 more]</label></div><br/><div class="children"><div class="content">Yes thanks I figured that out later; they define the &quot;state&quot; as what in CS we would call the lines of code or control flow blocks. What I&#x27;m curious about is with our usual &quot;modern programmer&#x27;s&quot; understanding of a state, the state space is exponential in the size of the program. That&#x27;s why we have model checking and software verification. Whereas this theorem is about programs B whose state space is linear in the length of the encoding of the program, because they&#x27;re allowed to visit each Turing machine state at most once before halting. At first glance seems like a very specialized case of a class of programs to talk about.</div><br/><div id="36111757" class="c"><input type="checkbox" id="c-36111757" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106698">root</a><span>|</span><a href="#36111609">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36111757">[-]</label><label class="expand" for="c-36111757">[3 more]</label></div><br/><div class="children"><div class="content">State space refers to the number of states of not just the program counter, but more importantly, the data operated on by that program, which in case of TMs is the tape contents.<p>This theorem is not about programs B whose tape contents is linear in the length of the encoding of the program.</div><br/><div id="36111836" class="c"><input type="checkbox" id="c-36111836" checked=""/><div class="controls bullet"><span class="by">calf</span><span>|</span><a href="#36106698">root</a><span>|</span><a href="#36111757">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36111836">[-]</label><label class="expand" for="c-36111836">[2 more]</label></div><br/><div class="children"><div class="content">The criterion is that p in B must halt before returning to a Program Counter value (what they define as repeating a Turing machine &quot;state&quot;). That&#x27;s the length of the program text. So, I have no idea why they are talking about polynomials, it looks linear because the program counter has 1 value per line of code in a program text. If not, I would like to know where my misunderstanding could be. Clearly the authors think the paragraph is a simple, obvious step not worth discussing clearly (they say something about running the program for n steps being sufficient, but they do not outright, explicitly say why it would be polynomial, etc.)</div><br/><div id="36111860" class="c"><input type="checkbox" id="c-36111860" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106698">root</a><span>|</span><a href="#36111836">parent</a><span>|</span><a href="#36106706">next</a><span>|</span><label class="collapse" for="c-36111860">[-]</label><label class="expand" for="c-36111860">[1 more]</label></div><br/><div class="children"><div class="content">Oh, you&#x27;re right that the criterion for B seems to ignore tape contents. I agree that B is a very uninteresting subset of programs from a programming perspective...</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36106706" class="c"><input type="checkbox" id="c-36106706" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#36106698">prev</a><span>|</span><a href="#36106399">next</a><span>|</span><label class="collapse" for="c-36106706">[-]</label><label class="expand" for="c-36106706">[13 more]</label></div><br/><div class="children"><div class="content">Similarly, as the number of particles in a system increases, the less you have to worry about Heisenberg uncertainty bounds on your momentum&#x2F;position measurements.<p>It’s a misreading of the halting problem to think of it as a ‘barrier’ of some sort. What it really means is that there are some computer programs where the only way to find out what they will do is to actually run them. There’s not a ‘better trick’ you can pull to get the answer. This is kind of intuitive, since we know there are problems we run into where the easiest way we can think of to solve them is to write a program and run it. The halting problem tells us that it’s plausible that that instinct is right - that for some programs, you really can’t do some other analysis of the program that tells you what it’s going to do. You have to just run it.<p>Like: take a random complex number with magnitude &lt; 2. Keep squaring it and adding the original number. Will you ever get a number with magnitude &gt; 2?<p>For some numbers you can take a shortcut and say yes or no. But for others the only way to find out is to keep doing it.</div><br/><div id="36107043" class="c"><input type="checkbox" id="c-36107043" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#36106706">parent</a><span>|</span><a href="#36107287">next</a><span>|</span><label class="collapse" for="c-36107043">[-]</label><label class="expand" for="c-36107043">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The halting problem tells us that it’s plausible that that instinct is right - that for some programs, you really can’t do some other analysis of the program that tells you what it’s going to do. You have to just run it.<p>This isn&#x27;t quite right. The halting problem says that you can&#x27;t just run it. If you just run it, you will not learn whether or not it halts after any finite amount of time.<p>Also I don&#x27;t see how this is related to uncertainty bounds.</div><br/><div id="36107451" class="c"><input type="checkbox" id="c-36107451" checked=""/><div class="controls bullet"><span class="by">ttctciyf</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36107043">parent</a><span>|</span><a href="#36107287">next</a><span>|</span><label class="collapse" for="c-36107451">[-]</label><label class="expand" for="c-36107451">[6 more]</label></div><br/><div class="children"><div class="content">&gt; If you just run it, you will not learn whether or not it halts after any finite amount of time.<p>If it halts within a finite amount of time, you will.</div><br/><div id="36109871" class="c"><input type="checkbox" id="c-36109871" checked=""/><div class="controls bullet"><span class="by">SideQuark</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36107451">parent</a><span>|</span><a href="#36108416">next</a><span>|</span><label class="collapse" for="c-36109871">[-]</label><label class="expand" for="c-36109871">[2 more]</label></div><br/><div class="children"><div class="content">No you won&#x27;t. Pick any finite time you will check. It may not stop by then, yet may stop later. So ahead of time, even if the program will stop, you cannot make a plan to learn that in finite time. You&#x27;re stuck letting run possibly forever, because at each finite time you still cannot answer yes or no. Only if you&#x27;ve waited long enough, which can be arbitrarily far out, and it stops, can you answer.</div><br/><div id="36111052" class="c"><input type="checkbox" id="c-36111052" checked=""/><div class="controls bullet"><span class="by">ttctciyf</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36109871">parent</a><span>|</span><a href="#36108416">next</a><span>|</span><label class="collapse" for="c-36111052">[-]</label><label class="expand" for="c-36111052">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Only if you&#x27;ve waited long enough, which can be arbitrarily far out, and it stops, can you answer<p>So, we agree!</div><br/></div></div></div></div><div id="36108416" class="c"><input type="checkbox" id="c-36108416" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36107451">parent</a><span>|</span><a href="#36109871">prev</a><span>|</span><a href="#36107287">next</a><span>|</span><label class="collapse" for="c-36108416">[-]</label><label class="expand" for="c-36108416">[3 more]</label></div><br/><div class="children"><div class="content">But that is not the only possibility. So you are missing the point.</div><br/><div id="36108932" class="c"><input type="checkbox" id="c-36108932" checked=""/><div class="controls bullet"><span class="by">Sinidir</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36108416">parent</a><span>|</span><a href="#36107287">next</a><span>|</span><label class="collapse" for="c-36108932">[-]</label><label class="expand" for="c-36108932">[2 more]</label></div><br/><div class="children"><div class="content">They are not missing the point. The previous post was simply wrong. The halting problem is semi-decidable. So you can potentially find out wether a program halts.</div><br/><div id="36109020" class="c"><input type="checkbox" id="c-36109020" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36108932">parent</a><span>|</span><a href="#36107287">next</a><span>|</span><label class="collapse" for="c-36109020">[-]</label><label class="expand" for="c-36109020">[1 more]</label></div><br/><div class="children"><div class="content">Besides missing the point, this is also pedantic and quite boring.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36107287" class="c"><input type="checkbox" id="c-36107287" checked=""/><div class="controls bullet"><span class="by">qubex</span><span>|</span><a href="#36106706">parent</a><span>|</span><a href="#36107043">prev</a><span>|</span><a href="#36107813">next</a><span>|</span><label class="collapse" for="c-36107287">[-]</label><label class="expand" for="c-36107287">[2 more]</label></div><br/><div class="children"><div class="content">I think you’re confusing computational irreducibility and the halting problem.</div><br/><div id="36108723" class="c"><input type="checkbox" id="c-36108723" checked=""/><div class="controls bullet"><span class="by">s-zeng</span><span>|</span><a href="#36106706">root</a><span>|</span><a href="#36107287">parent</a><span>|</span><a href="#36107813">next</a><span>|</span><label class="collapse" for="c-36108723">[-]</label><label class="expand" for="c-36108723">[1 more]</label></div><br/><div class="children"><div class="content">I think he might be referring to Rice&#x27;s Theorem, which to be fair is reducible to the halting problem</div><br/></div></div></div></div><div id="36107813" class="c"><input type="checkbox" id="c-36107813" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36106706">parent</a><span>|</span><a href="#36107287">prev</a><span>|</span><a href="#36106829">next</a><span>|</span><label class="collapse" for="c-36107813">[-]</label><label class="expand" for="c-36107813">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly, as the number of particles in a system increases, the less you have to worry about Heisenberg uncertainty bounds on your momentum&#x2F;position measurements.<p>This certainly makes intuitive sense, since it explains why we don&#x27;t have trouble measuring both the speed and position of objects in everyday life with fairly high precision.</div><br/></div></div><div id="36106829" class="c"><input type="checkbox" id="c-36106829" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#36106706">parent</a><span>|</span><a href="#36107813">prev</a><span>|</span><a href="#36108131">next</a><span>|</span><label class="collapse" for="c-36106829">[-]</label><label class="expand" for="c-36106829">[1 more]</label></div><br/><div class="children"><div class="content">What does this have to do with Heisenberg uncertainty?</div><br/></div></div><div id="36108131" class="c"><input type="checkbox" id="c-36108131" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#36106706">parent</a><span>|</span><a href="#36106829">prev</a><span>|</span><a href="#36106399">next</a><span>|</span><label class="collapse" for="c-36108131">[-]</label><label class="expand" for="c-36108131">[1 more]</label></div><br/><div class="children"><div class="content">Unexpected Mandelbrot</div><br/></div></div></div></div><div id="36106399" class="c"><input type="checkbox" id="c-36106399" checked=""/><div class="controls bullet"><span class="by">l33t233372</span><span>|</span><a href="#36106706">prev</a><span>|</span><a href="#36105999">next</a><span>|</span><label class="collapse" for="c-36106399">[-]</label><label class="expand" for="c-36106399">[4 more]</label></div><br/><div class="children"><div class="content">I’ve never seen “asymptomatic density” referred to as “asymptomatic probability.”<p>Anyways, if anyone is interested is a more complete survey of similarly flavored computability&#x2F;density results, this paper is good: <a href="https:&#x2F;&#x2F;faculty.math.illinois.edu&#x2F;~jockusch&#x2F;DensityCE_JML.pdf" rel="nofollow">https:&#x2F;&#x2F;faculty.math.illinois.edu&#x2F;~jockusch&#x2F;DensityCE_JML.pd...</a><p>There is even some pure combinatorics involved, for example I remember lemma 6.7 from my combinatorics class back in undergrad</div><br/><div id="36107790" class="c"><input type="checkbox" id="c-36107790" checked=""/><div class="controls bullet"><span class="by">meithecatte</span><span>|</span><a href="#36106399">parent</a><span>|</span><a href="#36105999">next</a><span>|</span><label class="collapse" for="c-36107790">[-]</label><label class="expand" for="c-36107790">[3 more]</label></div><br/><div class="children"><div class="content">Note: it&#x27;s not asymptomatic, but asymptotic - without the ma. I can only wonder whether you&#x27;ve always been writing it like that, or if this is the toll that the pandemic had on you.</div><br/><div id="36110206" class="c"><input type="checkbox" id="c-36110206" checked=""/><div class="controls bullet"><span class="by">l33t233372</span><span>|</span><a href="#36106399">root</a><span>|</span><a href="#36107790">parent</a><span>|</span><a href="#36107962">next</a><span>|</span><label class="collapse" for="c-36110206">[-]</label><label class="expand" for="c-36110206">[1 more]</label></div><br/><div class="children"><div class="content">I think my autocorrect got the better of me there!</div><br/></div></div><div id="36107962" class="c"><input type="checkbox" id="c-36107962" checked=""/><div class="controls bullet"><span class="by">aklein</span><span>|</span><a href="#36106399">root</a><span>|</span><a href="#36107790">parent</a><span>|</span><a href="#36110206">prev</a><span>|</span><a href="#36105999">next</a><span>|</span><label class="collapse" for="c-36107962">[-]</label><label class="expand" for="c-36107962">[1 more]</label></div><br/><div class="children"><div class="content">Maybe they just need a vaccination… uh I mean a vacation</div><br/></div></div></div></div></div></div><div id="36105999" class="c"><input type="checkbox" id="c-36105999" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#36106399">prev</a><span>|</span><a href="#36108353">next</a><span>|</span><label class="collapse" for="c-36105999">[-]</label><label class="expand" for="c-36105999">[29 more]</label></div><br/><div class="children"><div class="content">In case anyone wants a quick tl;dr: as the length of a program (expressed as the number of states in a Turing machine) grows, the relative fraction of undecidable programs decreases. In other words, &quot;most&quot; (approaching &quot;nearly all&quot; as they get longer) Turing machines, out of the set of all possible Turing machines of that same size, are actually decidable. (Though this doesn&#x27;t tell us about whether most real programs are decidable, as the programs humans write also come from a small subset of the universe of Turing machines. But we know that in practice, this is also true).<p>This relates nicely to the earlier discussion of SAT: while SAT is NP-complete, many instances can be solved in reasonable time. Similarly, we can verify that many actual programs will halt even if the problem is, in general, undecidable.</div><br/><div id="36106033" class="c"><input type="checkbox" id="c-36106033" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36105999">parent</a><span>|</span><a href="#36106517">next</a><span>|</span><label class="collapse" for="c-36106033">[-]</label><label class="expand" for="c-36106033">[21 more]</label></div><br/><div class="children"><div class="content">I think it would be pretty shocking if the opposite were true. I imagine most randomly generated turing machines are pretty trivial.</div><br/><div id="36106151" class="c"><input type="checkbox" id="c-36106151" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106033">parent</a><span>|</span><a href="#36106401">next</a><span>|</span><label class="collapse" for="c-36106151">[-]</label><label class="expand" for="c-36106151">[13 more]</label></div><br/><div class="children"><div class="content">Dunno. The real numbers, for example, are in the “most things are eldritch abominations” camp[1]: the reals are uncountable, the <i>computable</i> reals are a(n everywhere dense) countable set[2] (that is therefore[3]) of measure zero. Not that there’s a reason to expect these cases to be similar, just that weird things do happen.<p>[1] <a href="https:&#x2F;&#x2F;mathwithbaddrawings.com&#x2F;2016&#x2F;12&#x2F;28&#x2F;why-the-number-line-freaks-me-out&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mathwithbaddrawings.com&#x2F;2016&#x2F;12&#x2F;28&#x2F;why-the-number-li...</a><p>[2] There’s a finite set of programs of a fixed length, thus (countable union of finite sets) a countable set of all programs, thus only at most a countable set of numbers they can compute.<p>[3] Every countable set has Lebesgue measure zero: cover point #n by a blot of measure ε &#x2F; 2^n (that could even intersect other blots) to prove all of them have measure at most ε &gt; 0, take ε as small as desired.</div><br/><div id="36106380" class="c"><input type="checkbox" id="c-36106380" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106151">parent</a><span>|</span><a href="#36107051">next</a><span>|</span><label class="collapse" for="c-36106380">[-]</label><label class="expand" for="c-36106380">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve made the argument many times before that the reals are certainly an interesting set of objects, but a poor abstraction for the concept of a number. We should work towards replacing them with a more well-behaved set without eldritch monsters such as uncomputable &#x27;numbers&#x27; that you can&#x27;t add or multiply with. E.g. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computable_number" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computable_number</a>.</div><br/><div id="36106470" class="c"><input type="checkbox" id="c-36106470" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106380">parent</a><span>|</span><a href="#36106629">next</a><span>|</span><label class="collapse" for="c-36106470">[-]</label><label class="expand" for="c-36106470">[5 more]</label></div><br/><div class="children"><div class="content">Computable functions do also have some weird behavior. For example: a) all functions are continuous, b) equality is not computable (maybe not so weird for anyone used to floating point), c) differentiation is not computable unless you work over complex numbers (but integration is!)</div><br/><div id="36106723" class="c"><input type="checkbox" id="c-36106723" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106470">parent</a><span>|</span><a href="#36106629">next</a><span>|</span><label class="collapse" for="c-36106723">[-]</label><label class="expand" for="c-36106723">[4 more]</label></div><br/><div class="children"><div class="content">a) All functions from computable reals to computable reals are continuous. This makes sense, because an arbitrarily small input difference leading to an arbitrarily large output difference is not a good basis for computation. You can still have discontinuities for discrete computable maps.<p>b) Neither is equality computable for the reals. Nothing is lost here.<p>c) Differentiation is computable for the functions of computable reals if you have a computable rate of convergence.</div><br/><div id="36107253" class="c"><input type="checkbox" id="c-36107253" checked=""/><div class="controls bullet"><span class="by">chromoblob</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106723">parent</a><span>|</span><a href="#36106629">next</a><span>|</span><label class="collapse" for="c-36107253">[-]</label><label class="expand" for="c-36107253">[3 more]</label></div><br/><div class="children"><div class="content">How to do (c)? I tried to model the reals as lazily computed sequences of intervals with rational bounds where every next interval is subset of previous one, and couldn&#x27;t write a higher-order differentiator function because on every step for a given input interval there is output interval with non-zero (in most cases) size and the differentiated function may contain quick enough oscillations that the derivative is unbounded, and thus the derivative will stay unbounded no matter what you do. What do you mean by rate of convergence?</div><br/><div id="36107686" class="c"><input type="checkbox" id="c-36107686" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36107253">parent</a><span>|</span><a href="#36106629">next</a><span>|</span><label class="collapse" for="c-36107686">[-]</label><label class="expand" for="c-36107686">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modulus_of_convergence" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modulus_of_convergence</a></div><br/><div id="36110669" class="c"><input type="checkbox" id="c-36110669" checked=""/><div class="controls bullet"><span class="by">chromoblob</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36107686">parent</a><span>|</span><a href="#36106629">next</a><span>|</span><label class="collapse" for="c-36110669">[-]</label><label class="expand" for="c-36110669">[1 more]</label></div><br/><div class="children"><div class="content">(I assume you refer to the sequence of reals that is used to compute the limit in the definition of derivative) But is there a way to somehow construct this modulus automatically for some functions? And if there isn&#x27;t, then isn&#x27;t requiring manual input of the modulus like just requiring manual input of the derivative itself? Can you typically find the modulus manually more easily than the derivative?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36106629" class="c"><input type="checkbox" id="c-36106629" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106380">parent</a><span>|</span><a href="#36106470">prev</a><span>|</span><a href="#36107051">next</a><span>|</span><label class="collapse" for="c-36106629">[-]</label><label class="expand" for="c-36106629">[1 more]</label></div><br/><div class="children"><div class="content">There’s a tradeoff[1] throughout mathematics, not unlike the expressiveness—analyzability one in programming languages: either the <i>set</i> of things you’re working with has nice properties (e.g., for the reals, completeness) and supports nice constructions with no caveats (e.g., for the reals, limits); or each of the <i>things</i> in the set is individually nice and tractable (e.g. computable).<p>There isn’t a single universally appropriate choice here, and sometimes even the direction of the axis is not obvious (real numbers lack solutions for algebraic equations; complex numbers lack smooth functions nonzero only in a finite region), but usually a simple family of eldritch objects is easier to deal with than an byzantine clan of cuddly objects.<p>Could you do simple physics and more generally ordinary differential equations over the computable numbers? You <i>probably</i> could to some extent, but it’s unlikely you’d get the nice intuitive geometry you get over the reals (see e.g. Arnold’s ODE textbook). The (basic) geometry of surfaces parametrized by real coordinates is fairly straightforward (differential geometry); the geometry of surfaces parametrized by <i>rational</i> coordinates is famously mind-blowingly abstract (algebraic geometry). The (basic) theory of real or complex functions is mostly understandable (analysis); the theory of natural or rational functions is <i>horrifying</i> (number theory).<p>Also, as a sibling reply mentions, it’s not like computable numbers will solve every problem: even though arithmetic over them is decidable, order still isn’t, and computable transcendental functions aren’t exactly a cakewalk either.<p>It doesn’t mean the computable reals aren’t worth knowing about, but, well, we live in a world where mandatory education has violently rejected[2] every advance in mathematical thought since Otto von Bismarck left office, and reduced the ones it accepted to a desiccated husk[3], so there are a great many things in that category. (I cannot help but remember the SMBC patriotism vs nationalism comic[4]: “Now I am mathematics.”)<p>[1] <a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;dichotomy+between+nice+objects+and+nice+categories" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;dichotomy+between+nice+objects...</a><p>[2] <a href="http:&#x2F;&#x2F;www.ams.org&#x2F;notices&#x2F;201201&#x2F;rtx120100031p.pdf" rel="nofollow">http:&#x2F;&#x2F;www.ams.org&#x2F;notices&#x2F;201201&#x2F;rtx120100031p.pdf</a><p>[3] <a href="https:&#x2F;&#x2F;www.maa.org&#x2F;external_archive&#x2F;devlin&#x2F;devlin_03_08.html" rel="nofollow">https:&#x2F;&#x2F;www.maa.org&#x2F;external_archive&#x2F;devlin&#x2F;devlin_03_08.htm...</a><p>[4] <a href="https:&#x2F;&#x2F;www.smbc-comics.com&#x2F;comic&#x2F;an-important-distinction" rel="nofollow">https:&#x2F;&#x2F;www.smbc-comics.com&#x2F;comic&#x2F;an-important-distinction</a></div><br/></div></div></div></div><div id="36107051" class="c"><input type="checkbox" id="c-36107051" checked=""/><div class="controls bullet"><span class="by">fpoling</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106151">parent</a><span>|</span><a href="#36106380">prev</a><span>|</span><a href="#36106463">next</a><span>|</span><label class="collapse" for="c-36107051">[-]</label><label class="expand" for="c-36107051">[4 more]</label></div><br/><div class="children"><div class="content">The notion of uncountable set assumes certain axioms and classical logic. If instead one assumes rules of constructive mathematics, then one cannot construct uncountable set. Simplifying only computable numbers can exist.</div><br/><div id="36107519" class="c"><input type="checkbox" id="c-36107519" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36107051">parent</a><span>|</span><a href="#36106463">next</a><span>|</span><label class="collapse" for="c-36107519">[-]</label><label class="expand" for="c-36107519">[3 more]</label></div><br/><div class="children"><div class="content">Note that there are multiple versions[1] of “constructive mathematics”, so for example what Bishop’s constructive real analysis book considers constructive is not what Markov’s “constructive = computable” tradition does.<p>You are also going to encounter other funny things. One of De Morgan’s laws failing could seem troubling but ultimately theoretical—how, then, about the distinction about countable and <i>constructively</i> countable[3]? The set of all programs is countable; the set of all <i>terminating</i> programs is a subset of it, but can’t constructively be proven to itself be countable—after all, that would imply a solution to the halting problem! (Neither can it constructively be proven to <i>not</i> be such, as it <i>is</i> such in a consistent extension, namely classical mathematics.) Thus you get the new and exciting notion of <i>subcountable</i> sets. And that’s one of the mildest things that you’re going to encounter in your shiny new theory of cardinals.<p>(Anybody who can explain to me what the hell constructive Hahn—Banach[4] is about gets a beverage of their choice if we are ever in the same city. Without HB, you cannot do any functional analysis worth a damn, and without that you can’t really talk about Green’s functions &#x2F; fundamental solutions to linear PDEs, which are in turn a basic tool for any electodynamics or quantum mechanics worth speaking about. Unless you want to forgo proof or the natural sciences, you need it, is my point.)<p>None of this is to say that I think intuitionistic logic is useless, mind you. It’s interesting and useful[5]! But so far it seems that you need to learn at least some logic (as a piece of mathematics and not mere terminology, so including scary words like “metalogic”) before you can really understand how it comes together.<p>[1] It seems categorical logic[2] says useful things about what the One True Definition should be? But I don’t understand it well enough to tell, and in any case the constructivist tradition predates not only it but category theory in general.<p>[2] <a href="https:&#x2F;&#x2F;mikeshulman.github.io&#x2F;catlog&#x2F;catlog.pdf" rel="nofollow">https:&#x2F;&#x2F;mikeshulman.github.io&#x2F;catlog&#x2F;catlog.pdf</a><p>[3] <a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;constructive+mathematics" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;constructive+mathematics</a><p>[4] <a href="https:&#x2F;&#x2F;www.cse.chalmers.se&#x2F;~coquand&#x2F;hahn1.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cse.chalmers.se&#x2F;~coquand&#x2F;hahn1.pdf</a><p>[5] <a href="https:&#x2F;&#x2F;www.ams.org&#x2F;journals&#x2F;bull&#x2F;2017-54-03&#x2F;S0273-0979-2016-01556-4&#x2F;S0273-0979-2016-01556-4.pdf" rel="nofollow">https:&#x2F;&#x2F;www.ams.org&#x2F;journals&#x2F;bull&#x2F;2017-54-03&#x2F;S0273-0979-2016...</a></div><br/><div id="36111550" class="c"><input type="checkbox" id="c-36111550" checked=""/><div class="controls bullet"><span class="by">fpoling</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36107519">parent</a><span>|</span><a href="#36107708">next</a><span>|</span><label class="collapse" for="c-36111550">[-]</label><label class="expand" for="c-36111550">[1 more]</label></div><br/><div class="children"><div class="content">Markov’s variety of the constructive mathematics is just what Bishop did plus the assumption that Church-Markov-Turing thesis holds. One does not need to assume that to recover any result of classical mathematics applicable in the real world. Also all those weird results of Markov’s approach that apparently “contradict” the classical mathematics is a consequence of Church thesis. Without that one cannot prove them. So Bishop’s approach is always compatible with classical mathematics.<p>As for Hahn—Banach I can only site the book “Techniques of Constructive Analysis” by Douglas S. Bridges:<p>For example, our proof of the Hahn-Banach theorem (Theorem 5.3.3) is, as it stands, a valid algorithmic proof of the classical Hahn Banach theorem. Moreover and this is one advantage of a constructive proof in general our proof embodies an algorithm for the construction of the functional whose existence is stated in the theorem. This algorithm can be extracted from the proof, and, as an undeserved bonus, the proof itself demonstrates that the algorithm is correct or, in computer science parlance, &quot;meets its specifications&quot;.
…<p>The Hahn-Banach theorem enables us to extend a normed linear functional, with an arbitrarily small increase in norm, from a subspace of a normed space to the entire space. This fundamental result has numerous applications throughout functional analysis.<p>In the constructive context we deal only with the extension of linear functionals on subspaces of a separable normed space. The standard classical proofs extending the theorem to nonseparable normed spaces depend on Zorn&#x27;s lemma and are therefore nonconstructive.
…
The classical Hahn-Banach theorem says that we can extend a bounded linear functional v from Y to a functional u on the whole space X with exact preservation of norm. In general, as Exercise 5 shows, we cannot do this constructively. But, as we shall see, if we impose extra conditions on the norm of X, then we can make the extension norm-preserving.</div><br/></div></div><div id="36107708" class="c"><input type="checkbox" id="c-36107708" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36107519">parent</a><span>|</span><a href="#36111550">prev</a><span>|</span><a href="#36106463">next</a><span>|</span><label class="collapse" for="c-36107708">[-]</label><label class="expand" for="c-36107708">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the distinction about countable and constructively countable? The set of all programs is countable; the set of all terminating programs is a subset of it, but can’t constructively be proven to itself be countable—after all, that would imply a solution to the halting problem!<p>I thought this had to do with the difference between being computable and computably enumerable.</div><br/></div></div></div></div></div></div><div id="36106463" class="c"><input type="checkbox" id="c-36106463" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106151">parent</a><span>|</span><a href="#36107051">prev</a><span>|</span><a href="#36106401">next</a><span>|</span><label class="collapse" for="c-36106463">[-]</label><label class="expand" for="c-36106463">[1 more]</label></div><br/><div class="children"><div class="content">tl;dr : Maybe the reals are far more mysterious. All we ever have handle over are the  countable sets.<p>[0] Looking back, the core of my confusion was this. I had thought: I can visualize what ℵ0 means; that’s just the infinity of integers. I can also visualize what C=2^ℵ0 means; that’s the infinity of points on a line. Those, therefore, are the two bedrocks of clarity in this discussion. By contrast, I can’t visualize a set of intermediate cardinality between ℵ0 and C. The intermediate infinity, being weird and ghostlike, is the one that shouldn’t exist unless we deliberately “force” it to.<p>Turns out I had things backwards. For starters, I can’t visualize the uncountable infinity of real numbers. I might think I’m visualizing the real line—it’s solid, it’s black, it’s got little points everywhere—but how can I be sure that I’m not merely visualizing the ℵ0 rationals, or (say) the computable or definable reals, which include all the ones that arise in ordinary math?<p>The continuum C is not at all the bedrock of clarity that I’d thought it was. Unlike its junior partner ℵ0, the continuum is adjustable, changeable—and we will change it when we build different models of ZFC. What’s (relatively) more “fixed” in this game is something that I, like many non-experts, had always given short shrift to: Cantor’s sequence of Alephs ℵ0, ℵ1, ℵ2, etc.<p>[0] <a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=4974" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=4974</a></div><br/></div></div></div></div><div id="36106401" class="c"><input type="checkbox" id="c-36106401" checked=""/><div class="controls bullet"><span class="by">EscapeFromNY</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106033">parent</a><span>|</span><a href="#36106151">prev</a><span>|</span><a href="#36106517">next</a><span>|</span><label class="collapse" for="c-36106401">[-]</label><label class="expand" for="c-36106401">[7 more]</label></div><br/><div class="children"><div class="content">My intuition tells me the opposite.<p>Suppose you have one undecidable statement, U, out of s possible statements. A random program of length n contains U at least once with probability 1-(1-1&#x2F;s)^n. If the program is of infinite length, it contains U with probability 1. So I would have thought the chances of undecidability <i>increase</i> as the program gets longer.<p>Clearly my intuition is <i>wrong</i>, per the paper, but I don&#x27;t think the result is immediately obvious.</div><br/><div id="36106561" class="c"><input type="checkbox" id="c-36106561" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106401">parent</a><span>|</span><a href="#36110552">next</a><span>|</span><label class="collapse" for="c-36106561">[-]</label><label class="expand" for="c-36106561">[2 more]</label></div><br/><div class="children"><div class="content">Think about it like this, there are infinitely many Turing machine state classes that are easily decidable. For example, a simple infinite loop or its equivalent. Most of these classes are also very trivial to construct, and require only a few &quot;instructions&quot;.<p>So if you make a random TM, it&#x27;s almost guaranteed that it&#x27;ll get eventually &quot;trapped&quot; in one of these easily decidable infinite loops.</div><br/><div id="36106672" class="c"><input type="checkbox" id="c-36106672" checked=""/><div class="controls bullet"><span class="by">EscapeFromNY</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106561">parent</a><span>|</span><a href="#36110552">next</a><span>|</span><label class="collapse" for="c-36106672">[-]</label><label class="expand" for="c-36106672">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, that&#x27;s a perfect explanation</div><br/></div></div></div></div><div id="36110552" class="c"><input type="checkbox" id="c-36110552" checked=""/><div class="controls bullet"><span class="by">CaptainNegative</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106401">parent</a><span>|</span><a href="#36106561">prev</a><span>|</span><a href="#36107479">next</a><span>|</span><label class="collapse" for="c-36110552">[-]</label><label class="expand" for="c-36110552">[1 more]</label></div><br/><div class="children"><div class="content">It entirely depends on the description language. In Python, the opposite is true for basically the reason you gave: an asymptotically positive constant fraction of valid Python programs will begin with code searching for a contradiction to ZFC followed by an exit statement. In the model where Turing machines are modeled by random graphs with out-degree two, it is no longer necessarily the case that the start state component is exactly some fixed undecidable subgraph; i.e. as more states are added the probability of finding the start state inside a particular induced subgraph shrinks to zero.</div><br/></div></div><div id="36107479" class="c"><input type="checkbox" id="c-36107479" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106401">parent</a><span>|</span><a href="#36110552">prev</a><span>|</span><a href="#36106481">next</a><span>|</span><label class="collapse" for="c-36107479">[-]</label><label class="expand" for="c-36107479">[1 more]</label></div><br/><div class="children"><div class="content">I think the chance of having an undecidable (group of) statements go up, but the chance of executing it does not.<p>There isn&#x27;t really a single undecidable statement, it would be a complex subroutine. My intuition would be its much more likely a halt or indef loop (both relatively simple) would appear before program control would transfer to the undecidable part, in most cases.<p>I.e. if something undecidable requires 60 symbols in a row in correct order, but halting requires one, than probability of a halt at any given spot seems much higher on average.</div><br/></div></div><div id="36106481" class="c"><input type="checkbox" id="c-36106481" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106401">parent</a><span>|</span><a href="#36107479">prev</a><span>|</span><a href="#36106517">next</a><span>|</span><label class="collapse" for="c-36106481">[-]</label><label class="expand" for="c-36106481">[2 more]</label></div><br/><div class="children"><div class="content">A statement in a program can’t really be undecidable on its own. It’s the program that has that property.</div><br/><div id="36107288" class="c"><input type="checkbox" id="c-36107288" checked=""/><div class="controls bullet"><span class="by">chromoblob</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106481">parent</a><span>|</span><a href="#36106517">next</a><span>|</span><label class="collapse" for="c-36107288">[-]</label><label class="expand" for="c-36107288">[1 more]</label></div><br/><div class="children"><div class="content">A statement is just a subprogram. Whether it can be decidable depends on whether a single program can be undecidable (and I can&#x27;t see how that could be possible, undecidability is property of the problem - decision procedure on <i>set</i> of programs)</div><br/></div></div></div></div></div></div></div></div><div id="36106517" class="c"><input type="checkbox" id="c-36106517" checked=""/><div class="controls bullet"><span class="by">turminal</span><span>|</span><a href="#36105999">parent</a><span>|</span><a href="#36106033">prev</a><span>|</span><a href="#36106486">next</a><span>|</span><label class="collapse" for="c-36106517">[-]</label><label class="expand" for="c-36106517">[1 more]</label></div><br/><div class="children"><div class="content">The difference with SAT is that for SAT we actually know the opposite is true - the instances that can be solved quickly are the &quot;rare&quot; kind.</div><br/></div></div><div id="36106486" class="c"><input type="checkbox" id="c-36106486" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#36105999">parent</a><span>|</span><a href="#36106517">prev</a><span>|</span><a href="#36106424">next</a><span>|</span><label class="collapse" for="c-36106486">[-]</label><label class="expand" for="c-36106486">[1 more]</label></div><br/><div class="children"><div class="content">The simplex algorithm is similar being exponential time worst case but in practice often closer to linear</div><br/></div></div><div id="36106424" class="c"><input type="checkbox" id="c-36106424" checked=""/><div class="controls bullet"><span class="by">SilasX</span><span>|</span><a href="#36105999">parent</a><span>|</span><a href="#36106486">prev</a><span>|</span><a href="#36106330">next</a><span>|</span><label class="collapse" for="c-36106424">[-]</label><label class="expand" for="c-36106424">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure the comparison to SAT is a good one because, in that case, we know of particular “phase transition” regions in which most problems <i>aren’t</i> clearly satisfiable or unsatisfiable. (Specifically, when the ratio of clauses to variables in 3SAT is about 4.2.)</div><br/><div id="36107620" class="c"><input type="checkbox" id="c-36107620" checked=""/><div class="controls bullet"><span class="by">oldgradstudent</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106424">parent</a><span>|</span><a href="#36106330">next</a><span>|</span><label class="collapse" for="c-36107620">[-]</label><label class="expand" for="c-36107620">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an excellent comparison to SAT, because in both cases nobody cares about random instances at all.<p>For non-random instances the ratio of clauses to variables in is utterly meaningless.</div><br/></div></div></div></div><div id="36106330" class="c"><input type="checkbox" id="c-36106330" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#36105999">parent</a><span>|</span><a href="#36106424">prev</a><span>|</span><a href="#36108353">next</a><span>|</span><label class="collapse" for="c-36106330">[-]</label><label class="expand" for="c-36106330">[3 more]</label></div><br/><div class="children"><div class="content">Also the same applies with the CAP theorem… it is mostly a theoretical result but in practice things go well the vast majority of the time!<p>Also look up Buridan’s Principle by Leslie Lamport. I emailed him and “argued” with him for a while after reading his paper, but in a theoretical sense and some practical subsets it is correct!</div><br/><div id="36106633" class="c"><input type="checkbox" id="c-36106633" checked=""/><div class="controls bullet"><span class="by">sebzim4500</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106330">parent</a><span>|</span><a href="#36108353">next</a><span>|</span><label class="collapse" for="c-36106633">[-]</label><label class="expand" for="c-36106633">[2 more]</label></div><br/><div class="children"><div class="content">Interesting paper. I agree that he is probably technically correct, but I think he downplays the fact that all over physics people say &quot;never&quot; when they mean &quot;with probably less than 10^-1000.<p>For example, in classical thermodynamics there is a nonzero probability that all the air molecules in a room will happen to travel to one side, violating many laws of fluid mechanics. In quantum mechanics the situation is even worse, where basically anything can happen with nonzero probability.</div><br/><div id="36110172" class="c"><input type="checkbox" id="c-36110172" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#36105999">root</a><span>|</span><a href="#36106633">parent</a><span>|</span><a href="#36108353">next</a><span>|</span><label class="collapse" for="c-36110172">[-]</label><label class="expand" for="c-36110172">[1 more]</label></div><br/><div class="children"><div class="content">&gt; basically anything can happen with nonzero probability.<p>It took me some time to realize that that&#x27;s what &quot;HitchHiker&#x27;s Guide to Galaxy&quot; was about.</div><br/></div></div></div></div></div></div></div></div><div id="36108353" class="c"><input type="checkbox" id="c-36108353" checked=""/><div class="controls bullet"><span class="by">Jeff_Brown</span><span>|</span><a href="#36105999">prev</a><span>|</span><a href="#36106967">next</a><span>|</span><label class="collapse" for="c-36108353">[-]</label><label class="expand" for="c-36108353">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting result, but the probability distribution seems to be doing a lot of the work. The distribution of programs a human is likely to encounter is very different from the set of all programs of length N uniformly distributed.</div><br/></div></div><div id="36106967" class="c"><input type="checkbox" id="c-36106967" checked=""/><div class="controls bullet"><span class="by">nico</span><span>|</span><a href="#36108353">prev</a><span>|</span><a href="#36106376">next</a><span>|</span><label class="collapse" for="c-36106967">[-]</label><label class="expand" for="c-36106967">[7 more]</label></div><br/><div class="children"><div class="content">Is there a contest somewhere for the longest continuously-running computation?<p>It would be interesting to see how long we are capable of running even just a while true<p>The power might go out, some electronic component might fail, or the cooling system, etc<p>What is the longest that we are actually capable of keeping the most simple system running?</div><br/><div id="36111506" class="c"><input type="checkbox" id="c-36111506" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#36106967">parent</a><span>|</span><a href="#36106983">next</a><span>|</span><label class="collapse" for="c-36111506">[-]</label><label class="expand" for="c-36111506">[1 more]</label></div><br/><div class="children"><div class="content">The Oxford bell is running since 1840.</div><br/></div></div><div id="36106983" class="c"><input type="checkbox" id="c-36106983" checked=""/><div class="controls bullet"><span class="by">jgtrosh</span><span>|</span><a href="#36106967">parent</a><span>|</span><a href="#36111506">prev</a><span>|</span><a href="#36107167">next</a><span>|</span><label class="collapse" for="c-36106983">[-]</label><label class="expand" for="c-36106983">[2 more]</label></div><br/><div class="children"><div class="content">Does the century old continuously running lamp bulb in a fire brigade count as a computation, if a while true does?</div><br/><div id="36107169" class="c"><input type="checkbox" id="c-36107169" checked=""/><div class="controls bullet"><span class="by">mannykannot</span><span>|</span><a href="#36106967">root</a><span>|</span><a href="#36106983">parent</a><span>|</span><a href="#36107167">next</a><span>|</span><label class="collapse" for="c-36107169">[-]</label><label class="expand" for="c-36107169">[1 more]</label></div><br/><div class="children"><div class="content">Life on Earth is an out-of-equilibrium process that has been running for ~3.5 billion years.</div><br/></div></div></div></div><div id="36107167" class="c"><input type="checkbox" id="c-36107167" checked=""/><div class="controls bullet"><span class="by">odo1242</span><span>|</span><a href="#36106967">parent</a><span>|</span><a href="#36106983">prev</a><span>|</span><a href="#36106376">next</a><span>|</span><label class="collapse" for="c-36107167">[-]</label><label class="expand" for="c-36107167">[3 more]</label></div><br/><div class="children"><div class="content">Probably Voyager 2. Running since August 20, 1977 - never been rebooted (because good luck doing that)</div><br/><div id="36111407" class="c"><input type="checkbox" id="c-36111407" checked=""/><div class="controls bullet"><span class="by">loicd</span><span>|</span><a href="#36106967">root</a><span>|</span><a href="#36107167">parent</a><span>|</span><a href="#36108480">next</a><span>|</span><label class="collapse" for="c-36111407">[-]</label><label class="expand" for="c-36111407">[1 more]</label></div><br/><div class="children"><div class="content">I think it would make more sense to measure the longest computation in the number of cycles executed rather than in seconds. If I&#x27;m not mistaken, Voyager 2 had a processor running at 4MHz. So a modern 2 GHz processor will execute more cycles in a couple months than a 4MHz processor in 50 years...</div><br/></div></div><div id="36108480" class="c"><input type="checkbox" id="c-36108480" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#36106967">root</a><span>|</span><a href="#36107167">parent</a><span>|</span><a href="#36111407">prev</a><span>|</span><a href="#36106376">next</a><span>|</span><label class="collapse" for="c-36108480">[-]</label><label class="expand" for="c-36108480">[1 more]</label></div><br/><div class="children"><div class="content">Maybe there&#x27;s a clock on Earth with a microcontroller and some kind of UPS or battery backup or large capacitor backup?<p>You could argue that the timekeeping of TAI (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;International_Atomic_Time" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;International_Atomic_Time</a>) could be seen as a distributed computation (where different entities are counting the same value and running manual and automated protocols to keep the value synchronized), and that has been running since 1972. It almost certainly hasn&#x27;t been running continuously on any individual hardware device, but there have always been devices that represented its value and always been efforts to maintain continuity between calculations.<p>Although I guess the same logic could argue for civil timekeeping in <i>any</i> calendar, because people have actively tracked it as &quot;the same computation&quot; and cared about it for centuries or millennia. Maybe the distinctive argument for TAI is that it&#x27;s presumably been continually <i>represented digitally in programmable computers</i> since 1972.</div><br/></div></div></div></div></div></div><div id="36106376" class="c"><input type="checkbox" id="c-36106376" checked=""/><div class="controls bullet"><span class="by">credit_guy</span><span>|</span><a href="#36106967">prev</a><span>|</span><a href="#36106060">next</a><span>|</span><label class="collapse" for="c-36106376">[-]</label><label class="expand" for="c-36106376">[4 more]</label></div><br/><div class="children"><div class="content">This contradicts Murphy’s theorem, that if something can go bad it will go bad with asymptotic probability one.</div><br/><div id="36106433" class="c"><input type="checkbox" id="c-36106433" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#36106376">parent</a><span>|</span><a href="#36106559">next</a><span>|</span><label class="collapse" for="c-36106433">[-]</label><label class="expand" for="c-36106433">[1 more]</label></div><br/><div class="children"><div class="content">I would say it’s consistent since something going bad can often mean halting</div><br/></div></div><div id="36106559" class="c"><input type="checkbox" id="c-36106559" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36106376">parent</a><span>|</span><a href="#36106433">prev</a><span>|</span><a href="#36106457">next</a><span>|</span><label class="collapse" for="c-36106559">[-]</label><label class="expand" for="c-36106559">[1 more]</label></div><br/><div class="children"><div class="content">No, Murphy says that despite having a vanishingly small probability, somebody will toss an undecidable problem into your non-halting oracle.</div><br/></div></div><div id="36106457" class="c"><input type="checkbox" id="c-36106457" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#36106376">parent</a><span>|</span><a href="#36106559">prev</a><span>|</span><a href="#36106060">next</a><span>|</span><label class="collapse" for="c-36106457">[-]</label><label class="expand" for="c-36106457">[1 more]</label></div><br/><div class="children"><div class="content">Well, if the program is operating a business-critical function, then having it halt is bad.</div><br/></div></div></div></div><div id="36106060" class="c"><input type="checkbox" id="c-36106060" checked=""/><div class="controls bullet"><span class="by">isaacfrond</span><span>|</span><a href="#36106376">prev</a><span>|</span><a href="#36107329">next</a><span>|</span><label class="collapse" for="c-36106060">[-]</label><label class="expand" for="c-36106060">[11 more]</label></div><br/><div class="children"><div class="content">The problem is that with probability 1 a random problem will access an undefined memory position. Such program halt by definition.<p>This makes the result a lot less interesting. Sure random programs will typically halt before long, but with an illegal memory access ( in the parlance of the article, they read from the left of the turing tape)</div><br/><div id="36106671" class="c"><input type="checkbox" id="c-36106671" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#36106060">parent</a><span>|</span><a href="#36106338">next</a><span>|</span><label class="collapse" for="c-36106671">[-]</label><label class="expand" for="c-36106671">[1 more]</label></div><br/><div class="children"><div class="content">This is wrong and directly contradicted, unambiguously by the linked paper.<p>&quot;For the purposes of defining the halting problem H, one should specify whether it
officially counts as halting or not if the head should happen to fall off the left edge of the tape. Although the truth of the main theorem will not depend on these details, provided we adopt a uniform answer, let us be definite and regard such computations as having not officially halted, as the halt state was not reached.&quot;</div><br/></div></div><div id="36106338" class="c"><input type="checkbox" id="c-36106338" checked=""/><div class="controls bullet"><span class="by">l33t233372</span><span>|</span><a href="#36106060">parent</a><span>|</span><a href="#36106671">prev</a><span>|</span><a href="#36107329">next</a><span>|</span><label class="collapse" for="c-36106338">[-]</label><label class="expand" for="c-36106338">[9 more]</label></div><br/><div class="children"><div class="content">There is no such notion of “undefined memory region” for a Turing Machine</div><br/><div id="36106385" class="c"><input type="checkbox" id="c-36106385" checked=""/><div class="controls bullet"><span class="by">thelopa</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106338">parent</a><span>|</span><a href="#36107329">next</a><span>|</span><label class="collapse" for="c-36106385">[-]</label><label class="expand" for="c-36106385">[8 more]</label></div><br/><div class="children"><div class="content">Some models of the Turing machine have an infinite tape in only one direction. Some also don’t require every state to have an exhaustive set of transitions. Those models generally consider going off the end of the tape or failing to find a transition to be a halting state.</div><br/><div id="36106683" class="c"><input type="checkbox" id="c-36106683" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106385">parent</a><span>|</span><a href="#36106420">next</a><span>|</span><label class="collapse" for="c-36106683">[-]</label><label class="expand" for="c-36106683">[1 more]</label></div><br/><div class="children"><div class="content">The paper makes explicit how this is dealt with:<p>&gt; For the purposes of defining the halting problem H, one should specify whether it officially counts as halting or not if the head should happen to fall off the left edge of the tape. Although the truth of the main theorem will not depend on these details, provided we adopt a uniform answer, let us be definite and regard such computations as having not officially halted, as the halt state was not reached.</div><br/></div></div><div id="36106420" class="c"><input type="checkbox" id="c-36106420" checked=""/><div class="controls bullet"><span class="by">l33t233372</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106385">parent</a><span>|</span><a href="#36106683">prev</a><span>|</span><a href="#36106679">next</a><span>|</span><label class="collapse" for="c-36106420">[-]</label><label class="expand" for="c-36106420">[5 more]</label></div><br/><div class="children"><div class="content">It’s unclear to me why restricting ourselves to that model is useful here</div><br/><div id="36106484" class="c"><input type="checkbox" id="c-36106484" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106420">parent</a><span>|</span><a href="#36106615">next</a><span>|</span><label class="collapse" for="c-36106484">[-]</label><label class="expand" for="c-36106484">[2 more]</label></div><br/><div class="children"><div class="content">Changing the model wouldn&#x27;t change anything. A turing machine is equivalent to any computational machine you want to put in there. It doesn&#x27;t matter what the machine is. The turing machine is the goto because it was first used for them.<p>Any other machine that can simulate a turing machine can simulate failing in those same ways. You can&#x27;t escape the problems of turing completeness without losing it.</div><br/><div id="36106643" class="c"><input type="checkbox" id="c-36106643" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106484">parent</a><span>|</span><a href="#36106615">next</a><span>|</span><label class="collapse" for="c-36106643">[-]</label><label class="expand" for="c-36106643">[1 more]</label></div><br/><div class="children"><div class="content">It does matter, the second and last sentence of the abstract is &quot;The proof is sensitive to the particular computational models.&quot;</div><br/></div></div></div></div><div id="36106615" class="c"><input type="checkbox" id="c-36106615" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106420">parent</a><span>|</span><a href="#36106484">prev</a><span>|</span><a href="#36106679">next</a><span>|</span><label class="collapse" for="c-36106615">[-]</label><label class="expand" for="c-36106615">[2 more]</label></div><br/><div class="children"><div class="content">It’s the simplest model which can simulate <i>all</i> useful models of computation we have so far.<p>So, if you want to prove something about the limits of computation, a Turing machine is usually the right choice.</div><br/><div id="36110215" class="c"><input type="checkbox" id="c-36110215" checked=""/><div class="controls bullet"><span class="by">l33t233372</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106615">parent</a><span>|</span><a href="#36106679">next</a><span>|</span><label class="collapse" for="c-36110215">[-]</label><label class="expand" for="c-36110215">[1 more]</label></div><br/><div class="children"><div class="content">I was referring to the instantiation of a TM as having a one sided tape.</div><br/></div></div></div></div></div></div><div id="36106679" class="c"><input type="checkbox" id="c-36106679" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#36106060">root</a><span>|</span><a href="#36106385">parent</a><span>|</span><a href="#36106420">prev</a><span>|</span><a href="#36107329">next</a><span>|</span><label class="collapse" for="c-36106679">[-]</label><label class="expand" for="c-36106679">[1 more]</label></div><br/><div class="children"><div class="content">It is true that some models define halting that way, but in this paper they explicitly do not.</div><br/></div></div></div></div></div></div></div></div><div id="36107329" class="c"><input type="checkbox" id="c-36107329" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36106060">prev</a><span>|</span><label class="collapse" for="c-36107329">[-]</label><label class="expand" for="c-36107329">[7 more]</label></div><br/><div class="children"><div class="content">No one talks about the fact that the halting problem has been solved for linear bounded automata.</div><br/><div id="36107561" class="c"><input type="checkbox" id="c-36107561" checked=""/><div class="controls bullet"><span class="by">russdill</span><span>|</span><a href="#36107329">parent</a><span>|</span><a href="#36110880">next</a><span>|</span><label class="collapse" for="c-36107561">[-]</label><label class="expand" for="c-36107561">[5 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s immediately obvious that for anything with a finite number of states determining if it runs forever is &quot;trivial&quot; as running it until it either repeats a state or halts which will always occur in finite time.</div><br/><div id="36108438" class="c"><input type="checkbox" id="c-36108438" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#36107329">root</a><span>|</span><a href="#36107561">parent</a><span>|</span><a href="#36108089">next</a><span>|</span><label class="collapse" for="c-36108438">[-]</label><label class="expand" for="c-36108438">[3 more]</label></div><br/><div class="children"><div class="content">Uh, yeah, but my PC with 96GB of memory has quite some  possible states.<p>So, most likely, the <i>real</i> reason nobody is interested is that the numbers are too large.</div><br/><div id="36110632" class="c"><input type="checkbox" id="c-36110632" checked=""/><div class="controls bullet"><span class="by">russdill</span><span>|</span><a href="#36107329">root</a><span>|</span><a href="#36108438">parent</a><span>|</span><a href="#36108747">next</a><span>|</span><label class="collapse" for="c-36110632">[-]</label><label class="expand" for="c-36110632">[1 more]</label></div><br/><div class="children"><div class="content">If your computer had 4k of memory, it&#x27;d be too many states to keep track of</div><br/></div></div><div id="36108747" class="c"><input type="checkbox" id="c-36108747" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36107329">root</a><span>|</span><a href="#36108438">parent</a><span>|</span><a href="#36110632">prev</a><span>|</span><a href="#36108089">next</a><span>|</span><label class="collapse" for="c-36108747">[-]</label><label class="expand" for="c-36108747">[1 more]</label></div><br/><div class="children"><div class="content">Well the trick is knowing which states to keep track of.</div><br/></div></div></div></div><div id="36108089" class="c"><input type="checkbox" id="c-36108089" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#36107329">root</a><span>|</span><a href="#36107561">parent</a><span>|</span><a href="#36108438">prev</a><span>|</span><a href="#36110880">next</a><span>|</span><label class="collapse" for="c-36108089">[-]</label><label class="expand" for="c-36108089">[1 more]</label></div><br/><div class="children"><div class="content">Right, why are there so few total languages then?</div><br/></div></div></div></div><div id="36110880" class="c"><input type="checkbox" id="c-36110880" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#36107329">parent</a><span>|</span><a href="#36107561">prev</a><span>|</span><label class="collapse" for="c-36110880">[-]</label><label class="expand" for="c-36110880">[1 more]</label></div><br/><div class="children"><div class="content">When you say no one talks about it, isn&#x27;t that what Turing means when he says:<p><pre><code>    The fallacy in this argument lies in the assumption that Beta is computable. It would be true if we could enumerate the computable sequences by finite means, but the problem of enumerating computable sequences is equivalent to the problem of finding out whether a given number is the D.N of a circle-free machine, and we have no general process for doing this in a finite number of steps.[1]
</code></pre>
In an LBA can&#x27;t we always enumerate the computable sequences by finite
means?<p>[1] On computable numbers <a href="https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~robins&#x2F;Turing_Paper_1936.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~robins&#x2F;Turing_Paper_1936.pdf</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>