<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709888451440" as="style"/><link rel="stylesheet" href="styles.css?v=1709888451440"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://androidcalculator.com/how-do-calculators-compute-sine/">How do computers calculate sine?</a> <span class="domain">(<a href="https://androidcalculator.com">androidcalculator.com</a>)</span></div><div class="subtext"><span>vegesm</span> | <span>135 comments</span></div><br/><div><div id="39636258" class="c"><input type="checkbox" id="c-39636258" checked=""/><div class="controls bullet"><span class="by">staplung</span><span>|</span><a href="#39633574">next</a><span>|</span><label class="collapse" for="c-39636258">[-]</label><label class="expand" for="c-39636258">[14 more]</label></div><br/><div class="children"><div class="content">I recently learned how Doom was ported to the SNES. It&#x27;s quite impressive. The SNES hardware was nowhere near fast enough to do all the trig calculations needed for the game but cartridge based games had a trick up their sleeve: they could include actual hardware <i>inside the cart</i> that the game code could make use of. It was more expensive but if you expected to sell a boatload of copies, it could be worth it. However, even using extra hardware wasn&#x27;t enough in this case. So they pre-calculated lookup tables for sine, cosine, tangent etc. for every angle at the necessary precision. They were helped by the fact that the game resolution in this case was fairly low.<p>If you&#x27;re interested, you can peruse the C code that was used to generate the tables. Here&#x27;s the file for sine&#x2F;cosine:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;RandalLinden&#x2F;DOOM-FX&#x2F;blob&#x2F;master&#x2F;source&#x2F;mksin.c">https:&#x2F;&#x2F;github.com&#x2F;RandalLinden&#x2F;DOOM-FX&#x2F;blob&#x2F;master&#x2F;source&#x2F;m...</a></div><br/><div id="39639061" class="c"><input type="checkbox" id="c-39639061" checked=""/><div class="controls bullet"><span class="by">tdudhhu</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39637064">next</a><span>|</span><label class="collapse" for="c-39639061">[-]</label><label class="expand" for="c-39639061">[3 more]</label></div><br/><div class="children"><div class="content">Once I tested lookup tables for a path tracer (ray tracer).<p>It is interesting that you can get very decent results even with low quality tables. Of course there will be artifacts but due to the randomness of a path tracer this is not always very noticeable.</div><br/><div id="39639192" class="c"><input type="checkbox" id="c-39639192" checked=""/><div class="controls bullet"><span class="by">ImHereToVote</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39639061">parent</a><span>|</span><a href="#39637064">next</a><span>|</span><label class="collapse" for="c-39639192">[-]</label><label class="expand" for="c-39639192">[2 more]</label></div><br/><div class="children"><div class="content">I always wonder when hearing about these old optimizations why they aren&#x27;t used in contemporary code. Wouldn&#x27;t you want to squeeze every bit of performance even on modern hardware?</div><br/><div id="39639254" class="c"><input type="checkbox" id="c-39639254" checked=""/><div class="controls bullet"><span class="by">lkschubert8</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39639192">parent</a><span>|</span><a href="#39637064">next</a><span>|</span><label class="collapse" for="c-39639254">[-]</label><label class="expand" for="c-39639254">[1 more]</label></div><br/><div class="children"><div class="content">Doing so costs time&#x2F;wage dollars.</div><br/></div></div></div></div></div></div><div id="39637064" class="c"><input type="checkbox" id="c-39637064" checked=""/><div class="controls bullet"><span class="by">pillusmany</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39639061">prev</a><span>|</span><a href="#39637980">next</a><span>|</span><label class="collapse" for="c-39637064">[-]</label><label class="expand" for="c-39637064">[4 more]</label></div><br/><div class="children"><div class="content">Games targetting pre-Pentium PCs also used precomputed trig tables.<p>Pentium was fast enough that it didn&#x27;t matter as much.<p>Just a few years later it was slower to read a trig precomputed table.</div><br/><div id="39637385" class="c"><input type="checkbox" id="c-39637385" checked=""/><div class="controls bullet"><span class="by">BD103</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39637064">parent</a><span>|</span><a href="#39637237">next</a><span>|</span><label class="collapse" for="c-39637385">[-]</label><label class="expand" for="c-39637385">[2 more]</label></div><br/><div class="children"><div class="content">Yup, I remember watching a video about how the RAM bus is the bottleneck when running Super Mario 64 on the N64. The original implementation used trig lookup tables, but the person optimized it by instead using Taylor series (I think) and some negation &#x2F; shifting.</div><br/><div id="39637572" class="c"><input type="checkbox" id="c-39637572" checked=""/><div class="controls bullet"><span class="by">Polycryptus</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39637385">parent</a><span>|</span><a href="#39637237">next</a><span>|</span><label class="collapse" for="c-39637572">[-]</label><label class="expand" for="c-39637572">[1 more]</label></div><br/><div class="children"><div class="content">For anyone curious, the video:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;xFKFoGiGlXQ" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;xFKFoGiGlXQ</a></div><br/></div></div></div></div><div id="39637237" class="c"><input type="checkbox" id="c-39637237" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39637064">parent</a><span>|</span><a href="#39637385">prev</a><span>|</span><a href="#39637980">next</a><span>|</span><label class="collapse" for="c-39637237">[-]</label><label class="expand" for="c-39637237">[1 more]</label></div><br/><div class="children"><div class="content">in other words, for those of us who remember, they used the equivalent of a slide rule</div><br/></div></div></div></div><div id="39637980" class="c"><input type="checkbox" id="c-39637980" checked=""/><div class="controls bullet"><span class="by">mads</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39637064">prev</a><span>|</span><a href="#39638783">next</a><span>|</span><label class="collapse" for="c-39637980">[-]</label><label class="expand" for="c-39637980">[1 more]</label></div><br/><div class="children"><div class="content">Back in the 80&#x27;s, when I made demos on the C64, we also used pre-calculated sines. I remember going to the library to get a book with the values.</div><br/></div></div><div id="39638783" class="c"><input type="checkbox" id="c-39638783" checked=""/><div class="controls bullet"><span class="by">hakuseki</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39637980">prev</a><span>|</span><a href="#39637326">next</a><span>|</span><label class="collapse" for="c-39638783">[-]</label><label class="expand" for="c-39638783">[2 more]</label></div><br/><div class="children"><div class="content">&gt; However, even using extra hardware wasn&#x27;t enough in this case. So they pre-calculated lookup tables for sine, cosine, tangent etc. for every angle at the necessary precision.<p>Is this really the order of events? I imagine the pre-calculated route is what you&#x27;d try first, and only go for extra hardware if that failed somehow.</div><br/><div id="39638939" class="c"><input type="checkbox" id="c-39638939" checked=""/><div class="controls bullet"><span class="by">shzhdbi09gv8ioi</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39638783">parent</a><span>|</span><a href="#39637326">next</a><span>|</span><label class="collapse" for="c-39638939">[-]</label><label class="expand" for="c-39638939">[1 more]</label></div><br/><div class="children"><div class="content">Lookup tables were commonplace in 80s-90s graphics programming. It should have been used before any consideration of custom hardware solutions.</div><br/></div></div></div></div><div id="39637326" class="c"><input type="checkbox" id="c-39637326" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39638783">prev</a><span>|</span><a href="#39638035">next</a><span>|</span><label class="collapse" for="c-39637326">[-]</label><label class="expand" for="c-39637326">[1 more]</label></div><br/><div class="children"><div class="content">It turns out that SNES DOOM missed out on a big optimization that people figured out later on.  If you use the SNES&#x27;s Mosaic feature combined with scrolling tricks, you can nearly double the fill rate.  Rather than outputting two pixels, you let the SNES&#x27;s mosaic hardware do the pixel doubling.</div><br/></div></div><div id="39638035" class="c"><input type="checkbox" id="c-39638035" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39636258">parent</a><span>|</span><a href="#39637326">prev</a><span>|</span><a href="#39633574">next</a><span>|</span><label class="collapse" for="c-39638035">[-]</label><label class="expand" for="c-39638035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; […] pre-calculated lookup tables […]<p>The approach is older than that. I remember my grandfather&#x27;s engineering books from 1950&#x27;s – nearly each of them had a large addendum with the said pre-calculated sine, cosine, tangent and logarithm lookup tables. And there was at least one book that only had such tables and no other information.<p>That is how engineers used to calculate before the advent of computers.</div><br/><div id="39639055" class="c"><input type="checkbox" id="c-39639055" checked=""/><div class="controls bullet"><span class="by">aoanla</span><span>|</span><a href="#39636258">root</a><span>|</span><a href="#39638035">parent</a><span>|</span><a href="#39633574">next</a><span>|</span><label class="collapse" for="c-39639055">[-]</label><label class="expand" for="c-39639055">[1 more]</label></div><br/><div class="children"><div class="content">The classic of this field of books is Abramowitz and Stegun&#x27;s &quot;Handbook of Mathematical Functions&quot; - although the two listed names are merely those of the compilation editors, as the calculations of the numerous tables of values (and sheets of mathematical identities) required hundreds of human computers operating for years. 
Ironically, on publication in 1964 it was just in time to see the dawn of the electronic computer age that would supplant it.</div><br/></div></div></div></div></div></div><div id="39633574" class="c"><input type="checkbox" id="c-39633574" checked=""/><div class="controls bullet"><span class="by">warpech</span><span>|</span><a href="#39636258">prev</a><span>|</span><a href="#39633966">next</a><span>|</span><label class="collapse" for="c-39633574">[-]</label><label class="expand" for="c-39633574">[58 more]</label></div><br/><div class="children"><div class="content">This made me realize that trigonometric functions are not deterministic across different CPU architectures, OS, and programming languages (floating point precision aside).<p>E.g. I would assume that Math.sin(x) returns the same thing in NodeJS on Windows and Mac&#x2F;M1, but it turns out it is necessarily so. 
 <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;74074312&#x2F;standard-math-functions-reproducibility-on-different-cpus" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;74074312&#x2F;standard-math-f...</a></div><br/><div id="39634680" class="c"><input type="checkbox" id="c-39634680" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39636927">next</a><span>|</span><label class="collapse" for="c-39634680">[-]</label><label class="expand" for="c-39634680">[4 more]</label></div><br/><div class="children"><div class="content">Rounding transcendentals correctly has unknown time and space complexity. [1]  Sort of brushes up against the halting problem.  With limited precision, the upper limit becomes calculable but it&#x27;s rather large - packages that offer correct rounding on 64-bit floating point use potentially hundreds of bytes to deal with a single floating point value.  Dedicated circuitry to implement it fast would be big and complicated even by today&#x27;s standards.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rounding#Table-maker&#x27;s_dilemma" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rounding#Table-maker&#x27;s_dilemma</a></div><br/><div id="39636172" class="c"><input type="checkbox" id="c-39636172" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634680">parent</a><span>|</span><a href="#39639214">next</a><span>|</span><label class="collapse" for="c-39636172">[-]</label><label class="expand" for="c-39636172">[1 more]</label></div><br/><div class="children"><div class="content">True in general, almost false for binary64. Important univariate functions have been thoroughly mapped for known hard-to-round cases, which resulted in the fact that we only need at most triple-double format to do the correct rounding. (Bivariate functions like `pow` are much harder, and not yet fully mapped as of this writing.) As a result we now have a mathematical library that almost ensures correct rounding [1], and a further optimization is currently in progress.<p>[1] <a href="https:&#x2F;&#x2F;core-math.gitlabpages.inria.fr&#x2F;" rel="nofollow">https:&#x2F;&#x2F;core-math.gitlabpages.inria.fr&#x2F;</a></div><br/></div></div><div id="39639214" class="c"><input type="checkbox" id="c-39639214" checked=""/><div class="controls bullet"><span class="by">ImHereToVote</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634680">parent</a><span>|</span><a href="#39636172">prev</a><span>|</span><a href="#39636644">next</a><span>|</span><label class="collapse" for="c-39639214">[-]</label><label class="expand" for="c-39639214">[1 more]</label></div><br/><div class="children"><div class="content">Why should just use analog circuit for this sort of thing where the exact precision doesn&#x27;t matter.</div><br/></div></div><div id="39636644" class="c"><input type="checkbox" id="c-39636644" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634680">parent</a><span>|</span><a href="#39639214">prev</a><span>|</span><a href="#39636927">next</a><span>|</span><label class="collapse" for="c-39636644">[-]</label><label class="expand" for="c-39636644">[1 more]</label></div><br/><div class="children"><div class="content">unknown time and space complexity<p>True in general but for the basic datatypes sent through hardware regusters your processor architecture has fixed precision.  So the time and space complexity is O(1)</div><br/></div></div></div></div><div id="39636927" class="c"><input type="checkbox" id="c-39636927" checked=""/><div class="controls bullet"><span class="by">Arelius</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39634680">prev</a><span>|</span><a href="#39633877">next</a><span>|</span><label class="collapse" for="c-39636927">[-]</label><label class="expand" for="c-39636927">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but you&#x27;d be surprised at how frequently they appear to be the same. I once worked on a HTML5 game that that relied on deterministic simulation for networking. And it wasn&#x27;t untill pretty late in development that a build of Chrome shipped on some platform that finally triggered a desync in our extensive cross-platform test suite.<p>We implemented a deterministic approximation, and moved on. But I learned something important about trig functions that day.</div><br/></div></div><div id="39633877" class="c"><input type="checkbox" id="c-39633877" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39636927">prev</a><span>|</span><a href="#39634117">next</a><span>|</span><label class="collapse" for="c-39633877">[-]</label><label class="expand" for="c-39633877">[16 more]</label></div><br/><div class="children"><div class="content">Well, what&#x27;s fun is that (AFAIK) trigonometric functions tend not to be implemented in the newer floating point instructions, such as AVX or SSE.<p>So while what you say is true about the x87 implementation of those functions, for anything targeting a machine built in the last 20 years it&#x27;s likely the code will run consistently regardless the architecture (barring architecture floating point bugs, which aren&#x27;t terribly uncommon in the less significant bits and when overclocking comes into play).<p>x86 compilers won&#x27;t use x87 instructions when SSE2 and later are available.  x87 is just a really weird and funky instruction set that&#x27;s best left in the gutter of history.</div><br/><div id="39634029" class="c"><input type="checkbox" id="c-39634029" checked=""/><div class="controls bullet"><span class="by">bnprks</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633877">parent</a><span>|</span><a href="#39638560">next</a><span>|</span><label class="collapse" for="c-39634029">[-]</label><label class="expand" for="c-39634029">[7 more]</label></div><br/><div class="children"><div class="content">Sadly even SSE vs. AVX is enough to often give different results, as SSE doesn&#x27;t have support for fused multiply-add instructions which allow calculation of a*b + c with guaranteed correct rounding. Even though this should allow CPUs from 2013 and later to all use FMA, gcc&#x2F;clang don&#x27;t enable AVX by default for the x86-64 targets. And even if they did, results are only guaranteed identical if implementations have chosen the exact same polynomial approximation method and no compiler optimizations alter the instruction sequence.<p>Unfortunately, floating point results will probably continue to differ across platforms for the foreseeable future.</div><br/><div id="39634115" class="c"><input type="checkbox" id="c-39634115" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634029">parent</a><span>|</span><a href="#39634216">next</a><span>|</span><label class="collapse" for="c-39634115">[-]</label><label class="expand" for="c-39634115">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a bit of a different problem IMO.<p>Barring someone doing a &quot;check if AVX is available&quot; check inside their code, binaries are generally compiled targeting either SSE or AVX and not both.  You can reasonably expect that the same binary thrown against multiple architectures will have the same output.<p>This, of course, doesn&#x27;t apply if we are talking about a JIT.  All bets are off if you are talking about javascript or the JVM.<p>That is to say, you can expect that a C++ binary blob from the Ubuntu repo is going to get the same numbers regardless the machine since they generally will target fairly old architectures.</div><br/><div id="39634695" class="c"><input type="checkbox" id="c-39634695" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634115">parent</a><span>|</span><a href="#39634216">next</a><span>|</span><label class="collapse" for="c-39634695">[-]</label><label class="expand" for="c-39634695">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Barring someone doing a &quot;check if AVX is available&quot; check inside their code<p>Afaik that is exactly what glibc does internally</div><br/></div></div></div></div><div id="39634216" class="c"><input type="checkbox" id="c-39634216" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634029">parent</a><span>|</span><a href="#39634115">prev</a><span>|</span><a href="#39638560">next</a><span>|</span><label class="collapse" for="c-39634216">[-]</label><label class="expand" for="c-39634216">[4 more]</label></div><br/><div class="children"><div class="content">GCC won&#x27;t use FMA without fast-math though. Even when AVX is otherwise enabled.</div><br/><div id="39634273" class="c"><input type="checkbox" id="c-39634273" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634216">parent</a><span>|</span><a href="#39638560">next</a><span>|</span><label class="collapse" for="c-39634273">[-]</label><label class="expand" for="c-39634273">[3 more]</label></div><br/><div class="children"><div class="content">Sure it will:<p>&gt; -ffp-contract=fast enables floating-point expression contraction such as forming of fused multiply-add operations if the target has native support for them<p>&gt; The default is -ffp-contract=off for C in a standards compliant mode (-std=c11 or similar), -ffp-contract=fast otherwise.<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Optimize-Options.html#index-ffp-contract" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Optimize-Options.html#ind...</a></div><br/><div id="39634998" class="c"><input type="checkbox" id="c-39634998" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634273">parent</a><span>|</span><a href="#39638560">next</a><span>|</span><label class="collapse" for="c-39634998">[-]</label><label class="expand" for="c-39634998">[2 more]</label></div><br/><div class="children"><div class="content">Oh, wow, forgot about fp-contract. It says it is off in C by default, what about C++?</div><br/><div id="39635088" class="c"><input type="checkbox" id="c-39635088" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634998">parent</a><span>|</span><a href="#39638560">next</a><span>|</span><label class="collapse" for="c-39635088">[-]</label><label class="expand" for="c-39635088">[1 more]</label></div><br/><div class="children"><div class="content">Read closer, it defaults to fast, not off</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39638560" class="c"><input type="checkbox" id="c-39638560" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633877">parent</a><span>|</span><a href="#39634029">prev</a><span>|</span><a href="#39633974">next</a><span>|</span><label class="collapse" for="c-39638560">[-]</label><label class="expand" for="c-39638560">[1 more]</label></div><br/><div class="children"><div class="content">What about GPU ISAs?</div><br/></div></div><div id="39634260" class="c"><input type="checkbox" id="c-39634260" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633877">parent</a><span>|</span><a href="#39633974">prev</a><span>|</span><a href="#39634161">next</a><span>|</span><label class="collapse" for="c-39634260">[-]</label><label class="expand" for="c-39634260">[5 more]</label></div><br/><div class="children"><div class="content">&gt; x87 is just a really weird and funky instruction set that&#x27;s best left in the gutter of history<p>hmmm, can you use the long doubles in sse or avx?  They are glorious, and as far as I see from playing with godbolt, they still require dirtying your hands with the x87 stack.</div><br/><div id="39634457" class="c"><input type="checkbox" id="c-39634457" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634260">parent</a><span>|</span><a href="#39634161">next</a><span>|</span><label class="collapse" for="c-39634457">[-]</label><label class="expand" for="c-39634457">[4 more]</label></div><br/><div class="children"><div class="content">The 80bit float?  Not as far as I&#x27;m aware.  However, it&#x27;s fairly trivial to represent a 127bit float with 2 64bit floats.  And with the nature of AVX&#x2F;SSE, you don&#x27;t really take much of a performance hit for doing that as you are often operating on both parts of the double with the same instruction.</div><br/><div id="39634618" class="c"><input type="checkbox" id="c-39634618" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634457">parent</a><span>|</span><a href="#39634161">next</a><span>|</span><label class="collapse" for="c-39634618">[-]</label><label class="expand" for="c-39634618">[3 more]</label></div><br/><div class="children"><div class="content">Do you know if there&#x27;s language support for that?  Are there obscure gcc options that make &quot;long double&quot; be quadruple precision floats?</div><br/><div id="39634731" class="c"><input type="checkbox" id="c-39634731" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634618">parent</a><span>|</span><a href="#39634685">next</a><span>|</span><label class="collapse" for="c-39634731">[-]</label><label class="expand" for="c-39634731">[1 more]</label></div><br/><div class="children"><div class="content">You can just use standard C _Float128 type <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Floating-Types.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Floating-Types.html</a></div><br/></div></div><div id="39634685" class="c"><input type="checkbox" id="c-39634685" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634618">parent</a><span>|</span><a href="#39634731">prev</a><span>|</span><a href="#39634161">next</a><span>|</span><label class="collapse" for="c-39634685">[-]</label><label class="expand" for="c-39634685">[1 more]</label></div><br/><div class="children"><div class="content">Which language?<p>For C++, there&#x27;s this: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;floating-point" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;floating-point</a></div><br/></div></div></div></div></div></div></div></div><div id="39634161" class="c"><input type="checkbox" id="c-39634161" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633877">parent</a><span>|</span><a href="#39634260">prev</a><span>|</span><a href="#39634117">next</a><span>|</span><label class="collapse" for="c-39634161">[-]</label><label class="expand" for="c-39634161">[1 more]</label></div><br/><div class="children"><div class="content">They do, however, have some intrinsics for trig functions in AVX in their compilers. Not as good as having an instruction of course.</div><br/></div></div></div></div><div id="39637227" class="c"><input type="checkbox" id="c-39637227" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39634117">prev</a><span>|</span><a href="#39633730">next</a><span>|</span><label class="collapse" for="c-39637227">[-]</label><label class="expand" for="c-39637227">[1 more]</label></div><br/><div class="children"><div class="content">&gt; deterministic<p>I would use the word &quot;consistent.&quot;<p>Non-determinism implies randomness.</div><br/></div></div><div id="39633730" class="c"><input type="checkbox" id="c-39633730" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39637227">prev</a><span>|</span><a href="#39634002">next</a><span>|</span><label class="collapse" for="c-39633730">[-]</label><label class="expand" for="c-39633730">[26 more]</label></div><br/><div class="children"><div class="content">Safer to assume that floats are never deterministic.</div><br/><div id="39634000" class="c"><input type="checkbox" id="c-39634000" checked=""/><div class="controls bullet"><span class="by">jacobolus</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39634335">next</a><span>|</span><label class="collapse" for="c-39634000">[-]</label><label class="expand" for="c-39634000">[8 more]</label></div><br/><div class="children"><div class="content">Floats follow a clear specification which determines precisely how basic arithmetic should work. They should work the same on all popular modern platforms. (Whether specific software libraries are the same is a separate question.)</div><br/><div id="39634150" class="c"><input type="checkbox" id="c-39634150" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634000">parent</a><span>|</span><a href="#39634335">next</a><span>|</span><label class="collapse" for="c-39634150">[-]</label><label class="expand" for="c-39634150">[7 more]</label></div><br/><div class="children"><div class="content">But transcendentals like sine are not part of the strictly defined basic arithmetic; they are intentionally defined with relaxed behavior.</div><br/><div id="39634900" class="c"><input type="checkbox" id="c-39634900" checked=""/><div class="controls bullet"><span class="by">jacobolus</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634150">parent</a><span>|</span><a href="#39634279">next</a><span>|</span><label class="collapse" for="c-39634900">[-]</label><label class="expand" for="c-39634900">[4 more]</label></div><br/><div class="children"><div class="content">If you implement sine in software using the same sequence of basic arithmetic instructions, the result should be the same across platforms. If you make two different implementations using different arithmetic, then of course you can&#x27;t rely on them being the same.</div><br/><div id="39635073" class="c"><input type="checkbox" id="c-39635073" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634900">parent</a><span>|</span><a href="#39634279">next</a><span>|</span><label class="collapse" for="c-39635073">[-]</label><label class="expand" for="c-39635073">[3 more]</label></div><br/><div class="children"><div class="content">Point being that IEEE 754 defines two sets of operations, the required operations (section 5) that should be produce correctly rounded results to the last digit, and recommend operations (section 9) with relaxed requirements. And sine belongs to the latter section, so IEEE 754 does not mandate reproducible results for sine.</div><br/><div id="39635129" class="c"><input type="checkbox" id="c-39635129" checked=""/><div class="controls bullet"><span class="by">jacobolus</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635073">parent</a><span>|</span><a href="#39634279">next</a><span>|</span><label class="collapse" for="c-39635129">[-]</label><label class="expand" for="c-39635129">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that most software always uses some software implementation of sine, rather than calling a hardware instruction. Which is definitely what you should do if you care about getting the exact same results across platforms.</div><br/><div id="39636484" class="c"><input type="checkbox" id="c-39636484" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635129">parent</a><span>|</span><a href="#39634279">next</a><span>|</span><label class="collapse" for="c-39636484">[-]</label><label class="expand" for="c-39636484">[1 more]</label></div><br/><div class="children"><div class="content">Software implementations can and do differ (even dynamically) based on the hardware though - e.g. glibc&#x27;s sin(x) function, what C code will end up using (if not other languages relying on the C stdlib), uses FMA instructions on my CPU, and thus the exact same binary on the exact same OS with the exact same glibc should behave differently on a very old CPU without FMA where it should have a different implementation (as generally things using FMA cannot be exactly ported to hardware without it without a gigantic drop in performance which&#x27;d be extremely unacceptable).</div><br/></div></div></div></div></div></div></div></div><div id="39634279" class="c"><input type="checkbox" id="c-39634279" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634150">parent</a><span>|</span><a href="#39634900">prev</a><span>|</span><a href="#39634335">next</a><span>|</span><label class="collapse" for="c-39634279">[-]</label><label class="expand" for="c-39634279">[2 more]</label></div><br/><div class="children"><div class="content">Even there many standard libraries provide very good precision at least within sane domain.</div><br/><div id="39634316" class="c"><input type="checkbox" id="c-39634316" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634279">parent</a><span>|</span><a href="#39634335">next</a><span>|</span><label class="collapse" for="c-39634316">[-]</label><label class="expand" for="c-39634316">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that’s kind of my point. 99% consistent isn’t.</div><br/></div></div></div></div></div></div></div></div><div id="39634335" class="c"><input type="checkbox" id="c-39634335" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39634000">prev</a><span>|</span><a href="#39634038">next</a><span>|</span><label class="collapse" for="c-39634335">[-]</label><label class="expand" for="c-39634335">[8 more]</label></div><br/><div class="children"><div class="content">This is not always a safe assumption (in certain scenarios floating point results being nondeterministic has the possibility to introduce bugs and security issues) and is also a kind of sad way to look at the world. The response to &quot;I don&#x27;t understand how this works&quot; should not be to adopt an incorrect viewpoint, but to know the limitations of your understanding.</div><br/><div id="39638944" class="c"><input type="checkbox" id="c-39638944" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634335">parent</a><span>|</span><a href="#39634550">next</a><span>|</span><label class="collapse" for="c-39638944">[-]</label><label class="expand" for="c-39638944">[1 more]</label></div><br/><div class="children"><div class="content">Irrational numbers cannot have an exact representation in digital bits. (Computers use rational numbers with modular arithmetic under the hood.)</div><br/></div></div><div id="39634550" class="c"><input type="checkbox" id="c-39634550" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634335">parent</a><span>|</span><a href="#39638944">prev</a><span>|</span><a href="#39634038">next</a><span>|</span><label class="collapse" for="c-39634550">[-]</label><label class="expand" for="c-39634550">[6 more]</label></div><br/><div class="children"><div class="content">It’s not that I don’t understand, it’s that I do. Floats are inherently lossy representations. Yes, this means the more operations you perform on a float input, the fuzzier the value is.You ignore that harsh reality at <i>your</i> peril.  If you find engineering rigor sad, I don’t know what to tell you.</div><br/><div id="39634694" class="c"><input type="checkbox" id="c-39634694" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634550">parent</a><span>|</span><a href="#39634795">next</a><span>|</span><label class="collapse" for="c-39634694">[-]</label><label class="expand" for="c-39634694">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Floats are not deterministic&quot; is not engineering rigor, it&#x27;s just wrong. They are specified precisely by IEEE-754 in how they must behave and which operations are allowed to produce which results.</div><br/><div id="39634763" class="c"><input type="checkbox" id="c-39634763" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634694">parent</a><span>|</span><a href="#39634795">next</a><span>|</span><label class="collapse" for="c-39634763">[-]</label><label class="expand" for="c-39634763">[2 more]</label></div><br/><div class="children"><div class="content">IEEE 754 conforming floats conform to IEEE-754. If they actually conform. Low end devices with shitty software implementations often get the hard edge cases wrong.</div><br/><div id="39634793" class="c"><input type="checkbox" id="c-39634793" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634763">parent</a><span>|</span><a href="#39634795">next</a><span>|</span><label class="collapse" for="c-39634793">[-]</label><label class="expand" for="c-39634793">[1 more]</label></div><br/><div class="children"><div class="content">Yes and when that happens it is important to know what went wrong rather than just handwaving &quot;oh it&#x27;s that float stuff again I can&#x27;t trust it&quot;.</div><br/></div></div></div></div></div></div><div id="39634795" class="c"><input type="checkbox" id="c-39634795" checked=""/><div class="controls bullet"><span class="by">jacobolus</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634550">parent</a><span>|</span><a href="#39634694">prev</a><span>|</span><a href="#39634038">next</a><span>|</span><label class="collapse" for="c-39634795">[-]</label><label class="expand" for="c-39634795">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the more operations you perform on a float input, the fuzzier the value is</i><p>No, any float always precisely represents a specific number. The issue is that only a finite number of numbers are representable.<p>Some algorithms are poorly conditioned and when implemented using floating point arithmetic will lead to a result that is different than what you would get in idealized real number arithmetic. That doesn&#x27;t make any floating point value &quot;fuzzy&quot;.</div><br/><div id="39638459" class="c"><input type="checkbox" id="c-39638459" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634795">parent</a><span>|</span><a href="#39634038">next</a><span>|</span><label class="collapse" for="c-39638459">[-]</label><label class="expand" for="c-39638459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No, any float always precisely represents a specific number. The issue is that only a finite number of numbers are representable.<p>A float always precisely represents a specific number, but that number is not always precisely the equal to the algebraic result of the operations performed (even when ignoring transcendental and irrational functions).  This should be obvious since there is no limit to rational numbers, but finite floating point numbers.<p>If you design your algorithms very carefully, you can end up with the ratio of the output of your algorithm to the ratio of the algebraic result close to unity over a wide domain of inputs.</div><br/></div></div></div></div></div></div></div></div><div id="39634038" class="c"><input type="checkbox" id="c-39634038" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39634335">prev</a><span>|</span><a href="#39635931">next</a><span>|</span><label class="collapse" for="c-39634038">[-]</label><label class="expand" for="c-39634038">[1 more]</label></div><br/><div class="children"><div class="content">Floats are well defined, and it is perfectly possible to reason about how algorithms based on them should behave. Few languages specify the accuracy of things like trig functions, so relying on them can be tricky, and JavaScript is particularly bad in that respect.</div><br/></div></div><div id="39635931" class="c"><input type="checkbox" id="c-39635931" checked=""/><div class="controls bullet"><span class="by">throwway120385</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39634038">prev</a><span>|</span><a href="#39635741">next</a><span>|</span><label class="collapse" for="c-39635931">[-]</label><label class="expand" for="c-39635931">[2 more]</label></div><br/><div class="children"><div class="content">It depends. If you&#x27;re constrained to one chip and one platform you can characterize or you can estimate the characteristics of a float that matter in your application. In some applications like embedded that&#x27;s actually totally fine, and modern embedded chips can often do floating point as fast or faster than they can emulate fixed point to work around floating point&#x27;s drawbacks. On one project I worked on they originally wrote everything fixed point out of fear that floating point would introduce some deleterious effect. But in the end they rewrote parts of the project using floating point to no ill effect and great performance improvement. And there were features of the product that they had to strike because the rewrite needed to support them couldn&#x27;t touch certain sensitive areas of the code that had been tested extensively in the 2 or 3 years of development. It would have been much better to evaluate the assumption that floats are bad early on in the project and make the decision based on real information. The heuristic they were applying ended up costing part of the product that was strategically important.</div><br/><div id="39636001" class="c"><input type="checkbox" id="c-39636001" checked=""/><div class="controls bullet"><span class="by">Jyaif</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635931">parent</a><span>|</span><a href="#39635741">next</a><span>|</span><label class="collapse" for="c-39636001">[-]</label><label class="expand" for="c-39636001">[1 more]</label></div><br/><div class="children"><div class="content">&gt; constrained to one chip and one platform<p>and constrained to one compiler at a precise version, and one set of compiler options</div><br/></div></div></div></div><div id="39635741" class="c"><input type="checkbox" id="c-39635741" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39635931">prev</a><span>|</span><a href="#39637749">next</a><span>|</span><label class="collapse" for="c-39635741">[-]</label><label class="expand" for="c-39635741">[4 more]</label></div><br/><div class="children"><div class="content">They&#x27;re always <i>deterministic</i> in some sense (and as long as your OS respects the rounding mode after a context switch properly). This might sound pedantic but it determines how we think about floats — the behaviour is specified quite exactly.</div><br/><div id="39636217" class="c"><input type="checkbox" id="c-39636217" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635741">parent</a><span>|</span><a href="#39635796">next</a><span>|</span><label class="collapse" for="c-39636217">[-]</label><label class="expand" for="c-39636217">[1 more]</label></div><br/><div class="children"><div class="content">Curiously, early Intel 386 processors had a bug where 32-bit multiplies were genuinely nondeterministic: some answers would depend on the voltage, frequency, temperature, and manufacturing conditions. The problem was essentially analog, a layout issue, where the signal didn&#x27;t always have enough margin. (This is unrelated to the famous Pentium FDIV bug.) Until Intel got the problem fixed, they would stamp bad chips with &quot;16 BIT S&#x2F;W ONLY&quot;, while good chips were labeled &quot;ΣΣ&quot;.</div><br/></div></div><div id="39635796" class="c"><input type="checkbox" id="c-39635796" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635741">parent</a><span>|</span><a href="#39636217">prev</a><span>|</span><a href="#39636124">next</a><span>|</span><label class="collapse" for="c-39635796">[-]</label><label class="expand" for="c-39635796">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is that the same code running on different hardware&#x2F;os may not always give the same answer. It’ll be close, but you can’t always expect bit for bit identical.</div><br/></div></div><div id="39636124" class="c"><input type="checkbox" id="c-39636124" checked=""/><div class="controls bullet"><span class="by">ducttapecrown</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39635741">parent</a><span>|</span><a href="#39635796">prev</a><span>|</span><a href="#39637749">next</a><span>|</span><label class="collapse" for="c-39636124">[-]</label><label class="expand" for="c-39636124">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re always deterministic, just as long as physics is.</div><br/></div></div></div></div><div id="39637749" class="c"><input type="checkbox" id="c-39637749" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39635741">prev</a><span>|</span><a href="#39635742">next</a><span>|</span><label class="collapse" for="c-39637749">[-]</label><label class="expand" for="c-39637749">[1 more]</label></div><br/><div class="children"><div class="content">But why? We all know 0.1+0.2 won’t give 0.3 with floats but at least we should expect deterministic result for same numbers and same operations and same order, no?</div><br/></div></div><div id="39635742" class="c"><input type="checkbox" id="c-39635742" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39633730">parent</a><span>|</span><a href="#39637749">prev</a><span>|</span><a href="#39634002">next</a><span>|</span><label class="collapse" for="c-39635742">[-]</label><label class="expand" for="c-39635742">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s safe at all. Catastrophic cancellation would be quite a lot less catastrophic if rounding errors were random but accurate on average.</div><br/></div></div></div></div><div id="39634002" class="c"><input type="checkbox" id="c-39634002" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39633730">prev</a><span>|</span><a href="#39633683">next</a><span>|</span><label class="collapse" for="c-39634002">[-]</label><label class="expand" for="c-39634002">[5 more]</label></div><br/><div class="children"><div class="content">Somewhat annoyingly the ascribe standard only specifies that various math functions return an approximation but does not set any bounds on that approximation. So for many functions you could just return NaN and still be compliant.</div><br/><div id="39634057" class="c"><input type="checkbox" id="c-39634057" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634002">parent</a><span>|</span><a href="#39633683">next</a><span>|</span><label class="collapse" for="c-39634057">[-]</label><label class="expand" for="c-39634057">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t NaN the one value that can’t possibly count as an approximation, because it’s not a number and unordered? ;)</div><br/><div id="39634189" class="c"><input type="checkbox" id="c-39634189" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634057">parent</a><span>|</span><a href="#39633683">next</a><span>|</span><label class="collapse" for="c-39634189">[-]</label><label class="expand" for="c-39634189">[3 more]</label></div><br/><div class="children"><div class="content">You might think so, but if it’s not specified in the standard…</div><br/><div id="39634289" class="c"><input type="checkbox" id="c-39634289" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634189">parent</a><span>|</span><a href="#39634256">next</a><span>|</span><label class="collapse" for="c-39634289">[-]</label><label class="expand" for="c-39634289">[1 more]</label></div><br/><div class="children"><div class="content">I was submitting an interpretation of the standard.</div><br/></div></div><div id="39634256" class="c"><input type="checkbox" id="c-39634256" checked=""/><div class="controls bullet"><span class="by">zardo</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39634189">parent</a><span>|</span><a href="#39634289">prev</a><span>|</span><a href="#39633683">next</a><span>|</span><label class="collapse" for="c-39634256">[-]</label><label class="expand" for="c-39634256">[1 more]</label></div><br/><div class="children"><div class="content">It is the worst possible approximation though.</div><br/></div></div></div></div></div></div></div></div><div id="39633683" class="c"><input type="checkbox" id="c-39633683" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39634002">prev</a><span>|</span><a href="#39636223">next</a><span>|</span><label class="collapse" for="c-39633683">[-]</label><label class="expand" for="c-39633683">[1 more]</label></div><br/><div class="children"><div class="content">some languages (e.g. Julia) provide their own math library do that you get the same results across across operating systems.</div><br/></div></div><div id="39636223" class="c"><input type="checkbox" id="c-39636223" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#39633574">parent</a><span>|</span><a href="#39633683">prev</a><span>|</span><a href="#39633966">next</a><span>|</span><label class="collapse" for="c-39636223">[-]</label><label class="expand" for="c-39636223">[2 more]</label></div><br/><div class="children"><div class="content">So you can use sin(x) for various x to tell what you are running on. Maybe even in the browser?</div><br/><div id="39636240" class="c"><input type="checkbox" id="c-39636240" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39633574">root</a><span>|</span><a href="#39636223">parent</a><span>|</span><a href="#39633966">next</a><span>|</span><label class="collapse" for="c-39636240">[-]</label><label class="expand" for="c-39636240">[1 more]</label></div><br/><div class="children"><div class="content">V8 and SpiderMonkey have converged to the same underlying library (fdlibm), partly for the interoperability, so you generally can&#x27;t.</div><br/></div></div></div></div></div></div><div id="39633966" class="c"><input type="checkbox" id="c-39633966" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#39633574">prev</a><span>|</span><a href="#39635835">next</a><span>|</span><label class="collapse" for="c-39633966">[-]</label><label class="expand" for="c-39633966">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s much clearer if you read one of the source code of the libm.<p>Plan 9: <a href="https:&#x2F;&#x2F;9p.io&#x2F;sources&#x2F;plan9&#x2F;sys&#x2F;src&#x2F;libc&#x2F;port&#x2F;sin.c" rel="nofollow">https:&#x2F;&#x2F;9p.io&#x2F;sources&#x2F;plan9&#x2F;sys&#x2F;src&#x2F;libc&#x2F;port&#x2F;sin.c</a><p>Freebsd: <a href="https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;lib&#x2F;msun&#x2F;src&#x2F;k_sin.c" rel="nofollow">https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;lib&#x2F;msun&#x2F;src&#x2F;k_sin.c</a></div><br/><div id="39636185" class="c"><input type="checkbox" id="c-39636185" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39633966">parent</a><span>|</span><a href="#39635835">next</a><span>|</span><label class="collapse" for="c-39636185">[-]</label><label class="expand" for="c-39636185">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD code is missing the range reduction step (it&#x27;s named a &quot;kernel&quot; for the reason): <a href="https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;lib&#x2F;msun&#x2F;src&#x2F;e_rem_pio2.c" rel="nofollow">https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;lib&#x2F;msun&#x2F;src&#x2F;e_rem_pio2.c</a></div><br/></div></div></div></div><div id="39635835" class="c"><input type="checkbox" id="c-39635835" checked=""/><div class="controls bullet"><span class="by">toolslive</span><span>|</span><a href="#39633966">prev</a><span>|</span><a href="#39633734">next</a><span>|</span><label class="collapse" for="c-39635835">[-]</label><label class="expand" for="c-39635835">[2 more]</label></div><br/><div class="children"><div class="content">After reducing the interval, you don&#x27;t want to use the Taylor series as you&#x27;re building an approximation that&#x27;s really good in 0 but not so good moving away from 0. 
It&#x27;s better to use an interpolating polynomial (Chebychev comes to mind) over the whole target interval.</div><br/><div id="39635858" class="c"><input type="checkbox" id="c-39635858" checked=""/><div class="controls bullet"><span class="by">paulpauper</span><span>|</span><a href="#39635835">parent</a><span>|</span><a href="#39633734">next</a><span>|</span><label class="collapse" for="c-39635858">[-]</label><label class="expand" for="c-39635858">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways to do this. It&#x27;s not a difficult problem unless memory is constrained.</div><br/></div></div></div></div><div id="39633734" class="c"><input type="checkbox" id="c-39633734" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#39635835">prev</a><span>|</span><a href="#39633600">next</a><span>|</span><label class="collapse" for="c-39633734">[-]</label><label class="expand" for="c-39633734">[1 more]</label></div><br/><div class="children"><div class="content">You might also find this video interesting:<p>&quot;Finding the BEST sine function for Nintendo 64&quot;<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xFKFoGiGlXQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xFKFoGiGlXQ</a></div><br/></div></div><div id="39633600" class="c"><input type="checkbox" id="c-39633600" checked=""/><div class="controls bullet"><span class="by">microtherion</span><span>|</span><a href="#39633734">prev</a><span>|</span><a href="#39633461">next</a><span>|</span><label class="collapse" for="c-39633600">[-]</label><label class="expand" for="c-39633600">[1 more]</label></div><br/><div class="children"><div class="content">P.J. Plauger&#x27;s _The Standard C Library_ provides an implementation for all functions in the (then) C standard: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Standard-Library-P-J-Plauger&#x2F;dp&#x2F;0138380120?ref_=ast_author_dp&amp;dib=eyJ2IjoiMSJ9.J2FZMVfhMnUjy3nORwaNfJ39GKhZvMa1t-YBXfQeaEgAuQf63AYkxWWCauQjjBeo9Z3_OrNF4PZDHa-l_tdvzR3ooYzJBGyfigUwXLxNHiszIfSYtPsgIzjEKpUmRBVOSMlrnXBoG26XMFM6WGfX6gSXoSJCch-ZygQNZo-OuqAfqvHlSY4NZBnBxp3ORQySq32fkwuWqv516zBqZMCmp6fPUdbJG1rJgG9Z5yJxIc8.Kz9qxgL-6ZhzUqEeAARs4sTCGFg8uFGlXxRP21iGrRc&amp;dib_tag=AUTHOR" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Standard-Library-P-J-Plauger&#x2F;dp&#x2F;01383...</a></div><br/></div></div><div id="39633461" class="c"><input type="checkbox" id="c-39633461" checked=""/><div class="controls bullet"><span class="by">tails4e</span><span>|</span><a href="#39633600">prev</a><span>|</span><a href="#39636203">next</a><span>|</span><label class="collapse" for="c-39633461">[-]</label><label class="expand" for="c-39633461">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen the third order Taylor series used, but with the coefficients calculated at various offsets for a quarter wave. So you lookuo where you are in the quarter wave, then look up the 3 or 4 cofficients. This keeps the error somewhat bounded as the size of X is a small so the series does not diverge too much.</div><br/></div></div><div id="39636203" class="c"><input type="checkbox" id="c-39636203" checked=""/><div class="controls bullet"><span class="by">eh_why_not</span><span>|</span><a href="#39633461">prev</a><span>|</span><a href="#39633643">next</a><span>|</span><label class="collapse" for="c-39636203">[-]</label><label class="expand" for="c-39636203">[2 more]</label></div><br/><div class="children"><div class="content">Anyone experienced with the Remez algorithm mentioned at the end of the article?<p>The degree-9 polynomial, said to be a thousand times better than the original Taylor approximation in maximum error, also appears to be very close to the Taylor series in the first place.<p>Rounding the Taylor coefficients to 6 digits after the decimal:<p>1&#x2F;3! = 0.166667<p>1&#x2F;5! = 0.008333<p>1&#x2F;7! = 0.000198<p>1&#x2F;9! = 0.000027(56)<p>The first 2 are exact, the third is 5 digits only (so 0.000190), and the fourth is more different starting from the 6th digit (0.000026019).<p>The delta in the 9-th order is expected if you were to truncate the Taylor series starting from the 11th order to infinity (+ x^11 &#x2F; 11! - x^13&#x2F;13! ...).</div><br/><div id="39636721" class="c"><input type="checkbox" id="c-39636721" checked=""/><div class="controls bullet"><span class="by">stephencanon</span><span>|</span><a href="#39636203">parent</a><span>|</span><a href="#39633643">next</a><span>|</span><label class="collapse" for="c-39636721">[-]</label><label class="expand" for="c-39636721">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Remez_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Remez_algorithm</a><p>It’s a very simple iterative algorithm, essentially the dumbest thing that could possibly work (like most good algorithms). It fails to converge for functions that have poles nearby unless you have a very good initial guess (the Chebyshev or Carathéodory-Fejér approximants are ~always good starting points and easily computed). In practice you want to optimize a weighted L-inf norm rather than absolute, because floating-point errors are measured in a relative norm.</div><br/></div></div></div></div><div id="39633643" class="c"><input type="checkbox" id="c-39633643" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39636203">prev</a><span>|</span><a href="#39634445">next</a><span>|</span><label class="collapse" for="c-39633643">[-]</label><label class="expand" for="c-39633643">[1 more]</label></div><br/><div class="children"><div class="content">This was my first use of open source, around 1978. I wondered how calculators and computers did trig functions, and was also using Unix V7. We had a large disk and kept the source on line. So I was able to find this: <a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;libm&#x2F;sin.c" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;libm&#x2F;s...</a> and from there this book: <a href="https:&#x2F;&#x2F;www.biblio.com&#x2F;book&#x2F;computer-approximations-john-f-hart-e&#x2F;d&#x2F;1504828236" rel="nofollow">https:&#x2F;&#x2F;www.biblio.com&#x2F;book&#x2F;computer-approximations-john-f-h...</a></div><br/></div></div><div id="39634445" class="c"><input type="checkbox" id="c-39634445" checked=""/><div class="controls bullet"><span class="by">azhenley</span><span>|</span><a href="#39633643">prev</a><span>|</span><a href="#39637914">next</a><span>|</span><label class="collapse" for="c-39634445">[-]</label><label class="expand" for="c-39634445">[1 more]</label></div><br/><div class="children"><div class="content">I blogged my adventure of implementing cosine from scratch and how others have done it:<p><a href="https:&#x2F;&#x2F;austinhenley.com&#x2F;blog&#x2F;cosine.html" rel="nofollow">https:&#x2F;&#x2F;austinhenley.com&#x2F;blog&#x2F;cosine.html</a></div><br/></div></div><div id="39637914" class="c"><input type="checkbox" id="c-39637914" checked=""/><div class="controls bullet"><span class="by">sema4hacker</span><span>|</span><a href="#39634445">prev</a><span>|</span><a href="#39633322">next</a><span>|</span><label class="collapse" for="c-39637914">[-]</label><label class="expand" for="c-39637914">[1 more]</label></div><br/><div class="children"><div class="content">I remember seeing the source code for a version of SpaceWar! running on an Adage Graphics Terminal (a one&#x27;s complement machine) around 1970 that used a precomputed sine table.<p>I wonder what the first program was that ever used a precomputed trig table.</div><br/></div></div><div id="39633322" class="c"><input type="checkbox" id="c-39633322" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39637914">prev</a><span>|</span><a href="#39637087">next</a><span>|</span><label class="collapse" for="c-39633322">[-]</label><label class="expand" for="c-39633322">[3 more]</label></div><br/><div class="children"><div class="content">1 - cos^2(x), obviously</div><br/><div id="39633802" class="c"><input type="checkbox" id="c-39633802" checked=""/><div class="controls bullet"><span class="by">nh23423fefe</span><span>|</span><a href="#39633322">parent</a><span>|</span><a href="#39634553">next</a><span>|</span><label class="collapse" for="c-39633802">[-]</label><label class="expand" for="c-39633802">[1 more]</label></div><br/><div class="children"><div class="content">instead, you could just double negate to optimize away the square root<p><pre><code>    -(-(sin(x))</code></pre></div><br/></div></div><div id="39634553" class="c"><input type="checkbox" id="c-39634553" checked=""/><div class="controls bullet"><span class="by">ChainOfFools</span><span>|</span><a href="#39633322">parent</a><span>|</span><a href="#39633802">prev</a><span>|</span><a href="#39637087">next</a><span>|</span><label class="collapse" for="c-39634553">[-]</label><label class="expand" for="c-39634553">[1 more]</label></div><br/><div class="children"><div class="content">clear, but too verbose.    1&#x2F;csc is what you want.<p>or for style points just  -cos&#x27;</div><br/></div></div></div></div><div id="39637087" class="c"><input type="checkbox" id="c-39637087" checked=""/><div class="controls bullet"><span class="by">mettamage</span><span>|</span><a href="#39633322">prev</a><span>|</span><a href="#39636812">next</a><span>|</span><label class="collapse" for="c-39637087">[-]</label><label class="expand" for="c-39637087">[3 more]</label></div><br/><div class="children"><div class="content">What’s the best way to calculate it by hand?<p>I’m brushing up my math basics (I graduated CS while dodging the math requirements) and it frustrates me that in trig I need to remember values at all. The values such as sqrt(2)&#x2F;2 make sense but how hard is it to calculate sin(5 degrees) by hand?</div><br/><div id="39637138" class="c"><input type="checkbox" id="c-39637138" checked=""/><div class="controls bullet"><span class="by">HenryPrickett</span><span>|</span><a href="#39637087">parent</a><span>|</span><a href="#39637397">next</a><span>|</span><label class="collapse" for="c-39637138">[-]</label><label class="expand" for="c-39637138">[1 more]</label></div><br/><div class="children"><div class="content">Use a Taylor series with a four function calculator.<p>0 is a decent approximation of sin near 0.<p>x is a better one.<p>x - x^3&#x2F;6 is an even better one.<p>x - x^3&#x2F;6 + x^5&#x2F;120 ...<p>Note that x here is in radians rather than degrees so convert (degrees * pi&#x2F;180) first. Repeat until you&#x27;re satisfied with how many stable digits you get</div><br/></div></div><div id="39637397" class="c"><input type="checkbox" id="c-39637397" checked=""/><div class="controls bullet"><span class="by">empath-nirvana</span><span>|</span><a href="#39637087">parent</a><span>|</span><a href="#39637138">prev</a><span>|</span><a href="#39636812">next</a><span>|</span><label class="collapse" for="c-39637397">[-]</label><label class="expand" for="c-39637397">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3d6DsjIBzJ4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3d6DsjIBzJ4</a></div><br/></div></div></div></div><div id="39636812" class="c"><input type="checkbox" id="c-39636812" checked=""/><div class="controls bullet"><span class="by">simonblack</span><span>|</span><a href="#39637087">prev</a><span>|</span><a href="#39633454">next</a><span>|</span><label class="collapse" for="c-39636812">[-]</label><label class="expand" for="c-39636812">[1 more]</label></div><br/><div class="children"><div class="content">The same way you can eat an elephant: one byte at a time.<p>Any calculating job can be undertaken by a proper Turing machine. You just have to keep in mind the old triangle of usage: Cost, capability and speed.<p>If a human can calculate a sine, so can any full-blown computer.</div><br/></div></div><div id="39633454" class="c"><input type="checkbox" id="c-39633454" checked=""/><div class="controls bullet"><span class="by">t-3</span><span>|</span><a href="#39636812">prev</a><span>|</span><a href="#39633656">next</a><span>|</span><label class="collapse" for="c-39633454">[-]</label><label class="expand" for="c-39633454">[1 more]</label></div><br/><div class="children"><div class="content">Link doesn&#x27;t appear to be valid, but aren&#x27;t these usually precalculated and stored in a lookup table?</div><br/></div></div><div id="39633656" class="c"><input type="checkbox" id="c-39633656" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39633454">prev</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39633656">[-]</label><label class="expand" for="c-39633656">[23 more]</label></div><br/><div class="children"><div class="content">CORDIC is how it&#x27;s usually done in hardware (and FPGAs).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CORDIC" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CORDIC</a></div><br/><div id="39633819" class="c"><input type="checkbox" id="c-39633819" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39633656">parent</a><span>|</span><a href="#39633701">next</a><span>|</span><label class="collapse" for="c-39633819">[-]</label><label class="expand" for="c-39633819">[9 more]</label></div><br/><div class="children"><div class="content">CORDIC is pretty obsolete, AFAIK. Its advantage is that its hardware requirements are absolutely tiny: two (?) accumulator registers, and hardware adders and shift-ers—I think that&#x27;s all. No multiplication needed, in particular. Very convenient if you&#x27;re building things from <i>discrete transistors</i>, like the some of those earlier scientific calculators!<p>(Also has a nice property, apparently, that CORDIC-like routines exist for a bunch of special functions and they&#x27;re very similar to each other. Does anyone have a good resource for learning the details of those algorithms? They sound  elegant).</div><br/><div id="39633909" class="c"><input type="checkbox" id="c-39633909" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39638027">next</a><span>|</span><label class="collapse" for="c-39633909">[-]</label><label class="expand" for="c-39633909">[1 more]</label></div><br/><div class="children"><div class="content">CORDIC still is used in tiny microcontrollers (smaller than Cortex-M0) and in FPGAs when you are very resource-constrained.  Restricting the domain and using Chebyshev&#x2F;Remez is the way to go pretty much everywhere.</div><br/></div></div><div id="39638027" class="c"><input type="checkbox" id="c-39638027" checked=""/><div class="controls bullet"><span class="by">idatum</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39633909">prev</a><span>|</span><a href="#39635989">next</a><span>|</span><label class="collapse" for="c-39638027">[-]</label><label class="expand" for="c-39638027">[1 more]</label></div><br/><div class="children"><div class="content">I just recently came across CORDIC in a fun read I just finished, &#x27;Empire of the Sum&#x27;, by Keith Houston. It&#x27;s a history of calculators, and there&#x27;s a chapter on the HP-35 which used CORDIC. The author goes into some details how it was used by that constrained device.<p>There are a lot of references given in the book including more details on CORDIC.</div><br/></div></div><div id="39635989" class="c"><input type="checkbox" id="c-39635989" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39638027">prev</a><span>|</span><a href="#39637564">next</a><span>|</span><label class="collapse" for="c-39635989">[-]</label><label class="expand" for="c-39635989">[1 more]</label></div><br/><div class="children"><div class="content">CORDIC doesn&#x27;t make sense if multiplies have a similar cost to adds. If you have cheap multiplications then a successive approximation is faster. If multiplications are expensive relative to adds then CORDIC can still generally win. Basically this is only the case nowadays if you are doing ASICs or FPGAs.</div><br/></div></div><div id="39637564" class="c"><input type="checkbox" id="c-39637564" checked=""/><div class="controls bullet"><span class="by">derf_</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39635989">prev</a><span>|</span><a href="#39635804">next</a><span>|</span><label class="collapse" for="c-39637564">[-]</label><label class="expand" for="c-39637564">[1 more]</label></div><br/><div class="children"><div class="content">I have used CORDIC to compute fixed-point log&#x2F;exp with 64 bits of precision, mostly because I wanted to avoid having to implement (portable) 64x64-&gt;128 bit integer multiplication in C. It is probably still slower than doing that, but the code was really simple, and very accurate.</div><br/></div></div><div id="39635804" class="c"><input type="checkbox" id="c-39635804" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39637564">prev</a><span>|</span><a href="#39634380">next</a><span>|</span><label class="collapse" for="c-39635804">[-]</label><label class="expand" for="c-39635804">[1 more]</label></div><br/><div class="children"><div class="content">I think still used out of necessity when hw floating point not available (like fpgas)</div><br/></div></div><div id="39634380" class="c"><input type="checkbox" id="c-39634380" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633819">parent</a><span>|</span><a href="#39635804">prev</a><span>|</span><a href="#39633701">next</a><span>|</span><label class="collapse" for="c-39634380">[-]</label><label class="expand" for="c-39634380">[3 more]</label></div><br/><div class="children"><div class="content">Multiplication is pretty much needed in cordic! And is far from obsolete! It works perfectly fine, and dont have any of the problems said in the article.</div><br/><div id="39635842" class="c"><input type="checkbox" id="c-39635842" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39634380">parent</a><span>|</span><a href="#39634502">next</a><span>|</span><label class="collapse" for="c-39635842">[-]</label><label class="expand" for="c-39635842">[1 more]</label></div><br/><div class="children"><div class="content">CORDIC doesn&#x27;t use multipliers. That&#x27;s the whole appeal for low performance hardware since it&#x27;s all shifts and adds. It can still be useful on more capable platforms when you want sin and cos in one operation since there is no extra cost.</div><br/></div></div><div id="39634502" class="c"><input type="checkbox" id="c-39634502" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39634380">parent</a><span>|</span><a href="#39635842">prev</a><span>|</span><a href="#39633701">next</a><span>|</span><label class="collapse" for="c-39634502">[-]</label><label class="expand" for="c-39634502">[1 more]</label></div><br/><div class="children"><div class="content">It uses multiplication by powers of two, which is a floating-point bit shift.</div><br/></div></div></div></div></div></div><div id="39633701" class="c"><input type="checkbox" id="c-39633701" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39633656">parent</a><span>|</span><a href="#39633819">prev</a><span>|</span><a href="#39634345">next</a><span>|</span><label class="collapse" for="c-39633701">[-]</label><label class="expand" for="c-39633701">[7 more]</label></div><br/><div class="children"><div class="content">no it&#x27;s not. cordic has awful convergence of 1 bit per iteration. pretty much everyone uses power series.</div><br/><div id="39634407" class="c"><input type="checkbox" id="c-39634407" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633701">parent</a><span>|</span><a href="#39637292">next</a><span>|</span><label class="collapse" for="c-39634407">[-]</label><label class="expand" for="c-39634407">[5 more]</label></div><br/><div class="children"><div class="content">That is 64 iterations for a double, that is nothing!</div><br/><div id="39635979" class="c"><input type="checkbox" id="c-39635979" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39634407">parent</a><span>|</span><a href="#39637292">next</a><span>|</span><label class="collapse" for="c-39635979">[-]</label><label class="expand" for="c-39635979">[4 more]</label></div><br/><div class="children"><div class="content">53, but that&#x27;s still a lot more than the 5th degree polynomial that you need.</div><br/><div id="39636000" class="c"><input type="checkbox" id="c-39636000" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39635979">parent</a><span>|</span><a href="#39637292">next</a><span>|</span><label class="collapse" for="c-39636000">[-]</label><label class="expand" for="c-39636000">[3 more]</label></div><br/><div class="children"><div class="content">yeah, but 52 adds can be a lot cheaper than a few multiplies, if you&#x27;re making them out of shift registers and logic gates (or LUT). in a CPU or GPU, who cares, moving around the data is 100x more expensive than the ALU operation.</div><br/><div id="39636322" class="c"><input type="checkbox" id="c-39636322" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39636000">parent</a><span>|</span><a href="#39636534">next</a><span>|</span><label class="collapse" for="c-39636322">[-]</label><label class="expand" for="c-39636322">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in a CPU or GPU, who cares, moving around the data is 100x more expensive than the ALU operation<p>Moving data is indeed expensive, but there’s another reason to not care. Modern CPUs take same time to add or multiply floats.<p>For example, the computer I’m using, with AMD Zen3 CPU cores, takes 3 cycles to add or multiply numbers, which applies to both 32- and 64-bit flavors of floats. See addps, mulps, addpd, mulpd SSE instructions in that table: <a href="https:&#x2F;&#x2F;www.uops.info&#x2F;table.html" rel="nofollow">https:&#x2F;&#x2F;www.uops.info&#x2F;table.html</a></div><br/></div></div><div id="39636534" class="c"><input type="checkbox" id="c-39636534" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39636000">parent</a><span>|</span><a href="#39636322">prev</a><span>|</span><a href="#39637292">next</a><span>|</span><label class="collapse" for="c-39636534">[-]</label><label class="expand" for="c-39636534">[1 more]</label></div><br/><div class="children"><div class="content">&gt; moving around the data is 100x more expensive than the ALU operation.<p>This is exactly the problem with CORDIC. 52 dependent adds requires moving data from a register to the ALU and back 52 times.</div><br/></div></div></div></div></div></div></div></div><div id="39637292" class="c"><input type="checkbox" id="c-39637292" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39633701">parent</a><span>|</span><a href="#39634407">prev</a><span>|</span><a href="#39634345">next</a><span>|</span><label class="collapse" for="c-39637292">[-]</label><label class="expand" for="c-39637292">[1 more]</label></div><br/><div class="children"><div class="content">Actually pretty much everyone implements double precision sin&#x2F;cos using the same (IIRC) pair of 6th order polynomials.  The same SunPro code exists unchnaged in essentially every C library everywehre.  It&#x27;s just a fitted curve, no fancy series definition beyond what appears in the output coefficients.  One for the &quot;mostly linear&quot; segment where the line crosses the origin and another for the &quot;mostly parabolic&quot; peak of the curve.</div><br/></div></div></div></div><div id="39634345" class="c"><input type="checkbox" id="c-39634345" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39633656">parent</a><span>|</span><a href="#39633701">prev</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39634345">[-]</label><label class="expand" for="c-39634345">[6 more]</label></div><br/><div class="children"><div class="content">Why would you ever use CORDIC if you had any other option?</div><br/><div id="39634390" class="c"><input type="checkbox" id="c-39634390" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39634345">parent</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39634390">[-]</label><label class="expand" for="c-39634390">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great for hardware implementations, because it&#x27;s simple and you get good&#x2F;excellent accuracy. I wouldn&#x27;t be surprised if that&#x27;s still how modern x86-64 CPUs compute sin, cos, etc.<p>That said, last time I had to do that in software, I used Taylor series. Might not have been an optimal solution.<p>EDIT:<p>AMD&#x27;s Zen 4 takes 50-200 cycles (latency) to compute sine. I think that strongly suggests AMD uses CORDIC. <a href="https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;instruction_tables.pdf" rel="nofollow">https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;instruction_tables.pdf</a> page 130.<p>Same for Intel, Tiger Lake (Intel gen 11) has 60-120 cycles of latency. Page 353.<p>I&#x27;d guess usually ~50 cycles for Zen 4 (and ~60 for Intel) for float32, float64&#x2F;float80 datatype. Denormals might also cost more cycles.</div><br/><div id="39635037" class="c"><input type="checkbox" id="c-39635037" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39634390">parent</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39635037">[-]</label><label class="expand" for="c-39635037">[4 more]</label></div><br/><div class="children"><div class="content">They switched away from CORDIC at one point:  <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;the-difference-between-x87-instructions-and-mathematical-functions.html?wapkw=fsin" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>(there doesn&#x27;t seem to actually be a linked article there, just the summary)</div><br/><div id="39635364" class="c"><input type="checkbox" id="c-39635364" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39635037">parent</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39635364">[-]</label><label class="expand" for="c-39635364">[3 more]</label></div><br/><div class="children"><div class="content">Pretty weird Intel&#x27;s sine computation latency hasn&#x27;t changed all that much over the years. Latencies have been pretty similar for 20 years.<p>EDIT: That&#x27;s a paper for a software library, not the CPU&#x27;s internal implementation. Which is probably still done with CORDIC.</div><br/><div id="39635621" class="c"><input type="checkbox" id="c-39635621" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39635364">parent</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39635621">[-]</label><label class="expand" for="c-39635621">[2 more]</label></div><br/><div class="children"><div class="content">&gt; EDIT: That&#x27;s a paper for a software library, not the CPU&#x27;s internal implementation.<p>Unless you&#x27;re seeing something I&#x27;m not, it&#x27;s talking about x87, which hasn&#x27;t been anything other than &#x27;internal&#x27; since they stopped selling the 80486sx.</div><br/><div id="39635717" class="c"><input type="checkbox" id="c-39635717" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39633656">root</a><span>|</span><a href="#39635621">parent</a><span>|</span><a href="#39634307">next</a><span>|</span><label class="collapse" for="c-39635717">[-]</label><label class="expand" for="c-39635717">[1 more]</label></div><br/><div class="children"><div class="content">Ah you&#x27;re right.<p>Anyways I wonder why it&#x27;s still so slow.<p>60-120 cycles sure looks like a CORDIC implementation, but perhaps not.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39634307" class="c"><input type="checkbox" id="c-39634307" checked=""/><div class="controls bullet"><span class="by">deepthaw</span><span>|</span><a href="#39633656">prev</a><span>|</span><a href="#39633914">next</a><span>|</span><label class="collapse" for="c-39634307">[-]</label><label class="expand" for="c-39634307">[4 more]</label></div><br/><div class="children"><div class="content">Ignorant question:<p>Given the ridiculous number of transistors and so on we can use in CPUs and GPUs nowadays how feasible is a relatively huge trig lookup table burned into rom?</div><br/><div id="39638496" class="c"><input type="checkbox" id="c-39638496" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39634307">parent</a><span>|</span><a href="#39634428">next</a><span>|</span><label class="collapse" for="c-39638496">[-]</label><label class="expand" for="c-39638496">[1 more]</label></div><br/><div class="children"><div class="content">A lookup table (for any function) that covered all values between 0 and 1 in <i>single precision</i>, would be ~4GB; there are approximately 1B values between 0 and 1, and the result of each value is 4 bytes.<p>Such a table for double-precision would be much, much larger.</div><br/></div></div><div id="39634428" class="c"><input type="checkbox" id="c-39634428" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39634307">parent</a><span>|</span><a href="#39638496">prev</a><span>|</span><a href="#39634362">next</a><span>|</span><label class="collapse" for="c-39634428">[-]</label><label class="expand" for="c-39634428">[1 more]</label></div><br/><div class="children"><div class="content">There is huge number of 64bit floats and huge portion of those are between 0..pi&#x2F;2.</div><br/></div></div><div id="39634362" class="c"><input type="checkbox" id="c-39634362" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39634307">parent</a><span>|</span><a href="#39634428">prev</a><span>|</span><a href="#39633914">next</a><span>|</span><label class="collapse" for="c-39634362">[-]</label><label class="expand" for="c-39634362">[1 more]</label></div><br/><div class="children"><div class="content">Seems like a terrible idea on latency grounds alone.</div><br/></div></div></div></div><div id="39633914" class="c"><input type="checkbox" id="c-39633914" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39634307">prev</a><span>|</span><a href="#39633495">next</a><span>|</span><label class="collapse" for="c-39633914">[-]</label><label class="expand" for="c-39633914">[1 more]</label></div><br/><div class="children"><div class="content">Is this still current? The paper has a publication year of 1999.</div><br/></div></div><div id="39633495" class="c"><input type="checkbox" id="c-39633495" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39633914">prev</a><span>|</span><a href="#39636346">next</a><span>|</span><label class="collapse" for="c-39633495">[-]</label><label class="expand" for="c-39633495">[2 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;steve.hollasch.net&#x2F;cgindex&#x2F;math&#x2F;inccos.html" rel="nofollow">http:&#x2F;&#x2F;steve.hollasch.net&#x2F;cgindex&#x2F;math&#x2F;inccos.html</a> is a great technique if you need a fast integer approximation for some some arbitrary sampling interval (i.e. motor control)</div><br/><div id="39636407" class="c"><input type="checkbox" id="c-39636407" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#39633495">parent</a><span>|</span><a href="#39636346">next</a><span>|</span><label class="collapse" for="c-39636407">[-]</label><label class="expand" for="c-39636407">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing FoC motor control for a long time and I&#x27;ve settled on a neat little fixed point approximation for sin&#x2F;cos. I haven&#x27;t been able to find the blog I got the idea from. It&#x27;s accurate to 9 bits, but is very symmetric and hits 1,0,-1 exactly. It&#x27;s also smooth which usually makes it better than lookup tables.</div><br/></div></div></div></div><div id="39636346" class="c"><input type="checkbox" id="c-39636346" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#39633495">prev</a><span>|</span><a href="#39636135">next</a><span>|</span><label class="collapse" for="c-39636346">[-]</label><label class="expand" for="c-39636346">[1 more]</label></div><br/><div class="children"><div class="content">Why isn&#x27;t this just done with an industry standard lookup table these days?</div><br/></div></div><div id="39636135" class="c"><input type="checkbox" id="c-39636135" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#39636346">prev</a><span>|</span><a href="#39633466">next</a><span>|</span><label class="collapse" for="c-39636135">[-]</label><label class="expand" for="c-39636135">[5 more]</label></div><br/><div class="children"><div class="content">I thought modern CPUs since the late 1980&#x27;s used a lookup table for trig&#x2F;transcendental functions. Is the LUT just an expansion of the polynomial? I never really understood how FPUs worked...</div><br/><div id="39636684" class="c"><input type="checkbox" id="c-39636684" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39636135">parent</a><span>|</span><a href="#39638509">next</a><span>|</span><label class="collapse" for="c-39636684">[-]</label><label class="expand" for="c-39636684">[2 more]</label></div><br/><div class="children"><div class="content">That would take way too much room. A full lookup table would have 2^64 entries of 64 bits each, at 2^70 bits of ROM.<p>For comparison:<p>- Apple’s M2 Ultra has about 134 billion transistors. That’s about 2^38.<p>- Avogadro’s number is about 2^79.<p>Reducing the argument to a small range around zero decreases that a lot, but not enough by a far stretch. There are 2^52 doubles in [0.5, 1.0), 2^52 more in [0.25, 0.5], 2^52 more in [0.125, 0.25], etc. so you’d still easily need 2^52 entries or 2^58 bits (likely way, way more)</div><br/><div id="39636814" class="c"><input type="checkbox" id="c-39636814" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#39636135">root</a><span>|</span><a href="#39636684">parent</a><span>|</span><a href="#39638509">next</a><span>|</span><label class="collapse" for="c-39636814">[-]</label><label class="expand" for="c-39636814">[1 more]</label></div><br/><div class="children"><div class="content">They DO use a lookup table because that’s what the FDIV but came from:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Pentium_FDIV_bug" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Pentium_FDIV_bug</a><p>“It is implemented using a programmable logic array with 2,048 cells, of which 1,066 cells should have been populated with one of five values: −2, −1, 0, +1, +2.”<p>Not sure what you’re trying to demonstrate, they wouldn’t store every single float!! I hope don’t program. ;)</div><br/></div></div></div></div><div id="39638509" class="c"><input type="checkbox" id="c-39638509" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39636135">parent</a><span>|</span><a href="#39636684">prev</a><span>|</span><a href="#39636694">next</a><span>|</span><label class="collapse" for="c-39638509">[-]</label><label class="expand" for="c-39638509">[1 more]</label></div><br/><div class="children"><div class="content">TFA says they use a 32 entry LUT, then do some math on the result.</div><br/></div></div><div id="39636694" class="c"><input type="checkbox" id="c-39636694" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39636135">parent</a><span>|</span><a href="#39638509">prev</a><span>|</span><a href="#39633466">next</a><span>|</span><label class="collapse" for="c-39636694">[-]</label><label class="expand" for="c-39636694">[1 more]</label></div><br/><div class="children"><div class="content">Older CPUs generally have used CORDIC (which does use LUT but that&#x27;s only a part of the algorithm) due to its simplicity and compactness, while later CPUs with extensive microcode support would do the same thing as software implementations.</div><br/></div></div></div></div><div id="39633466" class="c"><input type="checkbox" id="c-39633466" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#39636135">prev</a><span>|</span><a href="#39633241">next</a><span>|</span><label class="collapse" for="c-39633466">[-]</label><label class="expand" for="c-39633466">[2 more]</label></div><br/><div class="children"><div class="content">And arcsin?</div><br/><div id="39635861" class="c"><input type="checkbox" id="c-39635861" checked=""/><div class="controls bullet"><span class="by">paulpauper</span><span>|</span><a href="#39633466">parent</a><span>|</span><a href="#39633241">next</a><span>|</span><label class="collapse" for="c-39635861">[-]</label><label class="expand" for="c-39635861">[1 more]</label></div><br/><div class="children"><div class="content">harder due to convergence issues</div><br/></div></div></div></div><div id="39633241" class="c"><input type="checkbox" id="c-39633241" checked=""/><div class="controls bullet"><span class="by">paulpauper</span><span>|</span><a href="#39633466">prev</a><span>|</span><label class="collapse" for="c-39633241">[-]</label><label class="expand" for="c-39633241">[4 more]</label></div><br/><div class="children"><div class="content">sine is easy because the series is globally convergent and fast converging</div><br/><div id="39637099" class="c"><input type="checkbox" id="c-39637099" checked=""/><div class="controls bullet"><span class="by">zgs</span><span>|</span><a href="#39633241">parent</a><span>|</span><a href="#39633394">next</a><span>|</span><label class="collapse" for="c-39637099">[-]</label><label class="expand" for="c-39637099">[1 more]</label></div><br/><div class="children"><div class="content">It would also be extremely inaccurate.  The x^n numerators grow very quickly and digits get lost because unlimited precision isn&#x27;t available.  Likewise, the n! denominators also grow rapidly.  Then the series is alternating which means cancellation is happening for every added term.<p>If you don&#x27;t believe me try for x=10.</div><br/></div></div><div id="39633394" class="c"><input type="checkbox" id="c-39633394" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#39633241">parent</a><span>|</span><a href="#39637099">prev</a><span>|</span><label class="collapse" for="c-39633394">[-]</label><label class="expand" for="c-39633394">[2 more]</label></div><br/><div class="children"><div class="content">Did you read the article? It is specifically about how the series looks simple, but the error is actually very bad if you do things naively.</div><br/><div id="39633543" class="c"><input type="checkbox" id="c-39633543" checked=""/><div class="controls bullet"><span class="by">paulpauper</span><span>|</span><a href="#39633241">root</a><span>|</span><a href="#39633394">parent</a><span>|</span><label class="collapse" for="c-39633543">[-]</label><label class="expand" for="c-39633543">[1 more]</label></div><br/><div class="children"><div class="content">That still makes it easier compared to computing constants in which the series are not globally convergent, like inverse trig functions. Obviously, you would have to break it apart to speed convergence.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>