<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685955681113" as="style"/><link rel="stylesheet" href="styles.css?v=1685955681113"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/containers/crun">Crun: Fast and lightweight OCI runtime and C library for running containers</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nateb2022</span> | <span>39 comments</span></div><br/><div><div id="36190040" class="c"><input type="checkbox" id="c-36190040" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36189574">next</a><span>|</span><label class="collapse" for="c-36190040">[-]</label><label class="expand" for="c-36190040">[6 more]</label></div><br/><div class="children"><div class="content">systemd has nspawn, often overlooked ion the container discussion.<p><a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;systemd-nspawn" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;systemd-nspawn</a><p>&quot;systemd-nspawn is like the chroot command, but it is a chroot on steroids.<p>systemd-nspawn may be used to run a command or OS in a light-weight namespace container. It is more powerful than chroot since it fully virtualizes the file system hierarchy, as well as the process tree, the various IPC subsystems and the host and domain name. &quot;</div><br/><div id="36190288" class="c"><input type="checkbox" id="c-36190288" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#36190040">parent</a><span>|</span><a href="#36189574">next</a><span>|</span><label class="collapse" for="c-36190288">[-]</label><label class="expand" for="c-36190288">[5 more]</label></div><br/><div class="children"><div class="content">nspawn (and LXC&#x2F;LXD) is overlooked because people mostly want application containers not system containers.</div><br/><div id="36190912" class="c"><input type="checkbox" id="c-36190912" checked=""/><div class="controls bullet"><span class="by">alexgartrell</span><span>|</span><a href="#36190040">root</a><span>|</span><a href="#36190288">parent</a><span>|</span><a href="#36190740">next</a><span>|</span><label class="collapse" for="c-36190912">[-]</label><label class="expand" for="c-36190912">[3 more]</label></div><br/><div class="children"><div class="content">I actually disagree that this is the reason for the aversion. Instead I think it comes down to a couple of things:<p>1. Containers are commodity. For commodities, price wins first, then marketing. Docker is equally free (as in beer) and is far better marketed
2. There are a very low number of people working on systemd-nspawn and a very high number of people working on docker (and the ecosystem).
3. Dockerfiles and images are ubiquitous. They&#x27;re easy to support from other run times, but if you&#x27;re already in the ecosystem, what&#x27;s the incentive to change?</div><br/><div id="36192807" class="c"><input type="checkbox" id="c-36192807" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#36190040">root</a><span>|</span><a href="#36190912">parent</a><span>|</span><a href="#36190740">next</a><span>|</span><label class="collapse" for="c-36192807">[-]</label><label class="expand" for="c-36192807">[2 more]</label></div><br/><div class="children"><div class="content">There is also the fact that some people have a knee jerk reaction to hate anything associated with systemd. Although, I think that is less significant than the two reasons you listed.</div><br/><div id="36193911" class="c"><input type="checkbox" id="c-36193911" checked=""/><div class="controls bullet"><span class="by">arunkant</span><span>|</span><a href="#36190040">root</a><span>|</span><a href="#36192807">parent</a><span>|</span><a href="#36190740">next</a><span>|</span><label class="collapse" for="c-36193911">[-]</label><label class="expand" for="c-36193911">[1 more]</label></div><br/><div class="children"><div class="content">I think people in generate are happy that systemd happend</div><br/></div></div></div></div></div></div><div id="36190740" class="c"><input type="checkbox" id="c-36190740" checked=""/><div class="controls bullet"><span class="by">cpufry</span><span>|</span><a href="#36190040">root</a><span>|</span><a href="#36190288">parent</a><span>|</span><a href="#36190912">prev</a><span>|</span><a href="#36189574">next</a><span>|</span><label class="collapse" for="c-36190740">[-]</label><label class="expand" for="c-36190740">[1 more]</label></div><br/><div class="children"><div class="content">yea thats what my general understanding of that was too, people want the most shrink wrappiest and minimal virtualisation boundary</div><br/></div></div></div></div></div></div><div id="36189574" class="c"><input type="checkbox" id="c-36189574" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#36190040">prev</a><span>|</span><a href="#36189579">next</a><span>|</span><label class="collapse" for="c-36189574">[-]</label><label class="expand" for="c-36189574">[1 more]</label></div><br/><div class="children"><div class="content">* crun could go much lower than that, and require &lt; 1M. The used 4MB is a hard limit set directly in Podman before calling the OCI runtime.*<p>Enough room to hide a lisp implementation!</div><br/></div></div><div id="36189579" class="c"><input type="checkbox" id="c-36189579" checked=""/><div class="controls bullet"><span class="by">snapplebobapple</span><span>|</span><a href="#36189574">prev</a><span>|</span><a href="#36193710">next</a><span>|</span><label class="collapse" for="c-36189579">[-]</label><label class="expand" for="c-36189579">[10 more]</label></div><br/><div class="children"><div class="content">For those of us not into this space, does this replace docker or kubernetes or just some piece of the puzzle that could be bolted into both to replace some component?</div><br/><div id="36189651" class="c"><input type="checkbox" id="c-36189651" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#36189579">parent</a><span>|</span><a href="#36189650">next</a><span>|</span><label class="collapse" for="c-36189651">[-]</label><label class="expand" for="c-36189651">[5 more]</label></div><br/><div class="children"><div class="content">Take a car, the engine is the OCI runtime, crun, containerd, etc.. The whole car is Docker, or Podman. Kubernetes is the city where the cars run.<p>---<p>EDIT: For more details, OCI (Open Container Initiative) defines a few things:<p><pre><code>  - an image format (how to create them)
  - a runtime specification (how to run them)
  - ...
</code></pre>
A container runtime is an implementation of one of those things.<p>Docker is a set of tools hidden under a unified CLI which gives you the ability to:<p><pre><code>  - create images
  - upload&#x2F;download images to&#x2F;from a registry
  - run images with volumes, networking configuration, environment variables, ...
</code></pre>
But Docker is only one host.<p>Kubernetes is an interface to abstract a cluster of hosts. Everything is described as a &quot;resource&quot; which goes through the &quot;control loop&quot;:<p><pre><code>  1. the user uses the k8s REST API to create&#x2F;read&#x2F;update&#x2F;delete the resource
  2. the k8s api server will contact admission controllers (via webhook) to authorize (and&#x2F;or mutate) the action
  3. the action is persisted to a distributed database (usually, etcd)
  4. then, controllers are notified of the change and will run the side effects
</code></pre>
This is the simplified version. But what is stored in the distributed database is called the &quot;desired&quot; state, and controllers have the duty of observing the real state (the &quot;observed&quot; state) and make it converge towards the &quot;desired&quot; state.<p>So a &quot;Pod&quot; controller&#x27;s job will be to observe Docker instances, to check what containers are running, and start&#x2F;stop the containers based on what &quot;Pod&quot; resources exists in k8s&#x27;s database.<p>A &quot;Deployment&quot; controller&#x27;s job will be to observe the &quot;Pod&quot; resources in the k8s database and create&#x2F;update&#x2F;delete them based on what &quot;Deployment&quot; resources exists in k8s&#x27;s database.<p>etc...<p>In theory, Kubernetes does not need docker. You could have a &quot;proxmox&quot; controller which would start&#x2F;stop virtual machines instead.<p>Kubernetes provides a lot of tooling for storage management, secret management, networking, workload management, etc... so that you can manage it all with a unified REST API.<p>The very nature of the &quot;control loop&quot; makes it very extensible, allowing you to build layers of abstraction on top of layers of abstraction on top of layers of abstraction ... A real &quot;onion cloud&quot; if I dare say it.</div><br/><div id="36189949" class="c"><input type="checkbox" id="c-36189949" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36189579">root</a><span>|</span><a href="#36189651">parent</a><span>|</span><a href="#36189650">next</a><span>|</span><label class="collapse" for="c-36189949">[-]</label><label class="expand" for="c-36189949">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The whole car is Docker, or Podman. Kubernetes is the city where the cars run.<p>Kubernetes doesn&#x27;t use Docker or Podman.</div><br/><div id="36189963" class="c"><input type="checkbox" id="c-36189963" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#36189579">root</a><span>|</span><a href="#36189949">parent</a><span>|</span><a href="#36190235">next</a><span>|</span><label class="collapse" for="c-36189963">[-]</label><label class="expand" for="c-36189963">[1 more]</label></div><br/><div class="children"><div class="content">And there are more than 2 models of cars. The metaphor is still valid.</div><br/></div></div><div id="36190235" class="c"><input type="checkbox" id="c-36190235" checked=""/><div class="controls bullet"><span class="by">rumdz</span><span>|</span><a href="#36189579">root</a><span>|</span><a href="#36189949">parent</a><span>|</span><a href="#36189963">prev</a><span>|</span><a href="#36189650">next</a><span>|</span><label class="collapse" for="c-36190235">[-]</label><label class="expand" for="c-36190235">[2 more]</label></div><br/><div class="children"><div class="content">What does Kubernetes use instead?</div><br/><div id="36190355" class="c"><input type="checkbox" id="c-36190355" checked=""/><div class="controls bullet"><span class="by">pipe_connector</span><span>|</span><a href="#36189579">root</a><span>|</span><a href="#36190235">parent</a><span>|</span><a href="#36189650">next</a><span>|</span><label class="collapse" for="c-36190355">[-]</label><label class="expand" for="c-36190355">[1 more]</label></div><br/><div class="children"><div class="content">kubernetes can use anything that conforms to the CRI interface, which in practice is either CRI-O (RedHat) or Containerd (Docker, Inc.). Podman and Docker are also consumers of both of those engines</div><br/></div></div></div></div></div></div></div></div><div id="36189650" class="c"><input type="checkbox" id="c-36189650" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36189579">parent</a><span>|</span><a href="#36189651">prev</a><span>|</span><a href="#36189835">next</a><span>|</span><label class="collapse" for="c-36189650">[-]</label><label class="expand" for="c-36189650">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes needs an OCI runtime to run containers with. Crun is one implementation it can use.<p>Docker also appears to be able to use crun for it&#x27;s engine as well. <a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;crun&#x2F;issues&#x2F;37">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;crun&#x2F;issues&#x2F;37</a></div><br/></div></div><div id="36189835" class="c"><input type="checkbox" id="c-36189835" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#36189579">parent</a><span>|</span><a href="#36189650">prev</a><span>|</span><a href="#36190818">next</a><span>|</span><label class="collapse" for="c-36189835">[-]</label><label class="expand" for="c-36189835">[2 more]</label></div><br/><div class="children"><div class="content">It replaces `runc` which is used by most non-docker container runtimes to actually start the container. Thus the punny name.<p>When using kubernetes, the hierarchy is as follows:<p><pre><code>  1. kubernetes master tells kubelet what to do (sort of, not important here)
  2. kubelet uses CRI-compatible runtime to start containers
  3. containerd or CRI-O handle management of containers and start them using runc or crun
  4. runc&#x2F;crun are the applications that setup the final environment of application to run in container, using resources (mounts, devices, etc) provided to them by upper layers. They also handle things like sending stdout&#x2F;stderr to logs, or setting up a pseudoterminal to talk to a program in container, etc.</code></pre></div><br/><div id="36191315" class="c"><input type="checkbox" id="c-36191315" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#36189579">root</a><span>|</span><a href="#36189835">parent</a><span>|</span><a href="#36190818">next</a><span>|</span><label class="collapse" for="c-36191315">[-]</label><label class="expand" for="c-36191315">[1 more]</label></div><br/><div class="children"><div class="content">I mean, Docker is using runc by default as well.</div><br/></div></div></div></div><div id="36190818" class="c"><input type="checkbox" id="c-36190818" checked=""/><div class="controls bullet"><span class="by">cmckn</span><span>|</span><a href="#36189579">parent</a><span>|</span><a href="#36189835">prev</a><span>|</span><a href="#36193710">next</a><span>|</span><label class="collapse" for="c-36190818">[-]</label><label class="expand" for="c-36190818">[1 more]</label></div><br/><div class="children"><div class="content">Kubelet speaks CRI to containerd, which speaks OCI to runc (or crun).<p>Docker can be wedged in there between Kubernetes and containerd (which was originally part of Docker).<p>The OCI implementation is the lowest-level component in the “container stack”.</div><br/></div></div></div></div><div id="36193710" class="c"><input type="checkbox" id="c-36193710" checked=""/><div class="controls bullet"><span class="by">hkt</span><span>|</span><a href="#36189579">prev</a><span>|</span><a href="#36191581">next</a><span>|</span><label class="collapse" for="c-36193710">[-]</label><label class="expand" for="c-36193710">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A Lua binding is available.<p>Bliss. Fantastic. I&#x27;m going to write something with this. I remain delighted every single time somebody rewrites a thing in C.</div><br/></div></div><div id="36191581" class="c"><input type="checkbox" id="c-36191581" checked=""/><div class="controls bullet"><span class="by">seckuriti</span><span>|</span><a href="#36193710">prev</a><span>|</span><a href="#36191478">next</a><span>|</span><label class="collapse" for="c-36191581">[-]</label><label class="expand" for="c-36191581">[1 more]</label></div><br/><div class="children"><div class="content">I try to avoid setuid binaries written in memory-unsafe languages.<p>This feels like the wrong direction.</div><br/></div></div><div id="36191478" class="c"><input type="checkbox" id="c-36191478" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#36191581">prev</a><span>|</span><a href="#36190793">next</a><span>|</span><label class="collapse" for="c-36191478">[-]</label><label class="expand" for="c-36191478">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no fan of Go, but &quot;I used C instead&quot; is not a selling point</div><br/><div id="36192729" class="c"><input type="checkbox" id="c-36192729" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36191478">parent</a><span>|</span><a href="#36190793">next</a><span>|</span><label class="collapse" for="c-36192729">[-]</label><label class="expand" for="c-36192729">[1 more]</label></div><br/><div class="children"><div class="content">Indeed for all its design issues, it is still way better than using plain old C, unless there is no way around it.</div><br/></div></div></div></div><div id="36190793" class="c"><input type="checkbox" id="c-36190793" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#36191478">prev</a><span>|</span><a href="#36191412">next</a><span>|</span><label class="collapse" for="c-36190793">[-]</label><label class="expand" for="c-36190793">[15 more]</label></div><br/><div class="children"><div class="content">I can’t go into too much detail but: IME the benefits are somewhat doubtful and it can run into weird issues that are hard to debug (because C) at scale. I wouldn’t use it unless I had a maintainer or a C expert on my team. The other OCI runtimes are written in go and are (generally) easier to debug.</div><br/><div id="36193815" class="c"><input type="checkbox" id="c-36193815" checked=""/><div class="controls bullet"><span class="by">chippiewill</span><span>|</span><a href="#36190793">parent</a><span>|</span><a href="#36191281">next</a><span>|</span><label class="collapse" for="c-36193815">[-]</label><label class="expand" for="c-36193815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wouldn’t use it unless I had a maintainer or a C expert on my team<p>I suppose you keep a Linux kernel dev or C expert on your team when you run on Linux too?</div><br/></div></div><div id="36191281" class="c"><input type="checkbox" id="c-36191281" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36190793">parent</a><span>|</span><a href="#36193815">prev</a><span>|</span><a href="#36191371">next</a><span>|</span><label class="collapse" for="c-36191281">[-]</label><label class="expand" for="c-36191281">[11 more]</label></div><br/><div class="children"><div class="content">Why is Go easier to debug? It kinda sounds like you&#x27;re more familiar with one language than another and are basing your assessment of the tool on that.</div><br/><div id="36193460" class="c"><input type="checkbox" id="c-36193460" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191281">parent</a><span>|</span><a href="#36191593">next</a><span>|</span><label class="collapse" for="c-36193460">[-]</label><label class="expand" for="c-36193460">[4 more]</label></div><br/><div class="children"><div class="content">Compare these two programs:<p><pre><code>   char foo[123];
   int x;
   foo[124] = 10;
</code></pre>
and:<p><pre><code>   var foo [123]byte
   var x int
   foo[124] = 10;
</code></pre>
In C, this surprisingly changes the value of x.  (Well, it&#x27;s undefined, so it could do anything!)  In Go, the program crashes with the error that index 124 is out of bounds.<p>C is the absolute best programming languages for programmers who don&#x27;t make mistakes.  I&#x27;m not one of them, and I&#x27;ve never met one of them.  If it works for you, that&#x27;s impressive!</div><br/><div id="36193670" class="c"><input type="checkbox" id="c-36193670" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36193460">parent</a><span>|</span><a href="#36191593">next</a><span>|</span><label class="collapse" for="c-36193670">[-]</label><label class="expand" for="c-36193670">[3 more]</label></div><br/><div class="children"><div class="content">You know sanitizers and static analysis tools exist, and have existed for decades, and have been the basis for the work done in Rust and other &quot;safe&quot; languages?<p>Also, a disciplined C programmer will always keep the size of the buffer near the buffer itself.<p>For example, using something like this is perfectly safe (though, we can see the performance hit of those if-statements if used intensively):<p><pre><code>  struct buffer {
    size_t size;
    char *data;
  };

  void buffer_alloc(struct buffer *buf, size_t size) {
    if (buf != NULL) {
      buf-&gt;data = calloc(size, sizeof(char));
      if (buf-&gt;data != NULL) {
        buf-&gt;size = size;
      }
    }
  }

  void buffer_free(struct buffer *buf) {
    if (buf != NULL &amp;&amp; buf-&gt;data != NULL) {
      free(buf-&gt;data);
      buf-&gt;size = 0;
    }
  }

  bool buffer_read(struct buffer buf, size_t offset, char *dest) {
    if (dest != NULL) {
      if (buf.data != NULL &amp;&amp; offset &gt;= 0 &amp;&amp; offset &lt; buf.size) {
        *dest = buf.data[offset];
        return true;
      }
    }

    return false;
  }

  int main() {
    struct buffer buf = {0};
    buffer_alloc(&amp;buf, 123);
    char c;
    buffer_read(buf, 124, &amp;c);
    buffer_free(&amp;buf);
    return 0;
  }
</code></pre>
It is possible to write safe C code, but it takes understanding of the language, sometimes of the compiler as well.<p>The whole &quot;There is no programmer who don&#x27;t make mistakes&quot; argument is fallacious at best.<p>C is like a chainsaw, there are certain rules on how to use it safely. Yes you can cut limbs with a chainsaw, that does not make the chainsaw useless.</div><br/><div id="36193902" class="c"><input type="checkbox" id="c-36193902" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36193670">parent</a><span>|</span><a href="#36191593">next</a><span>|</span><label class="collapse" for="c-36193902">[-]</label><label class="expand" for="c-36193902">[2 more]</label></div><br/><div class="children"><div class="content">This comes up from time-to-time. Surely, there&#x27;s some caveat here either for performance or other reasons (I&#x27;m not a solid C programmer enough to know the if this hypothesis is viable or not). If it was so simple this approach would be ubiquitous and C would be safe. What am I missing?</div><br/><div id="36193982" class="c"><input type="checkbox" id="c-36193982" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36193902">parent</a><span>|</span><a href="#36191593">next</a><span>|</span><label class="collapse" for="c-36193982">[-]</label><label class="expand" for="c-36193982">[1 more]</label></div><br/><div class="children"><div class="content">A chainsaw is not safe. But you can learn to use it safely.<p>Replace chainsaw with:<p><pre><code>  - knife
  - guns
  - C programming language
</code></pre>
There are tools and methods (and a lot of discipline) to ensure safety in C:<p><pre><code>  - compiler&#x27;s sanitizers[0]:
    - address: to detect out-of-bounds and use-after-free bugs
    - pointer-compare, pointer-subtract: to detect invalid operation when pointers are non null
    - shadow-call-stack: to detect return address overwrites (stack buffer overflows)
    - thread: to detect data races
    - leak: to detect memory leaks
    - undefined: to detect undefined behaviors
    - ...
  - static analysis tools, like Splint[1]
</code></pre>
Would you ride a motorbike without the proper protections (helmet, heavy jacket, ...) ?<p>[0] - <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Instrumentation-Options.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Instrumentation-Options.h...</a><p>[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;splintchecker&#x2F;splint">https:&#x2F;&#x2F;github.com&#x2F;splintchecker&#x2F;splint</a></div><br/></div></div></div></div></div></div></div></div><div id="36191593" class="c"><input type="checkbox" id="c-36191593" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191281">parent</a><span>|</span><a href="#36193460">prev</a><span>|</span><a href="#36191448">next</a><span>|</span><label class="collapse" for="c-36191593">[-]</label><label class="expand" for="c-36191593">[3 more]</label></div><br/><div class="children"><div class="content">Unless unsafe package is used which is rare or there’s a bug in the compiler which is rarer still you will not get silent memory corruption bugs which are stupid common in C and hard to debug to boot</div><br/><div id="36191818" class="c"><input type="checkbox" id="c-36191818" checked=""/><div class="controls bullet"><span class="by">throwaway173738</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191593">parent</a><span>|</span><a href="#36191448">next</a><span>|</span><label class="collapse" for="c-36191818">[-]</label><label class="expand" for="c-36191818">[2 more]</label></div><br/><div class="children"><div class="content">So your whole argument isn’t that crun itself is unstable but that C can be hard for non-experts to write programs in. That could be said of tons of stuff including the OS kernel you’re using to run containers, so I’d be curious to hear what you’re using to replace Linux in your work.<p>The principal issue with Go applications in my work continues to be the massive size of the executables.</div><br/><div id="36192270" class="c"><input type="checkbox" id="c-36192270" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191818">parent</a><span>|</span><a href="#36191448">next</a><span>|</span><label class="collapse" for="c-36192270">[-]</label><label class="expand" for="c-36192270">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for crun specifically since I haven&#x27;t used it personally but almost every single C application I&#x27;ve had to deal with had these hard to debug memory corruption bugs which required an expert (me) days&#x2F;weeks to fix. And that included the Linux kernel itself btw, the difference being it was almost always fixed in the upstream by the time I found it.<p>&gt; The principal issue with Go applications in my work continues to be the massive size of the executables.<p>That is certainly true in general case, however out of curiosity I went to see the size of containerd runtimes on my machine and:<p><pre><code>  -rwxr-xr-x 1 1001 121 46889792 Sep 22  2022 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;containerd
  -rwxr-xr-x 1 1001 121 9699328 Sep 22  2022 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;containerd-shim-runc-v2
</code></pre>
Does not seem that bad... (note that only the shim is launched per container, containerd process is a single systemd service)</div><br/></div></div></div></div></div></div><div id="36191448" class="c"><input type="checkbox" id="c-36191448" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191281">parent</a><span>|</span><a href="#36191593">prev</a><span>|</span><a href="#36191413">next</a><span>|</span><label class="collapse" for="c-36191448">[-]</label><label class="expand" for="c-36191448">[2 more]</label></div><br/><div class="children"><div class="content">Easier to track allocations and tie them to structures.</div><br/><div id="36192692" class="c"><input type="checkbox" id="c-36192692" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191448">parent</a><span>|</span><a href="#36191413">next</a><span>|</span><label class="collapse" for="c-36192692">[-]</label><label class="expand" for="c-36192692">[1 more]</label></div><br/><div class="children"><div class="content">Technically if you use jemalloc, which most everyone should do anyway, it comes with built-in instrumentation but you need to enable it compile time and generally not many are aware of this.</div><br/></div></div></div></div><div id="36191413" class="c"><input type="checkbox" id="c-36191413" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#36190793">root</a><span>|</span><a href="#36191281">parent</a><span>|</span><a href="#36191448">prev</a><span>|</span><a href="#36191371">next</a><span>|</span><label class="collapse" for="c-36191413">[-]</label><label class="expand" for="c-36191413">[1 more]</label></div><br/><div class="children"><div class="content">Less undefined behavior I would assume.</div><br/></div></div></div></div><div id="36191371" class="c"><input type="checkbox" id="c-36191371" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#36190793">parent</a><span>|</span><a href="#36191281">prev</a><span>|</span><a href="#36191817">next</a><span>|</span><label class="collapse" for="c-36191371">[-]</label><label class="expand" for="c-36191371">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; hard to debug (because C) at scale<p>I think what the crun author is positing is the container runtime is closer to the kernal (cgroups) than it is the orchestrator (Kubernetes). I tend to agree.<p>Of course kernel &#x2F; cgroups &#x2F; container runtime need to be rock solid. There should be no need to debug these in most use cases.</div><br/></div></div><div id="36191817" class="c"><input type="checkbox" id="c-36191817" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#36190793">parent</a><span>|</span><a href="#36191371">prev</a><span>|</span><a href="#36191412">next</a><span>|</span><label class="collapse" for="c-36191817">[-]</label><label class="expand" for="c-36191817">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also 1 in Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;youki">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;youki</a></div><br/></div></div></div></div><div id="36191412" class="c"><input type="checkbox" id="c-36191412" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#36190793">prev</a><span>|</span><a href="#36191823">next</a><span>|</span><label class="collapse" for="c-36191412">[-]</label><label class="expand" for="c-36191412">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be very cautious about running such a core piece of infrastructure in an insecure language. Especially one without the level of scrutiny other projects like linux have.</div><br/></div></div><div id="36191823" class="c"><input type="checkbox" id="c-36191823" checked=""/><div class="controls bullet"><span class="by">akkartik</span><span>|</span><a href="#36191412">prev</a><span>|</span><label class="collapse" for="c-36191823">[-]</label><label class="expand" for="c-36191823">[1 more]</label></div><br/><div class="children"><div class="content">I went looking for an answer to the obvious question, and there is indeed a Rust version. <a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;youki#motivation">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;youki#motivation</a> has a nice comparison with both runc and crun.</div><br/></div></div></div></div></div></div></div></body></html>