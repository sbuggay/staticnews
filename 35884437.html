<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683709263271" as="style"/><link rel="stylesheet" href="styles.css?v=1683709263271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://subtls.pages.dev/">See this page fetch itself, byte by byte, over TLS</a> <span class="domain">(<a href="https://subtls.pages.dev">subtls.pages.dev</a>)</span></div><div class="subtext"><span>gmac</span> | <span>29 comments</span></div><br/><div><div id="35884666" class="c"><input type="checkbox" id="c-35884666" checked=""/><div class="controls bullet"><span class="by">jxf</span><span>|</span><a href="#35885106">next</a><span>|</span><label class="collapse" for="c-35884666">[-]</label><label class="expand" for="c-35884666">[6 more]</label></div><br/><div class="children"><div class="content">This was beautiful. Two things stood out to me:<p>* There&#x27;s more stuff than I expected which exists only for backwards compatibility. That&#x27;s a lot of bytes when you add it all up over the whole Internet.<p>* There&#x27;s a lot of &quot;expect N more bytes for a data structure of type T1&quot; messages followed immediately by &quot;expect N-k more bytes for a data structure of type T1::T2&quot;. I assume this is because there&#x27;s other stuff that could go in that spot, but it still looks strange.<p>I&#x27;m sure all of this is necessary and important; I just found it really fascinating to peek under the covers. It&#x27;s nice to be able to have it all (mostly) just work thanks to the tireless efforts of many engineers and protocol developers.</div><br/><div id="35884762" class="c"><input type="checkbox" id="c-35884762" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#35884666">parent</a><span>|</span><a href="#35885106">next</a><span>|</span><label class="collapse" for="c-35884762">[-]</label><label class="expand" for="c-35884762">[5 more]</label></div><br/><div class="children"><div class="content">That kind of stuff is necessary for binary protocols to evolve in a compatible way. When a TLS 1.4 is defined, we need a window where clients and servers can still negotiate 1.3 until both have been upgraded. And 1.3 had to find ways to be compatible with 1.2, and so forth. Decades of that kind of evolution are guaranteed to leave some marks in the protocol.<p>But let&#x27;s keep a sense of proportion. I find it hard to worry about &quot;wasting&quot; maybe 0.01% of the total internet bandwidth for a few extra bytes here or there, when that&#x27;s necessary to keep the internet working at all, when on the other hand, for no end-user benefit, we don&#x27;t hesitate to waste maybe 15% (after compression) by insisting on using text-based formats for the payload in all our web standards.<p>In fact, I&#x27;d love to see a back-of-the-envelope calculation of how many tons of CO2 would have been saved in total if HTML was a well-engineered binary format. (Including bandwidth, storage, parsing on the client etc.) The number must be insane.</div><br/><div id="35884835" class="c"><input type="checkbox" id="c-35884835" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#35884666">root</a><span>|</span><a href="#35884762">parent</a><span>|</span><a href="#35885132">next</a><span>|</span><label class="collapse" for="c-35884835">[-]</label><label class="expand" for="c-35884835">[2 more]</label></div><br/><div class="children"><div class="content">The thing about html is that it&#x27;s a verbose text format on the surface, but it compresses incredibly easily, and support for gzip is widespread. If you&#x27;re concerned about size, brotli is better again.</div><br/><div id="35884918" class="c"><input type="checkbox" id="c-35884918" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#35884666">root</a><span>|</span><a href="#35884835">parent</a><span>|</span><a href="#35885132">next</a><span>|</span><label class="collapse" for="c-35884918">[-]</label><label class="expand" for="c-35884918">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  The thing about html is that it&#x27;s a verbose text format on the surface, but it compresses incredibly easily, and support for gzip is widespread. If you&#x27;re concerned about size, brotli is better again.<p>That&#x27;s why I said it wastes 15%, not 100%. Whenever text-based formats and binary formats are compared, the results after compression (of both) are usually in that range. You can debate those precise numbers, they might be lower for the brotli&#x2F;HTML combination. That won&#x27;t really change the point I was making in context: That a few extra bytes for backwards compatibility in the TLS handshake pale in comparison to the amount of waste we accept for encoding the payload.</div><br/></div></div></div></div><div id="35885132" class="c"><input type="checkbox" id="c-35885132" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#35884666">root</a><span>|</span><a href="#35884762">parent</a><span>|</span><a href="#35884835">prev</a><span>|</span><a href="#35884883">next</a><span>|</span><label class="collapse" for="c-35885132">[-]</label><label class="expand" for="c-35885132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That kind of stuff is necessary for binary protocols to evolve in a compatible way. When a TLS 1.4 is defined, we need a window where clients and servers can still negotiate 1.3 until both have been upgraded. And 1.3 had to find ways to be compatible with 1.2, and so forth. Decades of that kind of evolution are guaranteed to leave some marks in the protocol.<p>It&#x27;s necessary because people are incompetent, and because overall the market rewards them for incompetence. <i>From the outset</i> TLS provided a trivial version negotiation mechanism but it was easier to ignore it and write incompatible garbage especially for so-called &quot;Middle boxes&quot; often sold as a drop-in security &quot;solution&quot; for businesses.<p>So when it came time to ship TLS 1.1, it was soon discovered that in practice you can&#x27;t just say &quot;Hi, I speak TLS 1.1&quot; which would be a couple of bytes - that won&#x27;t work, you need to find some other way to quietly signal to competent people that you know the newer protocol. So they did, slightly weakening the security in the process, and this continued into TLS 1.2 where browsers began doing &quot;Fallback&quot; which was a risky but sadly necessary process where you give up attempting the new protocol altogether sometimes, thus opening yourself up to supposedly obsolete attacks.<p>By TLS 1.3 things had become so bad that TLS 1.3 essentially begins, as you can see if you inspect the data shown on that page, by pretending we&#x27;re speaking TLS 1.2 and then saying we want to negotiate an optional &quot;extension&quot; to TLS 1.2 which is where we confess we actually speak TLS 1.3.<p>Every single packet of TLS 1.3 encrypted data is <i>also</i> wrapped in a TLS 1.2 layer saying &quot;Don&#x27;t mind me, I&#x27;m just application data&quot;. Why? Because we can&#x27;t confess we&#x27;re not speaking TLS 1.2, ever, and if we said we were doing TLS 1.2 crypto system stuff the same incompetent garbage software would try to get involved because it &quot;understands&quot; (badly) how to speak TLS 1.2, so we just pretend it missed the negotiation phase, this is just application data, nothing to see.<p><i>And it works</i>. That&#x27;s crucial. It&#x27;s why we did all this, and yet it reveals that because the products people bought were developed incompetently they wouldn&#x27;t even have detected serious attacks anyway, let alone prevented them. Need to sneak 40GB of stolen financial data over a network &quot;protected&quot; by this Genuine Marketing Leading Brand Next Generation Firewall? Don&#x27;t worry, just label it &quot;application data&quot; with no explanation and it&#x27;ll be completely ignored.<p>If you&#x27;ve ever watched a Lock Picking Lawyer video on Youtube, it was like one of the ones where it&#x27;s several minutes so you expect it&#x27;ll be hard to pick, but then you find out he&#x27;s actually so disgusted by the lacklustre security of this $150 &quot;Pick Proof High Security Lock&quot; that although he rakes it open in 2 seconds with a cheap tool, and then shims it open with a discarded Redbull can, and then knocks it open with a hammer, and then uses a purpose built bypass tool to open it instantly in a single flowing motion, he <i>also</i> takes time to disassemble it and show you that the manufacturer fucked up, wasting material solving a non-existent problem and in the process making the lock much worse, which is why the video was so long.<p>Learning from their experience with these &quot;Security&quot; products for TLS 1.3, the QUIC people designed QUIC specifically with the intent that you can&#x27;t even tell what version it is unless you&#x27;re the client or the server, and then they shipped a new QUIC version to check that works even though they don&#x27;t really need one yet, so that they don&#x27;t have to do this whole dance again every few years.</div><br/></div></div></div></div></div></div><div id="35885106" class="c"><input type="checkbox" id="c-35885106" checked=""/><div class="controls bullet"><span class="by">simonjgreen</span><span>|</span><a href="#35884666">prev</a><span>|</span><a href="#35885069">next</a><span>|</span><label class="collapse" for="c-35885106">[-]</label><label class="expand" for="c-35885106">[1 more]</label></div><br/><div class="children"><div class="content">Not trying to diminish it&#x27;s importance, however isn&#x27;t it slightly sad how much total payload is devoted to encryption?<p>Also, and I know this is slightly  pedantic, but this is only speaking to layer 7. If you really wanted to watch everything byte by byte you&#x27;d need everything upwards of layer 2 where we go from bits on wire to bytes and frames. If you&#x27;ve not used Wireshark before run it yourself and load some pages.</div><br/></div></div><div id="35885069" class="c"><input type="checkbox" id="c-35885069" checked=""/><div class="controls bullet"><span class="by">emielm</span><span>|</span><a href="#35885106">prev</a><span>|</span><a href="#35884790">next</a><span>|</span><label class="collapse" for="c-35885069">[-]</label><label class="expand" for="c-35885069">[1 more]</label></div><br/><div class="children"><div class="content">This brings back memories of when I created a webbased version of spotify[1], using their (custom) encrypted protocol over TCP[2].<p>Notably: back then I used flash to speak TCP, with a memory-leaky and bug-ridden mechanism to transfer byte buffers between JS and Flash.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2556118" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2556118</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;EmielM&#x2F;spotifyontheweb-crypt">https:&#x2F;&#x2F;github.com&#x2F;EmielM&#x2F;spotifyontheweb-crypt</a></div><br/></div></div><div id="35884790" class="c"><input type="checkbox" id="c-35884790" checked=""/><div class="controls bullet"><span class="by">jpopesculian</span><span>|</span><a href="#35885069">prev</a><span>|</span><a href="#35885176">next</a><span>|</span><label class="collapse" for="c-35884790">[-]</label><label class="expand" for="c-35884790">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! Reminds me of the illustrated TLS connection which was a helpful resource for me when I had to implement a variation of it.<p><a href="https:&#x2F;&#x2F;tls12.xargs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tls12.xargs.org&#x2F;</a></div><br/></div></div><div id="35885176" class="c"><input type="checkbox" id="c-35885176" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#35884790">prev</a><span>|</span><a href="#35885029">next</a><span>|</span><label class="collapse" for="c-35885176">[-]</label><label class="expand" for="c-35885176">[2 more]</label></div><br/><div class="children"><div class="content">This is great, would be useful to be able to point it at any domain.</div><br/><div id="35885184" class="c"><input type="checkbox" id="c-35885184" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#35885176">parent</a><span>|</span><a href="#35885029">next</a><span>|</span><label class="collapse" for="c-35885184">[-]</label><label class="expand" for="c-35885184">[1 more]</label></div><br/><div class="children"><div class="content">For those looking for in-depth info on TLS, see also <a href="https:&#x2F;&#x2F;www.feistyduck.com&#x2F;books&#x2F;bulletproof-tls-and-pki&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.feistyduck.com&#x2F;books&#x2F;bulletproof-tls-and-pki&#x2F;</a></div><br/></div></div></div></div><div id="35885029" class="c"><input type="checkbox" id="c-35885029" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#35885176">prev</a><span>|</span><a href="#35884615">next</a><span>|</span><label class="collapse" for="c-35885029">[-]</label><label class="expand" for="c-35885029">[3 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t quite follow the symmetric key derivation.<p>First there&#x27;s something called &quot;handshake key computations&quot;, which generates a full set of encryption and mac keys. It seems to be entirely based on secp256r1 (NIST P-256) key share. I understand that this part is not protected against man-in-the-middle, right?<p>Then there&#x27;s &quot;application key computations&quot;, what are those values computed from? This process creates another complete set of encryption and authentication keys, and I assume this set is protected against man-in-the-middle.</div><br/><div id="35885037" class="c"><input type="checkbox" id="c-35885037" checked=""/><div class="controls bullet"><span class="by">gmac</span><span>|</span><a href="#35885029">parent</a><span>|</span><a href="#35884615">next</a><span>|</span><label class="collapse" for="c-35885037">[-]</label><label class="expand" for="c-35885037">[2 more]</label></div><br/><div class="children"><div class="content">You might find this useful (it was a helpful source when implementing): <a href="https:&#x2F;&#x2F;tls13.xargs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tls13.xargs.org&#x2F;</a>. Both sets of keys should be MITM-proof.</div><br/><div id="35885111" class="c"><input type="checkbox" id="c-35885111" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#35885029">root</a><span>|</span><a href="#35885037">parent</a><span>|</span><a href="#35884615">next</a><span>|</span><label class="collapse" for="c-35885111">[-]</label><label class="expand" for="c-35885111">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link.<p>But I believe that the first set of keys&#x2F;IVs is not protected whatsoever. Anyone can run the &quot;Server Key Exchange Generation&quot;, as it doesn&#x27;t require any secrets such as certificate private keys, only random inputs.<p>EDIT: Specifically, at least up to this point anyone can impersonate the server.</div><br/></div></div></div></div></div></div><div id="35884615" class="c"><input type="checkbox" id="c-35884615" checked=""/><div class="controls bullet"><span class="by">demarq</span><span>|</span><a href="#35885029">prev</a><span>|</span><a href="#35884950">next</a><span>|</span><label class="collapse" for="c-35884615">[-]</label><label class="expand" for="c-35884615">[5 more]</label></div><br/><div class="children"><div class="content">This is a really beautiful way to see something we take for granted all the time. The fact that computers can do all this in the blink of an eye (sans network speed) is just mind blowing.</div><br/><div id="35884679" class="c"><input type="checkbox" id="c-35884679" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#35884615">parent</a><span>|</span><a href="#35884950">next</a><span>|</span><label class="collapse" for="c-35884679">[-]</label><label class="expand" for="c-35884679">[4 more]</label></div><br/><div class="children"><div class="content">One kinda related thing I find constantly amazing is that your processor running at x GHz will have had several more ticks in the time  it takes the photons to go from your screen to your eyes.<p>(Light travels at about 30cm&#x2F;1ft per nanosecond)</div><br/><div id="35884975" class="c"><input type="checkbox" id="c-35884975" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884615">root</a><span>|</span><a href="#35884679">parent</a><span>|</span><a href="#35884941">next</a><span>|</span><label class="collapse" for="c-35884975">[-]</label><label class="expand" for="c-35884975">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that this puts a fundamental limit on how fast CPU clocks can be. If the CPU die has a diameter of 3 centimeters, and the clock speed is a hypothetical 20 GHz, light (and electrical signals) can traverse at most half the size of the die in the course of one clock cycle. It&#x27;s hard to imagine how such a CPU could work, since components at opposite sides of the die cannot communicate within a cycle.</div><br/><div id="35885057" class="c"><input type="checkbox" id="c-35885057" checked=""/><div class="controls bullet"><span class="by">HALtheWise</span><span>|</span><a href="#35884615">root</a><span>|</span><a href="#35884975">parent</a><span>|</span><a href="#35884941">next</a><span>|</span><label class="collapse" for="c-35885057">[-]</label><label class="expand" for="c-35885057">[1 more]</label></div><br/><div class="children"><div class="content">Definitely nitpicking here, but for a modern pipelined CPU there&#x27;s already lots of components of the die that aren&#x27;t designed to be able to exchange data within a single clock. I don&#x27;t see what would be fundamentally different about laying out a CPU die such that operations that need to happen in the same clock are physically nearby, and it seems like it would (at worst) have similar properties to multi-socket and pipelined CPUs today where cache coherency operations and branch mispredictions have multi-cycle penalties associated with them. I&#x27;m pretty sure that multi-socket CPUs can&#x27;t talk in less than one clock cycle anyway.</div><br/></div></div></div></div><div id="35884941" class="c"><input type="checkbox" id="c-35884941" checked=""/><div class="controls bullet"><span class="by">xpil</span><span>|</span><a href="#35884615">root</a><span>|</span><a href="#35884679">parent</a><span>|</span><a href="#35884975">prev</a><span>|</span><a href="#35884950">next</a><span>|</span><label class="collapse" for="c-35884941">[-]</label><label class="expand" for="c-35884941">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention eons required for our optical organics to start registering the photons!</div><br/></div></div></div></div></div></div><div id="35884950" class="c"><input type="checkbox" id="c-35884950" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#35884615">prev</a><span>|</span><a href="#35884983">next</a><span>|</span><label class="collapse" for="c-35884950">[-]</label><label class="expand" for="c-35884950">[3 more]</label></div><br/><div class="children"><div class="content">Since they add annotations to what is actually loaded, shouldn&#x27;t the loading continue forever?</div><br/><div id="35885200" class="c"><input type="checkbox" id="c-35885200" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#35884950">parent</a><span>|</span><a href="#35885126">next</a><span>|</span><label class="collapse" for="c-35885200">[-]</label><label class="expand" for="c-35885200">[1 more]</label></div><br/><div class="children"><div class="content">This site is fetched twice, once by your browser, and another time by the JS code after you press the button. For example the JS loader specifies that only one cipher suite is to be used (TLS_AES_128_GCM_SHA256 ), while your browser will definitely support more than one. Any additional traffic is again fetched by your browser.</div><br/></div></div><div id="35885126" class="c"><input type="checkbox" id="c-35885126" checked=""/><div class="controls bullet"><span class="by">laszlokorte</span><span>|</span><a href="#35884950">parent</a><span>|</span><a href="#35885200">prev</a><span>|</span><a href="#35884983">next</a><span>|</span><label class="collapse" for="c-35885126">[-]</label><label class="expand" for="c-35885126">[1 more]</label></div><br/><div class="children"><div class="content">If the annotations were added by the server, yes. Not if they are added client side.</div><br/></div></div></div></div><div id="35884983" class="c"><input type="checkbox" id="c-35884983" checked=""/><div class="controls bullet"><span class="by">captn3m0</span><span>|</span><a href="#35884950">prev</a><span>|</span><a href="#35884711">next</a><span>|</span><label class="collapse" for="c-35884983">[-]</label><label class="expand" for="c-35884983">[3 more]</label></div><br/><div class="children"><div class="content">The subtls hack is an amazing idea. I’ve been wanting to build a TLS Playground for a while(play around with CAs, Cert Issuance, Client Certs etc) and this would be great for it.</div><br/><div id="35885030" class="c"><input type="checkbox" id="c-35885030" checked=""/><div class="controls bullet"><span class="by">gmac</span><span>|</span><a href="#35884983">parent</a><span>|</span><a href="#35884711">next</a><span>|</span><label class="collapse" for="c-35885030">[-]</label><label class="expand" for="c-35885030">[2 more]</label></div><br/><div class="children"><div class="content">Subtls author and OP here. That sounds great — feel free to ping me if useful! (Assemble these into an email address: george mackerron com).</div><br/><div id="35885190" class="c"><input type="checkbox" id="c-35885190" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#35884983">root</a><span>|</span><a href="#35885030">parent</a><span>|</span><a href="#35884711">next</a><span>|</span><label class="collapse" for="c-35885190">[-]</label><label class="expand" for="c-35885190">[1 more]</label></div><br/><div class="children"><div class="content">Would be good to be able to point at any domain, a common issue with debugging cert stuff is working out which cert is being presented, TLS level, cipher suites etc are being negotiated.</div><br/></div></div></div></div></div></div><div id="35884711" class="c"><input type="checkbox" id="c-35884711" checked=""/><div class="controls bullet"><span class="by">globalise83</span><span>|</span><a href="#35884983">prev</a><span>|</span><a href="#35884878">next</a><span>|</span><label class="collapse" for="c-35884711">[-]</label><label class="expand" for="c-35884711">[1 more]</label></div><br/><div class="children"><div class="content">Very good! This would be very helpful for students on every &quot;intro to networks&quot; course on computer science courses as a way to visualise something that can seem very abstract.</div><br/></div></div><div id="35884878" class="c"><input type="checkbox" id="c-35884878" checked=""/><div class="controls bullet"><span class="by">codemanjoe</span><span>|</span><a href="#35884711">prev</a><span>|</span><a href="#35885100">next</a><span>|</span><label class="collapse" for="c-35884878">[-]</label><label class="expand" for="c-35884878">[1 more]</label></div><br/><div class="children"><div class="content">Nice, super helpful for cs students.</div><br/></div></div><div id="35885100" class="c"><input type="checkbox" id="c-35885100" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#35884878">prev</a><span>|</span><label class="collapse" for="c-35885100">[-]</label><label class="expand" for="c-35885100">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of when I first discovered Wireshark (called Ethereal back then). It&#x27;s always a good day when I have to break it out and still fun. I would try to reverse engineer the protocols. It&#x27;s nice to see the annotations here as a lot of it doesn&#x27;t make much sense without it.</div><br/></div></div></div></div></div></div></div></body></html>