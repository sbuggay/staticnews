<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710838876782" as="style"/><link rel="stylesheet" href="styles.css?v=1710838876782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rxdb.info/articles/websockets-sse-polling-webrtc-webtransport.html">WebSockets vs. Server-Sent-Events vs. Long-Polling vs. WebRTC vs. WebTransport</a> <span class="domain">(<a href="https://rxdb.info">rxdb.info</a>)</span></div><div class="subtext"><span>bubblehack3r</span> | <span>161 comments</span></div><br/><div><div id="39747285" class="c"><input type="checkbox" id="c-39747285" checked=""/><div class="controls bullet"><span class="by">kellengreen</span><span>|</span><a href="#39753664">next</a><span>|</span><label class="collapse" for="c-39747285">[-]</label><label class="expand" for="c-39747285">[24 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always had a bit of a soft spot for Server Sent Events. Just simple and easy to use&#x2F;implement.</div><br/><div id="39748463" class="c"><input type="checkbox" id="c-39748463" checked=""/><div class="controls bullet"><span class="by">shams93</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39747508">next</a><span>|</span><label class="collapse" for="c-39748463">[-]</label><label class="expand" for="c-39748463">[5 more]</label></div><br/><div class="children"><div class="content">With ipv6 they can now be fully scaled easily but they are absolutely awesome, much easier to scale because you can give your client a simple list of sse services and its essentially stateless if done right.<p>Websockets get really complex to scale past a certain level of use.</div><br/><div id="39749668" class="c"><input type="checkbox" id="c-39749668" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39748463">parent</a><span>|</span><a href="#39752296">next</a><span>|</span><label class="collapse" for="c-39749668">[-]</label><label class="expand" for="c-39749668">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With ipv6 they can now be fully scaled easily<p>Any day now: <a href="https:&#x2F;&#x2F;www.google.com&#x2F;intl&#x2F;en&#x2F;ipv6&#x2F;statistics.html" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;intl&#x2F;en&#x2F;ipv6&#x2F;statistics.html</a></div><br/></div></div><div id="39752296" class="c"><input type="checkbox" id="c-39752296" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39748463">parent</a><span>|</span><a href="#39749668">prev</a><span>|</span><a href="#39751907">next</a><span>|</span><label class="collapse" for="c-39752296">[-]</label><label class="expand" for="c-39752296">[2 more]</label></div><br/><div class="children"><div class="content">What does ipv6 give you that virtual hosts don&#x27;t?</div><br/><div id="39753165" class="c"><input type="checkbox" id="c-39753165" checked=""/><div class="controls bullet"><span class="by">cushpush</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39752296">parent</a><span>|</span><a href="#39751907">next</a><span>|</span><label class="collapse" for="c-39753165">[-]</label><label class="expand" for="c-39753165">[1 more]</label></div><br/><div class="children"><div class="content">why dropbox when rsync&quot;</div><br/></div></div></div></div><div id="39751907" class="c"><input type="checkbox" id="c-39751907" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39748463">parent</a><span>|</span><a href="#39752296">prev</a><span>|</span><a href="#39747508">next</a><span>|</span><label class="collapse" for="c-39751907">[-]</label><label class="expand" for="c-39751907">[1 more]</label></div><br/><div class="children"><div class="content">is anybody actually able to disable ipv4?  maybe if you only serve vpn or internal users?<p>This might be the best thing about Elixir&#x2F;Phoenix LiveView.  I haven&#x27;t actually had to care in quite some time :-) (though to be fair, I keep things over the websocket pretty light)</div><br/></div></div></div></div><div id="39747508" class="c"><input type="checkbox" id="c-39747508" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39748463">prev</a><span>|</span><a href="#39747600">next</a><span>|</span><label class="collapse" for="c-39747508">[-]</label><label class="expand" for="c-39747508">[1 more]</label></div><br/><div class="children"><div class="content">Works with bog-standard Apache prefork and PHP.</div><br/></div></div><div id="39747600" class="c"><input type="checkbox" id="c-39747600" checked=""/><div class="controls bullet"><span class="by">ajvpot</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39747508">prev</a><span>|</span><a href="#39751161">next</a><span>|</span><label class="collapse" for="c-39747600">[-]</label><label class="expand" for="c-39747600">[13 more]</label></div><br/><div class="children"><div class="content">I agree. Unfortunately you can only have 6 SSE streams per origin per browser instance, so you may be limited to 6 tabs without adding extra complexity on the client side.<p><a href="https:&#x2F;&#x2F;crbug.com&#x2F;275955" rel="nofollow">https:&#x2F;&#x2F;crbug.com&#x2F;275955</a></div><br/><div id="39747641" class="c"><input type="checkbox" id="c-39747641" checked=""/><div class="controls bullet"><span class="by">TheP1000</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747816">next</a><span>|</span><label class="collapse" for="c-39747641">[-]</label><label class="expand" for="c-39747641">[1 more]</label></div><br/><div class="children"><div class="content">Is above still an issue with http2&#x2F;3?<p>edit: From the article: 
To workaround the limitation you have to use HTTP&#x2F;2 or HTTP&#x2F;3 with which the browser will only open a single connection per domain and then use multiplexing to run all data through a single connection.</div><br/></div></div><div id="39747816" class="c"><input type="checkbox" id="c-39747816" checked=""/><div class="controls bullet"><span class="by">andrewmutz</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747641">prev</a><span>|</span><a href="#39747661">next</a><span>|</span><label class="collapse" for="c-39747816">[-]</label><label class="expand" for="c-39747816">[1 more]</label></div><br/><div class="children"><div class="content">You can get around that limit using domain sharding, although it feels a bit hacky.</div><br/></div></div><div id="39747661" class="c"><input type="checkbox" id="c-39747661" checked=""/><div class="controls bullet"><span class="by">ravxx</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747816">prev</a><span>|</span><a href="#39747994">next</a><span>|</span><label class="collapse" for="c-39747661">[-]</label><label class="expand" for="c-39747661">[4 more]</label></div><br/><div class="children"><div class="content">just use a service worker to share state, you would be much better off doing this anyways. saves a ton and is performant.</div><br/><div id="39747739" class="c"><input type="checkbox" id="c-39747739" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747661">parent</a><span>|</span><a href="#39747994">next</a><span>|</span><label class="collapse" for="c-39747739">[-]</label><label class="expand" for="c-39747739">[3 more]</label></div><br/><div class="children"><div class="content">I think you need a SharedWorker for that rather than a service worker <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;SharedWorker" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;SharedWorke...</a></div><br/><div id="39752305" class="c"><input type="checkbox" id="c-39752305" checked=""/><div class="controls bullet"><span class="by">jedschmidt</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747739">parent</a><span>|</span><a href="#39747994">next</a><span>|</span><label class="collapse" for="c-39752305">[-]</label><label class="expand" for="c-39752305">[2 more]</label></div><br/><div class="children"><div class="content">A service worker would work fine; the connection would be instantiated from the SW and each window&#x2F;worker could communicate with it via navigator.serviceWorker.</div><br/><div id="39753021" class="c"><input type="checkbox" id="c-39753021" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39752305">parent</a><span>|</span><a href="#39747994">next</a><span>|</span><label class="collapse" for="c-39753021">[-]</label><label class="expand" for="c-39753021">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t work because browsers have duration limits on ServiceWorkers:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;w3c&#x2F;ServiceWorker&#x2F;issues&#x2F;980#issuecomment-782094985">https:&#x2F;&#x2F;github.com&#x2F;w3c&#x2F;ServiceWorker&#x2F;issues&#x2F;980#issuecomment...</a><p>Also unfortunately Chrome doesn&#x27;t keep SharedWorker alive after a navigation (Firefox and Safari do):<p><a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40284712" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40284712</a><p>Hopefully Chrome will fix this eventually, it really makes it hard to build performant MPAs.</div><br/></div></div></div></div></div></div></div></div><div id="39747994" class="c"><input type="checkbox" id="c-39747994" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747661">prev</a><span>|</span><a href="#39747697">next</a><span>|</span><label class="collapse" for="c-39747994">[-]</label><label class="expand" for="c-39747994">[2 more]</label></div><br/><div class="children"><div class="content">Can the tabs share a background worker that would handle that?</div><br/><div id="39748040" class="c"><input type="checkbox" id="c-39748040" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747994">parent</a><span>|</span><a href="#39747697">next</a><span>|</span><label class="collapse" for="c-39748040">[-]</label><label class="expand" for="c-39748040">[1 more]</label></div><br/><div class="children"><div class="content">You can use <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;broadcast-channel" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;broadcast-channel</a> which creates a tab leader, no need for a background worker<p>Edit: of course you could use: <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;sharedworkers" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;sharedworkers</a> but android does not support it. We migrated to the lib because safari took its time… so mobile was&#x2F;is not a thing for us</div><br/></div></div></div></div><div id="39747697" class="c"><input type="checkbox" id="c-39747697" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747994">prev</a><span>|</span><a href="#39751189">next</a><span>|</span><label class="collapse" for="c-39747697">[-]</label><label class="expand" for="c-39747697">[3 more]</label></div><br/><div class="children"><div class="content">Is that true if you are using HTTP&#x2F;2?</div><br/><div id="39751648" class="c"><input type="checkbox" id="c-39751648" checked=""/><div class="controls bullet"><span class="by">hobobaggins</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747697">parent</a><span>|</span><a href="#39751223">next</a><span>|</span><label class="collapse" for="c-39751648">[-]</label><label class="expand" for="c-39751648">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the limit is different (usually much higher) and negotiated, up to maximum SETTINGS_MAX_CONCURRENT_STREAMS (which is fixed at 100 in Chrome, and apparently less in IOS&#x2F;Safari.)</div><br/></div></div><div id="39751223" class="c"><input type="checkbox" id="c-39751223" checked=""/><div class="controls bullet"><span class="by">cassepipe</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747697">parent</a><span>|</span><a href="#39751648">prev</a><span>|</span><a href="#39751189">next</a><span>|</span><label class="collapse" for="c-39751223">[-]</label><label class="expand" for="c-39751223">[1 more]</label></div><br/><div class="children"><div class="content">Nope. That&#x27;s only a problem with HTTP&#x2F;1.1</div><br/></div></div></div></div><div id="39751189" class="c"><input type="checkbox" id="c-39751189" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39747285">root</a><span>|</span><a href="#39747600">parent</a><span>|</span><a href="#39747697">prev</a><span>|</span><a href="#39751161">next</a><span>|</span><label class="collapse" for="c-39751189">[-]</label><label class="expand" for="c-39751189">[1 more]</label></div><br/><div class="children"><div class="content">HTTP 2&#x2F;3 doesn&#x27;t have they limitation.<p>For HTTP 1, simply shard the domain.</div><br/></div></div></div></div><div id="39751161" class="c"><input type="checkbox" id="c-39751161" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39747600">prev</a><span>|</span><a href="#39751767">next</a><span>|</span><label class="collapse" for="c-39751161">[-]</label><label class="expand" for="c-39751161">[1 more]</label></div><br/><div class="children"><div class="content">The downside is that you have to base64 payloads or otherwise remove newlines.<p>I wonder why they didn&#x27;t just a multipart streamed response.<p>Supports my metadata, very commonly implemented format</div><br/></div></div><div id="39751767" class="c"><input type="checkbox" id="c-39751767" checked=""/><div class="controls bullet"><span class="by">fswd</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39751161">prev</a><span>|</span><a href="#39747525">next</a><span>|</span><label class="collapse" for="c-39751767">[-]</label><label class="expand" for="c-39751767">[1 more]</label></div><br/><div class="children"><div class="content">don&#x27;t forget the timeout reconnect!</div><br/></div></div><div id="39747525" class="c"><input type="checkbox" id="c-39747525" checked=""/><div class="controls bullet"><span class="by">marban</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39751767">prev</a><span>|</span><a href="#39749930">next</a><span>|</span><label class="collapse" for="c-39747525">[-]</label><label class="expand" for="c-39747525">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely underrated.</div><br/></div></div><div id="39749930" class="c"><input type="checkbox" id="c-39749930" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39747285">parent</a><span>|</span><a href="#39747525">prev</a><span>|</span><a href="#39753664">next</a><span>|</span><label class="collapse" for="c-39749930">[-]</label><label class="expand" for="c-39749930">[1 more]</label></div><br/><div class="children"><div class="content">SSE are really a subset of Comet-Stream (eternal HTTP response with Transfer-Encoding: chunked) only they use a header (Accept: text&#x2F;event-stream) and wraps the chunks with &quot;data:&quot; and &quot;\n\n&quot;.<p>But yes it&#x27;s the superior (simplest, most robust, most performant and scalable) way to do real-time for eternity.<p>The browser is dead, but SSE will keep on doing work for native apps.</div><br/></div></div></div></div><div id="39753664" class="c"><input type="checkbox" id="c-39753664" checked=""/><div class="controls bullet"><span class="by">tdudhhu</span><span>|</span><a href="#39747285">prev</a><span>|</span><a href="#39748216">next</a><span>|</span><label class="collapse" for="c-39753664">[-]</label><label class="expand" for="c-39753664">[1 more]</label></div><br/><div class="children"><div class="content">Not in the article by also relevant is short polling. While this does not send messages from a server to a client it can still be useful when all other options are not available (on shared hosting for example).<p>In my experience it even works great when the poll interval is long (for example 20 seconds) but when you also include the message list in each response. That way the client will be up to date when it interacts with the server: user presses a button -&gt; the client sends a request to the server -&gt; the server reponds with data and also a list of the latest messages.</div><br/></div></div><div id="39748216" class="c"><input type="checkbox" id="c-39748216" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39753664">prev</a><span>|</span><a href="#39747423">next</a><span>|</span><label class="collapse" for="c-39748216">[-]</label><label class="expand" for="c-39748216">[13 more]</label></div><br/><div class="children"><div class="content">A few additional cons to be aware of:<p>WebSockets lack flow control (backpressure) and multiplexing, so if you need them you either roll your own or use something similar to RSocket.<p>Also SSE can&#x27;t send binary data directly. You have to base64 encode it or similar.<p>WebTransport addresses these and also solves head of line blocking. But I&#x27;m concerned that we might run into a similar problem as we had with going from Python2 to Python3 and IPv6. Too easy for people to keep using the old version, and too little (perceived) benefit to upgrading.<p>As long as browsers still work with TCP, some networks will continue to block UDP (and thus HTTP3&#x2F;WebTransport) outright.</div><br/><div id="39748388" class="c"><input type="checkbox" id="c-39748388" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39748216">parent</a><span>|</span><a href="#39750972">next</a><span>|</span><label class="collapse" for="c-39748388">[-]</label><label class="expand" for="c-39748388">[5 more]</label></div><br/><div class="children"><div class="content">&gt; WebSockets lack flow control (backpressure) and multiplexing, so if you need them you either roll your own or use something similar to RSocket.<p>Yes, head of line blocking is an issue, but TCP provides flow control, and if you&#x27;re not using that, you&#x27;re going over HTTP3.<p>&gt; WebTransport addresses these and also solves head of line blocking. But I&#x27;m concerned that we might run into a similar problem as we had with going from Python2 to Python3 and IPv6. Too easy for people to keep using the old version, and too little (perceived) benefit to upgrading.<p>At one time or another, one could have said the same thing about TLS transport, HTTP3, or XHR itself. Because of the comparatively huge domination of a few key browser engines, it&#x27;s much easier to roll out new browser capabilities &amp; protocols.<p>&gt; As long as browsers still work with TCP, some networks will continue to block UDP (and thus HTTP3&#x2F;WebTransport) outright.<p>By that logic, as long as browsers still work with HTTP 1.1 without TLS, some networks will continue to block HTTP 2 and TLS. While that&#x27;s not entirely incorrect, the broad adoption of HTTP2 and TLS in particular suggests it&#x27;s less of a problem than you think.</div><br/><div id="39748948" class="c"><input type="checkbox" id="c-39748948" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39748388">parent</a><span>|</span><a href="#39750972">next</a><span>|</span><label class="collapse" for="c-39748948">[-]</label><label class="expand" for="c-39748948">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, head of line blocking is an issue, but TCP provides flow control<p>Unfortunately, the way browsers implement WebSocket it undermines TCP&#x27;s flow control. It&#x27;s trivial to crash a browser tab by opening a (larger than RAM) file and trying to stream it to a server using a tight loop sending on a WebSocket. WebSocket.bufferedAmount exists, but as of 2019 I failed to use it to solve this problem and had to implement application-level backpressure.<p>&gt; At one time or another, one could have said the same thing about TLS transport, HTTP3, or XHR itself. Because of the comparatively huge domination of a few key browser engines, it&#x27;s much easier to roll out new browser capabilities &amp; protocols.<p>&gt; By that logic, as long as browsers still work with HTTP 1.1 without TLS, some networks will continue to block HTTP 2 and TLS. While that&#x27;s not entirely incorrect, the broad adoption of HTTP2 and TLS in particular suggests it&#x27;s less of a problem than you think.<p>HTTP3 actually falls under my concern. There are still networks that block HTTP3, because it has really nice fallback to HTTP2&#x2F;1.1, so there&#x27;s no obvious impact on users.<p>So I guess the real question is will QUIC be an HTTP&#x2F;2 or an IPv6, or something in between? Was HTTP&#x2F;2 ever actively blocked the way UDP is? If so that certainly gives us hope.<p>The reason I care is that I&#x27;m currently developing a protocol that WebTransport is an excellent fit for. But I can&#x27;t assume WebTransport will work because UDP might be blocked, so I&#x27;m having to implement WebSocket support as well, which is a lot more work.</div><br/><div id="39750186" class="c"><input type="checkbox" id="c-39750186" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39748948">parent</a><span>|</span><a href="#39749095">next</a><span>|</span><label class="collapse" for="c-39750186">[-]</label><label class="expand" for="c-39750186">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Unfortunately, the way browsers implement WebSocket it undermines TCP&#x27;s flow control. It&#x27;s trivial to crash a browser tab by opening a (larger than RAM) file and trying to stream it to a server using a tight loop sending on a WebSocket. WebSocket.bufferedAmount exists, but as of 2019 I failed to use it to solve this problem and had to implement application-level backpressure.<p>Before you were saying, &quot;WebSockets lack flow control (backpressure) and multiplexing, so if you need them you either roll your own or use something similar to RSocket.&quot;, and now you&#x27;re saying you can&#x27;t roll your own? ;-)<p>&gt; HTTP3 actually falls under my concern. There are still networks that block HTTP3, because it has really nice fallback to HTTP2&#x2F;1.1, so there&#x27;s no obvious impact on users.<p>Erm, HTTP2 &amp; HTTP 1.1 have their own problems, some of which you yourself have identified. We actually rolled back from HTTP2 to HTTP 1.1 because of problems with HTTP2, particularly with mobile performance.<p>Our migration to HTTP3 has been all win so far. While UDP might be blocked for security reasons, there are security reasons to move to HTTP3.<p>That said, there are cases where only HTTP&#x2F;1.0 is supported.<p>&gt; The reason I care is that I&#x27;m currently developing a protocol that WebTransport is an excellent fit for. But I can&#x27;t assume WebTransport will work because UDP might be blocked, so I&#x27;m having to implement WebSocket support as well, which is a lot more work.<p>I feel your pain. I&#x27;ve been using WebRTC, and the vast majority of the time UDP doesn&#x27;t seem to be blocked anymore. That said, adoption of HTTP3 seems to be about half that of HTTP2 right now. Not bad for a brand new protocol, but I&#x27;d say we still have a significant amount of time to go before HTTP3 is the dominant protocol. I think the path forward is going to require some toil by the likes of you to support both, but no reason you can&#x27;t support HTTP3 better! ;-)</div><br/><div id="39751375" class="c"><input type="checkbox" id="c-39751375" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39750186">parent</a><span>|</span><a href="#39749095">next</a><span>|</span><label class="collapse" for="c-39751375">[-]</label><label class="expand" for="c-39751375">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Before you were saying, &quot;WebSockets lack flow control (backpressure) and multiplexing, so if you need them you either roll your own or use something similar to RSocket.&quot;, and now you&#x27;re saying you can&#x27;t roll your own? ;-)<p>You can, but you need to do it at the application level, which is a lot more involved. It would be nice if it were as simple as checking if bufferAmount &gt; some threshold and then waiting on a promise before attempting to send again. That&#x27;s essentially what you get with ReadableStream and WritableStream, which are provided by WebTransport.<p>&gt; Erm, HTTP2 &amp; HTTP 1.1 have their own problems, some of which you yourself have identified. We actually rolled back from HTTP2 to HTTP 1.1 because of problems with HTTP2, particularly with mobile performance.<p>Not sure if we&#x27;re actually disagreeing here. In any case, we can both agree HTTP2 is not a panacea, and actually worse than HTTP&#x2F;1.1 in some cases.<p>&gt; That said, adoption of HTTP3 seems to be about half that of HTTP2 right now. Not bad for a brand new protocol, but I&#x27;d say we still have a significant amount of time to go before HTTP3 is the dominant protocol.<p>Here here. Overall I&#x27;m bullish on HTTP3 in the long run. I really just hope random enterprise networks don&#x27;t decide to block it. In any case, it&#x27;s going to be a big win for the places where it works.</div><br/></div></div></div></div><div id="39749095" class="c"><input type="checkbox" id="c-39749095" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39748948">parent</a><span>|</span><a href="#39750186">prev</a><span>|</span><a href="#39750972">next</a><span>|</span><label class="collapse" for="c-39749095">[-]</label><label class="expand" for="c-39749095">[1 more]</label></div><br/><div class="children"><div class="content">HTTP&#x2F;2 traffic was looking essentially the same as HTTP&#x2F;1.1 + TLS.<p>It wasn&#x27;t particularly interesting to block to begin with. UDP if blocked, then it&#x27;s blocked in a name of Security.</div><br/></div></div></div></div></div></div><div id="39750972" class="c"><input type="checkbox" id="c-39750972" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#39748216">parent</a><span>|</span><a href="#39748388">prev</a><span>|</span><a href="#39749069">next</a><span>|</span><label class="collapse" for="c-39750972">[-]</label><label class="expand" for="c-39750972">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As long as browsers still work with TCP, some networks will continue to block UDP (and thus HTTP3&#x2F;WebTransport) outright.<p>HTTP2 should still work in that scenario then you don&#x27;t need to worry about multiplexing.</div><br/><div id="39751327" class="c"><input type="checkbox" id="c-39751327" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39750972">parent</a><span>|</span><a href="#39749069">next</a><span>|</span><label class="collapse" for="c-39751327">[-]</label><label class="expand" for="c-39751327">[2 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t use HTTP2 directly in the browser. Or are you referring to something else?</div><br/><div id="39753243" class="c"><input type="checkbox" id="c-39753243" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39751327">parent</a><span>|</span><a href="#39749069">next</a><span>|</span><label class="collapse" for="c-39753243">[-]</label><label class="expand" for="c-39753243">[1 more]</label></div><br/><div class="children"><div class="content">All browsers released since the end of 2015 support HTTP2. If the server supports it the browser will use it. Unlike HTTP3 this is all TCP.<p>If you connect to a WebSocket over an HTTP2 connection then you don&#x27;t need to worry about multiplexing since you can rely on the browser doing it for you - HTTP2 connections support over 200 concurrent streams.</div><br/></div></div></div></div></div></div><div id="39749069" class="c"><input type="checkbox" id="c-39749069" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#39748216">parent</a><span>|</span><a href="#39750972">prev</a><span>|</span><a href="#39750163">next</a><span>|</span><label class="collapse" for="c-39749069">[-]</label><label class="expand" for="c-39749069">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As long as browsers still work with TCP, some networks will continue to block UDP (and thus HTTP3&#x2F;WebTransport) outright.<p>I keep hearing it, but I&#x27;ve never actually seen such a network. There are many things that run on UDP. I can see it being closed in some tiny offices (but those usually lack brain power to accomplish it) or some dystopian corporate offices you can only see in a movie.<p>I really don&#x27;t see how the fact that some networks might ban UDP has anything to do with it. Some networks ban google.com and wikipedia.com, you don&#x27;t see them failing.</div><br/><div id="39749123" class="c"><input type="checkbox" id="c-39749123" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39749069">parent</a><span>|</span><a href="#39749140">next</a><span>|</span><label class="collapse" for="c-39749123">[-]</label><label class="expand" for="c-39749123">[1 more]</label></div><br/><div class="children"><div class="content">In their excellent article on NAT traversal[0], Tailscale mentions that the UC Berkeley guest wifi blocks all outbound UDP except DNS.<p>EDIT: According to this[1] issue, Berkeley guest wifi allows port 443, which would solve HTTP3&#x2F;WebTransport. That&#x27;s certainly hopeful, and I hope all networks are like this in the future. It&#x27;s just not a forgone conclusion yet.<p>[0]: <a href="https:&#x2F;&#x2F;tailscale.com&#x2F;blog&#x2F;how-nat-traversal-works#have-you-considered-giving-up" rel="nofollow">https:&#x2F;&#x2F;tailscale.com&#x2F;blog&#x2F;how-nat-traversal-works#have-you-...</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;danderson&#x2F;natlab&#x2F;issues&#x2F;1">https:&#x2F;&#x2F;github.com&#x2F;danderson&#x2F;natlab&#x2F;issues&#x2F;1</a></div><br/></div></div><div id="39749140" class="c"><input type="checkbox" id="c-39749140" checked=""/><div class="controls bullet"><span class="by">CodesInChaos</span><span>|</span><a href="#39748216">root</a><span>|</span><a href="#39749069">parent</a><span>|</span><a href="#39749123">prev</a><span>|</span><a href="#39750163">next</a><span>|</span><label class="collapse" for="c-39749140">[-]</label><label class="expand" for="c-39749140">[1 more]</label></div><br/><div class="children"><div class="content">Not a traditional network, but Tor doesn&#x27;t support UDP.</div><br/></div></div></div></div></div></div><div id="39747423" class="c"><input type="checkbox" id="c-39747423" checked=""/><div class="controls bullet"><span class="by">rvanmil</span><span>|</span><a href="#39748216">prev</a><span>|</span><a href="#39747746">next</a><span>|</span><label class="collapse" for="c-39747423">[-]</label><label class="expand" for="c-39747423">[11 more]</label></div><br/><div class="children"><div class="content">Or, if you’re building for clients with a traditional “enterprise” and  “secure” IT infrastructure: add refresh buttons and call it a day.  
If there’s one thing in my experience that consistently fails in these environments and cannot be fixed due to endless red tape, it’s trying to make real-time work for these type of clients.</div><br/><div id="39753031" class="c"><input type="checkbox" id="c-39753031" checked=""/><div class="controls bullet"><span class="by">palmfacehn</span><span>|</span><a href="#39747423">parent</a><span>|</span><a href="#39748254">next</a><span>|</span><label class="collapse" for="c-39753031">[-]</label><label class="expand" for="c-39753031">[1 more]</label></div><br/><div class="children"><div class="content">Jetty&#x2F;CometD will fall back to long polling if other transports are not available.</div><br/></div></div><div id="39748254" class="c"><input type="checkbox" id="c-39748254" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747423">parent</a><span>|</span><a href="#39753031">prev</a><span>|</span><a href="#39748083">next</a><span>|</span><label class="collapse" for="c-39748254">[-]</label><label class="expand" for="c-39748254">[4 more]</label></div><br/><div class="children"><div class="content">Honestly, all the techniques for this stuff have their problems, including the refresh button.</div><br/><div id="39748393" class="c"><input type="checkbox" id="c-39748393" checked=""/><div class="controls bullet"><span class="by">rvanmil</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748254">parent</a><span>|</span><a href="#39748083">next</a><span>|</span><label class="collapse" for="c-39748393">[-]</label><label class="expand" for="c-39748393">[3 more]</label></div><br/><div class="children"><div class="content">True, though when carefully implemented it’s the most reliable option I guess.</div><br/><div id="39748426" class="c"><input type="checkbox" id="c-39748426" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748393">parent</a><span>|</span><a href="#39748083">next</a><span>|</span><label class="collapse" for="c-39748426">[-]</label><label class="expand" for="c-39748426">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve switched to using SSE to get around problems with the refresh button. It&#x27;s pretty simple and reliable.</div><br/><div id="39748903" class="c"><input type="checkbox" id="c-39748903" checked=""/><div class="controls bullet"><span class="by">rvanmil</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748426">parent</a><span>|</span><a href="#39748083">next</a><span>|</span><label class="collapse" for="c-39748903">[-]</label><label class="expand" for="c-39748903">[1 more]</label></div><br/><div class="children"><div class="content">That’s great. Unfortunately I’ve seen SSE fail quite a few times in the scenario I described.</div><br/></div></div></div></div></div></div></div></div><div id="39748083" class="c"><input type="checkbox" id="c-39748083" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#39747423">parent</a><span>|</span><a href="#39748254">prev</a><span>|</span><a href="#39747746">next</a><span>|</span><label class="collapse" for="c-39748083">[-]</label><label class="expand" for="c-39748083">[5 more]</label></div><br/><div class="children"><div class="content">My browser has a refresh button. Alas your application likely breaks when I use it.</div><br/><div id="39748420" class="c"><input type="checkbox" id="c-39748420" checked=""/><div class="controls bullet"><span class="by">rvanmil</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748083">parent</a><span>|</span><a href="#39747746">next</a><span>|</span><label class="collapse" for="c-39748420">[-]</label><label class="expand" for="c-39748420">[4 more]</label></div><br/><div class="children"><div class="content">Not entirely sure why it would break…?</div><br/><div id="39750756" class="c"><input type="checkbox" id="c-39750756" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748420">parent</a><span>|</span><a href="#39750084">next</a><span>|</span><label class="collapse" for="c-39750756">[-]</label><label class="expand" for="c-39750756">[2 more]</label></div><br/><div class="children"><div class="content">Clearly I don’t know what <i>your</i> application is, but many heavyweight “web apps” don’t cope with a simple refresh, kicking back to a default screen or even login screen in some cases.</div><br/><div id="39751696" class="c"><input type="checkbox" id="c-39751696" checked=""/><div class="controls bullet"><span class="by">hobobaggins</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39750756">parent</a><span>|</span><a href="#39750084">next</a><span>|</span><label class="collapse" for="c-39751696">[-]</label><label class="expand" for="c-39751696">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes this is to scope logins to single tabs for security reasons (I think that&#x27;s why Userify does it that way). It&#x27;s annoying but for infrequently used apps, no worse than getting logged out every three minutes.</div><br/></div></div></div></div><div id="39750084" class="c"><input type="checkbox" id="c-39750084" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39747423">root</a><span>|</span><a href="#39748420">parent</a><span>|</span><a href="#39750756">prev</a><span>|</span><a href="#39747746">next</a><span>|</span><label class="collapse" for="c-39750084">[-]</label><label class="expand" for="c-39750084">[1 more]</label></div><br/><div class="children"><div class="content">client side state that isn&#x27;t in the URL or local storage</div><br/></div></div></div></div></div></div></div></div><div id="39747746" class="c"><input type="checkbox" id="c-39747746" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39747423">prev</a><span>|</span><a href="#39747798">next</a><span>|</span><label class="collapse" for="c-39747746">[-]</label><label class="expand" for="c-39747746">[4 more]</label></div><br/><div class="children"><div class="content">This is probably naive, but it seems like assuming HTTP&#x2F;2 or better, an EventSource combined with fetch() for sending messages should be just as good as any other protocol that uses a single TCP connection? And HTTP&#x2F;3 uses UDP, so even better.<p>(This all assumes you only care about maintaining a connection when the tab is in the foreground.)<p>I’m wondering what problems people have run into when they tried this.</div><br/><div id="39749730" class="c"><input type="checkbox" id="c-39749730" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747746">parent</a><span>|</span><a href="#39751884">next</a><span>|</span><label class="collapse" for="c-39749730">[-]</label><label class="expand" for="c-39749730">[1 more]</label></div><br/><div class="children"><div class="content">One limitation is SSE is text-only, so you can&#x27;t efficiently send binary data. You have to encode it as base64 or similar.</div><br/></div></div><div id="39751884" class="c"><input type="checkbox" id="c-39751884" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#39747746">parent</a><span>|</span><a href="#39749730">prev</a><span>|</span><a href="#39748596">next</a><span>|</span><label class="collapse" for="c-39751884">[-]</label><label class="expand" for="c-39751884">[1 more]</label></div><br/><div class="children"><div class="content">Was thinking exactly the same thing. H2 with SSE solves 99% of problems? I was wondering if we could push SSE even further along with lower latency, memory usage and CPU resources than doing something completely different.</div><br/></div></div><div id="39748596" class="c"><input type="checkbox" id="c-39748596" checked=""/><div class="controls bullet"><span class="by">jacobr1</span><span>|</span><a href="#39747746">parent</a><span>|</span><a href="#39751884">prev</a><span>|</span><a href="#39747798">next</a><span>|</span><label class="collapse" for="c-39748596">[-]</label><label class="expand" for="c-39748596">[1 more]</label></div><br/><div class="children"><div class="content">This presumes the majority of your use case is server-client, but otherwise yes.</div><br/></div></div></div></div><div id="39747798" class="c"><input type="checkbox" id="c-39747798" checked=""/><div class="controls bullet"><span class="by">Fabricio20</span><span>|</span><a href="#39747746">prev</a><span>|</span><a href="#39748840">next</a><span>|</span><label class="collapse" for="c-39747798">[-]</label><label class="expand" for="c-39747798">[17 more]</label></div><br/><div class="children"><div class="content">To this day I still dont know why WebSockets and SSE dont support sending headers on the initial request, such as Authorization. Leaving authentication on realtime services entirely up to whoever is implementing the service.<p>I may be wrong here and the spec suggests a good way to do it, but i&#x27;ve seen so many different approaches that at this point might as well say there&#x27;s none.</div><br/><div id="39751382" class="c"><input type="checkbox" id="c-39751382" checked=""/><div class="controls bullet"><span class="by">rexxars</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39747916">next</a><span>|</span><label class="collapse" for="c-39751382">[-]</label><label class="expand" for="c-39751382">[3 more]</label></div><br/><div class="children"><div class="content">The EventSource API (the browser &quot;client API&quot; for Server-Sent Events) leaves a lot to be desired. While I am a maintainer of the most used EventSource polyfill[1], I&#x27;ve recently started a new project that aims to be a modern take on what an EventSource client could be: <a href="https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client">https:&#x2F;&#x2F;github.com&#x2F;rexxars&#x2F;eventsource-client</a>.<p>Beyond handling the custom headers aspect, it also supports any request method (POST, PATCH..), allows you to include a request body, allows subscribing to any named event (the EventSource `onmessage` vs `on(&#x27;named event&#x27;)` is very confusing), as well as setting an initial last event ID (which can be helpful when restoring state after a reload or similar). And you can use it as an async iterator.<p>I love the simplicity of Server-Sent Events, but the `EventSource` API seem to me like a rushed implementation that just kinda stuck around.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;eventsource&#x2F;eventsource">https:&#x2F;&#x2F;github.com&#x2F;eventsource&#x2F;eventsource</a></div><br/><div id="39753348" class="c"><input type="checkbox" id="c-39753348" checked=""/><div class="controls bullet"><span class="by">martypitt</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39751382">parent</a><span>|</span><a href="#39747916">next</a><span>|</span><label class="collapse" for="c-39753348">[-]</label><label class="expand" for="c-39753348">[2 more]</label></div><br/><div class="children"><div class="content">Nice work! This addresses many of the issues I&#x27;ve had with SSE.<p>Another problem we&#x27;ve never worked out the solution to, is how to send a termination - signalling &quot;there are no more events coming&quot;. We always end up having to roll our own, though it felt like something that should&#x27;ve been handled at the protocol layer.</div><br/><div id="39753438" class="c"><input type="checkbox" id="c-39753438" checked=""/><div class="controls bullet"><span class="by">skinner927</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39753348">parent</a><span>|</span><a href="#39747916">next</a><span>|</span><label class="collapse" for="c-39753438">[-]</label><label class="expand" for="c-39753438">[1 more]</label></div><br/><div class="children"><div class="content">Just read the spec<p>Clients will reconnect if the connection is closed; a client can be told to stop reconnecting using the HTTP 204 No Content response code.</div><br/></div></div></div></div></div></div><div id="39747916" class="c"><input type="checkbox" id="c-39747916" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39751382">prev</a><span>|</span><a href="#39748085">next</a><span>|</span><label class="collapse" for="c-39747916">[-]</label><label class="expand" for="c-39747916">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; To this day I still dont know why WebSockets and SSE dont support sending headers on the initial request</i><p>Doesn&#x27;t the initial request get to send a full set of standard HTTP headers, cookies and all?</div><br/><div id="39748348" class="c"><input type="checkbox" id="c-39748348" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39747916">parent</a><span>|</span><a href="#39748085">next</a><span>|</span><label class="collapse" for="c-39748348">[-]</label><label class="expand" for="c-39748348">[3 more]</label></div><br/><div class="children"><div class="content">It does, but if you&#x27;re calling it from the browser you can&#x27;t add arbitrary data to them (the way you can in e.g. a `fetch`)</div><br/><div id="39749498" class="c"><input type="checkbox" id="c-39749498" checked=""/><div class="controls bullet"><span class="by">makkesk8</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39748348">parent</a><span>|</span><a href="#39750940">next</a><span>|</span><label class="collapse" for="c-39749498">[-]</label><label class="expand" for="c-39749498">[1 more]</label></div><br/><div class="children"><div class="content">Someone at Azure thought of this[1]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;fetch-event-source">https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;fetch-event-source</a></div><br/></div></div><div id="39750940" class="c"><input type="checkbox" id="c-39750940" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39748348">parent</a><span>|</span><a href="#39749498">prev</a><span>|</span><a href="#39748085">next</a><span>|</span><label class="collapse" for="c-39750940">[-]</label><label class="expand" for="c-39750940">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>you can&#x27;t add arbitrary data to them</i><p>What about intercepting the request with a service worker?</div><br/></div></div></div></div></div></div><div id="39748085" class="c"><input type="checkbox" id="c-39748085" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39747916">prev</a><span>|</span><a href="#39748156">next</a><span>|</span><label class="collapse" for="c-39748085">[-]</label><label class="expand" for="c-39748085">[2 more]</label></div><br/><div class="children"><div class="content">They do send cookies.</div><br/><div id="39753953" class="c"><input type="checkbox" id="c-39753953" checked=""/><div class="controls bullet"><span class="by">Sammi</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39748085">parent</a><span>|</span><a href="#39748156">next</a><span>|</span><label class="collapse" for="c-39753953">[-]</label><label class="expand" for="c-39753953">[1 more]</label></div><br/><div class="children"><div class="content">I do login the bog standard way with a regular old http request and the server responds with setting an http only cookie. Then I reconnect the websocket, which will then provide the cookie to the server on reconnect.</div><br/></div></div></div></div><div id="39748156" class="c"><input type="checkbox" id="c-39748156" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39748085">prev</a><span>|</span><a href="#39747914">next</a><span>|</span><label class="collapse" for="c-39748156">[-]</label><label class="expand" for="c-39748156">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s always TLS certificates... ;-)</div><br/></div></div><div id="39747914" class="c"><input type="checkbox" id="c-39747914" checked=""/><div class="controls bullet"><span class="by">omgtehlion</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39748156">prev</a><span>|</span><a href="#39748249">next</a><span>|</span><label class="collapse" for="c-39747914">[-]</label><label class="expand" for="c-39747914">[5 more]</label></div><br/><div class="children"><div class="content">Wait, what?? Been using these for years. Am I missing something?</div><br/><div id="39748101" class="c"><input type="checkbox" id="c-39748101" checked=""/><div class="controls bullet"><span class="by">tytho</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39747914">parent</a><span>|</span><a href="#39748089">next</a><span>|</span><label class="collapse" for="c-39748101">[-]</label><label class="expand" for="c-39748101">[3 more]</label></div><br/><div class="children"><div class="content">The browser EventSource constructor does not have options to pass in your own headers. You can pass an option to have it use the cookies for the domain you’re using. There are libraries that allow you to pass in additional HTTP options, but they essentially reimplement the built-in EventSource object in order to do so. Not terribly difficult, fairly simple spec.</div><br/><div id="39748306" class="c"><input type="checkbox" id="c-39748306" checked=""/><div class="controls bullet"><span class="by">omgtehlion</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39748101">parent</a><span>|</span><a href="#39748089">next</a><span>|</span><label class="collapse" for="c-39748306">[-]</label><label class="expand" for="c-39748306">[2 more]</label></div><br/><div class="children"><div class="content">Well, that constructor by default sends all the headers you have for your own domain and auth you are entitled to. This is how all other APIs in browsers work due to security and privacy concerns.<p>If you call to other domains, then this problem is no different to what we had with CORS years ago.</div><br/><div id="39749756" class="c"><input type="checkbox" id="c-39749756" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39748306">parent</a><span>|</span><a href="#39748089">next</a><span>|</span><label class="collapse" for="c-39749756">[-]</label><label class="expand" for="c-39749756">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is how all other APIs in browsers work due to security and privacy concerns<p>They&#x27;re probably comparing it to the fetch and XHR APIs, which both allow custom headers.</div><br/></div></div></div></div></div></div><div id="39748089" class="c"><input type="checkbox" id="c-39748089" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747798">root</a><span>|</span><a href="#39747914">parent</a><span>|</span><a href="#39748101">prev</a><span>|</span><a href="#39748249">next</a><span>|</span><label class="collapse" for="c-39748089">[-]</label><label class="expand" for="c-39748089">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re probably referring to browsers specifically. The WebSocket constructor doesn&#x27;t allow for headers</div><br/></div></div></div></div><div id="39748249" class="c"><input type="checkbox" id="c-39748249" checked=""/><div class="controls bullet"><span class="by">paol</span><span>|</span><a href="#39747798">parent</a><span>|</span><a href="#39747914">prev</a><span>|</span><a href="#39748840">next</a><span>|</span><label class="collapse" for="c-39748249">[-]</label><label class="expand" for="c-39748249">[1 more]</label></div><br/><div class="children"><div class="content">Oooh boy you touched a pet peeve. I mean who needs authentication on the modern Web right? &#x2F;s<p>The even more irritating thing is that there is nothing preventing this, and every server I&#x27;ve tried supports it. It&#x27;s only the <i>browser</i> WebSocket API that was designed without this. Cookies are the only thing browsers will deign to send in the initial request.</div><br/></div></div></div></div><div id="39748840" class="c"><input type="checkbox" id="c-39748840" checked=""/><div class="controls bullet"><span class="by">eightnoteight</span><span>|</span><a href="#39747798">prev</a><span>|</span><a href="#39747670">next</a><span>|</span><label class="collapse" for="c-39748840">[-]</label><label class="expand" for="c-39748840">[4 more]</label></div><br/><div class="children"><div class="content">websockets and sse are a big headache to manage at scale, especially backend, requires special observability, if not implemented really carefully on mobile devices its a nightmare to debug on frontend side<p>devices switch off network or slow down etc,... for battery conservation, or when you don&#x27;t explicitly do the I&#x2F;O using a dedicated API for it.<p>new connection setup is a costly operation, the server has to store the state somewhere and when this stateful layer faces any issue, clients keep retrying and timing out. forever stuck on performing this costly operation. it&#x27;s not like there is an easy way to control the throughput and slowly put the load on database<p>reliability wise long polling is the best one IME, if event based flow is really important, even then its better to have a 2 layer backend, where frontend does long polling on the 1st layer which then subscribes to websockets to the 2nd layer backend. much better control in terms of reliability</div><br/><div id="39751621" class="c"><input type="checkbox" id="c-39751621" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#39748840">parent</a><span>|</span><a href="#39748904">next</a><span>|</span><label class="collapse" for="c-39751621">[-]</label><label class="expand" for="c-39751621">[2 more]</label></div><br/><div class="children"><div class="content">SSE supports long polling. You can make the server close the connection whenever you want. SSE supports automatic reconnection, and will even include the last ID seen to let the server continue seamlessly.</div><br/><div id="39751751" class="c"><input type="checkbox" id="c-39751751" checked=""/><div class="controls bullet"><span class="by">hobobaggins</span><span>|</span><a href="#39748840">root</a><span>|</span><a href="#39751621">parent</a><span>|</span><a href="#39748904">next</a><span>|</span><label class="collapse" for="c-39751751">[-]</label><label class="expand" for="c-39751751">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s important to remember that SSE won&#x27;t automatically reconnect for quite a few HTTP status codes (i.e., upstream proxy outages like 50x error codes)</div><br/></div></div></div></div><div id="39748904" class="c"><input type="checkbox" id="c-39748904" checked=""/><div class="controls bullet"><span class="by">debarshri</span><span>|</span><a href="#39748840">parent</a><span>|</span><a href="#39751621">prev</a><span>|</span><a href="#39747670">next</a><span>|</span><label class="collapse" for="c-39748904">[-]</label><label class="expand" for="c-39748904">[1 more]</label></div><br/><div class="children"><div class="content">I cannot agree more with you. I have seen people shot themselves on foot with Websockets and SSE. Long Polling even though is expensive, is it most explainable and scalable approach in my opinion.</div><br/></div></div></div></div><div id="39747670" class="c"><input type="checkbox" id="c-39747670" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39748840">prev</a><span>|</span><a href="#39747233">next</a><span>|</span><label class="collapse" for="c-39747670">[-]</label><label class="expand" for="c-39747670">[11 more]</label></div><br/><div class="children"><div class="content">I always find articles like this amusing, because I designed an online auction system back in the late 90&#x27;s. No XHR requests at all. Real-time updates were all handled with server-push&#x2F;HTTP streaming. It wasn&#x27;t easy to handle all the open connections at the time, but it could be done to an acceptable scale with the right architecture.</div><br/><div id="39748014" class="c"><input type="checkbox" id="c-39748014" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#39747670">parent</a><span>|</span><a href="#39747233">next</a><span>|</span><label class="collapse" for="c-39748014">[-]</label><label class="expand" for="c-39748014">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve spent so many hours trying to communicate to folks the importance of HTTP streaming ... it&#x27;s an uphill challenge for sure.<p>Yes, all the benefits of http&#x2F;2 (or 3) are great, but we should also be aware of what we can take advantage of in http 1.1, especially since it&#x27;s effectively universally supported.</div><br/><div id="39748410" class="c"><input type="checkbox" id="c-39748410" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39748014">parent</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39748410">[-]</label><label class="expand" for="c-39748410">[8 more]</label></div><br/><div class="children"><div class="content">Actually what he meant is not supported anymore: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Push_technology#HTTP_server_push" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Push_technology#HTTP_server_...</a><p>Comet&#x2F;sse&#x2F;chunked transfer needs xhr to work. x-mixed-replace was würd back in the days and still is.<p>Edit: maybe you could also use an iframe&#x2F;frame which holds a chunked connection but that will only give you text.</div><br/><div id="39748512" class="c"><input type="checkbox" id="c-39748512" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39748410">parent</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39748512">[-]</label><label class="expand" for="c-39748512">[7 more]</label></div><br/><div class="children"><div class="content">Chunked transfer encoding (which is indeed the underlying mechanism behind server-push) predates XHR, and AFAIK is still supported and will continue to be as long as HTTP&#x2F;1.1 is still supported.<p>You can use a frame&#x2F;iframes, but you can also just have content that is updated with multi-part MIME that doesn&#x27;t cause the page layout to be redone.</div><br/><div id="39748775" class="c"><input type="checkbox" id="c-39748775" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39748512">parent</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39748775">[-]</label><label class="expand" for="c-39748775">[6 more]</label></div><br/><div class="children"><div class="content">x-mixed-replace Was the only mechanism that did that and chrome removed it and it is not standard and never was</div><br/><div id="39749137" class="c"><input type="checkbox" id="c-39749137" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39748775">parent</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39749137">[-]</label><label class="expand" for="c-39749137">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so confused. Was x-mixed-replace the only way to use chunked transfer encoding (which <i>is</i> part of the HTTP standard) or are you talking about something else entirely?</div><br/><div id="39749256" class="c"><input type="checkbox" id="c-39749256" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39749137">parent</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39749256">[-]</label><label class="expand" for="c-39749256">[4 more]</label></div><br/><div class="children"><div class="content">actually you can use transfer encoding chunked to stream data , but it will get appended and the page would never finish loading, that worked back than it works today but that is not useful for several reasons and wasn’t back than.<p>with x-mixed-replace (as the name implies x-: experimentell) you can stream the page over and over again and the browser would change to the new version. (chrome still supports that for images, cheap webcams)<p>Tbf without frames neither mechanism made much sense, (even back than) because it would be horrible to use with form fields.<p>I started to play with the web in the early 2000s where xhr&#x2F;long-polling&#x2F;comet(via iframes, later it used xhr onreadystatechange with chuncked encoding, without sse, which basically was created because of that) started to gain traction and x-mixed-replace was extremely niche even back than because of the limitations it had on the page<p>Edit: comet (streaming script tags, inside an iframe) of course worked, back then. But I never heard of an implementation before 2006 (maybe a few years earlier like 2-3)or so, would’ve been worth a Wikipedia change if you would have old entries. Also http&#x2F;1.1 was 97</div><br/><div id="39751106" class="c"><input type="checkbox" id="c-39751106" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39749256">parent</a><span>|</span><a href="#39750353">next</a><span>|</span><label class="collapse" for="c-39751106">[-]</label><label class="expand" for="c-39751106">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Tbf without frames neither mechanism made much sense, (even back than) because it would be horrible to use with form fields.<p>Frames were the common way to deal with that, but I even did stuff with having a separate &quot;named&quot; browser window.<p>&gt; Also http&#x2F;1.1 was 97<p>IIRC there was support for it in Netscape before it was really a standard.</div><br/><div id="39753577" class="c"><input type="checkbox" id="c-39753577" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39751106">parent</a><span>|</span><a href="#39750353">next</a><span>|</span><label class="collapse" for="c-39753577">[-]</label><label class="expand" for="c-39753577">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IIRC there was support for it in Netscape before it was really a standard.<p>That is probably true, since x-mixed-replace started the whole chunked transfer encoding.<p>It’s probably also what really triggered the invention of comet and later xhr. Netscape was way ahead and Microsoft just pushed it out with money, integration, activex? and of course unfair advantage.</div><br/></div></div></div></div><div id="39750353" class="c"><input type="checkbox" id="c-39750353" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39749256">parent</a><span>|</span><a href="#39751106">prev</a><span>|</span><a href="#39748132">next</a><span>|</span><label class="collapse" for="c-39750353">[-]</label><label class="expand" for="c-39750353">[1 more]</label></div><br/><div class="children"><div class="content">&gt; actually you can use transfer encoding chunked to stream data , but it will get appended and the page would never finish loading, that worked back than it works today but that is not useful for several reasons and wasn’t back than.<p>Oh Server Push has all kinds of issues with it. There are lots of good reasons to prefer the newer protocols for a lot of use cases.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39748132" class="c"><input type="checkbox" id="c-39748132" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747670">root</a><span>|</span><a href="#39748014">parent</a><span>|</span><a href="#39748410">prev</a><span>|</span><a href="#39747233">next</a><span>|</span><label class="collapse" for="c-39748132">[-]</label><label class="expand" for="c-39748132">[1 more]</label></div><br/><div class="children"><div class="content">Hello fellow traveler. ;-)<p>Nobody reads the specs anymore, and to a certain degree I can&#x27;t blame them, as the protocols&#x2F;standards have become quite complicated.</div><br/></div></div></div></div></div></div><div id="39747233" class="c"><input type="checkbox" id="c-39747233" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#39747670">prev</a><span>|</span><a href="#39749284">next</a><span>|</span><label class="collapse" for="c-39747233">[-]</label><label class="expand" for="c-39747233">[14 more]</label></div><br/><div class="children"><div class="content">I kind of miss long polling. It was so stupidly simple compared to newer tech, and that&#x27;s coming from someone who thinks WebRTC is the best thing since sliced bread.</div><br/><div id="39747743" class="c"><input type="checkbox" id="c-39747743" checked=""/><div class="controls bullet"><span class="by">mmis1000</span><span>|</span><a href="#39747233">parent</a><span>|</span><a href="#39750268">next</a><span>|</span><label class="collapse" for="c-39747743">[-]</label><label class="expand" for="c-39747743">[5 more]</label></div><br/><div class="children"><div class="content">SSE isn&#x27;t really more complex than long polling. The only difference is the server don&#x27;t close the connection immediately after sent the response. Instead, it wait for data again and send more response using the same stream.</div><br/><div id="39749030" class="c"><input type="checkbox" id="c-39749030" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39747743">parent</a><span>|</span><a href="#39748674">next</a><span>|</span><label class="collapse" for="c-39749030">[-]</label><label class="expand" for="c-39749030">[1 more]</label></div><br/><div class="children"><div class="content">One limitation of SSE compared to long polling (and WebSockets etc) is you can&#x27;t efficiently send binary data such as cbor, protobuf, etc. Though if your long polling is chatty enough eventually the HTTP overhead will kill your efficiency too.</div><br/></div></div><div id="39748674" class="c"><input type="checkbox" id="c-39748674" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39747743">parent</a><span>|</span><a href="#39749030">prev</a><span>|</span><a href="#39748609">next</a><span>|</span><label class="collapse" for="c-39748674">[-]</label><label class="expand" for="c-39748674">[2 more]</label></div><br/><div class="children"><div class="content">Long polling is more amenable than SSE for most HTTP tools out of the box, eg curl. The SSE message body is notably different from plain HTTP responses.<p>To the OP, you can still build APIs with long polling. They are uncommon because push patterns are difficult to design well, regardless of protocol (whether long-polling, SSE, websockets, etc).<p>Whiteboarding a push API is a good exercise. There is a lot of nuance that gets overlooked in discussions whenever these patterns come up.</div><br/><div id="39749311" class="c"><input type="checkbox" id="c-39749311" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39748674">parent</a><span>|</span><a href="#39748609">next</a><span>|</span><label class="collapse" for="c-39749311">[-]</label><label class="expand" for="c-39749311">[1 more]</label></div><br/><div class="children"><div class="content">Well I know <i>I</i> can write applications use it, but I don&#x27;t often write code outside the context of a team that has other opinions anymore :)</div><br/></div></div></div></div><div id="39748609" class="c"><input type="checkbox" id="c-39748609" checked=""/><div class="controls bullet"><span class="by">jacobr1</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39747743">parent</a><span>|</span><a href="#39748674">prev</a><span>|</span><a href="#39750268">next</a><span>|</span><label class="collapse" for="c-39748609">[-]</label><label class="expand" for="c-39748609">[1 more]</label></div><br/><div class="children"><div class="content">Agreed - I see SSE as basically a standardized approach to modern long polling</div><br/></div></div></div></div><div id="39750268" class="c"><input type="checkbox" id="c-39750268" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39747233">parent</a><span>|</span><a href="#39747743">prev</a><span>|</span><a href="#39748549">next</a><span>|</span><label class="collapse" for="c-39750268">[-]</label><label class="expand" for="c-39750268">[7 more]</label></div><br/><div class="children"><div class="content">Oh, if only it were that simple.<p>The networking that makes Second Life go uses long polling HTTPS for an &quot;event channel&quot;, over which the server can send event messages to the clients. Most messages go over UDP, but a few that need encryption or are large go over the HTTPS&#x2F;TCP event channel.<p>At the client end, C++ clients use &quot;libcurl&quot;. Its default timeout settings are not compatible with long polling. Libcurl will break connections and make another request. This can result in lost or duplicated messages.<p>At the server end, Apache front-ends the actual simulation servers, to filter out irrelevant connection attempts (Random HTTP attacks that try any open port, probably). Apache has its own timeouts, and will abort connections, forcing the client to retry.<p>There&#x27;s a message serial number to try to prevent this mechanism from losing messages. The Second Life servers ignore the serial number the client sends back as a check. Some supposedly compatible servers from Open Simulator skip sequential numbers.<p>The end result is an HTTPS based system which can both lose and duplicate what were supposed to be reliable messages. Some of those messages, if lost, will stall out the user&#x27;s activity in the game.
The people who designed this are long gone. The current staff was unaware of how bad the mess is. Outside users had to find the problem and document it. The company staff has been trying to fix this for months. 
It seems to be difficult enough to fix that the current action is to defer work on the problem.<p>So, no, long polling is not &quot;stupidly simple&quot;.<p>The right way to do this is probably to send a keep-alive message frequently enough that the TCP and HTTPS levels never time out. This keeps Apache and libcurl on their &quot;happy paths&quot;, which work.</div><br/><div id="39750725" class="c"><input type="checkbox" id="c-39750725" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39750268">parent</a><span>|</span><a href="#39748549">next</a><span>|</span><label class="collapse" for="c-39750725">[-]</label><label class="expand" for="c-39750725">[6 more]</label></div><br/><div class="children"><div class="content">My solution to broken connections has actually been to have relatively short timeouts by default, eg 10 seconds. That guarantees we have a fresh connection every so often without any assumptions about liveness. You can even overlap the reconnects a bit (eg 10 second request timeouts, but reconnect every 8 seconds) as long as the application can reconcile duplicated messages - which it should be able to do anyway, for robustness reasons.<p>Really, anytime there is any form of push (whether SSE, long polling, etc) then you need another way to re-hydrate to the full state. In which case you are nearly at the point of doing plain old polling to sidestep the complexity of server-driven incremental updates and all the state coordination problems that entails.<p>Of course with polling, you lose responsiveness. For latency-sensitive applications (like an interactive mmorpg!) then HTTP is probably not the correct protocol to use.<p>It does sound like Second Life has its own special blend of weirdness on top of all that. Condolences to the engineers maintaining their systems.</div><br/><div id="39751019" class="c"><input type="checkbox" id="c-39751019" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39750725">parent</a><span>|</span><a href="#39752700">next</a><span>|</span><label class="collapse" for="c-39751019">[-]</label><label class="expand" for="c-39751019">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a bunch of timeouts &#x2F; heartbeat &#x2F; keep alive durations.  I think it might have been Wireguard, but <i>25 seconds</i> seems like a good number.  Usefully long, most things that break are more likely to do it at ~30 seconds, and if there&#x27;s an active activity push at 15 or 20 seconds with device wakeup then the keep alive &#x2F; connection kill might not even happen.<p>Full Refresh; yes please, in the protocol, with a user button, with local client state cached client code and reloaded state on reconnect.  Maybe even a configurable polling period; some services might offer shorter poll as a reason to pay for a higher tier account.</div><br/><div id="39752716" class="c"><input type="checkbox" id="c-39752716" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39751019">parent</a><span>|</span><a href="#39752700">next</a><span>|</span><label class="collapse" for="c-39752716">[-]</label><label class="expand" for="c-39752716">[2 more]</label></div><br/><div class="children"><div class="content">&gt; with a user button<p>If the user ever has to push a &quot;retry&quot; button, the networking levels are very badly designed. Just because some crappy web sites work that way does not mean it&#x27;s OK.</div><br/><div id="39753610" class="c"><input type="checkbox" id="c-39753610" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39752716">parent</a><span>|</span><a href="#39752700">next</a><span>|</span><label class="collapse" for="c-39753610">[-]</label><label class="expand" for="c-39753610">[1 more]</label></div><br/><div class="children"><div class="content">The user shouldn&#x27;t _have_ to.  However, a &#x27;refresh state&#x27; (and validate state, more gracefully than a full kill and reload) button can be both helpful and psychologically reassuring.<p>It can also be very helpful for out of band issues, like ISP hiccups, random hardware failures, bitflips, etc.</div><br/></div></div></div></div></div></div><div id="39752700" class="c"><input type="checkbox" id="c-39752700" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39750725">parent</a><span>|</span><a href="#39751019">prev</a><span>|</span><a href="#39748549">next</a><span>|</span><label class="collapse" for="c-39752700">[-]</label><label class="expand" for="c-39752700">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Of course with polling, you lose responsiveness.<p>No, that&#x27;s the whole point of long polling. The server delays the reply until it has something to say. Then it sends it immediately.<p>The trouble here is middleware which does not comprehend what&#x27;s going on and introduces extraneous retry logic.</div><br/><div id="39753406" class="c"><input type="checkbox" id="c-39753406" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39747233">root</a><span>|</span><a href="#39752700">parent</a><span>|</span><a href="#39748549">next</a><span>|</span><label class="collapse" for="c-39753406">[-]</label><label class="expand" for="c-39753406">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, that part of the comment was probably not clear - I was comparing &quot;plain old polling&quot; (stateless request-reply with no delay) with &quot;push&quot;, ie long polling</div><br/></div></div></div></div></div></div></div></div><div id="39748549" class="c"><input type="checkbox" id="c-39748549" checked=""/><div class="controls bullet"><span class="by">ramesh31</span><span>|</span><a href="#39747233">parent</a><span>|</span><a href="#39750268">prev</a><span>|</span><a href="#39749284">next</a><span>|</span><label class="collapse" for="c-39748549">[-]</label><label class="expand" for="c-39748549">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I kind of miss long polling. It was so stupidly simple compared to newer tech, and that&#x27;s coming from someone who thinks WebRTC is the best thing since sliced bread.<p>I still use it all the time. There are plenty of applications where the request overhead is reasonable in exchange for keeping everything within the context of an existing HTTP API.</div><br/></div></div></div></div><div id="39749284" class="c"><input type="checkbox" id="c-39749284" checked=""/><div class="controls bullet"><span class="by">tschellenbach</span><span>|</span><a href="#39747233">prev</a><span>|</span><a href="#39747531">next</a><span>|</span><label class="collapse" for="c-39749284">[-]</label><label class="expand" for="c-39749284">[2 more]</label></div><br/><div class="children"><div class="content">(I work at Stream, we power activity feeds, chat and video calling&#x2F;streaming for some very large apps)<p>You should in most cases just use websockets with a keep-alive ping every 30 seconds or so. It&#x27;s not common anymore to block websockets on firewalls, so fallback solutions like Faye&#x2F;Socket.io are typically not needed anymore.<p>WebTransport can have lower latency. If you&#x27;re sending voice data (outside of regular webrtc), or have a realtime game its something to consider.</div><br/><div id="39750721" class="c"><input type="checkbox" id="c-39750721" checked=""/><div class="controls bullet"><span class="by">ambigious7777</span><span>|</span><a href="#39749284">parent</a><span>|</span><a href="#39747531">next</a><span>|</span><label class="collapse" for="c-39750721">[-]</label><label class="expand" for="c-39750721">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m making a WASM browser dungeon crawler game using WebTransport. It currently does not have great support -- namely Safari -- but because of other API incompatibilities I&#x27;m not planning on supporting Safari :P<p>WebTransport is a bit more work than other ones, like SSE, but the flexibility and performance make it work it IMO.</div><br/></div></div></div></div><div id="39747531" class="c"><input type="checkbox" id="c-39747531" checked=""/><div class="controls bullet"><span class="by">ravxx</span><span>|</span><a href="#39749284">prev</a><span>|</span><a href="#39747570">next</a><span>|</span><label class="collapse" for="c-39747531">[-]</label><label class="expand" for="c-39747531">[6 more]</label></div><br/><div class="children"><div class="content">Whoever made this article is pretty clueless. The article states using WebRTC would be pointless since you need to run it over websockets, sse, or webtransport, but forgets to mention the main benefit of WebRTC is that it can be done with UDP. Which is why I expect it was faster in the results... I am shocked to not even see UDP mentioned in this article.</div><br/><div id="39748433" class="c"><input type="checkbox" id="c-39748433" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#39747531">parent</a><span>|</span><a href="#39747966">next</a><span>|</span><label class="collapse" for="c-39748433">[-]</label><label class="expand" for="c-39748433">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Whoever made this article is pretty clueless<p>This genre of HN comment irks me. Technical writing is an exercise in taking a lot of material and distilling it down to an audience. Writing that does a good job this will often look basic to someone with a deep understanding of the tech. It doesn&#x27;t mean the author is clueless, it just means they decided they made different decisions on what to cut than you would have.</div><br/><div id="39749791" class="c"><input type="checkbox" id="c-39749791" checked=""/><div class="controls bullet"><span class="by">kordlessagain</span><span>|</span><a href="#39747531">root</a><span>|</span><a href="#39748433">parent</a><span>|</span><a href="#39747966">next</a><span>|</span><label class="collapse" for="c-39749791">[-]</label><label class="expand" for="c-39749791">[1 more]</label></div><br/><div class="children"><div class="content">That the author didn&#x27;t mention UDP &quot;leaves out&quot; the vs. objective, however. If it were a fair contest, the article would mention the use of WebRTC over UDP, which isn&#x27;t just for streaming media (an assumption I had before doing a bit more research on it).<p>&gt; This article aims to delve into these technologies, comparing their performance, highlighting their benefits and limitations, and offering recommendations for various use cases to help developers make informed decisions when building real-time web applications.<p>So, the article&#x27;s <i>intent</i> was to help others. When we do things like this, we should ensure all technologies being evaluated will be covered exhaustively. Otherwise, you risk leaving out an important part of the puzzle and then assumptions kick in which ignore a possible better solution for a given use case.<p>It looks like UDP use is possible between a browser and a server, and that connection has to have components that deal with dropout, given it&#x27;s UDP. There is a LOT to consider and deal with implementing UDP over WebRTC, so I put a dump of this up here: <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;xgA78dky" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;xgA78dky</a></div><br/></div></div></div></div><div id="39747966" class="c"><input type="checkbox" id="c-39747966" checked=""/><div class="controls bullet"><span class="by">realPubkey</span><span>|</span><a href="#39747531">parent</a><span>|</span><a href="#39748433">prev</a><span>|</span><a href="#39748051">next</a><span>|</span><label class="collapse" for="c-39747966">[-]</label><label class="expand" for="c-39747966">[2 more]</label></div><br/><div class="children"><div class="content">Author here. The article is mostly about web apps. How would your signaling server emit new connection updates to clients in the scenario you describe?</div><br/><div id="39748141" class="c"><input type="checkbox" id="c-39748141" checked=""/><div class="controls bullet"><span class="by">andreigheorghe</span><span>|</span><a href="#39747531">root</a><span>|</span><a href="#39747966">parent</a><span>|</span><a href="#39748051">next</a><span>|</span><label class="collapse" for="c-39748141">[-]</label><label class="expand" for="c-39748141">[1 more]</label></div><br/><div class="children"><div class="content">I think what they mean is that yes, the signalling needs to be done over &quot;traditional&quot; web APIs (websockets, etc), but that&#x27;s just for discovering&#x2F;negotiating the p2p connections. The actual data transfer between the peers then happens over UDP which can have a bunch of advantages over TCP for some scenarios.</div><br/></div></div></div></div><div id="39748051" class="c"><input type="checkbox" id="c-39748051" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747531">parent</a><span>|</span><a href="#39747966">prev</a><span>|</span><a href="#39747570">next</a><span>|</span><label class="collapse" for="c-39748051">[-]</label><label class="expand" for="c-39748051">[1 more]</label></div><br/><div class="children"><div class="content">The WebRTC section of the article seemed weird in general. The reason WebRTC doesn&#x27;t specify signaling requirements is that clients can use any communications mechanism they&#x27;d like for signaling, and in the case where you are using WebRTC as sever-push mechanism, the &quot;signaling&quot; server and the server you want to receive pushes from could be the same server, allowing the use of &quot;regular&quot; HTTP as the transport for your &quot;signaling&quot; data.<p>With QUIC &amp; HTTP&#x2F;3, and things like RFC 8441 &amp; 9220, you could well be using UDP with non-WebRTC protocols, and TCP stacks &amp; routers tend to be pretty well tuned these days, so UDP doesn&#x27;t <i>necessarily</i> have much of an advantage in this kind of use case.<p>If you check out the benchmark the article uses, it specifically breaks out using &quot;unreliable WebRTC&#x2F;WebTransport&quot;. The &quot;unreliable&quot; looks to be referring to UDP (I despise how people misleadingly associate UDP with &quot;unreliable&quot;). They also have &quot;reliable WebRTC&#x2F;WebTransport&quot;, which appears to be using TCP. In the latter case, they actually found in some cases WebTransport doing a tad better in the face of packet loss, which is interesting. I haven&#x27;t looked at the details of the tests, but in my experience benchmarching WebRTC is not as straightforward as one might expect; it&#x27;s entirely possible the nature of the benchmark itself is leading to WebRTC&#x27;s better &amp; worse performance.</div><br/></div></div></div></div><div id="39747570" class="c"><input type="checkbox" id="c-39747570" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#39747531">prev</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39747570">[-]</label><label class="expand" for="c-39747570">[9 more]</label></div><br/><div class="children"><div class="content">Jsonrpc over websockets is underrated tech. Simple, easy to implement, maps to programming language constructs (async functions, events, errors) which means code looks natural as any library&#x2F;package&#x2F;module usage devs are used to, can be easily decorated with type safety, easy to debug, log, optimize etc, works on current browsers and can be used for internal service to service comms, it&#x27;s fast (ie. nodejs is using simdjson [0]), can be compressed if needed (rarely the need), we built several things on top of it ie. async generators (avoids head of line blocking, maps naturally to typescript&#x2F;js async generators).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson</a></div><br/><div id="39748224" class="c"><input type="checkbox" id="c-39748224" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747570">parent</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39748224">[-]</label><label class="expand" for="c-39748224">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I&#x27;ve used websockets, but at least the last time I did, &quot;simple&quot; wouldn&#x27;t be the word I&#x27;d have used. All kinds of annoying issues between different browsers. SSE was generally much simpler.</div><br/><div id="39748302" class="c"><input type="checkbox" id="c-39748302" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39748224">parent</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39748302">[-]</label><label class="expand" for="c-39748302">[7 more]</label></div><br/><div class="children"><div class="content">Must have been time when spec wasn&#x27;t stabilized and browsers have been introducing it. Those times are long gone.</div><br/><div id="39748476" class="c"><input type="checkbox" id="c-39748476" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39748302">parent</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39748476">[-]</label><label class="expand" for="c-39748476">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about long gone. I still support a websocket solution that needs to have server-push as a fallback because of browser incompatibility issues.</div><br/><div id="39749557" class="c"><input type="checkbox" id="c-39749557" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39748476">parent</a><span>|</span><a href="#39749055">next</a><span>|</span><label class="collapse" for="c-39749557">[-]</label><label class="expand" for="c-39749557">[3 more]</label></div><br/><div class="children"><div class="content">It shouldn&#x27;t be a problem for about a decade [0]?<p>What&#x27;s your hit rate for the fallback?<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;WebSocket" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;WebSocket</a></div><br/><div id="39750199" class="c"><input type="checkbox" id="c-39750199" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39749557">parent</a><span>|</span><a href="#39749055">next</a><span>|</span><label class="collapse" for="c-39750199">[-]</label><label class="expand" for="c-39750199">[2 more]</label></div><br/><div class="children"><div class="content">The hit rate for fallback is pretty low. It was less than 5% the last I checked.</div><br/><div id="39753215" class="c"><input type="checkbox" id="c-39753215" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39750199">parent</a><span>|</span><a href="#39749055">next</a><span>|</span><label class="collapse" for="c-39753215">[-]</label><label class="expand" for="c-39753215">[1 more]</label></div><br/><div class="children"><div class="content">This 5% includes or excludes non-human traffic?</div><br/></div></div></div></div></div></div><div id="39749055" class="c"><input type="checkbox" id="c-39749055" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39748476">parent</a><span>|</span><a href="#39749557">prev</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39749055">[-]</label><label class="expand" for="c-39749055">[2 more]</label></div><br/><div class="children"><div class="content">Do you have some specific examples?</div><br/><div id="39750194" class="c"><input type="checkbox" id="c-39750194" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747570">root</a><span>|</span><a href="#39749055">parent</a><span>|</span><a href="#39750945">next</a><span>|</span><label class="collapse" for="c-39750194">[-]</label><label class="expand" for="c-39750194">[1 more]</label></div><br/><div class="children"><div class="content">Old Android handsets seem to be the big ones.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39750945" class="c"><input type="checkbox" id="c-39750945" checked=""/><div class="controls bullet"><span class="by">lxe</span><span>|</span><a href="#39747570">prev</a><span>|</span><a href="#39750800">next</a><span>|</span><label class="collapse" for="c-39750945">[-]</label><label class="expand" for="c-39750945">[2 more]</label></div><br/><div class="children"><div class="content">I love how SSE is just a &quot;don&#x27;t close the connection and just keep flushing data&quot;. I bet IE6 supports this.</div><br/><div id="39751593" class="c"><input type="checkbox" id="c-39751593" checked=""/><div class="controls bullet"><span class="by">hobobaggins</span><span>|</span><a href="#39750945">parent</a><span>|</span><a href="#39750800">next</a><span>|</span><label class="collapse" for="c-39751593">[-]</label><label class="expand" for="c-39751593">[1 more]</label></div><br/><div class="children"><div class="content">There are at least two polyfills for it, but I think most of them require at least IE10. (but IE6 has so many other issues that probably 90% of your other JS won&#x27;t work anyway... so glad it&#x27;s gone!)</div><br/></div></div></div></div><div id="39750800" class="c"><input type="checkbox" id="c-39750800" checked=""/><div class="controls bullet"><span class="by">atum47</span><span>|</span><a href="#39750945">prev</a><span>|</span><a href="#39748579">next</a><span>|</span><label class="collapse" for="c-39750800">[-]</label><label class="expand" for="c-39750800">[1 more]</label></div><br/><div class="children"><div class="content">I did some testing with using SSE to send push notifications to my phone if someone set off a sensor, worked kinda good, but the browser had to be running in the background in order for it to work. After that i implemented a chat for a meme app that I&#x27;ve created to share memes with my friends, using websocket (Open Swoole) it is working nicely also. Never tested to see how many clients it can handle at once, but i guess the bottleneck would be in my server, not the software.<p>Open Swoole is very easy to setup and there&#x27;s lots of tutorials online. Got my ass kicked a little bit trying to making my websocket secure (wss) but I&#x27;m the end it worked fine.</div><br/></div></div><div id="39748579" class="c"><input type="checkbox" id="c-39748579" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#39750800">prev</a><span>|</span><a href="#39751434">next</a><span>|</span><label class="collapse" for="c-39748579">[-]</label><label class="expand" for="c-39748579">[4 more]</label></div><br/><div class="children"><div class="content">Is there a modern open-source solution for bridging a traditional stateless web application to real-time notifications - one that&#x27;s implemented all the best practices from the OP? Something like pusher.com but on self-hosted infrastructure&#x2F;k8s, where messages from clients are turned into webhooks to an arbitrary server, and the server can HTTP POST to a public&#x2F;private channel that clients can subscribe to if they know the channel secret.<p>I&#x27;ve come across <a href="https:&#x2F;&#x2F;github.com&#x2F;soketi&#x2F;soketi">https:&#x2F;&#x2F;github.com&#x2F;soketi&#x2F;soketi</a> and <a href="https:&#x2F;&#x2F;centrifugal.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;centrifugal.dev&#x2F;</a> but not sure if there are more battle-tested solutions.</div><br/><div id="39753061" class="c"><input type="checkbox" id="c-39753061" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#39748579">parent</a><span>|</span><a href="#39749768">next</a><span>|</span><label class="collapse" for="c-39753061">[-]</label><label class="expand" for="c-39753061">[1 more]</label></div><br/><div class="children"><div class="content">I maintain the Mercure protocol (built on SSE) and the reference implementation (written in Go, available as a standalone binary and a Caddy module) which does exactly that: <a href="https:&#x2F;&#x2F;mercure.rocks" rel="nofollow">https:&#x2F;&#x2F;mercure.rocks</a><p>In addition to the free and open source server, we also provide a cloud offering and on-premises versions that support clustering using Redis Streams, Kafka, Pulsar or Postgres LISTEN&#x2F;NOTIFY as backends.<p>The solution is used by many big actors in production for years:<p>How Raven Controls uses Mercure to power big events such as Cop 21 and Euro 2020: <a href="https:&#x2F;&#x2F;api-platform.com&#x2F;con&#x2F;2022&#x2F;conferences&#x2F;real-time-and-beyond-with-mercure&#x2F;" rel="nofollow">https:&#x2F;&#x2F;api-platform.com&#x2F;con&#x2F;2022&#x2F;conferences&#x2F;real-time-and-...</a><p>Pushing 8 million Mercure notifications per day to run mail.tm: <a href="https:&#x2F;&#x2F;les-tilleuls.coop&#x2F;en&#x2F;blog&#x2F;mail-tm-mercure-rocks-and-api-platform" rel="nofollow">https:&#x2F;&#x2F;les-tilleuls.coop&#x2F;en&#x2F;blog&#x2F;mail-tm-mercure-rocks-and-...</a><p>100,000 simultaneous Mercure users to power iGraal: <a href="https:&#x2F;&#x2F;speakerdeck.com&#x2F;dunglas&#x2F;mercure-real-time-for-php-made-easy" rel="nofollow">https:&#x2F;&#x2F;speakerdeck.com&#x2F;dunglas&#x2F;mercure-real-time-for-php-ma...</a></div><br/></div></div><div id="39749768" class="c"><input type="checkbox" id="c-39749768" checked=""/><div class="controls bullet"><span class="by">roopakv</span><span>|</span><a href="#39748579">parent</a><span>|</span><a href="#39753061">prev</a><span>|</span><a href="#39750339">next</a><span>|</span><label class="collapse" for="c-39749768">[-]</label><label class="expand" for="c-39749768">[1 more]</label></div><br/><div class="children"><div class="content">Another one to check out <a href="https:&#x2F;&#x2F;partykit.io" rel="nofollow">https:&#x2F;&#x2F;partykit.io</a><p>They are building on top of Cloudflare, and getting started is a breeze.<p>That being said they are also fairly new, but based on everything I have seen, I am a fan</div><br/></div></div><div id="39750339" class="c"><input type="checkbox" id="c-39750339" checked=""/><div class="controls bullet"><span class="by">jkarneges</span><span>|</span><a href="#39748579">parent</a><span>|</span><a href="#39749768">prev</a><span>|</span><a href="#39751434">next</a><span>|</span><label class="collapse" for="c-39750339">[-]</label><label class="expand" for="c-39750339">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also Pushpin, if you want the API to blend with your existing app.<p>Disclosure: Pushpin lead dev.</div><br/></div></div></div></div><div id="39751434" class="c"><input type="checkbox" id="c-39751434" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39748579">prev</a><span>|</span><a href="#39747390">next</a><span>|</span><label class="collapse" for="c-39751434">[-]</label><label class="expand" for="c-39751434">[4 more]</label></div><br/><div class="children"><div class="content">A decent number of corporate firewalls still don&#x27;t support web sockets...<p>That means if you build something that requires web sockets, prepare to have a deluge of support&#x2F;refund requests from the most valuable clients who think your site is broken.<p>I suggest just having a once-per-second polling fallback, perhaps with an info bar saying &#x27;the network you are connected to is degrading your experience&#x27;.</div><br/><div id="39751464" class="c"><input type="checkbox" id="c-39751464" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#39751434">parent</a><span>|</span><a href="#39747390">next</a><span>|</span><label class="collapse" for="c-39751464">[-]</label><label class="expand" for="c-39751464">[3 more]</label></div><br/><div class="children"><div class="content">Certainty this can’t be true? I believe you but do you have any actual examples?</div><br/><div id="39753725" class="c"><input type="checkbox" id="c-39753725" checked=""/><div class="controls bullet"><span class="by">paddybyers</span><span>|</span><a href="#39751434">root</a><span>|</span><a href="#39751464">parent</a><span>|</span><a href="#39751516">next</a><span>|</span><label class="collapse" for="c-39753725">[-]</label><label class="expand" for="c-39753725">[1 more]</label></div><br/><div class="children"><div class="content">Yes it&#x27;s true. At Ably we support websockets, SSE and comet fallbacks (simple long-polling and streamed long-polling). It&#x27;s less and less common but there are firewalls that fail to handle websockets correctly, or simply block them. I can&#x27;t name specific companies&#x2F;examples, but call centers are one example - the network and desktop environments are fully locked down.<p>We also see in these cases that streamed HTTP can also be broken by the firewall - for example a chunked response can be held back by the firewall and only forwarded to the client when the request ends, as a fixed-length response. Obviously that breaks SSE and means you can&#x27;t just use streamed comet as a fallback when websockets don&#x27;t work.</div><br/></div></div><div id="39751516" class="c"><input type="checkbox" id="c-39751516" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39751434">root</a><span>|</span><a href="#39751464">parent</a><span>|</span><a href="#39753725">prev</a><span>|</span><a href="#39747390">next</a><span>|</span><label class="collapse" for="c-39751516">[-]</label><label class="expand" for="c-39751516">[1 more]</label></div><br/><div class="children"><div class="content">All UK government offices doesn&#x27;t seem to allow it...   That&#x27;s a couple of million potential users right away.</div><br/></div></div></div></div></div></div><div id="39747390" class="c"><input type="checkbox" id="c-39747390" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39751434">prev</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39747390">[-]</label><label class="expand" for="c-39747390">[6 more]</label></div><br/><div class="children"><div class="content">Great comparison. Would love to see http response streaming added to the mix. I think a lot of use cases involving finite streams sent from server to client can be handled by the server streaming JSONL in the response. I tend to prefer this over SSE for finite data streams.</div><br/><div id="39747693" class="c"><input type="checkbox" id="c-39747693" checked=""/><div class="controls bullet"><span class="by">mmis1000</span><span>|</span><a href="#39747390">parent</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39747693">[-]</label><label class="expand" for="c-39747693">[5 more]</label></div><br/><div class="children"><div class="content">Server send event IS http response streaming. It is a standardized way to implement response streaming.</div><br/><div id="39747870" class="c"><input type="checkbox" id="c-39747870" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39747390">root</a><span>|</span><a href="#39747693">parent</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39747870">[-]</label><label class="expand" for="c-39747870">[4 more]</label></div><br/><div class="children"><div class="content">I agree, but SSE is a more complex protocol that requires additional handling on both client and server, with capabilities that may not be relevant for your use case (multiple event types, event id). For JS clients and JS servers it is not particularly onerous to implement, but for other ecosystems can require a fair bit of code. JSONL streaming is very easy to implement on both ends, so all else aside I think would be preferred if all you really want to do is stream JSON values.</div><br/><div id="39749080" class="c"><input type="checkbox" id="c-39749080" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747390">root</a><span>|</span><a href="#39747870">parent</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39749080">[-]</label><label class="expand" for="c-39749080">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented SSE from scratch on the server and XHR streaming&#x2F;parsing from scratch on the client side (which would be necessary for JSONL), and SSE was way simpler. Unless there&#x27;s another way to do JSONL in a browser that I&#x27;m not aware of?</div><br/><div id="39750063" class="c"><input type="checkbox" id="c-39750063" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39747390">root</a><span>|</span><a href="#39749080">parent</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39750063">[-]</label><label class="expand" for="c-39750063">[2 more]</label></div><br/><div class="children"><div class="content">If you use the fetch API you can get a readable stream and party on without too much difficulty. You can also implement a transform stream in ~10SLOC that will make the reader vend parsed JSON objects and can be reused easily.</div><br/><div id="39751406" class="c"><input type="checkbox" id="c-39751406" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39747390">root</a><span>|</span><a href="#39750063">parent</a><span>|</span><a href="#39749076">next</a><span>|</span><label class="collapse" for="c-39751406">[-]</label><label class="expand" for="c-39751406">[1 more]</label></div><br/><div class="children"><div class="content">This is a good point. In fact, you just helped me realize that I can probably replace this[0] at work with a fetch implementation. ReadableStreams weren&#x27;t generally available across browsers when I wrote that. This would also allow us to return binary data if we so desired (XHR can handle binary but it can&#x27;t stream it chunk by chunk). Thanks!<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;anderspitman&#x2F;xhr-stream-dl">https:&#x2F;&#x2F;github.com&#x2F;anderspitman&#x2F;xhr-stream-dl</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39749076" class="c"><input type="checkbox" id="c-39749076" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39747390">prev</a><span>|</span><a href="#39752544">next</a><span>|</span><label class="collapse" for="c-39749076">[-]</label><label class="expand" for="c-39749076">[8 more]</label></div><br/><div class="children"><div class="content">Browser push APIs are hard to design well regardless of the underlying protocol (SSE, Long Polling, Websockets, etc). There are a bunch of things to consider:<p>- Is this a full or partial state update?<p>- What if the client misses an update?<p>- What if the client loses connectivity?<p>- How can the server detect and clean up clients that have disappeared?<p>How those are answered in turn raise more questions.<p>SSE or long polling or even WebSockets is a relatively unimportant implementation detail. IMO the bigger consideration should probably be ease-of-use and tooling interoperability. For that, I would say that long polling (or even just <i>polling</i>) is the clear winner.</div><br/><div id="39749752" class="c"><input type="checkbox" id="c-39749752" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39749076">parent</a><span>|</span><a href="#39749167">next</a><span>|</span><label class="collapse" for="c-39749752">[-]</label><label class="expand" for="c-39749752">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Is this a full or partial state update?<p>It&#x27;s a message.  Mapping protocol units to messages was always your business.<p>&gt; What if the client misses an update?<p>Sequence numbers on updates combined with a &quot;fill in&quot; mechanism through a separate request.<p>&gt; What if the client loses connectivity?<p>Then more important things won&#x27;t work either.<p>&gt; How can the server detect and clean up clients that have disappeared?<p>The SSE client will restart dropped connections.  You can have the server opportunistically close connections that haven&#x27;t received messages recently.  The browser will automatically reconnect if the object is still alive on the client side.<p>&gt; For that, I would say that long polling (or even just polling) is the clear winner.<p>Coordinating polling intervals while simultaneously avoiding strong bursting behavior is genuinely not fun.</div><br/><div id="39750234" class="c"><input type="checkbox" id="c-39750234" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39749076">root</a><span>|</span><a href="#39749752">parent</a><span>|</span><a href="#39749167">next</a><span>|</span><label class="collapse" for="c-39750234">[-]</label><label class="expand" for="c-39750234">[4 more]</label></div><br/><div class="children"><div class="content">All that speaks to the point that the underlying protocol does not matter that much. The larger design is a more important consideration than the specific push tech.<p>None of this favors SSE, or anything else for that matter. You still have to think about bursting &#x2F; thundering herd behavior after server restarts, which would affect any protocol. The browser auto reconnecting doesn&#x27;t mean you can assume the connection remains alive indefinitely if a reconnect hasn&#x27;t happened; you may want periodic notifications as a keepalive to enable more immediate recovery. Long-lived server state introduces its own distributed coordination and cleanup problems, which strict request-reply polling sidesteps entirely. Etc.<p>There is no silver bullet, only tradeoffs in the design space that need to be matched to your application&#x27;s requirements.</div><br/><div id="39750763" class="c"><input type="checkbox" id="c-39750763" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39749076">root</a><span>|</span><a href="#39750234">parent</a><span>|</span><a href="#39749167">next</a><span>|</span><label class="collapse" for="c-39750763">[-]</label><label class="expand" for="c-39750763">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the underlying protocol does not matter that much<p>Then why is long polling the &quot;clear winner?&quot;</div><br/><div id="39750839" class="c"><input type="checkbox" id="c-39750839" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39749076">root</a><span>|</span><a href="#39750763">parent</a><span>|</span><a href="#39749167">next</a><span>|</span><label class="collapse" for="c-39750839">[-]</label><label class="expand" for="c-39750839">[2 more]</label></div><br/><div class="children"><div class="content">For interoperability with HTTP tooling (eg, curl) it is the clear winner</div><br/><div id="39752621" class="c"><input type="checkbox" id="c-39752621" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39749076">root</a><span>|</span><a href="#39750839">parent</a><span>|</span><a href="#39749167">next</a><span>|</span><label class="collapse" for="c-39752621">[-]</label><label class="expand" for="c-39752621">[1 more]</label></div><br/><div class="children"><div class="content">SSE,  which is just an HTTP request,  works perfectly fine with curl or any other library which makes HTTP requests.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39749167" class="c"><input type="checkbox" id="c-39749167" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39749076">parent</a><span>|</span><a href="#39749752">prev</a><span>|</span><a href="#39752544">next</a><span>|</span><label class="collapse" for="c-39749167">[-]</label><label class="expand" for="c-39749167">[2 more]</label></div><br/><div class="children"><div class="content">This is one of my favorite articles along these lines:<p><a href="https:&#x2F;&#x2F;blog.sequin.io&#x2F;events-not-webhooks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.sequin.io&#x2F;events-not-webhooks&#x2F;</a></div><br/><div id="39749683" class="c"><input type="checkbox" id="c-39749683" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39749076">root</a><span>|</span><a href="#39749167">parent</a><span>|</span><a href="#39752544">next</a><span>|</span><label class="collapse" for="c-39749683">[-]</label><label class="expand" for="c-39749683">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that is a great article, and I agree that long polling an events endpoint along with a cursor gets you most of the way there for browser clients. At that point, things start to resemble the Kafka protocol.</div><br/></div></div></div></div></div></div><div id="39752544" class="c"><input type="checkbox" id="c-39752544" checked=""/><div class="controls bullet"><span class="by">elwell</span><span>|</span><a href="#39749076">prev</a><span>|</span><a href="#39751183">next</a><span>|</span><label class="collapse" for="c-39752544">[-]</label><label class="expand" for="c-39752544">[1 more]</label></div><br/><div class="children"><div class="content">Man... I was trying to use WebRTC over ten years ago to implement livestreaming from your phone&#x27;s camera *within a PhoneGap app*! Didn&#x27;t work too well.</div><br/></div></div><div id="39751183" class="c"><input type="checkbox" id="c-39751183" checked=""/><div class="controls bullet"><span class="by">lgrapenthin</span><span>|</span><a href="#39752544">prev</a><span>|</span><a href="#39748927">next</a><span>|</span><label class="collapse" for="c-39751183">[-]</label><label class="expand" for="c-39751183">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Long-Polling: The least scalable due to the high server load generated by frequent connection establishment, making it suitable only as a fallback mechanism.<p>That makes no sense.  Long-polling scales linearly like all the other ones as well.</div><br/><div id="39751498" class="c"><input type="checkbox" id="c-39751498" checked=""/><div class="controls bullet"><span class="by">hnav</span><span>|</span><a href="#39751183">parent</a><span>|</span><a href="#39748927">next</a><span>|</span><label class="collapse" for="c-39751498">[-]</label><label class="expand" for="c-39751498">[1 more]</label></div><br/><div class="children"><div class="content">there are a few ways that long-polling is &quot;least scalable&quot;<p>- other approaches give you locality without sticky load-balancing: let&#x27;s say your application server needs to subscribe to a topic once a connection is established, with long polling you need to setup and teardown that subscription every time, other approaches let you keep that HTTP stream alive and periodically send some stuff on it resulting in mostly just memory overhead.<p>- each returned payload will result in at least 1 extra packet (the initial request headers, assuming the response headers and the payload fit into a packet) and at least 1&#x2F;2 RTT delay.</div><br/></div></div></div></div><div id="39748927" class="c"><input type="checkbox" id="c-39748927" checked=""/><div class="controls bullet"><span class="by">ascii78</span><span>|</span><a href="#39751183">prev</a><span>|</span><a href="#39747719">next</a><span>|</span><label class="collapse" for="c-39748927">[-]</label><label class="expand" for="c-39748927">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been reading about WebRTC, does anyone actually know if browser to browser communication actually works reliably in practice ? Specifically NAT traversal, been hesitant to research it further because of this issue, seems that most of the connection parts seem to be legacy voip related protocols.</div><br/><div id="39748999" class="c"><input type="checkbox" id="c-39748999" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#39748927">parent</a><span>|</span><a href="#39747719">next</a><span>|</span><label class="collapse" for="c-39748999">[-]</label><label class="expand" for="c-39748999">[1 more]</label></div><br/><div class="children"><div class="content">Works well! Lots of developers&#x2F;companies use WebRTC with NAT Traversal.<p>You can also use it in a client&#x2F;server setup. Check out &#x27;WebRTC SFU&#x27;<p>I wrote a little bit about the different topologies in [0]<p>[0] <a href="https:&#x2F;&#x2F;webrtcforthecurious.com&#x2F;docs&#x2F;08-applied-webrtc&#x2F;#webrtc-topologies" rel="nofollow">https:&#x2F;&#x2F;webrtcforthecurious.com&#x2F;docs&#x2F;08-applied-webrtc&#x2F;#webr...</a></div><br/></div></div></div></div><div id="39747719" class="c"><input type="checkbox" id="c-39747719" checked=""/><div class="controls bullet"><span class="by">arendtio</span><span>|</span><a href="#39748927">prev</a><span>|</span><a href="#39750227">next</a><span>|</span><label class="collapse" for="c-39747719">[-]</label><label class="expand" for="c-39747719">[8 more]</label></div><br/><div class="children"><div class="content">I wonder why mobile push notifications are just a side-note in this article as mobile clients are responsible for a large part of the global traffic.</div><br/><div id="39748088" class="c"><input type="checkbox" id="c-39748088" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39747719">parent</a><span>|</span><a href="#39750227">next</a><span>|</span><label class="collapse" for="c-39748088">[-]</label><label class="expand" for="c-39748088">[7 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t mobile push notifications an <i>entirely</i> different tech, one that significantly uses the capabilities of mobile carriers?</div><br/><div id="39748437" class="c"><input type="checkbox" id="c-39748437" checked=""/><div class="controls bullet"><span class="by">arendtio</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39748088">parent</a><span>|</span><a href="#39748275">next</a><span>|</span><label class="collapse" for="c-39748437">[-]</label><label class="expand" for="c-39748437">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about the implementation details, but even the use case is slightly different, as the discussed techs are also meant to transfer larger amounts of data. At the same time, mobile push is more about triggering synchronization than transferring large amounts of data.<p>However, since the discussed techs all have major problems with mobile connections, I still think it should have been discussed in more depth.</div><br/></div></div><div id="39748275" class="c"><input type="checkbox" id="c-39748275" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39748088">parent</a><span>|</span><a href="#39748437">prev</a><span>|</span><a href="#39748228">next</a><span>|</span><label class="collapse" for="c-39748275">[-]</label><label class="expand" for="c-39748275">[3 more]</label></div><br/><div class="children"><div class="content">You can do mobile push notifications to a phone even if they aren&#x27;t connected to a mobile carrier.<p>That said, I&#x27;d argue SSE is the browser equivalent of mobile push notifications.</div><br/><div id="39750342" class="c"><input type="checkbox" id="c-39750342" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39748275">parent</a><span>|</span><a href="#39748228">next</a><span>|</span><label class="collapse" for="c-39750342">[-]</label><label class="expand" for="c-39750342">[2 more]</label></div><br/><div class="children"><div class="content">SSE generally requires the page to be active in the foreground, which is not a viable solution for mobile.<p>Web Push is a distinct API for browsers to emulate native push notifications via service workers. <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Push_API" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Push_API</a></div><br/><div id="39751007" class="c"><input type="checkbox" id="c-39751007" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39750342">parent</a><span>|</span><a href="#39748228">next</a><span>|</span><label class="collapse" for="c-39751007">[-]</label><label class="expand" for="c-39751007">[1 more]</label></div><br/><div class="children"><div class="content">I thought it was more that the Document object had to stay alive. ...although, these days a lot of mobile browsers will kill that thing off if the page is not in the background, so yeah...</div><br/></div></div></div></div></div></div><div id="39748228" class="c"><input type="checkbox" id="c-39748228" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39748088">parent</a><span>|</span><a href="#39748275">prev</a><span>|</span><a href="#39750227">next</a><span>|</span><label class="collapse" for="c-39748228">[-]</label><label class="expand" for="c-39748228">[2 more]</label></div><br/><div class="children"><div class="content">iOS and android push does not rely on mobile carrier capability afaik, it has its own service</div><br/><div id="39749953" class="c"><input type="checkbox" id="c-39749953" checked=""/><div class="controls bullet"><span class="by">psnehanshu</span><span>|</span><a href="#39747719">root</a><span>|</span><a href="#39748228">parent</a><span>|</span><a href="#39750227">next</a><span>|</span><label class="collapse" for="c-39749953">[-]</label><label class="expand" for="c-39749953">[1 more]</label></div><br/><div class="children"><div class="content">Yes, iOS has APNS and Android has FCM. One can use FCM for both Android and iOS as FCM is capable of abstracting away APNS. If you are building on React Native with Expo, you can also use Expo Push, which abstracts away both APNS and FCM, albeit it is not fully featured.</div><br/></div></div></div></div></div></div></div></div><div id="39750227" class="c"><input type="checkbox" id="c-39750227" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#39747719">prev</a><span>|</span><a href="#39747904">next</a><span>|</span><label class="collapse" for="c-39750227">[-]</label><label class="expand" for="c-39750227">[1 more]</label></div><br/><div class="children"><div class="content">Note that the author misses an essential point: custom compression dictionaries, which can only be used by WebSockets (WS13) and hardly by the others, as that would break compatibility. I&#x27;d argue that you can push websocket data usage way lower than the other protocols, if you use a binary compression based on a predefined schema.<p>In WebSockets, you can use plug&amp;play extensions which can modify the payload on both the client and the server, which make them also ideal for tunneling and peer-to-peer applications.<p>I&#x27;ve written an article from an implementer&#x27;s perspective a while ago, in case you are interested [1]<p>[1] <a href="https:&#x2F;&#x2F;cookie.engineer&#x2F;weblog&#x2F;articles&#x2F;implementers-guide-to-websockets.html" rel="nofollow">https:&#x2F;&#x2F;cookie.engineer&#x2F;weblog&#x2F;articles&#x2F;implementers-guide-t...</a></div><br/></div></div><div id="39747904" class="c"><input type="checkbox" id="c-39747904" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#39750227">prev</a><span>|</span><a href="#39751497">next</a><span>|</span><label class="collapse" for="c-39747904">[-]</label><label class="expand" for="c-39747904">[2 more]</label></div><br/><div class="children"><div class="content">What I want to know is, on iOS can we have Web Workers running for a few hours when the browser is in the background, with setInterval communicating w the network or will they get suspended?</div><br/><div id="39749964" class="c"><input type="checkbox" id="c-39749964" checked=""/><div class="controls bullet"><span class="by">psnehanshu</span><span>|</span><a href="#39747904">parent</a><span>|</span><a href="#39751497">next</a><span>|</span><label class="collapse" for="c-39749964">[-]</label><label class="expand" for="c-39749964">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t assume reliability</div><br/></div></div></div></div><div id="39751497" class="c"><input type="checkbox" id="c-39751497" checked=""/><div class="controls bullet"><span class="by">lakomen</span><span>|</span><a href="#39747904">prev</a><span>|</span><a href="#39748053">next</a><span>|</span><label class="collapse" for="c-39751497">[-]</label><label class="expand" for="c-39751497">[2 more]</label></div><br/><div class="children"><div class="content">SSE in gin (go) is broken and has been for years. No one uses it and no one bothers to fix it.</div><br/><div id="39751545" class="c"><input type="checkbox" id="c-39751545" checked=""/><div class="controls bullet"><span class="by">hobobaggins</span><span>|</span><a href="#39751497">parent</a><span>|</span><a href="#39748053">next</a><span>|</span><label class="collapse" for="c-39751545">[-]</label><label class="expand" for="c-39751545">[1 more]</label></div><br/><div class="children"><div class="content">r3labs&#x2F;sse seems pretty good, but doesn&#x27;t seem to handle backpressure or defend against slow-client attacks. (actually, I haven&#x27;t seen any libs that do.. maybe this isn&#x27;t a problem for anyone?) You could roll your own, since the protocol is extremely simple.</div><br/></div></div></div></div></div></div></div></div></div></body></html>