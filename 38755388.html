<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703494858722" as="style"/><link rel="stylesheet" href="styles.css?v=1703494858722"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.perfectcircuit.com/signal/what-is-fm-synthesis">Synthesis Methods Explained: What Is FM Synthesis?</a> <span class="domain">(<a href="https://www.perfectcircuit.com">www.perfectcircuit.com</a>)</span></div><div class="subtext"><span>peter_d_sherman</span> | <span>38 comments</span></div><br/><div><div id="38758707" class="c"><input type="checkbox" id="c-38758707" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38759578">next</a><span>|</span><label class="collapse" for="c-38758707">[-]</label><label class="expand" for="c-38758707">[13 more]</label></div><br/><div class="children"><div class="content">For a couple years I&#x27;ve wanted to write a subtractive synth from scratch in software. But I _cannot_ find any source that explains how to write a low-pass filter, in code, without assuming tons of knowledge about calculus and these odd things like Z-transforms?<p>Like, I understand FFTs and DCTs. But the explanation for how to construct filters in software is pathetic.<p>I looked at the code for VCVRack but could not understand it. It&#x27;s already optimized for SIMD, processing 4 signals at once, which didn&#x27;t help readability. (I&#x27;m sure it&#x27;s very fast though)</div><br/><div id="38759538" class="c"><input type="checkbox" id="c-38759538" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38760427">next</a><span>|</span><label class="collapse" for="c-38759538">[-]</label><label class="expand" for="c-38759538">[2 more]</label></div><br/><div class="children"><div class="content">This was one of the things that was most surprising to me doing software defined radio. It was &quot;how does a finite impulse response filter work?&quot; and &quot;how to I make it work in a specific way?&quot; The interesting question for synths would be how to give it an input that that changes its cut off frequency.<p>For me, the &quot;aha&quot; moment was when I connected the dots between &quot;averaging&quot; (which is a common way to filter noise out in an embedded computer) and &quot;rolling average&quot; is just summing the previous &#x27;n&#x27; samples as sample * 1&#x2F;n, and a picture of a fir filter that was (C code but it&#x27;s pretty readable)<p><pre><code>   out = 0;
   for (i = 0; i &lt; n; i++) {
     out = out + sample[n-i]&#x2F;n;
   }
   return(out);
</code></pre>
That is a &quot;FIR&quot; filter where the coefficients are all 1&#x2F;n. Now take that and do the FFT of n samples of n&#x2F;1 (adding zeros to get the resolution you want). And <i>that</i> is the frequency response of your filter for frequencies between 0 (DC) and sample_rate&#x2F;2.<p>For me at least that connected a lot of dots in what I was reading.</div><br/><div id="38759558" class="c"><input type="checkbox" id="c-38759558" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38758707">root</a><span>|</span><a href="#38759538">parent</a><span>|</span><a href="#38760427">next</a><span>|</span><label class="collapse" for="c-38759558">[-]</label><label class="expand" for="c-38759558">[1 more]</label></div><br/><div class="children"><div class="content">You probably want to defer the division until output, and not do the loop each time - instead, just subtract back N samples when adding the current sample.</div><br/></div></div></div></div><div id="38760427" class="c"><input type="checkbox" id="c-38760427" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38759538">prev</a><span>|</span><a href="#38759126">next</a><span>|</span><label class="collapse" for="c-38760427">[-]</label><label class="expand" for="c-38760427">[1 more]</label></div><br/><div class="children"><div class="content">Check out GNU Radio. In contrary to what the name suggests, it&#x27;s not just for radio, but can be used for doing complex DSP operations. It includes a nice filter design tool, too.<p><a href="https:&#x2F;&#x2F;www.gnuradio.org&#x2F;grcon&#x2F;grcon18&#x2F;presentations&#x2F;The_Bright_Side_of_the_Dark_Side_of_DSP_Audio_Effects_using_GNU_Radio&#x2F;2-Ashish_Chaudhari_audio_effects.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnuradio.org&#x2F;grcon&#x2F;grcon18&#x2F;presentations&#x2F;The_Bri...</a><p><a href="https:&#x2F;&#x2F;w7fu.com&#x2F;audio-oscillator-project&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;w7fu.com&#x2F;audio-oscillator-project&#x2F;</a><p>The best option to install it on Windows is radioconda: <a href="https:&#x2F;&#x2F;github.com&#x2F;ryanvolz&#x2F;radioconda">https:&#x2F;&#x2F;github.com&#x2F;ryanvolz&#x2F;radioconda</a></div><br/></div></div><div id="38759126" class="c"><input type="checkbox" id="c-38759126" checked=""/><div class="controls bullet"><span class="by">samdafi</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38760427">prev</a><span>|</span><a href="#38759148">next</a><span>|</span><label class="collapse" for="c-38759126">[-]</label><label class="expand" for="c-38759126">[1 more]</label></div><br/><div class="children"><div class="content">Classic biquad approach with instructions for calculating coefficients of various filter shapes:<p><a href="https:&#x2F;&#x2F;webaudio.github.io&#x2F;Audio-EQ-Cookbook&#x2F;audio-eq-cookbook.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;webaudio.github.io&#x2F;Audio-EQ-Cookbook&#x2F;audio-eq-cookbo...</a><p>An analog modeling approach, but cross-reference the coefficient calculations!<p><a href="https:&#x2F;&#x2F;cytomic.com&#x2F;technical-papers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cytomic.com&#x2F;technical-papers&#x2F;</a></div><br/></div></div><div id="38759148" class="c"><input type="checkbox" id="c-38759148" checked=""/><div class="controls bullet"><span class="by">thepjb</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38759126">prev</a><span>|</span><a href="#38759631">next</a><span>|</span><label class="collapse" for="c-38759148">[-]</label><label class="expand" for="c-38759148">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;ThePJB&#x2F;okiir&#x2F;blob&#x2F;a356b5b09917c0dbd856c9b2eb34660368e2fc37&#x2F;src&#x2F;sound_synthesis.rs#L86C3-L86C3">https:&#x2F;&#x2F;github.com&#x2F;ThePJB&#x2F;okiir&#x2F;blob&#x2F;a356b5b09917c0dbd856c9b...</a><p>Here&#x27;s mine lol<p>Yeah I can&#x27;t help but think there might be a niche for intermediate level discussion of these topics. I have a burning desire to wrap my head around z transform and other dsp black magic... (Like for example application of Hilbert transform to synthesis, anyone?)  A lot of it comes back to understanding the complex plane. Like, I think Z transform relies on the fact that every *e^j2pi wraps around the unit circle again for one sample period.</div><br/></div></div><div id="38759631" class="c"><input type="checkbox" id="c-38759631" checked=""/><div class="controls bullet"><span class="by">ViktorV</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38759148">prev</a><span>|</span><a href="#38758955">next</a><span>|</span><label class="collapse" for="c-38759631">[-]</label><label class="expand" for="c-38759631">[1 more]</label></div><br/><div class="children"><div class="content">Z-transform is very similar to Fourier or Laplace transform, but in discrete time. These things are not that hard, if you get FFT already then you can get there if you want.</div><br/></div></div><div id="38758955" class="c"><input type="checkbox" id="c-38758955" checked=""/><div class="controls bullet"><span class="by">AtomicOrbital</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38759631">prev</a><span>|</span><a href="#38758980">next</a><span>|</span><label class="collapse" for="c-38758955">[-]</label><label class="expand" for="c-38758955">[2 more]</label></div><br/><div class="children"><div class="content">A intuition for creating a lowpass filter ... audio happens in the time domain ... Fourier transform outputs the frequency domain representation of the audio you feed it ... number of audio samples you feed into the FFT call determines the element count of the array returned ... now you have an array of your audio in the frequency domain ... for lowpass crank down to zero array elements above the first  quarter of them ... this silences those frequencies ... to render the audio ( generate sound ) feed your edited frequency domain array into an IFFT ( inverse Fourier transform )</div><br/><div id="38759181" class="c"><input type="checkbox" id="c-38759181" checked=""/><div class="controls bullet"><span class="by">samdafi</span><span>|</span><a href="#38758707">root</a><span>|</span><a href="#38758955">parent</a><span>|</span><a href="#38758980">next</a><span>|</span><label class="collapse" for="c-38759181">[-]</label><label class="expand" for="c-38759181">[1 more]</label></div><br/><div class="children"><div class="content">This does work, but the sound of it isn’t super pleasing and it limits your filter design options. Checking out time domain IIR filters and methods for generating coefficients gets you flexibility and efficiency with no latency. I posted some links above but the RBJ Cookbook is a good place to start.</div><br/></div></div></div></div><div id="38758980" class="c"><input type="checkbox" id="c-38758980" checked=""/><div class="controls bullet"><span class="by">Scene_Cast2</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38758955">prev</a><span>|</span><a href="#38759113">next</a><span>|</span><label class="collapse" for="c-38758980">[-]</label><label class="expand" for="c-38758980">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;fiiir.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fiiir.com&#x2F;</a> will help you design a filter. Select &quot;Python script&quot; to get some comments on how to apply that filter on your data (look for &quot;convolve&quot;).<p>For more understanding, I do recommend reading up on DSP and Signals concepts, they&#x27;re pretty critical to know if you&#x27;re designing filters.</div><br/></div></div><div id="38759113" class="c"><input type="checkbox" id="c-38759113" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38758980">prev</a><span>|</span><a href="#38758741">next</a><span>|</span><label class="collapse" for="c-38759113">[-]</label><label class="expand" for="c-38759113">[1 more]</label></div><br/><div class="children"><div class="content">Will Pirkle&#x27;s books might be close to what you&#x27;re looking for. He covers Z transforms (which you do ultimately need to understand to code up filters) but also provides implementations you can use as a starting point&#x2F;to get a better idea of what to do concretely in software.</div><br/></div></div><div id="38758741" class="c"><input type="checkbox" id="c-38758741" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#38758707">parent</a><span>|</span><a href="#38759113">prev</a><span>|</span><a href="#38759578">next</a><span>|</span><label class="collapse" for="c-38758741">[-]</label><label class="expand" for="c-38758741">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But the explanation for how to construct filters in software is pathetic.<p>Pick your favorite FIR filter, set up a ring buffer, input samples go in, at each step you multiply the buffer elements by your filter coefficients, sum, and output the result.</div><br/><div id="38758974" class="c"><input type="checkbox" id="c-38758974" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#38758707">root</a><span>|</span><a href="#38758741">parent</a><span>|</span><a href="#38759578">next</a><span>|</span><label class="collapse" for="c-38758974">[-]</label><label class="expand" for="c-38758974">[1 more]</label></div><br/><div class="children"><div class="content">The hard part is calculating the coefficients.</div><br/></div></div></div></div></div></div><div id="38759578" class="c"><input type="checkbox" id="c-38759578" checked=""/><div class="controls bullet"><span class="by">gomijacogeo</span><span>|</span><a href="#38758707">prev</a><span>|</span><a href="#38757668">next</a><span>|</span><label class="collapse" for="c-38759578">[-]</label><label class="expand" for="c-38759578">[1 more]</label></div><br/><div class="children"><div class="content">Ken Shirriff, naturally, has tackled the subject a while back in a multipart analysis of the Yamaha DX7.<p><a href="https:&#x2F;&#x2F;www.righto.com&#x2F;search&#x2F;label&#x2F;dx7" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.righto.com&#x2F;search&#x2F;label&#x2F;dx7</a></div><br/></div></div><div id="38757668" class="c"><input type="checkbox" id="c-38757668" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#38759578">prev</a><span>|</span><a href="#38757946">next</a><span>|</span><label class="collapse" for="c-38757668">[-]</label><label class="expand" for="c-38757668">[1 more]</label></div><br/><div class="children"><div class="content">The original paper is quite short and readable: <a href="https:&#x2F;&#x2F;people.ece.cornell.edu&#x2F;land&#x2F;courses&#x2F;ece4760&#x2F;Math&#x2F;GCC644&#x2F;FM_synth&#x2F;Chowning.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;people.ece.cornell.edu&#x2F;land&#x2F;courses&#x2F;ece4760&#x2F;Math&#x2F;GCC...</a></div><br/></div></div><div id="38757946" class="c"><input type="checkbox" id="c-38757946" checked=""/><div class="controls bullet"><span class="by">gylterud</span><span>|</span><a href="#38757668">prev</a><span>|</span><a href="#38758079">next</a><span>|</span><label class="collapse" for="c-38757946">[-]</label><label class="expand" for="c-38757946">[3 more]</label></div><br/><div class="children"><div class="content">I love through-zero frequency modulation (TZFM).<p>If your oscillator can do TZFM you can bring it’s frequency down to zero, where it stops oscillating and then to “negative frequency” where it starts oscillating again, but with a reversed waveform.<p>This has two main usages:<p>first you can do normal FM sounds with very deep modulation without getting strange pitch shifts because the frequency is capped before zero.<p>Second, you can set the oscillator to start at zero and then modulate symmetrically around zero. The sound you get is quite unique — ranging from woody sounds to growling lead sounds.  The fundamental pitch is decided by the modulator (as opposed to the carrier in usual FM). Symmetric TZFM takes the modulator signal and integrates it, then adds harmonic content by folding 
according to the waveshape of the modulator. This works best if the two oscillators are kept in soft or hard sync.<p>My favourite patch is to use a harmonic oscillator as modulator for a TZFM carrier. Modulating the distribution of sines in the modulator and the frequency of the carries gives  such a unique set of timbre controls.</div><br/><div id="38759210" class="c"><input type="checkbox" id="c-38759210" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#38757946">parent</a><span>|</span><a href="#38758383">next</a><span>|</span><label class="collapse" for="c-38759210">[-]</label><label class="expand" for="c-38759210">[1 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s like time running backwards. Or the speed. FM is basically turning the speed up and down, no reason it can&#x27;t go backwards too!
Edit: or a DJ doing a record scratch</div><br/></div></div><div id="38758383" class="c"><input type="checkbox" id="c-38758383" checked=""/><div class="controls bullet"><span class="by">IanHalbwachs</span><span>|</span><a href="#38757946">parent</a><span>|</span><a href="#38759210">prev</a><span>|</span><a href="#38758079">next</a><span>|</span><label class="collapse" for="c-38758383">[-]</label><label class="expand" for="c-38758383">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m intrigued. Anywhere I can hear some examples of this, or know of any (free) ways I can generate some with software?</div><br/></div></div></div></div><div id="38758079" class="c"><input type="checkbox" id="c-38758079" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#38757946">prev</a><span>|</span><a href="#38756370">next</a><span>|</span><label class="collapse" for="c-38758079">[-]</label><label class="expand" for="c-38758079">[1 more]</label></div><br/><div class="children"><div class="content">Site requires a whole bunch of hosts (including Google and Facebook) to be unblocked before any audio plays.</div><br/></div></div><div id="38756370" class="c"><input type="checkbox" id="c-38756370" checked=""/><div class="controls bullet"><span class="by">CrypticShift</span><span>|</span><a href="#38758079">prev</a><span>|</span><a href="#38756400">next</a><span>|</span><label class="collapse" for="c-38756370">[-]</label><label class="expand" for="c-38756370">[15 more]</label></div><br/><div class="children"><div class="content">FM synth programming can feel like a dark art for starters. It&#x27;s much less straightforward to dial in a specific sound compared to, say, subtractive synths.<p>Now imagine a synth that reverse-engineers audio sounds you feed it, adjusting its parameters to match. This would be a game-changer for learning.  This recently released FM synth is trying to do just that with AI : <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3gTYlYG6-R8" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3gTYlYG6-R8</a></div><br/><div id="38757386" class="c"><input type="checkbox" id="c-38757386" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757289">next</a><span>|</span><label class="collapse" for="c-38757386">[-]</label><label class="expand" for="c-38757386">[4 more]</label></div><br/><div class="children"><div class="content">As a synth head that teaches synthesizers at university: While I think that is an interesting idea in itself, it is probably not the best idea for <i>learning</i> how FM synthesis works. Learning synths is both about gaining an intution what sounds emerge when you change a set of parameters, as well as having a mental model of the signal flow and how that shapes the sounds.<p>Both are things that are not helped by having something that creates presets for you — in fact it might even be more productive to look at human made presets if you need guidence.<p>Also: Synthesizers are also good for creating never before heard, totally out there sounds, and those are hard to reach when you feed it existing stuff. My own personal learning approach always was to use a simple init preset and then create everything manually from there. I called this my &quot;No-presets rule&quot; (meaning I don&#x27;t use presets that I did not make myswlf for anything, unless ot is a commercial gig). If you then make your 10th preset from scratch you probably understood <i>something</i> already. And then at some point looking at other people&#x27;s stuff starts to make sense because now you have a set of eyeballs that can actually peeceive the things they did.</div><br/><div id="38757744" class="c"><input type="checkbox" id="c-38757744" checked=""/><div class="controls bullet"><span class="by">ducharmdev</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757386">parent</a><span>|</span><a href="#38757289">next</a><span>|</span><label class="collapse" for="c-38757744">[-]</label><label class="expand" for="c-38757744">[3 more]</label></div><br/><div class="children"><div class="content">Re: your experience teaching synths in university, do you feel there is certain knowledge&#x2F;concepts that are difficult for those self-teaching sound design?<p>I do the same &quot;no presets rule&quot;, with most being the result of random experimentation and fiddling of parameters. This does a good job at &quot;creating never before heard, totally out there sounds&quot;, but I imagine it&#x27;s trickier the more specific your end goal is.</div><br/><div id="38757967" class="c"><input type="checkbox" id="c-38757967" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757744">parent</a><span>|</span><a href="#38757289">next</a><span>|</span><label class="collapse" for="c-38757967">[-]</label><label class="expand" for="c-38757967">[2 more]</label></div><br/><div class="children"><div class="content">I think the hardest part is getting the basics straight, and by that I mean things like understanding oscillation produces sound, amplitude influences the spund level while the speed of the oscillation influences the pitch. Understanding that by modulating pitch and amplitude you can already create a ton.<p>The biggest challenge for students in my experience is grasping all these obscure words and acronyms, with VCOs, LFOs, keytracking, Envelopes, ADSR, Triggers, Gates, CVs, oscillations, overtones, frequency graphs, filter cutoff points, resonance, ...<p>It is just a lot of concepts at once. Sometimes it can pay of to take a step back and limit one&#x27;s arsenal and figure out how far you can get only using one or two of those.</div><br/><div id="38759140" class="c"><input type="checkbox" id="c-38759140" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757967">parent</a><span>|</span><a href="#38757289">next</a><span>|</span><label class="collapse" for="c-38759140">[-]</label><label class="expand" for="c-38759140">[1 more]</label></div><br/><div class="children"><div class="content">Totally. I&#x27;m self-taught in this area and I feel like the biggest obstacle for self-study is that the basic concepts are often passed over too quickly (like simply the idea of using phase&#x2F;the unit circle to represent oscillations, and how all that relates to frequency and period). I recently sat down and tried to make sure I <i>really</i> understood the mathematical modeling part of the whole business and it brings a lot of clarity when tackling more advanced topics. This is kind of true for self-studying any mathematical domain generally. It&#x27;s easy to pass over the &quot;entry-level&quot; or foundational stuff quickly because on the surface it seems straightforward, but getting those fundamental ideas crystal clear and burned into your brain is absolutely crucial if you&#x27;re going to comprehend anything that follows.</div><br/></div></div></div></div></div></div></div></div><div id="38757289" class="c"><input type="checkbox" id="c-38757289" checked=""/><div class="controls bullet"><span class="by">SeanLuke</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757386">prev</a><span>|</span><a href="#38757169">next</a><span>|</span><label class="collapse" for="c-38757289">[-]</label><label class="expand" for="c-38757289">[4 more]</label></div><br/><div class="children"><div class="content">Using genetic algorithms or other evolutionary computation methods for this purpose is pretty old.  There are two versions.  First, there is <i>evolutionary resynthesis</i>, where the system is trying to optimize a synth program to match an existing sound. This can be done automatically: try a bunch of sounds, have some automatic comparator compare them to the target sound, assess them, mix-and-match, try again.  Then there is <i>interactive evolution</i>, where the system is trying to come up with sounds interesting to the musician.  Here the system proposes and auditions synth patches, and the musician responds with what he thinks are the better ones, and using that information the system mixes and matches and tries again.<p>Evolutionary resynthesis has been around since at least 1996 (Horner).  Aphex Twin was enamored with it for a while.  I don&#x27;t think it&#x27;s particularly interesting: if you already have a target sound, why are you trying to come up with a program to match it?  Why not use the sound itself?  But interactive evolution is both useful, more difficult, and interesting, as it makes it possible for the musician to explore the space of synth programs without having to program them (and that&#x27;s particularly good for FM, since FM is EXTREMELY counterintuitive to program).<p>I wrote what I think is the best <i>general-purpose</i> interactive evolution style synth programming system right now: Edisyn.  It works with a wide range of synthesizers and synthesis types.  If you restrict yourself to exactly one synthesizer of your own design, you can get better results still, and there are a number of softsynths out there which do this.<p>But most interestingly: interactive evolution has a specific inventor: BRIAN ENO!  He invented it around 1995 in a letter he wrote to Stewart Brand.</div><br/><div id="38757401" class="c"><input type="checkbox" id="c-38757401" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757289">parent</a><span>|</span><a href="#38758710">next</a><span>|</span><label class="collapse" for="c-38757401">[-]</label><label class="expand" for="c-38757401">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you already have a target sound, why are you trying to come up with a program to match it?<p>Once you have the program matching the sound, you can tweak it and get variations. At least that&#x27;s what I imagine people would want it for.</div><br/></div></div><div id="38758710" class="c"><input type="checkbox" id="c-38758710" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757289">parent</a><span>|</span><a href="#38757401">prev</a><span>|</span><a href="#38757169">next</a><span>|</span><label class="collapse" for="c-38758710">[-]</label><label class="expand" for="c-38758710">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>if you already have a target sound, why are you trying to come up with a program to match it</i><p>Because then you have it (or something close) in your own synthesizer, as opposed to whatever other synth or natural source you sampled it from, and you can enhance it, adjust it, use filters and others on it, and so on using all its native cabilities.</div><br/><div id="38760506" class="c"><input type="checkbox" id="c-38760506" checked=""/><div class="controls bullet"><span class="by">SeanLuke</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38758710">parent</a><span>|</span><a href="#38757169">next</a><span>|</span><label class="collapse" for="c-38760506">[-]</label><label class="expand" for="c-38760506">[1 more]</label></div><br/><div class="children"><div class="content">Sure.  But you can manipulate the sample in complex ways with filters, effects, etc. on your sampler or rompler already.  I&#x27;m not saying there&#x27;s <i>no</i> reason -- I&#x27;m just saying it&#x27;s a fairly narrow and not hugely compelling one.</div><br/></div></div></div></div></div></div><div id="38757169" class="c"><input type="checkbox" id="c-38757169" checked=""/><div class="controls bullet"><span class="by">unleaded</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757289">prev</a><span>|</span><a href="#38757318">next</a><span>|</span><label class="collapse" for="c-38757169">[-]</label><label class="expand" for="c-38757169">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s been around for at least 30 years[1] although there is a strange lack of tools using it, I looked into it a while ago. There&#x27;s a tool for generating OPN2 patches[2] (sound chip used in Sega Mega Drive) which is what I&#x27;m most interested in this technology for but I couldn&#x27;t get it running right. And a modern method that uses neural networks instead of genetic algorithms but I haven&#x27;t found any applications of it [3].<p>[1]  <a href="https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;3680541" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;3680541</a><p>[2]  <a href="https:&#x2F;&#x2F;github.com&#x2F;jpcima&#x2F;fmprog">https:&#x2F;&#x2F;github.com&#x2F;jpcima&#x2F;fmprog</a><p>[3]  <a href="http:&#x2F;&#x2F;kth.diva-portal.org&#x2F;smash&#x2F;get&#x2F;diva2:1334639&#x2F;FULLTEXT01.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;kth.diva-portal.org&#x2F;smash&#x2F;get&#x2F;diva2:1334639&#x2F;FULLTEXT0...</a><p>p.s. does anyone know why do so many papers on new technologies like this never even provide code samples? what&#x27;s the point?</div><br/></div></div><div id="38757318" class="c"><input type="checkbox" id="c-38757318" checked=""/><div class="controls bullet"><span class="by">derriz</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757169">prev</a><span>|</span><a href="#38757450">next</a><span>|</span><label class="collapse" for="c-38757318">[-]</label><label class="expand" for="c-38757318">[3 more]</label></div><br/><div class="children"><div class="content">Fiddling around with FM, I&#x27;ve found it easy to dial in interesting sounds but very difficult to find sounds that are &quot;musical&quot; so it&#x27;s difficult to actually incorporate them into a piece of music.  I guess the wild success of the built-in patches of something like the DX7 proves that this is down to my own lack of skill but FM synthesis seems somewhat chaotic - a small adjustment to one parameter can cause a wild swing in the sound.</div><br/><div id="38758119" class="c"><input type="checkbox" id="c-38758119" checked=""/><div class="controls bullet"><span class="by">anigbrowl</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38757318">parent</a><span>|</span><a href="#38757450">next</a><span>|</span><label class="collapse" for="c-38758119">[-]</label><label class="expand" for="c-38758119">[2 more]</label></div><br/><div class="children"><div class="content">Try to use modulation frequencies that are in some sort of integer ratio to the carrier wave; the lower the ratio the less tinny&#x2F;fizzy the sound will be. Non-integer ratios are enharmonic, good for percussion and SFX but also quickly tailing off into noise.</div><br/><div id="38758677" class="c"><input type="checkbox" id="c-38758677" checked=""/><div class="controls bullet"><span class="by">chillingeffect</span><span>|</span><a href="#38756370">root</a><span>|</span><a href="#38758119">parent</a><span>|</span><a href="#38757450">next</a><span>|</span><label class="collapse" for="c-38758677">[-]</label><label class="expand" for="c-38758677">[1 more]</label></div><br/><div class="children"><div class="content">Underrated comment.  This is one of the most inportant parts of FM, imo.  Each integer ratio of carrier to modulator has a specific flavor.  The &quot;simpler&quot; the ratio the less complex and flavorful the sound.<p>Therefore, fading from irrational to rational ratios can make a crazy, inharmonic sound &quot;stabilize.&quot;<p>After working for years with FM, i have found a somewhat narrow range of sounds and the layering becomes more inportant than the algorithm.  So getting to know of the ratios is important, 1:2, 1:3, 1:4, etc.</div><br/></div></div></div></div></div></div><div id="38757450" class="c"><input type="checkbox" id="c-38757450" checked=""/><div class="controls bullet"><span class="by">u_s_e_r</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757318">prev</a><span>|</span><a href="#38757852">next</a><span>|</span><label class="collapse" for="c-38757450">[-]</label><label class="expand" for="c-38757450">[1 more]</label></div><br/><div class="children"><div class="content">Another approach, rather than generating randomized offspring, differentiable dsp provides a mechanism to self-correct using a loss function<p><a href="https:&#x2F;&#x2F;deepai.org&#x2F;publication&#x2F;ddx7-differentiable-fm-synthesis-of-musical-instrument-sounds" rel="nofollow noreferrer">https:&#x2F;&#x2F;deepai.org&#x2F;publication&#x2F;ddx7-differentiable-fm-synthe...</a></div><br/></div></div><div id="38757852" class="c"><input type="checkbox" id="c-38757852" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#38756370">parent</a><span>|</span><a href="#38757450">prev</a><span>|</span><a href="#38756400">next</a><span>|</span><label class="collapse" for="c-38757852">[-]</label><label class="expand" for="c-38757852">[1 more]</label></div><br/><div class="children"><div class="content">I disagree, given one of my favorite synths FM8, which in particular I&#x27;ve always found easy given its very thoughtful interface mechanisms of an &quot;easy mode&quot; and a &quot;hard mode&quot; both of which have extremely powerful, precise envelopes which can be dialed in really cleanly to visually carve out any kind of sound one is looking for. It&#x27;s easy to grab a preset, customize to taste, and experiment with it to gain your footing and intuition around how it works.<p>I also disagree that a synth which &quot;reverse-engineers&quot; the audio sounds you feed it is the right way to go. By doing this rather than learning how to do it from scratch (albeit with training wheels as I&#x27;ve previously described), you rob yourself of the rich experience of learning how to use FM synthesis as applied physical modeling.</div><br/></div></div></div></div><div id="38756400" class="c"><input type="checkbox" id="c-38756400" checked=""/><div class="controls bullet"><span class="by">fassssst</span><span>|</span><a href="#38756370">prev</a><span>|</span><label class="collapse" for="c-38756400">[-]</label><label class="expand" for="c-38756400">[3 more]</label></div><br/><div class="children"><div class="content">Modulate one oscillator with another</div><br/><div id="38757969" class="c"><input type="checkbox" id="c-38757969" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#38756400">parent</a><span>|</span><a href="#38757492">next</a><span>|</span><label class="collapse" for="c-38757969">[-]</label><label class="expand" for="c-38757969">[1 more]</label></div><br/><div class="children"><div class="content">Can vibrato be considered FM synthesis?<p>Edit: aaah, should have read further into the article</div><br/></div></div><div id="38757492" class="c"><input type="checkbox" id="c-38757492" checked=""/><div class="controls bullet"><span class="by">Subdivide8452</span><span>|</span><a href="#38756400">parent</a><span>|</span><a href="#38757969">prev</a><span>|</span><label class="collapse" for="c-38757492">[-]</label><label class="expand" for="c-38757492">[1 more]</label></div><br/><div class="children"><div class="content">The end.</div><br/></div></div></div></div></div></div></div></div></div></body></html>