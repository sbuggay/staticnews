<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684227658934" as="style"/><link rel="stylesheet" href="styles.css?v=1684227658934"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://billydm.github.io/blog/daw-frontend-development-struggles/">Digital Audio Workstation Front End Development Struggles</a> <span class="domain">(<a href="https://billydm.github.io">billydm.github.io</a>)</span></div><div class="subtext"><span>ingve</span> | <span>115 comments</span></div><br/><div><div id="35958500" class="c"><input type="checkbox" id="c-35958500" checked=""/><div class="controls bullet"><span class="by">ogoffart</span><span>|</span><a href="#35958193">next</a><span>|</span><label class="collapse" for="c-35958500">[-]</label><label class="expand" for="c-35958500">[11 more]</label></div><br/><div class="children"><div class="content">Slint dev here.<p>I&#x27;m a bit disappointed to see that Slint is considered a non-starter. In fact, one of our users is currently working on exactly that (a VST plugin for an audio application) and they are about to release it very soon. Unfortunately, I can&#x27;t share a link until it&#x27;s officially released.<p>The author seems to dismiss declarative UI without explaining why. From my perspective, declarative is the best way to describe UI.<p>Regarding the limited support for custom widgets, I disagree. In Slint, it&#x27;s incredibly easy to create custom widgets. A widget is simply a component that can be created and utilized.<p>While it&#x27;s true that our desktop integration is still a work in progress, we have already implemented the core functionalities needed for building such UIs. We are actively developing features based on user needs and prioritize implementing features that our users require immediately. If you&#x27;re interested in using Slint, please reach out to us, and we&#x27;ll ensure that we implement what is necessary for your product.</div><br/><div id="35958739" class="c"><input type="checkbox" id="c-35958739" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#35958500">parent</a><span>|</span><a href="#35959042">next</a><span>|</span><label class="collapse" for="c-35958739">[-]</label><label class="expand" for="c-35958739">[3 more]</label></div><br/><div class="children"><div class="content">Declarative UI, even when implemented coherently within the same langauge like in Flutter and MAUI&#x2F;Xamarin, so there is no need for an ugly bridge between two worlds, still leads to an unreadable nested hell.<p>Surprisingly, an imperative GUI creation code is much more easier to read and modify.</div><br/><div id="35958897" class="c"><input type="checkbox" id="c-35958897" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958739">parent</a><span>|</span><a href="#35959068">next</a><span>|</span><label class="collapse" for="c-35958897">[-]</label><label class="expand" for="c-35958897">[1 more]</label></div><br/><div class="children"><div class="content">Hmm? I&#x27;ve written a fair bit of React, which I assume fits the declarative description, and I never got the impression that it leads to an &quot;unreadable nested hell&quot;. You split up your big functions into smaller reusable functions, just like in all other forms of programming.</div><br/></div></div><div id="35959068" class="c"><input type="checkbox" id="c-35959068" checked=""/><div class="controls bullet"><span class="by">ogoffart</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958739">parent</a><span>|</span><a href="#35958897">prev</a><span>|</span><a href="#35959042">next</a><span>|</span><label class="collapse" for="c-35959068">[-]</label><label class="expand" for="c-35959068">[1 more]</label></div><br/><div class="children"><div class="content">I respectfully disagree. In my experience, Declarative UI is more concise, making development and changes easier. It enhances productivity and allows for a clear separation of concerns, which is beneficial.<p>Moreover, Declarative UI enables the development of powerful tooling and visual editors. For instance, in Slint, we have an extension that provides live UI preview and code transformation capabilities. We are also actively working on a visual editor that lets users drag and drop widgets. Such capabilities are difficult or impossible to achieve with imperative APIs.</div><br/></div></div></div></div><div id="35959042" class="c"><input type="checkbox" id="c-35959042" checked=""/><div class="controls bullet"><span class="by">andyjohnson0</span><span>|</span><a href="#35958500">parent</a><span>|</span><a href="#35958739">prev</a><span>|</span><a href="#35958809">next</a><span>|</span><label class="collapse" for="c-35959042">[-]</label><label class="expand" for="c-35959042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; From my perspective, declarative is the best way to describe UI<p>I agree.<p>It seems like we have some good solutions for declaratively describing the structure and static appearance of UIs - but beyond things like transition animations, we don&#x27;t have anything that satisfactorily describes their behaviour. Its a hard problem nut I sometimes wonder why this aspect is under-served by the technologies we have.</div><br/></div></div><div id="35958809" class="c"><input type="checkbox" id="c-35958809" checked=""/><div class="controls bullet"><span class="by">larschdk</span><span>|</span><a href="#35958500">parent</a><span>|</span><a href="#35959042">prev</a><span>|</span><a href="#35958581">next</a><span>|</span><label class="collapse" for="c-35958809">[-]</label><label class="expand" for="c-35958809">[4 more]</label></div><br/><div class="children"><div class="content">I find Slint&#x27;s font rendering odd and somewhat off-putting. It doesn&#x27;t look sharp, especially on classic 96 DPI displays. Big text look inconsistently both fuzzy and aliased, and small text has inconsistent intensity. Lack of subpixel rendering and hinting? Rounded corners look sharp in comparison.</div><br/><div id="35958882" class="c"><input type="checkbox" id="c-35958882" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958809">parent</a><span>|</span><a href="#35958581">next</a><span>|</span><label class="collapse" for="c-35958882">[-]</label><label class="expand" for="c-35958882">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s unfortunately an issue I have seen with several new GUI frameworks over the last years: with High-DPI displays getting more widespread, they tend to push subpixel rendering support down the road.</div><br/><div id="35958935" class="c"><input type="checkbox" id="c-35958935" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958882">parent</a><span>|</span><a href="#35958581">next</a><span>|</span><label class="collapse" for="c-35958935">[-]</label><label class="expand" for="c-35958935">[2 more]</label></div><br/><div class="children"><div class="content">And understandably so. Du pixel rendering only works on some kinds of displays (many modern displays don&#x27;t have 3 vertical subpixels per pixel), makes the text look kinda bad due to the wonky colors, really doesn&#x27;t mesh well with any sort of transparency or even coloured text, it requires that you keep 3 images of each glyph in memory to account for the 3 different sub pixel offsets. It also deeply entangles detailed knowledge of the monitor into your font rendering. You need to re-render everything and update all text any time orientation changes or the window is dragged between monitors. And <i>how the hell</i> do you handle a window stretching across 2 different monitors?<p>That&#x27;s not to dismiss subpixel rendering, there is arguably a legibility improvement to trading off color accuracy for horizontal resolution, but it&#x27;s really no wonder that new frameworks don&#x27;t bother and that old frameworks are losing the ability to do subpixel rendering. Apple, for example, ripped out subpixel rendering from their frameworks a long time ago (before Retina displays, IIRC).</div><br/><div id="35959090" class="c"><input type="checkbox" id="c-35959090" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958935">parent</a><span>|</span><a href="#35958581">next</a><span>|</span><label class="collapse" for="c-35959090">[-]</label><label class="expand" for="c-35959090">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Apple, for example, ripped out subpixel rendering from their frameworks a long time ago (before Retina displays, IIRC).</i><p>...or at least when Retina displays were still rare and expensive, probably to <i>encourage</i> the adoption.</div><br/></div></div></div></div></div></div></div></div><div id="35958581" class="c"><input type="checkbox" id="c-35958581" checked=""/><div class="controls bullet"><span class="by">chaosprint</span><span>|</span><a href="#35958500">parent</a><span>|</span><a href="#35958809">prev</a><span>|</span><a href="#35958193">next</a><span>|</span><label class="collapse" for="c-35958581">[-]</label><label class="expand" for="c-35958581">[2 more]</label></div><br/><div class="children"><div class="content">Do you have plan for wgpu?</div><br/><div id="35958695" class="c"><input type="checkbox" id="c-35958695" checked=""/><div class="controls bullet"><span class="by">tronical</span><span>|</span><a href="#35958500">root</a><span>|</span><a href="#35958581">parent</a><span>|</span><a href="#35958193">next</a><span>|</span><label class="collapse" for="c-35958695">[-]</label><label class="expand" for="c-35958695">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re working on interop, so that when you select Slint&#x27;s Skia renderer on top of Vulkan or Metal, you can import a wgpu texture if wgpu&#x27;s Metal or Vulkan adapter was chosen.<p>What kind of feature set do you need?</div><br/></div></div></div></div></div></div><div id="35958193" class="c"><input type="checkbox" id="c-35958193" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#35958500">prev</a><span>|</span><a href="#35958507">next</a><span>|</span><label class="collapse" for="c-35958193">[-]</label><label class="expand" for="c-35958193">[20 more]</label></div><br/><div class="children"><div class="content">&gt; Both Javascript and the DOM are slow, there&#x27;s no changing that.<p>The DOM isn&#x27;t slow. Adding or removing a DOM node is literally a few point swaps, which isn&#x27;t much more than setting a property on an OOP language object. What is slow is &quot;layout&quot;. When Javascript changes something and hands control back to the browser it invokes its CSS recalc, layout, repaint and finally recomposition algorithms to redraw the screen.  The layout algorithm is quite complex and it&#x27;s synchronous, which makes it stupidly easy to make thing slow. Frameworks like React with virtual DOMs help you by redrawing on every state change, which will typically both speed things up significantly and also carry you through a lot of things that would break if you were using non virtual DOM frameworks like JQuery. You can get smooth and quick animations with JavaScript and the DOM, however, but only if you build things to limit what your application can do in a frame to operations which can be performed on the GPU.<p>I can understand if that&#x27;s not exactly an option for the author of this article, but I&#x27;m not convinced you couldn&#x27;t get Electron (or similar) to work as a GUI framework for a DAW. I suspect Electron specifically might actually be a pretty good framework for DAW&#x27;s, considering what Microsoft is doing with VSC. I also think that the downside of frameworks like Electron is that you need to be, not only Microsoft, but the Microsoft VSC team (and not the Microsoft Teams team) specifically, to bend them to your way.<p>That being said, I think this will likely be one of those things where you&#x27;d need to create a GUI framework (or bend one to your will) to really get DAWs to work for you. Because I think the author is spot on about the &quot;state&quot; of GUI frameworks in general.</div><br/><div id="35958359" class="c"><input type="checkbox" id="c-35958359" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#35958193">parent</a><span>|</span><a href="#35958489">next</a><span>|</span><label class="collapse" for="c-35958359">[-]</label><label class="expand" for="c-35958359">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Frameworks like React with virtual DOMs help you by redrawing on every state change, which will typically both speed things up significantly and also carry you through a lot of things that would break if you were using non virtual DOM frameworks<p>A virtual DOM based framework will not be faster than manual DOM manipulation with either vanilla JS or even JQuery. It certainly makes development easier, and massively reduces the risk of bugs. But there is no magic to a VDOM and speed, technically you are usually doing <i>more</i> work, building a VDOM and diffing it.<p>Edit:<p>Rich Harris of Svelte has a good post explaining:<p>&gt; Virtual DOM is pure overhead. Let&#x27;s retire the &#x27;virtual DOM is fast&#x27; myth once and for all<p><a href="https:&#x2F;&#x2F;svelte.dev&#x2F;blog&#x2F;virtual-dom-is-pure-overhead" rel="nofollow">https:&#x2F;&#x2F;svelte.dev&#x2F;blog&#x2F;virtual-dom-is-pure-overhead</a></div><br/><div id="35958551" class="c"><input type="checkbox" id="c-35958551" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958359">parent</a><span>|</span><a href="#35958747">next</a><span>|</span><label class="collapse" for="c-35958551">[-]</label><label class="expand" for="c-35958551">[4 more]</label></div><br/><div class="children"><div class="content">&gt; But there is no magic to a VDOM and speed<p>There absolutely is. If you are using standard DOM APIs and are first changing the text of a &lt;span&gt; element, then changing it back to what it was before (which can easily happen if your application logic is sufficiently complex, with multiple piecewise state changes impacting the UI), the browser will have to re-render the element twice, which means two full re-layouts unless the element is absolutely positioned or something.<p>By contrast, VDOM-based frameworks will detect that the DOM hasn&#x27;t actually changed, and as a result, the browser doesn&#x27;t have to do anything (other than update the VDOM).<p>That&#x27;s indeed &quot;magic&quot;, and makes a tremendous performance difference with complex applications in practice.</div><br/><div id="35958607" class="c"><input type="checkbox" id="c-35958607" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958551">parent</a><span>|</span><a href="#35958747">next</a><span>|</span><label class="collapse" for="c-35958607">[-]</label><label class="expand" for="c-35958607">[3 more]</label></div><br/><div class="children"><div class="content">No, in a correctly implemented pure DOM manipulation app you would update the DOM once to match your state, that&#x27;s faster than building a VDOM and diffing it. Modifying the DOM twice, with an unintentional reflow and redraw between, would be a bug in your code.<p>Yes, &quot;if your application logic is sufficiently complex, with multiple piecewise state changes impacting the UI&quot; is what a VDOM helps with from a developer perspective. But it isn&#x27;t magically &quot;faster&quot;.<p>Personally I&#x27;m a fan of reactive frameworks such as Vue that do use a VDOM, but also by using a reactive state can do fine grain partial rendering of that VDOM for efficiency.<p>Would I build an app without a (probably VDOM based) framework, no I wouldn&#x27;t.<p>Also note that the &quot;fastest&quot; frameworks, such as Solid, don&#x27;t use a VDOM, they track state changes and do fine grade DOM manipulation to match it.</div><br/><div id="35958853" class="c"><input type="checkbox" id="c-35958853" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958607">parent</a><span>|</span><a href="#35958747">next</a><span>|</span><label class="collapse" for="c-35958853">[-]</label><label class="expand" for="c-35958853">[2 more]</label></div><br/><div class="children"><div class="content">Who needs memory safety? Just correctly use malloc and free on every possible code path. Easy and simple!</div><br/><div id="35959004" class="c"><input type="checkbox" id="c-35959004" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958853">parent</a><span>|</span><a href="#35958747">next</a><span>|</span><label class="collapse" for="c-35959004">[-]</label><label class="expand" for="c-35959004">[1 more]</label></div><br/><div class="children"><div class="content">VDOM isn&#x27;t the equivalent of memory safety - such as using Rust over C, its much more similar to using a garbage collected high level language - such as Python or Ruby - over C.<p>Your implied comparison doesn&#x27;t work.</div><br/></div></div></div></div></div></div></div></div><div id="35958747" class="c"><input type="checkbox" id="c-35958747" checked=""/><div class="controls bullet"><span class="by">ricardobayes</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958359">parent</a><span>|</span><a href="#35958551">prev</a><span>|</span><a href="#35958489">next</a><span>|</span><label class="collapse" for="c-35958747">[-]</label><label class="expand" for="c-35958747">[3 more]</label></div><br/><div class="children"><div class="content">Huh? You&#x27;re not doing any of this, the framework does it automatically. The virtual DOM and DOM change reconciliation makes it faster. DOM changes are really slow. The reconciliation makes sure only the parts are re-rendered which have changed. Failing that, the full screen is re-rendered.
If you&#x27;re doing manual VDOM building you&#x27;re doing something very wrong.</div><br/><div id="35958914" class="c"><input type="checkbox" id="c-35958914" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958747">parent</a><span>|</span><a href="#35958489">next</a><span>|</span><label class="collapse" for="c-35958914">[-]</label><label class="expand" for="c-35958914">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re doing manual VDOM building you&#x27;re doing something very wrong.<p>Rendering a React or Vue component is building a VDOM, that&#x27;s what I&#x27;m referring to. Your code is explicitly building a VDOM.<p>&gt; The reconciliation makes sure only the parts are re-rendered which have changed.<p>Yes, and that makes development easier.<p>That reconciliation is only &quot;faster&quot; if your alternative non-VDOM code is poorly written, throwing away chunks of DOM and rebuilding from scratch.<p>I&#x27;m not advocating for not using VDOM frameworks, I use them, I&#x27;m advocating for understanding they are not faster than the DOM. that is a myth, and results in people misunderstanding the tools or how the DOM and browsers work.</div><br/><div id="35959039" class="c"><input type="checkbox" id="c-35959039" checked=""/><div class="controls bullet"><span class="by">ricardobayes</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958914">parent</a><span>|</span><a href="#35958489">next</a><span>|</span><label class="collapse" for="c-35959039">[-]</label><label class="expand" for="c-35959039">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I definitely agree with VDOM doesn&#x27;t necessarily speed up anything on its own. There are many frameworks that benchmark better than react, for example - svelte, lit - these don&#x27;t have VDOM at all.</div><br/></div></div></div></div></div></div></div></div><div id="35958489" class="c"><input type="checkbox" id="c-35958489" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#35958193">parent</a><span>|</span><a href="#35958359">prev</a><span>|</span><a href="#35958334">next</a><span>|</span><label class="collapse" for="c-35958489">[-]</label><label class="expand" for="c-35958489">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about the performance but web is THE most capable platform that itself is cross platform.<p>As for performance, text editor with dozens of plugins and syntax highlight is no joke either and I have no issues on my MacBook Air with only two cores from few years ago - abandoned Jet Brains IDEs for a web based text editor (VScode) and works pretty well even on large code bases.</div><br/><div id="35958539" class="c"><input type="checkbox" id="c-35958539" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958489">parent</a><span>|</span><a href="#35958334">next</a><span>|</span><label class="collapse" for="c-35958539">[-]</label><label class="expand" for="c-35958539">[3 more]</label></div><br/><div class="children"><div class="content">I think you have failed to comprehend what a DAW actually needs to do&#x2F;render, quickly.</div><br/><div id="35958861" class="c"><input type="checkbox" id="c-35958861" checked=""/><div class="controls bullet"><span class="by">yurishimo</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958539">parent</a><span>|</span><a href="#35958685">next</a><span>|</span><label class="collapse" for="c-35958861">[-]</label><label class="expand" for="c-35958861">[1 more]</label></div><br/><div class="children"><div class="content">Can you share some examples where a DAW&#x2F;plugin would need to update that much visual data onscreen with almost zero latency? I&#x27;m genuinely asking someone who used to make music with orchestral&#x2F;Pianos&#x2F;Drum VSTs a ton a few years ago.<p>I agree that the underlying audio should be as fast as possible, but I don&#x27;t see why the UI couldn&#x27;t &quot;lag&quot; behind by a few extra milliseconds for on screen rendering. Especially as a plugin.<p>Again, not trolling; genuinely curious!</div><br/></div></div><div id="35958685" class="c"><input type="checkbox" id="c-35958685" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958539">parent</a><span>|</span><a href="#35958861">prev</a><span>|</span><a href="#35958334">next</a><span>|</span><label class="collapse" for="c-35958685">[-]</label><label class="expand" for="c-35958685">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong to assume so. I think I should have said that minus the DAW and otherwise generally speaking for let&#x27;s say 95% of the use cases, the web is pretty OK.<p>So instead of editing the comment above, I&#x27;d agree with your underlying point about DAW and complexity of the UI. It is no trivial.<p>As a backend engineer, the progress on web platform certainly is dazzling from Web Assembly to Web GPU, Flex, Grid, Container queries and lately view transitions.</div><br/></div></div></div></div></div></div><div id="35958334" class="c"><input type="checkbox" id="c-35958334" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#35958193">parent</a><span>|</span><a href="#35958489">prev</a><span>|</span><a href="#35958507">next</a><span>|</span><label class="collapse" for="c-35958334">[-]</label><label class="expand" for="c-35958334">[7 more]</label></div><br/><div class="children"><div class="content">&gt;  I also think that the downside of frameworks like Electron is that you need to be, not only Microsoft, but the Microsoft VSC team (and not the Microsoft Teams team) specifically, to bend them to your way.<p>I am not sure this is true, Discord as one example is pretty good. As is Slack&#x27;s desktop app*<p>*By &quot;good&quot; I mean, perform the task in a stable way and appear fairly &#x27;native&#x27; in terms of UX (but not UI design of course)</div><br/><div id="35959240" class="c"><input type="checkbox" id="c-35959240" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958334">parent</a><span>|</span><a href="#35958867">next</a><span>|</span><label class="collapse" for="c-35959240">[-]</label><label class="expand" for="c-35959240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am not sure this is true, Discord as one example is pretty good. As is Slack&#x27;s desktop app*<p>I think you actually need to try out an actual good native app just to see how much of a ridiculous claim that is.</div><br/></div></div><div id="35958867" class="c"><input type="checkbox" id="c-35958867" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958334">parent</a><span>|</span><a href="#35959240">prev</a><span>|</span><a href="#35958622">next</a><span>|</span><label class="collapse" for="c-35958867">[-]</label><label class="expand" for="c-35958867">[1 more]</label></div><br/><div class="children"><div class="content">The slack desktop app often lags when I type...</div><br/></div></div><div id="35958622" class="c"><input type="checkbox" id="c-35958622" checked=""/><div class="controls bullet"><span class="by">thorncorona</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958334">parent</a><span>|</span><a href="#35958867">prev</a><span>|</span><a href="#35958367">next</a><span>|</span><label class="collapse" for="c-35958622">[-]</label><label class="expand" for="c-35958622">[3 more]</label></div><br/><div class="children"><div class="content">Discord and Slack are both nicely optimized web apps but they&#x27;re not very fast compared to native apps.<p>You can tell that there&#x27;s a noticeable lag between when you type into discord versus the terminal.</div><br/><div id="35958998" class="c"><input type="checkbox" id="c-35958998" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958622">parent</a><span>|</span><a href="#35958367">next</a><span>|</span><label class="collapse" for="c-35958998">[-]</label><label class="expand" for="c-35958998">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t realise the bar latency had to get over was a comparison to a terminal!<p>I best throw every ide or tool I&#x27;ve ever used in the bin!</div><br/><div id="35959245" class="c"><input type="checkbox" id="c-35959245" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958998">parent</a><span>|</span><a href="#35958367">next</a><span>|</span><label class="collapse" for="c-35959245">[-]</label><label class="expand" for="c-35959245">[1 more]</label></div><br/><div class="children"><div class="content">We can start with something basic like a native chat app - e.g. Telegram is a nice example of an app that doesn&#x27;t lag like ass when chatting.<p>Or an IRC client - see for example Textual.</div><br/></div></div></div></div></div></div><div id="35958367" class="c"><input type="checkbox" id="c-35958367" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#35958193">root</a><span>|</span><a href="#35958334">parent</a><span>|</span><a href="#35958622">prev</a><span>|</span><a href="#35958507">next</a><span>|</span><label class="collapse" for="c-35958367">[-]</label><label class="expand" for="c-35958367">[1 more]</label></div><br/><div class="children"><div class="content">It could be argued that in this sense, the Discord frontend team “is” a VS Code team (and not a MS Teams team)</div><br/></div></div></div></div></div></div><div id="35958507" class="c"><input type="checkbox" id="c-35958507" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#35958193">prev</a><span>|</span><a href="#35958064">next</a><span>|</span><label class="collapse" for="c-35958507">[-]</label><label class="expand" for="c-35958507">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on big complex UI projects that needed to run on embedded hardware, using different tech. Some of my observations over the years, if it helps:<p>* The DOM isn&#x27;t &quot;slow&quot; per se, but using the DOM for this kind of application is usually the wrong path to take. As soon as I need something even slightly off the well beaten path of web applications I tend to reach for canvas based solutions.<p>* Libraries like EFL are quite nice to work with but also quite low level. By default that means C, but there are bindings for other languages.<p>* Some of the things you describe (like rendering spectrographs) I&#x27;m not convinced are as CPU intensive as you think they are? Have you benchmarked? Winamp was doing these kind of visualizations back in the 90&#x27;s. I kind of doubt if you really need to use shaders to render a typical DAW if you&#x27;re smart with which parts need immediate mode rendering and which can use retained mode. Using render targets etc seems like a smart way to do a DAW, as most parts are actually quite static and only move around the screen.<p>* I have a feeling - just a feeling - that a lot of people choose Rust for projects because it&#x27;s one of the newer shinier languages, but as you&#x27;ve discovered, maybe that&#x27;s not necessarily smart. I would choose Rust for its concurrency paradigm - which might be useful for a DAW! - but for building a UI I would actually personally choose something JavaScript-based. The productivity is just so much better than most other languages, for building UI&#x27;s. This is not just my experience - I worked for some time at a large public listed US company who used JavaScript for all their big UI projects on embedded hardware, what they changed over time was the underlying rendering engine, but they kept JS because 1) hiring devs 2) productivity.<p>Good luck, it&#x27;s a super ambitious project, but I&#x27;m sure it&#x27;s amazing fun to work on! :)</div><br/><div id="35958570" class="c"><input type="checkbox" id="c-35958570" checked=""/><div class="controls bullet"><span class="by">jerrre</span><span>|</span><a href="#35958507">parent</a><span>|</span><a href="#35958618">next</a><span>|</span><label class="collapse" for="c-35958570">[-]</label><label class="expand" for="c-35958570">[2 more]</label></div><br/><div class="children"><div class="content">Regarding drawing analyzers, spectrographs:<p>I feel it actually has become a lot more expensive to draw individual pixels to a screen with the cpu compared to 20yrs ago.<p>Perhaps just because the resolutions are higher, but maybe the architecture (hardware or os) have just changed.</div><br/><div id="35959089" class="c"><input type="checkbox" id="c-35959089" checked=""/><div class="controls bullet"><span class="by">cannam</span><span>|</span><a href="#35958507">root</a><span>|</span><a href="#35958570">parent</a><span>|</span><a href="#35958618">next</a><span>|</span><label class="collapse" for="c-35959089">[-]</label><label class="expand" for="c-35959089">[1 more]</label></div><br/><div class="children"><div class="content">With CPU, totally.<p>As an example I can look at my own Sonic Visualiser application, largely written 15-18 years ago and entirely CPU-driven. It&#x27;s <i>horrible</i> on contemporary Macs for example and feels far slower than it did a decade ago. It just isn&#x27;t what the hardware expects.<p>(There may be an element of toolkit-platform impedance and simple poor design on my part - it uses Qt and feels quicker on other platforms - and I don&#x27;t want to argue the details here, but I think the basic principle that you really want to avoid CPU in the frame update is sound. Preparing things on a non-time-critical path via CPU should be another matter however, there&#x27;s quite a lot of capacity there.)</div><br/></div></div></div></div><div id="35958618" class="c"><input type="checkbox" id="c-35958618" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#35958507">parent</a><span>|</span><a href="#35958570">prev</a><span>|</span><a href="#35958769">next</a><span>|</span><label class="collapse" for="c-35958618">[-]</label><label class="expand" for="c-35958618">[1 more]</label></div><br/><div class="children"><div class="content">&gt; for building a UI I would actually personally choose something JavaScript-based<p>The author does address this at [0]. Their main arguments are that web-based stuff is slow and requires lots of memory, especially when making something which runs outside a web browser.<p>[0] <a href="https:&#x2F;&#x2F;billydm.github.io&#x2F;blog&#x2F;daw-frontend-development-struggles&#x2F;#the-web-based-toolkits" rel="nofollow">https:&#x2F;&#x2F;billydm.github.io&#x2F;blog&#x2F;daw-frontend-development-stru...</a></div><br/></div></div><div id="35958769" class="c"><input type="checkbox" id="c-35958769" checked=""/><div class="controls bullet"><span class="by">ricardobayes</span><span>|</span><a href="#35958507">parent</a><span>|</span><a href="#35958618">prev</a><span>|</span><a href="#35958064">next</a><span>|</span><label class="collapse" for="c-35958769">[-]</label><label class="expand" for="c-35958769">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d think C++ and imgUI would be a good fit for this work but many other approaches could work fine.</div><br/></div></div></div></div><div id="35958064" class="c"><input type="checkbox" id="c-35958064" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#35958507">prev</a><span>|</span><a href="#35958887">next</a><span>|</span><label class="collapse" for="c-35958064">[-]</label><label class="expand" for="c-35958064">[7 more]</label></div><br/><div class="children"><div class="content">What we need is a AAA game where the main character fiddles around on an in-game DAW in some abandoned recording studio to unlock a cool zombie-blasting weapon. That will guarantee that any widget redrawing therein happens as efficiently and responsive as possible.<p>Maybe put it in the first level so that audio engineers can easily get to it and just hang out in that part of the game to do their work, glitch free.</div><br/><div id="35958435" class="c"><input type="checkbox" id="c-35958435" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#35958064">parent</a><span>|</span><a href="#35958323">next</a><span>|</span><label class="collapse" for="c-35958435">[-]</label><label class="expand" for="c-35958435">[5 more]</label></div><br/><div class="children"><div class="content">I do feel like there should be more crossover between video game &amp; GUI development; most game engines are crossplatform nowadays, GUIs in games are nothing new (and probably reinvented all the time), and everything is GPU rendered already.<p>I&#x27;ve yet to see any desktop app that isn&#x27;t a video game built in e.g. Unreal or Unity.<p>I did see a colleague build a website widget (iirc it was about placing furniture or a TV in a living room to see what it looks like) using Unity though, that was pretty cool.</div><br/><div id="35959219" class="c"><input type="checkbox" id="c-35959219" checked=""/><div class="controls bullet"><span class="by">SSLy</span><span>|</span><a href="#35958064">root</a><span>|</span><a href="#35958435">parent</a><span>|</span><a href="#35958830">next</a><span>|</span><label class="collapse" for="c-35959219">[-]</label><label class="expand" for="c-35959219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;ve yet to see any desktop app that isn&#x27;t a video game built in e.g. Unreal or Unity.</i><p><a href="https:&#x2F;&#x2F;arkenforge.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arkenforge.com&#x2F;</a></div><br/></div></div><div id="35958830" class="c"><input type="checkbox" id="c-35958830" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#35958064">root</a><span>|</span><a href="#35958435">parent</a><span>|</span><a href="#35959219">prev</a><span>|</span><a href="#35958701">next</a><span>|</span><label class="collapse" for="c-35958830">[-]</label><label class="expand" for="c-35958830">[1 more]</label></div><br/><div class="children"><div class="content">Because Unity&#x27;s UI old system (ugui) is actually not that good? From my experience using web+Electron is just so, so much easier.<p>By the way, SimCity&#x27;s UI is done by a custom version of WebKit. <a href="https:&#x2F;&#x2F;twitter.com&#x2F;MaxisScott&#x2F;status&#x2F;310835756107177984" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;MaxisScott&#x2F;status&#x2F;310835756107177984</a></div><br/></div></div><div id="35958701" class="c"><input type="checkbox" id="c-35958701" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#35958064">root</a><span>|</span><a href="#35958435">parent</a><span>|</span><a href="#35958830">prev</a><span>|</span><a href="#35958323">next</a><span>|</span><label class="collapse" for="c-35958701">[-]</label><label class="expand" for="c-35958701">[2 more]</label></div><br/><div class="children"><div class="content">I have seen a handful of desktop software apps built in Godot over the years. For example, <a href="https:&#x2F;&#x2F;bauxite.itch.io&#x2F;bitmapflow" rel="nofollow">https:&#x2F;&#x2F;bauxite.itch.io&#x2F;bitmapflow</a> is an app which I&#x27;ve gotten value out of built in Godot.</div><br/><div id="35958907" class="c"><input type="checkbox" id="c-35958907" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#35958064">root</a><span>|</span><a href="#35958701">parent</a><span>|</span><a href="#35958323">next</a><span>|</span><label class="collapse" for="c-35958907">[-]</label><label class="expand" for="c-35958907">[1 more]</label></div><br/><div class="children"><div class="content">My favorite Godot app is Material Maker (<a href="https:&#x2F;&#x2F;www.materialmaker.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.materialmaker.org&#x2F;</a>). I downloaded it when Substance Designer was acquired by Adoboe. I&#x27;d say it actually has better usability than Designer.</div><br/></div></div></div></div></div></div><div id="35958323" class="c"><input type="checkbox" id="c-35958323" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#35958064">parent</a><span>|</span><a href="#35958435">prev</a><span>|</span><a href="#35958887">next</a><span>|</span><label class="collapse" for="c-35958323">[-]</label><label class="expand" for="c-35958323">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;243220&#x2F;FRACT_OSC&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;243220&#x2F;FRACT_OSC&#x2F;</a></div><br/></div></div></div></div><div id="35958887" class="c"><input type="checkbox" id="c-35958887" checked=""/><div class="controls bullet"><span class="by">squarefoot</span><span>|</span><a href="#35958064">prev</a><span>|</span><a href="#35958993">next</a><span>|</span><label class="collapse" for="c-35958887">[-]</label><label class="expand" for="c-35958887">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t recommend a toolkit or a set of widgets because ages ago I came to the conclusion that there&#x27;s no way to use traditional ones for a good DAW interface, and something very specific to the task should be developed, which is a pain in the ass.
For spectrograms, I could suggest a look at Jaaa&#x27;s source. It draws directly using wrappers on X11 libraries and it&#x27;s fast and efficient also on low end hardware.<p><a href="https:&#x2F;&#x2F;wiki.linuxaudio.org&#x2F;apps&#x2F;all&#x2F;jaaa" rel="nofollow">https:&#x2F;&#x2F;wiki.linuxaudio.org&#x2F;apps&#x2F;all&#x2F;jaaa</a><p><a href="http:&#x2F;&#x2F;kokkinizita.linuxaudio.org&#x2F;linuxaudio&#x2F;" rel="nofollow">http:&#x2F;&#x2F;kokkinizita.linuxaudio.org&#x2F;linuxaudio&#x2F;</a></div><br/></div></div><div id="35958993" class="c"><input type="checkbox" id="c-35958993" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#35958887">prev</a><span>|</span><a href="#35958624">next</a><span>|</span><label class="collapse" for="c-35958993">[-]</label><label class="expand" for="c-35958993">[1 more]</label></div><br/><div class="children"><div class="content">After decades of development the GUI space feels more chaotic than ever. There are several dimensions that can become critical bottleneck in advanced use cases (performance, platform independence, ease of development, library&#x2F;tool availability and maturity etc) and - as this post highlights quite clearly - it is non-trivial to chart a path.<p>Some of the difficulty is definitely intrinsic to the problem space. Nobody said that arbitrary complex interfaces have a license to run at lightning speeds with minimal coding on arbitrary and&#x2F;or minimal hardware.<p>But I do have the feeling that in part the difficulty is because the different approaches (both historical and current) have been effectively islands, self-contained with no standardization or separation of concerns. E.g. I would at least hope that we would by now have an accepted universal way to <i>describe</i> GUI&#x27;s (declarative). I think this might be one reason for the popularity of web based approaches: while html&#x2F;css was made for documents not GUI&#x27;s, it is at least something everybody agrees on.</div><br/></div></div><div id="35958624" class="c"><input type="checkbox" id="c-35958624" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#35958993">prev</a><span>|</span><a href="#35958372">next</a><span>|</span><label class="collapse" for="c-35958624">[-]</label><label class="expand" for="c-35958624">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Ideally I want to support loading user-generated themes.<p>I <i>really</i> hope this just means &quot;alternative colour palettes&quot;. Otherwise they&#x27;re about to make one of the hardest UI programming tasks I can imagine exponentially harder.<p>I&#x27;ve never understood the passion for themeability. It&#x27;s like going into a restaurant and expecting to participate in the cooking of your meal.<p>As much nostalgia as I have for the heyday of Winamp skins, most of them were awful and had terrible usability. It was a garish novelty akin to &quot;Pimp My Ride&quot;</div><br/><div id="35959105" class="c"><input type="checkbox" id="c-35959105" checked=""/><div class="controls bullet"><span class="by">dagw</span><span>|</span><a href="#35958624">parent</a><span>|</span><a href="#35958724">next</a><span>|</span><label class="collapse" for="c-35959105">[-]</label><label class="expand" for="c-35959105">[1 more]</label></div><br/><div class="children"><div class="content"><i>It&#x27;s like going into a restaurant and expecting to participate in the cooking of your meal.</i><p>Lots of people expect and do this all the time. I want this cooked like this, no this, this replaced with that etc. Hell, some restaurants just put out all the food they have on a big table and say &quot;go ahead and put together your own meal with whatever you want, we don&#x27;t care&quot;, and that is many peoples favourite restaurant experience.</div><br/></div></div><div id="35958724" class="c"><input type="checkbox" id="c-35958724" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#35958624">parent</a><span>|</span><a href="#35959105">prev</a><span>|</span><a href="#35958372">next</a><span>|</span><label class="collapse" for="c-35958724">[-]</label><label class="expand" for="c-35958724">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree. I&#x27;d even go so far as to say that beyond pure accessibility and compat concerns (color blind modes or high contrast erc) even that is going too far with customization.</div><br/></div></div></div></div><div id="35958372" class="c"><input type="checkbox" id="c-35958372" checked=""/><div class="controls bullet"><span class="by">franky47</span><span>|</span><a href="#35958624">prev</a><span>|</span><a href="#35958470">next</a><span>|</span><label class="collapse" for="c-35958372">[-]</label><label class="expand" for="c-35958372">[1 more]</label></div><br/><div class="children"><div class="content">I worked in that field for 8 years for a somewhat known plugin editor. We used JUCE a lot at the beginning, but ended up slowly moving to an OpenGL-backed renderer for performance-critical parts (eg: VU meters and other audio-to-UI feedback), and JUCE for the rest of UI scaffolding (layout, controls, menus etc).<p>Same thing went for the other parts of a plugin architecture: we wrote our own VST&#x2F;AU&#x2F;AAX interfaces with the DAW to overcome some of the issues we encountered with JUCE.<p>After I left the company, my former teammates rewrote the whole UI framework to a pure OpenGL implementation. I&#x27;m not sure if there&#x27;s even a drop of JUCE in the codebase anymore.<p>Note: this was before the PACE acquisition (though we had good contacts with the PACE team, their founders being brilliant engineers).<p>So my advice to people starting in this field: use whatever is available now, JUCE is a treasure trove for beginners, then slowly optimise where needed.</div><br/></div></div><div id="35958470" class="c"><input type="checkbox" id="c-35958470" checked=""/><div class="controls bullet"><span class="by">zorr</span><span>|</span><a href="#35958372">prev</a><span>|</span><a href="#35958051">next</a><span>|</span><label class="collapse" for="c-35958470">[-]</label><label class="expand" for="c-35958470">[2 more]</label></div><br/><div class="children"><div class="content">I have a feeling desktop development is going to slowly revert back to classic OOP paradigms just like the web world detoured from MPA -&gt; SPA -&gt; SPA+SSR -&gt; back to something that looks a lot like MPA again.<p>Classic toolkits like GTK, Qt, UIKit&#x2F;AppKit, Swing and JavaFX use OOP to solve some of the problems this article talks about.<p>However, this OOP model seems to be somewhat incompatible with Rust&#x27;s strict memory safety rules. At least I think it is because I haven&#x27;t seen any big efforts for a Rust OOP toolkit like this. Most of the existing Rust toolkits are immediate mode or ECS or something &quot;reactive&quot; that looks like React.<p>While I understand the idea of moving away from &quot;unsafe&quot; languages like C&#x2F;C++ to something like Rust, I wonder if Rust is the right language for building UI applications? Maybe a better architecture is to use Rust for the core logic as a library to be consumed by a higher level language that meshes well with these OOP widget tree and event handling paradigms.</div><br/><div id="35958508" class="c"><input type="checkbox" id="c-35958508" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#35958470">parent</a><span>|</span><a href="#35958051">next</a><span>|</span><label class="collapse" for="c-35958508">[-]</label><label class="expand" for="c-35958508">[1 more]</label></div><br/><div class="children"><div class="content">I think we need other UI models instead of everything mature being object-oriented-oriented. Doing UI work in FP (or FRP) is great in many aspects until you need to integrate with these OO models like the DOM, et.al. Direct integration or a first-class VDOM-like model would be a nice step. There’s a tangent issue with all of popular game engines built around objects.</div><br/></div></div></div></div><div id="35958051" class="c"><input type="checkbox" id="c-35958051" checked=""/><div class="controls bullet"><span class="by">lagniappe</span><span>|</span><a href="#35958470">prev</a><span>|</span><a href="#35957979">next</a><span>|</span><label class="collapse" for="c-35958051">[-]</label><label class="expand" for="c-35958051">[1 more]</label></div><br/><div class="children"><div class="content">oh hey this is a topic i know of somewhat by chance :) i recently challenged myself to make a daw in the fewest lines of code and i came up with a cli based tracker that essentially does this:<p>- load track.csv<p>- each column corresponds to 1.wav, 2.wav, 3.wav, 4.wav etc<p>- for each line, parse the cell of each column for characteristics and play the sound according to those characteristics (i just did on&#x2F;off with an x, but you could do volume or duration)<p>- delay before the next line for BPM<p>what i ended up was a fun little toy csv-tracker. i was convinced it would be too stupid to be fun beyond the task of making it, but as soon as i saw the &#x27;notes&#x27; scrolling line by line.. ooo-weeee what a rush of nostalgia 10&#x2F;10 would recommend as a fun exercise.<p>Edit:  to actually respond to the article though, because this sounded a bit like storytime, since the author was asking (possibly rhetorically), i think the author -should- stick with Rust. im not saying this due to any fanboy tendencies, 90%+ of what i write is in Go, including the tracker I mentioned above.<p>what makes me say that Rust is a good fit is because though it is difficult to produce code at a high velocity and with more simplicity in Rust, audio is one of the problem domains where realtime computation is a must, and Rust as compared to Go for example would excel in capable hands due to the way Rust manages resources and leans more toward realtime tasks. We&#x27;re really splitting hairs here, but be that as it may, i know that it wouldn&#x27;t take long to be thinking about tweaking the GC if i were doing a &#x27;serious&#x27; daw in Go.<p>evidently i was not the first with this idea <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=RFdCM2kHL64">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=RFdCM2kHL64</a></div><br/></div></div><div id="35957979" class="c"><input type="checkbox" id="c-35957979" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#35958051">prev</a><span>|</span><a href="#35958145">next</a><span>|</span><label class="collapse" for="c-35957979">[-]</label><label class="expand" for="c-35957979">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s weird that the article mentions Makepad, but somehow fails to observe that Makepad&#x27;s primary demo application is actually a software synthesizer. Go watch some of Rik Arends&#x27; talks! Most recently this one from RustNL last week: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=9Q4yNlbfiYk">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=9Q4yNlbfiYk</a> (first talk of the day).</div><br/></div></div><div id="35958145" class="c"><input type="checkbox" id="c-35958145" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#35957979">prev</a><span>|</span><a href="#35958651">next</a><span>|</span><label class="collapse" for="c-35958145">[-]</label><label class="expand" for="c-35958145">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of funny how the author dismisses web technologies while complaining about redundant rerenders in Rust GUI libraries. This is all solved in browsers, both on the rendering engine and on the web framework library levels.<p>Yes you need to pay attention to performance, but the premise that &quot;web is slow&quot; has been disproven so many times already. Just because it&#x27;s really easy to write apps that are slow (and thus these apps being ubiquitous) doesn&#x27;t mean that you can&#x27;t write performant apps if you are so motivated.</div><br/><div id="35958274" class="c"><input type="checkbox" id="c-35958274" checked=""/><div class="controls bullet"><span class="by">usernew</span><span>|</span><a href="#35958145">parent</a><span>|</span><a href="#35958218">next</a><span>|</span><label class="collapse" for="c-35958274">[-]</label><label class="expand" for="c-35958274">[3 more]</label></div><br/><div class="children"><div class="content">Alright, here&#x27;s I want you to do.  It&#x27;ll be interesting and fun, you&#x27;ll make something cool, it&#x27;s free, and then you&#x27;ll come back and look at your comment and reply with a &quot;&#x2F;s.&quot;<p>Download pirated copies of protools and melodyne, and a bunch of virtual instrument libraries from torrents.  Download a midi file for a song you like, dump it into protools.  Record yourself singing, right on the PC or headset mic - no need to hit the right notes.  Dump the voice instrument and your voice recording into Melodyne and drag the voice to match the notes on the voalc tone track.  Now set up a link from your Melodyne track into a protools track.<p>Then go wild, play around, apply filters, do fun stuff.  You might get stuck in the fun for a week and it&#x27;ll keep you awake late.<p>Once you&#x27;re done, think about doing all that on a web page or a web page pretending to be a local app.  Then reread your comment.<p>Oh by the way, you will need to install a new raw driver for your soundcard.  You see, something like a 5ms audio latency you get from you normal windows sound driver, is too slow.  Give some thought on how slow doing anything in JS is going to be, if a native hardware driver is too slow.</div><br/><div id="35958849" class="c"><input type="checkbox" id="c-35958849" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958274">parent</a><span>|</span><a href="#35958434">next</a><span>|</span><label class="collapse" for="c-35958849">[-]</label><label class="expand" for="c-35958849">[1 more]</label></div><br/><div class="children"><div class="content">Until last year, I worked on a team that built an electron app for video conferencing with a double digit million user base. We did audio processing (mixing, RNN noise reduction) via WebAudio in WASM. This is in production right now as far as I know and adds very little latency.<p>That being said, this is about GUI. No reason not to do as much native processing as your heart desires outside of your GUI layer.</div><br/></div></div></div></div><div id="35958218" class="c"><input type="checkbox" id="c-35958218" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#35958145">parent</a><span>|</span><a href="#35958274">prev</a><span>|</span><a href="#35958178">next</a><span>|</span><label class="collapse" for="c-35958218">[-]</label><label class="expand" for="c-35958218">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but the premise that &quot;web is slow&quot; has been disproven so many times already.<p>No it is not. Though it seems proven that even with very powerful hardware users in general have been pushed to minimal expectations. So GUIs that take seconds to start or respond on multi Ghz processors and multi GB RAMs are considered <i>fast</i> now.<p>This argument is <i>web GUI is fast</i> is more of &quot;It&#x27;s been proven multiple times meal kits are cheaper than buying groceries from store&quot;. Yeah, someone can find really cheap meal kits if they spend many hours on hunting a deal. But in general case grocery in store is plain cheaper for most of reasonable shoppers.</div><br/><div id="35958908" class="c"><input type="checkbox" id="c-35958908" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958218">parent</a><span>|</span><a href="#35958522">next</a><span>|</span><label class="collapse" for="c-35958908">[-]</label><label class="expand" for="c-35958908">[1 more]</label></div><br/><div class="children"><div class="content">Define fast. Do you care about frame rates? input latency? startup times? memory usage?<p>There are trade offs, but if you care about high frame rates and low  input latency, web apps can totally deliver that.<p>Look at <a href="https:&#x2F;&#x2F;lighttracer.org&#x2F;app.html" rel="nofollow">https:&#x2F;&#x2F;lighttracer.org&#x2F;app.html</a>, for example.</div><br/></div></div></div></div><div id="35958178" class="c"><input type="checkbox" id="c-35958178" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35958145">parent</a><span>|</span><a href="#35958218">prev</a><span>|</span><a href="#35958297">next</a><span>|</span><label class="collapse" for="c-35958178">[-]</label><label class="expand" for="c-35958178">[9 more]</label></div><br/><div class="children"><div class="content">The amount of effort it takes to create high-performance applications in a web environment is significant, though, and the benefits you get simply working in a faster language in a desktop environment are lost on most web developers, I think, simply because most of them don&#x27;t actually do any desktop or graphics API work.<p>They simply wouldn&#x27;t know.<p>Also UI compositors are not a solved space. If they were, people would absolutely not being using Electron. But no one is saying, &quot;Hey I have a CSS 2.1 compliant rasterizer and compositor that you can use in your C++ or Rust environment!&quot; are they?</div><br/><div id="35958558" class="c"><input type="checkbox" id="c-35958558" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958178">parent</a><span>|</span><a href="#35958211">next</a><span>|</span><label class="collapse" for="c-35958558">[-]</label><label class="expand" for="c-35958558">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>But no one is saying, &quot;Hey I have a CSS 2.1 compliant rasterizer and compositor that you can use in your C++ or Rust environment!&quot; are they?</i><p>There’s actually quite a lot of interesting work going on in that general space, has been in various forms for some years. A couple that immediately spring to mind:<p>• Azul &lt;<a href="https:&#x2F;&#x2F;azul.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;azul.rs&#x2F;</a>&gt; builds on WebRender, as used in Firefox. I haven’t looked at it for a few years, but it looks to have grown quite interesting now.<p>• Blitz &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;DioxusLabs&#x2F;blitz">https:&#x2F;&#x2F;github.com&#x2F;DioxusLabs&#x2F;blitz</a>&gt; is based on from-scratch implementations of CSS layout and rendering, and wgpu rendering. It’s not usable yet, but is a very interesting concept. If one happens to be familiar with React Native: it’s kinda like that, or React Native Web.</div><br/><div id="35958799" class="c"><input type="checkbox" id="c-35958799" checked=""/><div class="controls bullet"><span class="by">ricardobayes</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958558">parent</a><span>|</span><a href="#35958211">next</a><span>|</span><label class="collapse" for="c-35958799">[-]</label><label class="expand" for="c-35958799">[2 more]</label></div><br/><div class="children"><div class="content">React Native Web is a bit like scratching your left ear with your right arm :)</div><br/><div id="35958903" class="c"><input type="checkbox" id="c-35958903" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958799">parent</a><span>|</span><a href="#35958211">next</a><span>|</span><label class="collapse" for="c-35958903">[-]</label><label class="expand" for="c-35958903">[1 more]</label></div><br/><div class="children"><div class="content">Actually, forget the React Native Web thing, I think I was mixing it up with something from a few years back that was more the other way round (running React web stuff on React Native, not running React Native on web).<p>React Native Web… eh, it has a potential place. Maybe like scratching your left ear with your right arm, because your left arm is partially paralysed, or something!</div><br/></div></div></div></div></div></div><div id="35958211" class="c"><input type="checkbox" id="c-35958211" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958178">parent</a><span>|</span><a href="#35958558">prev</a><span>|</span><a href="#35958198">next</a><span>|</span><label class="collapse" for="c-35958211">[-]</label><label class="expand" for="c-35958211">[1 more]</label></div><br/><div class="children"><div class="content">Right. The point of wanting to avoid redraws is for performance. Sure, you avoid redundant redraws in web browsers, but it defeats the point because the browser is slow compared to native, even with those avoided redraws.</div><br/></div></div><div id="35958198" class="c"><input type="checkbox" id="c-35958198" checked=""/><div class="controls bullet"><span class="by">rahkiin</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958178">parent</a><span>|</span><a href="#35958211">prev</a><span>|</span><a href="#35958321">next</a><span>|</span><label class="collapse" for="c-35958198">[-]</label><label class="expand" for="c-35958198">[3 more]</label></div><br/><div class="children"><div class="content">Please, if someone has just that, let me know. It would be excellent for games.
I do believe there are implementations of flexbox in rust.</div><br/><div id="35958217" class="c"><input type="checkbox" id="c-35958217" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958198">parent</a><span>|</span><a href="#35958404">next</a><span>|</span><label class="collapse" for="c-35958217">[-]</label><label class="expand" for="c-35958217">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s a problem space I&#x27;d like to try to tackle again some day. Yoga et al. aren&#x27;t enough.<p>I think people are dying for a web-based compositor in other host language environments, but don&#x27;t know how to elucidate this concept because they don&#x27;t know anything else.</div><br/></div></div></div></div></div></div><div id="35958297" class="c"><input type="checkbox" id="c-35958297" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#35958145">parent</a><span>|</span><a href="#35958178">prev</a><span>|</span><a href="#35958651">next</a><span>|</span><label class="collapse" for="c-35958297">[-]</label><label class="expand" for="c-35958297">[3 more]</label></div><br/><div class="children"><div class="content">Yeah. The OP should spend a day or two making HTML5 prototypes for the key aspects and see if it&#x27;s really true that it&#x27;s &quot;slow&quot;.<p>The UI is not the hot code, it&#x27;s the audio mixing.  So long as the audio mising is faultless, it doesn&#x27;t matter too much if it takes an extra video frame to update the dB display.<p>Because there are thousands of people working to maintain the code in the browser stack every day that are on his side then.</div><br/><div id="35958620" class="c"><input type="checkbox" id="c-35958620" checked=""/><div class="controls bullet"><span class="by">richrichardsson</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958297">parent</a><span>|</span><a href="#35958651">next</a><span>|</span><label class="collapse" for="c-35958620">[-]</label><label class="expand" for="c-35958620">[2 more]</label></div><br/><div class="children"><div class="content">I can assure you that users complain when the GUIs of DAWs start to run below 30fps, and really the expectation these days is that &quot;performant&quot; GUIs run at 60fps.</div><br/><div id="35959113" class="c"><input type="checkbox" id="c-35959113" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#35958145">root</a><span>|</span><a href="#35958620">parent</a><span>|</span><a href="#35958651">next</a><span>|</span><label class="collapse" for="c-35959113">[-]</label><label class="expand" for="c-35959113">[1 more]</label></div><br/><div class="children"><div class="content">I am suggesting confirming if it is actually &quot;slow&quot; for the &quot;key aspects&quot;.<p>You and the OP are just assuming it can&#x27;t do whatever it is at &quot;30fps&quot;... if you&#x27;re right, it will only take ten minutes if it&#x27;s so bad, or an hour or two if it&#x27;s subtle, to actually confirm whatever the worst thing is.<p>The &quot;extra frame&quot; I was thinking of is graphics pipeline latency, not redraw time.</div><br/></div></div></div></div></div></div></div></div><div id="35958651" class="c"><input type="checkbox" id="c-35958651" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#35958145">prev</a><span>|</span><a href="#35958029">next</a><span>|</span><label class="collapse" for="c-35958651">[-]</label><label class="expand" for="c-35958651">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know much (or anything, really) about DAW development, but as a Reaper user I know you can make a cross-platform DAW that performs extremely well on very little ressources, including displaying many instances of all the things the author is talking about (spectrograms, audio files, zoomable midi clips, etc.) in real time, on a Raspberry Pi, while playing audio and driving physical synthesis plugins.</div><br/></div></div><div id="35958029" class="c"><input type="checkbox" id="c-35958029" checked=""/><div class="controls bullet"><span class="by">chaosprint</span><span>|</span><a href="#35958651">prev</a><span>|</span><a href="#35958986">next</a><span>|</span><label class="collapse" for="c-35958029">[-]</label><label class="expand" for="c-35958029">[3 more]</label></div><br/><div class="children"><div class="content">DAW is so challeging! But in terms of audio effect plugins, I think EGUI is usable already. Here is a Dattorro reverb VST plugin written in Rust with egui and glicol_synth:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;DLFO4dXzKsg" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;DLFO4dXzKsg</a><p>Since EGUI can be used almost every where, I also made an experimental front end for Glicol music language with EGUI: <a href="https:&#x2F;&#x2F;glicol-egui.netlify.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;glicol-egui.netlify.app&#x2F;</a><p>There are many features missing, compared with HTML&#x2F;CSS: <a href="https:&#x2F;&#x2F;glicol.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;glicol.org&#x2F;</a><p>The biggest issue with EGUI is that the style seems to be quite fixed. The default style looks great for some customisation would be more ideal in some context.<p>although we are not there yet, it&#x27;s great to see more and more attempts for audio &#x2F;gui in rust. And I really feel that Rust is the best choice for the audio backend now.</div><br/><div id="35958047" class="c"><input type="checkbox" id="c-35958047" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35958029">parent</a><span>|</span><a href="#35958514">next</a><span>|</span><label class="collapse" for="c-35958047">[-]</label><label class="expand" for="c-35958047">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can meaningfully use immediate-mode GUIs for anything related to compositing work.<p>If you&#x27;re creating debug UIs or basic UIs at best, you&#x27;re fine. That might actually work out alright for DAWs, but if you want sophisticated user-interfaces where you can add effects to things, you need to start retaining graphics data, and so many people advocating for these old school immediate-mode GUI libraries just don&#x27;t get that.</div><br/></div></div><div id="35958514" class="c"><input type="checkbox" id="c-35958514" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#35958029">parent</a><span>|</span><a href="#35958047">prev</a><span>|</span><a href="#35958986">next</a><span>|</span><label class="collapse" for="c-35958514">[-]</label><label class="expand" for="c-35958514">[1 more]</label></div><br/><div class="children"><div class="content">Not beautiful. That is not something that makes you want to use egui.<p>(My plugins: <a href="https:&#x2F;&#x2F;github.com&#x2F;rerdavies&#x2F;ToobAmp">https:&#x2F;&#x2F;github.com&#x2F;rerdavies&#x2F;ToobAmp</a> using a web interface; I&#x27;m currently weighing options for GUI backend for a Linux native interface. LV2 plugins infamously cannot use GTK or QT). Current leading choices: cairo2, or embedding a browser control.</div><br/></div></div></div></div><div id="35958986" class="c"><input type="checkbox" id="c-35958986" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#35958029">prev</a><span>|</span><a href="#35957905">next</a><span>|</span><label class="collapse" for="c-35958986">[-]</label><label class="expand" for="c-35958986">[1 more]</label></div><br/><div class="children"><div class="content">For the relative mouse movements, can&#x27;t you just move the (hidden) mouse pointer to the centre of the screen every time you get a movement event?  It will be very hard to hit the edge that way.</div><br/></div></div><div id="35957905" class="c"><input type="checkbox" id="c-35957905" checked=""/><div class="controls bullet"><span class="by">porkbeer</span><span>|</span><a href="#35958986">prev</a><span>|</span><a href="#35958439">next</a><span>|</span><label class="collapse" for="c-35957905">[-]</label><label class="expand" for="c-35957905">[8 more]</label></div><br/><div class="children"><div class="content">Its weird to see the impressions of someone who has apparently never used the equipment used in music production trying to talk intelligently about said devices. So many incorrect assumptions its really painful to read as someone aquainted with audio engineering. Interesting window into how the devs see it nonetheless.</div><br/><div id="35957959" class="c"><input type="checkbox" id="c-35957959" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#35957905">parent</a><span>|</span><a href="#35958026">next</a><span>|</span><label class="collapse" for="c-35957959">[-]</label><label class="expand" for="c-35957959">[1 more]</label></div><br/><div class="children"><div class="content">You should comment on the specific issues you see in the article.</div><br/></div></div><div id="35958026" class="c"><input type="checkbox" id="c-35958026" checked=""/><div class="controls bullet"><span class="by">astroalex</span><span>|</span><a href="#35957905">parent</a><span>|</span><a href="#35957959">prev</a><span>|</span><a href="#35958085">next</a><span>|</span><label class="collapse" for="c-35958026">[-]</label><label class="expand" for="c-35958026">[1 more]</label></div><br/><div class="children"><div class="content">Huh? The author wasn’t talking about audio engineering, so I don’t see how that is relevant. The GUI programming issues they’re discussing would be true for any realtime application. The fact they are building a DAW is a bit beside the point otherwise.</div><br/></div></div><div id="35958085" class="c"><input type="checkbox" id="c-35958085" checked=""/><div class="controls bullet"><span class="by">unboxingelf</span><span>|</span><a href="#35957905">parent</a><span>|</span><a href="#35958026">prev</a><span>|</span><a href="#35958032">next</a><span>|</span><label class="collapse" for="c-35958085">[-]</label><label class="expand" for="c-35958085">[3 more]</label></div><br/><div class="children"><div class="content">the comments about the layout of “mixing tracks” not following design guidelines or being a standard list&#x2F;tree&#x2F;etc struck me.<p>in traditional audio engineering we call them channel strips and their layout reflects the signal flow - eq knobs are typically at the top, followed by compression, fx, and so on.</div><br/><div id="35958277" class="c"><input type="checkbox" id="c-35958277" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#35957905">root</a><span>|</span><a href="#35958085">parent</a><span>|</span><a href="#35958117">next</a><span>|</span><label class="collapse" for="c-35958277">[-]</label><label class="expand" for="c-35958277">[1 more]</label></div><br/><div class="children"><div class="content">Naming conventions are a mixed bag (hehe) in DAWs, since not everyone who dabbles in them is an audio engineer by trade.<p>- Ableton calls them &quot;mixer controls&quot;: <a href="https:&#x2F;&#x2F;www.ableton.com&#x2F;en&#x2F;manual&#x2F;mixing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ableton.com&#x2F;en&#x2F;manual&#x2F;mixing&#x2F;</a><p>- Bitwig&#x27;s manual does mention channel strips: <a href="https:&#x2F;&#x2F;www.bitwig.com&#x2F;userguide&#x2F;latest&#x2F;the_mix_view&#x2F;#channel_strip_section" rel="nofollow">https:&#x2F;&#x2F;www.bitwig.com&#x2F;userguide&#x2F;latest&#x2F;the_mix_view&#x2F;#channe...</a><p>- Adobe Audition has &quot;track controls&quot;: <a href="https:&#x2F;&#x2F;helpx.adobe.com&#x2F;audition&#x2F;using&#x2F;multitrack-editor-overview.html#editing_multitrack_sessions_in_the_editor_panel_and_mixer" rel="nofollow">https:&#x2F;&#x2F;helpx.adobe.com&#x2F;audition&#x2F;using&#x2F;multitrack-editor-ove...</a><p>- Ardour... probably has mixing board tape and felt pen marker emulation as well, I&#x27;m late and couldn&#x27;t be bothered to look up its manual.</div><br/></div></div><div id="35958117" class="c"><input type="checkbox" id="c-35958117" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#35957905">root</a><span>|</span><a href="#35958085">parent</a><span>|</span><a href="#35958277">prev</a><span>|</span><a href="#35958032">next</a><span>|</span><label class="collapse" for="c-35958117">[-]</label><label class="expand" for="c-35958117">[1 more]</label></div><br/><div class="children"><div class="content">I think he meant that they don’t follow typical design guidelines <i>for graphical user interfaces on a computer</i>. Which they don’t — outside DAWs (and maybe some image editors?), I’ve never seen a GUI arranged like a channel strip, where controls are stacked on top of each other but not necessarily arranged in a perfect grid. A set of controls like e.g. [0] in Ableton is highly non-standard, compared to the kinds of layouts most GUI toolkits provide.<p>[0] <a href="https:&#x2F;&#x2F;rekkerd.org&#x2F;img&#x2F;201210&#x2F;ableton_live9.png" rel="nofollow">https:&#x2F;&#x2F;rekkerd.org&#x2F;img&#x2F;201210&#x2F;ableton_live9.png</a></div><br/></div></div></div></div><div id="35958032" class="c"><input type="checkbox" id="c-35958032" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#35957905">parent</a><span>|</span><a href="#35958085">prev</a><span>|</span><a href="#35958439">next</a><span>|</span><label class="collapse" for="c-35958032">[-]</label><label class="expand" for="c-35958032">[2 more]</label></div><br/><div class="children"><div class="content">It seems like the level of experience of the average poster here has been decreasing steadily over time.</div><br/><div id="35958694" class="c"><input type="checkbox" id="c-35958694" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#35957905">root</a><span>|</span><a href="#35958032">parent</a><span>|</span><a href="#35958439">next</a><span>|</span><label class="collapse" for="c-35958694">[-]</label><label class="expand" for="c-35958694">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure there&#x27;s a clever term for it, but a lot of developers (and this is probably a timeless thing) think they can dive into any industry and make a difference, or see things from a different point of view and therefore better.<p>I mean it has a basis in reality, loads of people here will have joined companies that were years behind, companies in new industries. Myself I&#x27;ve gone from cable TV to investment banking to public transit to B2B e-commerce to telcoms to the energy industry, but nowhere did I assume to think I knew better. Not when it came to their main industry anyway, software development and practices, sure, that&#x27;s kind of my jam.<p>When it comes down to it, every job is just data in, data out, localization and date &#x2F; number formatting. And trying to get my colleagues to not overcomplicate things, like come on, it&#x27;s just a simple list view, if you&#x27;re bored by that you&#x27;re on the wrong assignment.</div><br/></div></div></div></div></div></div><div id="35958439" class="c"><input type="checkbox" id="c-35958439" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#35957905">prev</a><span>|</span><a href="#35959067">next</a><span>|</span><label class="collapse" for="c-35958439">[-]</label><label class="expand" for="c-35958439">[3 more]</label></div><br/><div class="children"><div class="content">I wonder (and admire) what DaVinvi Resolve is using for it&#x27;s UI.<p>It seems very polished but is also very performant and is even cross platform.</div><br/><div id="35958631" class="c"><input type="checkbox" id="c-35958631" checked=""/><div class="controls bullet"><span class="by">tayistay</span><span>|</span><a href="#35958439">parent</a><span>|</span><a href="#35959067">next</a><span>|</span><label class="collapse" for="c-35958631">[-]</label><label class="expand" for="c-35958631">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re using Qt. All the Qt libraries are there inside the app&#x27;s package on macOS.</div><br/><div id="35958690" class="c"><input type="checkbox" id="c-35958690" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#35958439">root</a><span>|</span><a href="#35958631">parent</a><span>|</span><a href="#35959067">next</a><span>|</span><label class="collapse" for="c-35958690">[-]</label><label class="expand" for="c-35958690">[1 more]</label></div><br/><div class="children"><div class="content">Amazing. Didn&#x27;t know Qt is so capable in the right hands. Doesn&#x27;t even look like typical Qt app.</div><br/></div></div></div></div></div></div><div id="35959125" class="c"><input type="checkbox" id="c-35959125" checked=""/><div class="controls bullet"><span class="by">gizajob</span><span>|</span><a href="#35959067">prev</a><span>|</span><a href="#35958676">next</a><span>|</span><label class="collapse" for="c-35959125">[-]</label><label class="expand" for="c-35959125">[1 more]</label></div><br/><div class="children"><div class="content">You could just buy Ableton for $500 and save yourself the dev hassle. It’s already a solved problem. Why reinvent the wheel?</div><br/></div></div><div id="35958676" class="c"><input type="checkbox" id="c-35958676" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#35959125">prev</a><span>|</span><a href="#35958182">next</a><span>|</span><label class="collapse" for="c-35958676">[-]</label><label class="expand" for="c-35958676">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Bitwig using a C++ backend with a Java frontend? It it were me I&#x27;d probably choose between biting the bullet and going all rust, or if I was planning on interop anyway, then go for something a bit more high level like AvaloniaUI (C#) or a thin java solution on top like Bitwig or the Jetbrains platforms.</div><br/></div></div><div id="35958182" class="c"><input type="checkbox" id="c-35958182" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#35958676">prev</a><span>|</span><a href="#35958258">next</a><span>|</span><label class="collapse" for="c-35958182">[-]</label><label class="expand" for="c-35958182">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This performance is not a problem if the app is small or the app already redraws every frame like a video game.<p>Seems to me like immediate mode UIs were dismissed rather too quickly. Why not update a DAW UI like a video game? It has similar realtime requirements.</div><br/><div id="35958738" class="c"><input type="checkbox" id="c-35958738" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#35958182">parent</a><span>|</span><a href="#35958227">next</a><span>|</span><label class="collapse" for="c-35958738">[-]</label><label class="expand" for="c-35958738">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, immediate mode seems like a perfect fit for a DAW. I see a lot of common misconceptions in the article. It seems like this is mostly an opinionated list of hypothetical issues imagined by the author, not something backed by a lot of data gathered from implementation experience.</div><br/><div id="35958918" class="c"><input type="checkbox" id="c-35958918" checked=""/><div class="controls bullet"><span class="by">lelag</span><span>|</span><a href="#35958182">root</a><span>|</span><a href="#35958738">parent</a><span>|</span><a href="#35958227">next</a><span>|</span><label class="collapse" for="c-35958918">[-]</label><label class="expand" for="c-35958918">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I also agree that the author is wrong to dismiss immediate-mode toolkits. Immediate mode would be my first choice for a DAW application. I even would say it&#x27;s almost a no-brainer as it makes so many things easier. You would need to be careful when rendering data-heavy widgets (ex: wavform) but the approach goes a long way with some careful planning even without necessarily implementing complex texture caching etc.</div><br/></div></div></div></div><div id="35958227" class="c"><input type="checkbox" id="c-35958227" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35958182">parent</a><span>|</span><a href="#35958738">prev</a><span>|</span><a href="#35958258">next</a><span>|</span><label class="collapse" for="c-35958227">[-]</label><label class="expand" for="c-35958227">[2 more]</label></div><br/><div class="children"><div class="content">Immediate mode GUIs have significant limitations. You can probably lie to your end users by saying the API is immediate mode styled, but actually retained under the hood (and I think to some degree, this already happens today with cached state), but I think that defeats the point.</div><br/><div id="35958619" class="c"><input type="checkbox" id="c-35958619" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#35958182">root</a><span>|</span><a href="#35958227">parent</a><span>|</span><a href="#35958258">next</a><span>|</span><label class="collapse" for="c-35958619">[-]</label><label class="expand" for="c-35958619">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Immediate mode&quot; is a description of the API, not the implementation. It&#x27;s not a lie to cache state under the hood. In fact it&#x27;s sensible and doesn&#x27;t defeat the point at all.</div><br/></div></div></div></div></div></div><div id="35958258" class="c"><input type="checkbox" id="c-35958258" checked=""/><div class="controls bullet"><span class="by">z3t4</span><span>|</span><a href="#35958182">prev</a><span>|</span><a href="#35958617">next</a><span>|</span><label class="collapse" for="c-35958258">[-]</label><label class="expand" for="c-35958258">[1 more]</label></div><br/><div class="children"><div class="content">You would like to use a canvas element for custom ui. A canvas is a hardware accelerated 2d library (for example Skia) where you call functions to draw lines and curves. To make a decibel gauge you would have the background face image in a buffer, then only redraw the hand line on top of it for each frame.</div><br/></div></div><div id="35957917" class="c"><input type="checkbox" id="c-35957917" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35958617">prev</a><span>|</span><a href="#35957913">next</a><span>|</span><label class="collapse" for="c-35957917">[-]</label><label class="expand" for="c-35957917">[14 more]</label></div><br/><div class="children"><div class="content">I actually know this space fairly well, probably better than most, because being an implementor of a UI compositor raises some difficult technical challenges with respect to UI tree backing layers and draw invalidation.<p>I&#x27;m still not actually sure what the state of the art on these matters is after having researched this for years, and I suspect even what we do today across software like web browsers, video game UI is wildly inefficient for modern rich user-interface requirements.<p>For instance, you could tailor GUI software to strictly draw to specific frame buffer&#x2F;backing layer regions and you could manually invalidate and redraw when the developer specified, but that&#x27;s generally far too implementation specific for most UI developers to actually follow. A master UI implementor wouldn&#x27;t have too much trouble with this, but most people don&#x27;t have a decade of graphics API level experience on top of designing world-class user-interfaces.<p>So you have some ambiguous UI tree you need to draw and redraw when things move or animate. Today&#x27;s state of the art is to multithread draw the space to tiles using virtual graphics commands that later get converted into target graphic API calls and those tiles translate to the corresponding graphics API backing layer abstraction, some sort of frame buffer.<p>When the UI tree changes state, those leaves are invalidated all the way up&#x2F;down the tree to the root at which point the compositor redraws what&#x27;s necessary and combines the layers into what gets displayed on the screen.<p>There&#x27;s a bit of work to separate disparate UI element bounds from layers which require acceleration, but those nodes are flagged for the requirement usually by explicit properties.<p>This is really complex work, and actually I think only web browsers today do it. I&#x27;m not sure even operating systems do, because usually they don&#x27;t operate with the same challenges that web browsers do where you have total UI flexibility, or as many people using the platform as web developers.<p>But it&#x27;s also the only platform that has this architecture.<p>So if you&#x27;re building desktop software, you can try to emulate this architecture and end up with some fairly good performance. Even just using nested frame buffers gets you really far. But if you&#x27;re writing front-ends on the web, you&#x27;re stuck between the browser&#x27;s compositor or rejecting it entirely and writing your own stack in a graphics layer that gets pushed to a canvas.<p>None of this is good, it&#x27;s all trade-offs, and I suspect the state of affairs will continue for years, because we don&#x27;t have enough people doing compositing work. It&#x27;s exceptionally specialized work.<p>As an addendum, the DOM isn&#x27;t slow. This is just parroting. It&#x27;s total crap. People who say this have no idea what they&#x27;re talking about. What&#x27;s slow is everything GPU related. That&#x27;s not even the CSSOM, either. It&#x27;s specifically the part where pixels get rasterized. But you don&#x27;t have lots of people who work on compositors telling you that. You have a bunch of speculators thinking the DOM is slow without actually measuring anything.<p>Painting and drawing to backing layers is super expensive. Pixel fill is expensive. Changing document subtree node properties is not.<p>You absolutely need efficient invalidation in UI drawing. I have no idea what this author is talking about.</div><br/><div id="35958004" class="c"><input type="checkbox" id="c-35958004" checked=""/><div class="controls bullet"><span class="by">audidude</span><span>|</span><a href="#35957917">parent</a><span>|</span><a href="#35958005">next</a><span>|</span><label class="collapse" for="c-35958004">[-]</label><label class="expand" for="c-35958004">[2 more]</label></div><br/><div class="children"><div class="content">GTK 4, which the author mentions in their post, uses a retained rendering model so that the UI can be rendered on GPU. Widgets snapshot render nodes which are immutable and can even be cached between frames. Those render nodes are diffed to calculate the damage region automatically.<p>That damage is then used to scissor clip in GL before the render tree is converted to shader commands. The original damage flows through to eglSwapBuffersWithDamage() to limit the screen damage to the diffed areas. Some work is needed to do tiled&#x2F;threaded processing of the render tree to reduce pathological cases instead of large scissor clips. Given how much a DAW changes per-frame when animating, it&#x27;s probably close to pathological anyway.<p>In git, there is support for something akin to swap-chains so that you can use DMA-BUF textures (or similar, such as IOSurface), and specify the damage between each buffer. This is useful for things like virtual machines or other external plumbing where you have a buffer+damage to integrate into GTK&#x27;s composition pipeline and don&#x27;t want full-frame renders to result due to gsk_render_node_diff() falling over.</div><br/><div id="35958081" class="c"><input type="checkbox" id="c-35958081" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958004">parent</a><span>|</span><a href="#35958005">next</a><span>|</span><label class="collapse" for="c-35958081">[-]</label><label class="expand" for="c-35958081">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing this. I&#x27;m not familiar with how GTK renders under the hood as compared to other pieces of software.</div><br/></div></div></div></div><div id="35958005" class="c"><input type="checkbox" id="c-35958005" checked=""/><div class="controls bullet"><span class="by">EscapeFromNY</span><span>|</span><a href="#35957917">parent</a><span>|</span><a href="#35958004">prev</a><span>|</span><a href="#35957984">next</a><span>|</span><label class="collapse" for="c-35958005">[-]</label><label class="expand" for="c-35958005">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure even operating systems do<p>Oddly enough Windows used to be a lot better at what you describe than it is (in practice) today. I&#x27;ve used old systems where it took 0.5sec to clear the screen, and you could see the color sweep down the monitor from top to bottom. Now THAT is slow. Because of that the OS used a lot of tricks to minimize drawing, such as xoring the caret, and precisely tracking dirty regions to minimize the number of pixels drawn, etc.<p>Much of that finesse has been lost in this new generation of GUIs built on 3D APIs where the entire window is thrown away and redrawn every frame.</div><br/><div id="35958015" class="c"><input type="checkbox" id="c-35958015" checked=""/><div class="controls bullet"><span class="by">audidude</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958005">parent</a><span>|</span><a href="#35958027">next</a><span>|</span><label class="collapse" for="c-35958015">[-]</label><label class="expand" for="c-35958015">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Much of that finesse has been lost in this new generation of GUIs built on 3D APIs where the entire window is thrown away and redrawn every frame.<p>GTK 4 uses eglSwapBuffersWithDamage() scissor clipped to the union of the damage rectangles. Operations falling outside that clip are culled.<p>Only the damage areas are composited, assuming a competent compositor.</div><br/></div></div><div id="35958027" class="c"><input type="checkbox" id="c-35958027" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958005">parent</a><span>|</span><a href="#35958015">prev</a><span>|</span><a href="#35958099">next</a><span>|</span><label class="collapse" for="c-35958027">[-]</label><label class="expand" for="c-35958027">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right. It used to be practice to limit your invalidation rect&#x2F;region based on known bound information. Now every developer treats their entire buffer as a cheap throwaway and they couldn&#x27;t be further from the truth.</div><br/></div></div><div id="35958099" class="c"><input type="checkbox" id="c-35958099" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958005">parent</a><span>|</span><a href="#35958027">prev</a><span>|</span><a href="#35957984">next</a><span>|</span><label class="collapse" for="c-35958099">[-]</label><label class="expand" for="c-35958099">[1 more]</label></div><br/><div class="children"><div class="content">Which is why on modern Windows one would use the compositor APIs as well, however that implies some COM fun, which could be great if WinDev wasn&#x27;t stuck in  their ways on how to provide tooling for it.</div><br/></div></div></div></div><div id="35957984" class="c"><input type="checkbox" id="c-35957984" checked=""/><div class="controls bullet"><span class="by">Zolomon</span><span>|</span><a href="#35957917">parent</a><span>|</span><a href="#35958005">prev</a><span>|</span><a href="#35958037">next</a><span>|</span><label class="collapse" for="c-35957984">[-]</label><label class="expand" for="c-35957984">[2 more]</label></div><br/><div class="children"><div class="content">From your description I think that .NET WPF[0] has the same architecture?<p>[0]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;desktop&#x2F;wpf&#x2F;overview&#x2F;?view=netdesktop-7.0" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;desktop&#x2F;wpf&#x2F;overvie...</a></div><br/><div id="35958089" class="c"><input type="checkbox" id="c-35958089" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35957984">parent</a><span>|</span><a href="#35958037">next</a><span>|</span><label class="collapse" for="c-35958089">[-]</label><label class="expand" for="c-35958089">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t doubt they do something similar, or perhaps they inherent Win32 invalidation somehow, or build on top of it.</div><br/></div></div></div></div><div id="35958037" class="c"><input type="checkbox" id="c-35958037" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#35957917">parent</a><span>|</span><a href="#35957984">prev</a><span>|</span><a href="#35957913">next</a><span>|</span><label class="collapse" for="c-35958037">[-]</label><label class="expand" for="c-35958037">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Pixel fill is expensive.<p>And how.  People don&#x27;t realize that even with modern graphics card bandwidths, windows that are a good fraction of a 4K monitor take a remarkable amount of bandwidth to clear and fill.</div><br/><div id="35958070" class="c"><input type="checkbox" id="c-35958070" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958037">parent</a><span>|</span><a href="#35958124">next</a><span>|</span><label class="collapse" for="c-35958070">[-]</label><label class="expand" for="c-35958070">[2 more]</label></div><br/><div class="children"><div class="content">Thank you! Man, if you could get people who work on UIs to write a shader once in their software career and tell them, hey how do you get a nice Gaussian blur to draw fast on a 4&#x2F;5&#x2F;8k monitor, they&#x27;ll quickly realize you need to do as little drawing as possible.</div><br/><div id="35958429" class="c"><input type="checkbox" id="c-35958429" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958070">parent</a><span>|</span><a href="#35958124">next</a><span>|</span><label class="collapse" for="c-35958429">[-]</label><label class="expand" for="c-35958429">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;d probably answer: you need to be using 2D FFT convolution. ;-P</div><br/></div></div></div></div><div id="35958124" class="c"><input type="checkbox" id="c-35958124" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958037">parent</a><span>|</span><a href="#35958070">prev</a><span>|</span><a href="#35957913">next</a><span>|</span><label class="collapse" for="c-35958124">[-]</label><label class="expand" for="c-35958124">[2 more]</label></div><br/><div class="children"><div class="content">Is there somewhere that has a good guide to understanding why this is the case? I&#x27;d love to learn more about it. I imagine there&#x27;s a lot more to it than a gpu&#x27;s pixel fill rate, which from the marketing should be sufficient but obviously from this discussion is not.</div><br/><div id="35958204" class="c"><input type="checkbox" id="c-35958204" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#35957917">root</a><span>|</span><a href="#35958124">parent</a><span>|</span><a href="#35957913">next</a><span>|</span><label class="collapse" for="c-35958204">[-]</label><label class="expand" for="c-35958204">[1 more]</label></div><br/><div class="children"><div class="content">You really don&#x27;t feel this unless you do graphics programming and then it hits you like a ton of bricks.<p>If you want a beginner&#x27;s introduction to pixel fill impact, and say, you&#x27;re a web developer, try picking up a friendly graphics framework like Phaser, LÖVE, or something comparable and writing a shader that&#x27;s applied to a fullscreen framebuffer, and measure the frametime that it takes to simply draw that as compared to a texture without a &quot;default&quot; fragment shader.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>