<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706864456339" as="style"/><link rel="stylesheet" href="styles.css?v=1706864456339"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dhwthompson.com/2019/my-favourite-git-commit">My favourite Git commit (2019)</a> <span class="domain">(<a href="https://dhwthompson.com">dhwthompson.com</a>)</span></div><div class="subtext"><span>karagenit</span> | <span>242 comments</span></div><br/><div><div id="39218538" class="c"><input type="checkbox" id="c-39218538" checked=""/><div class="controls bullet"><span class="by">schacon</span><span>|</span><a href="#39217992">next</a><span>|</span><label class="collapse" for="c-39218538">[-]</label><label class="expand" for="c-39218538">[99 more]</label></div><br/><div class="children"><div class="content">For better or worse, my experience as a GitHub cofounder and author of several Git books (Pro Git, etc) is that the Git commit message is a unique vector for code documentation that is highly sub-optimal.<p>The main issue is that most of the tooling (in Git or GitHub or whatever) generally only shows the first line. So in the case of this commit example would be the very simple message of a generic &quot;US-ASCII error&quot; problem. Everything they talk about in this article is what is great about the _rest_ of the commit message, which, given modern tools, is _almost never_ seen by anyone.<p>The main problem is that Git was built so that the commit message is the _email body_, meant to be read by everyone in the project. But for better or worse, that is not generally the role of this text today. Almost nobody ever sees it. Unless it&#x27;s discussed in a bunch of patch series over a mailing list, nobody reads anything other than the first 50 chars of the headline. It&#x27;s actively difficult to do, by nearly every tool built around the Git ecosystem.<p>Even if you&#x27;re _very good_ at Git, finding the correct invocation of &quot;git blame&quot; (is it &quot;-w -C -C -C&quot;? Or just _two_ dash C&#x27;s?) to even find the right messages that are relevant to the code blocks you care about is not widely known and even if you find them, still only show the first line. Then you need to &quot;git show&quot; the identified commit SHA to get this long form message. There is just no good way to find this information, even if it&#x27;s well written.<p>This is one of my biggest complaints with Git (or, indeed, any VCS before it), and I think why people just don&#x27;t care much about good commit messages. It&#x27;s just not easy to get this data back once it&#x27;s written.<p>If you want an example of this, search through the Git project&#x27;s history. Run a blame on any file. It&#x27;s _so hard_ to figure out a story of any function implementation in any file, but the commit messages are _pristine_. Paragraphs and paragraphs of high quality explanation for almost every single commit. Look at any single commit that Jeff King has done for the last decade. Hundreds of hours of amazing documentation from a true genius that almost nobody will ever appreciate. It&#x27;s horrifying.<p>I don&#x27;t know exactly what the answer is, but the sad truth of Git is that writing amazing documentation via commit message, for most communities, is almost entirely a waste of time. It&#x27;s just too difficult to find them.</div><br/><div id="39219037" class="c"><input type="checkbox" id="c-39219037" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39221103">next</a><span>|</span><label class="collapse" for="c-39219037">[-]</label><label class="expand" for="c-39219037">[21 more]</label></div><br/><div class="children"><div class="content">As someone who has contributed to Git since before GitHub existed and who maintains legacy code, I simply cannot disagree more. I use `git blame`, `git log`, and `git show` in the terminal all the time. It&#x27;s trivial to follow the history of a file. It takes me seconds to use `git log -G` to find when something was added or removed.<p>Nothing pains me more than to track down the commit and then find a commit message that&#x27;s of the form &quot;bleh&quot; or &quot;add a thing&quot; when the developer could have spent 60 second to write down why they did it.<p>Nothing gives me more joy than to find a commit message (often my own) that explains in detail why something was done. A single good commit message can save me hours or days of work.<p>Let me also just say, and this is a bit of shot: GitHub contributes to the problem of bad commit messages. If I&#x27;m lucky, folks have put some amount of detail in the PR description, but sadly that&#x27;s not close at hand to the commit log. It&#x27;s another tool I have to open. Usually though, the PR is just a link to Jira, so that&#x27;s another degree of indirection I need to follow. Then the Jira is a link to a Slack conversation. And the Slack conversation probably links to a Google doc.<p>As an industry, we&#x27;re _terrible_ at documentation. But folks like Jeff King are fighting the good fight. At the end of the day, I don&#x27;t think the problem is with the technology. I think it&#x27;s a people problem. Folks perceive writing documentation as extra work, so they don&#x27;t. There&#x27;s no immediate value to it. The payoff comes days, weeks, or months later.<p>Please, write good commit messages. Just spend a minute saying why you did something so that every commit isn&#x27;t a damn Chesteron&#x27;s fence exercise. Put it in the commit message where I can easily find it. Your future self and I thank you.<p>Edit to add: I didn&#x27;t address your argument, that commit messages are too hard to find.<p>First, I don&#x27;t find this to be true. I rarely have trouble following the history of a line of code, a function, or a file.<p>Second, commit messages have value at the time they are written even if they are never seen again. I find that writing a good commit message helps ensure that I&#x27;ve written in code what I&#x27;ve intended to (I often view the diff while writing the commit message) and they have value to the  people reviewing my code.</div><br/><div id="39220523" class="c"><input type="checkbox" id="c-39220523" checked=""/><div class="controls bullet"><span class="by">neilkk</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219037">parent</a><span>|</span><a href="#39225045">next</a><span>|</span><label class="collapse" for="c-39220523">[-]</label><label class="expand" for="c-39220523">[13 more]</label></div><br/><div class="children"><div class="content">The thing is that writing a good commit message for future people doing `git blame` is only worth it if it&#x27;s a line of code which someone in the future will look at and need to know <i>why</i> it was changed from its previous form to the current form.<p>If you simply want to comment the current state of the code, you should add a comment <i>in</i> the code.<p>No one will ever need to know in the future <i>why</i> that particular space character is an ascii space, so the whole commit message is just a blog entry in the wrong place.<p>It would have made sense to just put a comment at the top of the file saying &quot;make sure encoding is whatever&quot;.</div><br/><div id="39224654" class="c"><input type="checkbox" id="c-39224654" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39222436">next</a><span>|</span><label class="collapse" for="c-39224654">[-]</label><label class="expand" for="c-39224654">[3 more]</label></div><br/><div class="children"><div class="content">Then don&#x27;t write commit messages for the future, write them for reviewers.<p>Seriously, as somebody who reviews a lot of code, well-written commit messages are a godsend.<p>It&#x27;s an awful shame that GitHub doesn&#x27;t allow commenting on commit messages. It&#x27;s as if GitHub is being run by people who just don&#x27;t know how Git is meant to be used.</div><br/><div id="39225010" class="c"><input type="checkbox" id="c-39225010" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39224654">parent</a><span>|</span><a href="#39224875">next</a><span>|</span><label class="collapse" for="c-39225010">[-]</label><label class="expand" for="c-39225010">[1 more]</label></div><br/><div class="children"><div class="content">I write commit messages for future-me. Sooner or later I&#x27;m going to encounter the same problem again and wonder how I solved it last time. If I have a vague inkling that I dealt with this before, all I have to do is searching through my commit history and I can find it again. I can search my author (me), I can search by date, I can search by what files I touched. It&#x27;s lovely.</div><br/></div></div><div id="39224875" class="c"><input type="checkbox" id="c-39224875" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39224654">parent</a><span>|</span><a href="#39225010">prev</a><span>|</span><a href="#39222436">next</a><span>|</span><label class="collapse" for="c-39224875">[-]</label><label class="expand" for="c-39224875">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s an awful shame that GitHub doesn&#x27;t allow commenting on commit messages.<p>You actually can comment on a commit itself.  I&#x27;m in the habit on middle-clicking on the sha1 link of commits in a PR and looking at the commit itself.  You can comment on lines in the commit, and there&#x27;s a text area at the bottom where you can comment on the entire commit itself.  I&#x27;ll then follow up with making a comment on the PR linking the commit (pasting the sha1 link) and saying I made a few comments here.<p>&gt;  It&#x27;s as if GitHub is being run by people who just don&#x27;t know how Git is meant to be used.<p>Github wasn&#x27;t really designed with code review in mind.  A lot of the features they added over the years for review appear to be hacked on rather than fixing fundamental design issues (like being able to comment on commit messages without having to jump through a bunch of hoops).<p>Review systems like gerrit, phabricator, review board, or even email, do a much better job at exposing individual commits and their associated metadata like the commit message.</div><br/></div></div></div></div><div id="39222436" class="c"><input type="checkbox" id="c-39222436" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39224654">prev</a><span>|</span><a href="#39221446">next</a><span>|</span><label class="collapse" for="c-39222436">[-]</label><label class="expand" for="c-39222436">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes a comment is appropriate. Sometimes a commit message is appropriate. Sometimes I need both. Often when dealing with legacy code I find neither. I&#x27;d be happy with either.<p>A commit message lets me tell a short story about a change that touches multiple locations in the code base. Maybe no one part of the change is all that tricky.<p>A commit message also allows me to explain why I&#x27;m making the change, whereas a comment may explain why the code is the way it is.<p>Commit messages and comments have overlapping use cases, but the Venn diagram is not a circle.<p>$0.02.</div><br/></div></div><div id="39221446" class="c"><input type="checkbox" id="c-39221446" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39222436">prev</a><span>|</span><a href="#39225077">next</a><span>|</span><label class="collapse" for="c-39221446">[-]</label><label class="expand" for="c-39221446">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    The thing is that writing a good commit message for future people doing `git blame` is only worth it if it&#x27;s a line of code which someone in the future will look at and need to know why it was changed from its previous form to the current form.
</code></pre>
Well what about this example: I removed a few lines of code and explained in the commit message why I thought it was correct to do that. If somebody (possibly me) comes looking for that code and realizes it&#x27;s not there, they&#x27;ll be much happier to see some sort of explanation rather than a &quot;removed lines&quot; message.<p>Regarding commenting in the code vs. in the commit message, sometimes I copy-paste my explanatory comment if there is one into my commit message.</div><br/><div id="39221979" class="c"><input type="checkbox" id="c-39221979" checked=""/><div class="controls bullet"><span class="by">neilkk</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221446">parent</a><span>|</span><a href="#39225077">next</a><span>|</span><label class="collapse" for="c-39221979">[-]</label><label class="expand" for="c-39221979">[2 more]</label></div><br/><div class="children"><div class="content">Right. You&#x27;ve given an example of exactly what I said was the only reasonable use case for detailed info in the commit message: someone in the future will need to know the history of that particular piece of code. It seems like the point of your specific example is to say &#x27;in some cases you might want to know the history of a <i>gap</i>&#x27;. Fine. That seems like a nitpick to me.<p>No one in the future will need to know the history of a particular ascii encoded blank space (among a whole file of ASCII encoded blank spaces). Anyone who needs the general info that the file needs to be ascii will be helped by it being somewhere else, as opposed to in a random commit message.</div><br/><div id="39222855" class="c"><input type="checkbox" id="c-39222855" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221979">parent</a><span>|</span><a href="#39225077">next</a><span>|</span><label class="collapse" for="c-39222855">[-]</label><label class="expand" for="c-39222855">[1 more]</label></div><br/><div class="children"><div class="content">But virtually every diff is one that someone in the future might want more information on. You can&#x27;t know that they won&#x27;t until you get to the end of the future and haven&#x27;t needed it.</div><br/></div></div></div></div></div></div><div id="39225077" class="c"><input type="checkbox" id="c-39225077" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39221446">prev</a><span>|</span><a href="#39220742">next</a><span>|</span><label class="collapse" for="c-39225077">[-]</label><label class="expand" for="c-39225077">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If you simply want to comment the current state of the code, you should add a comment in the code.<p>I think you mean &quot;past state of the code&quot;...<p>These comments rarely get updated.  My favorite recent one was several sentences describing a data structure and how it mapped out statuses, written about a decade ago.  Barely a year after that comment and its code was written, the entire thing was re-written with completely different structure - and the comment left unchanged.  Left a co-worker completely baffled due to inexperience with perl, we figured out what happened because of svn blame.</div><br/><div id="39226016" class="c"><input type="checkbox" id="c-39226016" checked=""/><div class="controls bullet"><span class="by">JetSetIlly</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39225077">parent</a><span>|</span><a href="#39226109">next</a><span>|</span><label class="collapse" for="c-39226016">[-]</label><label class="expand" for="c-39226016">[1 more]</label></div><br/><div class="children"><div class="content">The drifting of code from comments is a problem I would love to see solved.<p>I&#x27;ve seen tools that can compare the git commit dates of code with nearby comments and that&#x27;s a good start. However, there are potential problems with that, such as code and the comments that discuss the code not being near each other; or the code being updated and there being no need to update the comment<p>I think literal programming might help here, but that&#x27;s an entirely different topic really.<p>Looking for more advanced tools that that and I suppose we&#x27;re into the world of AI - asking the tool to understand both the code and the comment and to compare the underlying meaning.<p>Code review is an option but outside of an organisation that&#x27;s difficult to do and besides, I think the problem would be best solved by something that is repeatable and part of the build process. And I&#x27;d love to be able to have a git commit hook that can say, &quot;hold on! you&#x27;ve updated code but there&#x27;s a comment that now looks old&quot;. That&#x27;s the dream.</div><br/></div></div><div id="39226109" class="c"><input type="checkbox" id="c-39226109" checked=""/><div class="controls bullet"><span class="by">metafunctor</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39225077">parent</a><span>|</span><a href="#39226016">prev</a><span>|</span><a href="#39220742">next</a><span>|</span><label class="collapse" for="c-39226109">[-]</label><label class="expand" for="c-39226109">[1 more]</label></div><br/><div class="children"><div class="content">Mistakes can happen.  But if code comments are frequently not updated as the code evolves, it is a level of lazy that will probably manifest in other ways as well.</div><br/></div></div></div></div><div id="39220742" class="c"><input type="checkbox" id="c-39220742" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39225077">prev</a><span>|</span><a href="#39222628">next</a><span>|</span><label class="collapse" for="c-39220742">[-]</label><label class="expand" for="c-39220742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the whole commit message is just a blog entry in the wrong place.<p>Right.  All this wonderful information and detailed error messages need to be findable by someone searching the same error.  Someone digging into the code is a very different use case and they need a tiny fraction of that information.</div><br/></div></div><div id="39222628" class="c"><input type="checkbox" id="c-39222628" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220523">parent</a><span>|</span><a href="#39220742">prev</a><span>|</span><a href="#39225045">next</a><span>|</span><label class="collapse" for="c-39222628">[-]</label><label class="expand" for="c-39222628">[1 more]</label></div><br/><div class="children"><div class="content">The example in the blog post would be a much better example if some kind of test or linting step was added to catch these white-space errors, to explain the need for catching such errors.<p>Pro tip, you can write both comments and commit messages.</div><br/></div></div></div></div><div id="39225045" class="c"><input type="checkbox" id="c-39225045" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219037">parent</a><span>|</span><a href="#39220523">prev</a><span>|</span><a href="#39224636">next</a><span>|</span><label class="collapse" for="c-39225045">[-]</label><label class="expand" for="c-39225045">[1 more]</label></div><br/><div class="children"><div class="content">Definite agree there:  Be it git or svn I spent a huge amount of my bugfixing and refactoring time in the history figuring out why things are the way they are.<p>&gt; Usually though, the PR is just a link to Jira, so that&#x27;s another degree of indirection I need to follow. Then the Jira is a link to a Slack conversation. And the Slack conversation probably links to a Google doc.<p>Assuming all those links in the chain still exist.  Before Jira we had FogBugz, almost all those old cases are gone (some were imported).  And we used Flowdock for 10 years, that&#x27;s completely gone.<p>Commit messages are the only thing we can rely on for this history.  Use it.  And try to avoid squashing commits, that erases this history - yes, even for a feature branch, changes from code review should be separate from the initial push, explain why it&#x27;s being changed so we don&#x27;t make the same mistake later.</div><br/></div></div><div id="39224636" class="c"><input type="checkbox" id="c-39224636" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219037">parent</a><span>|</span><a href="#39225045">prev</a><span>|</span><a href="#39222935">next</a><span>|</span><label class="collapse" for="c-39224636">[-]</label><label class="expand" for="c-39224636">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m mixed on this. My project has a bug tracker. A commit is required to have a bug id. The bug tracker has entire discussions of what lead to the commit so it&#x27;s not clear to me that a detailed commit message is a plus when the real detailed info is in the tracker. Yes it&#x27;s indirect but there&#x27;s no way I&#x27;m going to summarize the entire issue discussion.<p>Maybe this is a job for machine learning. Read the code, read the commits, read the bug tracker, add a git super-blame that asks the LLM to summarize why every line is the way it is and what it&#x27;s doing</div><br/><div id="39224827" class="c"><input type="checkbox" id="c-39224827" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39224636">parent</a><span>|</span><a href="#39224649">next</a><span>|</span><label class="collapse" for="c-39224827">[-]</label><label class="expand" for="c-39224827">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A commit is required to have a bug id. The bug tracker has entire discussions of what lead to the commit<p>Companies do change bug trackers and ticketing systems and those links may no longer work years down the line.<p>&gt; The bug tracker has entire discussions of what lead to the commit so it&#x27;s not clear to me that a detailed commit message is a plus when the real detailed info is in the tracker.  Yes it&#x27;s indirect but there&#x27;s no way I&#x27;m going to summarize the entire issue discussion.<p>But summarizing it can be one of the most valuable things you can do for a maintainer who has to make changes years after you&#x27;ve moved on.  For one thing, the problem and discussion is fresh in your mind and you understand the context.  In a few minutes, you could summarize the problem, the approach taken to fix it and alternatives that were considered but not used because the chosen solution clearly didn&#x27;t have an issue&#x2F;was more efficient, etc.<p>Even if you didn&#x27;t want to do that, you could just copy and paste the entire discussion text at the end of the commit message so that even if the bug tracker is no longer in use in the future, the discussion itself was preserved in the commit history and accessible via git log or blame.</div><br/><div id="39225113" class="c"><input type="checkbox" id="c-39225113" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39224827">parent</a><span>|</span><a href="#39224649">next</a><span>|</span><label class="collapse" for="c-39225113">[-]</label><label class="expand" for="c-39225113">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; A commit is required to have a bug id. The bug tracker has entire discussions of what lead to the commit<p>&gt; Companies do change bug trackers and ticketing systems and those links may no longer work years down the line.<p>I&#x27;ve experienced this twice, we switched from Bugzilla to FogBugz to Jira in my time.  With one relatively small exception in the FogBugz to Jira transition, all past case information was lost.</div><br/></div></div></div></div><div id="39224649" class="c"><input type="checkbox" id="c-39224649" checked=""/><div class="controls bullet"><span class="by">ghqst</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39224636">parent</a><span>|</span><a href="#39224827">prev</a><span>|</span><a href="#39222935">next</a><span>|</span><label class="collapse" for="c-39224649">[-]</label><label class="expand" for="c-39224649">[1 more]</label></div><br/><div class="children"><div class="content">This is why at work the only required rule for commit messages is that they include the story number, so we can very easily find at least the general reason for a change from git blame.</div><br/></div></div></div></div><div id="39222935" class="c"><input type="checkbox" id="c-39222935" checked=""/><div class="controls bullet"><span class="by">spacemankiller</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219037">parent</a><span>|</span><a href="#39224636">prev</a><span>|</span><a href="#39224814">next</a><span>|</span><label class="collapse" for="c-39222935">[-]</label><label class="expand" for="c-39222935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Edit to add: I didn&#x27;t address your argument, that commit messages are too hard to find.
First, I don&#x27;t find this to be true. I rarely have trouble following the history of a line of code, a function, or a file.<p>I don’t think this is proper way of reasoning. What is hard and easy is subjective. And you discuss it as it would be objective. Word against word. It would be wise to have some poll and see results.<p>If one geek is writing and reading commit messages doesn’t mean it’s easily accessible by everyone. It’s hard to make something as a widespread standard if tooling doesn’t make it super easy to access.
Allow people to leave kudos and emoji to other people commits messages and people will start making them better :D And later show heroic people with git —-stats</div><br/></div></div><div id="39224814" class="c"><input type="checkbox" id="c-39224814" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219037">parent</a><span>|</span><a href="#39222935">prev</a><span>|</span><a href="#39221103">next</a><span>|</span><label class="collapse" for="c-39224814">[-]</label><label class="expand" for="c-39224814">[1 more]</label></div><br/><div class="children"><div class="content">His credentials indicate that it may be possible that his arguments are based on data while your credentials and evidence indicate personal, anecdotal experience. Therefore I would trust his reasoning more. Additionally, I personally identify with it.<p>I mean a git developer finds git easy to use? That&#x27;s biased data.<p>I love how both of you dropped your street cred before launching into your reasoning. It just shows how much more credentials convinces people rather then the argument itself. Normally that stuff logically doesn&#x27;t matter and people are just doing it to grab some &quot;authoritah&quot; but in this case your backgrounds actually contributed to the arguments.</div><br/></div></div></div></div><div id="39221103" class="c"><input type="checkbox" id="c-39221103" checked=""/><div class="controls bullet"><span class="by">krobelus</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39219037">prev</a><span>|</span><a href="#39226015">next</a><span>|</span><label class="collapse" for="c-39221103">[-]</label><label class="expand" for="c-39221103">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The main problem is that Git was built so that the commit message is the _email body_, meant to be read by everyone in the project.<p>I find this very hard to believe. Isn&#x27;t it &quot;everyone who is interested in the commit subject&#x2F;files touched should read the body&quot;. Why would anyone else read immutable historical documentation?<p>&gt; Even if you&#x27;re _very good_ at Git, finding the correct invocation of &quot;git blame&quot; (is it &quot;-w -C -C -C&quot;? Or just _two_ dash C&#x27;s?) to even find the right messages that are relevant to the code blocks you care about is not widely known and even if you find them, still only show the first line. Then you need to &quot;git show&quot; the identified commit SHA to get this long form message. There is just no good way to find this information, even if it&#x27;s well written.<p>This sounds like you are joking. Any good IDE will be able to annotate each line with blame info, and show the diff at the press of a button. On such diffs, the IDE should allow recursive blaming on context&#x2F;deleted lines. Tools like Tig allow exactly that.<p>GitHub certainly does make it hard to see commit messages, I give you that :)<p>&gt; Hundreds of hours of amazing documentation from a true genius that almost nobody will ever appreciate. It&#x27;s horrifying.<p>?? It&#x27;s not like it was written for fun. This documentation attached to a commit exists to reduce the risk of accepting the patch from someone who might not be around in future, to fix any problems introduced. By disclosing all their relevant thoughts, the author shows their good intentions: they enable others to build on top of their work. If the author kept their thoughts to themselves they would gradually build up exclusive ownership of the code, which is often not a good idea. Also a commit message serves as proof of work, which can be important when there&#x27;s too many patches. For commercial projects some of this is less important.</div><br/><div id="39223529" class="c"><input type="checkbox" id="c-39223529" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221103">parent</a><span>|</span><a href="#39226015">next</a><span>|</span><label class="collapse" for="c-39223529">[-]</label><label class="expand" for="c-39223529">[1 more]</label></div><br/><div class="children"><div class="content">I might be in the minority, but parent&#x27;s comment is probably about people like me: most of my coworkers have context free, or at best succinct commit messages. I never read more than the first line listed in the commit list, and don&#x27;t even assume the description is always accurate.<p>Instead I&#x27;ll spend my time stalking the related merge request, where the full description of the whole change resides, with probably a link to the ticket or reference documentation, and all the back and forth on why something is or isn&#x27;t a good idea.<p>I think the world could be a better place if all of that was in git directly, but that&#x27;s also utting much more burden on an already complex tool.</div><br/></div></div></div></div><div id="39226015" class="c"><input type="checkbox" id="c-39226015" checked=""/><div class="controls bullet"><span class="by">schacon</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39221103">prev</a><span>|</span><a href="#39218857">next</a><span>|</span><label class="collapse" for="c-39226015">[-]</label><label class="expand" for="c-39226015">[1 more]</label></div><br/><div class="children"><div class="content">To be clear from reading some of the other comments, I don&#x27;t work at GitHub anymore so while I may have partially caused the issues I&#x27;m complaining about, I don&#x27;t have the ability to fix them anymore.<p>Also, while most GUIs and editors have blame capability (as does GitHub actually), most of them don&#x27;t ignore whitespace changes (-w), code movement or renames (the -C options) so they&#x27;re often of limited use.<p>Finally, I _would_ like people to write good commit messages, I just would like to see a tool that actually uses that work in a way that helps document your code in an easy and valuable way, and the Git&#x2F;Hub tooling makes that process at best &quot;tedious&quot; as someone in the thread says.<p>I am working on a new Git client called GitButler[1] and would like to address this at some point down the line, so maybe it ends up being me who helps fix this after all :)<p>1: <a href="https:&#x2F;&#x2F;gitbutler.com" rel="nofollow">https:&#x2F;&#x2F;gitbutler.com</a></div><br/></div></div><div id="39218857" class="c"><input type="checkbox" id="c-39218857" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39226015">prev</a><span>|</span><a href="#39225727">next</a><span>|</span><label class="collapse" for="c-39218857">[-]</label><label class="expand" for="c-39218857">[21 more]</label></div><br/><div class="children"><div class="content">&gt; Even if you&#x27;re _very good_ at Git, finding the correct invocation of &quot;git blame&quot; (is it &quot;-w -C -C -C&quot;? Or just _two_ dash C&#x27;s?) to even find the right messages<p>I am terrible at git on the terminal, but with IntelliJ or emacs and magit, I can trivially find every commit ever to change a file, and easily navigate the commits to see every full commit message. It&#x27;s not hard when you use a proper tool, and I have a feeling almost everyone has something like that?! Do you really try to stick with the git CLI and memorize hundreds of commands and flags?? Why?!</div><br/><div id="39219722" class="c"><input type="checkbox" id="c-39219722" checked=""/><div class="controls bullet"><span class="by">winwhiz</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39219065">next</a><span>|</span><label class="collapse" for="c-39219722">[-]</label><label class="expand" for="c-39219722">[11 more]</label></div><br/><div class="children"><div class="content">Really simple answer: Repeatability. I am not saying it is the only one right blessed answer, but if you really want to know why people haven&#x27;t moved to pure GUI interfaces, imagine describing to someone how to add a new directory to their path.<p><pre><code>  fleet $HOME&#x2F;.config&#x2F;fish.config
  # ADD this line somewhere
  set -x PATH &#x2F;opt&#x2F;git&#x2F;bin $PATH
</code></pre>
Or: 1. Either hit WINDOWS-E and right click on This PC and select properties (it might be called something other than This PC if someone renamed it) or either press WINDOWS key or click Start or click the Windows icon (if you don&#x27;t see them try mousing into a corner of your screen (typically bottom left) until they and the rest of the bar un-autohide) look for and click a gear symbol (should expand to say Settings if you hover), click System, on the left and the bottom you should see About. 2. Click the text Advanced system settings (on the right), look for a new window with a set of tabs, you want Advanced. Click the button Environment Variables. 3. In the top columnar box EITHER find a variable named Path, highlight and click button Edit, in a new window click button New, type &#x27;&#x2F;opt&#x2F;bin&#x2F;git&#x27; in a text field that has appeared at the bottom list items, click OK OR click the button New, in a new window enter Path for Variable name and &#x2F;opt&#x2F;git&#x2F;bin for Variable value, click OK (you shouldn&#x27;t need to Browse Directory or Browse File). 4. Click OK button, click OK button, close Settings window.</div><br/><div id="39220068" class="c"><input type="checkbox" id="c-39220068" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219722">parent</a><span>|</span><a href="#39222134">next</a><span>|</span><label class="collapse" for="c-39220068">[-]</label><label class="expand" for="c-39220068">[3 more]</label></div><br/><div class="children"><div class="content">On Windows it&#x27;s actually just:<p>1. Press Win key
2. Type env
3. Choose system or account</div><br/><div id="39224332" class="c"><input type="checkbox" id="c-39224332" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220068">parent</a><span>|</span><a href="#39221589">next</a><span>|</span><label class="collapse" for="c-39224332">[-]</label><label class="expand" for="c-39224332">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s even better because thanks to the Start Menu randomization process either could appear first in the results. Sometimes they will switch position after being presented.</div><br/></div></div><div id="39221589" class="c"><input type="checkbox" id="c-39221589" checked=""/><div class="controls bullet"><span class="by">winwhiz</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220068">parent</a><span>|</span><a href="#39224332">prev</a><span>|</span><a href="#39222134">next</a><span>|</span><label class="collapse" for="c-39221589">[-]</label><label class="expand" for="c-39221589">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! This is what I was secretly hoping for. I am doing this a lot lately.</div><br/></div></div></div></div><div id="39222134" class="c"><input type="checkbox" id="c-39222134" checked=""/><div class="controls bullet"><span class="by">gregmac</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219722">parent</a><span>|</span><a href="#39220068">prev</a><span>|</span><a href="#39220592">next</a><span>|</span><label class="collapse" for="c-39222134">[-]</label><label class="expand" for="c-39222134">[3 more]</label></div><br/><div class="children"><div class="content">Your fictional example is not a good comparison -- I just can&#x27;t imagine the scenario where you need to explain to someone who doesn&#x27;t know how to modify their path why they need to add something to it.<p>For someone actually using git (and the CLI, at that) I&#x27;d expect to be able to say &quot;oh, make sure git is in your path&quot; and for them to understand how to check and set that, or at least be able to Google it and follow the instructions themselves. Likewise I&#x27;d ask something like &quot;Can you cherry pick just that bug fix into a new PR so we can merge and deploy it today?&quot;, not give them a series of git CLI commands to paste in.<p>My observation of git beginners is ones using CLI say things like &quot;oh, I screwed up my repo and had to clone a new copy&quot;. Good GUIs don&#x27;t easily cause this situation, and mostly let you see and fix what happens when you do some weird accidental merge or rebase or someone else has force-pushed.</div><br/><div id="39224923" class="c"><input type="checkbox" id="c-39224923" checked=""/><div class="controls bullet"><span class="by">rablackburn</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39222134">parent</a><span>|</span><a href="#39222429">next</a><span>|</span><label class="collapse" for="c-39224923">[-]</label><label class="expand" for="c-39224923">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I just can&#x27;t imagine the scenario where you need to explain to someone who doesn&#x27;t know how to modify their path why they need to add something to it.<p>Sounds like someone hasn’t had to train fresh graduate engineers for awhile ;)</div><br/></div></div><div id="39222429" class="c"><input type="checkbox" id="c-39222429" checked=""/><div class="controls bullet"><span class="by">winwhiz</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39222134">parent</a><span>|</span><a href="#39224923">prev</a><span>|</span><a href="#39220592">next</a><span>|</span><label class="collapse" for="c-39222429">[-]</label><label class="expand" for="c-39222429">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I think I conflated a git specific question from the GP and a more general CLI question, my bad.<p>The argument can be made the interfacing with git is bad whether with mouse or with keyboard. My git secret weapon is to ask myself how do I make git do this thing that is easy in Subversion or Fossil and then I do that thing and I write it down so I can do it again in X number of months.</div><br/></div></div></div></div><div id="39220592" class="c"><input type="checkbox" id="c-39220592" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219722">parent</a><span>|</span><a href="#39222134">prev</a><span>|</span><a href="#39220436">next</a><span>|</span><label class="collapse" for="c-39220592">[-]</label><label class="expand" for="c-39220592">[2 more]</label></div><br/><div class="children"><div class="content">Have you ever heard of &quot;abstraction&quot;?  People that actually use windows can handle opening the start menu as a single part of a step.  There&#x27;s no conscious checklist for how the UI can be customized.<p>If you&#x27;re going to make that into a complicated mess, then you absolutely do not get to assume the user understands &quot;add this line somewhere&quot; or has &quot;fleet&quot; installed and set up the way you expect.</div><br/><div id="39221969" class="c"><input type="checkbox" id="c-39221969" checked=""/><div class="controls bullet"><span class="by">winwhiz</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39220592">parent</a><span>|</span><a href="#39220436">next</a><span>|</span><label class="collapse" for="c-39221969">[-]</label><label class="expand" for="c-39221969">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think we agree that abstraction is great (with or without &quot;scair&quot; quotes.) My point is that CLIs are valued as tools of explication, repeatable explication. I have actually used Window since 3.1. I cherry picked a particularly juicy example that I run into a lot.<p>&gt; If you&#x27;re going to make that into a complicated mess, then you absolutely do not get to assume...<p>As far as tooling goes the GP mentioned IntelliJ so I rewrote <i>code</i> with <i>fleet</i>, I could have easily have picked emacs or vim or bash or zsh or tcsh  instead of fish and the complexity of interface would have remained static. I think HN formatting tools are partly to blame for the messiness but if you look at any quality set of docs describing a complicated computer interaction, to achieve the same level of repeatability as text-based, POSIXy interactions you are going to need a lot of screen shots and a few this or thats. WHICH is fine! Remember software engineering is about trade offs!<p>EDIT: CLI allows for abstractions like $EDITOR and $SHELL</div><br/></div></div></div></div><div id="39220436" class="c"><input type="checkbox" id="c-39220436" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219722">parent</a><span>|</span><a href="#39220592">prev</a><span>|</span><a href="#39220035">next</a><span>|</span><label class="collapse" for="c-39220436">[-]</label><label class="expand" for="c-39220436">[1 more]</label></div><br/><div class="children"><div class="content">If the tool calls git(1) then it can show you the script that your actions produced. Magit has something like this but I’ve never used it for that (since I also use git(1)) so I don’t know if it captures the whole context&#x2F;commands.<p>I used a GUI frontend to R in a statistics course. Never needed to write R myself.</div><br/></div></div><div id="39220035" class="c"><input type="checkbox" id="c-39220035" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219722">parent</a><span>|</span><a href="#39220436">prev</a><span>|</span><a href="#39219065">next</a><span>|</span><label class="collapse" for="c-39220035">[-]</label><label class="expand" for="c-39220035">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t even need the set -x, can just use fish_add_path for convenience.</div><br/></div></div></div></div><div id="39219065" class="c"><input type="checkbox" id="c-39219065" checked=""/><div class="controls bullet"><span class="by">bradjohnson</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39219722">prev</a><span>|</span><a href="#39221090">next</a><span>|</span><label class="collapse" for="c-39219065">[-]</label><label class="expand" for="c-39219065">[4 more]</label></div><br/><div class="children"><div class="content">IME git abstractions make it easy to read and navigate standard workflows, but incredibly difficult to repair issues that arise due to divergence of some kind or another because they are so opinionated.<p>I use git 99% in the terminal, and 1% in some git tool for visualization, but I find that a lot of people use it in the opposite way and have problems working with others that use a very slightly different workflow. You don&#x27;t need to memorize hundreds of commands and flags, honestly a dozen or two gets you to expert status in most respects.</div><br/><div id="39219476" class="c"><input type="checkbox" id="c-39219476" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219065">parent</a><span>|</span><a href="#39221090">next</a><span>|</span><label class="collapse" for="c-39219476">[-]</label><label class="expand" for="c-39219476">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have any problem at all, when some really tricky stuff needs to be done, I google for a solution and run whatever command magic I find. If you don&#x27;t need to google for git commands to do uncommon things, I imagine you have a huge capacity to memorize things, good for you, but most of us don&#x27;t.<p>I do understand how git works and could use the CLI most of the time if I wanted to, but there&#x27;s exactly zero reason to do so. The GUIs offered by modern tools make it much more convenient and efficient to do things correctly. You really should&#x27;t commit stuff without doing a careful review of the changes first, which is terrible to do in the terminal compared with using a GUI for that, for example.</div><br/><div id="39219557" class="c"><input type="checkbox" id="c-39219557" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219476">parent</a><span>|</span><a href="#39220975">next</a><span>|</span><label class="collapse" for="c-39219557">[-]</label><label class="expand" for="c-39219557">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT is really good at giving me the git invocation I need for weird complex stuff that doesn&#x27;t come up everyday.</div><br/></div></div><div id="39220975" class="c"><input type="checkbox" id="c-39220975" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219476">parent</a><span>|</span><a href="#39219557">prev</a><span>|</span><a href="#39221090">next</a><span>|</span><label class="collapse" for="c-39220975">[-]</label><label class="expand" for="c-39220975">[1 more]</label></div><br/><div class="children"><div class="content">Terminal for repeatability, gitlab for visualization is a good combo I’ve found.  Push your branch and a great diff is waiting for you.</div><br/></div></div></div></div></div></div><div id="39221090" class="c"><input type="checkbox" id="c-39221090" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39219065">prev</a><span>|</span><a href="#39218915">next</a><span>|</span><label class="collapse" for="c-39221090">[-]</label><label class="expand" for="c-39221090">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find it more difficult to use or remember commands for than remembering how to accomplish similar tasks in some GUI (especially if that GUI is emacs). And unlike most GUIs (emacs may be an exception), I can trust that my knowledge of the git CLI won&#x27;t become out of date when my GUI tool inevitably undergoes a UI redesign of some sort.<p>But more importantly, the CLI allows my typical workflow where I chain together a bunch of git (and other) commands in a row, allowing me to just type in, for instance, several different commits, their messages, and what files should go into each in one go without having to break my concentration by having to move around in some GUI between commits. Sprinkle in some stash manipulation and interactive rebases, compilation, and unit testing, and you&#x27;ll really start to see how the CLI allows you to offload some of your working memory to your invocation in a way that a GUI just can&#x27;t.</div><br/></div></div><div id="39218915" class="c"><input type="checkbox" id="c-39218915" checked=""/><div class="controls bullet"><span class="by">schacon</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39221090">prev</a><span>|</span><a href="#39219607">next</a><span>|</span><label class="collapse" for="c-39218915">[-]</label><label class="expand" for="c-39218915">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know IntelliJ well, but I would be surprised if they did the rather expensive rename following that the multiple -C invocations did. Maybe someone can inform us here? GitHub definitely does not, but that is 100% my personal fault I assume.</div><br/></div></div><div id="39219607" class="c"><input type="checkbox" id="c-39219607" checked=""/><div class="controls bullet"><span class="by">bigfatfrock</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39218915">prev</a><span>|</span><a href="#39223445">next</a><span>|</span><label class="collapse" for="c-39219607">[-]</label><label class="expand" for="c-39219607">[1 more]</label></div><br/><div class="children"><div class="content">I was mind blown reading this also - are we not programmers for the sake of laziness in the face of these kinds of &quot;problems&quot;? I have to hail Tim Pope for Fugitive.vim also. HAIL TIM POPE!</div><br/></div></div><div id="39223445" class="c"><input type="checkbox" id="c-39223445" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39219607">prev</a><span>|</span><a href="#39218916">next</a><span>|</span><label class="collapse" for="c-39223445">[-]</label><label class="expand" for="c-39223445">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you really try to stick with the git CLI and memorize hundreds of commands and flags?? Why?!<p>Because IntelliJ is... less capable than it should be. Personally, I find `git add&#x2F;commit -p`, `git diff` far easier to use than IntelliJ, and because Python is a fucking mess I had to install the codecommit git helper into a Python venv... but you can&#x27;t tell IntelliJ to use that venv&#x27;s $PATH for `git pull`&#x2F;`git push`.<p>Oh, and you can&#x27;t really macro complex stuff in IntelliJ, whereas I can do a single-command release and push-tag of a project with about 30 Git submodules in a (convoluted) Bash one-liner.</div><br/></div></div><div id="39218916" class="c"><input type="checkbox" id="c-39218916" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218857">parent</a><span>|</span><a href="#39223445">prev</a><span>|</span><a href="#39225727">next</a><span>|</span><label class="collapse" for="c-39218916">[-]</label><label class="expand" for="c-39218916">[1 more]</label></div><br/><div class="children"><div class="content">100% this</div><br/></div></div></div></div><div id="39225727" class="c"><input type="checkbox" id="c-39225727" checked=""/><div class="controls bullet"><span class="by">adityaathalye</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39218857">prev</a><span>|</span><a href="#39218612">next</a><span>|</span><label class="collapse" for="c-39225727">[-]</label><label class="expand" for="c-39225727">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know exactly what the answer is, but the sad truth of Git<p>&gt; is that writing amazing documentation via commit message,<p>&gt; for most communities, is almost entirely a waste of time.<p>&gt; It&#x27;s just too difficult to find them.<p>I completely agree that well-written git log messages are goldmines of information.<p>I wish makers of popular git forges had made it easier to create and consume this information.<p>Almost all my wiki pages start with piping git log messages into a text file.<p>Git logs are the entry point to good project documentation.<p>(edit: fix formatting)</div><br/></div></div><div id="39218612" class="c"><input type="checkbox" id="c-39218612" checked=""/><div class="controls bullet"><span class="by">codemac</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39225727">prev</a><span>|</span><a href="#39218718">next</a><span>|</span><label class="collapse" for="c-39218612">[-]</label><label class="expand" for="c-39218612">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great for historical research though. It&#x27;s one of the few pieces of documentation that will live with the code forever. github and other forms of centralization are not open data formats that folks trivially backup&#x2F;convert&#x2F;carry forward. They usually leave the data behind if they move the project somewhere else.<p>So no, I don&#x27;t think it helps the current community much either. But it helps the debugger years later.</div><br/><div id="39218724" class="c"><input type="checkbox" id="c-39218724" checked=""/><div class="controls bullet"><span class="by">schacon</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218612">parent</a><span>|</span><a href="#39220048">next</a><span>|</span><label class="collapse" for="c-39218724">[-]</label><label class="expand" for="c-39218724">[10 more]</label></div><br/><div class="children"><div class="content">Is it great for historical research? I feel like the format and tooling around it is uniquely _not great_ for historical research. I think it&#x27;s optimized for discussions before integration, which is largely what PR descriptions and comments are largely used for now.<p>I feel like given great commit messages, determining a story and useful history around any block of code given the Git tooling is incredibly difficult even if there are _amazing_ commit messages.<p>Like say you are trying to determine why a 10 line function is the way that it is. You blame it. Not even with the stupid-simple GitHub UI that _I_ originally wrote, but with the more expensive CLI interface that follows renames and ignores whitespace changes, etc. Now you get a list of SHAs of commits and the first 50 chars of commit messages for each line for the last modifications, etc. How do you even stitch those messages into a useful story (in order) to tell you how that function evolved to what it is now and why?</div><br/><div id="39220830" class="c"><input type="checkbox" id="c-39220830" checked=""/><div class="controls bullet"><span class="by">somerandomqaguy</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39218823">next</a><span>|</span><label class="collapse" for="c-39220830">[-]</label><label class="expand" for="c-39220830">[1 more]</label></div><br/><div class="children"><div class="content">Tediously commit by commit. But it&#x27;s often better then the alternative. Design decisions and business logic separately from the code or source control are infinitely harder to reference code against, and realistically that documentation will be lost.<p>At least if you have the git repo then there&#x27;s at least some chance to be able to git through the history of some code that&#x27;s kept with the code. Especially for stuff that code cannot document and you&#x27;re working with devs that seem to be firmly believe that code is self documenting.<p>Doesn&#x27;t mean that every code base needs to have amazing git commits. But code bases expected to live a long time at least give some possibility to string together a history after some work.</div><br/></div></div><div id="39218823" class="c"><input type="checkbox" id="c-39218823" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39220830">prev</a><span>|</span><a href="#39221919">next</a><span>|</span><label class="collapse" for="c-39218823">[-]</label><label class="expand" for="c-39218823">[1 more]</label></div><br/><div class="children"><div class="content">It might depend on which tools you&#x27;re using. When I&#x27;m doing historical research for how a function evolved, I normally run &quot;gitk&quot; on the file, and walk through the commits; the full commit message is shown together with each diff to the file. It used to be even better in the past, when gitk showed the full commit diff, instead of the diff to just the file I passed on the command line, but &quot;git show&quot; on the commit hash (or another gitk which is not filtered to a path) is good enough.</div><br/></div></div><div id="39221919" class="c"><input type="checkbox" id="c-39221919" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39218823">prev</a><span>|</span><a href="#39224695">next</a><span>|</span><label class="collapse" for="c-39221919">[-]</label><label class="expand" for="c-39221919">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s optimized for discussions before integration, which is largely what PR descriptions and comments are largely used for now.<p>As a GitHub co-founder, whose fault is that? I have seen many great PR descriptions on GitHub that never make their way into the final inclusion in the main&#x2F;master git history.<p>Meanwhile the git project links every commit to the message id whence the original patch (for many years now—not the whole history). Which will be available as long as the email archives are out there somewhere.<p>And the commit messages get reviewed into a good shape. Something that I’ve never seen anyone do on GitHub.</div><br/><div id="39222033" class="c"><input type="checkbox" id="c-39222033" checked=""/><div class="controls bullet"><span class="by">neilkk</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221919">parent</a><span>|</span><a href="#39224695">next</a><span>|</span><label class="collapse" for="c-39222033">[-]</label><label class="expand" for="c-39222033">[2 more]</label></div><br/><div class="children"><div class="content">But Github and similar tools actually solved this problem where Git failed to do so. Nowadays people have a setup with Github or bitbucket where they can navigate from a piece of code right to the pull request, where they can read the code review discussion, see the build log, reach linked resources like the Jira, etc.</div><br/><div id="39225943" class="c"><input type="checkbox" id="c-39225943" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39222033">parent</a><span>|</span><a href="#39224695">next</a><span>|</span><label class="collapse" for="c-39225943">[-]</label><label class="expand" for="c-39225943">[1 more]</label></div><br/><div class="children"><div class="content">“Just go to our web app” is not solving the same problem as what Git is trying to solve (the latter sometimes badly, it might be added).</div><br/></div></div></div></div></div></div><div id="39224695" class="c"><input type="checkbox" id="c-39224695" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39221919">prev</a><span>|</span><a href="#39220489">next</a><span>|</span><label class="collapse" for="c-39224695">[-]</label><label class="expand" for="c-39224695">[1 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re complaining about a problem which you helped create.<p>So, with all due respect, do your part to fix it. For example, by allowing review comments on commit messages in GitHub. Gerrit gets this right, FWIW.</div><br/></div></div><div id="39220489" class="c"><input type="checkbox" id="c-39220489" checked=""/><div class="controls bullet"><span class="by">lazyasciiart</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39224695">prev</a><span>|</span><a href="#39218968">next</a><span>|</span><label class="collapse" for="c-39220489">[-]</label><label class="expand" for="c-39220489">[1 more]</label></div><br/><div class="children"><div class="content">P4V (Perforce Visual Client) is amazing for visual historical research. I haven&#x27;t seen a git tool like it, but I&#x27;d love one. <a href="https:&#x2F;&#x2F;www.perforce.com&#x2F;video-tutorials&#x2F;vcs&#x2F;using-time-lapse-view" rel="nofollow">https:&#x2F;&#x2F;www.perforce.com&#x2F;video-tutorials&#x2F;vcs&#x2F;using-time-laps...</a></div><br/></div></div><div id="39222153" class="c"><input type="checkbox" id="c-39222153" checked=""/><div class="controls bullet"><span class="by">mtrower</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218724">parent</a><span>|</span><a href="#39218968">prev</a><span>|</span><a href="#39220048">next</a><span>|</span><label class="collapse" for="c-39222153">[-]</label><label class="expand" for="c-39222153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s optimized for discussions before integration, which is largely what PR descriptions and comments are largely used for now.<p>This isn&#x27;t even a git concept though; it&#x27;s something that was tacked on top of it.  What you seem to be saying here is that a third-party tool building on top of git spawned a social movement that moved this layer up a level.  Not every project uses github or a github workflow.<p>&gt; I think it&#x27;s optimized for discussions before integration<p>It&#x27;s optimized for discussion of the purpose of the code unit in question.  That discussion can be useful before integration; but pre-integration discussion can happen any way you like.  PR discussions work, e-mails on mailing lists work.  Face-to-face discussion works.<p>The real value (for me, I guess; apparently you just don&#x27;t see it that way) is explaining the purpose (and possibly circumstances) of the commit, after the fact, when I&#x27;m looking at it for some reason or other.  Not finding the commit, but explaining it once I&#x27;m there.  A well-written commit message can be absolutely priceless.<p>Maybe this last point should go in a top-level response to your original comment, but I&#x27;m already here, so I&#x27;ll just say it here.  Saying that commit messages are terrible because only short-messages (the &quot;subject line&quot;) are shown by default, seems to me about the same as saying e-mail bodies are useless for the same reason, or that file contents are terrible because `find` only lists file names by default.  You &#x27;have&#x27; to collapse by default, or you&#x27;d drown in a sea of commit messages anytime you tried to list <i>anything</i>.<p>&gt; Like say you are trying to determine why a 10 line function is the way that it is. You blame it. Not even with the stupid-simple GitHub UI that _I_ originally wrote, but with the more expensive CLI interface that follows renames and ignores whitespace changes, etc. Now you get a list of SHAs of commits and the first 50 chars of commit messages for each line for the last modifications, etc. How do you even stitch those messages into a useful story (in order) to tell you how that function evolved to what it is now and why?<p>Okay, I hear you, this is not the most ergonomic procedure to one-off.  But seriously, you have the SHA commits.  If you need to do this often, write a tool that takes those SHA commits, orders them based on log order (or chronological order, w&#x2F;e, pick an ordering mechanism), and prints out whatever information is interesting to you.  A simple display that can expand&#x2F;collapse full messages, diffs, etc. would probably do nicely.  It can be a GUI tool, a CLI tool (menu-driven, maybe); whatever works for you.  This should not be a big deal to write for the common case, and if you think it&#x27;s that critical to the community, publish it.</div><br/></div></div></div></div><div id="39220048" class="c"><input type="checkbox" id="c-39220048" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218612">parent</a><span>|</span><a href="#39218724">prev</a><span>|</span><a href="#39218718">next</a><span>|</span><label class="collapse" for="c-39220048">[-]</label><label class="expand" for="c-39220048">[1 more]</label></div><br/><div class="children"><div class="content">Till the team you are handing off the code to just copies the files and commits into a fresh new repo without any of the history. I had this happen once to a server I wrote, and then like 2 years later the new team comes and asks me if I knew of the server, and I&#x27;m like &quot;I wrote it&quot; and then they are all confused.</div><br/></div></div></div></div><div id="39218718" class="c"><input type="checkbox" id="c-39218718" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39218612">prev</a><span>|</span><a href="#39225285">next</a><span>|</span><label class="collapse" for="c-39218718">[-]</label><label class="expand" for="c-39218718">[11 more]</label></div><br/><div class="children"><div class="content">Well, `git` is still the primary way I interact with a git repository, and `git log` shows the entire commit message by default. So I don&#x27;t run into this problem.<p>If some &quot;modern&quot; git frontend is only capable of displaying the first line of a commit message, then this is a problem with that tool, not git itself.<p>(I&#x27;m also not convinced this is a limitation of all modern tooling...)</div><br/><div id="39218879" class="c"><input type="checkbox" id="c-39218879" checked=""/><div class="controls bullet"><span class="by">schacon</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218718">parent</a><span>|</span><a href="#39221052">next</a><span>|</span><label class="collapse" for="c-39218879">[-]</label><label class="expand" for="c-39218879">[7 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t tell if this is engaging with trolls or not, but I can&#x27;t imagine that all of your interactions with your codebase are via `git log` with no other flags. Even the with the normal Git CLI that most of us use daily, most of us use `--oneline` or whatever to simplify useful calculations and visualizations like `--graph`, etc. But we&#x27;re talking here mostly about code archeology, learning about the history of a block of code, so this comment seems somewhat ridiculous in that context.</div><br/><div id="39220258" class="c"><input type="checkbox" id="c-39220258" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218879">parent</a><span>|</span><a href="#39221933">next</a><span>|</span><label class="collapse" for="c-39220258">[-]</label><label class="expand" for="c-39220258">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I can&#x27;t imagine that all of your interactions with your codebase are via `git log` with no other flags.<p>When did I say anything like that?<p>My point is just that the `git log` command, by default, shows the full commit message. The same goes for `git show`. So a user of the git CLI will regularly see complete commit messages, unless they purposefully request a different format. So, it is not some inherit problem in git that the complete commit message is hard to find. That&#x27;s just a limitation of certain Git frontends.</div><br/></div></div><div id="39221933" class="c"><input type="checkbox" id="c-39221933" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218879">parent</a><span>|</span><a href="#39220258">prev</a><span>|</span><a href="#39219653">next</a><span>|</span><label class="collapse" for="c-39221933">[-]</label><label class="expand" for="c-39221933">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t tell if this is engaging with trolls or not, […] that most of us use daily, most of us use `--oneline`<p>You speculate that someone who uses git log without listing (or complaining about) all their flags are a troll?</div><br/></div></div><div id="39219653" class="c"><input type="checkbox" id="c-39219653" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218879">parent</a><span>|</span><a href="#39221933">prev</a><span>|</span><a href="#39221052">next</a><span>|</span><label class="collapse" for="c-39219653">[-]</label><label class="expand" for="c-39219653">[4 more]</label></div><br/><div class="children"><div class="content">Is it possible that you’ve been hit by<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;2501&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;2501&#x2F;</a><p>?<p><pre><code>  git log | less 

  &#x2F;whatever
</code></pre>
Works OK for those of us who don’t know any git flags.</div><br/><div id="39219808" class="c"><input type="checkbox" id="c-39219808" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219653">parent</a><span>|</span><a href="#39220290">next</a><span>|</span><label class="collapse" for="c-39219808">[-]</label><label class="expand" for="c-39219808">[2 more]</label></div><br/><div class="children"><div class="content">The only sets of arguments I use to git log regularly:<p>* `git log branch` because I want to cherrypick or checkout parts of another branch.<p>* `git log --stat` because what files changed can be a big clue for what I&#x27;m looking for.<p>* `git log -- dir1&#x2F; file1&#x2F;` because I only care about commits to a certain part of the tree.<p>Other than that, `git log` already provides so much information to &#x2F;search or even `grep` through that I can&#x27;t think of any other flags I use regularly, and if you don&#x27;t use them regularly you forget them.<p>The real GOAT that people are sleeping on is `git rebase --interactive` where you can go back and edit part of your branch to clean it up before rebasing or merging towards main. The cleaner the commits are, the more useful they become later for other tools like log, merge, rebase, cherry-pick, bisect, etc.</div><br/><div id="39223544" class="c"><input type="checkbox" id="c-39223544" checked=""/><div class="controls bullet"><span class="by">ycombobreaker</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219808">parent</a><span>|</span><a href="#39220290">next</a><span>|</span><label class="collapse" for="c-39223544">[-]</label><label class="expand" for="c-39223544">[1 more]</label></div><br/><div class="children"><div class="content">A rebase to clean up your branch is great, and I lean on my team to do this.  Unfortunately it&#x27;s impossible to automate, because it amounts to craftsmanship.  I&#x27;ve seen larger teams fall back to squash-merging, which at least discards checkpoint&#x2F;broken&#x2F;WIP commits.  But it loses the nuance of more complex changes performed in logical stages.</div><br/></div></div></div></div><div id="39220290" class="c"><input type="checkbox" id="c-39220290" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219653">parent</a><span>|</span><a href="#39219808">prev</a><span>|</span><a href="#39221052">next</a><span>|</span><label class="collapse" for="c-39220290">[-]</label><label class="expand" for="c-39220290">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how my comment was understood to mean that I am unfamiliar with git. My point was that those of us that use the git CLI have no issues seeing the rest of a commit message besides the first line, and in fact this is the default.</div><br/></div></div></div></div></div></div><div id="39221052" class="c"><input type="checkbox" id="c-39221052" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218718">parent</a><span>|</span><a href="#39218879">prev</a><span>|</span><a href="#39225285">next</a><span>|</span><label class="collapse" for="c-39221052">[-]</label><label class="expand" for="c-39221052">[3 more]</label></div><br/><div class="children"><div class="content">periodic reminder that `gitk` exists, and has come with git since... pretty much forever? If you&#x27;re reading `git log`, you really owe it to yourself to run `gitk` at least once to see what you&#x27;ve been missing for over a decade now.</div><br/><div id="39226143" class="c"><input type="checkbox" id="c-39226143" checked=""/><div class="controls bullet"><span class="by">ayewo</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221052">parent</a><span>|</span><a href="#39224243">next</a><span>|</span><label class="collapse" for="c-39226143">[-]</label><label class="expand" for="c-39226143">[1 more]</label></div><br/><div class="children"><div class="content">Well, I’ve heard of gitk too but gitk is not available by default on my default installation of macOS so there’s that.</div><br/></div></div><div id="39224243" class="c"><input type="checkbox" id="c-39224243" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221052">parent</a><span>|</span><a href="#39226143">prev</a><span>|</span><a href="#39225285">next</a><span>|</span><label class="collapse" for="c-39224243">[-]</label><label class="expand" for="c-39224243">[1 more]</label></div><br/><div class="children"><div class="content">What gave you the impression that I haven&#x27;t heard of gitk?</div><br/></div></div></div></div></div></div><div id="39225285" class="c"><input type="checkbox" id="c-39225285" checked=""/><div class="controls bullet"><span class="by">heads</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39218718">prev</a><span>|</span><a href="#39221360">next</a><span>|</span><label class="collapse" for="c-39225285">[-]</label><label class="expand" for="c-39225285">[1 more]</label></div><br/><div class="children"><div class="content">To tack one additional problem onto your excellent list: the commit message is usually only the <i>start</i> of a conversation about why a change should be made.  The rest of that discussion is whether it meets the bar and what needs to be adjusted before it can land on the collaborative trunk.  Done well, that is valuable reading.<p>Git was designed with the distributed viewpoint.  A commit message, as written by the author, is necessarily correct: <i>I’ve decided this is right, and it’s on you to decide if you want to merge it into your history too.</i><p>In our current systems we usually have a URL in the commit message that links to the actual story behind the commit — the discussion on the pull request, merge request, or code review.  I rarely see the results of these discussions being amended into the commit message.  If the repo lives forever but the database behind the code review tool gets toasted then something just as important is lost forever.<p>(I come from a background of one idea equals one amended, fast forwarded commit to master.  It’s possible other people rely on branch history to reflect the evolution of ideas and how they go from a request for review to approved code.  In my experience branch histories tend to have very low quality commit messages and even then they only show one side of the conversation — the author’s responses to their reviewer’s and their own critiques.)</div><br/></div></div><div id="39221360" class="c"><input type="checkbox" id="c-39221360" checked=""/><div class="controls bullet"><span class="by">sohamssd</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39225285">prev</a><span>|</span><a href="#39218775">next</a><span>|</span><label class="collapse" for="c-39221360">[-]</label><label class="expand" for="c-39221360">[1 more]</label></div><br/><div class="children"><div class="content">Your entire argument boils down to the fact that it&#x27;s hard to view git blames. It&#x27;s not.<p>As stated by other people, IDEs like VSCode and IntelliJ do an extremely good job of showing the blame. And they DO show the entire commit, body and everything at once.</div><br/></div></div><div id="39218775" class="c"><input type="checkbox" id="c-39218775" checked=""/><div class="controls bullet"><span class="by">tux1968</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39221360">prev</a><span>|</span><a href="#39221959">next</a><span>|</span><label class="collapse" for="c-39218775">[-]</label><label class="expand" for="c-39218775">[1 more]</label></div><br/><div class="children"><div class="content">I never considered the idea that it was atypical, but I read full commit message text all the time.  There are many different ways to drill down into a commit, and then read the entire commit once you know it&#x27;s relevant.  Even doing a simple git log, and then a searching for some keyword through every full commit message, can be useful.</div><br/></div></div><div id="39221959" class="c"><input type="checkbox" id="c-39221959" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39218775">prev</a><span>|</span><a href="#39218706">next</a><span>|</span><label class="collapse" for="c-39221959">[-]</label><label class="expand" for="c-39221959">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The main issue is that most of the tooling (in Git or GitHub or whatever) generally only shows the first line.<p>Maybe I do it wrong, but the most basic interface I use to check the git history is `git log`, which shows the whole commit message.<p>GitHub takes me 18 clicks to find the commits, I don&#x27;t see why I would even bother using it.</div><br/><div id="39222559" class="c"><input type="checkbox" id="c-39222559" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221959">parent</a><span>|</span><a href="#39218706">next</a><span>|</span><label class="collapse" for="c-39222559">[-]</label><label class="expand" for="c-39222559">[3 more]</label></div><br/><div class="children"><div class="content">Many engineers primarily or even exclusively use git via githubs interface and have never made a commit with a body.</div><br/><div id="39226153" class="c"><input type="checkbox" id="c-39226153" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39222559">parent</a><span>|</span><a href="#39222656">next</a><span>|</span><label class="collapse" for="c-39226153">[-]</label><label class="expand" for="c-39226153">[1 more]</label></div><br/><div class="children"><div class="content">Right, but then maybe the main issue is those engineers, and not the tooling? When I see someone using a hammer the wrong way, I don&#x27;t usually blame the hammer.</div><br/></div></div><div id="39222656" class="c"><input type="checkbox" id="c-39222656" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39222559">parent</a><span>|</span><a href="#39226153">prev</a><span>|</span><a href="#39218706">next</a><span>|</span><label class="collapse" for="c-39222656">[-]</label><label class="expand" for="c-39222656">[1 more]</label></div><br/><div class="children"><div class="content">Those &quot;engineers&quot; go on _The List_</div><br/></div></div></div></div></div></div><div id="39218706" class="c"><input type="checkbox" id="c-39218706" checked=""/><div class="controls bullet"><span class="by">tcoff91</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39221959">prev</a><span>|</span><a href="#39225427">next</a><span>|</span><label class="collapse" for="c-39218706">[-]</label><label class="expand" for="c-39218706">[3 more]</label></div><br/><div class="children"><div class="content">Many editors have great git blame integration that makes these messages quite accessible.<p>It&#x27;s really easy in emacs with magit to view commit messages from git blame view.<p>I believe vim, vscode, and jetbrains IDEs all make this simple.</div><br/><div id="39220085" class="c"><input type="checkbox" id="c-39220085" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218706">parent</a><span>|</span><a href="#39222305">next</a><span>|</span><label class="collapse" for="c-39220085">[-]</label><label class="expand" for="c-39220085">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, a lot of these also have Github and ticket tracker (Jira, etc) integration so they&#x27;ll also pull in context from those, too<p>Most of the stuff I work on uses merge commits on Github so you can just click the PR # in the merge commit message and arrive at the PR, browse through commit messages, discussion, etc</div><br/></div></div><div id="39222305" class="c"><input type="checkbox" id="c-39222305" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39218706">parent</a><span>|</span><a href="#39220085">prev</a><span>|</span><a href="#39225427">next</a><span>|</span><label class="collapse" for="c-39222305">[-]</label><label class="expand" for="c-39222305">[1 more]</label></div><br/><div class="children"><div class="content">Using vim-fugitive it&#x27;s<p><pre><code>  :Git blame %</code></pre></div><br/></div></div></div></div><div id="39225427" class="c"><input type="checkbox" id="c-39225427" checked=""/><div class="controls bullet"><span class="by">colelyman</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39218706">prev</a><span>|</span><a href="#39225818">next</a><span>|</span><label class="collapse" for="c-39225427">[-]</label><label class="expand" for="c-39225427">[1 more]</label></div><br/><div class="children"><div class="content">One tool that I think promotes commit messages like the OP is magit in Emacs. Before using magit, I always used `git commit -m &#x27;...&#x27;` and didn&#x27;t realize that commit messages could be longer than a line.<p>I agree that this is a tooling problem, but magit is a breath of fresh air in many ways (including verbose commit messages).</div><br/></div></div><div id="39225818" class="c"><input type="checkbox" id="c-39225818" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39225427">prev</a><span>|</span><a href="#39219800">next</a><span>|</span><label class="collapse" for="c-39225818">[-]</label><label class="expand" for="c-39225818">[1 more]</label></div><br/><div class="children"><div class="content">I use fugitive.vim, and blaming is very convenient there as well as every other git workflow. I can press a shortcut to see when every line in the current file was changed, and who changed it along with the commit hash. If I need more – I can expand every hash to see the full context, including full commit text and diff. Maybe cli git is not too easy to use since how complex it is, but there exists a git wrapper so awesome it should be illegal</div><br/></div></div><div id="39219800" class="c"><input type="checkbox" id="c-39219800" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39225818">prev</a><span>|</span><a href="#39219439">next</a><span>|</span><label class="collapse" for="c-39219800">[-]</label><label class="expand" for="c-39219800">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The main issue is that most of the tooling ... generally only shows the first line.<p>&gt; I don&#x27;t know exactly what the answer is<p>Isn&#x27;t it obvious?  Write better tools.  There is no reason you have to be stuck with the deficiencies of what someone else has built.  That&#x27;s the <i>whole point</i> of open-source software.<p>It&#x27;s more than a little concerning that a &quot;GitHub cofounder and author of several Git books&quot; has to have this pointed out to them.</div><br/><div id="39222637" class="c"><input type="checkbox" id="c-39222637" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219800">parent</a><span>|</span><a href="#39219439">next</a><span>|</span><label class="collapse" for="c-39222637">[-]</label><label class="expand" for="c-39222637">[1 more]</label></div><br/><div class="children"><div class="content">&gt;There is no reason you have to be stuck with the deficiencies of what someone else has built.<p>There is a concerning trend of  &quot;we only use vscode&quot; and popular preference shifting to &quot;adjust to popular tool&quot; rather than  &quot;use best tool&quot;.<p>This means sadly things like GitHub start to define git even more for your coworkers.</div><br/></div></div></div></div><div id="39219439" class="c"><input type="checkbox" id="c-39219439" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39219800">prev</a><span>|</span><a href="#39219075">next</a><span>|</span><label class="collapse" for="c-39219439">[-]</label><label class="expand" for="c-39219439">[1 more]</label></div><br/><div class="children"><div class="content">I’m surprised that you (in particular) would say this. git-log is, to me, fine for displaying the whole message (not just the subject). And sure, I often fiddle with copy-pasting SHA1s like a caveman, but it’s fast enough for some quick history spelunking.<p>Finding the history of a particular code change is even more manual for me: maybe doing a chain of `git log -S&#x27;line&#x27;` where `line` copy-pasted in at every step. But doable and not a time-sink for my off-hand what’s-this thoughts. (But: something more convenient that isn’t an unreadable Unix pipeline one-liner would be very nice.)<p>My litmus test is simple and doesn’t involve hallucinating that other people are even reading my messages: am <i>I</i> reading my own past commit messages? Yes. I am curious why I did or didn’t do something on a daily basis(!)</div><br/></div></div><div id="39219075" class="c"><input type="checkbox" id="c-39219075" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39219439">prev</a><span>|</span><a href="#39220298">next</a><span>|</span><label class="collapse" for="c-39219075">[-]</label><label class="expand" for="c-39219075">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how it&#x27;s for everyone else, but I do value the body of the commits from others. It&#x27;s true that I see only the subject line for most commits. But I eventually read the full body of commits I&#x27;m interested in. Honestly, it&#x27;s frustrating when commit messages don&#x27;t carry enough context. Sometimes that context fits in the subject line. For others, I expect an elaborate body.</div><br/><div id="39219148" class="c"><input type="checkbox" id="c-39219148" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219075">parent</a><span>|</span><a href="#39220298">next</a><span>|</span><label class="collapse" for="c-39219148">[-]</label><label class="expand" for="c-39219148">[9 more]</label></div><br/><div class="children"><div class="content">On my work I make 1-15 commits a day. If I have to spend thought cycles on the commit message, that is time that goes from other productive endeavours.<p>I think, as the original commenter also wrote, this might be worth it in much slower paces projects that is run in another cadence &#x2F; over mailing lists.<p>I particularly think that high paced application development do not benefit from git as documentation.</div><br/><div id="39219671" class="c"><input type="checkbox" id="c-39219671" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219148">parent</a><span>|</span><a href="#39220980">next</a><span>|</span><label class="collapse" for="c-39219671">[-]</label><label class="expand" for="c-39219671">[2 more]</label></div><br/><div class="children"><div class="content">I would argue (rightly or wrongly) that there are two common truths to such a scenario:<p>Scenario 1, you’re doing a bunch of small changes that work towards a larger purpose.  They’re what I like to call “checkpoint commits”.  They aren’t the whole story —- just a step along the way to whatever you’re trying to accomplish.<p>Scenario 2, you’re coding instead of thinking.  Making “random” changes until you get what you want, but because you’re continuously delivering, they all go to production.  Note that “you” here might be the developer, or it might be business people demanding things from said developer.<p>In scenario 1, IMO you should be working on a branch.  Then, when you’re finished, you squash your commits and replace the countless mini-messages (“fixed”, “Oops”, “wtf?”) with the <i>actual</i> message you want to be there when you merge it.<p>In scenario 2, especially if it’s driven by business, you’re probably SOL.  In this instance, however, I tend to feel like people are making more work for themselves.  If they stopped and <i>thought it through</i> for half an hour before starting work, it might only take an hour’s worth of work and one commit, instead of a day and thirty commits.<p>Of course, there are always shades in between. :)</div><br/><div id="39226128" class="c"><input type="checkbox" id="c-39226128" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219671">parent</a><span>|</span><a href="#39220980">next</a><span>|</span><label class="collapse" for="c-39226128">[-]</label><label class="expand" for="c-39226128">[1 more]</label></div><br/><div class="children"><div class="content">None of these, the granularity of the changes are just smaller.<p>Yes, you could argue that we should go with preview envs and only merge larger changes into main. But then again, this adds considerable complexity to the infrastructure – something that might be merited when we scale to 10+ software engineers.<p>This is the nature of products where you work close with designers, POs, etc.<p>You simply don&#x27;t don&#x27;t do this effort to update text, positioning, colors, etc.<p>In particular: Remember that git is _not_ just for kernel-style projects.</div><br/></div></div></div></div><div id="39220980" class="c"><input type="checkbox" id="c-39220980" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219148">parent</a><span>|</span><a href="#39219671">prev</a><span>|</span><a href="#39221936">next</a><span>|</span><label class="collapse" for="c-39220980">[-]</label><label class="expand" for="c-39220980">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On my work I make 1-15 commits a day. If I have to spend thought cycles on the commit message, that is time that goes from other productive endeavours.<p>I make roughly that many commits a day as well. If something&#x27;s easy to understand I&#x27;ll put in a simple commit message (e.g. [1]), but I do put in the effort for more complicated ones.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;nextest-rs&#x2F;nextest&#x2F;commit&#x2F;efd194b2e1d8d615f092d3a4e3d538286d77ec08">https:&#x2F;&#x2F;github.com&#x2F;nextest-rs&#x2F;nextest&#x2F;commit&#x2F;efd194b2e1d8d61...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;omicron&#x2F;commit&#x2F;b07a8f593325efe97ddb526c2725d45d480bf7e6">https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;omicron&#x2F;commit&#x2F;b07a8f593325...</a></div><br/></div></div><div id="39221936" class="c"><input type="checkbox" id="c-39221936" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219148">parent</a><span>|</span><a href="#39220980">prev</a><span>|</span><a href="#39220429">next</a><span>|</span><label class="collapse" for="c-39221936">[-]</label><label class="expand" for="c-39221936">[2 more]</label></div><br/><div class="children"><div class="content">&gt; On my work I make 1-15 commits a day. If I have to spend thought cycles on the commit message, that is time that goes from other productive endeavours.<p>Do you apply that to everything? Like not answering questions from your colleagues, not writing test, not refactoring, not optimizing, etc?<p>I personally don&#x27;t measure my productivity by the number of commits I push. If I did, I could easily make 100 commits a day. And there of course it would be better for me to not care about the commit description, because it would take thought cycles and anyway the commits would make no sense.</div><br/><div id="39226298" class="c"><input type="checkbox" id="c-39226298" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39221936">parent</a><span>|</span><a href="#39220429">next</a><span>|</span><label class="collapse" for="c-39226298">[-]</label><label class="expand" for="c-39226298">[1 more]</label></div><br/><div class="children"><div class="content">Like the sibling comment, this comment reads like a person who don&#x27;t realise the breath of projects git are used for.<p>Not answering questions from my colleagues? No nee to be snarky, lets keep a good tone here.<p>Small refactorings is a good example of some code I would not write long commit messages. Like going through a function improving its clarity and adding comments – I would not redo that effort in the commit message. Text updates, style updates, etc. are also things that rarely merits big messages.<p>Great for you that you don&#x27;t make 100 commits a day – but watch out that you don&#x27;t mix disparate changes into a single commit.</div><br/></div></div></div></div><div id="39220429" class="c"><input type="checkbox" id="c-39220429" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219148">parent</a><span>|</span><a href="#39221936">prev</a><span>|</span><a href="#39219920">next</a><span>|</span><label class="collapse" for="c-39220429">[-]</label><label class="expand" for="c-39220429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think, as the original commenter also wrote, this might be worth it in much slower paces projects that is run in another cadence &#x2F; over mailing lists.<p>Very much this.<p>If I&#x27;m modifying some rather obvious and ovreall simple thing like an obvious config of a grafana, adding a customer to a config and such things... it&#x27;s hard to really bother with a long commit message. Also, with modern tools like VSCode with the Gremlin plugin, I don&#x27;t think I&#x27;d have spent many words on removing a weird whitespace from a code base, to be honest.<p>On the other hand, if I&#x27;ve spent 4 hours thinking and 2 of those hours discussing the change with another DBA changing a 2 into an 8 in the config of an SLA-critical postgres cluster... spending 10 minutes on a commit message in the config management is - with regard to time - a footnote, irrelevant and inconsequential.<p>But it can be worth more than gold down the road if you ask &quot;Why 8? Why not 6!&quot;</div><br/></div></div><div id="39219920" class="c"><input type="checkbox" id="c-39219920" checked=""/><div class="controls bullet"><span class="by">jonathanpglick</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219148">parent</a><span>|</span><a href="#39220429">prev</a><span>|</span><a href="#39220298">next</a><span>|</span><label class="collapse" for="c-39219920">[-]</label><label class="expand" for="c-39219920">[2 more]</label></div><br/><div class="children"><div class="content">Until it&#x27;s 7 years later, the original developers are gone, the ticketing system has changed twice, and you have no clue why something is the way it is.<p>When you&#x27;re committing is exactly when you already have the context of &quot;why&quot; loaded and even a short explanation should be quick to write. The thought cycles argument feels lazy unless you&#x27;re doing a bunch of quick exploratory commits and clean up&#x2F;squash your git history later and add context once a solution solidifies.</div><br/><div id="39226443" class="c"><input type="checkbox" id="c-39226443" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39219920">parent</a><span>|</span><a href="#39220298">next</a><span>|</span><label class="collapse" for="c-39226443">[-]</label><label class="expand" for="c-39226443">[1 more]</label></div><br/><div class="children"><div class="content">In that case, why should the commit history be the place to go? Commit histories are extremely exclusive – everybody not a part of the programming process will be locked out of that information. That is not fair.<p>Regardless, what you describe is more an organisational failure than an issue with commit messages.</div><br/></div></div></div></div></div></div></div></div><div id="39220298" class="c"><input type="checkbox" id="c-39220298" checked=""/><div class="controls bullet"><span class="by">jakub_g</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39219075">prev</a><span>|</span><a href="#39225739">next</a><span>|</span><label class="collapse" for="c-39220298">[-]</label><label class="expand" for="c-39220298">[1 more]</label></div><br/><div class="children"><div class="content">In my experience it all depends on what kind of codebase it is (product? library&#x2F;framework? private company? opensource?), commit velocity, release cadence &amp; how the codebase is used in general.<p>In low-velocity opensource libraries, good and clean commit messages can be really helpful when debugging arcane issues. I used to be maintainer of a frontend framework &amp; widget library and we tried to have good commit messages as we&#x27;d often go back when over old commits when fixing bugs.<p>I agree that using git from command line for blame is not easy, this is something I always do from GitHub UI instead.<p>When GitHub is the repo&#x27;s choice for PRs, and the codebase is product codebase with high velocity, having a pristine git history and clean commits and commit messages is not practical; however, the expectation should be to at least have good <i>PR descriptions</i>. When blaming commits in GH UI, it&#x27;s easy to go to the PR which introduced the commit (it&#x27;s linked below commit title); and PR descriptions can be enforced via templates in .github folder.<p>PR descriptions have an advantage that they can use images, videos etc. to better explain what they change. This is especially useful for frontend codebases.<p>I work on a big frontend monorepo. We have tools in place to do <i>visual bisect</i> between pull requests (each PR gets its own preview env). We very much <i>do read</i> PR descriptions when doing bisect to confirm which of the recently merged dozens of PRs introduced a regression in production N hours ago.<p>But in general I agree that commit messages are not good place to storage general knowledge (they&#x27;re good for &quot;what and why is changing here&quot;). For documenting gotchas etc. I prefer to have code comments in relevant places of code; or README.md in subfolders. (Sadly, I notice most programmers just don&#x27;t document anything anywhere at all).</div><br/></div></div><div id="39225739" class="c"><input type="checkbox" id="c-39225739" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39220298">prev</a><span>|</span><a href="#39225388">next</a><span>|</span><label class="collapse" for="c-39225739">[-]</label><label class="expand" for="c-39225739">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this explains a lot about why GitHub is so consistently hostile towards showing or writing decent commit messages.<p>Which has helped push people away from writing useful ones, on an unprecedented scale, which makes it a self-fulfilling prophecy.<p>Great.<p>Just great.</div><br/></div></div><div id="39225388" class="c"><input type="checkbox" id="c-39225388" checked=""/><div class="controls bullet"><span class="by">phaedrus</span><span>|</span><a href="#39218538">parent</a><span>|</span><a href="#39225739">prev</a><span>|</span><a href="#39217992">next</a><span>|</span><label class="collapse" for="c-39225388">[-]</label><label class="expand" for="c-39225388">[2 more]</label></div><br/><div class="children"><div class="content">So then I am <i>not wrong</i> that I do all my git commit messages via the &quot;-m&quot; commandline option with a short phrase like &quot;frob the baz&quot;?<p>(Initially I started using -m to avoid getting trapped in Vim.  But even after I gained the option to use e.g. Notepad++ as the editor, I never saw the point in using anything more than &quot;-m &#x27;message&#x27;&quot;.)</div><br/><div id="39225687" class="c"><input type="checkbox" id="c-39225687" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#39218538">root</a><span>|</span><a href="#39225388">parent</a><span>|</span><a href="#39217992">next</a><span>|</span><label class="collapse" for="c-39225687">[-]</label><label class="expand" for="c-39225687">[1 more]</label></div><br/><div class="children"><div class="content">Git respects the EDITOR environment variable and has done for decades (so likely before many here really used it) - you should probably be setting that (or equivalent on your platform) to the editor you want anyway.<p>Weird workaround just to avoid basic configuration seems like more work in the long run.</div><br/></div></div></div></div></div></div><div id="39217992" class="c"><input type="checkbox" id="c-39217992" checked=""/><div class="controls bullet"><span class="by">rpsw</span><span>|</span><a href="#39218538">prev</a><span>|</span><a href="#39217623">next</a><span>|</span><label class="collapse" for="c-39217992">[-]</label><label class="expand" for="c-39217992">[6 more]</label></div><br/><div class="children"><div class="content">Overall agree with the sentiment, but I would add a more specific Bottom Line Up Front (BLUF) such as:
&quot;Fix test issues caused by non-breaking space character \xa0&quot;.<p>Tells me exactly what the problem was straight away, but I&#x27;m still free to choose to read more if I want to know more.</div><br/><div id="39220207" class="c"><input type="checkbox" id="c-39220207" checked=""/><div class="controls bullet"><span class="by">Anon1096</span><span>|</span><a href="#39217992">parent</a><span>|</span><a href="#39219395">next</a><span>|</span><label class="collapse" for="c-39220207">[-]</label><label class="expand" for="c-39220207">[2 more]</label></div><br/><div class="children"><div class="content">Yep this message is way better. And honestly, looking at the diff in github it is pretty obvious to me what has changed (and why really, since the only reason for a changeset to have a diff look identical is that non-visible characters have been added or removed).<p>So all I&#x27;d require is a good main message for history-search purposes. A short story about how you went to Narnia and came back to find the root cause of a bug isn&#x27;t really relevant imo but I&#x27;m also not against writing it if you just want to vent in a PR description&#x2F;commit&#x27;s extended message.</div><br/><div id="39223141" class="c"><input type="checkbox" id="c-39223141" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#39217992">root</a><span>|</span><a href="#39220207">parent</a><span>|</span><a href="#39219395">next</a><span>|</span><label class="collapse" for="c-39223141">[-]</label><label class="expand" for="c-39223141">[1 more]</label></div><br/><div class="children"><div class="content">Stories about how you went to narnia and back may be useful to a future contributor who finds themselves in narnia. This is very likely not the last time that an invalid byte sequence will show up in one of the source files in this tree, and if it happens again, it may be good to see the symptoms in the git log.</div><br/></div></div></div></div><div id="39219395" class="c"><input type="checkbox" id="c-39219395" checked=""/><div class="controls bullet"><span class="by">master-lincoln</span><span>|</span><a href="#39217992">parent</a><span>|</span><a href="#39220207">prev</a><span>|</span><a href="#39219089">next</a><span>|</span><label class="collapse" for="c-39219395">[-]</label><label class="expand" for="c-39219395">[1 more]</label></div><br/><div class="children"><div class="content">This would be my ideal commit message as well. The rest of the commit body in the article is just how it was discovered. I don&#x27;t think describing how one works belongs into a git commit message. Your message tells me why and which change was made, that&#x27;s enough to me.</div><br/></div></div><div id="39219089" class="c"><input type="checkbox" id="c-39219089" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39217992">parent</a><span>|</span><a href="#39219395">prev</a><span>|</span><a href="#39217623">next</a><span>|</span><label class="collapse" for="c-39219089">[-]</label><label class="expand" for="c-39219089">[2 more]</label></div><br/><div class="children"><div class="content">I love this concept. I always begin messages with the most actionable or important thing at the top, and the rest that follows is the context. Respect the time of others and don&#x27;t bury the lede</div><br/><div id="39222382" class="c"><input type="checkbox" id="c-39222382" checked=""/><div class="controls bullet"><span class="by">SamuelAdams</span><span>|</span><a href="#39217992">root</a><span>|</span><a href="#39219089">parent</a><span>|</span><a href="#39217623">next</a><span>|</span><label class="collapse" for="c-39222382">[-]</label><label class="expand" for="c-39222382">[1 more]</label></div><br/><div class="children"><div class="content">You see this all the time in business proposals. Executive summary at the top, typically 2-3 paragraphs max. Manager summary, 1-2 pages. Engineer detailed overview, 3-10 pages. Anything else is an addendum.</div><br/></div></div></div></div></div></div><div id="39217623" class="c"><input type="checkbox" id="c-39217623" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#39217992">prev</a><span>|</span><a href="#39218591">next</a><span>|</span><label class="collapse" for="c-39217623">[-]</label><label class="expand" for="c-39217623">[28 more]</label></div><br/><div class="children"><div class="content">I have felt that pride in writing a great commit message, but I am less sure of the value to others. I don’t think most people search commit messages when they encounter an unusual error message, or when adding a new feature, or really almost ever.<p>It’s a bit sad, but I have a growing suspicion that beautiful commit messages are a bit of vanity by the programmer. The person primarily impressed is often the author; others will walk on by without noticing.<p>There is room sometimes for those aesthetic flourishes but I am not convinced they have much practical value, and I have stopped really being bothered by commit messages of “fix whitespace issue” from others. I think I am a better colleague for that.<p>Things might be different on a project like Git or Linux with huge distributed teams and tons of commits, versus the projects I am used to which have between 1 and 100 contributors, mostly from the same organization.</div><br/><div id="39217774" class="c"><input type="checkbox" id="c-39217774" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218434">next</a><span>|</span><label class="collapse" for="c-39217774">[-]</label><label class="expand" for="c-39217774">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I have felt that pride in writing a great commit message, but I am less sure of the value to others. I don’t think most people search commit messages when they encounter an unusual error message, or when adding a new feature, or really almost ever.<p>They have value even if the only person who will ever look at them is you - and I will say that when bisecting an issue, the commit message of the commit I finally find is really useful (or it could be if it wasn&#x27;t <i>fixed thing</i>). It also means that if you encounter a similar issue again, you know that there&#x27;s a note on a commit you can find.</div><br/><div id="39218067" class="c"><input type="checkbox" id="c-39218067" checked=""/><div class="controls bullet"><span class="by">anthomtb</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39217774">parent</a><span>|</span><a href="#39217891">next</a><span>|</span><label class="collapse" for="c-39218067">[-]</label><label class="expand" for="c-39218067">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this wholeheartedly. If writing a detailed, multiparagraph commit message, assume the target audience is future you.<p>Most likely, a time-pressed dev on the far side of the world will think your commit broke something and send a 2:00 AM message of &quot;URGENT: code broke CRITICAL customer request&quot; with a link to the commit, whatever JIRA issue they are working on, and zero additional context. They will NOT bother to read the message (likely explaining how they got into their pickle in the first place) but will see your email, send a message, and do whatever it is they do while waiting for someone else to figure out the problem. You, being that someone else, will now have an excellent starting point on the top priority for the day. Much better than if your message had just been &quot;fixed it&quot;.</div><br/></div></div><div id="39217891" class="c"><input type="checkbox" id="c-39217891" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39217774">parent</a><span>|</span><a href="#39218067">prev</a><span>|</span><a href="#39218434">next</a><span>|</span><label class="collapse" for="c-39217891">[-]</label><label class="expand" for="c-39217891">[7 more]</label></div><br/><div class="children"><div class="content">In some orgs, people never run a bisect. Not once a year.<p>They go as far as squashing out swaths of history into big un-reviewable blobs. Once code has been merged, they never look inside a past commit again.<p>In spite of isolated (desperate) demands for rigor, it works fine.</div><br/><div id="39218309" class="c"><input type="checkbox" id="c-39218309" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39217891">parent</a><span>|</span><a href="#39218434">next</a><span>|</span><label class="collapse" for="c-39218309">[-]</label><label class="expand" for="c-39218309">[6 more]</label></div><br/><div class="children"><div class="content">I despise squashs. It encourages people to tread git commit as a glorified ^S of their work.<p>You want to know why a change was made, or who so that they can explain it. You land on a blob of a diff, with no meaningful commit message (any commit message was squashed to &#x2F;dev&#x2F;null to be replaced with the MR title and description). And then off you go to the corresponding github&#x2F;gitlab&#x2F;whatever MR only to find a wall of &quot;hmmmm&quot; &quot;why no work?&quot; &quot;try something&quot; etc commits.</div><br/><div id="39223210" class="c"><input type="checkbox" id="c-39223210" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218309">parent</a><span>|</span><a href="#39218512">next</a><span>|</span><label class="collapse" for="c-39223210">[-]</label><label class="expand" for="c-39223210">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I despise squashs. It encourages people to tread git commit as a glorified ^S of their work.<p>I can’t imagine working with git any other way. Do you hold off committing because you haven’t collected your thoughts enough to craft a good message? What if your editor crashes and you lose your undo history? How do you get back to the last state where the code compiled? If some plan of attack doesn’t work, you just… reset hard and lose it forever?<p>I can’t count the number of times I’ve done something like the following:<p>- Try approach A<p>- Approach A sucks, commit what I’ve done so far, try approach B<p>- B sucks too, commit again and switch back to A (oh hey, there it is in my reflog!)<p>- Turns out I need a combination of A and B. Oh hey, a simple git diff shows me the deltas. Awesome!<p>- Repeat<p>- Once I’m ready to make the PR, I squash it all, craft a thoughtful, meaningful commit message, look at the commit as if I’m a reviewer, verify it all makes sense in context as a single commit.<p>(oh and by the end, the commit may be a SINGLE CHARACTER! Precisely what the author of this article is talking about! Is it your contention that every dead-end the author hit should have a permanent place in the repo’s commit history, forever?)<p>In your world, do you just… not use git at all here? Do you never try approach until you’re sure it’s the right one? You only commit when you have something you want someone else to see? That’s nuts to me. You’re absolutely missing out on some of the best workflow git has to offer.</div><br/></div></div><div id="39218512" class="c"><input type="checkbox" id="c-39218512" checked=""/><div class="controls bullet"><span class="by">adamsilkey</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218309">parent</a><span>|</span><a href="#39223210">prev</a><span>|</span><a href="#39218483">next</a><span>|</span><label class="collapse" for="c-39218512">[-]</label><label class="expand" for="c-39218512">[1 more]</label></div><br/><div class="children"><div class="content">Squashes and rebaseses, used properly, are done prior to committing work into a shared major branch (like trunk or develop or whatever). The goal of the squash is to make the resulting commit atomic.</div><br/></div></div><div id="39218483" class="c"><input type="checkbox" id="c-39218483" checked=""/><div class="controls bullet"><span class="by">bspammer</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218309">parent</a><span>|</span><a href="#39218512">prev</a><span>|</span><a href="#39218772">next</a><span>|</span><label class="collapse" for="c-39218483">[-]</label><label class="expand" for="c-39218483">[2 more]</label></div><br/><div class="children"><div class="content">This is a false dichotomy. Someone creating the &quot;fix problem&quot; commits is not going to suddenly write great commit messages because the merge strategy changed.<p>The root evil is actually MRs that live longer than a day or two, and change too much code at once.</div><br/><div id="39221891" class="c"><input type="checkbox" id="c-39221891" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218483">parent</a><span>|</span><a href="#39218772">next</a><span>|</span><label class="collapse" for="c-39221891">[-]</label><label class="expand" for="c-39221891">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes units of work that a branch would reflect are larger. I agree there are some branches that grow larger than they should, but often there are branches that involve a good number of changes, and breaking it into smaller branches doesn&#x27;t really make sense either. There will always be branches where there should be multiple meaningful commits, and automatically squashing them all together just defeats the purpose of good commit messages. I don&#x27;t buy into the idea that branches should always have just one commit or be reflected as a single commit on merge.</div><br/></div></div></div></div><div id="39218772" class="c"><input type="checkbox" id="c-39218772" checked=""/><div class="controls bullet"><span class="by">bandyaboot</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218309">parent</a><span>|</span><a href="#39218483">prev</a><span>|</span><a href="#39218434">next</a><span>|</span><label class="collapse" for="c-39218772">[-]</label><label class="expand" for="c-39218772">[1 more]</label></div><br/><div class="children"><div class="content">Most of my commits are indeed a glorified ^s. Doing this does require some discipline though. You’ve got to pay attention to when you’ve reached a point that the accumulated changes represent a reasonably small, but complete unit of work that should be squashed and documented with a good commit message.</div><br/></div></div></div></div></div></div></div></div><div id="39218434" class="c"><input type="checkbox" id="c-39218434" checked=""/><div class="controls bullet"><span class="by">20after4</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39217774">prev</a><span>|</span><a href="#39218170">next</a><span>|</span><label class="collapse" for="c-39218434">[-]</label><label class="expand" for="c-39218434">[1 more]</label></div><br/><div class="children"><div class="content">I might be weird but I try to at least skim all of the commits on any project I am actively involved with. If it&#x27;s an open source project then those commit messages will live on forever. They will even be indexed in regular search engines, not just code search (this maybe not so much now that GitHub is locking out bots more and more)<p>When I&#x27;m trying to solve a problem and not finding results on google or stack overflow, sometimes I search GitHub just to see if a similar thing shows up in PRs or commit messages anywhere (including private repos I have access to search).   It&#x27;s helped me out on countless occasions.  Good commit messages do have value beyond vanity, absolutely without a doubt. The fact that many developers aren&#x27;t looking, that&#x27;s their loss and hopefully they will see the light once they have enough experience.  Maybe teach a junior dev how to search them! Maybe link them to TFA.</div><br/></div></div><div id="39218170" class="c"><input type="checkbox" id="c-39218170" checked=""/><div class="controls bullet"><span class="by">Lex-2008</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218434">prev</a><span>|</span><a href="#39217948">next</a><span>|</span><label class="collapse" for="c-39218170">[-]</label><label class="expand" for="c-39218170">[1 more]</label></div><br/><div class="children"><div class="content">I was bitten by too-short commit messages few times already, when someone asks me &quot;why is it done this way?&quot; - I check git history to find my own 3-year-old commit with message &quot;it should be done this way&quot;...   Since then I try to write my commit messages so at least future me would get a hint why a change was necessary.</div><br/></div></div><div id="39217948" class="c"><input type="checkbox" id="c-39217948" checked=""/><div class="controls bullet"><span class="by">pletnes</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218170">prev</a><span>|</span><a href="#39218233">next</a><span>|</span><label class="collapse" for="c-39217948">[-]</label><label class="expand" for="c-39217948">[1 more]</label></div><br/><div class="children"><div class="content">I often use the git blame feature in the IDE to understand what’s been going on. A good commit message will be appreciated, should I happen to find one.</div><br/></div></div><div id="39218233" class="c"><input type="checkbox" id="c-39218233" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39217948">prev</a><span>|</span><a href="#39218831">next</a><span>|</span><label class="collapse" for="c-39218233">[-]</label><label class="expand" for="c-39218233">[6 more]</label></div><br/><div class="children"><div class="content">If you change a line of code without doing git-blame on it first you&#x27;re doing it wrong.<p>I&#x27;ve been bitten by this many times - I change obvious bug, I&#x27;m about to commit the changes, I see the previous commit which introduced the &quot;bug&quot; on purpose and the attached JIRA task has perfectly good explanation for why my obvious change would have reintroduced some bug from 2 years ago :)</div><br/><div id="39220404" class="c"><input type="checkbox" id="c-39220404" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218233">parent</a><span>|</span><a href="#39218788">next</a><span>|</span><label class="collapse" for="c-39220404">[-]</label><label class="expand" for="c-39220404">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If you change a line of code without doing git-blame on it first you&#x27;re doing it wrong.<p>Working on a project where this is necessary sounds like a hellish experience.<p>The place for comments explaining why the code is needed is right next to the code! On an adjacent line!</div><br/><div id="39220941" class="c"><input type="checkbox" id="c-39220941" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39220404">parent</a><span>|</span><a href="#39223648">next</a><span>|</span><label class="collapse" for="c-39220941">[-]</label><label class="expand" for="c-39220941">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a hellish experience.<p>It&#x27;s literally 1 click away. Or even just a hover over the margin.<p>&gt; The place for comments explaining why the code is needed is right next to the code! On an adjacent line!<p>And then you refactor the code (from another place) and the function name and parameters change but the comments in adjacent lines remain the same. Ups, the comments lie. After enough time passes it&#x27;s 50-50 whether a particular comment is still true.<p>The more high-level the comment - the higher likelihood it lies, because high-level comments are by their nature further away from the code they mention (and they always mention code in many places but you won&#x27;t copy-paste them everywhere relevant, right? DRY and all). So in reality the comments aren&#x27;t &quot;on the adjacent line&quot; but &quot;on the adjacent line in one of 10 places this code is related to - go look for all of them&quot;.<p>On the other hand commit message is always on all lines that changed, if you git blame a line - you see when it was changed last and why, and you can be sure nobody messed with it without changing the commit message.</div><br/></div></div><div id="39223648" class="c"><input type="checkbox" id="c-39223648" checked=""/><div class="controls bullet"><span class="by">wharvle</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39220404">parent</a><span>|</span><a href="#39220941">prev</a><span>|</span><a href="#39221024">next</a><span>|</span><label class="collapse" for="c-39223648">[-]</label><label class="expand" for="c-39223648">[1 more]</label></div><br/><div class="children"><div class="content">Hard concur. When something might look wrong or misleading to a future reader is exactly the time to comment.</div><br/></div></div><div id="39221024" class="c"><input type="checkbox" id="c-39221024" checked=""/><div class="controls bullet"><span class="by">wnoise</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39220404">parent</a><span>|</span><a href="#39223648">prev</a><span>|</span><a href="#39218788">next</a><span>|</span><label class="collapse" for="c-39221024">[-]</label><label class="expand" for="c-39221024">[1 more]</label></div><br/><div class="children"><div class="content">Why code is needed is different than why change is needed.</div><br/></div></div></div></div><div id="39218788" class="c"><input type="checkbox" id="c-39218788" checked=""/><div class="controls bullet"><span class="by">boolemancer</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39218233">parent</a><span>|</span><a href="#39220404">prev</a><span>|</span><a href="#39218831">next</a><span>|</span><label class="collapse" for="c-39218788">[-]</label><label class="expand" for="c-39218788">[1 more]</label></div><br/><div class="children"><div class="content">Seems to me that if you&#x27;re introducing something that seems like a bug on purpose, you should probably have the comment in the code explaining why it&#x27;s there.</div><br/></div></div></div></div><div id="39218831" class="c"><input type="checkbox" id="c-39218831" checked=""/><div class="controls bullet"><span class="by">cheald</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218233">prev</a><span>|</span><a href="#39217738">next</a><span>|</span><label class="collapse" for="c-39218831">[-]</label><label class="expand" for="c-39218831">[1 more]</label></div><br/><div class="children"><div class="content">IMO, the primary target audience for good commit messages is the same target audience as good code comments: me six months from now. Being able to read why and how a particular thing was done has helped me in debugging and troubleshooting an issue on more than one occasion.</div><br/></div></div><div id="39217738" class="c"><input type="checkbox" id="c-39217738" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218831">prev</a><span>|</span><a href="#39220134">next</a><span>|</span><label class="collapse" for="c-39217738">[-]</label><label class="expand" for="c-39217738">[1 more]</label></div><br/><div class="children"><div class="content">I find them valuable, especially when trying to study a new codebase. In the current era where we get immediate feedback on everything we post online, it&#x27;s harder to see the value that comes from writing good commits, and the value can be delayed by weeks, months, or even years.</div><br/></div></div><div id="39220134" class="c"><input type="checkbox" id="c-39220134" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39217738">prev</a><span>|</span><a href="#39218360">next</a><span>|</span><label class="collapse" for="c-39220134">[-]</label><label class="expand" for="c-39220134">[1 more]</label></div><br/><div class="children"><div class="content">I both agree and disagree.  I think you&#x27;re right that most commit messages won&#x27;t end up being seen.  But when you do need to see one, having a good commit message can be critical to understanding a change, especially if the person who made the change is long gone by the time you need to look at it.  Or, hell, if that person was you, but it was far enough in the past that you don&#x27;t recall the details.</div><br/></div></div><div id="39218360" class="c"><input type="checkbox" id="c-39218360" checked=""/><div class="controls bullet"><span class="by">gotts</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39220134">prev</a><span>|</span><a href="#39217741">next</a><span>|</span><label class="collapse" for="c-39218360">[-]</label><label class="expand" for="c-39218360">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you that searching across commit messages happens rather rarely so return on great commit messages might be questionable<p>where great commit messages like the one in the blog post make perfect sense are pull requests. If the commit message explains the whole thought process that the author had while working on it, it saves so much time on pull request review.</div><br/></div></div><div id="39217741" class="c"><input type="checkbox" id="c-39217741" checked=""/><div class="controls bullet"><span class="by">cybrox</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39218360">prev</a><span>|</span><a href="#39221411">next</a><span>|</span><label class="collapse" for="c-39217741">[-]</label><label class="expand" for="c-39217741">[1 more]</label></div><br/><div class="children"><div class="content">If anything, this just tells us that tooling should incorporate commit messages a lot more. While these kind of messages are most valuable in large projects, there are some of them in a lot of projects and they could have saved a lot of time.<p>Especially now with AI IDE integrations, incorporating a software&#x27;s whole history into supplemental tools would be more useful than ever before.</div><br/></div></div><div id="39221411" class="c"><input type="checkbox" id="c-39221411" checked=""/><div class="controls bullet"><span class="by">thefourthchime</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39217741">prev</a><span>|</span><a href="#39222886">next</a><span>|</span><label class="collapse" for="c-39221411">[-]</label><label class="expand" for="c-39221411">[2 more]</label></div><br/><div class="children"><div class="content">I agree. My view is that you shouldn&#x27;t write comments because if you have to, then your code isn&#x27;t clear or organized well enough. If you do need a comment, perhaps to document a &quot;Chesterton&#x27;s Fence&quot;, you should put a big nice comment block to explain why and what&#x27;s going on.<p>The reality is people don&#x27;t like to read, if they do it&#x27;ll be an overview of how the code is organized, they don&#x27;t want to read git commits or even comments. The code is the only truth. GPT can already explain in English what the code is doing pretty well already, imagine in 2-3 years.</div><br/><div id="39222956" class="c"><input type="checkbox" id="c-39222956" checked=""/><div class="controls bullet"><span class="by">agubelu</span><span>|</span><a href="#39217623">root</a><span>|</span><a href="#39221411">parent</a><span>|</span><a href="#39222886">next</a><span>|</span><label class="collapse" for="c-39222956">[-]</label><label class="expand" for="c-39222956">[1 more]</label></div><br/><div class="children"><div class="content">I think the &quot;code should be self-documenting&quot; view is a bit simplistic.<p>Good comments shouldn&#x27;t explain what the code is doing, I agree that should be evident from the code itself if it&#x27;s clear enough. However, <i>why</i> the code is doing what it&#x27;s doing, or why it&#x27;s being done in a certain way and not in a different way, is meta-information that is very hard to express in the code itself, and that&#x27;s where comments are most useful.</div><br/></div></div></div></div><div id="39222886" class="c"><input type="checkbox" id="c-39222886" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39221411">prev</a><span>|</span><a href="#39218441">next</a><span>|</span><label class="collapse" for="c-39222886">[-]</label><label class="expand" for="c-39222886">[1 more]</label></div><br/><div class="children"><div class="content">Worse, PR tools like Azure DevOps (and GitHub?) don&#x27;t do a good job of displaying the information.<p>Just a big diff.<p>I often get asked about the reason for a change in a review comment, even when there&#x27;s a thorough description in the backing commit.<p>It&#x27;s sad. I would prefer PRs over email like Git does</div><br/></div></div><div id="39218441" class="c"><input type="checkbox" id="c-39218441" checked=""/><div class="controls bullet"><span class="by">slily</span><span>|</span><a href="#39217623">parent</a><span>|</span><a href="#39222886">prev</a><span>|</span><a href="#39218591">next</a><span>|</span><label class="collapse" for="c-39218441">[-]</label><label class="expand" for="c-39218441">[1 more]</label></div><br/><div class="children"><div class="content">I agree this one goes into more detail than is useful for future reference, most of the explanation would be better off in a PR description. But in general I would rather people go into too much detail than the more common variant of not providing any contextual information anywhere (or only in a chatroom at best) and sticking to one-line commits. As long as the important information is near the top so I don&#x27;t have to wade through the verbose &quot;this is how I discovered this issue&quot; thing, go crazy.</div><br/></div></div></div></div><div id="39218591" class="c"><input type="checkbox" id="c-39218591" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39217623">prev</a><span>|</span><a href="#39217952">next</a><span>|</span><label class="collapse" for="c-39218591">[-]</label><label class="expand" for="c-39218591">[11 more]</label></div><br/><div class="children"><div class="content">That first line of the commit message is most important so that `git log` can address chesterton&#x27;s fence.  And IMHO in this case the committer whiffed.<p>The key is not to put <i>what</i> you did in that first line, but <i>why</i>.  Anyone interested in what can just look at the code, perhaps via a diff.<p>So something like &quot;nginx .conf files must be in us-ascii&quot;<p>Then &quot;changed blahblah.erb to remove nonbreaking space character&quot;<p>Then the rest of the commit message which is quite good.<p>Think of it as a news article: write in decreasing levels of importance and increasing levels of detail, assuming the reader could stop reading at any point.</div><br/><div id="39219004" class="c"><input type="checkbox" id="c-39219004" checked=""/><div class="controls bullet"><span class="by">hatsix</span><span>|</span><a href="#39218591">parent</a><span>|</span><a href="#39222014">next</a><span>|</span><label class="collapse" for="c-39219004">[-]</label><label class="expand" for="c-39219004">[5 more]</label></div><br/><div class="children"><div class="content">Nah, first line needs to be a summary of what you changed, so that you can find the offending commit in the first place.<p>A news article doesn&#x27;t explain WHY in the headline, it explains what.<p>In this case, the OP&#x27;s first line is spot on... if you&#x27;re reading through git log, you can see that this commit likely didn&#x27;t change anything functional about a test, and you should move on.</div><br/><div id="39219115" class="c"><input type="checkbox" id="c-39219115" checked=""/><div class="controls bullet"><span class="by">tux1968</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39219004">parent</a><span>|</span><a href="#39222014">next</a><span>|</span><label class="collapse" for="c-39219115">[-]</label><label class="expand" for="c-39219115">[4 more]</label></div><br/><div class="children"><div class="content">Hard disagree.<p>There&#x27;s little reason to search the text of commit messages to find out what changed.  There are many git tools to find out which commits affected parts of the code you&#x27;re interested in.  Whereas, trying to find that in commit messages is really inefficient and relies on reading, rather than such automated tools.<p>The purpose of the commit message is to help our fellow humans get a higher level understanding than is available from quickly scanning the code.</div><br/><div id="39219605" class="c"><input type="checkbox" id="c-39219605" checked=""/><div class="controls bullet"><span class="by">hermitdev</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39219115">parent</a><span>|</span><a href="#39219710">next</a><span>|</span><label class="collapse" for="c-39219605">[-]</label><label class="expand" for="c-39219605">[2 more]</label></div><br/><div class="children"><div class="content">Totally agree with you.<p>We already know <i>what</i> changed: it&#x27;s the diff! We need to know <i>why</i> you&#x27;re making the <i>what</i>.<p>The message should address <i>why</i> the diff is necessary. Was it a bug fix? Ok, what&#x27;s the bug you&#x27;re fixing? What&#x27;s the evidence that you think they diff addresses it? Is it a new feature? What&#x27;s the requirement? I can already tell <i>what</i> you did by the diff, but I can&#x27;t tell from the diff alone if it actually matches the requirement!</div><br/><div id="39220005" class="c"><input type="checkbox" id="c-39220005" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39219605">parent</a><span>|</span><a href="#39219710">next</a><span>|</span><label class="collapse" for="c-39220005">[-]</label><label class="expand" for="c-39220005">[1 more]</label></div><br/><div class="children"><div class="content">This is true of the overall commit message, but we&#x27;re talking about the first line. If I&#x27;m browsing git-log short or whatever, I <i>don&#x27;t</i> have the diff, I have an ordered list of commit hashes and one line summaries, and I&#x27;m trying to decide which diffs I actually want to look more closely at.</div><br/></div></div></div></div><div id="39219710" class="c"><input type="checkbox" id="c-39219710" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39219115">parent</a><span>|</span><a href="#39219605">prev</a><span>|</span><a href="#39222014">next</a><span>|</span><label class="collapse" for="c-39219710">[-]</label><label class="expand" for="c-39219710">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never thought about it this way.<p>I&#x27;ve always used it as a summary, so I can understand what has been done when browsing the history. It allows me to find changes that I want to cherry-pick or revert. OTOH I can see benefit of describing why a change was done as the summary, as then git blame on the line is a lot more effective.</div><br/></div></div></div></div></div></div><div id="39222014" class="c"><input type="checkbox" id="c-39222014" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39218591">parent</a><span>|</span><a href="#39219004">prev</a><span>|</span><a href="#39218872">next</a><span>|</span><label class="collapse" for="c-39222014">[-]</label><label class="expand" for="c-39222014">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The key is not to put what you did in that first line, but why.<p>Can&#x27;t we just say that the key is to put something that makes sense for the first line, given that sometimes only the first line is printed?<p>I don&#x27;t really care if it says &quot;The files must be in us-ascii&quot; or &quot;Changed the files to us-ascii&quot;... both of them clearly tell me that the files were changed to us-ascii.</div><br/><div id="39223634" class="c"><input type="checkbox" id="c-39223634" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39222014">parent</a><span>|</span><a href="#39218872">next</a><span>|</span><label class="collapse" for="c-39223634">[-]</label><label class="expand" for="c-39223634">[2 more]</label></div><br/><div class="children"><div class="content">The difference is Chesterton&#x27;s fence: when you encounter something seemingly pointless you should learn <i>why</i> it was there before you consider removing or changing it.</div><br/><div id="39226141" class="c"><input type="checkbox" id="c-39226141" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#39218591">root</a><span>|</span><a href="#39223634">parent</a><span>|</span><a href="#39218872">next</a><span>|</span><label class="collapse" for="c-39226141">[-]</label><label class="expand" for="c-39226141">[1 more]</label></div><br/><div class="children"><div class="content">Ok, but when I read the first line of the commit, I am usually not considering removing or changing it. When I consider removing or changing the content of a commit, the least I can do is read the full commit description.</div><br/></div></div></div></div></div></div><div id="39218872" class="c"><input type="checkbox" id="c-39218872" checked=""/><div class="controls bullet"><span class="by">nathan_phoenix</span><span>|</span><a href="#39218591">parent</a><span>|</span><a href="#39222014">prev</a><span>|</span><a href="#39219986">next</a><span>|</span><label class="collapse" for="c-39218872">[-]</label><label class="expand" for="c-39218872">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Think of it as a news article: write in decreasing levels of importance and increasing levels of detail, assuming the reader could stop reading at any point.<p>Great quote and life advice, will definitely steal this! Thanks!</div><br/></div></div><div id="39219986" class="c"><input type="checkbox" id="c-39219986" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#39218591">parent</a><span>|</span><a href="#39218872">prev</a><span>|</span><a href="#39217952">next</a><span>|</span><label class="collapse" for="c-39219986">[-]</label><label class="expand" for="c-39219986">[1 more]</label></div><br/><div class="children"><div class="content">But a commit message in an arbitrary project is not where you give someone a lesson about nginx rules.<p>&quot;nginx .conf files must be in us-ascii&quot; is maybe a good bug or pull request title, but it may correspond to multiple commits that do different things, but it doesn&#x27;t tell me what&#x27;s happening. Is this converting a file to us-ascii, is this writing a tool to convert files to ASCII, is this updating documentation, is it creating a test, some combination? Leading with what, not why addresses that confusion.</div><br/></div></div></div></div><div id="39217952" class="c"><input type="checkbox" id="c-39217952" checked=""/><div class="controls bullet"><span class="by">adrianmsmith</span><span>|</span><a href="#39218591">prev</a><span>|</span><a href="#39217603">next</a><span>|</span><label class="collapse" for="c-39217952">[-]</label><label class="expand" for="c-39217952">[21 more]</label></div><br/><div class="children"><div class="content">I think the disadvantage with this style of documentation is you can&#x27;t really alter the commit message after it&#x27;s written.<p>(I mean you could obviously with &quot;rebase&quot; but are you really going to alter something written one year ago, already merged to &quot;main&quot;, and cause a bunch of pain with everyone&#x27;s feature branch etc.?)<p>Compare that with documentation stored in a .md file, or even a Wiki or even Confluence. My colleague can write something and if I see a way to improve it I can go ahead and do that, and other colleagues can improve on what I&#x27;ve written.<p>In this particular case I suppose the bug is fixed and won&#x27;t come up again. But I also myself find it tempting to describing the design of a particular component when I commit that component, and that&#x27;s something I now avoid. What about when that component needs to be changed by a future commit e.g. due to the business requirements changing? Will the commit documentation just describe the differences? Then in order for a new team member to find out how the system works by reading the documentation they&#x27;ve got to read multiple commit messages and &quot;merge&quot; them in their head.</div><br/><div id="39218368" class="c"><input type="checkbox" id="c-39218368" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218159">next</a><span>|</span><label class="collapse" for="c-39218368">[-]</label><label class="expand" for="c-39218368">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I think the disadvantage with this style of documentation is you can&#x27;t really alter the commit message after it&#x27;s written.<p>That is not a disadvantage. The commit is a historical record, if I come back to that commit 3 years later I want to know its purpose in the context it was in, I don’t want a whitewashed history.<p>&gt; Compare that with documentation stored in a .md file, or even a Wiki or even Confluence. My colleague can write something and if I see a way to improve it I can go ahead and do that, and other colleagues can improve on what I&#x27;ve written.<p>That’s like comparing a bicycle and a goose.<p>&gt; But I also myself find it tempting to describing the design of a particular component when I commit that component, and that&#x27;s something I now avoid.<p>That’s a shame. Knowing the considerations (or lack thereof) and tradeoffs at time of creation are often useful to understand defects, either in the original, or in evolutions, or in changes of use case.<p>&gt; Will the commit documentation just describe the differences?<p>Yeees?<p>&gt; Then in order for a new team member to find out how the system works by reading the documentation they&#x27;ve got to read multiple commit messages and &quot;merge&quot; them in their head.<p>No, for that you maintain a separate “current” documentation, which does not need to cover implementation tradeoffs, or that the original was written under time crunch, or whatever.</div><br/><div id="39218912" class="c"><input type="checkbox" id="c-39218912" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218368">parent</a><span>|</span><a href="#39218556">next</a><span>|</span><label class="collapse" for="c-39218912">[-]</label><label class="expand" for="c-39218912">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That is not a disadvantage. The commit is a historical record<p>OP&#x27;s point is that, while commit message is indeed a historical record, documentation isn&#x27;t (or shouldn&#x27;t).<p>If you double commit message as documentation, it would cause issues like wrong information confusing or misleading future readers because it&#x27;s non-editable.</div><br/><div id="39221018" class="c"><input type="checkbox" id="c-39221018" checked=""/><div class="controls bullet"><span class="by">Sprocklem</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218912">parent</a><span>|</span><a href="#39218556">next</a><span>|</span><label class="collapse" for="c-39221018">[-]</label><label class="expand" for="c-39221018">[1 more]</label></div><br/><div class="children"><div class="content">Crucially, however, the commit message is not documentation of the code, which <i>would</i> need to be changed and updated. Instead, it is documentation of the change, describing the reason for the change, what the code does to achieve that, and, if relevant, why you chose that solution. It provides necessary context to the already immutable diff and therefore need not be mutable itself.</div><br/></div></div></div></div><div id="39218556" class="c"><input type="checkbox" id="c-39218556" checked=""/><div class="controls bullet"><span class="by">20after4</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218368">parent</a><span>|</span><a href="#39218912">prev</a><span>|</span><a href="#39225013">next</a><span>|</span><label class="collapse" for="c-39218556">[-]</label><label class="expand" for="c-39218556">[1 more]</label></div><br/><div class="children"><div class="content">I really love documentation that lives in the same repo with the code.  My favorite is a .md file for every module, class or component. Some mixture of inline code docs and standalone docs is probably ideal.  But docs as markdown that don&#x27;t require some compile step to build the documentation, and doesn&#x27;t require opening a browser to view them, is just so much better, IMO, compared to any sort of external docs like a wiki or html on a server somewhere that gets re-generated by a CI job.</div><br/></div></div><div id="39225013" class="c"><input type="checkbox" id="c-39225013" checked=""/><div class="controls bullet"><span class="by">spencerchubb</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218368">parent</a><span>|</span><a href="#39218556">prev</a><span>|</span><a href="#39221798">next</a><span>|</span><label class="collapse" for="c-39225013">[-]</label><label class="expand" for="c-39225013">[1 more]</label></div><br/><div class="children"><div class="content">If you put docs in a markdown file, you will still be able to see what the markdown said at that time because it will also be in the commit history.</div><br/></div></div><div id="39221798" class="c"><input type="checkbox" id="c-39221798" checked=""/><div class="controls bullet"><span class="by">twosdai</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218368">parent</a><span>|</span><a href="#39225013">prev</a><span>|</span><a href="#39218159">next</a><span>|</span><label class="collapse" for="c-39221798">[-]</label><label class="expand" for="c-39221798">[1 more]</label></div><br/><div class="children"><div class="content">Sucks when you mess up in your commit message though and don&#x27;t type the right thing.</div><br/></div></div></div></div><div id="39218159" class="c"><input type="checkbox" id="c-39218159" checked=""/><div class="controls bullet"><span class="by">ryanisnan</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218368">prev</a><span>|</span><a href="#39218156">next</a><span>|</span><label class="collapse" for="c-39218159">[-]</label><label class="expand" for="c-39218159">[1 more]</label></div><br/><div class="children"><div class="content">I think the non-editable nature of commit messages is precisely the benefit though. Yes, you can&#x27;t really modify them post-hoc, but being able to step through a code base&#x27;s history can be really illuminating.</div><br/></div></div><div id="39218156" class="c"><input type="checkbox" id="c-39218156" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218159">prev</a><span>|</span><a href="#39220162">next</a><span>|</span><label class="collapse" for="c-39218156">[-]</label><label class="expand" for="c-39218156">[6 more]</label></div><br/><div class="children"><div class="content">I really think git made a mistake in conflating the immutable log of <i>what</i> was changed with the (ideally mutable) story of what got merged in. So you see people arguing over squashing commits vs rebasing vs merging. Squashing commits makes the history of commits a better story of features being added. Merging preserves the immutable log of the actual changes made to the code, and rebasing sort of does a bit of both.<p>But, I don&#x27;t see any reason we can&#x27;t have our cake and eat it too. We&#x27;re programming computers after all and we can make them do whatever we like.<p>If I wrote my own git, I think I&#x27;d split commits into those two parts. I&#x27;d leave the history of changes immutable - probably with some sort of Merkle DAG like Git does. And then have a separate associated data store which stores the commit messages, in a nice sensible, editable log describing the work that actually happened. Let people arrange and rearrange the commit descriptors however they like. If you want, group commits around feature tags, fix typos and make any changes to the messages that you want. But, the whole while the underlying log of diffs (&quot;what actually changed in the code&quot;) can remain (gloriously) unaffected.</div><br/><div id="39218653" class="c"><input type="checkbox" id="c-39218653" checked=""/><div class="controls bullet"><span class="by">passivegains</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218156">parent</a><span>|</span><a href="#39218751">next</a><span>|</span><label class="collapse" for="c-39218653">[-]</label><label class="expand" for="c-39218653">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I really think git made a mistake in conflating the immutable log of what was changed with the (ideally mutable) story of what got merged in. So you see people arguing over squashing commits vs rebasing vs merging.<p>Every team I&#x27;ve been on struggled with this over and over and over. The tools are so hard to use it&#x27;s tempting to make the version control process facilitate &quot;git log&quot; instead of the other way around, which is just absolutely insane. Obviously my co-workers should learn to use their damn tools like professionals, something something a poor craftsman, but honestly? This time the tools really are to blame.</div><br/></div></div><div id="39218316" class="c"><input type="checkbox" id="c-39218316" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218156">parent</a><span>|</span><a href="#39218751">prev</a><span>|</span><a href="#39220162">next</a><span>|</span><label class="collapse" for="c-39218316">[-]</label><label class="expand" for="c-39218316">[3 more]</label></div><br/><div class="children"><div class="content">Fossil has something a bit like that.</div><br/><div id="39221110" class="c"><input type="checkbox" id="c-39221110" checked=""/><div class="controls bullet"><span class="by">wnoise</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39218316">parent</a><span>|</span><a href="#39220162">next</a><span>|</span><label class="collapse" for="c-39221110">[-]</label><label class="expand" for="c-39221110">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate how?</div><br/><div id="39225884" class="c"><input type="checkbox" id="c-39225884" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39217952">root</a><span>|</span><a href="#39221110">parent</a><span>|</span><a href="#39220162">next</a><span>|</span><label class="collapse" for="c-39225884">[-]</label><label class="expand" for="c-39225884">[1 more]</label></div><br/><div class="children"><div class="content">You can add text - essentially a wiki page - to a commit and edit it any time.<p>Additionally, you can also add tech notes, which are wiki-like entries in the timeline alongside commits.</div><br/></div></div></div></div></div></div></div></div><div id="39220162" class="c"><input type="checkbox" id="c-39220162" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218156">prev</a><span>|</span><a href="#39218961">next</a><span>|</span><label class="collapse" for="c-39220162">[-]</label><label class="expand" for="c-39220162">[1 more]</label></div><br/><div class="children"><div class="content">A commit message isn&#x27;t documentation that should be updated as things evolve.  It&#x27;s a historical record of a single change.  Sure, if you later realize you forgot to put an important detail there, that&#x27;s a shame.  But overall I think it&#x27;s actually important that they can never change.</div><br/></div></div><div id="39218961" class="c"><input type="checkbox" id="c-39218961" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39220162">prev</a><span>|</span><a href="#39222012">next</a><span>|</span><label class="collapse" for="c-39218961">[-]</label><label class="expand" for="c-39218961">[1 more]</label></div><br/><div class="children"><div class="content">Commit messages aren&#x27;t a replacement for source documentation. The latter contains information relevant to the tree. Commit messages are transient information (historical info as someone put it). For example, an update caused by outdated dependency. Or the tests done to diagnose a bug.</div><br/></div></div><div id="39222012" class="c"><input type="checkbox" id="c-39222012" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218961">prev</a><span>|</span><a href="#39220283">next</a><span>|</span><label class="collapse" for="c-39222012">[-]</label><label class="expand" for="c-39222012">[1 more]</label></div><br/><div class="children"><div class="content">I have seldom run into this being a problem.<p>The context of a commit message is that someone took some minutes to explain what the context of the change is. Using their current understanding. Explain the problem. Lay out the <i>assumptions</i>. Given three paragraphs or so it will help <i>immensely</i> to figure out how or why something you&#x2F;them thought was the case was in fact <i>wrong</i> when the message was written.<p><i>That</i> is documentation in itself.<p>And if you make straightforward mistakes like a typo in an issue key in the message and you <i>really</i> care: you can make a note of it on the commit with git notes.<p>&gt; Compare that with documentation stored in a .md file, or even a Wiki or even Confluence.<p>I don’t want to access a remote wiki for every little code context (certainly not Conf.). The code is just <i>right there</i>. Comments&#x2F;Doc comments&#x2F;commit messages are mostly enough for that.</div><br/></div></div><div id="39220283" class="c"><input type="checkbox" id="c-39220283" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39222012">prev</a><span>|</span><a href="#39218752">next</a><span>|</span><label class="collapse" for="c-39220283">[-]</label><label class="expand" for="c-39220283">[1 more]</label></div><br/><div class="children"><div class="content">I know this isn&#x27;t a great solution, but GitHub does let you write comments on individual commits. You could add whatever addendums you want there.</div><br/></div></div><div id="39218752" class="c"><input type="checkbox" id="c-39218752" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39220283">prev</a><span>|</span><a href="#39218118">next</a><span>|</span><label class="collapse" for="c-39218752">[-]</label><label class="expand" for="c-39218752">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t really alter the commit message after it&#x27;s written<p>You can append with git notes, though on a message that long I expect they&#x27;re unlikely to be noticed.</div><br/></div></div><div id="39218118" class="c"><input type="checkbox" id="c-39218118" checked=""/><div class="controls bullet"><span class="by">tyrust</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218752">prev</a><span>|</span><a href="#39218108">next</a><span>|</span><label class="collapse" for="c-39218118">[-]</label><label class="expand" for="c-39218118">[1 more]</label></div><br/><div class="children"><div class="content">I think commit messages are mostly valuable for a future code reader asking &quot;why is this bit like this?&quot; and then looking at blame logs for the answer.  As you point out, bigger picture stuff ought to be elsewhere (documentation, tracking bug).<p>Keeping docs in version control and including doc changes with the code changes is a nice way to address your concern.</div><br/></div></div><div id="39218108" class="c"><input type="checkbox" id="c-39218108" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#39217952">parent</a><span>|</span><a href="#39218118">prev</a><span>|</span><a href="#39217603">next</a><span>|</span><label class="collapse" for="c-39218108">[-]</label><label class="expand" for="c-39218108">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason this documentation can&#x27;t be replicated in another context, and for all we know it was.</div><br/></div></div></div></div><div id="39217603" class="c"><input type="checkbox" id="c-39217603" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39217952">prev</a><span>|</span><a href="#39219918">next</a><span>|</span><label class="collapse" for="c-39217603">[-]</label><label class="expand" for="c-39217603">[6 more]</label></div><br/><div class="children"><div class="content">One thing I disagree with is:<p>&gt; I wouldn’t expect all commits (<i>especially ones of this size</i>) to have this level of detail.<p>(emphasis added) - actually in my experience it&#x27;s often the little ones, innocuous looking things that might really need a relatively longer explanation.<p>Yesterday I wrote three paragraphs on why I added `--limit=999` to a `gh pr list` because it&#x27;s confusing: there&#x27;s already a `limit(` in the `--jq` argument, and the higher it is (given say infinite PRs in total) the lower the end result will actually be. (Yes I wrote a comment too. And probably spent even longer thinking about and working it up than writing about it; hopefully I&#x27;ll recall it as an example the next time someone implies the job is about churning out code!)</div><br/><div id="39217937" class="c"><input type="checkbox" id="c-39217937" checked=""/><div class="controls bullet"><span class="by">unregistereddev</span><span>|</span><a href="#39217603">parent</a><span>|</span><a href="#39217899">next</a><span>|</span><label class="collapse" for="c-39217937">[-]</label><label class="expand" for="c-39217937">[3 more]</label></div><br/><div class="children"><div class="content">I agree with you that the little innocuous things often need a longer explanation, but the linked commit message is way too long IMO. It either wastes the readers&#x27; time, or it causes the readers&#x27; eyes to gloss over at the wall of text. You don&#x27;t need to document your entire journey in order to document your findings and explain why.<p>&gt; This was a non-ascii whitespace character that caused `ArgumentError: invalid byte sequence in US-ASCII` when running `bundle exec rake`<p>^ should be sufficient. It includes enough keywords to come up in a search if someone has a similar problem in the future, it contains the root cause of the problem, and it is short enough that people are unlikely to gloss over it.</div><br/><div id="39219768" class="c"><input type="checkbox" id="c-39219768" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39217603">root</a><span>|</span><a href="#39217937">parent</a><span>|</span><a href="#39218053">next</a><span>|</span><label class="collapse" for="c-39219768">[-]</label><label class="expand" for="c-39219768">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s not my preferred style either, but it&#x27;s much better than &#x27;fixes error&#x27; type thing, subject line only, that&#x27;s so common.<p>I like the form:<p><pre><code>    Fix ArgumentError &#x27;invalid byte sequence&#x27;

    Non-ASCII whitespace characters cause [...]. This was apparent in [...] because [...].

    This commit fixes the issue by removing the offending character; so the file is now solely ASCII characters.
</code></pre>
Or that sort of thing. Subject tells me why, body tells me what the problem was and how it was fixed. (Who, when, where are already in the commit metadata! The diff shows a very literal &#x27;what&#x27; too, the what&#x2F;how in the body should offer context and explanation as required.)</div><br/></div></div><div id="39218053" class="c"><input type="checkbox" id="c-39218053" checked=""/><div class="controls bullet"><span class="by">mbork_pl</span><span>|</span><a href="#39217603">root</a><span>|</span><a href="#39217937">parent</a><span>|</span><a href="#39219768">prev</a><span>|</span><a href="#39217899">next</a><span>|</span><label class="collapse" for="c-39218053">[-]</label><label class="expand" for="c-39218053">[1 more]</label></div><br/><div class="children"><div class="content">The article explains why all the rest is, maybe not needed, but good to have.</div><br/></div></div></div></div><div id="39217899" class="c"><input type="checkbox" id="c-39217899" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39217603">parent</a><span>|</span><a href="#39217937">prev</a><span>|</span><a href="#39217879">next</a><span>|</span><label class="collapse" for="c-39217899">[-]</label><label class="expand" for="c-39217899">[1 more]</label></div><br/><div class="children"><div class="content">For a commit that adds a language binding (and might be 100+ additions&#x2F;deletions) I might just say “Add X function”. Because I’m just following established patterns. But for the linked kind of change? Yeah, several paragraphs of explanation is definitely useful.</div><br/></div></div><div id="39217879" class="c"><input type="checkbox" id="c-39217879" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#39217603">parent</a><span>|</span><a href="#39217899">prev</a><span>|</span><a href="#39219918">next</a><span>|</span><label class="collapse" for="c-39217879">[-]</label><label class="expand" for="c-39217879">[1 more]</label></div><br/><div class="children"><div class="content">I find myself commenting code in a similar pattern: A small kernel of &quot;interesting&quot; code that has a 1:1 ratio (or higher) of comments to code, which enables the rest of the codebase to be &quot;boring&quot; self-documenting boilerplate-y code that doesn’t really warrant much in the way of commenting.</div><br/></div></div></div></div><div id="39219918" class="c"><input type="checkbox" id="c-39219918" checked=""/><div class="controls bullet"><span class="by">macspoofing</span><span>|</span><a href="#39217603">prev</a><span>|</span><a href="#39218245">next</a><span>|</span><label class="collapse" for="c-39219918">[-]</label><label class="expand" for="c-39219918">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a great git commit.<p>1) For all that text, the first line &quot;Convert template to US-ASCII to fix error&quot; - could be better. Maybe a couple of extra words to state what whitespace character caused the error, and what the error was. That comment plus the diff is all the context you need.<p>2) Honestly, everything else is kind of pointless. It doesn&#x27;t hurt, but there&#x27;s not a lot of value here. The author documented their journey in tracking this bug .. who cares?</div><br/></div></div><div id="39218245" class="c"><input type="checkbox" id="c-39218245" checked=""/><div class="controls bullet"><span class="by">bhasi</span><span>|</span><a href="#39219918">prev</a><span>|</span><a href="#39223784">next</a><span>|</span><label class="collapse" for="c-39218245">[-]</label><label class="expand" for="c-39218245">[1 more]</label></div><br/><div class="children"><div class="content">For great commit messages, just browse the git history of the Linux kernel where this is the standard.<p>The first line always mentions the subsystem affected by the change, followed by a one-line imperative-mood summary of the change. Subsequently, three questions are answered in as much detail as possible:<p>1. What is the current behaviour?
2. What led to this change?
3. What is the new behaviour after applying this change?<p>Example:<p>&quot;Currently, code does X. When running test case T, unexpected behaviour U was observed. This is because of reason R. Fix this by doing F.&quot;</div><br/></div></div><div id="39223784" class="c"><input type="checkbox" id="c-39223784" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39218245">prev</a><span>|</span><a href="#39222521">next</a><span>|</span><label class="collapse" for="c-39223784">[-]</label><label class="expand" for="c-39223784">[1 more]</label></div><br/><div class="children"><div class="content">I used to write really long, essay style commit messages like this one.<p>Then a friend pointed out that I was effectively writing documentation and hiding it in commit messages.<p>Instead, I switched a lot of that effort to updating actual documentation (in a docs&#x2F; folder) that was relevant to the commit - so the commit would still have the information in it, it&#x27;s just it was in an actual file and not just the commit message.<p>I also make sure my commits almost always link to an issue thread, as that&#x27;s a great place to put all kinds of extra context around the commit that can be updated independently of the commit itself.</div><br/></div></div><div id="39222521" class="c"><input type="checkbox" id="c-39222521" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#39223784">prev</a><span>|</span><a href="#39219132">next</a><span>|</span><label class="collapse" for="c-39222521">[-]</label><label class="expand" for="c-39222521">[1 more]</label></div><br/><div class="children"><div class="content">I was told by a recent contributor that my approach (i.e. requirement) to git messages is &quot;unique&quot;.  Apparently my Linux kernel background is showing, but all my commit messages look like the one shown here!<p>If about existing code, the comment belongs with the code.  If it&#x27;s a process thing (e.g. code that is removed or didn&#x27;t work), it belongs in the commit.<p>Most importantly, while commit messages can reference issues for convenience, they MUST reproduce the critical details: GitHub is transient, git messages are not!</div><br/></div></div><div id="39219132" class="c"><input type="checkbox" id="c-39219132" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#39222521">prev</a><span>|</span><a href="#39217858">next</a><span>|</span><label class="collapse" for="c-39219132">[-]</label><label class="expand" for="c-39219132">[1 more]</label></div><br/><div class="children"><div class="content">Git commit message aside, the described debug session raises a lot of questions about the crappy tooling developers rely on.<p>&quot;ArgumentError: Invalid byte sequence in US-ASCII&quot; is a terrible, hard-to-action error message. What file? What line? What byte sequence? This &quot;let&#x27;s give the user another problem to solve&quot; style of error messages is pervasive in our tools.<p>Also, why does the tool even require US-ASCII as input in the first place? Are we still living in 1995?<p>Also, if only ASCII characters are allowed, why does the code editing tooling allow non-breaking spaces in source code? Is there a good reason for having such a character in this file? This problem could have been avoided if the editor could have been smarter or highlighted the &quot;bad&quot; character better.<p>This developer lost an hour of his life because of a cascading chain of defective tools.</div><br/></div></div><div id="39217858" class="c"><input type="checkbox" id="c-39217858" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39219132">prev</a><span>|</span><a href="#39219578">next</a><span>|</span><label class="collapse" for="c-39217858">[-]</label><label class="expand" for="c-39217858">[1 more]</label></div><br/><div class="children"><div class="content">Here is a context-full commit message.[1]<p>This is so common that the maintainer wrote this[2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;git&#x2F;git&#x2F;commit&#x2F;d70f554cdf38b0b05cfaa8e8eb9f80d54a5ae11c">https:&#x2F;&#x2F;github.com&#x2F;git&#x2F;git&#x2F;commit&#x2F;d70f554cdf38b0b05cfaa8e8eb...</a><p>[2] <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;git&#x2F;xmqqedevo8ps.fsf@gitster.g&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;git&#x2F;xmqqedevo8ps.fsf@gitster.g&#x2F;</a></div><br/></div></div><div id="39219578" class="c"><input type="checkbox" id="c-39219578" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#39217858">prev</a><span>|</span><a href="#39218852">next</a><span>|</span><label class="collapse" for="c-39219578">[-]</label><label class="expand" for="c-39219578">[3 more]</label></div><br/><div class="children"><div class="content">This is the reason I dislike automatic squashing branches with rebase. Squashing discourages thoughtful and meaningful commit messages. What is the point of making a meaningful commit message for some specific change when it is just going to all be smashed together as a single commit on merge. I feel like rebasing is something that should be intentional to clean things up by the dev, but not as a default pattern on merge.</div><br/><div id="39226177" class="c"><input type="checkbox" id="c-39226177" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39219578">parent</a><span>|</span><a href="#39218852">next</a><span>|</span><label class="collapse" for="c-39226177">[-]</label><label class="expand" for="c-39226177">[2 more]</label></div><br/><div class="children"><div class="content">Squashing is very useful....for local development.<p>The idea of squashing already-pushed commits frightens me, glad I&#x27;ve never had to deal with it. Where are they doing this?</div><br/><div id="39226387" class="c"><input type="checkbox" id="c-39226387" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#39219578">root</a><span>|</span><a href="#39226177">parent</a><span>|</span><a href="#39218852">next</a><span>|</span><label class="collapse" for="c-39226387">[-]</label><label class="expand" for="c-39226387">[1 more]</label></div><br/><div class="children"><div class="content">Github and Gitlab allow merge&#x2F;pull requests to automatically squash on merge. Some teams set the squash merge strategy. My team used to squash by default, but I helped convince them otherwise.</div><br/></div></div></div></div></div></div><div id="39218852" class="c"><input type="checkbox" id="c-39218852" checked=""/><div class="controls bullet"><span class="by">krmbzds</span><span>|</span><a href="#39219578">prev</a><span>|</span><a href="#39218478">next</a><span>|</span><label class="collapse" for="c-39218852">[-]</label><label class="expand" for="c-39218852">[2 more]</label></div><br/><div class="children"><div class="content">I would just go with &quot;Remove non-breaking space characters&quot; instead of writing a Russian novel.<p>Also, if you&#x27;re on macOS just use a Karabiner rule [0] that converts all non-breaking space characters to regular space characters to prevent yourself from accidentally typing it out.<p>[0] <a href="https:&#x2F;&#x2F;ke-complex-modifications.pqrs.org&#x2F;#nonbreaking_space" rel="nofollow">https:&#x2F;&#x2F;ke-complex-modifications.pqrs.org&#x2F;#nonbreaking_space</a></div><br/><div id="39219077" class="c"><input type="checkbox" id="c-39219077" checked=""/><div class="controls bullet"><span class="by">hoherd</span><span>|</span><a href="#39218852">parent</a><span>|</span><a href="#39218478">next</a><span>|</span><label class="collapse" for="c-39219077">[-]</label><label class="expand" for="c-39219077">[1 more]</label></div><br/><div class="children"><div class="content">There are also pre-commit hooks to remove the character, even one listed on the pre-commit site. This type of hook has saved me on many occasions, and would have saved my coworkers if they used pre-commit.<p><a href="https:&#x2F;&#x2F;pre-commit.com&#x2F;hooks.html" rel="nofollow">https:&#x2F;&#x2F;pre-commit.com&#x2F;hooks.html</a></div><br/></div></div></div></div><div id="39218478" class="c"><input type="checkbox" id="c-39218478" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#39218852">prev</a><span>|</span><a href="#39219741">next</a><span>|</span><label class="collapse" for="c-39218478">[-]</label><label class="expand" for="c-39218478">[1 more]</label></div><br/><div class="children"><div class="content">Great commit indeed. lots of context information. that&#x27;s gold.<p>The worst I&#x27;ve seen are dozens of tiny commits pushed to the master branch directly. If you want to find out what took to implement a feature, good luck.<p>I&#x27;m a fan of tiny commits during code review but afterwards I prefer to squash everything in a functionally relevant commit. It makes git archeology much easier.</div><br/></div></div><div id="39219741" class="c"><input type="checkbox" id="c-39219741" checked=""/><div class="controls bullet"><span class="by">Forge36</span><span>|</span><a href="#39218478">prev</a><span>|</span><a href="#39217583">next</a><span>|</span><label class="collapse" for="c-39219741">[-]</label><label class="expand" for="c-39219741">[2 more]</label></div><br/><div class="children"><div class="content">Previous discussion <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22519632">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22519632</a></div><br/><div id="39220998" class="c"><input type="checkbox" id="c-39220998" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39219741">parent</a><span>|</span><a href="#39217583">next</a><span>|</span><label class="collapse" for="c-39220998">[-]</label><label class="expand" for="c-39220998">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>My favourite Git commit (2019)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22519632">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22519632</a> - March 2020 (67 comments)<p><i>My Favourite Git Commit</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21289827">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21289827</a> - Oct 2019 (370 comments)</div><br/></div></div></div></div><div id="39217583" class="c"><input type="checkbox" id="c-39217583" checked=""/><div class="controls bullet"><span class="by">aeurielesn</span><span>|</span><a href="#39219741">prev</a><span>|</span><a href="#39222748">next</a><span>|</span><label class="collapse" for="c-39217583">[-]</label><label class="expand" for="c-39217583">[22 more]</label></div><br/><div class="children"><div class="content">I had a terrible time when someone used &quot;smart quotes&quot; (beautified Office quotation marks) in a configuration file. I believe this was only possible because they copied it from Outlook.</div><br/><div id="39217647" class="c"><input type="checkbox" id="c-39217647" checked=""/><div class="controls bullet"><span class="by">atahanacar</span><span>|</span><a href="#39217583">parent</a><span>|</span><a href="#39217643">next</a><span>|</span><label class="collapse" for="c-39217647">[-]</label><label class="expand" for="c-39217647">[14 more]</label></div><br/><div class="children"><div class="content">&gt;smart quotes<p>I never understood why a &quot;stylistic&quot; choice requires separate characters. If we don&#x27;t need a serif and non-serif version of every character and instead leave it to the software, why can&#x27;t we do the same with the &quot;smart&quot; quotes?</div><br/><div id="39217763" class="c"><input type="checkbox" id="c-39217763" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217647">parent</a><span>|</span><a href="#39218204">next</a><span>|</span><label class="collapse" for="c-39217763">[-]</label><label class="expand" for="c-39217763">[8 more]</label></div><br/><div class="children"><div class="content">Typographic quotes are left- and right-handed, vs. the ASCII double quote which is just a single character:<p><pre><code>   “quoted”

   &quot;quoted&quot;
</code></pre>
Who in the blazing highs of techno-utopianism fervor thought it was a good idea to automatically translate the latter to the former we&#x27;ll never know.</div><br/><div id="39218044" class="c"><input type="checkbox" id="c-39218044" checked=""/><div class="controls bullet"><span class="by">atahanacar</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217763">parent</a><span>|</span><a href="#39218370">next</a><span>|</span><label class="collapse" for="c-39218044">[-]</label><label class="expand" for="c-39218044">[6 more]</label></div><br/><div class="children"><div class="content">Why not stylize it as typographic but store it as a &quot;regular&quot; double quote though?</div><br/><div id="39218063" class="c"><input type="checkbox" id="c-39218063" checked=""/><div class="controls bullet"><span class="by">mbork_pl</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218044">parent</a><span>|</span><a href="#39218370">next</a><span>|</span><label class="collapse" for="c-39218063">[-]</label><label class="expand" for="c-39218063">[5 more]</label></div><br/><div class="children"><div class="content">How do you handle non-paired ones then?</div><br/><div id="39225240" class="c"><input type="checkbox" id="c-39225240" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218063">parent</a><span>|</span><a href="#39218127">next</a><span>|</span><label class="collapse" for="c-39225240">[-]</label><label class="expand" for="c-39225240">[1 more]</label></div><br/><div class="children"><div class="content">I would base direction on adjacent whitespace&#x2F;punctuation instead of trying to do pairing.</div><br/></div></div><div id="39218127" class="c"><input type="checkbox" id="c-39218127" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218063">parent</a><span>|</span><a href="#39225240">prev</a><span>|</span><a href="#39218370">next</a><span>|</span><label class="collapse" for="c-39218127">[-]</label><label class="expand" for="c-39218127">[3 more]</label></div><br/><div class="children"><div class="content">Render them as standard double quotes? The same way Markdown renders a single backtick as just a backtick, but text surrounded by backticks becomes code.</div><br/><div id="39218452" class="c"><input type="checkbox" id="c-39218452" checked=""/><div class="controls bullet"><span class="by">mbork_pl</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218127">parent</a><span>|</span><a href="#39218370">next</a><span>|</span><label class="collapse" for="c-39218452">[-]</label><label class="expand" for="c-39218452">[2 more]</label></div><br/><div class="children"><div class="content">Nice try, but the problem with this is that typography is _really_ complex.  For example, there is a rule in English typography (I&#x27;m not sure if it&#x27;s often used today though) that when you have a quotation spanning several paragraphs, you should put an _opening_ quote at the beginning of each paragraph – but only one _closing_ one at the end of the quote.</div><br/><div id="39223811" class="c"><input type="checkbox" id="c-39223811" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218452">parent</a><span>|</span><a href="#39218370">next</a><span>|</span><label class="collapse" for="c-39223811">[-]</label><label class="expand" for="c-39223811">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve let go of other historical typographic and spelling conventions, it&#x27;s time to let go of that one too.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39218370" class="c"><input type="checkbox" id="c-39218370" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217763">parent</a><span>|</span><a href="#39218044">prev</a><span>|</span><a href="#39218204">next</a><span>|</span><label class="collapse" for="c-39218370">[-]</label><label class="expand" for="c-39218370">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m french and I actually really like the auto-translation. This way software that does not care about which quote those are (mail, web, etc) can swap them, and where it matters then it does not translates it (vim, etc).<p>Sadly the new official french azerty keyboard has <i>dedicated</i> keys for both opening and closing quotes, and the good ol&#x27; simple quote tucked away behind modifier keys. As a dev I hate it. (arguably I should not even use azerty for development but that&#x27;s another issue)</div><br/></div></div></div></div><div id="39218204" class="c"><input type="checkbox" id="c-39218204" checked=""/><div class="controls bullet"><span class="by">jotaen</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217647">parent</a><span>|</span><a href="#39217763">prev</a><span>|</span><a href="#39223427">next</a><span>|</span><label class="collapse" for="c-39218204">[-]</label><label class="expand" for="c-39218204">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I never understood why a &quot;stylistic&quot; choice requires separate characters.<p>I don’t think it’s a purely stylistic choice, there is actually semantics to it:<p><pre><code>    “ opening quotation mark, i.e.: starts the quote

    ” closing quotation mark, i.e.: ends the quote
</code></pre>
You could otherwise make the same point about parenthesis: why not just |do this| instead (of this)?</div><br/></div></div><div id="39223427" class="c"><input type="checkbox" id="c-39223427" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217647">parent</a><span>|</span><a href="#39218204">prev</a><span>|</span><a href="#39218884">next</a><span>|</span><label class="collapse" for="c-39223427">[-]</label><label class="expand" for="c-39223427">[1 more]</label></div><br/><div class="children"><div class="content">Double quotes can be unambiguously autodetected by checking word boundaries, but separate single quotes are needed since apostrophe is the same character as a close quote, but can appear at the start of a word. Note that most smart-quote-generating software <i>does</i> fail badly at this.<p>Some common ambiguous pairs:<p>’bout - abbreviation for &quot;about&quot;<p>‘bout - starting a quote about a round of a fight<p>’cause - abbreviation for &quot;because&quot;<p>‘cause - starting a quote about a reason or ideal<p>’em - abbreviation for &quot;them&quot;<p>‘em - starting a quote about typographical units<p>’n’ - abbreviation for &quot;and&quot;<p>‘n’ - speaking of the letter itself</div><br/></div></div><div id="39218884" class="c"><input type="checkbox" id="c-39218884" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217647">parent</a><span>|</span><a href="#39223427">prev</a><span>|</span><a href="#39219554">next</a><span>|</span><label class="collapse" for="c-39218884">[-]</label><label class="expand" for="c-39218884">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a stylistic choice. Opening quotes and closing quotes are different things, and it isn&#x27;t possible to tell the difference (when not already provided) without parsing the language in which they&#x27;re used. That&#x27;s why in TeX you have to manually specify which kind you want, and in software like Wordpress that just guesses, the guess is usually wrong and your published text looks ridiculous.</div><br/><div id="39223827" class="c"><input type="checkbox" id="c-39223827" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39218884">parent</a><span>|</span><a href="#39219554">next</a><span>|</span><label class="collapse" for="c-39223827">[-]</label><label class="expand" for="c-39223827">[1 more]</label></div><br/><div class="children"><div class="content">The complaint was purely about software replacing normal quotes with &quot;smart quotes&quot;, not that it did it wrong.</div><br/></div></div></div></div><div id="39219554" class="c"><input type="checkbox" id="c-39219554" checked=""/><div class="controls bullet"><span class="by">mgdlbp</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217647">parent</a><span>|</span><a href="#39218884">prev</a><span>|</span><a href="#39217643">next</a><span>|</span><label class="collapse" for="c-39219554">[-]</label><label class="expand" for="c-39219554">[1 more]</label></div><br/><div class="children"><div class="content">&quot;quote unification&#x27;&#x27;:<p><pre><code>  most typefaces: “Hello” „Hallo“
</code></pre>
Verdana: “Hello” „Hallo“</div><br/></div></div></div></div><div id="39217643" class="c"><input type="checkbox" id="c-39217643" checked=""/><div class="controls bullet"><span class="by">karagenit</span><span>|</span><a href="#39217583">parent</a><span>|</span><a href="#39217647">prev</a><span>|</span><a href="#39217915">next</a><span>|</span><label class="collapse" for="c-39217643">[-]</label><label class="expand" for="c-39217643">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve been bitten by those quotes in the past too. I noticed recently that VSCode (probably other IDEs too) highlight these characters pretty clearly to help avoid these issues.</div><br/><div id="39218400" class="c"><input type="checkbox" id="c-39218400" checked=""/><div class="controls bullet"><span class="by">jboy55</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217643">parent</a><span>|</span><a href="#39217915">next</a><span>|</span><label class="collapse" for="c-39218400">[-]</label><label class="expand" for="c-39218400">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how much infighting there was between orgs at Microsoft over this. with an Outlook&#x2F;Word PM escalating... &quot;Make the languages understand smart quotes!&quot;</div><br/></div></div></div></div><div id="39217915" class="c"><input type="checkbox" id="c-39217915" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39217583">parent</a><span>|</span><a href="#39217643">prev</a><span>|</span><a href="#39217781">next</a><span>|</span><label class="collapse" for="c-39217915">[-]</label><label class="expand" for="c-39217915">[1 more]</label></div><br/><div class="children"><div class="content">In other words real quotes that people use in published writing.</div><br/></div></div><div id="39217781" class="c"><input type="checkbox" id="c-39217781" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#39217583">parent</a><span>|</span><a href="#39217915">prev</a><span>|</span><a href="#39217895">next</a><span>|</span><label class="collapse" for="c-39217781">[-]</label><label class="expand" for="c-39217781">[1 more]</label></div><br/><div class="children"><div class="content">For a long time there was a Perl script called the Demoronizer that fixed this kind of nonsense.</div><br/></div></div><div id="39217895" class="c"><input type="checkbox" id="c-39217895" checked=""/><div class="controls bullet"><span class="by">selimthegrim</span><span>|</span><a href="#39217583">parent</a><span>|</span><a href="#39217781">prev</a><span>|</span><a href="#39222748">next</a><span>|</span><label class="collapse" for="c-39217895">[-]</label><label class="expand" for="c-39217895">[3 more]</label></div><br/><div class="children"><div class="content">I think this pops up in MacOS shells too</div><br/><div id="39217980" class="c"><input type="checkbox" id="c-39217980" checked=""/><div class="controls bullet"><span class="by">dblitt</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217895">parent</a><span>|</span><a href="#39222748">next</a><span>|</span><label class="collapse" for="c-39217980">[-]</label><label class="expand" for="c-39217980">[2 more]</label></div><br/><div class="children"><div class="content">IIRC TextEdit.app has options like smart quotes, auto capitalize, and spell check turned on (in addition to being rich text by default), so you have to change all those to be a dumb plain text editor.</div><br/><div id="39221814" class="c"><input type="checkbox" id="c-39221814" checked=""/><div class="controls bullet"><span class="by">fishyjoe</span><span>|</span><a href="#39217583">root</a><span>|</span><a href="#39217980">parent</a><span>|</span><a href="#39222748">next</a><span>|</span><label class="collapse" for="c-39221814">[-]</label><label class="expand" for="c-39221814">[1 more]</label></div><br/><div class="children"><div class="content">TextEdit and the Notes app have both caused me to copy&#x2F;paste the specialized quotation marks.<p>Now I only use vim as a scratchpad because I&#x27;ve been bitten too much by GUI apps</div><br/></div></div></div></div></div></div></div></div><div id="39222748" class="c"><input type="checkbox" id="c-39222748" checked=""/><div class="controls bullet"><span class="by">dgunay</span><span>|</span><a href="#39217583">prev</a><span>|</span><a href="#39224794">next</a><span>|</span><label class="collapse" for="c-39222748">[-]</label><label class="expand" for="c-39222748">[2 more]</label></div><br/><div class="children"><div class="content">I put less importance on commit messages being thorough, though I do admire when people write detailed information in the body. What&#x27;s more important to me is to have good commit hygiene. It&#x27;s something the industry is also generally terrible at, but has slightly more immediate value. For example, if your PRs have clean, atomic commits that can stand on their own, I can &quot;rescue&quot; chunks of useful functionality from review hell by cherry picking them out. I do this several times a month to help my teammates burn down huge PRs or take good ideas out of doomed branches.</div><br/><div id="39222843" class="c"><input type="checkbox" id="c-39222843" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39222748">parent</a><span>|</span><a href="#39224794">next</a><span>|</span><label class="collapse" for="c-39222843">[-]</label><label class="expand" for="c-39222843">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I&#x27;ll settle for good commit hygiene over good commit messages.<p>It often seems a tough ask to have both</div><br/></div></div></div></div><div id="39224794" class="c"><input type="checkbox" id="c-39224794" checked=""/><div class="controls bullet"><span class="by">nickm12</span><span>|</span><a href="#39222748">prev</a><span>|</span><a href="#39220118">next</a><span>|</span><label class="collapse" for="c-39224794">[-]</label><label class="expand" for="c-39224794">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not at all a fan of this commit message. The summary line is vague (what template? what error?) and then the body spends 250 words explaining all the steps it took to get to this fix. What is this, a recipe on the web?<p>The commit message should explain the change being made, what impact it will have, and why it is being made. The audience is the developers reviewing the change or someone looking through the logs to determine why this line changed.</div><br/></div></div><div id="39220118" class="c"><input type="checkbox" id="c-39220118" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39224794">prev</a><span>|</span><a href="#39218945">next</a><span>|</span><label class="collapse" for="c-39220118">[-]</label><label class="expand" for="c-39220118">[1 more]</label></div><br/><div class="children"><div class="content">I try to write useful commit messages. Sometimes they&#x27;re as expansive as this example, but not always. On GitHub, at least the way my team uses it, the PR is the more visible unit of code change. If you have a single-commit PR, GitHub will automatically make your commit message the PR description, which is nice. It does not do that if you have more than one commit, in which case I write a general overview of the changes and write &quot;See individual commit messages for more detail&quot; in bold.</div><br/></div></div><div id="39218945" class="c"><input type="checkbox" id="c-39218945" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#39220118">prev</a><span>|</span><a href="#39220843">next</a><span>|</span><label class="collapse" for="c-39218945">[-]</label><label class="expand" for="c-39218945">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised the author (of the git commit) put that much effort into the message, but did not mention what exactly that character is (its Unicode code point).</div><br/></div></div><div id="39220843" class="c"><input type="checkbox" id="c-39220843" checked=""/><div class="controls bullet"><span class="by">2devnull</span><span>|</span><a href="#39218945">prev</a><span>|</span><a href="#39219731">next</a><span>|</span><label class="collapse" for="c-39220843">[-]</label><label class="expand" for="c-39220843">[1 more]</label></div><br/><div class="children"><div class="content">Big fan of the straussian commit message&#x2F;commentary style. You read it once and think you understand, but you come back to it much later and understand it in a second, deeper way. There’s an art to this that some people seem to have. Maybe it correlates to taste.</div><br/></div></div><div id="39219731" class="c"><input type="checkbox" id="c-39219731" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#39220843">prev</a><span>|</span><a href="#39223047">next</a><span>|</span><label class="collapse" for="c-39219731">[-]</label><label class="expand" for="c-39219731">[2 more]</label></div><br/><div class="children"><div class="content">A complementary virtue is that the commit is tightly scoped to exactly one change. I still see most engineers commit whatever they had in their working directory as a sort of blanket Save Point, without any thought to how those changes can be captured as individual commits that can be commented and reviewed on their own merits.<p>This will typically also involve completely unnecessary changes, because when you&#x27;re merging unrelated changes anyway, the unnecessary ones are swept up in the noise. At best they complicate rebases for other contributors, but too often they also cause outright regressions.<p>It goes without saying that the commit messages are a write-off at this point, because even if they felt motivated to take the time to comment it clearly, the change is so messy and nebulous that it becomes hard to comment on. If their code gets reviewed it&#x27;s more likely the reviewer gives up and stamps it so they no longer have to look at it.<p>Most people still don&#x27;t seem to know that `git add -p`, `git reset HEAD`, `git stash`, `git rebase --interactive`, etc. are even available. They never learn what git is capable of, so they act like version control is a bureaucratic obligation rather than the peerless superpower that it can be. The problems they cause don&#x27;t end at their terminal though, because now they&#x27;ve made a mess of the repository for every other contributor as well.</div><br/><div id="39223008" class="c"><input type="checkbox" id="c-39223008" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#39219731">parent</a><span>|</span><a href="#39223047">next</a><span>|</span><label class="collapse" for="c-39223008">[-]</label><label class="expand" for="c-39223008">[1 more]</label></div><br/><div class="children"><div class="content">&gt; git add -p<p>That command is a UX monstrosity and don&#x27;t ever prompt any junior to use it. Use magit, use jj, use your IDE, just not that.<p>I agree with your overall sentiment however. I try to measure up commits in anticipation of future revert(s). A commit is a minimal change that can still (1) pass UT (2) become a sensible revert one day. That&#x27;s my measuring stick.</div><br/></div></div></div></div><div id="39223047" class="c"><input type="checkbox" id="c-39223047" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#39219731">prev</a><span>|</span><a href="#39218830">next</a><span>|</span><label class="collapse" for="c-39223047">[-]</label><label class="expand" for="c-39223047">[1 more]</label></div><br/><div class="children"><div class="content">Not completely on topic (if you read TFA) but my favorite Git commit is by compiler badass and HN frequenter, where he checks in an entire C compiler to the D language repo:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;12507">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;12507</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27102584">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27102584</a></div><br/></div></div><div id="39218830" class="c"><input type="checkbox" id="c-39218830" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#39223047">prev</a><span>|</span><a href="#39218135">next</a><span>|</span><label class="collapse" for="c-39218830">[-]</label><label class="expand" for="c-39218830">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true that giving a little potted history like this is &quot;good&quot; (other than he should have made a nice informative first line for summaries)<p>BUT it&#x27;s not super useful to say this is good, the hard part is knowing WHEN to put this much effort in and when you can skip it.<p>I have many instances where I could do a longer story like this but it would be exhausting to do it every time. I try to do it when the commit might look unclear in intent or effect to an outsider, when the change is being made for an important reason, &#x2F;and&#x2F; where this a potentially negative consequence (like naively reverting or writing bad code) if the change is not explained.<p>I think this is a decent example of that but not great, because no one is intentionally going to go in and start introducing nonbreaking spaces.</div><br/><div id="39219310" class="c"><input type="checkbox" id="c-39219310" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39218830">parent</a><span>|</span><a href="#39218135">next</a><span>|</span><label class="collapse" for="c-39219310">[-]</label><label class="expand" for="c-39219310">[1 more]</label></div><br/><div class="children"><div class="content">&gt; BUT it&#x27;s not super useful to say this is good, the hard part is knowing WHEN to put this much effort in and when you can skip it.<p>I learned git in the context of Linux kernel development (its original use case). In that context, the commit message is where you explain, to whoever is reading, what your change does and why it should be accepted. The more subtle the change is, the longer and more detailed the explanation must be to convince a reviewer.<p>So basically, the rule of thumb would be: pretend you&#x27;re going to email your commit to another developer, who has the power to accept or reject your change, and who is not going to consider anything outside that email in their decision. The more subtle your change is, the more detailed and convincing its explanation has to be.</div><br/></div></div></div></div><div id="39218135" class="c"><input type="checkbox" id="c-39218135" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218830">prev</a><span>|</span><a href="#39218652">next</a><span>|</span><label class="collapse" for="c-39218135">[-]</label><label class="expand" for="c-39218135">[11 more]</label></div><br/><div class="children"><div class="content">At the DLF, our pull requests are usually accompanied by a link to the bugzilla entry, which usually have a detailed explanation.<p>P.S. Having multiple Unicode values that exhibit identically when displayed are a huge veer-into-the-ditch mistake. I.e. the notion that code points should have semantic value is simply wrong.</div><br/><div id="39220238" class="c"><input type="checkbox" id="c-39220238" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39218135">parent</a><span>|</span><a href="#39219016">next</a><span>|</span><label class="collapse" for="c-39220238">[-]</label><label class="expand" for="c-39220238">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>our pull requests are usually accompanied by a link to the bugzilla entry, which usually have a detailed explanation.</i><p>This practice annoys me quite a bit, actually.  Well, if there is a bug tracker issue, of course, definitely link to it in the commit message.  But that should provide extra, optional information; everything I reasonably need to understand the change should still be in the commit message.  I don&#x27;t want to have to chase down the information in an external system, a system which may not even be running anymore... and of course we all know that when systems get shut down, of course they get backed up and archived and made accessible properly every time... right.</div><br/><div id="39224578" class="c"><input type="checkbox" id="c-39224578" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39220238">parent</a><span>|</span><a href="#39219016">next</a><span>|</span><label class="collapse" for="c-39224578">[-]</label><label class="expand" for="c-39224578">[1 more]</label></div><br/><div class="children"><div class="content">I see your point. We are migrating to using github issues for that and related reasons.</div><br/></div></div></div></div><div id="39219016" class="c"><input type="checkbox" id="c-39219016" checked=""/><div class="controls bullet"><span class="by">boolemancer</span><span>|</span><a href="#39218135">parent</a><span>|</span><a href="#39220238">prev</a><span>|</span><a href="#39218652">next</a><span>|</span><label class="collapse" for="c-39219016">[-]</label><label class="expand" for="c-39219016">[8 more]</label></div><br/><div class="children"><div class="content">&gt; P.S. Having multiple Unicode values that exhibit identically when displayed are a huge veer-into-the-ditch mistake. I.e. the notion that code points should have semantic value is simply wrong.<p>Should a cyrillic `а` and a latin `a` have the same code point?<p>If they did then there&#x27;s no consistent way to group those two alphabets, one or the other would end up with letters outside it&#x27;s main grouping.<p>And what happens if the shapes of those two characters divege over time? Do you have a breaking change to introduce a new code point for one of the languages, or do you just make it impossible to have a font that can be used for both latin and cyrillic at the same time?<p>This isn&#x27;t just a theoretical problem, by the way. There are characters in Chinese and Japanese that share a code point but the shapes of the characters aren&#x27;t the same in the two languages.</div><br/><div id="39222845" class="c"><input type="checkbox" id="c-39222845" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39219016">parent</a><span>|</span><a href="#39218652">next</a><span>|</span><label class="collapse" for="c-39222845">[-]</label><label class="expand" for="c-39222845">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Should a cyrillic `а` and a latin `a` have the same code point?<p>Yes. Consider a book. Can you tell if it&#x27;s a cyrillic or a latin `a`? Of course you can, because of the context. Unicode is about visible text, having hidden semantic meaning makes it something else.<p>Besides, &#x27;a&#x27; can have all kinds of semantic meanings - all depending on the context in which they are used. There is no way to encode all this into Unicode.<p>&gt; If they did then there&#x27;s no consistent way to group those two alphabets<p>Doesn&#x27;t matter.<p>&gt; And what happens if the shapes of those two characters divege over time?<p>If it actually looks different, then it becomes a different code point.<p>&gt; There are characters in Chinese and Japanese that share a code point but the shapes of the characters aren&#x27;t the same in the two languages<p>More evidence that the Unicode committee lost its way.<p>Think of it this way. Printing Unicode text on a piece of paper, and then OCRing it back into Unicode, should be a lossless operation. Or another way - anyone should be able to tell what the code point value is by looking at the visual representation of it.</div><br/><div id="39223570" class="c"><input type="checkbox" id="c-39223570" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39222845">parent</a><span>|</span><a href="#39223687">next</a><span>|</span><label class="collapse" for="c-39223570">[-]</label><label class="expand" for="c-39223570">[4 more]</label></div><br/><div class="children"><div class="content">How about an l and an I? Or a closed &quot;a&quot; and one with the little handle? A zero with a stroke, a zero without a stroke, and an O?<p>I can see where you&#x27;re coming from, but deduplicating every glyph from every culture based on which do or don&#x27;t generally look the same when printed sounds like a tall order. And if all you want to record is the shape, you can use a PNG with OCR and bypass Unicode entirely.</div><br/><div id="39224570" class="c"><input type="checkbox" id="c-39224570" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39223570">parent</a><span>|</span><a href="#39223687">next</a><span>|</span><label class="collapse" for="c-39224570">[-]</label><label class="expand" for="c-39224570">[3 more]</label></div><br/><div class="children"><div class="content">&gt; How about an l and an I? Or a closed &quot;a&quot; and one with the little handle? A zero with a stroke, a zero without a stroke, and an O?<p>Those are font differences, not character differences. (Unicode has also failed by adding in some fonts. The nuttiness never ends.)</div><br/><div id="39224918" class="c"><input type="checkbox" id="c-39224918" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39224570">parent</a><span>|</span><a href="#39223687">next</a><span>|</span><label class="collapse" for="c-39224918">[-]</label><label class="expand" for="c-39224918">[2 more]</label></div><br/><div class="children"><div class="content">But just as the “a” in alphabet and the «а» in азбука are only distinguishable by context, so too the “O” in SOS and the 0 in 90210 are often only distinguishable by context. I don’t see how you propose to determine which glyphs should be the same and which should be different in your system.</div><br/><div id="39225634" class="c"><input type="checkbox" id="c-39225634" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39224918">parent</a><span>|</span><a href="#39223687">next</a><span>|</span><label class="collapse" for="c-39225634">[-]</label><label class="expand" for="c-39225634">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so too the “O” in SOS and the 0 in 90210 are often only distinguishable by context<p>Only if it&#x27;s a bad font.</div><br/></div></div></div></div></div></div></div></div><div id="39223687" class="c"><input type="checkbox" id="c-39223687" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39222845">parent</a><span>|</span><a href="#39223570">prev</a><span>|</span><a href="#39218652">next</a><span>|</span><label class="collapse" for="c-39223687">[-]</label><label class="expand" for="c-39223687">[2 more]</label></div><br/><div class="children"><div class="content">How does your scheme handle Turkish &quot;Dotless I&quot;?<p>Should there be different codepoints for serif and sans-serif versions of the same letter?  After all, in some typefaces, &quot;uppercase I&quot; and &quot;lowercase L&quot; look just about the same.</div><br/><div id="39224574" class="c"><input type="checkbox" id="c-39224574" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39218135">root</a><span>|</span><a href="#39223687">parent</a><span>|</span><a href="#39218652">next</a><span>|</span><label class="collapse" for="c-39224574">[-]</label><label class="expand" for="c-39224574">[1 more]</label></div><br/><div class="children"><div class="content">I think you mean fonts. No, Unicode should not encode fonts.<p>Nor should it encode italic, boldface, underline, line out, reverse video, point size, superscript, subscript, or colored. Those are all style attributes, best applied with a style sheet, not a code point.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39218652" class="c"><input type="checkbox" id="c-39218652" checked=""/><div class="controls bullet"><span class="by">AeroNotix</span><span>|</span><a href="#39218135">prev</a><span>|</span><a href="#39217687">next</a><span>|</span><label class="collapse" for="c-39218652">[-]</label><label class="expand" for="c-39218652">[8 more]</label></div><br/><div class="children"><div class="content">Essentially zero people read complex commit messages.<p>Do with this information what you will.<p>9&#x2F;10 the code already is documentation enough for what the code currently does, if you need to go back through history then look at the commits. The messages are generally noise.<p>I&#x27;ve literally never cared _why_ someone made a change, I can see the change, I can see the effect of the old and new code. Rarely, if ever, has the thought process ever changed how I will interact with the code in question.<p>If I am at the level of debugging or history spelunking that the _commit message_ is the thing that saves me - I&#x27;ve already lost and there are other glaring organizational or design issues that are the actual problem.</div><br/><div id="39218785" class="c"><input type="checkbox" id="c-39218785" checked=""/><div class="controls bullet"><span class="by">advisedwang</span><span>|</span><a href="#39218652">parent</a><span>|</span><a href="#39220368">next</a><span>|</span><label class="collapse" for="c-39218785">[-]</label><label class="expand" for="c-39218785">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Essentially zero people read complex commit messages<p>I don&#x27;t think that&#x27;s true. I worked in support doing break&#x2F;fix and outage response work at a large organization. That means constantly dipping into codebases I&#x27;m utterly unfamiliar with. Often there is complexity, un-obvious elements, previous incorrect attempts at a bugfix and so on, where understanding what the author intended can save literal hours of examination, experimentation etc.<p>&gt; If I am at the level of debugging or history spelunking that the _commit message_ is the thing that saves me - I&#x27;ve already lost and there are other glaring organizational or design issues that are the actual problem.<p>This is kind of understanding what I mean, but there was no organizational or design failing here. This is just the nature of some work, I believe.</div><br/><div id="39218892" class="c"><input type="checkbox" id="c-39218892" checked=""/><div class="controls bullet"><span class="by">AeroNotix</span><span>|</span><a href="#39218652">root</a><span>|</span><a href="#39218785">parent</a><span>|</span><a href="#39220368">next</a><span>|</span><label class="collapse" for="c-39218892">[-]</label><label class="expand" for="c-39218892">[5 more]</label></div><br/><div class="children"><div class="content">&gt; [..]  where understanding what the author intended can save literal hours of examination, experimentation etc.<p>The problem with that it that you are relying on an inherently unreliable source of information - a human to enter details which may or may not lead you to the correct path.<p>The code doesn&#x27;t &quot;lie&quot;. Just read it and the current issue and work from there.</div><br/><div id="39219294" class="c"><input type="checkbox" id="c-39219294" checked=""/><div class="controls bullet"><span class="by">jotaen</span><span>|</span><a href="#39218652">root</a><span>|</span><a href="#39218892">parent</a><span>|</span><a href="#39221486">next</a><span>|</span><label class="collapse" for="c-39219294">[-]</label><label class="expand" for="c-39219294">[1 more]</label></div><br/><div class="children"><div class="content">The code may tell you <i>what</i> it does, but that doesn’t necessarily tell you <i>why</i> it’s there.<p>Especially for non-obvious pieces of code I have to deal with, I certainly prefer to understand the original reasoning and context within 5 minutes by looking at the original commit &#x2F; PR, than having to spend multiple hours rediscovering that one quirky edge-case scenario that someone else already dealt with 3 years ago.</div><br/></div></div><div id="39221486" class="c"><input type="checkbox" id="c-39221486" checked=""/><div class="controls bullet"><span class="by">advisedwang</span><span>|</span><a href="#39218652">root</a><span>|</span><a href="#39218892">parent</a><span>|</span><a href="#39219294">prev</a><span>|</span><a href="#39219273">next</a><span>|</span><label class="collapse" for="c-39221486">[-]</label><label class="expand" for="c-39221486">[1 more]</label></div><br/><div class="children"><div class="content">Code doesn&#x27;t lie, but it isn&#x27;t always obvious either. A diff that fixes a subtle corner case is very difficult to understand without explanation. A function to fix dirty external data cannot be understood without reference to what the author is fixing. It may not be clear why a certain performance trade-off is preferable.  A mistake may be hard to detect if you don&#x27;t know what was intended.</div><br/></div></div><div id="39219273" class="c"><input type="checkbox" id="c-39219273" checked=""/><div class="controls bullet"><span class="by">gray_-_wolf</span><span>|</span><a href="#39218652">root</a><span>|</span><a href="#39218892">parent</a><span>|</span><a href="#39221486">prev</a><span>|</span><a href="#39220389">next</a><span>|</span><label class="collapse" for="c-39219273">[-]</label><label class="expand" for="c-39219273">[1 more]</label></div><br/><div class="children"><div class="content">The code might not lie, but is also does not tell you <i>why</i> the DNS record in your IaC was changed from 1.2.3.4 to 4.3.2.1...<p>Well written commit messages are useful.  Some people use issue tracking system instead, but commit message should have the information in more concentrated form instead of spread over 50+ messages of discussion.</div><br/></div></div><div id="39220389" class="c"><input type="checkbox" id="c-39220389" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39218652">root</a><span>|</span><a href="#39218892">parent</a><span>|</span><a href="#39219273">prev</a><span>|</span><a href="#39220368">next</a><span>|</span><label class="collapse" for="c-39220389">[-]</label><label class="expand" for="c-39220389">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The code doesn&#x27;t &quot;lie&quot;. Just read it</i><p>No thanks.  Some diffs aren&#x27;t obvious.  I&#x27;m not a mind reader.  Having extra context is useful.</div><br/></div></div></div></div></div></div><div id="39220368" class="c"><input type="checkbox" id="c-39220368" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39218652">parent</a><span>|</span><a href="#39218785">prev</a><span>|</span><a href="#39217687">next</a><span>|</span><label class="collapse" for="c-39220368">[-]</label><label class="expand" for="c-39220368">[1 more]</label></div><br/><div class="children"><div class="content">Even if it&#x27;s true that essentially zero people read complex commit messages, that one person who needs to read it, 2 years later, will really appreciate its existence.<p>To me a commit message isn&#x27;t there so someone can sit around and read commit messages to tell themselves a story.  It&#x27;s there in the -- hopefully unlikely -- possibility that there&#x27;s a problem with the change, and someone needs to come back to it later, with no context, and understand why it was made so they can figure out what needs to be done.<p>I&#x27;ve absolutely used commit messages when debugging, and I don&#x27;t think there&#x27;s anything wrong with that.</div><br/></div></div></div></div><div id="39218564" class="c"><input type="checkbox" id="c-39218564" checked=""/><div class="controls bullet"><span class="by">mo_42</span><span>|</span><a href="#39217687">prev</a><span>|</span><a href="#39220880">next</a><span>|</span><label class="collapse" for="c-39218564">[-]</label><label class="expand" for="c-39218564">[2 more]</label></div><br/><div class="children"><div class="content">I have a different opinion about favourite Git commit messages.<p>I think commits should be small steps that display the thought process of the author. Every individual commit should be self-explanatory. So the commit message should not describe (again) what the changes are but why it’s necessary. Sometimes the change is not self-explanatory and then I&#x27;d put a longer description below.<p>Somehow I came up with this on my own, so I&#x27;d be interested if it really makes sense or if others have a similar style.</div><br/><div id="39220269" class="c"><input type="checkbox" id="c-39220269" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39218564">parent</a><span>|</span><a href="#39220880">next</a><span>|</span><label class="collapse" for="c-39220269">[-]</label><label class="expand" for="c-39220269">[1 more]</label></div><br/><div class="children"><div class="content">I just don&#x27;t think this is feasible, and I think you&#x27;re maybe over-estimating the diff-reading skills of others.  I agree that changes should be as small and self-contained as possible, but I don&#x27;t think it&#x27;s reasonable to expect a later diff-reader to be able to understand what the change is just by looking at it.<p>Certainly a commit message should include the why, but it should include -- start with, really -- the what as well.</div><br/></div></div></div></div><div id="39220880" class="c"><input type="checkbox" id="c-39220880" checked=""/><div class="controls bullet"><span class="by">daitangio</span><span>|</span><a href="#39218564">prev</a><span>|</span><label class="collapse" for="c-39220880">[-]</label><label class="expand" for="c-39220880">[1 more]</label></div><br/><div class="children"><div class="content">A good commit message must explain the reason of the commit (i.e. fix nasty char dncoding issue).
This commit is nice but far too long in my humble opinion (and I like to write!)
The what is already in the commit diff.
Explain the why, trust me.</div><br/></div></div></div></div></div></div></div></body></html>