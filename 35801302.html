<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683277251026" as="style"/><link rel="stylesheet" href="styles.css?v=1683277251026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://verdagon.dev/blog/first-100k-lines">How to Survive Your Project&#x27;s First 100k Lines</a> <span class="domain">(<a href="https://verdagon.dev">verdagon.dev</a>)</span></div><div class="subtext"><span>swah</span> | <span>52 comments</span></div><br/><div><div id="35826678" class="c"><input type="checkbox" id="c-35826678" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#35825321">next</a><span>|</span><label class="collapse" for="c-35826678">[-]</label><label class="expand" for="c-35826678">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the better articles (of this type of content) that I&#x27;ve read in a while.<p>Pushing implicit logic towards types, keeping non-determinism&#x2F;impurities at the edges of your program by asserting around edges is a <i>massive</i> win.<p>The only language that encourage this type of programming (as in it&#x27;s idiomatic across the ecosystem) whilst still keeping compile times down is OCaml.</div><br/></div></div><div id="35825321" class="c"><input type="checkbox" id="c-35825321" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#35826678">prev</a><span>|</span><a href="#35823789">next</a><span>|</span><label class="collapse" for="c-35825321">[-]</label><label class="expand" for="c-35825321">[5 more]</label></div><br/><div class="children"><div class="content">Regarding assertions:<p>The sections &quot;If you think you&#x27;re using enough assertions, you&#x27;re wrong&quot; and &quot;Bonus: Sanity Checking&quot; can be considered a subset of &quot;Design by Contract&quot;[0].<p>Regarding:<p><pre><code>  However, comments can become out-of-date, and you might
  not be lucky enough to stumble across the right comment
  before you embark on a refactoring adventure.
</code></pre>
Not if comments are treated as first-class citizens, just as important as the code change(s) which make them out-dated.  Better still is to ensure unit tests are &quot;executable documentation&quot;[1].<p>Regarding &quot;Prefer end-to-end tests&quot;:<p>In my experience, this leads to unit test atrophy, degrading system verification to rely solely on integration tests (&quot;end-to-end tests&quot;).  This has often resulted in higher coupling and always resulted in interminable build times.<p>0 - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Design_by_contract" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Design_by_contract</a><p>1 - <a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;154615&#x2F;are-unit-tests-really-used-as-documentation" rel="nofollow">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;1546...</a></div><br/><div id="35826681" class="c"><input type="checkbox" id="c-35826681" checked=""/><div class="controls bullet"><span class="by">MoreQARespect</span><span>|</span><a href="#35825321">parent</a><span>|</span><a href="#35826075">next</a><span>|</span><label class="collapse" for="c-35826681">[-]</label><label class="expand" for="c-35826681">[1 more]</label></div><br/><div class="children"><div class="content">End to end tests by definition are more loosely coupled.<p>They are better as executable documentation - mapping to actual user flows and able to generate docs (videos, screenshots, etc.).<p>They&#x27;re slower, but it&#x27;s easy enough to parallelize and cache.<p>Unit tests will often just mirror the behavior of the code. This is not useful.</div><br/></div></div><div id="35826075" class="c"><input type="checkbox" id="c-35826075" checked=""/><div class="controls bullet"><span class="by">forgotmypw17</span><span>|</span><a href="#35825321">parent</a><span>|</span><a href="#35826681">prev</a><span>|</span><a href="#35823789">next</a><span>|</span><label class="collapse" for="c-35826075">[-]</label><label class="expand" for="c-35826075">[3 more]</label></div><br/><div class="children"><div class="content">A comment with first class citizen status is an assert?</div><br/><div id="35826375" class="c"><input type="checkbox" id="c-35826375" checked=""/><div class="controls bullet"><span class="by">sideshowb</span><span>|</span><a href="#35825321">root</a><span>|</span><a href="#35826075">parent</a><span>|</span><a href="#35823789">next</a><span>|</span><label class="collapse" for="c-35826375">[-]</label><label class="expand" for="c-35826375">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen an assert explain why</div><br/><div id="35826515" class="c"><input type="checkbox" id="c-35826515" checked=""/><div class="controls bullet"><span class="by">tleb_</span><span>|</span><a href="#35825321">root</a><span>|</span><a href="#35826375">parent</a><span>|</span><a href="#35823789">next</a><span>|</span><label class="collapse" for="c-35826515">[-]</label><label class="expand" for="c-35826515">[1 more]</label></div><br/><div class="children"><div class="content">The signature for static_assert(3) in C has a second argument that is `char *msg`. With C23 onwards, it becomes optional.</div><br/></div></div></div></div></div></div></div></div><div id="35823789" class="c"><input type="checkbox" id="c-35823789" checked=""/><div class="controls bullet"><span class="by">stephendause</span><span>|</span><a href="#35825321">prev</a><span>|</span><a href="#35826206">next</a><span>|</span><label class="collapse" for="c-35823789">[-]</label><label class="expand" for="c-35823789">[31 more]</label></div><br/><div class="children"><div class="content">&gt; Use a language with good compile speeds.<p>This is an interesting suggestion to me. Honestly, I consider a lot of other things like type safety and ergonomics of the language before I think about compile speed if at all.<p>However, that&#x27;s not to say it&#x27;s irrelevant. Perhaps I should be thinking about it more. I did notice that they didn&#x27;t suggest any particular language with this comment. Compile speed seems like a difficult thing to compare between languages in general, since it would be difficult to make a genuine apples to apples comparison.</div><br/><div id="35824913" class="c"><input type="checkbox" id="c-35824913" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35824011">next</a><span>|</span><label class="collapse" for="c-35824913">[-]</label><label class="expand" for="c-35824913">[8 more]</label></div><br/><div class="children"><div class="content">I think a fast compile is essential.<p>I&#x27;ve worked on projects with slow and fast compiles, and man, it&#x27;s a completely different world. The way you think about problems and approach them, the way you approach adding new code, it&#x27;s just completely different.<p>Slow compile times makes the entire process of adding, changing, or debugging the code slower. It makes it painful, frustrating, and more confusing. It&#x27;s nonlinear. Doubling the time to compile a project can quadruple the time to solve problems, in my experience.</div><br/><div id="35825731" class="c"><input type="checkbox" id="c-35825731" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824913">parent</a><span>|</span><a href="#35824011">next</a><span>|</span><label class="collapse" for="c-35825731">[-]</label><label class="expand" for="c-35825731">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Doubling the time to compile a project can quadruple the time to solve problems, in my experience.<p>My experience has been somewhat opposite.<p>Long compile times lead you to put more thought into your program, roughly (obviously I&#x27;m way over generalizing here, it&#x27;s actually the language itself that causes this but I&#x27;m waving my hands and positing that there&#x27;s a rough correlation between compile speeds and language formality). Slow compile times mean you&#x27;re not thinking about how your problem is modeled formally and just kinda gluing things together and seeing what happens at runtime.<p>While quick compile times may get you a system that kinda works more quickly than a language with slow compile times, in my experience you have to iterate much much before the problem is truly solved. When I user slower languages I find myself iterating fewer times before the problem is usefully solved. Not to mention I spend far less time fixing bugs.<p>Maybe it&#x27;s all a wash, but slow languages definitely <i>do not</i> result in a quadratic slowdown in productivity...</div><br/><div id="35826497" class="c"><input type="checkbox" id="c-35826497" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825731">parent</a><span>|</span><a href="#35825776">next</a><span>|</span><label class="collapse" for="c-35826497">[-]</label><label class="expand" for="c-35826497">[1 more]</label></div><br/><div class="children"><div class="content">I dunno. I don&#x27;t think this should be down-voted into the ground. But I think it&#x27;s more nuanced.<p>Quick compile times may in some circumstances enable a sort of mentality of trial-and-error that I think is relatively common, but I don&#x27;t think is a good approach to software development.<p>On the other hand, I don&#x27;t think slow compile times are necessary to prevent this. Slow builds arguably more often lead to frustration and context switching. That isn&#x27;t good either.<p>I think the best option is to have fast builds but also have enough discipline to not write code by trial and error.</div><br/></div></div><div id="35825776" class="c"><input type="checkbox" id="c-35825776" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825731">parent</a><span>|</span><a href="#35826497">prev</a><span>|</span><a href="#35825919">next</a><span>|</span><label class="collapse" for="c-35825776">[-]</label><label class="expand" for="c-35825776">[1 more]</label></div><br/><div class="children"><div class="content">The trade off here assumes a “barely working prototype” is undesirable and only the bug free end result is the goal.<p>Most projects I’ve worked on though, <i>especially</i> in their first few 100k lines of code didn’t really know exactly what problem are they trying to solve. Having something that kinda works in front if stakeholders &#x2F; customers has been invaluable in actually getting the feedback and not wasting dev cycles on features nobody actually wanted.<p>Though granted “going back and doing things properly” has been as hard to achieve as “have complete requirements upfront”, so what do I know :-D</div><br/></div></div><div id="35825919" class="c"><input type="checkbox" id="c-35825919" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825731">parent</a><span>|</span><a href="#35825776">prev</a><span>|</span><a href="#35824011">next</a><span>|</span><label class="collapse" for="c-35825919">[-]</label><label class="expand" for="c-35825919">[4 more]</label></div><br/><div class="children"><div class="content">We should go back to punch cards, then. We&#x27;ll obviously have much higher quality software.</div><br/><div id="35826085" class="c"><input type="checkbox" id="c-35826085" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825919">parent</a><span>|</span><a href="#35824011">next</a><span>|</span><label class="collapse" for="c-35826085">[-]</label><label class="expand" for="c-35826085">[3 more]</label></div><br/><div class="children"><div class="content">You joke, but bugs in your punchcard program were a royal PITA, so people spent more time making sure they were correct before going through the work of punching them out. I&#x27;ve heard this from a first hand source.</div><br/><div id="35826374" class="c"><input type="checkbox" id="c-35826374" checked=""/><div class="controls bullet"><span class="by">biorach</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35826085">parent</a><span>|</span><a href="#35826396">next</a><span>|</span><label class="collapse" for="c-35826374">[-]</label><label class="expand" for="c-35826374">[1 more]</label></div><br/><div class="children"><div class="content">Yep, but they still had bugs,  and often the minimum turn-around time was 24 hours.  So it does not sound like a net positive</div><br/></div></div><div id="35826396" class="c"><input type="checkbox" id="c-35826396" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35826085">parent</a><span>|</span><a href="#35826374">prev</a><span>|</span><a href="#35824011">next</a><span>|</span><label class="collapse" for="c-35826396">[-]</label><label class="expand" for="c-35826396">[1 more]</label></div><br/><div class="children"><div class="content">Quality is not lack of bugs. That&#x27;s a component, maybe.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35824011" class="c"><input type="checkbox" id="c-35824011" checked=""/><div class="controls bullet"><span class="by">imadj</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35824913">prev</a><span>|</span><a href="#35826048">next</a><span>|</span><label class="collapse" for="c-35824011">[-]</label><label class="expand" for="c-35824011">[16 more]</label></div><br/><div class="children"><div class="content">&gt; I consider a lot of other things like type safety and ergonomics of the language before I think about compile speed if at all<p>I believe the good compile speed is hinting at having shorter feedback loops in your workflow, and how it can significantly boost your productivity<p>It&#x27;s something you&#x27;ll do often and can have hidden costs. Especially with cases when it takes half an hour to build a software.</div><br/><div id="35824210" class="c"><input type="checkbox" id="c-35824210" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824011">parent</a><span>|</span><a href="#35825741">next</a><span>|</span><label class="collapse" for="c-35824210">[-]</label><label class="expand" for="c-35824210">[1 more]</label></div><br/><div class="children"><div class="content">The number of engineers I&#x27;ve met that don&#x27;t know how to run a single test or single test file and wait minutes for 1000&#x27;s of tests to run is mind-boggling to me. Like, how do you get anything done?</div><br/></div></div><div id="35825741" class="c"><input type="checkbox" id="c-35825741" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824011">parent</a><span>|</span><a href="#35824210">prev</a><span>|</span><a href="#35824117">next</a><span>|</span><label class="collapse" for="c-35825741">[-]</label><label class="expand" for="c-35825741">[2 more]</label></div><br/><div class="children"><div class="content">productivity, or <i>perceived</i> productivity?</div><br/><div id="35826368" class="c"><input type="checkbox" id="c-35826368" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825741">parent</a><span>|</span><a href="#35824117">next</a><span>|</span><label class="collapse" for="c-35826368">[-]</label><label class="expand" for="c-35826368">[1 more]</label></div><br/><div class="children"><div class="content">productivity.</div><br/></div></div></div></div><div id="35824117" class="c"><input type="checkbox" id="c-35824117" checked=""/><div class="controls bullet"><span class="by">dimitrios1</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824011">parent</a><span>|</span><a href="#35825741">prev</a><span>|</span><a href="#35826048">next</a><span>|</span><label class="collapse" for="c-35824117">[-]</label><label class="expand" for="c-35824117">[12 more]</label></div><br/><div class="children"><div class="content">I believe it&#x27;s mostly just a direct jab at C++. Almost every other language has fast or fast enough compilation speeds.</div><br/><div id="35825565" class="c"><input type="checkbox" id="c-35825565" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824117">parent</a><span>|</span><a href="#35824177">next</a><span>|</span><label class="collapse" for="c-35825565">[-]</label><label class="expand" for="c-35825565">[2 more]</label></div><br/><div class="children"><div class="content">Scala can be very slow.<p>I’ve also worked on Java &#x2F; Spring Boot projects that seem to take 10s of seconds to compile, and even longer to start up.<p>And TypeScript too.<p>I suspect the latter two have simple options which could improve things significantly, but I haven’t dug in.</div><br/><div id="35826610" class="c"><input type="checkbox" id="c-35826610" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825565">parent</a><span>|</span><a href="#35824177">next</a><span>|</span><label class="collapse" for="c-35826610">[-]</label><label class="expand" for="c-35826610">[1 more]</label></div><br/><div class="children"><div class="content">Java is very much what you make of it. Spring Boot tends to pull in everything and the kitchen sink, and the atrocious build and start times are a fairly logical consequence.<p>Vanilla Java can be very quick to start and build, especially if you do incremental builds.<p>In my search engine project which is ~50kloc I have incremental builds that can be as fast as 1-2 seconds including running all pertinent tests[1], and the start time for the stuff that doesn&#x27;t like populate an 12 Gb hashmap in memory upon start-up is also single digit seconds.<p>[1] A clean rebuild is 37 seconds; 108 seconds with a full suite of tests. That&#x27;s fairly tolerable IMO. I&#x27;ve horror stories of Java builds that have had compile times anywhere between 15 and 45 minutes.</div><br/></div></div></div></div><div id="35824177" class="c"><input type="checkbox" id="c-35824177" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824117">parent</a><span>|</span><a href="#35825565">prev</a><span>|</span><a href="#35825611">next</a><span>|</span><label class="collapse" for="c-35824177">[-]</label><label class="expand" for="c-35824177">[6 more]</label></div><br/><div class="children"><div class="content">Rust sends its regards.</div><br/><div id="35825470" class="c"><input type="checkbox" id="c-35825470" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824177">parent</a><span>|</span><a href="#35824566">next</a><span>|</span><label class="collapse" for="c-35825470">[-]</label><label class="expand" for="c-35825470">[2 more]</label></div><br/><div class="children"><div class="content">Everyone says this but I&#x27;ve yet for it to ever actually be a problem.</div><br/><div id="35825965" class="c"><input type="checkbox" id="c-35825965" checked=""/><div class="controls bullet"><span class="by">earthling8118</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35825470">parent</a><span>|</span><a href="#35824566">next</a><span>|</span><label class="collapse" for="c-35825965">[-]</label><label class="expand" for="c-35825965">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because it isn&#x27;t unless you have a very exceptional case or maybe you make a mega-crate. I was rocking a severely outdated processor and it was slightly annoying, but not that bad at all. And once the dependencies are built it was a non-issue. With a more modern CPU the times are miniscule.</div><br/></div></div></div></div><div id="35824566" class="c"><input type="checkbox" id="c-35824566" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824177">parent</a><span>|</span><a href="#35825470">prev</a><span>|</span><a href="#35825611">next</a><span>|</span><label class="collapse" for="c-35824566">[-]</label><label class="expand" for="c-35824566">[3 more]</label></div><br/><div class="children"><div class="content">So does kotlin</div><br/><div id="35824779" class="c"><input type="checkbox" id="c-35824779" checked=""/><div class="controls bullet"><span class="by">andrekandre</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824566">parent</a><span>|</span><a href="#35825611">next</a><span>|</span><label class="collapse" for="c-35824779">[-]</label><label class="expand" for="c-35824779">[2 more]</label></div><br/><div class="children"><div class="content">swift too...</div><br/><div id="35824875" class="c"><input type="checkbox" id="c-35824875" checked=""/><div class="controls bullet"><span class="by">streakfix</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824779">parent</a><span>|</span><a href="#35825611">next</a><span>|</span><label class="collapse" for="c-35824875">[-]</label><label class="expand" for="c-35824875">[1 more]</label></div><br/><div class="children"><div class="content">Javascript too</div><br/></div></div></div></div></div></div></div></div><div id="35825611" class="c"><input type="checkbox" id="c-35825611" checked=""/><div class="controls bullet"><span class="by">rvense</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824117">parent</a><span>|</span><a href="#35824177">prev</a><span>|</span><a href="#35824526">next</a><span>|</span><label class="collapse" for="c-35825611">[-]</label><label class="expand" for="c-35825611">[1 more]</label></div><br/><div class="children"><div class="content">The Typescript&#x2F;Angular project I dayjob on sometimes takes minutes to compile, depending on whatever optimization settings the last Angular update has changed&#x2F;messed up. (The compilation also frequently spins out of control until it OOMs.)</div><br/></div></div><div id="35824526" class="c"><input type="checkbox" id="c-35824526" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824117">parent</a><span>|</span><a href="#35825611">prev</a><span>|</span><a href="#35825939">next</a><span>|</span><label class="collapse" for="c-35824526">[-]</label><label class="expand" for="c-35824526">[1 more]</label></div><br/><div class="children"><div class="content">Any language that uses an LLVM backend is dog slow.</div><br/></div></div><div id="35825939" class="c"><input type="checkbox" id="c-35825939" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#35823789">root</a><span>|</span><a href="#35824117">parent</a><span>|</span><a href="#35824526">prev</a><span>|</span><a href="#35826048">next</a><span>|</span><label class="collapse" for="c-35825939">[-]</label><label class="expand" for="c-35825939">[1 more]</label></div><br/><div class="children"><div class="content">C++ actually has pretty competitive compilation speeds, barring metaprogramming, up to a point.</div><br/></div></div></div></div></div></div><div id="35826048" class="c"><input type="checkbox" id="c-35826048" checked=""/><div class="controls bullet"><span class="by">easeout</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35824011">prev</a><span>|</span><a href="#35825906">next</a><span>|</span><label class="collapse" for="c-35826048">[-]</label><label class="expand" for="c-35826048">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say, use a toolchain that gives you rapid iteration to the point that you try to keep up with it, rather than the other way around. For instance a hot reloading workflow has been common for web apps for some years, but in native mobile we&#x27;ve only recently gained the capability via the preview canvas for SwiftUI. That makes a huge difference even though Swift is a big step down in compile speed from its predecessor.</div><br/></div></div><div id="35825906" class="c"><input type="checkbox" id="c-35825906" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35826048">prev</a><span>|</span><a href="#35825401">next</a><span>|</span><label class="collapse" for="c-35825906">[-]</label><label class="expand" for="c-35825906">[1 more]</label></div><br/><div class="children"><div class="content">The fact is the complexity in most valuable systems is interacting with other external systems.<p>Your system can be as type safe as it wants. It will never be type safe when tied to the systems of other companies, no matter what they say, or how they say their apis are supposed to work (assuming you have documented apis at all).<p>Being able to iterate quickly and test those connections is far more valuable to most businesses. At a certain scale, it probably flips, but at that point you&#x27;re a huge company.</div><br/></div></div><div id="35825401" class="c"><input type="checkbox" id="c-35825401" checked=""/><div class="controls bullet"><span class="by">sixstringtheory</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35825906">prev</a><span>|</span><a href="#35824699">next</a><span>|</span><label class="collapse" for="c-35825401">[-]</label><label class="expand" for="c-35825401">[1 more]</label></div><br/><div class="children"><div class="content">There’s also modularization to compartmentalize recompilation, reducing the overall time to rebuild for any given change. CI can cache compiled modules.<p>This then kicks the can down the road to the linker, and there’s been some work in this area as well with projects like mold.</div><br/></div></div><div id="35824699" class="c"><input type="checkbox" id="c-35824699" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35825401">prev</a><span>|</span><a href="#35824698">next</a><span>|</span><label class="collapse" for="c-35824699">[-]</label><label class="expand" for="c-35824699">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I agree. I think what matters more is IDE speed (which includes syntax and partial compile to some degree). Then comes incremental compile which should be fast or at least exist. and then comes compiletimes in general.<p>Also: compiletimes are not a property of just languages. It also depends how you use them. And languages with few guards and guarantees (like Go) of course compile faster - but you pay the price later.</div><br/></div></div><div id="35824698" class="c"><input type="checkbox" id="c-35824698" checked=""/><div class="controls bullet"><span class="by">omneity</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35824699">prev</a><span>|</span><a href="#35825015">next</a><span>|</span><label class="collapse" for="c-35824698">[-]</label><label class="expand" for="c-35824698">[1 more]</label></div><br/><div class="children"><div class="content">It might be that you didn’t encounter this as a problem before.<p>In its earlier days, changing a single character in a typescript codebase implied a trip to the kitchen.<p>Now TS compilation is decently fast but intellisense became the bottleneck.</div><br/></div></div><div id="35825015" class="c"><input type="checkbox" id="c-35825015" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#35823789">parent</a><span>|</span><a href="#35824698">prev</a><span>|</span><a href="#35826206">next</a><span>|</span><label class="collapse" for="c-35825015">[-]</label><label class="expand" for="c-35825015">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re all using languages that need to be compiled?</div><br/></div></div></div></div><div id="35826206" class="c"><input type="checkbox" id="c-35826206" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#35823789">prev</a><span>|</span><a href="#35823788">next</a><span>|</span><label class="collapse" for="c-35826206">[-]</label><label class="expand" for="c-35826206">[1 more]</label></div><br/><div class="children"><div class="content">There is some very good advice in here for when you reach medium size.  I found myself nodding along, saying of course, happy to see someone write all this up so well, good reference...<p>Until the fast turn around time item came around, and I knew exactly why my current work was bothering me.  I gues sometimes you need to be whacked around the ears with a checklist of stuff you should know, before you realize something&#x27;s off.</div><br/></div></div><div id="35823788" class="c"><input type="checkbox" id="c-35823788" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#35826206">prev</a><span>|</span><a href="#35825078">next</a><span>|</span><label class="collapse" for="c-35823788">[-]</label><label class="expand" for="c-35823788">[2 more]</label></div><br/><div class="children"><div class="content">About the first advice, if we’re talking about Rust, it might be a good idea to turn a number of assertions into debug_assert, so that it does not affect performance during prod. Of course it’s almost always not the case that you would want to not fail in prod, but sometimes you KNOW that an assert will HAVE TO be triggered in tests.<p>Another way to think about this is that there’s three kind of errors:<p>- recoverable (return Err)<p>- unrecoverable (debug assert)<p>- unrecoverable and tricky (assert)</div><br/><div id="35824091" class="c"><input type="checkbox" id="c-35824091" checked=""/><div class="controls bullet"><span class="by">slashdev</span><span>|</span><a href="#35823788">parent</a><span>|</span><a href="#35825078">next</a><span>|</span><label class="collapse" for="c-35824091">[-]</label><label class="expand" for="c-35824091">[1 more]</label></div><br/><div class="children"><div class="content">Assertions are often free or nearly so. On modern out of order processors, it’s a fully predictable branch and a cheap assertion that nothing depends on. So the pipeline is unaffected and there’s usually a cheap test that often is completely free because there’s spare capacity.<p>If the assert tests something expensive, I will usually switch to a debug assert.</div><br/></div></div></div></div><div id="35825078" class="c"><input type="checkbox" id="c-35825078" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#35823788">prev</a><span>|</span><a href="#35823597">next</a><span>|</span><label class="collapse" for="c-35825078">[-]</label><label class="expand" for="c-35825078">[1 more]</label></div><br/><div class="children"><div class="content">Another tip that helped my compiler. A compiler usually has passes which are optional (optimization) or things that can be done one or another way. Like a pass that can come befor or after another pass. Inputs that can be processed from left to right or right to left etc.. It is quick and easy to make flags for all these variants. Than run the integration tests with different flags.<p>Another tip, validation pass. If you have a (complex) data structure like an IR. Create a validation pass, which becomes the specification, of what exactly is legal in this data structure. This is like an assert on steroids.<p>And.. have a bigger use case at hand. Integration tests are great, but also have a real world case that can be run.</div><br/></div></div><div id="35823597" class="c"><input type="checkbox" id="c-35823597" checked=""/><div class="controls bullet"><span class="by">slondr</span><span>|</span><a href="#35825078">prev</a><span>|</span><a href="#35824858">next</a><span>|</span><label class="collapse" for="c-35823597">[-]</label><label class="expand" for="c-35823597">[2 more]</label></div><br/><div class="children"><div class="content">Good advice in here. The focus on assertion-oriented programming is interesting. Erlang doesn&#x27;t have assertions available in application code directly, but I think structure-enforced assignments are really similar in practice.</div><br/><div id="35826012" class="c"><input type="checkbox" id="c-35826012" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#35823597">parent</a><span>|</span><a href="#35824858">next</a><span>|</span><label class="collapse" for="c-35826012">[-]</label><label class="expand" for="c-35826012">[1 more]</label></div><br/><div class="children"><div class="content">Yes! The reasoning behind &#x27;let it crash&#x27; is just this; assume happy path destructuring (effectively asserts) and let the supervisor(s) decide what happens to a process that crashes.<p>Now you have very explicit expectations and contracts on data, yet the code is very straight forward and easy to reason about. Layering OTP on top means you can now decide how you react to one-off errors and when you&#x27;re drowning in bad data.<p>I love it.</div><br/></div></div></div></div><div id="35824858" class="c"><input type="checkbox" id="c-35824858" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#35823597">prev</a><span>|</span><a href="#35824518">next</a><span>|</span><label class="collapse" for="c-35824858">[-]</label><label class="expand" for="c-35824858">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add one more tip that I think far more software developers should do: Add unit-level fuzz testing throughout your projects. Fuzzy bois are like assertions on steroids.<p>With large projects you often get modules which have an API boundary, complex internals and clear rules for what correct &#x2F; incorrect look like. For example, data structures or some complex algorithms. (A-star, or whatever).<p>Every time I have a system like this, I&#x27;m now in the habit of writing 3 pieces of code:<p>1. A function that checks the internal invariants are true. Eg, in a Vec, the allocated length should be &gt;= the current length. In a sorted tree, if you iterate through the items, they&#x27;re sorted. And children are always &gt;= the internal nodes (or whatever the rules are for your tree). During development, I wrap my state mutators in check() calls. This means I know instantly if one of my mutating functions has broken something. (This is a godsend for debugging.)<p>2. A function which randomly exercises the code, in a loop. Eg, if you&#x27;re writing a hash table, write a function which creates a hash table and randomly inserts and deletes items in a loop for awhile. If you&#x27;ve implemented a search algorithm, generate random data and run searches on it. Most complex algorithms and data structures have simple ways to tell if the return value of a query is correct. So check everything. For example, a sorted tree should contain the same items in the same order as a sorted list. Its just faster. So if you&#x27;re writing a sorted tree, have your randomizer also maintain a sorted list and then periodically check that the sorted list contains the same items in the same order as your tree. If you&#x27;re writing A-star, check that an inefficient flood fill search returns the same result. Your randomizer should always be explicitly seeded so when it finds problems you can easily and deterministically reproduce them.<p>3. A test which calls the randomizer over and over again, and checks all the invariants are correct. When this can run overnight with optimizations enabled, your code is probably ok. There&#x27;s a bunch of delicate performance balances to strike here - its easy to spend too much CPU time checking your invariants. If you do that, you won&#x27;t find rare bugs because your test won&#x27;t run enough times. I often end up with something like this:<p><pre><code>    loop (ideally on all cores) {
        generate random seed
        initialize a new Foo
        for i in 0..100 {
            randomly make foo more complicated
            (at first check invariants here)
        }
        (then later move invariants here)
    }
</code></pre>
Every piece of a large program should be tested like this. And if you can, test your whole program like this too. (Doable for most libraries, databases, compilers, etc. This is much harder for graphics engines or UI code.)<p>I&#x27;ve been doing this for years and I can&#x27;t remember a <i>single time</i> I set something like this up and didn&#x27;t find bugs. I&#x27;m constantly humbled by how effective fuzzy bois are.<p>This sounds complex, but code like this will usually be much smaller and easier to maintain than a thorough unit testing suite.<p>Here&#x27;s an example from a rope (complex string) library I maintain. The library lets you insert or delete characters in a string at arbitrary locations. The randomizer loop is here[1]. I make Rope and a String, then in a loop make random changes and then call check() to make sure the contents match and all the internal invariants hold.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;jumprope-rs&#x2F;blob&#x2F;ae2a3f3c2bc7fc1fcf4b5e2f04031d785ade9a26&#x2F;tests&#x2F;test.rs#L357-L428">https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;jumprope-rs&#x2F;blob&#x2F;ae2a3f3c2bc7fc1f...</a><p>When I first ran this test, it found a handful of bugs in my code. I also ran this same code on a few rust rope libraries in cargo. About half of them fail this test.</div><br/><div id="35825359" class="c"><input type="checkbox" id="c-35825359" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#35824858">parent</a><span>|</span><a href="#35825088">next</a><span>|</span><label class="collapse" for="c-35825359">[-]</label><label class="expand" for="c-35825359">[1 more]</label></div><br/><div class="children"><div class="content">Regarding numbers 2 and 3, I believe you are describing &quot;property-based testing&quot;[0].  A Scala version of this is ScalaCheck and can be found here[1].<p>There appears to be at least one Rust library which claims to provide same, but I am not a Rust developer so cannot recommend any for fitness of purpose.<p>0 - <a href="https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;what-is-property-based-testing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;what-is-property-based-tes...</a><p>1 - <a href="https:&#x2F;&#x2F;github.com&#x2F;typelevel&#x2F;scalacheck&#x2F;blob&#x2F;main&#x2F;doc&#x2F;UserGuide.md">https:&#x2F;&#x2F;github.com&#x2F;typelevel&#x2F;scalacheck&#x2F;blob&#x2F;main&#x2F;doc&#x2F;UserGu...</a></div><br/></div></div><div id="35825088" class="c"><input type="checkbox" id="c-35825088" checked=""/><div class="controls bullet"><span class="by">vgatherps</span><span>|</span><a href="#35824858">parent</a><span>|</span><a href="#35825359">prev</a><span>|</span><a href="#35824518">next</a><span>|</span><label class="collapse" for="c-35825088">[-]</label><label class="expand" for="c-35825088">[1 more]</label></div><br/><div class="children"><div class="content">Agree with the above, will add that proper fuzzing is worth it quite often also.<p>If your ecosystem has tooling for structured fuzzing (or it&#x27;s easy for you to fuzz from a raw series of bytes), fuzzers are relatively effort to add and very powerful.</div><br/></div></div></div></div><div id="35824518" class="c"><input type="checkbox" id="c-35824518" checked=""/><div class="controls bullet"><span class="by">ohwellhere</span><span>|</span><a href="#35824858">prev</a><span>|</span><a href="#35824145">next</a><span>|</span><label class="collapse" for="c-35824518">[-]</label><label class="expand" for="c-35824518">[2 more]</label></div><br/><div class="children"><div class="content">Has anyone used Vale or have any thoughts on it?<p>(That&#x27;s my main curiosity after reading the post and clicking around. It looks neat but I&#x27;m just hearing of it.)</div><br/><div id="35824554" class="c"><input type="checkbox" id="c-35824554" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#35824518">parent</a><span>|</span><a href="#35824145">next</a><span>|</span><label class="collapse" for="c-35824554">[-]</label><label class="expand" for="c-35824554">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;vale.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vale.dev&#x2F;</a> for anybody else who might not have heard of it</div><br/></div></div></div></div><div id="35824583" class="c"><input type="checkbox" id="c-35824583" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#35824145">prev</a><span>|</span><label class="collapse" for="c-35824583">[-]</label><label class="expand" for="c-35824583">[2 more]</label></div><br/><div class="children"><div class="content">,,Dependency injection (the pattern, not the kind of framework)<p>Encapsulation<p>Polymorphism&#x27;&#x27;<p>These were just thrown in, but they both make the code less readable and less performant if they are not really needed.<p>In my experience while having separation of concerns is critical for software development, the only way to find the right interface for that separation is trial and error.<p>Iterating on the interface between layers is the most important part of software development.</div><br/><div id="35824650" class="c"><input type="checkbox" id="c-35824650" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#35824583">parent</a><span>|</span><label class="collapse" for="c-35824650">[-]</label><label class="expand" for="c-35824650">[1 more]</label></div><br/><div class="children"><div class="content">Those first two principles help promote simpler and more stable APIs, which is a must for large projects with many teams. If you iterate on the interface between large enough layers, it ends up anywhere between &quot;very costly migration&quot; and &quot;breaking change&quot;.<p>In a smaller project though, then yeah, it&#x27;s better to just refactor away one&#x27;s woes. Like you said, if it&#x27;s not really needed, they can have their drawbacks.</div><br/></div></div></div></div></div></div></div></div></div></body></html>