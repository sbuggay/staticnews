<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692867663432" as="style"/><link rel="stylesheet" href="styles.css?v=1692867663432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bun.sh/blog/bun-v0.8.0">Bun v0.8</a> <span class="domain">(<a href="https://bun.sh">bun.sh</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>81 comments</span></div><br/><div><div id="37245604" class="c"><input type="checkbox" id="c-37245604" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#37244236">next</a><span>|</span><label class="collapse" for="c-37245604">[-]</label><label class="expand" for="c-37245604">[5 more]</label></div><br/><div class="children"><div class="content">We provide both bun and deno as typescript runtimes for windmill.dev (oss retool alternative) and we get overwhelming feedback that people are confused by the little changes required to adapt to deno and would rather just stick to the node.js mode aka bun. Now that bun is getting close to 1:1 node.js support, I predict we will see a lot more bun everywhere.<p>@Jarred was super responsive to help me adapt bun to our distributed cache storage, so all props to him.</div><br/><div id="37246288" class="c"><input type="checkbox" id="c-37246288" checked=""/><div class="controls bullet"><span class="by">mogoh</span><span>|</span><a href="#37245604">parent</a><span>|</span><a href="#37245857">next</a><span>|</span><label class="collapse" for="c-37246288">[-]</label><label class="expand" for="c-37246288">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s sad. Deno is great.</div><br/></div></div><div id="37245857" class="c"><input type="checkbox" id="c-37245857" checked=""/><div class="controls bullet"><span class="by">antran22</span><span>|</span><a href="#37245604">parent</a><span>|</span><a href="#37246288">prev</a><span>|</span><a href="#37245722">next</a><span>|</span><label class="collapse" for="c-37245857">[-]</label><label class="expand" for="c-37245857">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for building Windmill. I spin up a test instance and was blown away by the well-designed-ness.<p>I&#x27;m looking to investigate using Windmill as a website builder for some small internal system. Few questions:
- Is it possible to setup custom path for flows (to hack it into a REST API)
- How can we go and make authenticated flow</div><br/></div></div><div id="37245722" class="c"><input type="checkbox" id="c-37245722" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#37245604">parent</a><span>|</span><a href="#37245857">prev</a><span>|</span><a href="#37244236">next</a><span>|</span><label class="collapse" for="c-37245722">[-]</label><label class="expand" for="c-37245722">[2 more]</label></div><br/><div class="children"><div class="content">windmill.dev looks really interesting. Does it have support for javascript as well as typescript?</div><br/><div id="37245768" class="c"><input type="checkbox" id="c-37245768" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#37245604">root</a><span>|</span><a href="#37245722">parent</a><span>|</span><a href="#37244236">next</a><span>|</span><label class="collapse" for="c-37245768">[-]</label><label class="expand" for="c-37245768">[1 more]</label></div><br/><div class="children"><div class="content">Yes since typescript is a superset of javascript and our runtimes support it (you can run javascript with bun)</div><br/></div></div></div></div></div></div><div id="37244236" class="c"><input type="checkbox" id="c-37244236" checked=""/><div class="controls bullet"><span class="by">Jarred</span><span>|</span><a href="#37245604">prev</a><span>|</span><a href="#37246188">next</a><span>|</span><label class="collapse" for="c-37244236">[-]</label><label class="expand" for="c-37244236">[60 more]</label></div><br/><div class="children"><div class="content">I work on Bun - happy to answer any questions</div><br/><div id="37244523" class="c"><input type="checkbox" id="c-37244523" checked=""/><div class="controls bullet"><span class="by">stephen</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244270">next</a><span>|</span><label class="collapse" for="c-37244523">[-]</label><label class="expand" for="c-37244523">[15 more]</label></div><br/><div class="children"><div class="content">Hi! I saw your PR review of a community effort to add Bun to the Techempower benchmark. You had really great, exact feedback about &quot;unnecessary allocation here&quot;, &quot;unnecessary allocation there&quot;.<p>It was eye-opening, in terms of how often us JS programmers play fast &amp; loose with &quot;a little filter&quot; here, &quot;a little map&quot; there, and end up with death by a thousand allocations.<p>Given that context, I&#x27;m curious:<p>1) How much you think Bun&#x27;s (super-appreciated!) fanatical OCD about optimizing everything &quot;up to &amp; outside of JSC&quot; will translate to the post-boot performance of everyday backend apps, and<p>2) If you&#x27;re tempted&#x2F;could be compelled :-D to create a &quot;Mojo of TypeScript&quot;, where you do a collab with Anders Hejlsberg to create some sort of &quot;TypeScript-ish&quot; language that, if a TS programmer plays by a stricter set of rules + relies on the latest borrowing inference magic, we could bring some of the Bun amazing-performance ethos to the current idiomatic FP&#x2F;JS&#x2F;TS style that is &quot;lol allocations everywhere&quot;. :-)<p>Or, maybe with Bun bringing the right native&#x2F;HTTP&#x2F;etc libraries wrapped around the core runtime, doing &quot;just the business logic&quot; in JS really won&#x27;t be that bad? Which iirc was the theory&#x2F;assertion of just-js when its author was benchmark hacking Techempower, and got pretty far with that approach.<p>Anyway, thanks for Bun! We&#x27;re not running on it yet, but it&#x27;s on the todo list. :-)</div><br/><div id="37245310" class="c"><input type="checkbox" id="c-37245310" checked=""/><div class="controls bullet"><span class="by">vorticalbox</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244523">parent</a><span>|</span><a href="#37244882">next</a><span>|</span><label class="collapse" for="c-37245310">[-]</label><label class="expand" for="c-37245310">[9 more]</label></div><br/><div class="children"><div class="content">&gt; us JS programmers play fast &amp; loose with &quot;a little filter&quot; here, &quot;a little map&quot; there, and end up with death by a thousand allocations.<p>That&#x27;s because speed isn&#x27;t always top priority. Readability is very high on the list.<p>I would rather have a slightly slower .map or .filter in a chain than a harder to read nested for or while loop.</div><br/><div id="37246499" class="c"><input type="checkbox" id="c-37246499" checked=""/><div class="controls bullet"><span class="by">intellix</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37245717">next</a><span>|</span><label class="collapse" for="c-37246499">[-]</label><label class="expand" for="c-37246499">[1 more]</label></div><br/><div class="children"><div class="content">yeah, cause fixing the missing index on your DB that adds 3 seconds to an API call is better than optimising loops to save 2ms.<p>In the front-end we were making about 20 API calls to fetch data we probably don&#x27;t need yet and the developer is like: the problem has to exist in the way we call them, time to optimise the loops!</div><br/></div></div><div id="37245717" class="c"><input type="checkbox" id="c-37245717" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37246499">prev</a><span>|</span><a href="#37246127">next</a><span>|</span><label class="collapse" for="c-37245717">[-]</label><label class="expand" for="c-37245717">[2 more]</label></div><br/><div class="children"><div class="content">This just shows again that readability is entirely subjective, IMHO combinations of .map, .filter, .reduce, etc are often less readable than doing the same thing in a nested loop.</div><br/><div id="37246113" class="c"><input type="checkbox" id="c-37246113" checked=""/><div class="controls bullet"><span class="by">vorticalbox</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245717">parent</a><span>|</span><a href="#37246127">next</a><span>|</span><label class="collapse" for="c-37246113">[-]</label><label class="expand" for="c-37246113">[1 more]</label></div><br/><div class="children"><div class="content">This is true I code very functional style in javascript but I can see how that might be harder to read for some.</div><br/></div></div></div></div><div id="37246127" class="c"><input type="checkbox" id="c-37246127" checked=""/><div class="controls bullet"><span class="by">ughitsaaron</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37245717">prev</a><span>|</span><a href="#37245445">next</a><span>|</span><label class="collapse" for="c-37246127">[-]</label><label class="expand" for="c-37246127">[1 more]</label></div><br/><div class="children"><div class="content">The fact of un-readability isn’t necessarily implied by the statement being replied to. `map` and `filter` are names for common operations on lists, not less performant alternatives other things. If there’s a more performant alternative to either operation, give it a name and express it in a function. That’s what functions are for, no?</div><br/></div></div><div id="37245445" class="c"><input type="checkbox" id="c-37245445" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37246127">prev</a><span>|</span><a href="#37245581">next</a><span>|</span><label class="collapse" for="c-37245445">[-]</label><label class="expand" for="c-37245445">[1 more]</label></div><br/><div class="children"><div class="content">A nested for or while loop isn&#x27;t <i>always</i> less readable FWIW.  If you need more than 3-4 filters and&#x2F;or maps the balance starts shifting back the other way.</div><br/></div></div><div id="37245581" class="c"><input type="checkbox" id="c-37245581" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37245445">prev</a><span>|</span><a href="#37245381">next</a><span>|</span><label class="collapse" for="c-37245581">[-]</label><label class="expand" for="c-37245581">[1 more]</label></div><br/><div class="children"><div class="content">Well-factored code often reveals more important optimizations one can make. Like figuring out the nested loop isn&#x27;t really necessary.</div><br/></div></div><div id="37245381" class="c"><input type="checkbox" id="c-37245381" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245310">parent</a><span>|</span><a href="#37245581">prev</a><span>|</span><a href="#37244882">next</a><span>|</span><label class="collapse" for="c-37245381">[-]</label><label class="expand" for="c-37245381">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, besides Javascript runs to client side so let client deal with bad perf. I am happy writing my beautifully designed readable code.</div><br/><div id="37246060" class="c"><input type="checkbox" id="c-37246060" checked=""/><div class="controls bullet"><span class="by">ranguna</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245381">parent</a><span>|</span><a href="#37244882">next</a><span>|</span><label class="collapse" for="c-37246060">[-]</label><label class="expand" for="c-37246060">[1 more]</label></div><br/><div class="children"><div class="content">Javascript also runs on server side.</div><br/></div></div></div></div></div></div><div id="37244882" class="c"><input type="checkbox" id="c-37244882" checked=""/><div class="controls bullet"><span class="by">polyrand</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244523">parent</a><span>|</span><a href="#37245310">prev</a><span>|</span><a href="#37245275">next</a><span>|</span><label class="collapse" for="c-37244882">[-]</label><label class="expand" for="c-37244882">[1 more]</label></div><br/><div class="children"><div class="content">PR link: <a href="https:&#x2F;&#x2F;github.com&#x2F;TechEmpower&#x2F;FrameworkBenchmarks&#x2F;pull&#x2F;8337">https:&#x2F;&#x2F;github.com&#x2F;TechEmpower&#x2F;FrameworkBenchmarks&#x2F;pull&#x2F;8337</a></div><br/></div></div><div id="37245275" class="c"><input type="checkbox" id="c-37245275" checked=""/><div class="controls bullet"><span class="by">dapperdrake</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244523">parent</a><span>|</span><a href="#37244882">prev</a><span>|</span><a href="#37244858">next</a><span>|</span><label class="collapse" for="c-37245275">[-]</label><label class="expand" for="c-37245275">[2 more]</label></div><br/><div class="children"><div class="content">Concerning stephen&#x27;s item (2).
The stricter set of rules was laid out by Richard C. Waters
in Optimization of Series Expressions: Part I: User&#x27;s Manual for the Series Macro Package, page 46 (document page 48).  See reference Waters(1989a).<p>The paper&#x27;s language is a bit different than contemporary (2023) language.<p>`map()` is called `map-fn`.<p>`reduce()` a.k.a. `fold` seems to be `collect-fn`, although `collecting-fn`
also seems interesting.<p>sorting, uniqueness and permutation seem to be covered by `producing`.<p>Just think of McIlroy&#x27;s famous pipeline in response to Donald Knuth&#x27;s trie implementation[mcilroy-source]:<p><pre><code>  tr -cs A-Za-z &#x27;\n&#x27; |
  tr A-Z a-z |
  sort |
  uniq -c |
  sort -rn |
  sed ${1}q
</code></pre>
As far as pipeline or stream processing diagrams are concerned, the diagram on page 13 (document page 15) of Waters(1989a) may also be worth a closer look.<p>What the SERIES compiler does is pipeline the loops.  Think of a UNIX shell
pipeline.  Think of streaming results.  Waters calls this pre-order processing.
This also seems to be where Rich Hickey got the term &quot;transducer&quot; from.
In short it means dropping unnecessary intermediate list or array allocations.<p>Shameless self-plug:  Eliminated unnecessary allocations in my JavaScript code
by adding support for SERIES to the PARENSCRIPT Common Lisp to JavaScript
compiler.  The trick was (1) to define (series-expand ...) on series expressions so that they can be passed into (parenscript:ps ...) and (2) the parenscript
compiler was missing (tagbody ... (go ...) ...) support.  The latter is
surprisingly tricky to implement.  See dapperdrake(2023).  Apologies for
the less than perfect blog post.  Got busy actually using this tool.
Suddenly stream processing is easy, and maintainable.<p>When adding a Hylang-style threading macro (-&gt; ...) you get UNIX style
pipelines without unnecessary allocations.  It looks similar to this:<p><pre><code>  (-&gt; (it :let*-symbol series::let)
    (scan-file in-path-name #&#x27;read)
    (map-fn T #&#x27;some-function it)
    (collect &#x27;list it))
</code></pre>
Sadly, the SERIES compiler available on quicklisp right now is a
bit arcane to use.  It seems like it may have been more user friendly
if it would have been integrated into the ANSI Common Lisp 1995 standard
so that is has access to compiler internals.  The trick seems to be to
use macros instead of (series::defun ...) and use (series::let ...) instead of (cl:let ...).  Note, that the two crucial symbols &#x27;defun and &#x27;let
are <i>not</i> exported by SERIES.  So using the package is insufficient
and pipelining fails without a decent warning.<p>Am chewing on the SERIES source code.  It is available on sourceforge. [series-source].
If anybody is interested in porting it, then please reach out.
It seems to be of similar importance as Google&#x27;s V8 relooper algorithm [relooper-reference].
Waters(1989b), page 27 (document page 29) even demonstrates an implementation for Pascal.  So it is possible.<p>References:<p>dapperdrake(2023): Faster Loops in JavaScript
<a href="https:&#x2F;&#x2F;dapperdrake.neocities.org&#x2F;faster-loops-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;dapperdrake.neocities.org&#x2F;faster-loops-javascript</a><p>Waters(1989a)
document page 48, paper page 46
<a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;6035&#x2F;AIM-1082.pdf?sequence=2&amp;isAllowed=y#page=48" rel="nofollow noreferrer">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;6035&#x2F;AIM-1082...</a><p>Waters(1989b)
document page 29, paper page 27
<a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;6031&#x2F;AIM-1083.pdf?sequence=2&amp;isAllowed=y#page=29" rel="nofollow noreferrer">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;bitstream&#x2F;handle&#x2F;1721.1&#x2F;6031&#x2F;AIM-1083...</a><p>[relooper-reference]
<a href="http:&#x2F;&#x2F;troubles.md&#x2F;why-do-we-need-the-relooper-algorithm-again&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;troubles.md&#x2F;why-do-we-need-the-relooper-algorithm-aga...</a><p>[series-source]
<a href="https:&#x2F;&#x2F;series.sourceforge.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;series.sourceforge.net&#x2F;</a><p>[mcilroy-source]
<a href="https:&#x2F;&#x2F;franklinchen.com&#x2F;blog&#x2F;2011&#x2F;12&#x2F;08&#x2F;revisiting-knuth-and-mcilroys-word-count-programs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;franklinchen.com&#x2F;blog&#x2F;2011&#x2F;12&#x2F;08&#x2F;revisiting-knuth-an...</a></div><br/><div id="37245567" class="c"><input type="checkbox" id="c-37245567" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245275">parent</a><span>|</span><a href="#37244858">next</a><span>|</span><label class="collapse" for="c-37245567">[-]</label><label class="expand" for="c-37245567">[1 more]</label></div><br/><div class="children"><div class="content">The paper about Series explicitly bemoans the lack of compiler integration, explaining why the hacks are that way: why Series has its own implementations of <i>let</i> and so on.</div><br/></div></div></div></div><div id="37244858" class="c"><input type="checkbox" id="c-37244858" checked=""/><div class="controls bullet"><span class="by">genuine_smiles</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244523">parent</a><span>|</span><a href="#37245275">prev</a><span>|</span><a href="#37244593">next</a><span>|</span><label class="collapse" for="c-37244858">[-]</label><label class="expand" for="c-37244858">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone have a link to the PR?</div><br/></div></div><div id="37244593" class="c"><input type="checkbox" id="c-37244593" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244523">parent</a><span>|</span><a href="#37244858">prev</a><span>|</span><a href="#37244270">next</a><span>|</span><label class="collapse" for="c-37244593">[-]</label><label class="expand" for="c-37244593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; PR review of a community effort to add Bun to the Techempower benchmark<p>Has this been added? That PR got closed right? Whilst valid, it was sad that Bun didn&#x27;t make it. Would be good if someone from the community or Bun team can give it another go.</div><br/></div></div></div></div><div id="37244270" class="c"><input type="checkbox" id="c-37244270" checked=""/><div class="controls bullet"><span class="by">tsujp</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244523">prev</a><span>|</span><a href="#37246397">next</a><span>|</span><label class="collapse" for="c-37244270">[-]</label><label class="expand" for="c-37244270">[3 more]</label></div><br/><div class="children"><div class="content">Hey Jarred, big fan of your work on Bun.<p>Until recently I&#x27;ve been using Deno (mostly to avoid using Node and the tooling hell that entails) and it looks like for my use-cases Bun is getting there. I&#x27;ve had a pleasant experience using Bun as the basis of a test harness.<p>Here&#x27;s my question (with a tiny bit of lead-in):<p>What I like about Deno is the integrated LSP (reducing tooling hell), are there any plans for Bun to feature this too? Bun already internally transpiles TypeScript which is great but having the LSP bundled too would give this single binary integrated experience a boon I feel.<p>Looking forward to Bun 1.0!<p>P.S. I&#x27;m starting to stretch my Zig muscles, you looking for Zig developers? ;)</div><br/><div id="37245630" class="c"><input type="checkbox" id="c-37245630" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244270">parent</a><span>|</span><a href="#37246018">next</a><span>|</span><label class="collapse" for="c-37245630">[-]</label><label class="expand" for="c-37245630">[1 more]</label></div><br/><div class="children"><div class="content">You can pretty much use tsserver with bun-types and get most if not all the features you get from deno-lsp. I know because we provide both deno-lsp and tsserver for windmill.dev to provide intellisense over websocket&#x2F;jsonrpc for our monaco webide at windmill.dev and it works great :)</div><br/></div></div><div id="37246018" class="c"><input type="checkbox" id="c-37246018" checked=""/><div class="controls bullet"><span class="by">twohaibei</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244270">parent</a><span>|</span><a href="#37245630">prev</a><span>|</span><a href="#37246397">next</a><span>|</span><label class="collapse" for="c-37246018">[-]</label><label class="expand" for="c-37246018">[1 more]</label></div><br/><div class="children"><div class="content">Friendly warning about expected working conditions: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;lukeshiru&#x2F;status&#x2F;1563493902560428034" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;lukeshiru&#x2F;status&#x2F;1563493902560428034</a></div><br/></div></div></div></div><div id="37246397" class="c"><input type="checkbox" id="c-37246397" checked=""/><div class="controls bullet"><span class="by">altano</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244270">prev</a><span>|</span><a href="#37244460">next</a><span>|</span><label class="collapse" for="c-37246397">[-]</label><label class="expand" for="c-37246397">[1 more]</label></div><br/><div class="children"><div class="content">Hey Jarred, any idea where the bundler + React server components fall in the priority list? Colin&#x27;s post[1] made me excited about the idea of having a lightweight RSC compiler&#x2F;bundler built into bun. I&#x27;m curious when it&#x27;ll be considered usable and ready for experimentation.<p>[1] <a href="https:&#x2F;&#x2F;bun.sh&#x2F;blog&#x2F;server-components-in-bun" rel="nofollow noreferrer">https:&#x2F;&#x2F;bun.sh&#x2F;blog&#x2F;server-components-in-bun</a></div><br/></div></div><div id="37244460" class="c"><input type="checkbox" id="c-37244460" checked=""/><div class="controls bullet"><span class="by">dj_gitmo</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37246397">prev</a><span>|</span><a href="#37244289">next</a><span>|</span><label class="collapse" for="c-37244460">[-]</label><label class="expand" for="c-37244460">[2 more]</label></div><br/><div class="children"><div class="content">From <a href="https:&#x2F;&#x2F;oven.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;oven.sh&#x2F;</a><p>&gt; The plan is to run our own servers on the edge in datacenters around the world. Oven will leverage end-to-end integration of the entire JavaScript stack (down to the hardware) to make new things possible.<p>So how does oven-sh the company make money? It sounds like you release Bun open source, and then sell access to your edge infrastructure to enterprises?<p>Is these edge servers basically a running a smarter version of NPM with a CDN? Can you say more about what this may eventually do?<p>Will individuals be able to use the edge servers via some free tier?<p>Does Bun in it&#x27;s current form use this edge infrastructure already?</div><br/><div id="37244648" class="c"><input type="checkbox" id="c-37244648" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244460">parent</a><span>|</span><a href="#37244289">next</a><span>|</span><label class="collapse" for="c-37244648">[-]</label><label class="expand" for="c-37244648">[1 more]</label></div><br/><div class="children"><div class="content">Same as Deno, Vercel, and many others; Oven will host your backend JS code for you and run it.</div><br/></div></div></div></div><div id="37244289" class="c"><input type="checkbox" id="c-37244289" checked=""/><div class="controls bullet"><span class="by">dead_alchemy</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244460">prev</a><span>|</span><a href="#37246370">next</a><span>|</span><label class="collapse" for="c-37244289">[-]</label><label class="expand" for="c-37244289">[8 more]</label></div><br/><div class="children"><div class="content">Hey Jarred! Is windows support for 1.0 still on the horizon or has that been pushed? What’s been the best part of this project for you?</div><br/><div id="37244378" class="c"><input type="checkbox" id="c-37244378" checked=""/><div class="controls bullet"><span class="by">Jarred</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244289">parent</a><span>|</span><a href="#37246370">next</a><span>|</span><label class="collapse" for="c-37244378">[-]</label><label class="expand" for="c-37244378">[7 more]</label></div><br/><div class="children"><div class="content">The honest answer is: don&#x27;t know yet, but if it doesn&#x27;t happen in 1.0, it will be the priority for 1.1.<p>I&#x27;m going to do some experiments in the next few days and see how it goes.<p>Roughly, the way we&#x27;re thinking of adding Windows support to Bun is:<p>1) Get all the Zig code using platform-specific system APIs to use the closest Windows equivalent API. Fortunately, we have lots of code for handling UTF-16 strings (since that&#x27;s what JS uses in some cases)<p>2) Get uSockets&#x2F;uWebSockets (C&#x2F;C++ library we use for tcp &amp; http serve) to compile for Windows, or fall back to using libuv if it takes too long to make it work<p>3) Get the rest of the dependencies to compile on Windows<p>4) Fix bugs and perf issues<p>There are a lot of open questions though. None of us are super familiar with I&#x2F;O  on Windows. JavaScriptCore doesn&#x27;t have WebAssembly enabled on Windows yet.<p>The biggest thing I&#x27;m worried about (other than time) re: Windows is async i&#x2F;o. In Bun, we _mostly_ use synchronous I&#x2F;O. Synchronous I&#x2F;O is simpler and when using SSDs, is often meaningfully lower overhead than the work necessary to make it async. I&#x27;ve heard that anti-virus software will often block I&#x2F;O for potentially seconds, which means that using sync I&#x2F;O at all is a super bad idea for performance in Windows (if this is true). If that is true, then making it fast will be difficult in cases where we need to do lots of filesystem lookups (like module resolution)</div><br/><div id="37246242" class="c"><input type="checkbox" id="c-37246242" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244378">parent</a><span>|</span><a href="#37245409">next</a><span>|</span><label class="collapse" for="c-37246242">[-]</label><label class="expand" for="c-37246242">[1 more]</label></div><br/><div class="children"><div class="content">Sync IO is probably fine on Windows with the exception of CloseHandle, in which case Windows Defender or other AV will invoke a file filter in the kernel&#x27;s file I&#x2F;O filter stack to scan changes for data recently written to the file. A common approach used in Rust, version control software, and other runtimes is to defer file closing to a different thread to keep other I&#x2F;O and user-facing threads responsive. All that said, I think IOCP on Win32 is a far superior asynchronous programming model to the equivalent APIs on Linux which feel far less usable (with more footguns).</div><br/></div></div><div id="37245409" class="c"><input type="checkbox" id="c-37245409" checked=""/><div class="controls bullet"><span class="by">snnn</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244378">parent</a><span>|</span><a href="#37246242">prev</a><span>|</span><a href="#37244408">next</a><span>|</span><label class="collapse" for="c-37245409">[-]</label><label class="expand" for="c-37245409">[1 more]</label></div><br/><div class="children"><div class="content">On Windows you may consider using higher level IO routines. For example, for HTTP requests you can use WinHTTP which is super fast and scalable. For other IOs you can use Windows Thread Pool API(<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;procthread&#x2F;thread-pool-api" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;procthread&#x2F;t...</a>) so that you do not need to manually manage threads or register&#x2F;unregister IO handlers&#x2F;callbacks.  gRPC uses that.
Though Windows IOs internally are all async, actually it makes using sync I&#x2F;O easier and you do not need to say it is a super bad idea. Windows has IOCP. If the machine has n logical CPUs, you may create a thread pool with 2*n threads. And, by default the operating system will not make more than n threads active at the same time. When one of the threads is doing blocking IO and entered IO wait state, the OS will wake-up another thread and let it go. This is why the number of threads in the thread pool needs be larger than than the number of CPUs. This design doesn&#x27;t lead to an optimal solution, however, practically it works very well. In this setting you still have the flexibility to use async IOs, but it is not a sin to use sync IO in a blocking manner in a thread pool.<p>Disclaimer: I work at Microsoft and ship code to Windows, but the above are just my personal opinions.</div><br/></div></div><div id="37244408" class="c"><input type="checkbox" id="c-37244408" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244378">parent</a><span>|</span><a href="#37245409">prev</a><span>|</span><a href="#37246370">next</a><span>|</span><label class="collapse" for="c-37244408">[-]</label><label class="expand" for="c-37244408">[4 more]</label></div><br/><div class="children"><div class="content">Common misconception - it&#x27;s not opening or writing files that can take a second, it&#x27;s <i>closing</i> them.</div><br/><div id="37244429" class="c"><input type="checkbox" id="c-37244429" checked=""/><div class="controls bullet"><span class="by">Jarred</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244408">parent</a><span>|</span><a href="#37246370">next</a><span>|</span><label class="collapse" for="c-37244429">[-]</label><label class="expand" for="c-37244429">[3 more]</label></div><br/><div class="children"><div class="content">This definitely also used to be true on macOS. Bun previously would just request the max ulimit for file descriptors and then not close them. Most tools don&#x27;t realize there are hard and soft limits to file descriptors, and the hard limit is usually much higher.<p>On Linux, not closing file descriptors makes opening new ones on multiple threads occasionally lock for 30ms or more. Early versions of `bun build` were something like 5x slower on Linux compared to macOS until we narrowed down that the bug was caused by not closing file descriptors.</div><br/><div id="37245343" class="c"><input type="checkbox" id="c-37245343" checked=""/><div class="controls bullet"><span class="by">CoolCold</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244429">parent</a><span>|</span><a href="#37246370">next</a><span>|</span><label class="collapse" for="c-37245343">[-]</label><label class="expand" for="c-37245343">[2 more]</label></div><br/><div class="children"><div class="content">Here likely meant that system level hooks of antiviral software are invoked on CloseFile call when you do writes, not on OpenFile.<p>You may want to take a look on <a href="https:&#x2F;&#x2F;youtu.be&#x2F;qbKGw8MQ0i8?si=HO5b0MuljPQN9Sb2" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;qbKGw8MQ0i8?si=HO5b0MuljPQN9Sb2</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37246370" class="c"><input type="checkbox" id="c-37246370" checked=""/><div class="controls bullet"><span class="by">wdb</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244289">prev</a><span>|</span><a href="#37246021">next</a><span>|</span><label class="collapse" for="c-37246370">[-]</label><label class="expand" for="c-37246370">[1 more]</label></div><br/><div class="children"><div class="content">Nice. I should revisit whether Bun nowadays supports OpenTelemetry</div><br/></div></div><div id="37246021" class="c"><input type="checkbox" id="c-37246021" checked=""/><div class="controls bullet"><span class="by">LinguaBrowse</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37246370">prev</a><span>|</span><a href="#37244294">next</a><span>|</span><label class="collapse" for="c-37246021">[-]</label><label class="expand" for="c-37246021">[1 more]</label></div><br/><div class="children"><div class="content">Any plans for Bun on mobile in future? If so, any idea around how big it might be (sub-megabyte, multi-megabyte)?</div><br/></div></div><div id="37244294" class="c"><input type="checkbox" id="c-37244294" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37246021">prev</a><span>|</span><a href="#37244893">next</a><span>|</span><label class="collapse" for="c-37244294">[-]</label><label class="expand" for="c-37244294">[3 more]</label></div><br/><div class="children"><div class="content">When will Bun use an open standard like IRC, XMPP, or Matrix as a community chat option instead of being limited to usage of proprietary Discord &amp; subject to their ToS?</div><br/><div id="37244473" class="c"><input type="checkbox" id="c-37244473" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244294">parent</a><span>|</span><a href="#37244893">next</a><span>|</span><label class="collapse" for="c-37244473">[-]</label><label class="expand" for="c-37244473">[2 more]</label></div><br/><div class="children"><div class="content">When will a large enough fraction of users prefer that?</div><br/><div id="37244655" class="c"><input type="checkbox" id="c-37244655" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244473">parent</a><span>|</span><a href="#37244893">next</a><span>|</span><label class="collapse" for="c-37244655">[-]</label><label class="expand" for="c-37244655">[1 more]</label></div><br/><div class="children"><div class="content">The crowd that is blocked by sanctions, values privacy&#x2F;freedom, has certain accessibility needs third-party clients could provide, or doesn’t have powerful enough hardware or a big&#x2F;fast enough internet plan likely hasn’t been able to participate even if they wanted to. It’s a bad choice, and we see users get banned for weird, non-project-related reasons &amp; they lose access to the community due to the whims of the Discord corporation.</div><br/></div></div></div></div></div></div><div id="37244893" class="c"><input type="checkbox" id="c-37244893" checked=""/><div class="controls bullet"><span class="by">POiNTx</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244294">prev</a><span>|</span><a href="#37244520">next</a><span>|</span><label class="collapse" for="c-37244893">[-]</label><label class="expand" for="c-37244893">[2 more]</label></div><br/><div class="children"><div class="content">Bun is an executable as far as I understand. Would it be possible to call Bun directly from another language with bindings?<p>For example Erlang (and Elixir) has Native Implemented Functions[0] (NIF) where you can call native code directly from Erlang. Elixir has the zigler[1] project where you can call Zig code directly from Elixir.<p>Maybe you can see where I&#x27;m going with this, but it would be super cool to have the ability to call Javascript code from within Elixir. Especially when it comes to code that should be called on the server and client. I&#x27;m the developer of LiveSvelte[2] where we use Node to do SSR but it&#x27;s quite slow atm, and would be very cool to use Bun for something like this.<p>In any case Bun is super impressive, keep it up!<p>[0] <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;tutorial&#x2F;nif.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;tutorial&#x2F;nif.html</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;E-xyza&#x2F;zigler">https:&#x2F;&#x2F;github.com&#x2F;E-xyza&#x2F;zigler</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;woutdp&#x2F;live_svelte">https:&#x2F;&#x2F;github.com&#x2F;woutdp&#x2F;live_svelte</a></div><br/><div id="37244913" class="c"><input type="checkbox" id="c-37244913" checked=""/><div class="controls bullet"><span class="by">Jarred</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244893">parent</a><span>|</span><a href="#37244520">next</a><span>|</span><label class="collapse" for="c-37244913">[-]</label><label class="expand" for="c-37244913">[1 more]</label></div><br/><div class="children"><div class="content">Yes it would be possible, though it&#x27;d be easier to start in Bun and then call out to your executable from JavaScript via napi or bun:ffi</div><br/></div></div></div></div><div id="37244520" class="c"><input type="checkbox" id="c-37244520" checked=""/><div class="controls bullet"><span class="by">nikivi</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244893">prev</a><span>|</span><a href="#37245527">next</a><span>|</span><label class="collapse" for="c-37244520">[-]</label><label class="expand" for="c-37244520">[1 more]</label></div><br/><div class="children"><div class="content">Have you given thought what Bun 2.0 would look like? What major features it would have? Or 2.0 if it ever happens is mostly making Bun work &#x27;at the edge&#x27;?</div><br/></div></div><div id="37245527" class="c"><input type="checkbox" id="c-37245527" checked=""/><div class="controls bullet"><span class="by">NiekvdMaas</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244520">prev</a><span>|</span><a href="#37245296">next</a><span>|</span><label class="collapse" for="c-37245527">[-]</label><label class="expand" for="c-37245527">[1 more]</label></div><br/><div class="children"><div class="content">Are there any plans to enhance the bun compile functionality, e.g. bytecode generation? Similar to pkg in the node world. We use the latter to ship close-source binaries to customers.</div><br/></div></div><div id="37245296" class="c"><input type="checkbox" id="c-37245296" checked=""/><div class="controls bullet"><span class="by">tmikaeld</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37245527">prev</a><span>|</span><a href="#37244652">next</a><span>|</span><label class="collapse" for="c-37245296">[-]</label><label class="expand" for="c-37245296">[2 more]</label></div><br/><div class="children"><div class="content">Do you plan to support sandboxing like deno?<p>What is your view on the usefulness of sandboxing and why it was skipped for bun?</div><br/><div id="37245582" class="c"><input type="checkbox" id="c-37245582" checked=""/><div class="controls bullet"><span class="by">kevlened</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245296">parent</a><span>|</span><a href="#37244652">next</a><span>|</span><label class="collapse" for="c-37245582">[-]</label><label class="expand" for="c-37245582">[1 more]</label></div><br/><div class="children"><div class="content">While not implemented, Bun may eventually have an alternative to Deno&#x27;s sandboxing: <a href="https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;discussions&#x2F;725">https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;discussions&#x2F;725</a><p>&quot;Rather than runtime permission checks (Deno&#x27;s model) which could potentially have bugs that lead to permissions being ignored, Bun plans to have binary dead code elimination based on statically analyzing what features&#x2F;native modules are used by the code.&quot;</div><br/></div></div></div></div><div id="37244652" class="c"><input type="checkbox" id="c-37244652" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37245296">prev</a><span>|</span><a href="#37244530">next</a><span>|</span><label class="collapse" for="c-37244652">[-]</label><label class="expand" for="c-37244652">[5 more]</label></div><br/><div class="children"><div class="content">Curious why you chose Zig and not e.g. Rust.</div><br/><div id="37245401" class="c"><input type="checkbox" id="c-37245401" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244652">parent</a><span>|</span><a href="#37245021">next</a><span>|</span><label class="collapse" for="c-37245401">[-]</label><label class="expand" for="c-37245401">[2 more]</label></div><br/><div class="children"><div class="content">That will be your opportunity to open issue on project about RIIR (Rewrite It In Rust).</div><br/><div id="37245432" class="c"><input type="checkbox" id="c-37245432" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245401">parent</a><span>|</span><a href="#37245021">next</a><span>|</span><label class="collapse" for="c-37245432">[-]</label><label class="expand" for="c-37245432">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s Deno already if someone really wants their JS runtime in Rust. Personally, since everything just runs on a JIT JS runtime anyway, I don&#x27;t really see to much of a difference between Node, Deno, and Bun, it&#x27;s not like the JS is being AOT compiled via Zig or Rust, which would be very interesting, you could basically treat JS as a compiled language rather than an interpreted one, even if the JIT is already fast.</div><br/></div></div></div></div><div id="37245021" class="c"><input type="checkbox" id="c-37245021" checked=""/><div class="controls bullet"><span class="by">postalrat</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244652">parent</a><span>|</span><a href="#37245401">prev</a><span>|</span><a href="#37244530">next</a><span>|</span><label class="collapse" for="c-37245021">[-]</label><label class="expand" for="c-37245021">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m quite happy they did.</div><br/><div id="37245032" class="c"><input type="checkbox" id="c-37245032" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245021">parent</a><span>|</span><a href="#37244530">next</a><span>|</span><label class="collapse" for="c-37245032">[-]</label><label class="expand" for="c-37245032">[1 more]</label></div><br/><div class="children"><div class="content">Why is that?</div><br/></div></div></div></div></div></div><div id="37244530" class="c"><input type="checkbox" id="c-37244530" checked=""/><div class="controls bullet"><span class="by">meepmorp</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244652">prev</a><span>|</span><a href="#37244287">next</a><span>|</span><label class="collapse" for="c-37244530">[-]</label><label class="expand" for="c-37244530">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s zig like to work with? Did the lack of async in 0.11 mess you up?</div><br/></div></div><div id="37244287" class="c"><input type="checkbox" id="c-37244287" checked=""/><div class="controls bullet"><span class="by">guideamigo_com</span><span>|</span><a href="#37244236">parent</a><span>|</span><a href="#37244530">prev</a><span>|</span><a href="#37246188">next</a><span>|</span><label class="collapse" for="c-37244287">[-]</label><label class="expand" for="c-37244287">[13 more]</label></div><br/><div class="children"><div class="content">Why would someone use this over much more maintainable and performant backends in Go or Rust?</div><br/><div id="37244405" class="c"><input type="checkbox" id="c-37244405" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37245753">next</a><span>|</span><label class="collapse" for="c-37244405">[-]</label><label class="expand" for="c-37244405">[5 more]</label></div><br/><div class="children"><div class="content">Define performant and define maintainable.<p>If you have a lot of duplicated functionality in a web frontend and backend, it may be a lot more maintainable to do the development once and not have to keep two implementations in sync.<p>As far as performance, if you’re using one of the JS application frameworks with server-side pre-rendering time to interactivity may very well be faster than anything you can build in Go or Rust.</div><br/><div id="37244513" class="c"><input type="checkbox" id="c-37244513" checked=""/><div class="controls bullet"><span class="by">LorenzoGood</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244405">parent</a><span>|</span><a href="#37245753">next</a><span>|</span><label class="collapse" for="c-37244513">[-]</label><label class="expand" for="c-37244513">[4 more]</label></div><br/><div class="children"><div class="content">There is no way that a js ssr framework is faster than a go ssr template renderer.</div><br/><div id="37244570" class="c"><input type="checkbox" id="c-37244570" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244513">parent</a><span>|</span><a href="#37245753">next</a><span>|</span><label class="collapse" for="c-37244570">[-]</label><label class="expand" for="c-37244570">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re building in plain Go with pure SSR, sure, but OP is talking about building a React frontend that is pre-rendered server-side. TTI very well could be faster with that than with a React front end that talks to a Go backend.</div><br/><div id="37245972" class="c"><input type="checkbox" id="c-37245972" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244570">parent</a><span>|</span><a href="#37245753">next</a><span>|</span><label class="collapse" for="c-37245972">[-]</label><label class="expand" for="c-37245972">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of lost here. It&#x27;s been ages since I wrote anything frontend related so here the question: how does it matter?<p>I mean unless you have pure front end app - you are still going to talk to some backend. Regardless of how  you got your frontend part - generated by the server or a static file served by nginx.</div><br/><div id="37246521" class="c"><input type="checkbox" id="c-37246521" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245972">parent</a><span>|</span><a href="#37245753">next</a><span>|</span><label class="collapse" for="c-37246521">[-]</label><label class="expand" for="c-37246521">[1 more]</label></div><br/><div class="children"><div class="content">Modern JS framework pre-render the components on the server then they attach to them to &quot;rehydrate&quot; and add JS handlers. They also allow mixing of purely-server-side components (essentially templates, no JS or hydration) and mostly-client-side components (that still pre-render on the server)<p>For Rust, Leptos (<a href="https:&#x2F;&#x2F;leptos.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;leptos.dev&#x2F;</a>) would be one choice that can do SSR+hydration (but not intermixed with server-side components, at least AFAIK not yet)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37245753" class="c"><input type="checkbox" id="c-37245753" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37244405">prev</a><span>|</span><a href="#37244439">next</a><span>|</span><label class="collapse" for="c-37245753">[-]</label><label class="expand" for="c-37245753">[2 more]</label></div><br/><div class="children"><div class="content">The performance of Go and the maintainability of Rust ..., did you forget a &#x2F;s there?</div><br/><div id="37246093" class="c"><input type="checkbox" id="c-37246093" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37245753">parent</a><span>|</span><a href="#37244439">next</a><span>|</span><label class="collapse" for="c-37246093">[-]</label><label class="expand" for="c-37246093">[1 more]</label></div><br/><div class="children"><div class="content">While many people have the impression the Rust type system slows them down while prototyping, I think it is a huge time saver when working on existing code, so I&#x27;m not sure why you think Rust isn&#x27;t as maintainable.</div><br/></div></div></div></div><div id="37244439" class="c"><input type="checkbox" id="c-37244439" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37245753">prev</a><span>|</span><a href="#37244713">next</a><span>|</span><label class="collapse" for="c-37244439">[-]</label><label class="expand" for="c-37244439">[1 more]</label></div><br/><div class="children"><div class="content">Because there&#x27;s a large productivity gain from being able to use one language for both the frontend and the backend, and server-side JS tooling is far more mature and usable than client-side Go or Rust.</div><br/></div></div><div id="37244713" class="c"><input type="checkbox" id="c-37244713" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37244439">prev</a><span>|</span><a href="#37244658">next</a><span>|</span><label class="collapse" for="c-37244713">[-]</label><label class="expand" for="c-37244713">[1 more]</label></div><br/><div class="children"><div class="content">because I can hire more JS&#x2F;TS developers than I can go or rust (especially rust) developers AND I can pay them less... No $400k for a crud app here.</div><br/></div></div><div id="37244658" class="c"><input type="checkbox" id="c-37244658" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37244713">prev</a><span>|</span><a href="#37244576">next</a><span>|</span><label class="collapse" for="c-37244658">[-]</label><label class="expand" for="c-37244658">[1 more]</label></div><br/><div class="children"><div class="content">Because they simply can&#x27;t convert all of their js code into either go or rust for a forseeable future? Even providing they actually find those languages desirable, comparing to typescript.</div><br/></div></div><div id="37244576" class="c"><input type="checkbox" id="c-37244576" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244287">parent</a><span>|</span><a href="#37244658">prev</a><span>|</span><a href="#37246188">next</a><span>|</span><label class="collapse" for="c-37244576">[-]</label><label class="expand" for="c-37244576">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why would someone use this over much more maintainable and performant backends in Go or Rust?<p>They were already using NodeJs or would have. And that&#x27;s a large part of the current ecosystem.</div><br/><div id="37244957" class="c"><input type="checkbox" id="c-37244957" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#37244236">root</a><span>|</span><a href="#37244576">parent</a><span>|</span><a href="#37246188">next</a><span>|</span><label class="collapse" for="c-37244957">[-]</label><label class="expand" for="c-37244957">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it’s a silly question. It’s like going into a python thread and being like “why didn’t you implement all of this in Go or Rust?” Well, there’s a thousand reasons, and it’s really not even worth the time to unwrap this very reductive question that is really only going to turn into a language flame war for no reason.</div><br/></div></div></div></div></div></div></div></div><div id="37246188" class="c"><input type="checkbox" id="c-37246188" checked=""/><div class="controls bullet"><span class="by">0xferruccio</span><span>|</span><a href="#37244236">prev</a><span>|</span><a href="#37245289">next</a><span>|</span><label class="collapse" for="c-37246188">[-]</label><label class="expand" for="c-37246188">[1 more]</label></div><br/><div class="children"><div class="content">Congrats - very excited to see Bun emerge in the JS ecosystem. I&#x27;m curious about what&#x27;s the vision for it.<p>Is the plan to eventually build a cohesive web framework kind of like Rails&#x2F;Laravel?</div><br/></div></div><div id="37244925" class="c"><input type="checkbox" id="c-37244925" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#37244431">prev</a><span>|</span><label class="collapse" for="c-37244925">[-]</label><label class="expand" for="c-37244925">[12 more]</label></div><br/><div class="children"><div class="content">Glad Bun exists, but still prefer Vite.</div><br/><div id="37244927" class="c"><input type="checkbox" id="c-37244927" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#37244925">parent</a><span>|</span><label class="collapse" for="c-37244927">[-]</label><label class="expand" for="c-37244927">[11 more]</label></div><br/><div class="children"><div class="content">Are they even remotely the same thing? One is a build tool, the other is a JavaScript runtime?</div><br/><div id="37244950" class="c"><input type="checkbox" id="c-37244950" checked=""/><div class="controls bullet"><span class="by">evilduck</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37244927">parent</a><span>|</span><label class="collapse" for="c-37244950">[-]</label><label class="expand" for="c-37244950">[10 more]</label></div><br/><div class="children"><div class="content">Yeah actually, Bun is also a bundler: <a href="https:&#x2F;&#x2F;bun.sh&#x2F;docs&#x2F;bundler" rel="nofollow noreferrer">https:&#x2F;&#x2F;bun.sh&#x2F;docs&#x2F;bundler</a></div><br/><div id="37244994" class="c"><input type="checkbox" id="c-37244994" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37244950">parent</a><span>|</span><label class="collapse" for="c-37244994">[-]</label><label class="expand" for="c-37244994">[9 more]</label></div><br/><div class="children"><div class="content">Isn’t that like saying “glad Typescript exists but still prefer Flow?” One does a tiny subset of the other after all, and when you compare what Flow does to what Typescript does, I think it’s possible to argue quite well that the very tiny subset of what Typescript does is arguably comparable to what flow offers but that perhaps you might get basically everything that Flow offers and 100x more if you adopted typescript. And perhaps Flow might be better at several things but if it’s only really good at solving 5% of the total problem I’m going to pick the solution that also solves the other 95% even if the 5% Flow solves is just a mediocre solution<p>Note that I don’t really think that bun is the solution for everything or really that it is all that great. I am just pointing out that you are trying to compare two things that are not really the same thing at all. One is probably a strict superset of the other</div><br/><div id="37245096" class="c"><input type="checkbox" id="c-37245096" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37244994">parent</a><span>|</span><a href="#37245101">next</a><span>|</span><label class="collapse" for="c-37245096">[-]</label><label class="expand" for="c-37245096">[4 more]</label></div><br/><div class="children"><div class="content">I think their point is bun is not a runtime either because you can use it to spit out a blob of js that is run by the browser as normal. Which is how I use it to build js libs. Bun is then just the build and test tooling, and the various runtime bugs do not affect my downstream users (but it can impact testing).</div><br/><div id="37245115" class="c"><input type="checkbox" id="c-37245115" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245096">parent</a><span>|</span><a href="#37245101">next</a><span>|</span><label class="collapse" for="c-37245115">[-]</label><label class="expand" for="c-37245115">[3 more]</label></div><br/><div class="children"><div class="content">Oh, people only use Bun as a build tool? Sorry, I thought it was being discussed as a runtime in the same land as Deno and Node. If it’s just a build tool, then parent comment is legitimate and I apologize. It’s weird though, when I google bun js the first thing it describes itself as is a “fast all-in-one JavaScript runtime”</div><br/><div id="37245323" class="c"><input type="checkbox" id="c-37245323" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245115">parent</a><span>|</span><a href="#37245101">next</a><span>|</span><label class="collapse" for="c-37245323">[-]</label><label class="expand" for="c-37245323">[2 more]</label></div><br/><div class="children"><div class="content">Bun is a runtime like Deno that can be a drop-in replacement for NodeJs. It is ALSO a bundler like esbuild.</div><br/><div id="37246202" class="c"><input type="checkbox" id="c-37246202" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245323">parent</a><span>|</span><a href="#37245101">next</a><span>|</span><label class="collapse" for="c-37246202">[-]</label><label class="expand" for="c-37246202">[1 more]</label></div><br/><div class="children"><div class="content">And a fricken great build tool because it speaks typescript, jest and bundling out of the box so you remove several layers of partially compatible tools (eg. Esm, jest and typescript don&#x27;t really work that well together), yet still end up with a blob of js and the end so it&#x27;s transparent to the browser end user</div><br/></div></div></div></div></div></div></div></div><div id="37245101" class="c"><input type="checkbox" id="c-37245101" checked=""/><div class="controls bullet"><span class="by">evilduck</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37244994">parent</a><span>|</span><a href="#37245096">prev</a><span>|</span><label class="collapse" for="c-37245101">[-]</label><label class="expand" for="c-37245101">[4 more]</label></div><br/><div class="children"><div class="content">We can really muddy the waters:<p>Bun also supports Vite.</div><br/><div id="37245335" class="c"><input type="checkbox" id="c-37245335" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245101">parent</a><span>|</span><label class="collapse" for="c-37245335">[-]</label><label class="expand" for="c-37245335">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We can really muddy the waters:<p>No we don&#x27;t. Bun is not Vite.<p>Bun the package manager replaces npm&#x2F;yarn&#x2F;etc<p>Bun the bundler replaces esbuild&#x2F;swc&#x2F;etc<p>Bun the runtime replaces Deno&#x2F;node&#x2F;etc</div><br/><div id="37245557" class="c"><input type="checkbox" id="c-37245557" checked=""/><div class="controls bullet"><span class="by">orta</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245335">parent</a><span>|</span><label class="collapse" for="c-37245557">[-]</label><label class="expand" for="c-37245557">[2 more]</label></div><br/><div class="children"><div class="content">( FWIW, they are right, Bun the _runtime_ can use the npm module Vite. <a href="https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;issues&#x2F;250#issuecomment-1646368911">https:&#x2F;&#x2F;github.com&#x2F;oven-sh&#x2F;bun&#x2F;issues&#x2F;250#issuecomment-16463...</a> )</div><br/><div id="37245739" class="c"><input type="checkbox" id="c-37245739" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37244925">root</a><span>|</span><a href="#37245557">parent</a><span>|</span><label class="collapse" for="c-37245739">[-]</label><label class="expand" for="c-37245739">[1 more]</label></div><br/><div class="children"><div class="content">Well yes as a NodeJS runtime of course it can use npm. It doesn’t muddy the waters though is what I replied to.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>