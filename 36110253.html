<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685350863662" as="style"/><link rel="stylesheet" href="styles.css?v=1685350863662"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://community.arm.com/arm-community-blogs/b/infrastructure-solutions-blog/posts/container-runtimes-wasmedge-arm">Container Runtimes and WasmEdge benchmarking on Arm</a> <span class="domain">(<a href="https://community.arm.com">community.arm.com</a>)</span></div><div class="subtext"><span>3Sophons</span> | <span>32 comments</span></div><br/><div><div id="36110796" class="c"><input type="checkbox" id="c-36110796" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110641">next</a><span>|</span><label class="collapse" for="c-36110796">[-]</label><label class="expand" for="c-36110796">[27 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of this article?<p>WASM vs a container runtime isn&#x27;t a meaningful comparison because they&#x27;re at different layers of the stack. A container runtime runs a process tree in a chroot, and whether the process binaries are native code (x86, ARM) or bytecode (JVM, WASM, CLR) is an implementation detail of the runtime.<p>This site appears to be comparing a full container image startup with the startup of a single WASM process (within a pre-existing native process?), which is doubly non-meaningful. Nobody is deploying large-scale services on top of what would be essentially the CGI model.</div><br/><div id="36110966" class="c"><input type="checkbox" id="c-36110966" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36110966">[-]</label><label class="expand" for="c-36110966">[13 more]</label></div><br/><div class="children"><div class="content">&gt; WASM vs a container runtime isn&#x27;t a meaningful comparison because they&#x27;re at different layers of the stack. A container runtime runs a process tree in a chroot, and whether the process binaries are native code (x86, ARM) or bytecode (JVM, WASM, CLR) is an implementation detail of the runtime.<p>It&#x27;s a meaningful comparison because they often solve the same business problem; you need to run some code in an isolated&#x2F;managed environment. Whether that&#x27;s done through a process tree or a single process is an implementation detail for many purposes; not being able to run multiple processes might have implications for some use cases, but a lot of systems (e.g. docker&#x2F;kubernetes, or especially anything serverless) are oriented around using a container for a single process.</div><br/><div id="36111025" class="c"><input type="checkbox" id="c-36111025" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110966">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111025">[-]</label><label class="expand" for="c-36111025">[12 more]</label></div><br/><div class="children"><div class="content">A comparison between WASM and x86&#x2F;ARM&#x2F;etc native binaries is meaningful, because those are different formats for executable code.<p>A comparison between WASM and &quot;containers&quot; is meaningless, because the binaries being executed by a container runtime could be written in WASM. The executable format and the packaging format are separate concerns.<p>This might be easier to think about if you imagine the article was written as &quot;native code vs containers&quot; -- what conclusions (if any) could you draw from the benchmarks in an article with that premise?</div><br/><div id="36111076" class="c"><input type="checkbox" id="c-36111076" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111025">parent</a><span>|</span><a href="#36111345">next</a><span>|</span><label class="collapse" for="c-36111076">[-]</label><label class="expand" for="c-36111076">[2 more]</label></div><br/><div class="children"><div class="content">A comparison between WASM and &quot;containers&quot; is meaningful because in popular usage there&#x27;s a cottage industry of WASM-based container solutions with the express goal (and co-evolved with the language to make this possible) of simplifying some of the thornier design decisions that make other containerization solutions easier to get started with (can just drop in any binary and dependencies) but also less performant for some set of tasks (have to set up network cgroups and other garbage). The phrase &quot;WASM&quot; isn&#x27;t just being used to refer to the actual stack machine.</div><br/><div id="36111138" class="c"><input type="checkbox" id="c-36111138" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111076">parent</a><span>|</span><a href="#36111345">next</a><span>|</span><label class="collapse" for="c-36111138">[-]</label><label class="expand" for="c-36111138">[1 more]</label></div><br/><div class="children"><div class="content">WASM is WebAssembly. Words have meanings.<p>If someone wants to try to advertise some weird custom platform that uses WASM as an intermediate bytecode for its packaging format then that&#x27;s fine, but they&#x27;ll need to pick a different name.</div><br/></div></div></div></div><div id="36111345" class="c"><input type="checkbox" id="c-36111345" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111025">parent</a><span>|</span><a href="#36111076">prev</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111345">[-]</label><label class="expand" for="c-36111345">[9 more]</label></div><br/><div class="children"><div class="content">Your argument is nonsense. It&#x27;s like arguing that comparing the performance of an API that use lambdas VS a traditional API with an application running in the server is meaningless because &quot;the lambda could be written in the application server&quot;. Who cares? If both can be used to implement the same API, the comparison is meaningful.</div><br/><div id="36111940" class="c"><input type="checkbox" id="c-36111940" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111345">parent</a><span>|</span><a href="#36111484">next</a><span>|</span><label class="collapse" for="c-36111940">[-]</label><label class="expand" for="c-36111940">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s replace with food.
Comparing eating soup with eating at a restaurant is meaningul because both are used to solve the same problem. Arguing that you can also eat soup at restaurant so these things are at different stack layers and should not be directly compared is a nonsense argument.</div><br/></div></div><div id="36111484" class="c"><input type="checkbox" id="c-36111484" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111345">parent</a><span>|</span><a href="#36111940">prev</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111484">[-]</label><label class="expand" for="c-36111484">[7 more]</label></div><br/><div class="children"><div class="content">Ok then. Let&#x27;s say I write a webserver with WASI, compile it to a `.wasm` file, package it as an OCI container image, and deploy it in Kubernetes via a container runtime that loads the entry point into wasmtime.<p>If containers and WASM are in fact competing technologies, as you and the article imply, then this shouldn&#x27;t be possible.<p>On the other hand, if WASM is a format for executable code as I claim, then packaging WASM as a container image and executing it in a container runtime is fine and should work as well as any other machine-independent bytecode (such as JVM).</div><br/><div id="36112010" class="c"><input type="checkbox" id="c-36112010" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111484">parent</a><span>|</span><a href="#36111615">next</a><span>|</span><label class="collapse" for="c-36112010">[-]</label><label class="expand" for="c-36112010">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If containers and WASM are in fact competing technologies, as you and the article imply, then this shouldn&#x27;t be possible.<p>That doesn&#x27;t make any sense to me. Just because you can put a thing inside another thing doesn&#x27;t mean they don&#x27;t also solve an overlapping set of problems.</div><br/></div></div><div id="36111615" class="c"><input type="checkbox" id="c-36111615" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111484">parent</a><span>|</span><a href="#36112010">prev</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111615">[-]</label><label class="expand" for="c-36111615">[5 more]</label></div><br/><div class="children"><div class="content">WASM is a bytecode format like Java bytecode... the difference is that it&#x27;s sandboxed. It can&#x27;t do anything that&#x27;s not explicitly given to it, including using WASI (the POSIX-like API for WASM code to &quot;talk&quot; to the system).<p>Because it&#x27;s sandboxed, you can use it without a container. I think that&#x27;s what you don&#x27;t seem to undestand. There are several companies offering WASM-based &quot;containers&quot; in the cloud - which don&#x27;t need any actual container, the WASM runtime has the same type of capability of a container, to isolate processes running on the same hardware securely.<p>It&#x27;s even possible to make an actual Docker container run purely on a WASM runtime, as Docker itself is doing now! <a href="https:&#x2F;&#x2F;wasmlabs.dev&#x2F;articles&#x2F;docker-without-containers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wasmlabs.dev&#x2F;articles&#x2F;docker-without-containers&#x2F;</a></div><br/><div id="36111713" class="c"><input type="checkbox" id="c-36111713" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111615">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111713">[-]</label><label class="expand" for="c-36111713">[4 more]</label></div><br/><div class="children"><div class="content">All bytecode is sandboxed by definition -- the VM decides which operations it delegates to the system. It is possible (and common!) to use JVM bytecode in a VM that restricts access to the underlying system, and in fact one of the original core use cases for Java (applets) relied on this functionality.<p>The difference between WASM and JVM is that WASM was designed to be both (1) a compilation target for memory-unsafe languages like C, and (2) have verifiable control flow so it&#x27;s easier to write a provably-secure JIT.<p><pre><code>  &gt; Because it&#x27;s sandboxed, you can use it without a container. I think
  &gt; that&#x27;s what you don&#x27;t seem to undestand.
</code></pre>
You don&#x27;t seem to understand what a container is, or what a sandbox is.<p>The reason to deploy software as a container image (instead of a standalone binary) is that a container image contains a full chroot, including auxiliary files that aren&#x27;t embedded into the main binary. Whether the binary is native machine code or WASM doesn&#x27;t matter -- the tradeoffs of bundling everything into one binary vs placing them on disk are the same regardless of executable format.<p>The reason to run a sandbox is to restrict which system resources a process can access or interfere with. You can sandbox a process whether or not it runs in a container.</div><br/><div id="36111767" class="c"><input type="checkbox" id="c-36111767" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111713">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111767">[-]</label><label class="expand" for="c-36111767">[3 more]</label></div><br/><div class="children"><div class="content">I see you like to ignore reality and go on with your own definitions for things.<p>&gt; All bytecode is sandboxed by definition<p>Oh my... you probably mean &quot;all bytecode COULD be sandboxed&quot;... try sandoboxing JVM bytecode... they tried that for years :D didn&#x27;t quite work.<p>&gt; The reason to deploy software as a container image (instead of a standalone binary) is that a container image contains a full chroot,<p>No. Stop trying to tell us what a container should be used for.
A container&#x27;s main usage nowadays is to run multiple isolated &quot;processes&quot; or set of processes in a safe manner, making the most of the hardware... coincidentally, you can also do that using WASM. Get over your outdated worldview, mate.<p>EDIT: please read the link I provided. From the creators of Docker:<p>&quot;If WASM+WASI existed in 2008, we wouldn&#x27;t have needed to create Docker.&quot;<p>How does that align with your definition of what a container is or isn&#x27;t?</div><br/><div id="36111820" class="c"><input type="checkbox" id="c-36111820" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111767">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111820">[-]</label><label class="expand" for="c-36111820">[2 more]</label></div><br/><div class="children"><div class="content">As an aside, to what degree does WASI exist _now_? The spec seems to be in a state of flux as to what the language the spec is written in is, and the language new proposals are written in seems to have grown futures? On the other hand, as far as I can tell, the latest draft spec doesn&#x27;t look to have support for UDP or scalable notification (epoll, kqueue, etc.), so is that really what people are using their existing software with?<p>Docker&#x27;s great win is that you don&#x27;t even need to recompile your software to use it, much less port it to what&#x27;s essentially a new non-POSIX operating system.</div><br/><div id="36111918" class="c"><input type="checkbox" id="c-36111918" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111820">parent</a><span>|</span><a href="#36111169">next</a><span>|</span><label class="collapse" for="c-36111918">[-]</label><label class="expand" for="c-36111918">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; As an aside, to what degree does WASI exist _now_?
</code></pre>
It&#x27;s ... rough. The impression I get (as an uninvolved third-party) is that the WASI folks set out with a goal of writing a sort of capability-based POSIX that they could write a thin libc for, but partway through realized that POSIX embeds a lot of assumptions that aren&#x27;t compatible with portability or capability-based security.<p>IMO (again, no direct involvement) a better approach would be to start with a low-level API that is capability-based from the beginning. Something like EFI, or (more experimentally) an RPC-oriented syscall API resembling Fuchsia&#x2F;Plan9. Then the various sorts of magic integers and process state found in POSIX can be layered on top of that as a library.<p>The good news is that the people working on WASI do seem aware of what they&#x27;ve gotten themselves into, and I think a lot of the chaos (shifting repos, broken docs, etc) is just the natural outcome of them exploring the solution space. My <i>expectation</i> is that they&#x27;ll be forced to drift pretty far from POSIX if they want a workable design, but maybe they&#x27;ll surprise us.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36111169" class="c"><input type="checkbox" id="c-36111169" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36110966">prev</a><span>|</span><a href="#36110842">next</a><span>|</span><label class="collapse" for="c-36111169">[-]</label><label class="expand" for="c-36111169">[1 more]</label></div><br/><div class="children"><div class="content">Things don&#x27;t have to be the same to compare &amp; contrast. There were dozens of articles a month comparing vm&#x27;s Vs containers back in the day.<p>I also think your fixed perspective that these are &amp; always will be different levels of the stack is an inadequate fixedness, lacks the mental agility to comprehend many of the things wasm is growing into. For years already, standard libraries like wasi are attempting to become fairly complete platform libraries. Instances of wasm run in effectively process trees of chroots, so the simar parity is apparent.<p>It&#x27;s absolutely coom sense to be comparing startup times across the two. There have been endless efforts to try to make cold boot containers or container snapshots as fast as possible. And this again extends backwards in time to comparisons versus vm&#x27;s as well, with efforts like the Xen Zerg demo trying to make vm&#x27;s fast enough to boot a vm per request. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5243360" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5243360</a><p>Getting back to a process per request or process per session model is a holy grail, one that every virtualization&#x2F;containerization technology has explored. It would greatly alter the application development model &amp; potentially greatly enhance security, could help radically reshape resource management. This article is doing a fine job pointing to the future, to what we are unlocking. We absolutely should compare versus what the technology of today (containers) can do. The comparison is spot on.</div><br/></div></div><div id="36110842" class="c"><input type="checkbox" id="c-36110842" checked=""/><div class="controls bullet"><span class="by">2fast4you</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36111169">prev</a><span>|</span><a href="#36111567">next</a><span>|</span><label class="collapse" for="c-36110842">[-]</label><label class="expand" for="c-36110842">[8 more]</label></div><br/><div class="children"><div class="content">Actually there is support for using WASM as a container runtime. You could in theory have WASM containers and Linux containers next to each other on the same K8s cluster. Not sure that I’d recommend it in production just yet, but it’s certainly usable<p><a href="https:&#x2F;&#x2F;next.redhat.com&#x2F;2023&#x2F;02&#x2F;01&#x2F;running-webassembly-workloads-on-container-runtimes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;next.redhat.com&#x2F;2023&#x2F;02&#x2F;01&#x2F;running-webassembly-workl...</a></div><br/><div id="36111214" class="c"><input type="checkbox" id="c-36111214" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110842">parent</a><span>|</span><a href="#36110894">next</a><span>|</span><label class="collapse" for="c-36111214">[-]</label><label class="expand" for="c-36111214">[1 more]</label></div><br/><div class="children"><div class="content">Right now most early examples alas boot a container with a wasm runtime for each wasm instance, which is a sad waste. The whole advantage of wasm should be very lightweight low overhead wasm runtime <i>instances</i> atop a common wasm process. Having a process or container for each instance loses a ton of the benefit, makes it not much better than a regular container.<p>Thankfully there is work like the Containerd Sandbox API which enables new architectures like this. <a href="https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;containerd&#x2F;issues&#x2F;4131">https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;containerd&#x2F;issues&#x2F;4131</a><p>It&#x27;s still being used to spawn a wasm processes per instance for now, but container runtime project Kuasar is already using the Sandbox API to save significant resources, and has already chimed in in comments on HN to express a desire to have shared-process&#x2F;multi-wasm-instamxe runtimes, which could indeed allow sub ms spawning that could enable instance per request architectures. <a href="https:&#x2F;&#x2F;github.com&#x2F;kuasar-io&#x2F;kuasar">https:&#x2F;&#x2F;github.com&#x2F;kuasar-io&#x2F;kuasar</a></div><br/></div></div><div id="36110894" class="c"><input type="checkbox" id="c-36110894" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110842">parent</a><span>|</span><a href="#36111214">prev</a><span>|</span><a href="#36111457">next</a><span>|</span><label class="collapse" for="c-36110894">[-]</label><label class="expand" for="c-36110894">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; Actually there is support for using WASM as a container runtime.
</code></pre>
Isn&#x27;t that what I said?<p>Some container runtimes (such as `runc`) execute a native binary. There are also container runtimes that execute a WASM+WASI binary.<p>So trying to compare WASM with &quot;containers&quot; is like asking &quot;should you deploy your code as x86 or as a container&quot;, which isn&#x27;t a useful question.</div><br/><div id="36110928" class="c"><input type="checkbox" id="c-36110928" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110894">parent</a><span>|</span><a href="#36111457">next</a><span>|</span><label class="collapse" for="c-36110928">[-]</label><label class="expand" for="c-36110928">[3 more]</label></div><br/><div class="children"><div class="content">I think your comparison to CGI is unfair, since CGI in containers is quite different from &quot;classic&quot; CGI imo.<p>Wikipedia describes CGI as &quot;In computing, Common Gateway Interface (CGI) is an interface specification that enables web servers to execute an external program, typically to process user requests.[1]<p>Such programs are often written in a scripting language and are commonly referred to as CGI scripts, but they may include compiled programs.[2]<p>A typical use case occurs when a web user submits a web form on a web page that uses CGI. The form&#x27;s data is sent to the web server within an HTTP request with a URL denoting a CGI script. The web server then launches the CGI script in a new computer process, passing the form data to it. The output of the CGI script, usually in the form of HTML, is returned by the script to the Web server, and the server relays it back to the browser as its response to the browser&#x27;s request.[3]&quot;<p>Which bears little resemblance here imo.</div><br/><div id="36111068" class="c"><input type="checkbox" id="c-36111068" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110928">parent</a><span>|</span><a href="#36110984">next</a><span>|</span><label class="collapse" for="c-36111068">[-]</label><label class="expand" for="c-36111068">[1 more]</label></div><br/><div class="children"><div class="content">I guess that across the board vendors are experimenting and evaluating the impact of introducing WASM&#x2F;WASI-based technologies and that may constitute something of a paradigm shift.<p>On the container side Docker also has native WASM support in a technical preview [0]. I don&#x27;t think they see WASM as a threat, but rather as an addition to how apps and services can be delivered.<p>The other day I found an InfoWorld article &quot;Solving the SBOM crisis with WebAssembly Components&quot; [1] that features a diagram on the evolution of Application Development Stacks (by Cosmonic, one early adopter Wasm vendor) that indicates the trend. Idea is to tackle some of the complexity in current infra setups that have become like &quot;Rube Goldberg machines&quot;.<p>It is interesting, but beware hype cycle trends.<p>[0] <a href="https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;announcing-dockerwasm-technical-preview-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;announcing-dockerwasm-technical-...</a><p>[1] <a href="https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3694902&#x2F;solving-the-sbom-crisis-with-webassembly-components.html" rel="nofollow">https:&#x2F;&#x2F;www.infoworld.com&#x2F;article&#x2F;3694902&#x2F;solving-the-sbom-c...</a></div><br/></div></div><div id="36110984" class="c"><input type="checkbox" id="c-36110984" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110928">parent</a><span>|</span><a href="#36111068">prev</a><span>|</span><a href="#36111457">next</a><span>|</span><label class="collapse" for="c-36110984">[-]</label><label class="expand" for="c-36110984">[1 more]</label></div><br/><div class="children"><div class="content">Is it possible you don&#x27;t have direct experience with CGI?<p>The typical way to deploy CGI during the &#x27;90s was to have a compiled program in C&#x2F;C++, which would be executed once per request. There were entire frameworks built around this &quot;process per request&quot; model, with various optimizations like pre-warming (start the process, connect to db, wait for request on stdin) and variant protocols (SCGI).<p>Any time you have an execution model based on running a single address space per request, it&#x27;s fundamentally CGI-ish. It doesn&#x27;t have anything to do with the implementation language. The limitation of CGI is that state can&#x27;t be persisted in-process between requests.<p>---<p>Going back to the thread, there&#x27;s multiple aspects when thinking about the structure of a hosted service:<p>1. Whether state is shared between requests (CGI vs long-lived process).<p>2. Whether the binary is native code (x86&#x2F;ARM&#x2F;) or bytecode (WASM&#x2F;JVM&#x2F;).<p>3. Whether the binary is standalone or comes with additional files.<p>4. If it needs additional files, whether it&#x27;s distributed as a package (apt&#x2F;rpm) or chroot (container image).<p>Does breaking those different concepts down into a list help? You can see that trying to compare the performance of &quot;WASM deployed as standalone binary with CGI execution model&quot; and &quot;native code deployed in container image&quot; just isn&#x27;t meaningful. The article is mixing up too many different ideas when trying to benchmark.</div><br/></div></div></div></div></div></div><div id="36111457" class="c"><input type="checkbox" id="c-36111457" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110842">parent</a><span>|</span><a href="#36110894">prev</a><span>|</span><a href="#36110856">next</a><span>|</span><label class="collapse" for="c-36111457">[-]</label><label class="expand" for="c-36111457">[1 more]</label></div><br/><div class="children"><div class="content">Indeed<p><a href="https:&#x2F;&#x2F;krustlet.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;krustlet.dev&#x2F;</a></div><br/></div></div><div id="36110856" class="c"><input type="checkbox" id="c-36110856" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36110842">parent</a><span>|</span><a href="#36111457">prev</a><span>|</span><a href="#36111567">next</a><span>|</span><label class="collapse" for="c-36110856">[-]</label><label class="expand" for="c-36110856">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, re-inventing application servers, badly.</div><br/></div></div></div></div><div id="36111567" class="c"><input type="checkbox" id="c-36111567" checked=""/><div class="controls bullet"><span class="by">ridruejo</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36110842">prev</a><span>|</span><a href="#36110850">next</a><span>|</span><label class="collapse" for="c-36111567">[-]</label><label class="expand" for="c-36111567">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Nobody is deploying large-scale services on top of what would be essentially the CGI model.&quot;  Yes, they are. That&#x27;s basically the Cloudflare workers model (which certainly qualifies as large-scale) and many other V8&#x2F;Wasm based serverless solutions</div><br/><div id="36111616" class="c"><input type="checkbox" id="c-36111616" checked=""/><div class="controls bullet"><span class="by">jmillikin</span><span>|</span><a href="#36110796">root</a><span>|</span><a href="#36111567">parent</a><span>|</span><a href="#36110850">next</a><span>|</span><label class="collapse" for="c-36111616">[-]</label><label class="expand" for="c-36111616">[1 more]</label></div><br/><div class="children"><div class="content">The article is not describing the Cloudflare approach (v8 isolates) -- note the graph of startup times. Their &quot;wasmedge&quot; line takes 20 seconds to start 1500 instances, or about 13 milliseconds per instance.<p>Cloudflare&#x27;s blog post at <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;cloud-computing-without-containers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;cloud-computing-without-containe...</a> contains a graph in which requests are handled in 200 <i>microseconds</i>, orders of magnitude faster.</div><br/></div></div></div></div><div id="36110850" class="c"><input type="checkbox" id="c-36110850" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36111567">prev</a><span>|</span><a href="#36111476">next</a><span>|</span><label class="collapse" for="c-36110850">[-]</label><label class="expand" for="c-36110850">[1 more]</label></div><br/><div class="children"><div class="content">Promote WASM no matter what, that is the point.<p>And for CGI model, there is a reason why servlets, ISAPI handlers and Apache language modules came to be.<p>Maybe compare those to start with, then sell how great WebAssembly is for server side. &#x2F;s</div><br/></div></div><div id="36111476" class="c"><input type="checkbox" id="c-36111476" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#36110796">parent</a><span>|</span><a href="#36110850">prev</a><span>|</span><a href="#36110641">next</a><span>|</span><label class="collapse" for="c-36111476">[-]</label><label class="expand" for="c-36111476">[1 more]</label></div><br/><div class="children"><div class="content">The author has carried out an assessment of how the use of the ARM assisted hardware virtualisation (normally used to isolate and run VM&#x27;s but not containers) affects different metrics of running different runtimes in a <i>container</i> environment that is aware of and that can take advantage of the hardware virtualisation features:<p><pre><code>  Kata Container is a secure container runtime that uses hardware virtualization technology as an additional layer of defense. This allows it to provide stronger workload isolation while still being lightweight and performing like regular containers.
</code></pre>
The author uses WASM runtimes as a conduit, and concludes the article with a compilation of results and the impact on each metric, namely: boot times, security, the ease of development in each setup, production readiness amongst others. The author does compare raw computational performance of each option, and it does not appear to be an objective.<p>The article title could have been better worded, though.</div><br/></div></div></div></div><div id="36110641" class="c"><input type="checkbox" id="c-36110641" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36110796">prev</a><span>|</span><a href="#36111562">next</a><span>|</span><label class="collapse" for="c-36110641">[-]</label><label class="expand" for="c-36110641">[3 more]</label></div><br/><div class="children"><div class="content">For me this article is flawed. Hello Worlds application are not good metric foundation to make such a comparison.<p>Also it is no surprising that a container cannot beat a sandboxed programming platform that wasm is. I do not know if there is some mode in Java that could be comparable.</div><br/><div id="36111621" class="c"><input type="checkbox" id="c-36111621" checked=""/><div class="controls bullet"><span class="by">ridruejo</span><span>|</span><a href="#36110641">parent</a><span>|</span><a href="#36110716">next</a><span>|</span><label class="collapse" for="c-36111621">[-]</label><label class="expand" for="c-36111621">[1 more]</label></div><br/><div class="children"><div class="content">Meaningful benchmarks are hard. Having said that, in this particular context it is a good metric to measure the latency for the simplest possible function invocation as that is important for serverless at the edge (and why you put those workers&#x2F;functions as close as possible to the clients in the first place)</div><br/></div></div><div id="36110716" class="c"><input type="checkbox" id="c-36110716" checked=""/><div class="controls bullet"><span class="by">nunobrito</span><span>|</span><a href="#36110641">parent</a><span>|</span><a href="#36111621">prev</a><span>|</span><a href="#36111562">next</a><span>|</span><label class="collapse" for="c-36110716">[-]</label><label class="expand" for="c-36110716">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Why bother with wasm when you can write the app from scratch in Java.<p>Boot up time also tends to be irrelevant since the true slowdown comes from initializing other dependencies anyways.<p>Wasm looks relevant for existing apps in C++ that you wish to run from a web browser.</div><br/></div></div></div></div><div id="36111562" class="c"><input type="checkbox" id="c-36111562" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#36110641">prev</a><span>|</span><label class="collapse" for="c-36111562">[-]</label><label class="expand" for="c-36111562">[1 more]</label></div><br/><div class="children"><div class="content">&gt; normal (debugging within the container is a problem)<p>That&#x27;s a medium difficulty then. Kata isn&#x27;t a great development environment.</div><br/></div></div></div></div></div></div></div></body></html>