<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683709263271" as="style"/><link rel="stylesheet" href="styles.css?v=1683709263271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/linux/FlockFcntlAndNFS">File Locks on Linux</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>miohtama</span> | <span>35 comments</span></div><br/><div><div id="35882320" class="c"><input type="checkbox" id="c-35882320" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#35882629">next</a><span>|</span><label class="collapse" for="c-35882320">[-]</label><label class="expand" for="c-35882320">[4 more]</label></div><br/><div class="children"><div class="content">The amusing thing, apart from the fact that we are <i>still</i> discussing the unexpected interactions of locks and NFS after 35 years, is that recommending not using flock() is the reverse of the manual pages and widespread existing practice.<p>The Linux manual calls the lockf()&#x2F;fcntl(F_SETLK) mechanism &quot;unfortunate&quot;.  The BSD manual, across all flavours, is not so restrained and calls them &quot;completely stupid semantics of System V&quot;.  The BSD manual calls the flock() mechanism &quot;much more rational&quot; and &quot;recommended&quot;.  The Linux manual likewise recommends using its per-open-file-description mechanism of fcntl(F_OFD_SETLK) as &quot;a Linux-specific alternative with better semantics&quot;.<p>Thus we are in the unenviable situation that the Linux NFS client&#x2F;server implementation breaks flock(), by translating into POSIX locks under the covers some of the time; but the non-POSIX flock() is the &quot;better&quot;, &quot;rational&quot;, mechanism that is widely recommended, and that has been long used by the BSD lockf(1) utility and the Bernstein setlock(1) utility and the Pape chpst(8) utility.</div><br/><div id="35883239" class="c"><input type="checkbox" id="c-35883239" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#35882320">parent</a><span>|</span><a href="#35882629">next</a><span>|</span><label class="collapse" for="c-35883239">[-]</label><label class="expand" for="c-35883239">[3 more]</label></div><br/><div class="children"><div class="content">For all the dangerous qualities of classic POSIX&#x2F;SysV locks, they&#x27;re in service of one key characteristic[1]: only a single process can hold a lock, which means you can easily identify and communicate with the lock-holding process, such as by querying for and sending a signal to the PID (ignoring NFS, which came along later). With BSD descriptor locks, multiple processes can and often invariably do hold the lock, by holding dup&#x27;d references to the same open file table entry.<p>[1] Maybe this could have been achieved with better semantics, but my guess is the semantics follow from a very straight-forward implementation given the classic 3-level Unix file model of per-process descriptor tables, global open file table, and global open inode table, where you just hang the lock index off of the global open inode table, without any back referencing to the higher-level tables, notwithstanding recording of the lock owner PID. SysV mandatory locking perhaps also figured into this design and the semantics.</div><br/><div id="35883666" class="c"><input type="checkbox" id="c-35883666" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#35882320">root</a><span>|</span><a href="#35883239">parent</a><span>|</span><a href="#35883497">next</a><span>|</span><label class="collapse" for="c-35883666">[-]</label><label class="expand" for="c-35883666">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s certainly the implementation, v_filocks.  But I&#x27;d be wary of saying that the implementation drove the design.  Remember that people have historically disagreed about synchronization mechanisms and which ones are the good ones.  It&#x27;s quite possible that the design was simply intentionally that way, not following from any implementation considerations.<p>For example: Dave Cutler architect of Windows NT called the OS&#x2F;2 mutex mechanism a &quot;mutant&quot; because xe thought the semantics were bad.  But the semantics that xe didn&#x27;t like were designed so that a locking thread was told whenever the preceding mutex owner lost the lock because it ABENDed, and that thus whatever the mutex was guarding was probably not in a consistent unlocked state.<p>One has only to cast one&#x27;s mind back to how file sharing flags worked, or just didn&#x27;t work, on MS&#x2F;PC&#x2F;DR-DOS when they first came along (Hands up if you remember compatibility mode sharing, or Netware&#x27;s added spin to the whole thing.) to be reminded that sometimes design was just odd, by today&#x27;s standards.  (-:<p>By the way:  NFS began in 1984 and was available for AT&amp;T Unix System 5 Release 2.  File locking with lockf()&#x2F;fcntl() dates from AT&amp;T Unix System 5 Release 3 which was actually later, not earlier.  Also remember that System 5 Release 3 at the same time introduced RFS, which <i>did</i> do locking and statefully maintained open file descriptions on the server, so the idea of the PID being accessible is a bit of a red herring.</div><br/></div></div><div id="35883497" class="c"><input type="checkbox" id="c-35883497" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#35882320">root</a><span>|</span><a href="#35883239">parent</a><span>|</span><a href="#35883666">prev</a><span>|</span><a href="#35882629">next</a><span>|</span><label class="collapse" for="c-35883497">[-]</label><label class="expand" for="c-35883497">[1 more]</label></div><br/><div class="children"><div class="content">IIRC the initial implementation of what became POSIX locks was cobbled together in a weekend just so that the author could submit <i>something</i> to the POSIX group but then apparently nobody else did, or bothered to read&#x2F;argue, so it got standardized as-is, with all of its unfortunate implications.</div><br/></div></div></div></div></div></div><div id="35882629" class="c"><input type="checkbox" id="c-35882629" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35882320">prev</a><span>|</span><a href="#35884081">next</a><span>|</span><label class="collapse" for="c-35882629">[-]</label><label class="expand" for="c-35882629">[9 more]</label></div><br/><div class="children"><div class="content">&quot;...the flock command uses flock() and it&#x27;s pretty much your best bet for locking in shell scripts.&quot;<p>I find that mkdir is the easiest and most reliable lock between shell scripts under my control, and I use this approach for several variants of inotify (incron, path units, and inotifywait).<p><pre><code>  #!&#x2F;bin&#x2F;sh
  if mkdir &#x2F;tmp&#x2F;dirlock 2&gt; &#x2F;dev&#x2F;null
  then trap &#x27;rmdir &#x2F;tmp&#x2F;dirlock&#x27; EXIT
       (critical section)
  fi
</code></pre>
This also does not require a subshell, so it is more efficient as it avoids a fork() - unlike the flock shell utility.<p>I don&#x27;t try to do this over NFS, but mkdir is guaranteed to be atomic, and I have never seen this fail. It&#x27;s also more secure to lock in a private directory rather than &#x2F;tmp, unless you want the lock mechanism to be promiscuous for some reason.</div><br/><div id="35882765" class="c"><input type="checkbox" id="c-35882765" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#35882629">parent</a><span>|</span><a href="#35883176">next</a><span>|</span><label class="collapse" for="c-35882765">[-]</label><label class="expand" for="c-35882765">[7 more]</label></div><br/><div class="children"><div class="content">Unlike real locks, your approach has the downside that an unexpected exit (e.g., kill -9) will stay locked until someone manually intervenes.</div><br/><div id="35882982" class="c"><input type="checkbox" id="c-35882982" checked=""/><div class="controls bullet"><span class="by">ASalazarMX</span><span>|</span><a href="#35882629">root</a><span>|</span><a href="#35882765">parent</a><span>|</span><a href="#35882983">next</a><span>|</span><label class="collapse" for="c-35882982">[-]</label><label class="expand" for="c-35882982">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes that&#x27;s precisely what you want, if the unfinished script should run again without being checked.</div><br/></div></div><div id="35882983" class="c"><input type="checkbox" id="c-35882983" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35882629">root</a><span>|</span><a href="#35882765">parent</a><span>|</span><a href="#35882982">prev</a><span>|</span><a href="#35883061">next</a><span>|</span><label class="collapse" for="c-35882983">[-]</label><label class="expand" for="c-35882983">[4 more]</label></div><br/><div class="children"><div class="content">This was actually a problem on dash, so I added several more signals (INT TERM etc.).<p>Nothing saves you from kill -9, as we all know.<p>I did add a reboot entry to cron (@reboot with Vixie cron) to remove the directory.<p>I can say that this method has processed millions of Oracle archived logs with no errors.</div><br/><div id="35883018" class="c"><input type="checkbox" id="c-35883018" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#35882629">root</a><span>|</span><a href="#35882983">parent</a><span>|</span><a href="#35884407">next</a><span>|</span><label class="collapse" for="c-35883018">[-]</label><label class="expand" for="c-35883018">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if the fact that you can delete a file and still access its contents as long as a file descriptor is still open would allow some dorty magic. Probably not because iirc you can create a file with the same name right after deletion even if a fd is open to the old one.</div><br/><div id="35883112" class="c"><input type="checkbox" id="c-35883112" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35882629">root</a><span>|</span><a href="#35883018">parent</a><span>|</span><a href="#35884407">next</a><span>|</span><label class="collapse" for="c-35883112">[-]</label><label class="expand" for="c-35883112">[1 more]</label></div><br/><div class="children"><div class="content">SQLite will open temporary files (for sorting and sundry functions), then immediately unlink() them. This is allowed behavior under POSIX.<p>The NFS trick was documented in &quot;Why NFS Sucks&quot; by Olaf Kirch.<p>&quot;Some other cases are a bit stranger. One such
case is the ability to write to an open unlinked
file. POSIX says an application can open a file
for reading and writing, unlink it, and continue
to do I&#x2F;O on it. The file is not supposed to go
away until the last application closes it.<p>&quot;This is difficult to do over NFS, since traditionally, the NFS server has no concept of “open”
files (this was added in NFSv4, however). So
when a client removes a file, it will be gone for
good, and the file handle is no longer valid—
and attempt to read from or write to that
file will result in a “Stale file handle” error.<p>&quot;The way NFS traditionally kludges around this
is by doing what has been dubbed a “silly re-
name.” When the NFS client notices during an
unlink call that one or more applications still
hold an open file descriptor to this file, it will
not send a REMOVE call to the server. Instead,
it will rename the file to some temporary file
name, usually .nfsXXX where XXX is some
hex number. This file will stay around until the
last application closes its open file descriptor,
and only then will the NFS client send the final
REMOVE call to the server that gets rid of this
renamed file.<p>&quot;This sounds like a rather smart sleight of hand,
and it is—up to a point. First off, this does not work across different clients. But that should
not come as a surprise given the lack of cache
consistency.&quot;<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;ols&#x2F;2006&#x2F;ols2006v2-pages-59-72.pdf" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;ols&#x2F;2006&#x2F;ols2006v2-pages-59-72.pd...</a></div><br/></div></div></div></div><div id="35884407" class="c"><input type="checkbox" id="c-35884407" checked=""/><div class="controls bullet"><span class="by">i_am_a_peasant</span><span>|</span><a href="#35882629">root</a><span>|</span><a href="#35882983">parent</a><span>|</span><a href="#35883018">prev</a><span>|</span><a href="#35883061">next</a><span>|</span><label class="collapse" for="c-35884407">[-]</label><label class="expand" for="c-35884407">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing saves you from kill -9, as we all know.<p>You making a syscall and getting the kernel stuck somewhere and having your process in a D state will keep you alive ;D.</div><br/></div></div></div></div></div></div><div id="35883176" class="c"><input type="checkbox" id="c-35883176" checked=""/><div class="controls bullet"><span class="by">jakeogh</span><span>|</span><a href="#35882629">parent</a><span>|</span><a href="#35882765">prev</a><span>|</span><a href="#35884081">next</a><span>|</span><label class="collapse" for="c-35883176">[-]</label><label class="expand" for="c-35883176">[1 more]</label></div><br/><div class="children"><div class="content">I spent some time formalizing mkdir&#x2F;noclobber locks (with lots of help from #bash): <a href="https:&#x2F;&#x2F;github.com&#x2F;jakeogh&#x2F;commandlock">https:&#x2F;&#x2F;github.com&#x2F;jakeogh&#x2F;commandlock</a><p>Long term work in progress... needs a simple Makefile</div><br/></div></div></div></div><div id="35884081" class="c"><input type="checkbox" id="c-35884081" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#35882629">prev</a><span>|</span><a href="#35883193">next</a><span>|</span><label class="collapse" for="c-35884081">[-]</label><label class="expand" for="c-35884081">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unfortunately, this change creates another surprising situation, which is that the NFS server and a NFS client can both obtain an exclusive flock() lock on the same file. Two NFS clients trying to exclusively flock() the same file will conflict with each other and only one will succeed, but the NFS server and an NFS client won&#x27;t, and both will &#x27;win&#x27; the lock (and everyone loses). This is the inevitable but surprising consequence of client side flock() locks being changed to POSIX locks on the NFS server, and POSIX locks not conflicting with flock() locks. From the NFS server&#x27;s perspective, it&#x27;s not two flock() exclusive locks on a file; it&#x27;s one exclusive POSIX lock (from a NFS client) and one exclusive local flock() lock, and that&#x27;s nominally fine.<p>One might say &quot;right, so don&#x27;t run apps on the file server&quot;, but if the file server is running multiple file server protocols some of which want to locally flock(), then you lose unless flocks and POSIX locks are made to conflict.<p>So either rip out this feature of the NFS client on Linux or make local flock locks and POSIX locks conflict at the very least if the filesystem is shared via NFS.</div><br/></div></div><div id="35883193" class="c"><input type="checkbox" id="c-35883193" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#35884081">prev</a><span>|</span><a href="#35884246">next</a><span>|</span><label class="collapse" for="c-35883193">[-]</label><label class="expand" for="c-35883193">[4 more]</label></div><br/><div class="children"><div class="content">Reading the Linux and BSD man pages for <i>flock</i> confuses me.<p><a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;flock.2.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;flock.2.html</a> says:<p><i>“Locks created by flock() are associated with an open file description”</i><p>On the other hand <a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;flock.2" rel="nofollow">https:&#x2F;&#x2F;man.openbsd.org&#x2F;flock.2</a> says:<p><i>“Locks are on files, not file descriptors.”</i><p>I guess the truth is in the middle. They’re associated with file descriptors, but cloning a file descriptor (e.g. through <i>fork</i> or <i>dup</i>) gives you true clones that both hold the lock.<p>Or are the Linux and OpenBSD functions subtly different?<p>The Linux man page also is confusing in that it says<p><i>“Only one process may hold an exclusive lock for a given file at a given time”</i><p>while, if I understand things correctly, also claiming that a forked process retains the locks of the parent process. So, what happens if that’s an exclusive lock? Does <i>fork</i> fail?</div><br/><div id="35883260" class="c"><input type="checkbox" id="c-35883260" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#35883193">parent</a><span>|</span><a href="#35884246">next</a><span>|</span><label class="collapse" for="c-35883260">[-]</label><label class="expand" for="c-35883260">[3 more]</label></div><br/><div class="children"><div class="content">The statements are not contradictory, just confusingly worded.  A lock is <i>on</i> a file, <i>held by</i> an open file description.<p>Also note that, &quot;open file description&quot; != &quot;file descriptor&quot;.  An open file description exists only in the kernel, and is created on open(2).  A file descriptor is the userland-visible handle to this open file description.  dup(2) creates a new handle (file descriptor) pointing to this same open file description.  Therefore, dup(2), fork(2), etc., do not violate the mutex property of the lock, since they are duplicating the file descriptors (handles), not the open file descriptions (which actually hold the locks).<p>What&#x27;s not clear from the man pages is what happens to a locked open file description which is passed to another process via a Unix domain socket.  I suspect at that point, both &quot;processes&quot; &quot;hold&quot; the lock -- which in reality simply means they both have a file descriptor referring to the same single open file description which holds the lock, thus not violating the mutex property.  Though this contradicts the extensive verbiage in flock(2) which refers to &quot;processes&quot; as being subject to the mutex property, I suspect that is a simplification, as later text in flock(2) indicates that open file descriptions are indeed the subject of the mutex property.</div><br/><div id="35884552" class="c"><input type="checkbox" id="c-35884552" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#35883193">root</a><span>|</span><a href="#35883260">parent</a><span>|</span><a href="#35883527">next</a><span>|</span><label class="collapse" for="c-35884552">[-]</label><label class="expand" for="c-35884552">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Completely overlooked that they talked about ‘description’, not ‘descriptor’ in several places.<p>It would have helped me if they pointed out that difference in a clearer way. The Linux man page says ‘Locks created by flock() are associated with an open file description (see open(2))’, and that says:<p><i>“The term open file description is the one used by POSIX to refer to the entries in the system-wide table of open files.  In other contexts, this object is variously also called an &quot;open file object&quot;, a &quot;file handle&quot;, an &quot;open file table entry&quot;, or—in kernel-developer parlance—a struct file.”</i></div><br/></div></div><div id="35883527" class="c"><input type="checkbox" id="c-35883527" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#35883193">root</a><span>|</span><a href="#35883260">parent</a><span>|</span><a href="#35884552">prev</a><span>|</span><a href="#35884246">next</a><span>|</span><label class="collapse" for="c-35883527">[-]</label><label class="expand" for="c-35883527">[1 more]</label></div><br/><div class="children"><div class="content">In the Windows land, those things are indeed called &quot;file objects&quot; and &quot;file handles&quot; respectively, which is a much less confusing terminology.</div><br/></div></div></div></div></div></div><div id="35884246" class="c"><input type="checkbox" id="c-35884246" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#35883193">prev</a><span>|</span><a href="#35883121">next</a><span>|</span><label class="collapse" for="c-35884246">[-]</label><label class="expand" for="c-35884246">[1 more]</label></div><br/><div class="children"><div class="content">rename() is an atomic and portable method of file locking that has worked everywhere for 30 years. Just rename a file. If you can stat the file, it hasn&#x27;t been renamed yet. If you try to stat the file and get an error that it doesn&#x27;t exist, someone already has the lock. When you can stat it, try to rename it; rename will only succeed if your system call successfully renamed it, in which case you have the lock. If rename fails, the lock was taken. Rename the file back to unlock it.<p>Works on every filesystem because you can&#x27;t just cache a rename (wouldn&#x27;t make much sense to try to open a file that doesn&#x27;t exist after a rename) and you can&#x27;t have a rename race condition.</div><br/></div></div><div id="35883121" class="c"><input type="checkbox" id="c-35883121" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#35884246">prev</a><span>|</span><a href="#35884322">next</a><span>|</span><label class="collapse" for="c-35883121">[-]</label><label class="expand" for="c-35883121">[1 more]</label></div><br/><div class="children"><div class="content">Not mentioned: “Open file description locks” (<a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;fcntl.2.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;fcntl.2.html</a>), which are the locks you usually <i>actually</i> want.</div><br/></div></div><div id="35884322" class="c"><input type="checkbox" id="c-35884322" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35883121">prev</a><span>|</span><a href="#35882776">next</a><span>|</span><label class="collapse" for="c-35884322">[-]</label><label class="expand" for="c-35884322">[1 more]</label></div><br/><div class="children"><div class="content">The locks that never actually lock unless all gotchas are taken care of, and even then, might break on other UNIX platforms.<p>Hence why I rather prefer the locks on non UNIX platforms,  they actually lock.</div><br/></div></div><div id="35882776" class="c"><input type="checkbox" id="c-35882776" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#35884322">prev</a><span>|</span><a href="#35882734">next</a><span>|</span><label class="collapse" for="c-35882776">[-]</label><label class="expand" for="c-35882776">[3 more]</label></div><br/><div class="children"><div class="content">Does anybody know how Linux NFS handles new OFD-owned file locks? Are they also mapped to classic POSIX locks?<p>OFD-owned locks are a cross of BSD flock and POSIX fcntl&#x2F;lockf locks. An original proposal is described at <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;586904&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;586904&#x2F;</a>, but the naming convention settled on OFD-owned (open file descriptor-owned) rather than file-private. I believe Linux was the first to get an implementation. They&#x27;re also included in the latest POSIX&#x2F;SUSv5 draft; &quot;POSIX locks&quot; will become ambiguous in the next year or two.</div><br/><div id="35882905" class="c"><input type="checkbox" id="c-35882905" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#35882776">parent</a><span>|</span><a href="#35882734">next</a><span>|</span><label class="collapse" for="c-35882905">[-]</label><label class="expand" for="c-35882905">[2 more]</label></div><br/><div class="children"><div class="content">Not quite answering your question, but the man page says<p><pre><code>  Conflicting lock combinations (i.e., a read lock and a write lock or two write locks) where one lock is an open file description lock and the other is a traditional record lock conflict even when they are acquired by the same process on the same file descriptor.</code></pre></div><br/><div id="35883416" class="c"><input type="checkbox" id="c-35883416" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#35882776">root</a><span>|</span><a href="#35882905">parent</a><span>|</span><a href="#35882734">next</a><span>|</span><label class="collapse" for="c-35883416">[-]</label><label class="expand" for="c-35883416">[1 more]</label></div><br/><div class="children"><div class="content">I think that answers it. And looking back at the specification in the SUSv5 draft, it seems this and analogous behavior has been codified--an OFD lock conflicts with a process-private lock and vice-versa. So there&#x27;s only one reasonable option for mapping OFD locks to NFS locks, which is that they both map  to the same NFS server lock in the same manner (unlike BSD flock, both support record locking).</div><br/></div></div></div></div></div></div><div id="35882734" class="c"><input type="checkbox" id="c-35882734" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#35882776">prev</a><span>|</span><a href="#35883761">next</a><span>|</span><label class="collapse" for="c-35882734">[-]</label><label class="expand" for="c-35882734">[4 more]</label></div><br/><div class="children"><div class="content">Wherever possible it is better to use filelocks (a named file or directory) or SQLite (which deals with the arcana for you and has been both unit and battle tested).<p>Using file locking APIs is just a minefield of pain otherwise.</div><br/><div id="35883321" class="c"><input type="checkbox" id="c-35883321" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35882734">parent</a><span>|</span><a href="#35883761">next</a><span>|</span><label class="collapse" for="c-35883321">[-]</label><label class="expand" for="c-35883321">[3 more]</label></div><br/><div class="children"><div class="content">I find that SQLITE_BUSY causes too many failures when used in this capacity.<p>Better to use a guaranteed atomic call; my preference is mkdir.</div><br/><div id="35883580" class="c"><input type="checkbox" id="c-35883580" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#35882734">root</a><span>|</span><a href="#35883321">parent</a><span>|</span><a href="#35883761">next</a><span>|</span><label class="collapse" for="c-35883580">[-]</label><label class="expand" for="c-35883580">[2 more]</label></div><br/><div class="children"><div class="content">You can get effectively the same behavior as an mkdir based lockfile when using BEGIN IMMEDIATE instead of just BEGIN with a WAL based SQLite db. (other modes should use BEGIN EXCLUSIVE). Using this feature statements will immediately fail if another process is writing to the db and you can use the sqlite3_busy_timeout to manage automatic retries for you (if desired).<p>The benefits over the lockfile approach include:<p>- transactional semantics &amp; rollbacks<p>- optional concurrent read only queries in WAL mode if you initiate them with BEGIN DEFERRED that operate on a snapshot of data and don&#x27;t impede the writing process<p>- simple online backups via VACUUM INTO.<p>Cons are it is heavier weight than a mkdir call and if all you want to do is elect a master process from a group and don&#x27;t have structured data to operate on transactionaly then it&#x27;s not worth it.</div><br/><div id="35883760" class="c"><input type="checkbox" id="c-35883760" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35882734">root</a><span>|</span><a href="#35883580">parent</a><span>|</span><a href="#35883761">next</a><span>|</span><label class="collapse" for="c-35883760">[-]</label><label class="expand" for="c-35883760">[1 more]</label></div><br/><div class="children"><div class="content">Oh my, you must understand the limitations of WAL mode. I just don&#x27;t think that SQLite is an appropriate alternative to mkdir() locking.<p><i>You cannot use WAL mode with networked filesystems as all processes cannot see the shared memory.</i><p>Below are well-known limitations of WAL mode.<p><a href="https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol15&#x2F;p3535-gaffney.pdf" rel="nofollow">https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol15&#x2F;p3535-gaffney.pdf</a><p>“To accelerate searching the WAL, SQLite creates a WAL index in shared memory. This improves the performance of read transactions, but the use of shared memory requires that all readers must be on the same machine [and OS instance]. Thus, WAL mode does not work on a network filesystem.”<p>“It is not possible to change the page size after entering WAL mode.”<p>“In addition, WAL mode comes with the added complexity of checkpoint operations and additional files to store the WAL and the WAL index.”<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;lang_attach.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;lang_attach.html</a><p>“SQLite does not guarantee ACID consistency with ATTACH DATABASE in WAL mode. “Transactions involving multiple attached databases are atomic, assuming that the main database is not &quot;:memory:&quot; and the journal_mode is not WAL. If the main database is &quot;:memory:&quot; or if the journal_mode is WAL, then transactions continue to be atomic within each individual database file. But if the host computer crashes in the middle of a COMMIT where two or more database files are updated, some of those files might get the changes where others might not.”<p>I just don&#x27;t think that SQLite is an appropriate alternative to mkdir() locking.<p>It&#x27;s just the wrong tool.</div><br/></div></div></div></div></div></div></div></div><div id="35883761" class="c"><input type="checkbox" id="c-35883761" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#35882734">prev</a><span>|</span><a href="#35881870">next</a><span>|</span><label class="collapse" for="c-35883761">[-]</label><label class="expand" for="c-35883761">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of locks if you are writing something that can run a long time and produces a log file it might be nice if you locked the log file before appending a new log entry.<p>If you do that, someone who wants to rotate logs can do it by (1) locking the log file, (2) copying it to the rotated file, (3) truncating the log file, and (4) releasing the lock.<p>Here&#x27;s a C program, cat-trunc, that does that. Usage is &quot;cat-trunc logfile&quot;.<p><pre><code>  #include &lt;stdio.h&gt;
  #include &lt;sys&#x2F;types.h&gt;
  #include &lt;sys&#x2F;stat.h&gt;
  #include &lt;fcntl.h&gt;
  #include &lt;unistd.h&gt;

  char buf[65536];

  int main(int argc, char *argv[])
  {
    struct flock l;
    ssize_t got;
    ssize_t copied = 0;
    off_t eof;
    int finished = 0;
    int status = 0;

    if (argc != 2)
    {
        fprintf(stderr, &quot;%s: error: no log file specified!\n&quot;, argv[0]);
        return 1;
    }

    int fd = open(argv[1], O_RDWR);
    if (fd == -1)
    {
        perror(argv[0]);
        return 2;
    }

    l.l_whence = SEEK_SET;
    l.l_start = 0;
    l.l_len = 0;

    while (! finished) {
        got = read(fd, buf, sizeof buf);
        if (got &gt; 0) {
            copied += got;
            if (write(1, buf, got) != got) {
                status = -1;
                finished = 1;
                perror(argv[0]);
            }
        } else if (got == 0) {
            l.l_type = F_WRLCK;
            fcntl(fd, F_SETLKW, &amp;l); 
            eof = lseek(fd, 0, SEEK_END);
            if (eof == copied) {
                ftruncate(fd, 0);
                finished = 1;
            } else {
                lseek(fd, copied, SEEK_SET);
            }
            l.l_type = F_UNLCK;
            fcntl(fd, F_SETLKW, &amp;l);
        } else {
            status = -1;
            finished = 1;
            perror(argv[0]);
        }
    }
    return status;
  }
</code></pre>
That&#x27;s a little more complicated than is necessary, because it tries to minimize the time it holds the lock.<p>If you&#x27;ve got a long running program whose stdout you want to log here&#x27;s a C++ program (but written like it is C plus std::string and std::list because I am lazy), lock-save, to help with that. Usage is &quot;lock-save [-t] file&quot;. It copies stdin to file, writing a line at a time, locking the file for those writes. You can then use cat-trunc to rotate the file. The -t option makes it also copy stdin to stdout, making it essentially tee with locks.<p><pre><code>  #include &lt;stdio.h&gt;
  #include &lt;sys&#x2F;types.h&gt;
  #include &lt;sys&#x2F;stat.h&gt;
  #include &lt;pwd.h&gt;
  #include &lt;fcntl.h&gt;
  #include &lt;unistd.h&gt;
  #include &lt;string&gt;
  #include &lt;list&gt;

  std::list&lt;std::string&gt;  lines;

  int main(int argc, char *argv[])
  {
    char * prog_name = argv[0];
    char * file_name = 0;
    int t_flag = 0;
    struct flock l;
    int c;
    std::string line;

    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-t&quot;) == 0) {
        t_flag = 1;
    }
    if (argc != 2+t_flag) {
        fprintf(stderr, &quot;Usage: %s [-t] file\n&quot;, prog_name);
        return 1;
    }
    file_name = argv[1+t_flag];

    int fd = open(file_name, O_RDWR | O_CREAT | O_APPEND, 0666);
    if (fd == -1) {
        perror(prog_name);
        return 2;
    }

    l.l_whence = SEEK_SET;
    l.l_start = 0;
    l.l_len = 0;
    while ((c = getchar()) != EOF) {
        if (t_flag) {
            putchar(c);
        }
        line += c;
        if (c == &#x27;\n&#x27;) {
            lines.push_back(line);
            l.l_type = F_WRLCK;
            if (fcntl(fd, F_SETLK, &amp;l) != -1) {
                while (lines.size())
                {
                    line = lines.front();
                    lines.pop_front();
                    write(fd, line.c_str(), line.length());
                }
                l.l_type = F_UNLCK;
                fcntl(fd, F_SETLK, &amp;l);
                line = &quot;&quot;;
            }
        }
    }
    return 0;
  }</code></pre></div><br/><div id="35884465" class="c"><input type="checkbox" id="c-35884465" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#35883761">parent</a><span>|</span><a href="#35881870">next</a><span>|</span><label class="collapse" for="c-35884465">[-]</label><label class="expand" for="c-35884465">[1 more]</label></div><br/><div class="children"><div class="content">...what&#x27;s wrong with writing to stderr? If you do <i>that</i>, then whatever is on its reading side can route the logs wherever and however it wants to, without any need for locking&#x2F;truncating shenanigans. Or is it way too simple?</div><br/></div></div></div></div><div id="35881870" class="c"><input type="checkbox" id="c-35881870" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#35883761">prev</a><span>|</span><a href="#35882222">next</a><span>|</span><label class="collapse" for="c-35881870">[-]</label><label class="expand" for="c-35881870">[3 more]</label></div><br/><div class="children"><div class="content">All the peculiarities of NFS actually made it so operationally it is optimal for us to just have the NFS server be incredibly dumb. All the action is on clients. Modern Linux permits xattr and flock over NFS so everything will work out so long as you use precisely one kind of lock over NFS and do your xattrs over NFS as well.<p>Honestly, it would be pretty nice to have some sort of path locking and an ability to request delegation on NFS rather than have it be this automatic conflict-resolution style. But whatever, ultimately it works.</div><br/><div id="35883028" class="c"><input type="checkbox" id="c-35883028" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#35881870">parent</a><span>|</span><a href="#35882693">next</a><span>|</span><label class="collapse" for="c-35883028">[-]</label><label class="expand" for="c-35883028">[1 more]</label></div><br/><div class="children"><div class="content">NFS has so many stupid warts that I often just use samba to share between Linux servers and feel bad about it.</div><br/></div></div><div id="35882693" class="c"><input type="checkbox" id="c-35882693" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#35881870">parent</a><span>|</span><a href="#35883028">prev</a><span>|</span><a href="#35882222">next</a><span>|</span><label class="collapse" for="c-35882693">[-]</label><label class="expand" for="c-35882693">[1 more]</label></div><br/><div class="children"><div class="content">The NFSv4 client is not dumb, as it implements delegations and can recall them from a client after they are granted.<p>Unlinking a file over NFS has also been implemented as renaming to a temporary file, so slight of hand intelligence was present in earlier versions.</div><br/></div></div></div></div><div id="35882222" class="c"><input type="checkbox" id="c-35882222" checked=""/><div class="controls bullet"><span class="by">syngrog66</span><span>|</span><a href="#35881870">prev</a><span>|</span><label class="collapse" for="c-35882222">[-]</label><label class="expand" for="c-35882222">[1 more]</label></div><br/><div class="children"><div class="content">fantastic article on flocks and NFS! and short and sweet<p>I was bitten many years ago by a few of the gotchas he covers in it. great to see clear and precise treatment like this. I like to keep an accurate model of the system in my ind, and pieces like this help me to do that a little better</div><br/></div></div></div></div></div></div></div></body></html>