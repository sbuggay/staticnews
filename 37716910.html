<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696150859561" as="style"/><link rel="stylesheet" href="styles.css?v=1696150859561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.righto.com/2023/09/8086-flip-flops.html">How flip-flops are implemented in the Intel 8086 processor</a> <span class="domain">(<a href="http://www.righto.com">www.righto.com</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>32 comments</span></div><br/><div><div id="37717823" class="c"><input type="checkbox" id="c-37717823" checked=""/><div class="controls bullet"><span class="by">denotational</span><span>|</span><a href="#37717022">next</a><span>|</span><label class="collapse" for="c-37717823">[-]</label><label class="expand" for="c-37717823">[4 more]</label></div><br/><div class="children"><div class="content">&gt; However, the enable input is a fairly obscure feature for a flip-flop component; most flip-flop chips have a clock input, but not an enable.<p>The clock-enable is actually <i>really</i> common for flops in an integrated circuit; it might have been unusual in the days of discrete TTL, but as the article concedes, practically every cell library or FPGA fabric you can find will have it.<p>Not only is it commonly present, but the CE is used all the time by the synthesis&#x2F;technology-mapping process, indeed any time you write an `if` without an `else` within a clock-edge sensitive process, the tool is probably going to use a CE.<p>On an FPGA, the only other option is a LUT-based feedback mux which can be undesirable for various reasons, including the use of additional routing resources if the fabric has no dedicated route in each CLB from the output flop to the input LUT, and the increased fanout on the flop.</div><br/><div id="37722333" class="c"><input type="checkbox" id="c-37722333" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#37717823">parent</a><span>|</span><a href="#37718218">next</a><span>|</span><label class="collapse" for="c-37722333">[-]</label><label class="expand" for="c-37722333">[1 more]</label></div><br/><div class="children"><div class="content">There were a few TTL ones available: 74x378 is one I used back in the day.  It was easier to meet timing with parts like this.  I used it for my PCI cards: it was part of a circuit that latched the address of PCI configuration writes- the only data that would make it to the board if the transaction times out.  Why did I need this? To load the bits into Xilinx 4010E FPGA which held the full PCI interface, thereby avoiding the need for a Xilinx configuration PROM.  After the design was loaded, the PCI interface would come alive and start responding to transactions.<p>This worked until Intel decided to save power by disabling the PCI clock on unused sockets: it means your device had better exist on the bus before the BIOS&#x27;s PCI enumeration (actually this is not true- with the full bridge documentation I could enable the clock- but I didn&#x27;t have it, and in any case, then the design would be chipset dependent).</div><br/></div></div><div id="37718218" class="c"><input type="checkbox" id="c-37718218" checked=""/><div class="controls bullet"><span class="by">guepe</span><span>|</span><a href="#37717823">parent</a><span>|</span><a href="#37722333">prev</a><span>|</span><a href="#37717022">next</a><span>|</span><label class="collapse" for="c-37718218">[-]</label><label class="expand" for="c-37718218">[2 more]</label></div><br/><div class="children"><div class="content">Xilinx&#x2F;amd fpga have a CE pin on many of its flops (if not all?). Not sure for altera&#x2F;intel but would be surprised they wouldn&#x27;t have.</div><br/><div id="37718517" class="c"><input type="checkbox" id="c-37718517" checked=""/><div class="controls bullet"><span class="by">denotational</span><span>|</span><a href="#37717823">root</a><span>|</span><a href="#37718218">parent</a><span>|</span><a href="#37717022">next</a><span>|</span><label class="collapse" for="c-37718517">[-]</label><label class="expand" for="c-37718517">[1 more]</label></div><br/><div class="children"><div class="content">I pretty much only work with Xilinx&#x2F;AMD parts these days, and, at least on US&#x2F;US+, they do indeed all have a CE on all the flops (unless there are undocumented degenerate cells with missing features).</div><br/></div></div></div></div></div></div><div id="37717022" class="c"><input type="checkbox" id="c-37717022" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37717823">prev</a><span>|</span><a href="#37717840">next</a><span>|</span><label class="collapse" for="c-37717022">[-]</label><label class="expand" for="c-37717022">[10 more]</label></div><br/><div class="children"><div class="content">Author here for all your 8086 questions :-)<p>By the way, HN&#x27;s title editing makes the title appear a bit strange. Of course flip-flops are implemented in the processor. The article describes <i>how</i> they are implemented.</div><br/><div id="37718430" class="c"><input type="checkbox" id="c-37718430" checked=""/><div class="controls bullet"><span class="by">mochomocha</span><span>|</span><a href="#37717022">parent</a><span>|</span><a href="#37721482">next</a><span>|</span><label class="collapse" for="c-37718430">[-]</label><label class="expand" for="c-37718430">[2 more]</label></div><br/><div class="children"><div class="content">I just wanted to express gratitude for the amazing work you&#x27;re doing. As someone with no hardware background, I learnt a lot from reading your blog, and I marvel at the amount of collective human intelligence packed into all the tiny chips surrounding our daily lives.</div><br/><div id="37718511" class="c"><input type="checkbox" id="c-37718511" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37717022">root</a><span>|</span><a href="#37718430">parent</a><span>|</span><a href="#37721482">next</a><span>|</span><label class="collapse" for="c-37718511">[-]</label><label class="expand" for="c-37718511">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Yes, it&#x27;s amazing how much effort is packed into tiny chips, especially when you consider that the 8086 was 45 years ago.</div><br/></div></div></div></div><div id="37721482" class="c"><input type="checkbox" id="c-37721482" checked=""/><div class="controls bullet"><span class="by">brudgers</span><span>|</span><a href="#37717022">parent</a><span>|</span><a href="#37718430">prev</a><span>|</span><a href="#37717055">next</a><span>|</span><label class="collapse" for="c-37721482">[-]</label><label class="expand" for="c-37721482">[3 more]</label></div><br/><div class="children"><div class="content">Understanding that the wires are used as capacitors makes the tiny scale of the tiny electronics inside chips make sense.<p>I feel inside-the-sausage-factory enlightenment. Which practically speaking might be the best kind I will experience. Thank you.</div><br/><div id="37721808" class="c"><input type="checkbox" id="c-37721808" checked=""/><div class="controls bullet"><span class="by">dev_tty01</span><span>|</span><a href="#37717022">root</a><span>|</span><a href="#37721482">parent</a><span>|</span><a href="#37717055">next</a><span>|</span><label class="collapse" for="c-37721808">[-]</label><label class="expand" for="c-37721808">[2 more]</label></div><br/><div class="children"><div class="content">Most of the capacitance is likely the gate capacitance at the input of the inverters.</div><br/><div id="37721980" class="c"><input type="checkbox" id="c-37721980" checked=""/><div class="controls bullet"><span class="by">brudgers</span><span>|</span><a href="#37717022">root</a><span>|</span><a href="#37721808">parent</a><span>|</span><a href="#37717055">next</a><span>|</span><label class="collapse" for="c-37721980">[-]</label><label class="expand" for="c-37721980">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, the high bit for me is that there are not tiny discrete capacitors inside.<p>It changed my mental model. And the new model is less complicated.</div><br/></div></div></div></div></div></div><div id="37717055" class="c"><input type="checkbox" id="c-37717055" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#37717022">parent</a><span>|</span><a href="#37721482">prev</a><span>|</span><a href="#37719179">next</a><span>|</span><label class="collapse" for="c-37717055">[-]</label><label class="expand" for="c-37717055">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, I edited the title. This HN misfeature regularly makes me furious.</div><br/></div></div><div id="37719179" class="c"><input type="checkbox" id="c-37719179" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#37717022">parent</a><span>|</span><a href="#37717055">prev</a><span>|</span><a href="#37717840">next</a><span>|</span><label class="collapse" for="c-37719179">[-]</label><label class="expand" for="c-37719179">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve toyed with the idea of a flip-flop that captures the input on both rising and falling edges. Doing this at the gate level seems inefficient, so I&#x27;ve wondered if there is a better way to design it, and if anyone uses such a thing in production. What do you think?</div><br/><div id="37719214" class="c"><input type="checkbox" id="c-37719214" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#37717022">root</a><span>|</span><a href="#37719179">parent</a><span>|</span><a href="#37721404">next</a><span>|</span><label class="collapse" for="c-37719214">[-]</label><label class="expand" for="c-37719214">[1 more]</label></div><br/><div class="children"><div class="content">Double sided flip flops are used in DDR SDRAM and many other applications.
<a href="https:&#x2F;&#x2F;docs.xilinx.com&#x2F;r&#x2F;en-US&#x2F;am010-versal-selectio&#x2F;Double-Data-Rate-Flip-Flops" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.xilinx.com&#x2F;r&#x2F;en-US&#x2F;am010-versal-selectio&#x2F;Double...</a></div><br/></div></div><div id="37721404" class="c"><input type="checkbox" id="c-37721404" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#37717022">root</a><span>|</span><a href="#37719179">parent</a><span>|</span><a href="#37719214">prev</a><span>|</span><a href="#37717840">next</a><span>|</span><label class="collapse" for="c-37721404">[-]</label><label class="expand" for="c-37721404">[1 more]</label></div><br/><div class="children"><div class="content">This is where the double in &quot;double data rate&quot; comes from.</div><br/></div></div></div></div></div></div><div id="37717840" class="c"><input type="checkbox" id="c-37717840" checked=""/><div class="controls bullet"><span class="by">SomeoneFromCA</span><span>|</span><a href="#37717022">prev</a><span>|</span><label class="collapse" for="c-37717840">[-]</label><label class="expand" for="c-37717840">[17 more]</label></div><br/><div class="children"><div class="content">Some observations:<p>1. Interesting, how fundamentally analog element such as capacitor, find its way into dynamic logic circuits.<p>2. The article states that asynchronous computers are not made anymore. Is not google TPU asynchronous?</div><br/><div id="37722367" class="c"><input type="checkbox" id="c-37722367" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#37717840">parent</a><span>|</span><a href="#37718314">next</a><span>|</span><label class="collapse" for="c-37722367">[-]</label><label class="expand" for="c-37722367">[1 more]</label></div><br/><div class="children"><div class="content">So at the opposite end of the speed spectrum, you might enjoy my relay computer: it uses a capacitor for the master part of the flip-flop for exactly the same reason- to save on the number of active components.  See:<p><a href="https:&#x2F;&#x2F;relaysbc.sourceforge.net&#x2F;circuits.html#:~:text=Low%20relay%20count%20master%2Dslave%20flip%2Dflop" rel="nofollow noreferrer">https:&#x2F;&#x2F;relaysbc.sourceforge.net&#x2F;circuits.html#:~:text=Low%2...</a></div><br/></div></div><div id="37718314" class="c"><input type="checkbox" id="c-37718314" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37717840">parent</a><span>|</span><a href="#37722367">prev</a><span>|</span><a href="#37719845">next</a><span>|</span><label class="collapse" for="c-37718314">[-]</label><label class="expand" for="c-37718314">[12 more]</label></div><br/><div class="children"><div class="content">All digital logic is fundamentally analog.<p>No, the TPU is not async.  It has a single main clock.  It does work in parallel, but it&#x27;s still synchronously clocked.  As neat as async is, it&#x27;s truly a paradigm shift that affects nearly everything about your system and most of us can&#x27;d think in partial differential equations.</div><br/><div id="37718381" class="c"><input type="checkbox" id="c-37718381" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718314">parent</a><span>|</span><a href="#37718673">next</a><span>|</span><label class="collapse" for="c-37718381">[-]</label><label class="expand" for="c-37718381">[7 more]</label></div><br/><div class="children"><div class="content">One of Vonada&#x27;s 14 engineering maxims is &quot;Digital circuits are made from analog parts.&quot; That said, dynamic logic that depends on capacitance is more analog than most digital logic :-)<p>Vonada&#x27;s engineering maxims: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;kenshirriff&#x2F;status&#x2F;1633154548318732289" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;kenshirriff&#x2F;status&#x2F;1633154548318732289</a></div><br/><div id="37723565" class="c"><input type="checkbox" id="c-37723565" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718381">parent</a><span>|</span><a href="#37719029">next</a><span>|</span><label class="collapse" for="c-37723565">[-]</label><label class="expand" for="c-37723565">[1 more]</label></div><br/><div class="children"><div class="content">Much different from one of Bob Widlar&#x27;s random maxims that was &quot;[digital?] every idiot can count to one.&quot;</div><br/></div></div><div id="37719029" class="c"><input type="checkbox" id="c-37719029" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718381">parent</a><span>|</span><a href="#37723565">prev</a><span>|</span><a href="#37718673">next</a><span>|</span><label class="collapse" for="c-37719029">[-]</label><label class="expand" for="c-37719029">[5 more]</label></div><br/><div class="children"><div class="content">OK I learned a bit today- I didn&#x27;t realize transistors were considered &quot;active&quot;, or that dynamic logic was uncommon.<p>Vonada&#x27;s engineering maxims are pretty scary to me- an amateur hobbyist soldering various chips together to build simple projects like &quot;a rotary encoding controlling a binary counter visualized with LEDs&quot;.  I spend many hours soldering and carefully debugging every individual component, and when I integrate, spend many more hours debugging why something doesn&#x27;t work.  The failures are almost always because I did something dumb, like wiring up VCC and GND backward, I honestly don&#x27;t know that I&#x27;d be able to debug &quot;When all but one wire in a group of wires switch, that one will switch also.&quot; in my binary counter&#x27;s inputs or outputs.</div><br/><div id="37719818" class="c"><input type="checkbox" id="c-37719818" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37719029">parent</a><span>|</span><a href="#37719957">next</a><span>|</span><label class="collapse" for="c-37719818">[-]</label><label class="expand" for="c-37719818">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Vonada&#x27;s engineering maxims are pretty scary to me- an amateur hobbyist soldering various chips together to build simple projects like &quot;a rotary encoding controlling a binary counter visualized with LEDs&quot;<p>Fortunately for probably most hobby projects you don&#x27;t have to worry about most of those things.<p>A lot of those maxims concern failures of the lumped element model.<p>The lumped element model is a model where all the capacitance occurs in capacitors, all the resistance is in resistors, all the inductance is in inductors, and so on, and wires are zero resistance conductors of current that do not couple magnetically or inductively with anything.<p>If clock speeds aren&#x27;t too high, there is enough gap between the highest 0 logic voltage and the lowest 1 logic voltage, wires aren&#x27;t too long, voltages and currents aren&#x27;t too high or too low, and you don&#x27;t do anything like put loops in your wires (other than when you are intentionally trying to make an inductor) the deviations of reality from the lumped element model shouldn&#x27;t cause any problems.<p>As you deal with higher frequencies reality starts to noticeably diverge from the lumped element model. You have to start worrying about things like capacitance between leads on your components, inductance between wires, and wires acting like transmission lines.<p>Keep going up in frequency and you can get to a point where you have to use software that can solve (exactly or numerically) Maxwell&#x27;s equations for the fields around things and take into account interactions with those fields.<p>Hobbyist projects can do things that get past where the lumped element model is all you need, such as WiFi or Bluetooth which operate at several GHz, but usually those functions are handled by modules that the hobbyist buys that are (hopefully!) designed by people who know how to deal with high frequencies. E.g., you buy an RF module that does the scary radio stuff, and you control it from a microcontroller that is running an order of magnitude or more slower than the RF module, and whatever inputs and sensors and non-radio outputs you have are probably at least an order of magnitude slower than your microcontroller.<p>Those non-RF parts of the project are likely to be well in the realm where lumped element works.<p>Most of the rest of the maxims concern things that are mostly going to be a problem for big projects where you might be worrying about things like synchronizing things across dozens of subsystems and with very tight tolerances.</div><br/><div id="37720091" class="c"><input type="checkbox" id="c-37720091" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37719818">parent</a><span>|</span><a href="#37721300">next</a><span>|</span><label class="collapse" for="c-37720091">[-]</label><label class="expand" for="c-37720091">[1 more]</label></div><br/><div class="children"><div class="content">In digital circuits the “frequency” when the lumped model breaks down is determined by the slew-rate (ie. spectral content of the edges), not the bitrate&#x2F;clock frequency. In the electronics hobbyist community there are many cases when you can run into that issue head first while just connecting modules together (because the whatever IC on the module has significantly faster slew-rate than you need). Another example are MCUs with somewhat high internal clock rates and their power requirements, even 20-ish year old dsPIC requires somewhat involved supply decoupling topology to work at all (and the quality of decoupling for ESP32 has direct effect on signal quality and how much of RF noise it spews out).</div><br/></div></div><div id="37721300" class="c"><input type="checkbox" id="c-37721300" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37719818">parent</a><span>|</span><a href="#37720091">prev</a><span>|</span><a href="#37719957">next</a><span>|</span><label class="collapse" for="c-37721300">[-]</label><label class="expand" for="c-37721300">[1 more]</label></div><br/><div class="children"><div class="content">The one situation where this seems to come up is that I&#x27;m using PWM duty cycle to control a constant current LED driver.  Because my light is far too bright at full intensity, the driver has a PWM pin that lets attenuate that.  however, because I&#x27;m taking extremely fast images (sub-millisecond exposures), if I use a low PWM frequency (&lt;1MHz) I see image artifacts.  I am trying 1MHz PWM (generated by my arduino) on a solderless breadboard, and I see flaky behavior when I increase the PWM beyond 250KHz or so.  Things look fine on my scope, but the LED itself often doesn&#x27;t behave as expected.</div><br/></div></div></div></div><div id="37719957" class="c"><input type="checkbox" id="c-37719957" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37719029">parent</a><span>|</span><a href="#37719818">prev</a><span>|</span><a href="#37718673">next</a><span>|</span><label class="collapse" for="c-37719957">[-]</label><label class="expand" for="c-37719957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I honestly don&#x27;t know that I&#x27;d be able to debug &quot;When all but one wire in a group of wires switch, that one will switch also.&quot; in my binary counter&#x27;s inputs or outputs.<p>The intention of the maxim is to design the system in a such way that the all-but-one situation never happens. And if it has to happen then you need to be sure that the “analog stuff” and “black magic” like power supply decoupling and ground return paths is handled correctly.<p>And in fact the binary counter is perfect example for that. You can design that as an ripple counter or synchronous counter. Ripple counter is simpler and does not suffer from these kind of issues because the switching ripples through the bits LSB to HSB, which also means that there is a period of time before the output stabilizes where it is simply wrong, which is the main drawback of that design.</div><br/></div></div></div></div></div></div><div id="37718673" class="c"><input type="checkbox" id="c-37718673" checked=""/><div class="controls bullet"><span class="by">SomeoneFromCA</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718314">parent</a><span>|</span><a href="#37718381">prev</a><span>|</span><a href="#37719845">next</a><span>|</span><label class="collapse" for="c-37718673">[-]</label><label class="expand" for="c-37718673">[4 more]</label></div><br/><div class="children"><div class="content">No one argues, that digital logic is indeed analoh, however you rarely see reliance on a passive element (in analog sense), to be &quot;active&quot; in a digital sense. DRAM is the only widely known example.</div><br/><div id="37719811" class="c"><input type="checkbox" id="c-37719811" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718673">parent</a><span>|</span><a href="#37718935">next</a><span>|</span><label class="collapse" for="c-37719811">[-]</label><label class="expand" for="c-37719811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you rarely see reliance on a passive element (in analog sense), to be &quot;active&quot; in a digital sense<p>This technique is referred to as &quot;dynamic logic&quot;. It was common in the early days of MOS ICs -- for instance, it was used extensively in the original 6502 -- and still finds some usage in high-performance ICs.</div><br/></div></div><div id="37718935" class="c"><input type="checkbox" id="c-37718935" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718673">parent</a><span>|</span><a href="#37719811">prev</a><span>|</span><a href="#37722034">next</a><span>|</span><label class="collapse" for="c-37718935">[-]</label><label class="expand" for="c-37718935">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only because capacitors let you use fewer transistors. Any effort to shrink memory cells as much as possible inevitably leads to a capacitor-transistor hybrid solution.<p>In logic circuits class they don&#x27;t talk about areal constraints, but IC designers have to think about such things.</div><br/></div></div><div id="37722034" class="c"><input type="checkbox" id="c-37722034" checked=""/><div class="controls bullet"><span class="by">hasmanean</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37718673">parent</a><span>|</span><a href="#37718935">prev</a><span>|</span><a href="#37719845">next</a><span>|</span><label class="collapse" for="c-37722034">[-]</label><label class="expand" for="c-37722034">[1 more]</label></div><br/><div class="children"><div class="content">Well using analog effects in digital logic has its risks…at relativistic speeds the capacitor dimensions will change, altering capacitance. Depending on the direction of travel, it could go up or down. ;)</div><br/></div></div></div></div></div></div><div id="37719845" class="c"><input type="checkbox" id="c-37719845" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#37717840">parent</a><span>|</span><a href="#37718314">prev</a><span>|</span><a href="#37719161">next</a><span>|</span><label class="collapse" for="c-37719845">[-]</label><label class="expand" for="c-37719845">[2 more]</label></div><br/><div class="children"><div class="content">Nobody designs async things anymore, because they are much harder to validate, partly because there is no async equivalent of all the tooling used to validate synchronous logic. The final product might be better, but if it takes 3 years longer to ship because validation is harder, there is no room for it in the market. (Because the synchronous competitor has already shipped their next version on a better process node by the time you get yours out.)</div><br/><div id="37720888" class="c"><input type="checkbox" id="c-37720888" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37717840">root</a><span>|</span><a href="#37719845">parent</a><span>|</span><a href="#37719161">next</a><span>|</span><label class="collapse" for="c-37720888">[-]</label><label class="expand" for="c-37720888">[1 more]</label></div><br/><div class="children"><div class="content">Maybe that was a valid rule of thumb for decades that everyone internalised as a hard rule… but recent process changes haven’t delivered anywhere near the giant leaps that they used to.<p>Maybe now it would be worth revisiting, especially since we can throw so much computer power at validation!</div><br/></div></div></div></div><div id="37719161" class="c"><input type="checkbox" id="c-37719161" checked=""/><div class="controls bullet"><span class="by">elromulous</span><span>|</span><a href="#37717840">parent</a><span>|</span><a href="#37719845">prev</a><span>|</span><label class="collapse" for="c-37719161">[-]</label><label class="expand" for="c-37719161">[1 more]</label></div><br/><div class="children"><div class="content">In VLSI you pay a lot of attention to those capacitances. I&#x27;ve even designed some VLSI circuits that make intentional use of those capacitances.</div><br/></div></div></div></div></div></div></div></div></div></body></html>