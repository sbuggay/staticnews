<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686992467816" as="style"/><link rel="stylesheet" href="styles.css?v=1686992467816"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jetpack.io/blog/why-did-nix-adopt-flakes/">Why did Nix adopt Flakes?</a> <span class="domain">(<a href="https://www.jetpack.io">www.jetpack.io</a>)</span></div><div class="subtext"><span>pushtheenvelope</span> | <span>63 comments</span></div><br/><div><div id="36362576" class="c"><input type="checkbox" id="c-36362576" checked=""/><div class="controls bullet"><span class="by">lima</span><span>|</span><a href="#36362516">next</a><span>|</span><label class="collapse" for="c-36362576">[-]</label><label class="expand" for="c-36362576">[13 more]</label></div><br/><div class="children"><div class="content">My biggest issue with Nix flakes right now is the way it integrates with Git.<p>It insists on copying the <i>entire</i> repository into the Nix store (which makes all of its content world-readable!). Even if your flake.nix is in a subdirectory of a monorepo, the entire monorepo will be copied into the store every time!</div><br/><div id="36362928" class="c"><input type="checkbox" id="c-36362928" checked=""/><div class="controls bullet"><span class="by">rnhmjoj</span><span>|</span><a href="#36362576">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36362928">[-]</label><label class="expand" for="c-36362928">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a known issue but fortunately is being worked on: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;pull&#x2F;6530">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;pull&#x2F;6530</a></div><br/><div id="36363196" class="c"><input type="checkbox" id="c-36363196" checked=""/><div class="controls bullet"><span class="by">tangjurine</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36362928">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36363196">[-]</label><label class="expand" for="c-36363196">[5 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t this still copy the repo, but just doesn&#x27;t unzip it?</div><br/><div id="36364338" class="c"><input type="checkbox" id="c-36364338" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36363196">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36364338">[-]</label><label class="expand" for="c-36364338">[4 more]</label></div><br/><div class="children"><div class="content">I think it only lazily copies files that are referenced by your nix expression.<p>I tested this branch, and a flake-based shell launched in 3 seconds inside a large monorepo (vs 30 seconds before). I don&#x27;t think it is possible to copy this repo in 3 seconds.</div><br/><div id="36364376" class="c"><input type="checkbox" id="c-36364376" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36364338">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36364376">[-]</label><label class="expand" for="c-36364376">[3 more]</label></div><br/><div class="children"><div class="content">I hope that helps with nixpkgs repo as this takes a lot of time whenever it is updated.</div><br/><div id="36366473" class="c"><input type="checkbox" id="c-36366473" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36364376">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36366473">[-]</label><label class="expand" for="c-36366473">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it will. There isn&#x27;t any good way to incrementally fetch remote nix files, so to use nixpkgs it all has to be downloaded and unpacked.</div><br/><div id="36367952" class="c"><input type="checkbox" id="c-36367952" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36366473">parent</a><span>|</span><a href="#36362753">next</a><span>|</span><label class="collapse" for="c-36367952">[-]</label><label class="expand" for="c-36367952">[1 more]</label></div><br/><div class="children"><div class="content">Unless you mean when developing on the nixpkgs repo, in which case it could help.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36362753" class="c"><input type="checkbox" id="c-36362753" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36362576">parent</a><span>|</span><a href="#36362928">prev</a><span>|</span><a href="#36364309">next</a><span>|</span><label class="collapse" for="c-36362753">[-]</label><label class="expand" for="c-36362753">[1 more]</label></div><br/><div class="children"><div class="content">ah, yeah, we have a cheeky workaround for this in Devbox ;-)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;devbox&#x2F;blob&#x2F;main&#x2F;internal&#x2F;impl&#x2F;generate.go#L167">https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;devbox&#x2F;blob&#x2F;main&#x2F;internal&#x2F;impl...</a></div><br/></div></div><div id="36364309" class="c"><input type="checkbox" id="c-36364309" checked=""/><div class="controls bullet"><span class="by">madjam002</span><span>|</span><a href="#36362576">parent</a><span>|</span><a href="#36362753">prev</a><span>|</span><a href="#36362674">next</a><span>|</span><label class="collapse" for="c-36364309">[-]</label><label class="expand" for="c-36364309">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is annoying purely from a disk space perspective too as I easily go through 200GB of disk space in a day if I&#x27;m actively working and iterating on some Nix code</div><br/></div></div><div id="36362674" class="c"><input type="checkbox" id="c-36362674" checked=""/><div class="controls bullet"><span class="by">t0astbread</span><span>|</span><a href="#36362576">parent</a><span>|</span><a href="#36364309">prev</a><span>|</span><a href="#36363328">next</a><span>|</span><label class="collapse" for="c-36362674">[-]</label><label class="expand" for="c-36362674">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it the same with channels though? On my system `&#x2F;nix&#x2F;var&#x2F;nix&#x2F;profiles&#x2F;per-user&#x2F;root&#x2F;channels&#x2F;nixos` is a symlink to `&#x2F;nix&#x2F;store&#x2F;[...]-nixos-23.05&#x2F;nixos`.</div><br/><div id="36365876" class="c"><input type="checkbox" id="c-36365876" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36362674">parent</a><span>|</span><a href="#36363328">next</a><span>|</span><label class="collapse" for="c-36365876">[-]</label><label class="expand" for="c-36365876">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but channels are updated less often and it&#x27;s very unusual to put an application git repository into one.<p>You might have two dozen flakes in your system. You&#x27;ll typically only have a single channel, if you use them.</div><br/></div></div></div></div><div id="36363328" class="c"><input type="checkbox" id="c-36363328" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#36362576">parent</a><span>|</span><a href="#36362674">prev</a><span>|</span><a href="#36362516">next</a><span>|</span><label class="collapse" for="c-36363328">[-]</label><label class="expand" for="c-36363328">[2 more]</label></div><br/><div class="children"><div class="content">Is this still an issue when using gitignoreSrc?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hercules-ci&#x2F;gitignore.nix">https:&#x2F;&#x2F;github.com&#x2F;hercules-ci&#x2F;gitignore.nix</a></div><br/><div id="36364362" class="c"><input type="checkbox" id="c-36364362" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#36362576">root</a><span>|</span><a href="#36363328">parent</a><span>|</span><a href="#36362516">next</a><span>|</span><label class="collapse" for="c-36364362">[-]</label><label class="expand" for="c-36364362">[1 more]</label></div><br/><div class="children"><div class="content">For me, yes. Even with a completely clean checkout, the repo is a few hundred megs.</div><br/></div></div></div></div></div></div><div id="36362516" class="c"><input type="checkbox" id="c-36362516" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#36362576">prev</a><span>|</span><a href="#36363193">next</a><span>|</span><label class="collapse" for="c-36362516">[-]</label><label class="expand" for="c-36362516">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a casual nixpkgs contributor. Flakes are like the embassies Nix sends out into the OSS world. Discussion about building the application are kept with the application, nuances and patches can be discussed with the actual authors.<p>Remember the debian SSH packaging snafu? The application authors weren&#x27;t involved. (edit: see below)<p>Nixpkgs is like the state department, a central unifying hub, great to bootstrap the package ecosystem (ten years old now), but it needs to spread its wings.</div><br/><div id="36362656" class="c"><input type="checkbox" id="c-36362656" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36362516">parent</a><span>|</span><a href="#36362818">next</a><span>|</span><label class="collapse" for="c-36362656">[-]</label><label class="expand" for="c-36362656">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Flakes are like the embassies Nix sends out into the OSS world.<p>It&#x27;s a package spec, just like debian&#x2F;* and rpm&#x2F;*.spec.<p>&gt;Discussion about building the application are kept with the application, nuances and patches can be discussed with the actual authors.<p>Every distro package ecosystem has the maintainers discuss patches with upstream.<p>&gt;Remember the debian SSH packaging snafu? The application authors weren&#x27;t involved.<p>Assuming you&#x27;re referring to the 2006-2008 OpenSSL vulnerability (which affected openssh and other things), yes the openssl devs were involved. The Debian maintainer who added the bad patch asked about it on the openssl mailing list, and only added it after he got ACKs from the devs.</div><br/><div id="36364303" class="c"><input type="checkbox" id="c-36364303" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36362516">root</a><span>|</span><a href="#36362656">parent</a><span>|</span><a href="#36362825">next</a><span>|</span><label class="collapse" for="c-36364303">[-]</label><label class="expand" for="c-36364303">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a package spec, just like debian&#x2F;* and rpm&#x2F;*.spec.<p>No. It&#x27;s not. The interface that Nixpkgs&#x27; callPackage expects to find in default.nix within the Nixpkgs source tree is (kinda) like an RPM spec or Debian control file and friends, but that&#x27;s not what flakes are.<p>Flakes is mostly about providing mechanisms for distributing and referring to code written in the Nix language, and in that way facilitates the maintenance of &#x27;out-of-tree&#x27; (read: not in Nixpkgs) Nix packages. But flakes can also be (and are) used to ship Nixlang <i>libraries</i>, end user configurations, IaC for clusters or fleets of servers, overlays of packages to be composed with an end user&#x27;s copy of Nixpkgs, etc.<p>A flake doesn&#x27;t have to contain any packages at all. And when it does contain a package, the package is always defined with reference to some other package collection that it pulls its dependencies from (almost always Nixpkgs), and the conventions for describing the build come from <i>there</i>. They&#x27;re not part of the flakes schema.<p>&gt; Every distro package ecosystem has the maintainers discuss patches with upstream.<p>Again, not what flakes are about. The situation the GP is describing is where a Nix package&#x27;s &#x27;recipe&#x27; <i>lives inside the upstream repository* and is maintained there directly by contributors to&#x2F;maintainers of the upstream project. This is more like a project including a Dockerfile for the convenience of new contributors, or application developers directly publishing their own Flatpak images.</i></div><br/><div id="36365486" class="c"><input type="checkbox" id="c-36365486" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36362516">root</a><span>|</span><a href="#36364303">parent</a><span>|</span><a href="#36362825">next</a><span>|</span><label class="collapse" for="c-36365486">[-]</label><label class="expand" for="c-36365486">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Flakes [...] facilitates the maintenance of &#x27;out-of-tree&#x27; (read: not in Nixpkgs) Nix packages.<p>Yes, aka a Nix package spec.<p>&gt;But flakes can also be (and are) used to ship Nixlang libraries, end user configurations, IaC for clusters or fleets of servers, overlays of packages to be composed with an end user&#x27;s copy of Nixpkgs, etc.<p>Yes, just like DEB &#x2F; RPM packages.<p>&gt;A flake doesn&#x27;t have to contain any packages at all. And when it does contain a package, the package is always defined with reference to some other package collection that it pulls its dependencies from (almost always Nixpkgs)<p>Yes, what DEB &#x2F; RPM call meta-packages.<p>&gt;The situation the GP is describing is where a Nix package&#x27;s &#x27;recipe&#x27; lives inside the upstream repository<p>Yeah, and just like you convinced upstream to hold your Nix package spec, many upstreams hold Debian &#x2F; RPM package specs too.</div><br/><div id="36365803" class="c"><input type="checkbox" id="c-36365803" checked=""/><div class="controls bullet"><span class="by">carlhjerpe</span><span>|</span><a href="#36362516">root</a><span>|</span><a href="#36365486">parent</a><span>|</span><a href="#36366583">next</a><span>|</span><label class="collapse" for="c-36365803">[-]</label><label class="expand" for="c-36365803">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a defined schema for exporting nix functions I&#x27;d say. I could share a flake with you to provision your disks like I do, a service like I do, your cloud infra or anything else nix can do now. It is way more than deb, but if you only compare packaging it&#x27;d be like automatically building every PPA and every locally compiled pkg against exactly your installed version of every pkg it uses.</div><br/></div></div><div id="36366583" class="c"><input type="checkbox" id="c-36366583" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36362516">root</a><span>|</span><a href="#36365486">parent</a><span>|</span><a href="#36365803">prev</a><span>|</span><a href="#36362825">next</a><span>|</span><label class="collapse" for="c-36366583">[-]</label><label class="expand" for="c-36366583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; Flakes [...] facilitates the maintenance of &#x27;out-of-tree&#x27; (read: not in Nixpkgs) Nix packages.<p>&gt; Yes, aka a Nix package spec.<p>Right... one of things that flakes can be used to distribute is roughly comparable to an RPM spec. That is not the same thing as <i>being</i> an RPM spec. A BitTorrent magnet link used to distribute an MP3 file is not itself an MP3 file, either.<p>&gt; &gt; But flakes can also be (and are) used to ship Nixlang libraries, end user configurations, IaC for clusters or fleets of servers, overlays of packages to be composed with an end user&#x27;s copy of Nixpkgs, etc.<p>&gt; Yes, just like DEB &#x2F; RPM packages.<p>There is a sense in which flakes and RPMs can (sort of) be used to achieve the same things here, but not remotely in a way &#x27;just like&#x27; each other. A flake.nix file is not an archive, and an RPM is not a configuration file format for something like Puppet. The latter point is so obvious that I have to assume you&#x27;re being deliberately obtuse here.<p>&gt; &gt; A flake doesn&#x27;t have to contain any packages at all. And when it does contain a package, the package is always defined with reference to some other package collection that it pulls its dependencies from (almost always Nixpkgs)<p>&gt; Yes, what DEB &#x2F; RPM call meta-packages.<p>No. RPM and DEB metapackages are &#x27;abuses&#x27; of an archive format for either (a) just distributing install-time hooks and activating triggers or (b) forcing the installation of actual packages through the normal mechanisms of declaring dependencies on them.<p>Nix has no equivalent to (a) because &#x27;installation&#x27; doesn&#x27;t mean the same thing with Nix and hooks and triggers are owned by Nix profile managers rather than packages.<p>If Nix has anything equivalent to (b) in the RPM and DEB worlds, it&#x27;s this¹ which has nothing to do with flakes and is certainly not equivalent to a flake with no packages declared. In fact, any flake used to distribute such a buildEnv-based metapackage would have to declare it as a package.<p>A flake without any packages declared is not an archive of a Nix package whose data is empty but whose metadata is present.<p>Idk what to tell you. Clearly you are trying to somehow &#x27;demystify&#x27; Nix terms by equating their referents to things that are familiar to you and others, but your desire for succinctness here pushes you to elide basic differences— not just with respect to Nix but with respect to source-based package management in general. Just like with two natural languages, it&#x27;s simply not the case that every term here has a 1:1 translation.<p>--<p>1: <a href="https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;FAQ#How_can_I_manage_software_with_nix-env_like_with_configuration.nix.3F" rel="nofollow noreferrer">https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;FAQ#How_can_I_manage_software_with_n...</a></div><br/></div></div></div></div></div></div><div id="36362825" class="c"><input type="checkbox" id="c-36362825" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#36362516">root</a><span>|</span><a href="#36362656">parent</a><span>|</span><a href="#36364303">prev</a><span>|</span><a href="#36362818">next</a><span>|</span><label class="collapse" for="c-36362825">[-]</label><label class="expand" for="c-36362825">[1 more]</label></div><br/><div class="children"><div class="content">Yes the OpenSSL one<p><a href="https:&#x2F;&#x2F;lists.debian.org&#x2F;debian-security-announce&#x2F;2008&#x2F;msg00152.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lists.debian.org&#x2F;debian-security-announce&#x2F;2008&#x2F;msg00...</a><p>&gt; he got ACKs from the devs<p>You&#x27;re totally right: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6343782">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6343782</a><p>&gt; Every distro package ecosystem has the maintainers discuss patches with upstream.<p>I don&#x27;t think that&#x27;s entirely fair to say, it&#x27;s certainly best practice.</div><br/></div></div></div></div><div id="36362818" class="c"><input type="checkbox" id="c-36362818" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36362516">parent</a><span>|</span><a href="#36362656">prev</a><span>|</span><a href="#36363193">next</a><span>|</span><label class="collapse" for="c-36362818">[-]</label><label class="expand" for="c-36362818">[1 more]</label></div><br/><div class="children"><div class="content">I love the analogy!<p>I think this is a great strength of flakes. Packaging an application can sometimes have nuances that external folks may not be fully aware of and so having the packaging instructions (i.e. flake.nix) defined in the core repository can narrow that knowledge gap.</div><br/></div></div></div></div><div id="36363193" class="c"><input type="checkbox" id="c-36363193" checked=""/><div class="controls bullet"><span class="by">Reventlov</span><span>|</span><a href="#36362516">prev</a><span>|</span><a href="#36366990">next</a><span>|</span><label class="collapse" for="c-36363193">[-]</label><label class="expand" for="c-36363193">[7 more]</label></div><br/><div class="children"><div class="content">So, did Nix actually adopt flakes ? Because last time I checked, it was still an experimental feature that everyone insists on using, but… it&#x27;s still experimental, which means you have to make effort to use it.</div><br/><div id="36363219" class="c"><input type="checkbox" id="c-36363219" checked=""/><div class="controls bullet"><span class="by">civilitty</span><span>|</span><a href="#36363193">parent</a><span>|</span><a href="#36364542">next</a><span>|</span><label class="collapse" for="c-36363219">[-]</label><label class="expand" for="c-36363219">[2 more]</label></div><br/><div class="children"><div class="content">That’s my experience using Nix in a nutshell, every time I’ve tried to use it.<p>Flakes, home manager, half the packages I need, etc</div><br/><div id="36365841" class="c"><input type="checkbox" id="c-36365841" checked=""/><div class="controls bullet"><span class="by">carlhjerpe</span><span>|</span><a href="#36363193">root</a><span>|</span><a href="#36363219">parent</a><span>|</span><a href="#36364542">next</a><span>|</span><label class="collapse" for="c-36365841">[-]</label><label class="expand" for="c-36365841">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a political thing, flakes are not going away or changing radically. Though the CLI commands aren&#x27;t &quot;stable&quot; (guaranteed not to change wise). I read somewhere that someone of importance believes and thinks flakes will be enabled by default in 23.11 already.</div><br/></div></div></div></div><div id="36364542" class="c"><input type="checkbox" id="c-36364542" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36363193">parent</a><span>|</span><a href="#36363219">prev</a><span>|</span><a href="#36363469">next</a><span>|</span><label class="collapse" for="c-36364542">[-]</label><label class="expand" for="c-36364542">[1 more]</label></div><br/><div class="children"><div class="content">The thing with nix is that features are experimental for a very long time, even though they are quite solid. It seems like it is mostly used so they can still make changes, like the CLI options or the names of attributes in the flake.
The effort to use it is just adding extra line to the config.</div><br/></div></div><div id="36363469" class="c"><input type="checkbox" id="c-36363469" checked=""/><div class="controls bullet"><span class="by">lucilleh</span><span>|</span><a href="#36363193">parent</a><span>|</span><a href="#36364542">prev</a><span>|</span><a href="#36364868">next</a><span>|</span><label class="collapse" for="c-36363469">[-]</label><label class="expand" for="c-36363469">[2 more]</label></div><br/><div class="children"><div class="content">So...devbox adopted flakes before Nix did? lol.</div><br/><div id="36365919" class="c"><input type="checkbox" id="c-36365919" checked=""/><div class="controls bullet"><span class="by">carlhjerpe</span><span>|</span><a href="#36363193">root</a><span>|</span><a href="#36363469">parent</a><span>|</span><a href="#36364868">next</a><span>|</span><label class="collapse" for="c-36365919">[-]</label><label class="expand" for="c-36365919">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone already rely on LLMs way too much? Yes, but nix is a lot more predictable than LLMs are.<p>It&#x27;s not for everyone, but when you work with infrastructure and can guarantee that the software the developers build is the exact same version you&#x27;re running for them it feels good to have that conversation out of the way already.</div><br/></div></div></div></div><div id="36364868" class="c"><input type="checkbox" id="c-36364868" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#36363193">parent</a><span>|</span><a href="#36363469">prev</a><span>|</span><a href="#36366990">next</a><span>|</span><label class="collapse" for="c-36364868">[-]</label><label class="expand" for="c-36364868">[1 more]</label></div><br/><div class="children"><div class="content">Even after it passes the experimental stage, I doubt they&#x27;ll drop support for the default install&#x2F;config method using configuration.nix.  Flakes will just another option but not required.</div><br/></div></div></div></div><div id="36366990" class="c"><input type="checkbox" id="c-36366990" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36363193">prev</a><span>|</span><a href="#36363974">next</a><span>|</span><label class="collapse" for="c-36366990">[-]</label><label class="expand" for="c-36366990">[1 more]</label></div><br/><div class="children"><div class="content">I think the second point (nix flakes avoid &#x27;stateful&#x27; channels) is the more compelling one. I don&#x27;t recall an easy way for ensuring channels on different systems pointed to the same value; and flakes basically do what Niv did. And, it&#x27;s much nicer to just install a flake, rather than having to add channels.<p>I&#x27;m glad to see the first point (flake.nix provides a consistent interface) mentioned. The consistent interface allows for the cli to be much nicer; `nix flake show` can list the outputs.</div><br/></div></div><div id="36363974" class="c"><input type="checkbox" id="c-36363974" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#36366990">prev</a><span>|</span><a href="#36365980">next</a><span>|</span><label class="collapse" for="c-36363974">[-]</label><label class="expand" for="c-36363974">[6 more]</label></div><br/><div class="children"><div class="content">This probably goes against the flow, but I tried NixOS on a VPS and I found the tools to be inscrutable. Was so confused about Nix packaging and whether to use Flakes.</div><br/><div id="36364087" class="c"><input type="checkbox" id="c-36364087" checked=""/><div class="controls bullet"><span class="by">aliasxneo</span><span>|</span><a href="#36363974">parent</a><span>|</span><a href="#36364170">next</a><span>|</span><label class="collapse" for="c-36364087">[-]</label><label class="expand" for="c-36364087">[3 more]</label></div><br/><div class="children"><div class="content">Depends on the person. I work in a company that uses Nix for everything one could possibly imagine, and I&#x27;ve found there are a few types of people:<p>1. The purist: Is on an actual crusade to promote Nix and stomp out any competition, because, &quot;reproducible.&quot;<p>2. The enthusiast: Likes using Nix to speed up development but recognizes it has a ton of shortcomings, among others being not friendly to beginners, and tends to avoid using it in production critical stuff.<p>3. The ex-Nix: matches the enthusiasm of the purist in stomping out Nix wherever possible and actively promoting its demise.<p>I&#x27;m personally in the second category. I use Nixos for my main development machine and really like devshells. Beyond that, I try to avoid it as much as possible for production.</div><br/><div id="36364457" class="c"><input type="checkbox" id="c-36364457" checked=""/><div class="controls bullet"><span class="by">hellcow</span><span>|</span><a href="#36363974">root</a><span>|</span><a href="#36364087">parent</a><span>|</span><a href="#36364170">next</a><span>|</span><label class="collapse" for="c-36364457">[-]</label><label class="expand" for="c-36364457">[2 more]</label></div><br/><div class="children"><div class="content">We use it for devshells, and it’s awesome. New devs install nix and direnv and they instantly have all the right versions of all of our tooling. A first day setup process is now done in minutes instead of a day. Flakes made it possible for us to package up internal and external tools and ensure consistency across a team.<p>I have no experience running it in production, but I imagine if you don’t want to use containers it’d be a pretty good option.</div><br/><div id="36364885" class="c"><input type="checkbox" id="c-36364885" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36363974">root</a><span>|</span><a href="#36364457">parent</a><span>|</span><a href="#36364170">next</a><span>|</span><label class="collapse" for="c-36364885">[-]</label><label class="expand" for="c-36364885">[1 more]</label></div><br/><div class="children"><div class="content">for devshells use <a href="https:&#x2F;&#x2F;devenv.sh" rel="nofollow noreferrer">https:&#x2F;&#x2F;devenv.sh</a></div><br/></div></div></div></div></div></div><div id="36364170" class="c"><input type="checkbox" id="c-36364170" checked=""/><div class="controls bullet"><span class="by">xaduha</span><span>|</span><a href="#36363974">parent</a><span>|</span><a href="#36364087">prev</a><span>|</span><a href="#36364954">next</a><span>|</span><label class="collapse" for="c-36364170">[-]</label><label class="expand" for="c-36364170">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d start by using Home Manager which is a way to use nix packages in a sensible manner on any distro.<p><a href="https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;nix-community.github.io&#x2F;home-manager&#x2F;index.html</a></div><br/></div></div><div id="36364954" class="c"><input type="checkbox" id="c-36364954" checked=""/><div class="controls bullet"><span class="by">jljljl</span><span>|</span><a href="#36363974">parent</a><span>|</span><a href="#36364170">prev</a><span>|</span><a href="#36365980">next</a><span>|</span><label class="collapse" for="c-36364954">[-]</label><label class="expand" for="c-36364954">[1 more]</label></div><br/><div class="children"><div class="content">If you like the properties of Nix, but find it confusing, you should check out Devbox! It simplifies the process of creating Nix-powered dev environments:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;devbox">https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;devbox</a></div><br/></div></div></div></div><div id="36365980" class="c"><input type="checkbox" id="c-36365980" checked=""/><div class="controls bullet"><span class="by">predictabl3</span><span>|</span><a href="#36363974">prev</a><span>|</span><a href="#36364485">next</a><span>|</span><label class="collapse" for="c-36365980">[-]</label><label class="expand" for="c-36365980">[1 more]</label></div><br/><div class="children"><div class="content">Flakes rule, impure eval drools.<p>But also, my &quot;personal config&quot; has two dozen imports and overrides nixpkgs on most of those. I have a list of complaints regarding flakes that is only dwarfed by 6+ year old general nix issues, but I could never go back.</div><br/></div></div><div id="36364485" class="c"><input type="checkbox" id="c-36364485" checked=""/><div class="controls bullet"><span class="by">0x69420</span><span>|</span><a href="#36365980">prev</a><span>|</span><a href="#36365645">next</a><span>|</span><label class="collapse" for="c-36364485">[-]</label><label class="expand" for="c-36364485">[1 more]</label></div><br/><div class="children"><div class="content">the article does a good job of explaining why something like the flake system was necessary, but man oh man does the particular thing we wound up with have issues.<p>you can smell from a mile away that they were engineered to solve widely-experienced problems... as experienced by a single company, with an existing, idiosyncratic set of methodologies. and they just happened to get the blessing because eelco was at that company. unlike nix proper, however, where eelco had the entire internet for feedback, the core design of flakes ossified before the world at large had reason to care about them.<p>it doesn&#x27;t help that nix&#x27;s command-line ux is currently super splintered as a result, and while that will be ironed out in the long run, the thing in the name of which those tools got splintered is rather insulting.<p>i love nix but god damn this is the stage at which i&#x27;d take someone to couples counseling</div><br/></div></div><div id="36365645" class="c"><input type="checkbox" id="c-36365645" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#36364485">prev</a><span>|</span><a href="#36367601">next</a><span>|</span><label class="collapse" for="c-36365645">[-]</label><label class="expand" for="c-36365645">[4 more]</label></div><br/><div class="children"><div class="content">I’m surprised all of these systems combine build logic and dependency graphs in the same config. It seems like flake might be a step in understanding these things are only tangentially related.<p>I would like to see composability of graphs (and other set operations on binary package repos) integrated into more dependency management systems.<p>FreeBSD is my server of choice and I’d love to say: create a package repo with my config package and it’s dependencies and nothing more and deploy from that knowing a million other dependencies can’t be pulled in (e.g. give me a new jail that pulls from subset).<p>It’s probably something I should prototype one day.</div><br/><div id="36365807" class="c"><input type="checkbox" id="c-36365807" checked=""/><div class="controls bullet"><span class="by">georgyo</span><span>|</span><a href="#36365645">parent</a><span>|</span><a href="#36367601">next</a><span>|</span><label class="collapse" for="c-36365807">[-]</label><label class="expand" for="c-36365807">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t fully understand what you are saying, and I don&#x27;t know what systems you&#x27;re including in &quot;all&quot;.<p>The system you describe building is exactly what nix does, as well as debian, El, and Arch. Their spec files describe both build and runtime dependices, and installing the package does not install things like Make.<p>Nix goes a little bit further by only including runtime dependices that it can find it the build output. It does this by scanning the output files.<p>But I don&#x27;t understand how you could separate build graph and runtime graph. If I declare something needs foo and bar, that is useless unless I can get built foo and bar. _Something_ has to know how to build the things this hypothetical system is installing.</div><br/><div id="36366947" class="c"><input type="checkbox" id="c-36366947" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#36365645">root</a><span>|</span><a href="#36365807">parent</a><span>|</span><a href="#36367601">next</a><span>|</span><label class="collapse" for="c-36366947">[-]</label><label class="expand" for="c-36366947">[2 more]</label></div><br/><div class="children"><div class="content">RPM rspecs, port Makefiles, Maven, etc. do not just define package dependencies (build, runtime, etc.) and artifacts, they also have to intimately understand how to patch, build, and package the artifacts. Making the build and package system separate from the dependency management separates concerns and allows the ability for a completely declarative “dumb” dependency graph that can be reasoned about without dealing with build logic that must be executed.<p>This also allows build processes to evolve without affecting the public dependency graph. This makes it easier to show dependencies are modeled and exposed correctly and makes build logic private to consumers.</div><br/><div id="36367276" class="c"><input type="checkbox" id="c-36367276" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36365645">root</a><span>|</span><a href="#36366947">parent</a><span>|</span><a href="#36367601">next</a><span>|</span><label class="collapse" for="c-36367276">[-]</label><label class="expand" for="c-36367276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; allows the ability for a completely declarative “dumb” dependency graph that can be reasoned about without dealing with build logic that must be executed.<p>Nixer Domen Kozar called this property &#x27;static metadata&#x27; in one of his talks¹ on Python packaging from a Nix perspective years ago.<p>The thing he was interested in was the ability to evaluate the dependencies of an upstream software package without having to actually &#x27;install&#x27; it or evaluate bespoke upstream code to do so. The reason for interest in this within the Nix community is that by default Nix performs builds in a restricted sandbox, and one of its restrictions is that no network access is allowed.<p>To use upstream build tools (e.g., Maven or Cargo or NPM, etc.) inside the Nix sandbox, then, fetching dependencies and verifying their contents is deferred from the upstream build tool to Nix, which does so in a controlled, deterministic way that <i>just</i> fetches and doesn&#x27;t have hooks to let those deps run custom code.<p>In order to make that happen, Nix has to &#x27;know&#x27; ahead of time where to fetch those dependencies and what their contents will be, and what you describe wishing for here— a &#x27;dumb dependency graph&#x27;— is more or less exactly what Nix wants to consume (although sometimes just a list of pairs of URIs and content hashes will do). For well-behaved upstream package managers, i.e., those which can emit comprehensive static metadata, that&#x27;s exactly what Nix does: it just translates a Cargo or NPM lock file into its usual conventions for describing source archives, and then that can be used to download those dependencies in the usual safe&#x2F;restricted way.<p>For package managers that don&#x27;t emit adequate &#x27;dumb&#x27; package metadata, Nix has to proceed by either emulating and replacing those upstream dependency resolvers (very error-prone) or by a hack implemented as a Maven plugin or similar that inspects dependencies as Maven resolves them and gets the metadata Nix needs.<p>As for flakes, flake inputs are certainly a kind of dependency that&#x27;s distinct from package dependencies in the Nix world, and also &#x27;dumber&#x27; in the sense that flakes don&#x27;t have to be &#x27;built&#x27; like packages to be consumed by other flakes. And yeah, in the case of flakes that provide packages, you can definitely swap one flake for another and allow that new flake to provide customized build instructions if those are needed for that version of the package it provides. But there are complexities and entanglements that flakes don&#x27;t&#x2F;can&#x27;t eliminate, since downstream dependencies can still have implicit expectations of build <i>outputs</i>, and you can&#x27;t really know in advance if the package in the new flake will meet all of those. You kinda still have to be able to peek into those and examine them and fix them up in a pinch. Plus you <i>can</i> write a flake in a way that depends on the build process of a package in a flake it consumes, e.g. by using package overrides on something provided in the upstream flake.<p>--<p>1: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;ADSM4vR2EQ0" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;ADSM4vR2EQ0</a></div><br/></div></div></div></div></div></div></div></div><div id="36367601" class="c"><input type="checkbox" id="c-36367601" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#36365645">prev</a><span>|</span><a href="#36362384">next</a><span>|</span><label class="collapse" for="c-36367601">[-]</label><label class="expand" for="c-36367601">[1 more]</label></div><br/><div class="children"><div class="content">I prefer Flakes non-Flakes, but it’s disappointing that you can’t specify mirrors unlike the fetch* commands. Things go down on the internet &amp; mirrors are a way to cover that sitution. There’s nothing like a failing CI because the one of the origin’s servers are down.</div><br/></div></div><div id="36362384" class="c"><input type="checkbox" id="c-36362384" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#36367601">prev</a><span>|</span><a href="#36364550">next</a><span>|</span><label class="collapse" for="c-36362384">[-]</label><label class="expand" for="c-36362384">[8 more]</label></div><br/><div class="children"><div class="content">This is a bit of a unnecessarily provocative title, since the question of whether or not to promote the &#x27;experimental&#x27; flakes system and replace the channels mechanism is still an active and controversial one in the Nix community. There hasn&#x27;t been any significant news on this front recently; this article simply explains why flakes were introduced as an experimental feature.</div><br/><div id="36362513" class="c"><input type="checkbox" id="c-36362513" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36362384">parent</a><span>|</span><a href="#36362539">next</a><span>|</span><label class="collapse" for="c-36362513">[-]</label><label class="expand" for="c-36362513">[5 more]</label></div><br/><div class="children"><div class="content">Oh, it isn&#x27;t intended to be provocative.<p>The title is simply literally the question that I was thinking about a few months ago when working on Devbox, and wrote a version of this post internally to answer the question for myself!</div><br/><div id="36362579" class="c"><input type="checkbox" id="c-36362579" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#36362384">root</a><span>|</span><a href="#36362513">parent</a><span>|</span><a href="#36362539">next</a><span>|</span><label class="collapse" for="c-36362579">[-]</label><label class="expand" for="c-36362579">[4 more]</label></div><br/><div class="children"><div class="content">Ah, that&#x27;s good to know :)  It is just that I was expecting to read about some breaking news; that I missed that Nix deprecated channels or something!  It is indeed a nice article explaining Flakes in general. Maybe &quot;Why did Nix introduce Flakes?&quot; might be a slightly better title for people coming with prior expectations like I did?</div><br/><div id="36362662" class="c"><input type="checkbox" id="c-36362662" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36362384">root</a><span>|</span><a href="#36362579">parent</a><span>|</span><a href="#36362539">next</a><span>|</span><label class="collapse" for="c-36362662">[-]</label><label class="expand" for="c-36362662">[3 more]</label></div><br/><div class="children"><div class="content">s&#x2F;adopt&#x2F;introduce<p>done :)</div><br/><div id="36362822" class="c"><input type="checkbox" id="c-36362822" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#36362384">root</a><span>|</span><a href="#36362662">parent</a><span>|</span><a href="#36362539">next</a><span>|</span><label class="collapse" for="c-36362822">[-]</label><label class="expand" for="c-36362822">[2 more]</label></div><br/><div class="children"><div class="content">Thank you; that was quick! :)  I apologise if my original comment came across as rather harsh!</div><br/><div id="36363850" class="c"><input type="checkbox" id="c-36363850" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36362384">root</a><span>|</span><a href="#36362822">parent</a><span>|</span><a href="#36362539">next</a><span>|</span><label class="collapse" for="c-36363850">[-]</label><label class="expand" for="c-36363850">[1 more]</label></div><br/><div class="children"><div class="content">idk, someone (moderator?) changed it back ...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36362539" class="c"><input type="checkbox" id="c-36362539" checked=""/><div class="controls bullet"><span class="by">toolz</span><span>|</span><a href="#36362384">parent</a><span>|</span><a href="#36362513">prev</a><span>|</span><a href="#36364550">next</a><span>|</span><label class="collapse" for="c-36362539">[-]</label><label class="expand" for="c-36362539">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what you would change the title to so that you perceive it to be less provocative? In my (disclosure: not engaged in the community much at all) opinion the provocation here is simply because the topic touches on a controversial issue.</div><br/><div id="36366890" class="c"><input type="checkbox" id="c-36366890" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36362384">root</a><span>|</span><a href="#36362539">parent</a><span>|</span><a href="#36364550">next</a><span>|</span><label class="collapse" for="c-36366890">[-]</label><label class="expand" for="c-36366890">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the &quot;Why did ...?&quot; can come across as confrontational. -- If something&#x27;s good, you&#x27;re less likely to ask &quot;why do that?&quot;.<p>&quot;What Nix Flakes Solve&quot; or &quot;Benefits of Nix Flakes&quot; would avoid that.<p>But, I didn&#x27;t read the title as provocative.</div><br/></div></div></div></div></div></div><div id="36364550" class="c"><input type="checkbox" id="c-36364550" checked=""/><div class="controls bullet"><span class="by">heleninboodler</span><span>|</span><a href="#36362384">prev</a><span>|</span><a href="#36363810">next</a><span>|</span><label class="collapse" for="c-36364550">[-]</label><label class="expand" for="c-36364550">[8 more]</label></div><br/><div class="children"><div class="content">Am I the only one completely confused by the examples that appear to put command line arguments after shell end-of-line comments?  Is that not a typical shell?<p>example:<p><pre><code>  nix run .#cowsay -- flakes are neat
</code></pre>
Some explanation of what the heck this means would be really useful.</div><br/><div id="36364807" class="c"><input type="checkbox" id="c-36364807" checked=""/><div class="controls bullet"><span class="by">pushtheenvelope</span><span>|</span><a href="#36364550">parent</a><span>|</span><a href="#36364695">next</a><span>|</span><label class="collapse" for="c-36364807">[-]</label><label class="expand" for="c-36364807">[1 more]</label></div><br/><div class="children"><div class="content">yikes! thanks for pointing that out. The blog&#x27;s renderer is confused too  and renders the `#cowsay -- flakes are neat` as a comment.<p>To explain what&#x27;s happening:<p>- The example above is running `nix run &lt;flake output attribute&gt; -- &lt;arguments to pass to the flake output&#x27;s binary&gt;`.<p>- The `&lt;flake output attribute&gt;` here is `.#cowsay`, which is to be read as: `&lt;flake reference&gt;#&lt;attribute path&gt;`. The # is a separator here.<p>- The `&lt;flake reference&gt;` being `.` implies its a local flake at the current directory.
The `&lt;attribute path&gt;` in this case is the output from the flake i.e. the `cowsay` program.<p>further fun to be found at: <a href="https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nix&#x2F;stable&#x2F;command-ref&#x2F;new-cli&#x2F;nix.html#flake-output-attribute" rel="nofollow noreferrer">https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nix&#x2F;stable&#x2F;command-ref&#x2F;new-cli&#x2F;nix....</a><p>As a meta-comment, yeah, this is kinda non-trivial for most of us. This is why we build devbox which provides a more familiar UX like `devbox add cowsay &amp;&amp; devbox run -- cowsay &quot;flakes are neat&quot;`</div><br/></div></div><div id="36364695" class="c"><input type="checkbox" id="c-36364695" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#36364550">parent</a><span>|</span><a href="#36364807">prev</a><span>|</span><a href="#36367290">next</a><span>|</span><label class="collapse" for="c-36364695">[-]</label><label class="expand" for="c-36364695">[3 more]</label></div><br/><div class="children"><div class="content">&quot;--&quot; isn&#x27;t anything special in a typical shell. It&#x27;s just another argument, one that customarily means &quot;pass the rest of arguments on to a subprocess&quot;. Or are you confused about the &quot;#&quot;? It doesn&#x27;t start a comment in the middle of a token.</div><br/><div id="36366463" class="c"><input type="checkbox" id="c-36366463" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36364550">root</a><span>|</span><a href="#36364695">parent</a><span>|</span><a href="#36365026">next</a><span>|</span><label class="collapse" for="c-36366463">[-]</label><label class="expand" for="c-36366463">[1 more]</label></div><br/><div class="children"><div class="content">&gt; one that customarily means &quot;pass the rest of arguments on to a subprocess&quot;.<p>It&#x27;s convenient for passing options and args to a subprocess, but it customarily means &quot;don&#x27;t interpret anything following this as a short or long option, just as a positional argument&quot;.  For example:<p><pre><code>  touch -f     # error
  touch -- -f  # creates a file named &quot;-f&quot;
  rm *         # oh crap we just passed &quot;rm -f&quot; a bunch of files
  rm -- *      # don&#x27;t treat that &quot;-f&quot; as an option, just delete the file named &quot;-f&quot;</code></pre></div><br/></div></div><div id="36365026" class="c"><input type="checkbox" id="c-36365026" checked=""/><div class="controls bullet"><span class="by">heleninboodler</span><span>|</span><a href="#36364550">root</a><span>|</span><a href="#36364695">parent</a><span>|</span><a href="#36366463">prev</a><span>|</span><a href="#36367290">next</a><span>|</span><label class="collapse" for="c-36365026">[-]</label><label class="expand" for="c-36365026">[1 more]</label></div><br/><div class="children"><div class="content">It was the &quot;#&quot;.  I didn&#x27;t realize that about the behavior in the middle of a token, and apparently the syntax colorizer doesn&#x27;t either.</div><br/></div></div></div></div><div id="36367290" class="c"><input type="checkbox" id="c-36367290" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36364550">parent</a><span>|</span><a href="#36364695">prev</a><span>|</span><a href="#36367014">next</a><span>|</span><label class="collapse" for="c-36367290">[-]</label><label class="expand" for="c-36367290">[1 more]</label></div><br/><div class="children"><div class="content">The comment syntax for most (virtually all?) shells actually doesn&#x27;t start with a pound sign but with the word boundary or whitespace preceding the pound sign. You can have unescaped pound signs within tokens in shell languages, and thus they are used (perhaps unfortunately) as delimiters in the current flake URI schema.</div><br/></div></div><div id="36367014" class="c"><input type="checkbox" id="c-36367014" checked=""/><div class="controls bullet"><span class="by">tripdout</span><span>|</span><a href="#36364550">parent</a><span>|</span><a href="#36367290">prev</a><span>|</span><a href="#36364730">next</a><span>|</span><label class="collapse" for="c-36367014">[-]</label><label class="expand" for="c-36367014">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nix run, the dot means current directory, # means flake, cowsay is the attribute, and then anything after -- is passed to what&#x27;s run by that command, which is typical of many Unix programs.<p>So it&#x27;s run the cowsay attribute from the flake in the current directory, passing flakes are neat as input to cowsay.</div><br/></div></div><div id="36364730" class="c"><input type="checkbox" id="c-36364730" checked=""/><div class="controls bullet"><span class="by">femiagbabiaka</span><span>|</span><a href="#36364550">parent</a><span>|</span><a href="#36367014">prev</a><span>|</span><a href="#36363810">next</a><span>|</span><label class="collapse" for="c-36364730">[-]</label><label class="expand" for="c-36364730">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1_chap12.html#tag_12_02" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1...</a><p>The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options. Any following arguments should be treated as operands, even if they begin with the &#x27;-&#x27; character.</div><br/></div></div></div></div><div id="36363810" class="c"><input type="checkbox" id="c-36363810" checked=""/><div class="controls bullet"><span class="by">soupbowl</span><span>|</span><a href="#36364550">prev</a><span>|</span><label class="collapse" for="c-36363810">[-]</label><label class="expand" for="c-36363810">[4 more]</label></div><br/><div class="children"><div class="content">I find the default way to work with nixos to be a lot easier to use compared to flakes. I am sure flakes are great and all but as with everything nix you can&#x27;t just integrate it into your normal flow, you have to jump all in with it. I don&#x27;t think that is a positive.</div><br/><div id="36363985" class="c"><input type="checkbox" id="c-36363985" checked=""/><div class="controls bullet"><span class="by">VTimofeenko</span><span>|</span><a href="#36363810">parent</a><span>|</span><a href="#36366843">next</a><span>|</span><label class="collapse" for="c-36363985">[-]</label><label class="expand" for="c-36363985">[1 more]</label></div><br/><div class="children"><div class="content">It is possible to use flakes on systems otherwise managed with channels. Just enable the 
 &quot;nix-command flakes&quot; experimental features[1] and stuff like &quot;nix run&quot; will work.<p>[1]: <a href="https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Flakes" rel="nofollow noreferrer">https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Flakes</a> section &quot;Enable Flakes&quot;.</div><br/></div></div><div id="36366843" class="c"><input type="checkbox" id="c-36366843" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36363810">parent</a><span>|</span><a href="#36363985">prev</a><span>|</span><a href="#36367453">next</a><span>|</span><label class="collapse" for="c-36366843">[-]</label><label class="expand" for="c-36366843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am sure flakes are great and all but as with everything nix you can&#x27;t just integrate it into your normal flow, you have to jump all in with it.<p>AFAIR, the only irreversible impact is switching from `nix-env --install` to `nix profile install`.<p>With repositories, you can add a flake.nix, and still use nix-build or nix-shell however you did before. e.g. You can have the flake.nix import the default.nix or shell.nix code.</div><br/></div></div><div id="36367453" class="c"><input type="checkbox" id="c-36367453" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#36363810">parent</a><span>|</span><a href="#36366843">prev</a><span>|</span><label class="collapse" for="c-36367453">[-]</label><label class="expand" for="c-36367453">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much, still not sold on flakes. My nixpkgs is also git repo not channel</div><br/></div></div></div></div></div></div></div></div></div></body></html>