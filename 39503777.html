<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708938059326" as="style"/><link rel="stylesheet" href="styles.css?v=1708938059326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matthewrocklin.com/write-dumb-code.html">Write Dumb Code (2018)</a> <span class="domain">(<a href="https://matthewrocklin.com">matthewrocklin.com</a>)</span></div><div class="subtext"><span>dvcoolarun</span> | <span>55 comments</span></div><br/><div><div id="39504513" class="c"><input type="checkbox" id="c-39504513" checked=""/><div class="controls bullet"><span class="by">GMoromisato</span><span>|</span><a href="#39508752">next</a><span>|</span><label class="collapse" for="c-39504513">[-]</label><label class="expand" for="c-39504513">[32 more]</label></div><br/><div class="children"><div class="content">This advice boils down to &quot;write good code.&quot; Unfortunately, practical advice that goes beyond that is really hard.<p>Software engineering is hard because everything is a trade off! Should I add another layer of abstraction or just add another optional parameter? Should I add flexibility for future requirements or simplify the code so it&#x27;s obvious to a junior programmer?<p>The answer to almost every question is, &quot;It depends!&quot;<p>What are the skills of the dev team? How much time do you have? Do you already have a lot of tech debt? Are you building a prototype or a safety-critical system?<p>Worse, many answers depend on unknowable facts: How will requirements change in the future? Will we ever need this functionality? Did we bet on the right ecosystem?<p>The best software engineers can balance all these questions, even the ones they don&#x27;t have answers to, and come up with a design that works. The fact that we, as an industry, can build multi-million-line programs is a minor miracle. The wonder isn&#x27;t that so many projects fail but that any succeed.<p>If anyone were to ask me for advice--which I notice they&#x27;re not--I would just say two things:<p>1. Write lots of programs.<p>2. Work with good software engineers.</div><br/><div id="39505525" class="c"><input type="checkbox" id="c-39505525" checked=""/><div class="controls bullet"><span class="by">overgard</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39505417">next</a><span>|</span><label class="collapse" for="c-39505525">[-]</label><label class="expand" for="c-39505525">[13 more]</label></div><br/><div class="children"><div class="content">&gt; This advice boils down to &quot;write good code.&quot; Unfortunately, practical advice that goes beyond that is really hard.<p>I don&#x27;t think that&#x27;s true. I think a better way to phrase it is &quot;avoid being clever if you don&#x27;t need to be.&quot; Sure, you <i>could</i> write that algorithm as three nested list comprehensions, but does that accomplish anything other than showing off? Do you really need that metaprogramming or would a simple function suffice? The worst code I&#x27;ve ever had to deal with was never written by juniors, it was written by guys that knew fancy template metaprogramming in C++ and would create a nightmare for everyone else to deal with because they wanted to show how smart they were.</div><br/><div id="39507218" class="c"><input type="checkbox" id="c-39507218" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505525">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39507218">[-]</label><label class="expand" for="c-39507218">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Sure, you could write that algorithm as three nested list comprehensions, but does that accomplish anything other than showing off?<p>Ask different programmers this and you&#x27;ll get different answers. One group will say that the list comprehensions reduces ceremony and makes the essential business logic clear, and writing out a loop longhand would serve no purpose other than showing off your knowledge of implementation trivia. Another group would say that writing the code without using list comprehensions makes it simpler, and the other group is just showing off their knowledge of language features.<p>&quot;Make it simpler&quot; advice is rarely actionable and usually just makes the debates more contentious. <a href="https:&#x2F;&#x2F;m50d.github.io&#x2F;2018&#x2F;12&#x2F;11&#x2F;people-who-disagree" rel="nofollow">https:&#x2F;&#x2F;m50d.github.io&#x2F;2018&#x2F;12&#x2F;11&#x2F;people-who-disagree</a></div><br/><div id="39507656" class="c"><input type="checkbox" id="c-39507656" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39507218">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39507656">[-]</label><label class="expand" for="c-39507656">[5 more]</label></div><br/><div class="children"><div class="content">One of the annoying things about &quot;code simplicity&quot; is that it is a subjective trait. Whether a piece of code is simple to understand depends very heavily on what the reader is used to, and that&#x27;s not something that the writer of the code has much control over.</div><br/><div id="39507797" class="c"><input type="checkbox" id="c-39507797" checked=""/><div class="controls bullet"><span class="by">zakirullin</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39507656">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39507797">[-]</label><label class="expand" for="c-39507797">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Code simplicity&quot; is indeed too abstract. &quot;Cognitive load&quot;, however, is more tangible thing to grasp.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;zakirullin&#x2F;cognitive-load">https:&#x2F;&#x2F;github.com&#x2F;zakirullin&#x2F;cognitive-load</a></div><br/><div id="39507816" class="c"><input type="checkbox" id="c-39507816" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39507797">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39507816">[-]</label><label class="expand" for="c-39507816">[3 more]</label></div><br/><div class="children"><div class="content">That has pretty much the same problem. Assembly programs have low &quot;cognitive load&quot; by that definition, but few would say that assembly programs are simpler.</div><br/><div id="39508713" class="c"><input type="checkbox" id="c-39508713" checked=""/><div class="controls bullet"><span class="by">zakirullin</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39507816">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39508713">[-]</label><label class="expand" for="c-39508713">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say so. When you&#x27;re on assembly programs, you hold things like &quot;register values&quot; in your head as well as other low-level things. It&#x27;s not only about abstractions and language features.</div><br/><div id="39508801" class="c"><input type="checkbox" id="c-39508801" checked=""/><div class="controls bullet"><span class="by">YetAnotherNick</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39508713">parent</a><span>|</span><a href="#39506296">next</a><span>|</span><label class="collapse" for="c-39508801">[-]</label><label class="expand" for="c-39508801">[1 more]</label></div><br/><div class="children"><div class="content">There are much lower number of register values compared to number of variables any half complicated code has.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39506296" class="c"><input type="checkbox" id="c-39506296" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505525">parent</a><span>|</span><a href="#39507218">prev</a><span>|</span><a href="#39505417">next</a><span>|</span><label class="collapse" for="c-39506296">[-]</label><label class="expand" for="c-39506296">[6 more]</label></div><br/><div class="children"><div class="content">My friends call this the complexity hump. Pretty much everyone goes through this phase. The faster you get out of it the better. Some stay there their whole career.</div><br/><div id="39506657" class="c"><input type="checkbox" id="c-39506657" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39506296">parent</a><span>|</span><a href="#39505417">next</a><span>|</span><label class="collapse" for="c-39506657">[-]</label><label class="expand" for="c-39506657">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Some stay there their whole career.<p>A massive cohort of programmers, some at very high positions that are highly analytically minded, do not understand this. It’s not for a lack of intelligence, but curiosity and empathy (as in the dictionary definition - the theory of mind stuff).<p>My current best way I try to explain this is: go ahead, assume you’re 10% or even 200% smarter than others - a true 10x engineer. It doesn’t matter, because complexity scales not linearly but exponentially. The difference between big brain and small brain is minuscule in face of the omnipresent beast of complexity. It’s like surviving a terminal desease - an athlete might live longer but you’re still gonna die. And complexity creeps in simply as a byproduct of doing anything, so ignoring it will result in more, just like more code leads to more bugs.<p><i>at least grug can see T-Rex</i></div><br/><div id="39507894" class="c"><input type="checkbox" id="c-39507894" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39506657">parent</a><span>|</span><a href="#39507265">next</a><span>|</span><label class="collapse" for="c-39507894">[-]</label><label class="expand" for="c-39507894">[1 more]</label></div><br/><div class="children"><div class="content">If you only have grugs, you will never solve the difficult problems, though. There&#x27;s no binary advice to be given around complexity - whether to avoid it or to embrace it, I think.</div><br/></div></div><div id="39507265" class="c"><input type="checkbox" id="c-39507265" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39506657">parent</a><span>|</span><a href="#39507894">prev</a><span>|</span><a href="#39507992">next</a><span>|</span><label class="collapse" for="c-39507265">[-]</label><label class="expand" for="c-39507265">[2 more]</label></div><br/><div class="children"><div class="content">I think a big part of the problem is the inherited collective ego of software being birthed by computer science. If you go look at early software, early Unix, whatever, there is such a tremendous volume of really clever things going on. Little DSLs, weird experiments that bled into POSIX. All the effort devoted to grammars and compilers and making Hard Problems look Easy.<p>I sometimes get frustrated that my colleagues don&#x27;t know how to read an awk script, or that they think it&#x27;s just a fact of life that they have to delete their git repository and perform a fresh clone because that&#x27;s just the way npm is sometimes. Am I asking for too much? But then I remember that we have built all of this on impossibly tall ivory towers of complexity. It&#x27;s almost unfathomable.<p>Almost every project is someone&#x27;s vice in this vein form of worship we call software development. We tell ourselves that we&#x27;ve moved past this phase, we&#x27;ve seen what complexity really is. But can we actually? Ever? Are we just fooling ourselves?<p>It always seemed to me that it&#x27;s ideal to use sophisticated tools to build mundane and interesting solutions. But every solution is just a tool for someone else. So much of what I love about what we do is hopelessly couples to that very complexity I despise. How can we reconcile this?<p>Out of sight, out of mind, I suppose.<p>I think the real problem is that we consider this all one big profession when in reality it&#x27;s as varied as the crafts: electricians, plumbers, metalworkers, laborers, carpenters, mechanics, engineers, architects, painters, roofers, landscapers...<p>We just do it all.</div><br/><div id="39507316" class="c"><input type="checkbox" id="c-39507316" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39507265">parent</a><span>|</span><a href="#39507992">next</a><span>|</span><label class="collapse" for="c-39507316">[-]</label><label class="expand" for="c-39507316">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But can we actually? Ever? Are we just fooling ourselves?<p>I don’t have any hopes of the deepest theoretical complexity problems will be solved. However, let’s not be too defeatist. Look back 10-20-30 years. The things that survive in the long run (longer than a ~5y hype-cycle) are almost always an improvement compared to the past. Some genies can’t be put back in the bottle - good ideas, models and abstractions fit that bill, in my view. I’m hopeful.<p>&gt; Out of sight, out of mind, I suppose.<p>Yes but this isn’t always bad. Things like schedulers, compilers, query planners <i>should</i> be out of mind. Or at least it’s the best way we can compartmentalize complexity today. It’s a last resort, so you shouldn’t pick immature <i>and</i> highly complex deps at the same time. Fortunately, we have mature tech that does a lot of heavy lifting, even if magical.</div><br/></div></div></div></div><div id="39507992" class="c"><input type="checkbox" id="c-39507992" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39506657">parent</a><span>|</span><a href="#39507265">prev</a><span>|</span><a href="#39505417">next</a><span>|</span><label class="collapse" for="c-39507992">[-]</label><label class="expand" for="c-39507992">[1 more]</label></div><br/><div class="children"><div class="content">Yup, moving from 40 hour weeks to 168 hour weeks (if the body supports) or a 4x hiring spree (if they integrate into the team) seems like nothing for some complicated crap I&#x27;ve seen.</div><br/></div></div></div></div></div></div></div></div><div id="39505417" class="c"><input type="checkbox" id="c-39505417" checked=""/><div class="controls bullet"><span class="by">okamiueru</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39505525">prev</a><span>|</span><a href="#39504713">next</a><span>|</span><label class="collapse" for="c-39505417">[-]</label><label class="expand" for="c-39505417">[1 more]</label></div><br/><div class="children"><div class="content">Then, there are a lot of programmers who are completely unaware of these tradeoffs, and simply follow some trend or methodology without any thought of their own. 20 lines of code split over 4 microservices? Sure, why not? &quot;It&#x27;s supposed to make development more flexible and improve the developer experience&quot;. Cherish coworkers who actually care about their craft, not all shops have them.</div><br/></div></div><div id="39504713" class="c"><input type="checkbox" id="c-39504713" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39505417">prev</a><span>|</span><a href="#39505141">next</a><span>|</span><label class="collapse" for="c-39504713">[-]</label><label class="expand" for="c-39504713">[5 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re saying about everything being a trade off really resonates with me.<p>I don&#x27;t think I really &quot;grasped&quot; software engineering until a more experienced friend told me, a couple decades ago, that every abstraction is also has trade offs and hidden costs.<p>To me it seemed ludicrous, since abstractions were &quot;obviously good&quot;, but ruminating on that and observing closely the code I was maintaining taught me that it was true. Everything is indeed a trade off...</div><br/><div id="39505616" class="c"><input type="checkbox" id="c-39505616" checked=""/><div class="controls bullet"><span class="by">geophph</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39504713">parent</a><span>|</span><a href="#39505141">next</a><span>|</span><label class="collapse" for="c-39505616">[-]</label><label class="expand" for="c-39505616">[4 more]</label></div><br/><div class="children"><div class="content">Reminds me of this quote attributable to Kent Beck<p>“first you learn the value of abstraction, then you learn the cost of abstraction, then you’re ready to engineer”</div><br/><div id="39505767" class="c"><input type="checkbox" id="c-39505767" checked=""/><div class="controls bullet"><span class="by">GMoromisato</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505616">parent</a><span>|</span><a href="#39505964">next</a><span>|</span><label class="collapse" for="c-39505767">[-]</label><label class="expand" for="c-39505767">[2 more]</label></div><br/><div class="children"><div class="content">Dr. Gregory House&#x27;s motto is &quot;Everybody lies.&quot;<p>My fantasy is to create a hit TV series about an engineering firm and the motto is &quot;Everything&#x27;s a trade-off.&quot;</div><br/><div id="39505967" class="c"><input type="checkbox" id="c-39505967" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505767">parent</a><span>|</span><a href="#39505964">next</a><span>|</span><label class="collapse" for="c-39505967">[-]</label><label class="expand" for="c-39505967">[1 more]</label></div><br/><div class="children"><div class="content">i thought that show&#x27;s key lesson was that &quot;everything is probably lupus&quot; but you may be right.</div><br/></div></div></div></div><div id="39505964" class="c"><input type="checkbox" id="c-39505964" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505616">parent</a><span>|</span><a href="#39505767">prev</a><span>|</span><a href="#39505141">next</a><span>|</span><label class="collapse" for="c-39505964">[-]</label><label class="expand" for="c-39505964">[1 more]</label></div><br/><div class="children"><div class="content">oh yeah i remember my first interface factory factory singletons with variable dependency injection aritys built with a flywheel pattern. pretty sure i got fired for that one.</div><br/></div></div></div></div></div></div><div id="39505141" class="c"><input type="checkbox" id="c-39505141" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39504713">prev</a><span>|</span><a href="#39508456">next</a><span>|</span><label class="collapse" for="c-39505141">[-]</label><label class="expand" for="c-39505141">[3 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t see how it&#x27;s just &quot;write good code.&quot; In fact the opening line is about removing code being better than writing more.<p>Maybe it boils down to KISS but IMO it goes deeper than that.  The lesson that code is a liability not an asset is not represented in either &quot;be good&quot; or &quot;be simple.&quot;</div><br/><div id="39505402" class="c"><input type="checkbox" id="c-39505402" checked=""/><div class="controls bullet"><span class="by">GMoromisato</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505141">parent</a><span>|</span><a href="#39506666">next</a><span>|</span><label class="collapse" for="c-39505402">[-]</label><label class="expand" for="c-39505402">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you&#x27;re right. Obviously, if this advice helps people, then I should just back off.<p>It&#x27;s true that removing code is better than adding it, and that code is a liability. And I admit that I needed to hear that early in my career.<p>But the article acknowledges that &quot;over-adherence to [that] dogma can be counter productive&quot;. Great--so how can I tell if I&#x27;ve gone too far? How do I know if I should write more code or less code? How do I know if my code is &quot;dumb&quot; enough? The article does not help with that.<p>Saying that &quot;code is a liability&quot; is not actionable advice.<p>Edit: In contrast, I found this article full of actionable advice: <a href="https:&#x2F;&#x2F;tidyfirst.substack.com&#x2F;p&#x2F;mastering-programming" rel="nofollow">https:&#x2F;&#x2F;tidyfirst.substack.com&#x2F;p&#x2F;mastering-programming</a></div><br/></div></div><div id="39506666" class="c"><input type="checkbox" id="c-39506666" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505141">parent</a><span>|</span><a href="#39505402">prev</a><span>|</span><a href="#39508456">next</a><span>|</span><label class="collapse" for="c-39506666">[-]</label><label class="expand" for="c-39506666">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The lesson that code is a liability not an asset is not represented in either &quot;be good&quot; or &quot;be simple.&quot;<p>I think it’s an extension of simplicity. 0 lines of code is simpler than 1 line, no?</div><br/></div></div></div></div><div id="39508456" class="c"><input type="checkbox" id="c-39508456" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39505141">prev</a><span>|</span><a href="#39504950">next</a><span>|</span><label class="collapse" for="c-39508456">[-]</label><label class="expand" for="c-39508456">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic comment. This is the best answer to &quot;What is good code?&quot; that I&#x27;ve ever seen. Nicely succinct too.</div><br/></div></div><div id="39504950" class="c"><input type="checkbox" id="c-39504950" checked=""/><div class="controls bullet"><span class="by">charlie0</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39508456">prev</a><span>|</span><a href="#39504736">next</a><span>|</span><label class="collapse" for="c-39504950">[-]</label><label class="expand" for="c-39504950">[1 more]</label></div><br/><div class="children"><div class="content">Being able to list different solutions and their tradeoffs is a true mark of seniority.</div><br/></div></div><div id="39504736" class="c"><input type="checkbox" id="c-39504736" checked=""/><div class="controls bullet"><span class="by">screenoridesagb</span><span>|</span><a href="#39504513">parent</a><span>|</span><a href="#39504950">prev</a><span>|</span><a href="#39508752">next</a><span>|</span><label class="collapse" for="c-39504736">[-]</label><label class="expand" for="c-39504736">[7 more]</label></div><br/><div class="children"><div class="content">And yet you see hundreds of people on this site seriously advocating stuff that has zero relevance or utility. Haskell, Perl these are languages that WILL make so the vast majority of developers will never touch it and yet here we are writing “I’m so smart I knew to use Haskell” code just so intern 8 months later will steamroll with ChatGPT generated Python that people will actually read.</div><br/><div id="39506924" class="c"><input type="checkbox" id="c-39506924" checked=""/><div class="controls bullet"><span class="by">ckw</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39504736">parent</a><span>|</span><a href="#39504903">next</a><span>|</span><label class="collapse" for="c-39506924">[-]</label><label class="expand" for="c-39506924">[1 more]</label></div><br/><div class="children"><div class="content">Haskell is incredible for refactoring. And if the team is composed of people with the outlook of the post author, the code will be usually be easy to understand. One ought not conflate the difficulty of understanding code written in an exotic language with which one is unfamiliar, and the difficulty of understanding code which is extremely abstract and unnecessarily clever. The latter sort can be written in any language.</div><br/></div></div><div id="39504903" class="c"><input type="checkbox" id="c-39504903" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39504736">parent</a><span>|</span><a href="#39506924">prev</a><span>|</span><a href="#39507423">next</a><span>|</span><label class="collapse" for="c-39504903">[-]</label><label class="expand" for="c-39504903">[4 more]</label></div><br/><div class="children"><div class="content">I mean, learning Haskell has made me a better programmer even if I&#x27;ve never used it at work.<p>Perl I have used. I wouldn&#x27;t say the same about that...</div><br/><div id="39505425" class="c"><input type="checkbox" id="c-39505425" checked=""/><div class="controls bullet"><span class="by">thesnide</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39504903">parent</a><span>|</span><a href="#39507423">next</a><span>|</span><label class="collapse" for="c-39505425">[-]</label><label class="expand" for="c-39505425">[3 more]</label></div><br/><div class="children"><div class="content">Perl is the canonical example of &quot;less is sometimes better&quot;.<p>I love coding in Perl. But it seems that everyone uses a disjoined subset of it, which makes collaboration awkward.<p>And, if C let you shoot yourself in the foot, C++ give you a shotgun to do so.. Perl gives you a timed nuclear device.</div><br/><div id="39505590" class="c"><input type="checkbox" id="c-39505590" checked=""/><div class="controls bullet"><span class="by">ay</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505425">parent</a><span>|</span><a href="#39507423">next</a><span>|</span><label class="collapse" for="c-39505590">[-]</label><label class="expand" for="c-39505590">[2 more]</label></div><br/><div class="children"><div class="content">Perl (without dependencies) works awesomely well as a replacement for bash in scripts, in my experience. Unlike Python, chances that it will break the next month (or the next decade) are virtually nil.</div><br/><div id="39505761" class="c"><input type="checkbox" id="c-39505761" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39505590">parent</a><span>|</span><a href="#39507423">next</a><span>|</span><label class="collapse" for="c-39505761">[-]</label><label class="expand" for="c-39505761">[1 more]</label></div><br/><div class="children"><div class="content">Python without dependencies will also work everywhere basically forever. Hell, most Python 2 is valid Python 3, but it&#x27;s been over a decade now - Python 3 is the default system Python in most everything.</div><br/></div></div></div></div></div></div></div></div><div id="39507423" class="c"><input type="checkbox" id="c-39507423" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#39504513">root</a><span>|</span><a href="#39504736">parent</a><span>|</span><a href="#39504903">prev</a><span>|</span><a href="#39508752">next</a><span>|</span><label class="collapse" for="c-39507423">[-]</label><label class="expand" for="c-39507423">[1 more]</label></div><br/><div class="children"><div class="content">You know there are companies making money and providing value in Haskell right now, right?<p>You probably use some in fact.<p>Your claim it is irrelevant or has no utility has no merit.</div><br/></div></div></div></div></div></div><div id="39508752" class="c"><input type="checkbox" id="c-39508752" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#39504513">prev</a><span>|</span><a href="#39504803">next</a><span>|</span><label class="collapse" for="c-39508752">[-]</label><label class="expand" for="c-39508752">[1 more]</label></div><br/><div class="children"><div class="content">There are too many articles that preach dumb code, KISS, etc. I think the issue is overemphasized, especially in the modern age of bootcamps and whatnot. Who is writing all that &quot;smart code&quot; people are complaining about? If code seems too smart for you, maybe PEBCAK. That seems far more realistic nowadays than ever before.<p>&gt; Look! I replaced this recursive function with a for loop and it still does everything that we need it to. I know it’s not as clever, but I noticed that the interns were having trouble with it and I thought that this change might help.<p>Recursion is not clever, it is not a trick. It&#x27;s a basic technique kids learn in high school in Advanced Placement CompSci A. I <i>do not</i> want to work with people who know less about their professional field of choice compared to kids. And if the educational system has failed interns, at least let them learn what recursion is on the job! Isn&#x27;t that what internship is for anyway?<p>Honestly, I don&#x27;t even get the sentiment. Many problems are naturally formulated in terms of recursion. And rewriting them as loops would be considered an optimization technique that obfuscates the reasoning.</div><br/></div></div><div id="39504803" class="c"><input type="checkbox" id="c-39504803" checked=""/><div class="controls bullet"><span class="by">ljosifov</span><span>|</span><a href="#39508752">prev</a><span>|</span><a href="#39507805">next</a><span>|</span><label class="collapse" for="c-39504803">[-]</label><label class="expand" for="c-39504803">[1 more]</label></div><br/><div class="children"><div class="content">Write boring code. Dumb code - that&#x27;s too much, no need for. Boring is just right. Steve Maguire&#x27;s &quot;Writing Solid Code&quot; is the rare book that is both practical and abstract in the right amounts. With time passing, it looks to me that boring, obvious is close enough to solid.</div><br/></div></div><div id="39507805" class="c"><input type="checkbox" id="c-39507805" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#39504803">prev</a><span>|</span><a href="#39504737">next</a><span>|</span><label class="collapse" for="c-39507805">[-]</label><label class="expand" for="c-39507805">[1 more]</label></div><br/><div class="children"><div class="content">The easiest way to explain dumb code is that there’s a brain budget, and reading someone else’s code is 2x harder than writing code. Therefore, writing dumb code means: make sure the code you write never exceeds the budget when it needs to be read.<p>Also the brain budget is very low because you often have a wide mix of talent working on the same stuff. It’s that simple.</div><br/></div></div><div id="39504737" class="c"><input type="checkbox" id="c-39504737" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#39507805">prev</a><span>|</span><a href="#39504719">next</a><span>|</span><label class="collapse" for="c-39504737">[-]</label><label class="expand" for="c-39504737">[2 more]</label></div><br/><div class="children"><div class="content">I think it is better to have a little &quot;smarter&quot; code if that means you will not bring a dependency. For example in Python or C I like things that do not need anything except the standard library. When you need to think about PIP or compilation of another library it is more code shifted to things that usually suck (like build systems) or you lose control and when something breaks you are still to blame. Sometimes it means to use something that is a bit more complex in comparison to using some nice libraries. Maybe the thing is that the library is not a dumb code anymore?</div><br/><div id="39505794" class="c"><input type="checkbox" id="c-39505794" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#39504737">parent</a><span>|</span><a href="#39504719">next</a><span>|</span><label class="collapse" for="c-39505794">[-]</label><label class="expand" for="c-39505794">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, your efforts to <i>not</i> bring in a dependency are being paid for in code you have to write and test and hope doesn&#x27;t trip over a more fundamental security flaw or exploit somewhere. If you have problems they&#x27;re now bespoke, there&#x27;s no userbase of knowledge out there.<p>And there&#x27;s a big difference between going from ZERO dependencies, to 1. Because once you&#x27;ve got 1, the complexity cost has been mostly paid already so your efforts not to bring in other dependencies are going to be marginal.<p>So the question is, are you really saving time or complexity by avoiding the dependency management process, or just wasting it deferring something you&#x27;ll already have to do later? Is it wise to constantly reproduce the same common code across multiple bits of software, rather then write it as your own library anyway (at which point you&#x27;ll be inheriting a dependency management process as well, even if it&#x27;s only internal).</div><br/></div></div></div></div><div id="39504719" class="c"><input type="checkbox" id="c-39504719" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#39504737">prev</a><span>|</span><a href="#39503899">next</a><span>|</span><label class="collapse" for="c-39504719">[-]</label><label class="expand" for="c-39504719">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We should not seek to build software. Software is the currency that we pay to solve problems, which is our actual goal. We should endeavor to build as little software as possible to solve our problems.<p><i>Slow clap</i></div><br/><div id="39506088" class="c"><input type="checkbox" id="c-39506088" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#39504719">parent</a><span>|</span><a href="#39503899">next</a><span>|</span><label class="collapse" for="c-39506088">[-]</label><label class="expand" for="c-39506088">[1 more]</label></div><br/><div class="children"><div class="content">&quot;My point today is that, if we wish to count lines of code, we should not regard them as &quot;lines produced&quot; but as &quot;lines spent&quot;: the current conventional wisdom is so foolish as to book that count on the wrong side of the ledger.&quot;<p>-- Dijkstra in 1988</div><br/></div></div></div></div><div id="39503899" class="c"><input type="checkbox" id="c-39503899" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39504719">prev</a><span>|</span><a href="#39507915">next</a><span>|</span><label class="collapse" for="c-39503899">[-]</label><label class="expand" for="c-39503899">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>Write dumb code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16257270">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16257270</a> - Jan 2018 (66 comments)</div><br/></div></div><div id="39507915" class="c"><input type="checkbox" id="c-39507915" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39503899">prev</a><span>|</span><a href="#39504278">next</a><span>|</span><label class="collapse" for="c-39507915">[-]</label><label class="expand" for="c-39507915">[1 more]</label></div><br/><div class="children"><div class="content">Code that is hard to understand at first is fine; but once you do, it should make you think &quot;wow, that&#x27;s it?&quot; and not &quot;I can think of a simpler way to do this.&quot;<p>The counterpoint to dumbing down has been called &quot;Kernighan&#x27;s lever&quot;: <a href="https:&#x2F;&#x2F;www.linusakesson.net&#x2F;programming&#x2F;kernighans-lever&#x2F;index.php" rel="nofollow">https:&#x2F;&#x2F;www.linusakesson.net&#x2F;programming&#x2F;kernighans-lever&#x2F;in...</a><p><i>but I noticed that the interns were having trouble with it</i><p>That&#x27;s their problem. The less they&#x27;re incentivised to learn and grow, the less they will; and once they no longer consider themselves beginners, they will know less than those who came before. The vicious cycle continues.<p>It&#x27;s worth noting that software development is an aberration; literally no other profession I know of has come to widely espouse the belief that beginners should be encouraged to remain stupid and unlearning while everyone else stoops to their level.</div><br/></div></div><div id="39504278" class="c"><input type="checkbox" id="c-39504278" checked=""/><div class="controls bullet"><span class="by">antoniojtorres</span><span>|</span><a href="#39507915">prev</a><span>|</span><a href="#39507108">next</a><span>|</span><label class="collapse" for="c-39504278">[-]</label><label class="expand" for="c-39504278">[2 more]</label></div><br/><div class="children"><div class="content">I couldn’t write any other type of code if I tried</div><br/><div id="39504810" class="c"><input type="checkbox" id="c-39504810" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#39504278">parent</a><span>|</span><a href="#39507108">next</a><span>|</span><label class="collapse" for="c-39504810">[-]</label><label class="expand" for="c-39504810">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. I always think I’m writing the simplest possible code, and yet when I look at it six months later, it’s still difficult.<p>I just last night was trying to remember how a PKCE client works by looking at my previous implementation. It’s not simple. This morning I was thinking, there must be a simpler way. And yet…</div><br/></div></div></div></div><div id="39507108" class="c"><input type="checkbox" id="c-39507108" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39504278">prev</a><span>|</span><a href="#39503845">next</a><span>|</span><label class="collapse" for="c-39507108">[-]</label><label class="expand" for="c-39507108">[1 more]</label></div><br/><div class="children"><div class="content">Imagine if engineers at Intel were told: design circuits that an electronics novice can understand!<p>Sometimes, the novice doesn&#x27;t understand the problem that the code is solving, no matter how the code is written, and even if it is documented in detail.<p>Now, sure, if people who easily understand <i>what</i> the code does have trouble seeing <i>how</i> the code does it, that could be a problem. Especially if the code uses a paradigm that they already understand.<p>If code solves a problem they understand, but with some unfamiliar paradigm like logic programming or functional programming, that&#x27;s their problem, though.<p>&quot;Don&#x27;t use logic programming or functional programming because some novices don&#x27;t understand it&quot; isn&#x27;t very good general advice. In situations where it makes sense, it&#x27;s not about the quality of the code but about programmers being easily replaceable with novices off the street.<p>I don&#x27;t see why any programmer should, as a matter of habit, write any code that can be maintained by people less knowledgeable or skilled than he or she. Unless it&#x27;s stipulated as a contractual requirement. In whose interest is that, anyway?</div><br/></div></div><div id="39503845" class="c"><input type="checkbox" id="c-39503845" checked=""/><div class="controls bullet"><span class="by">DriftRegion</span><span>|</span><a href="#39507108">prev</a><span>|</span><a href="#39508469">next</a><span>|</span><label class="collapse" for="c-39503845">[-]</label><label class="expand" for="c-39503845">[2 more]</label></div><br/><div class="children"><div class="content">Relevant: <a href="https:&#x2F;&#x2F;grugbrain.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;grugbrain.dev&#x2F;</a></div><br/><div id="39504235" class="c"><input type="checkbox" id="c-39504235" checked=""/><div class="controls bullet"><span class="by">DriftRegion</span><span>|</span><a href="#39503845">parent</a><span>|</span><a href="#39508469">next</a><span>|</span><label class="collapse" for="c-39504235">[-]</label><label class="expand" for="c-39504235">[1 more]</label></div><br/><div class="children"><div class="content">I have a nit with this concept being called &quot;dumb&quot; code. I see that term is an ironic rebuttal to clever code. However, calling it dumb is misleading.<p>Readability, composability and elegance in programming are always a reaction to trauma caused by the shortcomings of some previous system. Therefore I think it is not possible to teach new programmers to write it.<p>I think this trauma is the most fundamental force in organizational coding standards as well as programming language design.</div><br/></div></div></div></div><div id="39508469" class="c"><input type="checkbox" id="c-39508469" checked=""/><div class="controls bullet"><span class="by">yolkedgeek</span><span>|</span><a href="#39503845">prev</a><span>|</span><a href="#39503830">next</a><span>|</span><label class="collapse" for="c-39508469">[-]</label><label class="expand" for="c-39508469">[1 more]</label></div><br/><div class="children"><div class="content">I printed some of this and put it on the wall in my office for everyone to see</div><br/></div></div><div id="39506697" class="c"><input type="checkbox" id="c-39506697" checked=""/><div class="controls bullet"><span class="by">mofosyne</span><span>|</span><a href="#39503830">prev</a><span>|</span><a href="#39504884">next</a><span>|</span><label class="collapse" for="c-39506697">[-]</label><label class="expand" for="c-39506697">[1 more]</label></div><br/><div class="children"><div class="content">Could we use LLMs to give a readability score to codes?<p>If a dumb LLM can understand a piece of code, then maybe that&#x27;s one way to check if it&#x27;s a sensible code.</div><br/></div></div><div id="39504884" class="c"><input type="checkbox" id="c-39504884" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39506697">prev</a><span>|</span><a href="#39507475">next</a><span>|</span><label class="collapse" for="c-39504884">[-]</label><label class="expand" for="c-39504884">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a neat idea. Do something simple, easy to understand. Can&#x27;t go wrong, right? No chance of complexity sneaking in all sorts of ways.<p>I wonder if someone had this idea before.</div><br/></div></div><div id="39507475" class="c"><input type="checkbox" id="c-39507475" checked=""/><div class="controls bullet"><span class="by">mikermcneil</span><span>|</span><a href="#39504884">prev</a><span>|</span><a href="#39505872">next</a><span>|</span><label class="collapse" for="c-39507475">[-]</label><label class="expand" for="c-39507475">[1 more]</label></div><br/><div class="children"><div class="content">this is true</div><br/></div></div><div id="39505872" class="c"><input type="checkbox" id="c-39505872" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#39507475">prev</a><span>|</span><a href="#39505588">next</a><span>|</span><label class="collapse" for="c-39505872">[-]</label><label class="expand" for="c-39505872">[2 more]</label></div><br/><div class="children"><div class="content">It is not &quot;dumb code&quot;.<p>It is single interpretation, simple, noise free code, using the least powerful language features possible.</div><br/><div id="39508389" class="c"><input type="checkbox" id="c-39508389" checked=""/><div class="controls bullet"><span class="by">Ma8ee</span><span>|</span><a href="#39505872">parent</a><span>|</span><a href="#39505588">next</a><span>|</span><label class="collapse" for="c-39508389">[-]</label><label class="expand" for="c-39508389">[1 more]</label></div><br/><div class="children"><div class="content">&gt; using the least powerful language features possible<p>Why on earth would you do that? That just leads to more complex code where bugs can hide.</div><br/></div></div></div></div><div id="39505588" class="c"><input type="checkbox" id="c-39505588" checked=""/><div class="controls bullet"><span class="by">yawboakye</span><span>|</span><a href="#39505872">prev</a><span>|</span><label class="collapse" for="c-39505588">[-]</label><label class="expand" for="c-39505588">[1 more]</label></div><br/><div class="children"><div class="content">while i agree that simple is better than complex, there is no absolute measurement nor definition for what simple is. and typically complex structures&#x2F;foundations are what we build simple on top of. if our medium of expression isn’t already complex enough, we risk accidental complexity.<p>compare:<p><i>sapienti pauca</i>, a compact latin sentence which takes advantage of the complexity of latin grammar to say what may be translated into english as ‘a word to the wise is enough.’ there’s some poetic beauty in the latin sentence that adds to the force of the advice (it’s only two words after all). i don’t think we should avoid pithy expressions where the celebrate wonderful achievements (eg recursion) all in the name of sparing our audience some pain. no, write that compact code, please. we’re happy to spend time learning just as we’ve spent time learning and appreciating the works of masters of other fields.</div><br/></div></div></div></div></div></div></div></body></html>