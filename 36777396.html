<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689757254306" as="style"/><link rel="stylesheet" href="styles.css?v=1689757254306"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bytewax.io/blog/data-parallel-task-parallel-and-agent-actor-architectures">Data Parallel, Task Parallel, and Agent Actor Architectures</a> <span class="domain">(<a href="https://bytewax.io">bytewax.io</a>)</span></div><div class="subtext"><span>skadamat</span> | <span>23 comments</span></div><br/><div><div id="36779214" class="c"><input type="checkbox" id="c-36779214" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#36778575">next</a><span>|</span><label class="collapse" for="c-36779214">[-]</label><label class="expand" for="c-36779214">[6 more]</label></div><br/><div class="children"><div class="content">Tasks and Parallel are available as first class citizens in the .NET framework. Large apis. Easy to cold start a good headache. It&#x27;s not easy stuff.<p>Difficult patterns to optimize for is my experience if any IO or network boundaries are in play. Even that and it sometimes seems the more knowledge on how threading works on one particular cpu architecture.<p>So for me at least, on a high level these patterns seem easy enough and seems to play well in to the popculcural small service fad and large data processing. But be aware of the underlying cpu architecture and threading and how thread pools work on your particular OS.<p>Oh yes and then comes the debugging and reading the code part, which we all know are where the real efforts of time comes to play.<p>Use these when absolutely no other options are available. Just like multithreading.</div><br/><div id="36783653" class="c"><input type="checkbox" id="c-36783653" checked=""/><div class="controls bullet"><span class="by">rawoke083600</span><span>|</span><a href="#36779214">parent</a><span>|</span><a href="#36779539">next</a><span>|</span><label class="collapse" for="c-36783653">[-]</label><label class="expand" for="c-36783653">[1 more]</label></div><br/><div class="children"><div class="content">Agreed ! This looks complex but maybe cause I&#x27;m not in the .NET world ?<p>Noob question: Can 90%+ of the &quot;effect&quot; from the above not be replicated or be done with Go-Lang&#x27;s CSP (or another language that also uses CSP) ?<p>Is Golang or CSP model perfect ? Of course not, but It it is &quot;relatively&quot; easy to reason about compared to &quot;catalogue of other options&quot; ?</div><br/></div></div><div id="36779539" class="c"><input type="checkbox" id="c-36779539" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#36779214">parent</a><span>|</span><a href="#36783653">prev</a><span>|</span><a href="#36781164">next</a><span>|</span><label class="collapse" for="c-36779539">[-]</label><label class="expand" for="c-36779539">[1 more]</label></div><br/><div class="children"><div class="content">var task1 = service.DispatchFirst(param1);<p>var task2 = service.DispatchSecond(param2);<p>var final = service.DispatchThird(await task1, await task2);<p>or<p>var queries = users.Select(user =&gt; FetchPurchases(user.Id));<p>var results = await Task.WhenAll(queries);<p>Very easy.<p>As long as you don&#x27;t touch System.Threading.Tasks.Dataflow namespace, everything will be good.</div><br/></div></div><div id="36781164" class="c"><input type="checkbox" id="c-36781164" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#36779214">parent</a><span>|</span><a href="#36779539">prev</a><span>|</span><a href="#36779943">next</a><span>|</span><label class="collapse" for="c-36781164">[-]</label><label class="expand" for="c-36781164">[1 more]</label></div><br/><div class="children"><div class="content">Actually so is data - TPL Dataflow.</div><br/></div></div><div id="36779943" class="c"><input type="checkbox" id="c-36779943" checked=""/><div class="controls bullet"><span class="by">victor106</span><span>|</span><a href="#36779214">parent</a><span>|</span><a href="#36781164">prev</a><span>|</span><a href="#36779442">next</a><span>|</span><label class="collapse" for="c-36779943">[-]</label><label class="expand" for="c-36779943">[1 more]</label></div><br/><div class="children"><div class="content">Anyone know of these are available in the Java world?</div><br/></div></div><div id="36779442" class="c"><input type="checkbox" id="c-36779442" checked=""/><div class="controls bullet"><span class="by">Fellshard</span><span>|</span><a href="#36779214">parent</a><span>|</span><a href="#36779943">prev</a><span>|</span><a href="#36778575">next</a><span>|</span><label class="collapse" for="c-36779442">[-]</label><label class="expand" for="c-36779442">[1 more]</label></div><br/><div class="children"><div class="content">When I used those libraries in .NET, they simply did not function, for unspecified reasons. I boiled it down to the smallest possible example, based on their docs, and data simply never made it through the flow at all. It was baffling to me, but not an uncommon experience with various components of the core of .NET (not to be confused with .NET Core).</div><br/></div></div></div></div><div id="36778575" class="c"><input type="checkbox" id="c-36778575" checked=""/><div class="controls bullet"><span class="by">amath</span><span>|</span><a href="#36779214">prev</a><span>|</span><a href="#36780407">next</a><span>|</span><label class="collapse" for="c-36778575">[-]</label><label class="expand" for="c-36778575">[10 more]</label></div><br/><div class="children"><div class="content">Author of the post here. I would love to hear thoughts on folks experience using the different architectures and more pros and cons to each one. There was surprisingly not a lot of information comparing these different architectures that I could find and I would love to be able to update this post with more details.</div><br/><div id="36779947" class="c"><input type="checkbox" id="c-36779947" checked=""/><div class="controls bullet"><span class="by">Sardtok</span><span>|</span><a href="#36778575">parent</a><span>|</span><a href="#36781388">next</a><span>|</span><label class="collapse" for="c-36779947">[-]</label><label class="expand" for="c-36779947">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s the Seven Concurrency Models in Seven Weeks book. It&#x27;s a bit old, and not so much about frameworks, but more about programming languages and their available threading models or alternatives to pure threads. It still covers a lot of the same theory, but not distributed, and a bit lower level.<p><a href="https:&#x2F;&#x2F;pragprog.com&#x2F;titles&#x2F;pb7con&#x2F;seven-concurrency-models-in-seven-weeks&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pragprog.com&#x2F;titles&#x2F;pb7con&#x2F;seven-concurrency-models-...</a></div><br/></div></div><div id="36781388" class="c"><input type="checkbox" id="c-36781388" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#36778575">parent</a><span>|</span><a href="#36779947">prev</a><span>|</span><a href="#36778723">next</a><span>|</span><label class="collapse" for="c-36781388">[-]</label><label class="expand" for="c-36781388">[1 more]</label></div><br/><div class="children"><div class="content">I put here an aside: All this is super-complicated for most use-cases.<p>What I have never used, but is inferred from <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_concurrent_and_parallel_programming_languages" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_concurrent_and_paralle...</a> and in special the <i>original</i> CSP is how all this lacks total control in <i>build your network patterns</i>.<p>In special, is my dream to have a language that allows to express better what is explained starting here:<p><a href="https:&#x2F;&#x2F;zguide.zeromq.org&#x2F;docs&#x2F;chapter2&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zguide.zeromq.org&#x2F;docs&#x2F;chapter2&#x2F;</a><p>There is not (AFAIK) languages that make nice to properly wire this AND keep the semantic understanding&#x2F;composability of it.<p>For example, is hard to know if a function if is running in a thread&#x2F;process, what is their priority, etc.<p>I imagine that a language with orchestration (like Erlang&#x2F;Elixir) in a <i>explicit</i> way will be far easier, but is hard to figure how do it with good composability</div><br/></div></div><div id="36778723" class="c"><input type="checkbox" id="c-36778723" checked=""/><div class="controls bullet"><span class="by">skadamat</span><span>|</span><a href="#36778575">parent</a><span>|</span><a href="#36781388">prev</a><span>|</span><a href="#36780407">next</a><span>|</span><label class="collapse" for="c-36778723">[-]</label><label class="expand" for="c-36778723">[7 more]</label></div><br/><div class="children"><div class="content">besides Ray, are there other tools or platforms that embrace the agent actor architecture model?</div><br/><div id="36778872" class="c"><input type="checkbox" id="c-36778872" checked=""/><div class="controls bullet"><span class="by">felixgallo</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778723">parent</a><span>|</span><a href="#36781509">next</a><span>|</span><label class="collapse" for="c-36778872">[-]</label><label class="expand" for="c-36778872">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.erlang.org&#x2F;</a>
<a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;</a></div><br/><div id="36779355" class="c"><input type="checkbox" id="c-36779355" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778872">parent</a><span>|</span><a href="#36779375">next</a><span>|</span><label class="collapse" for="c-36779355">[-]</label><label class="expand" for="c-36779355">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is amazing, see also stuff like <a href="https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;libcluster">https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;libcluster</a> . I&#x27;m always surprised there&#x27;s not more excitement generated by the possibility of having <i>language-level features</i> that would normally require all the weight of something like k8s.  I don&#x27;t get the impression that many people are seriously using it for data-engineering work though, which seems like a shame</div><br/></div></div><div id="36779375" class="c"><input type="checkbox" id="c-36779375" checked=""/><div class="controls bullet"><span class="by">Nezteb</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778872">parent</a><span>|</span><a href="#36779355">prev</a><span>|</span><a href="#36781509">next</a><span>|</span><label class="collapse" for="c-36779375">[-]</label><label class="expand" for="c-36779375">[1 more]</label></div><br/><div class="children"><div class="content">Elixir definitely!<p>If you need to use Go, there is also ergo: <a href="https:&#x2F;&#x2F;github.com&#x2F;ergo-services&#x2F;ergo">https:&#x2F;&#x2F;github.com&#x2F;ergo-services&#x2F;ergo</a><p>Yet another cool tool is lunatic: <a href="https:&#x2F;&#x2F;github.com&#x2F;lunatic-solutions&#x2F;lunatic">https:&#x2F;&#x2F;github.com&#x2F;lunatic-solutions&#x2F;lunatic</a></div><br/></div></div></div></div><div id="36781509" class="c"><input type="checkbox" id="c-36781509" checked=""/><div class="controls bullet"><span class="by">jgraettinger1</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778723">parent</a><span>|</span><a href="#36778872">prev</a><span>|</span><a href="#36782264">next</a><span>|</span><label class="collapse" for="c-36781509">[-]</label><label class="expand" for="c-36781509">[1 more]</label></div><br/><div class="children"><div class="content">Estuary Flow derivations [1], I suspect (I work here)? You write a program which has messages pushed to it, which maintains and updates an internal state, and which publishes output messages.<p>You can build cyclic data-flows [2] - not just DAGs - which seems a key ingredient.<p>You can also write contract-based tests that verify the end-to-end behaviors of your &quot;agents&quot; [3].<p>Today, you&#x27;re limited to SQLite or TypeScript. Looking forward, we aim to open it up to any program packaged in a docker container.<p>[1] <a href="https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;derivations&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;derivations&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;derivations&#x2F;#approving-transfers" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;derivations&#x2F;#approving-tra...</a><p>[3] <a href="https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;tests&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.estuary.dev&#x2F;concepts&#x2F;tests&#x2F;</a></div><br/></div></div><div id="36782264" class="c"><input type="checkbox" id="c-36782264" checked=""/><div class="controls bullet"><span class="by">brahbrah</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778723">parent</a><span>|</span><a href="#36781509">prev</a><span>|</span><a href="#36779868">next</a><span>|</span><label class="collapse" for="c-36782264">[-]</label><label class="expand" for="c-36782264">[1 more]</label></div><br/><div class="children"><div class="content">Dask added an actor model after seeing it in Ray. I’ve used dasks in some computationally intensive applications (already had existing dask infrastructure which is why we didn’t go with rays)</div><br/></div></div><div id="36779868" class="c"><input type="checkbox" id="c-36779868" checked=""/><div class="controls bullet"><span class="by">Sardtok</span><span>|</span><a href="#36778575">root</a><span>|</span><a href="#36778723">parent</a><span>|</span><a href="#36782264">prev</a><span>|</span><a href="#36780407">next</a><span>|</span><label class="collapse" for="c-36779868">[-]</label><label class="expand" for="c-36779868">[1 more]</label></div><br/><div class="children"><div class="content">Akka uses the actor model. <a href="https:&#x2F;&#x2F;doc.akka.io&#x2F;docs&#x2F;akka&#x2F;current&#x2F;typed&#x2F;actors.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.akka.io&#x2F;docs&#x2F;akka&#x2F;current&#x2F;typed&#x2F;actors.html</a><p>IIRC, Akka based their implementation on Erlang (possibly OTP), but it&#x27;s been a long time since I did anything with either Erlang or Scala, and I never used Akka in Java.</div><br/></div></div></div></div></div></div><div id="36780407" class="c"><input type="checkbox" id="c-36780407" checked=""/><div class="controls bullet"><span class="by">lliamander</span><span>|</span><a href="#36778575">prev</a><span>|</span><a href="#36779213">next</a><span>|</span><label class="collapse" for="c-36780407">[-]</label><label class="expand" for="c-36780407">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused about task parallelism. Is that like a job scheduler that can run multiple jobs in parallel?  Or is it more like a pipeline parallelism?</div><br/></div></div><div id="36779213" class="c"><input type="checkbox" id="c-36779213" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#36780407">prev</a><span>|</span><a href="#36779997">next</a><span>|</span><label class="collapse" for="c-36779213">[-]</label><label class="expand" for="c-36779213">[2 more]</label></div><br/><div class="children"><div class="content">Ok, I&#x27;ll bite.  I&#x27;ve always thought that agent-oriented &#x2F; reactor &#x2F; proactor type patterns are elegant and yet under-utilized and under-appreciated.  If I had to guess about why.. maybe these systems scale well in terms of traffic but do not tend to scale well in terms of implementation at most orgs?<p>When the average dev team finally gets the simple queue they asked ops for, the thing is probably late and only present in 2&#x2F;3 of dev&#x2F;qa&#x2F;prod (or some similar SNAFU).  Flink works with AWS EMR, so we can&#x27;t explain everything by just considering whether hosted services are available, but admin&#x2F;setup&#x2F;general conceptual overhead is on a different level.  Partly because they&#x27;ve been burned in the past with stuff like this, and partly because they are lazy.. devs mostly want simple infrastructure mirroring simple data-structures where they can test&#x2F;develop discrete code locally without thinking about system-level stuff.<p>Consider the problem of a) developing a new agent in an actor system vs b) developing a new &quot;step&quot; in a simpler batch-oriented pipeline.  For (a), to actually run my code experimentally locally I need to simulate the appropriate message(s) locally and maybe other aspects of system-runtime.  Whereas for (b) one digs up appropriate input and starts hacking on a docker-container that one trusts can be jammed into an airflow DAG later.  Both approaches need a bit of dev&#x2F;test harness kinda setup, but (a) is potentially more involved and more importantly it usually crosses team-boundaries (requiring both devops and devs).  This will probably create pain unless the org has a talented &quot;platform team&quot; already in place.<p>Another aspect involving team boundaries is that besides dev teams disliking ops&#x2F;infra, they also don&#x27;t trust each other!  So after effort is sunk into things like the &quot;smarter-queue&quot; that might support messaging and actors making actors, it turns out every team wants their own queues, routing, codebases, underlying storage, etc.  For better or worse, attempting to provide features along the lines of flexibility&#x2F;interoperability are thus undermined.  Out of necessity, teams often want to provide some limited access to <i>data</i> which other teams can consume.  But they resist providing any kind of access to code APIs &#x2F; runtime.<p>Typical scenario: Ever work at an org that&#x27;s supposed to have a data-lake, but every single new app or new feature inside an existing app generates requests for new buckets that literally nothing in the existing system can access?  Some manager or &quot;senior&quot; dev is having a knee-jerk reaction that they want to build a kingdom.  In the end they won&#x27;t actually <i>enjoy</i> answering access-requests to their walled-garden, but they think they can push those over to support requests.  With only data as a deliverable, they don&#x27;t need to think about any interop and, bonus, no one will even know if their messy scripts are in version control.</div><br/><div id="36779318" class="c"><input type="checkbox" id="c-36779318" checked=""/><div class="controls bullet"><span class="by">amath</span><span>|</span><a href="#36779213">parent</a><span>|</span><a href="#36779997">next</a><span>|</span><label class="collapse" for="c-36779318">[-]</label><label class="expand" for="c-36779318">[1 more]</label></div><br/><div class="children"><div class="content">describing so many nightmares here :). The overhead of testing&#x2F;running locally is so important and yet so frequently not optimized for.</div><br/></div></div></div></div><div id="36779997" class="c"><input type="checkbox" id="c-36779997" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#36779213">prev</a><span>|</span><label class="collapse" for="c-36779997">[-]</label><label class="expand" for="c-36779997">[3 more]</label></div><br/><div class="children"><div class="content">&quot;data parallel&quot; and &quot;task parallel&quot; are the same thing. You work out data dependencies ahead of time and a thread does something specific by reading the data it needs. Whether you do that by giving a bunch of threads the same data and then giving them a range they need to work on or give them different chunks of data, it boils down to the same mechanic of having data ahead of time and executing something specific, dictated by a different thread and using data they don&#x27;t own.</div><br/><div id="36780030" class="c"><input type="checkbox" id="c-36780030" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#36779997">parent</a><span>|</span><label class="collapse" for="c-36780030">[-]</label><label class="expand" for="c-36780030">[2 more]</label></div><br/><div class="children"><div class="content">At a high enough level I guess everything is just computation but using GPGPU as an example there are programs where control flow diverges and ones where it doesn&#x27;t.</div><br/><div id="36780513" class="c"><input type="checkbox" id="c-36780513" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#36779997">root</a><span>|</span><a href="#36780030">parent</a><span>|</span><label class="collapse" for="c-36780513">[-]</label><label class="expand" for="c-36780513">[1 more]</label></div><br/><div class="children"><div class="content">I think you mean at a low enough level and jumping to that generality doesn&#x27;t make sense here.<p>The same could be said for splitting a bunch of threads off with opemMP. It isn&#x27;t about divergence, it is about data dependencies, data owership and synchronization, which are all the same in both scenarios.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>