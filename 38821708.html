<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704186060864" as="style"/><link rel="stylesheet" href="styles.css?v=1704186060864"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.methodsandtools.com/archive/archive.php?id=39">Decision Table Based Methodology for Software Development (2004)</a> <span class="domain">(<a href="https://www.methodsandtools.com">www.methodsandtools.com</a>)</span></div><div class="subtext"><span>rramadass</span> | <span>20 comments</span></div><br/><div><div id="38821833" class="c"><input type="checkbox" id="c-38821833" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38837935">next</a><span>|</span><label class="collapse" for="c-38821833">[-]</label><label class="expand" for="c-38821833">[10 more]</label></div><br/><div class="children"><div class="content">Excellent and succinct article on the use of &quot;Decision Tables&quot;. This is a fundamental technique in Software Development but is rarely taught&#x2F;known nowadays.<p>See also :<p>1) Hillel Wayne - <a href="https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;decision-tables&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;decision-tables&#x2F;</a> and <a href="https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;decision-table-patterns&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;decision-table-patterns&#x2F;</a><p>2) Parnas Tables : A Practical Formalism (pdf) - <a href="https:&#x2F;&#x2F;cs.uwaterloo.ca&#x2F;~jmatlee&#x2F;Talks&#x2F;Parnas01.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.uwaterloo.ca&#x2F;~jmatlee&#x2F;Talks&#x2F;Parnas01.pdf</a><p>3) Tabular Expressions and their Relational Semantics (pdf) - <a href="http:&#x2F;&#x2F;www.cas.mcmaster.ca&#x2F;~wassyng&#x2F;FIJanWas.pdf" rel="nofollow">http:&#x2F;&#x2F;www.cas.mcmaster.ca&#x2F;~wassyng&#x2F;FIJanWas.pdf</a></div><br/><div id="38836759" class="c"><input type="checkbox" id="c-38836759" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#38821833">parent</a><span>|</span><a href="#38822656">next</a><span>|</span><label class="collapse" for="c-38836759">[-]</label><label class="expand" for="c-38836759">[4 more]</label></div><br/><div class="children"><div class="content">And &quot;Decision Tables&quot; often lead one into the wonderful world of Finite State Machines[0], another fundamental concept &quot;rarely taught&#x2F;known nowadays.&quot;<p>The applicability of both in many problem domains remains a source of pleasant surprise to me to this day.<p>0 - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite-state_machine" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite-state_machine</a></div><br/><div id="38839223" class="c"><input type="checkbox" id="c-38839223" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38836759">parent</a><span>|</span><a href="#38822656">next</a><span>|</span><label class="collapse" for="c-38839223">[-]</label><label class="expand" for="c-38839223">[3 more]</label></div><br/><div class="children"><div class="content">As a non-CS major who had encountered finite state machines in my early teens, it boggles my mind to consider that nowadays someone could successfully get through a CS curriculum without them.<p>(a trie ain&#x27;t nothing but a degenerate state machine)<p>On second thought, this is a wonderful hypothesis, because it would explain <i>so</i> much about the modern software environment...</div><br/><div id="38839333" class="c"><input type="checkbox" id="c-38839333" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38839223">parent</a><span>|</span><a href="#38822656">next</a><span>|</span><label class="collapse" for="c-38839333">[-]</label><label class="expand" for="c-38839333">[2 more]</label></div><br/><div class="children"><div class="content">What makes them essential? Never have I encountered them</div><br/><div id="38839603" class="c"><input type="checkbox" id="c-38839603" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38839333">parent</a><span>|</span><a href="#38822656">next</a><span>|</span><label class="collapse" for="c-38839603">[-]</label><label class="expand" for="c-38839603">[1 more]</label></div><br/><div class="children"><div class="content">They are the Turing Machine without the (infinite) tape. What is your favourite abstraction of computer?</div><br/></div></div></div></div></div></div></div></div><div id="38822656" class="c"><input type="checkbox" id="c-38822656" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38821833">parent</a><span>|</span><a href="#38836759">prev</a><span>|</span><a href="#38836385">next</a><span>|</span><label class="collapse" for="c-38822656">[-]</label><label class="expand" for="c-38822656">[3 more]</label></div><br/><div class="children"><div class="content">Considering that defining functions by sets of pattern matched clauses is a thing in more and more languages, it&#x27;s rarely known for some values of &quot;rarely&quot;.</div><br/><div id="38822948" class="c"><input type="checkbox" id="c-38822948" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38822656">parent</a><span>|</span><a href="#38837635">next</a><span>|</span><label class="collapse" for="c-38822948">[-]</label><label class="expand" for="c-38822948">[1 more]</label></div><br/><div class="children"><div class="content">The article is not just about using decision tables at the code level but as a design methodology right from requirements stage.</div><br/></div></div><div id="38837635" class="c"><input type="checkbox" id="c-38837635" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38822656">parent</a><span>|</span><a href="#38822948">prev</a><span>|</span><a href="#38836385">next</a><span>|</span><label class="collapse" for="c-38837635">[-]</label><label class="expand" for="c-38837635">[1 more]</label></div><br/><div class="children"><div class="content">A key difference between pattern matching and decision tables is the intrinsic flexibility of the latter at the expense of simplicity the former provides.  Whereas pattern matching most often encodes branching statically by what is explicitly encoded, decision tables allow for runtime branching based on workflow context.<p>Both have their strengths and weaknesses and, IMHO, the choice as to which to use is situational.<p>Another related technique which employs a bit of both of these approaches is the Visitor pattern[0].<p>0 - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Visitor_pattern" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Visitor_pattern</a></div><br/></div></div></div></div><div id="38836385" class="c"><input type="checkbox" id="c-38836385" checked=""/><div class="controls bullet"><span class="by">gopher_space</span><span>|</span><a href="#38821833">parent</a><span>|</span><a href="#38822656">prev</a><span>|</span><a href="#38837935">next</a><span>|</span><label class="collapse" for="c-38836385">[-]</label><label class="expand" for="c-38836385">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but is rarely taught&#x2F;known nowadays<p>If you don&#x27;t need to codec through English there isn&#x27;t much of a point.  It&#x27;s easy to work with ctrl-v&#x27;d spreadsheet formulas and hard to create a written narrative around them.</div><br/><div id="38838753" class="c"><input type="checkbox" id="c-38838753" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38821833">root</a><span>|</span><a href="#38836385">parent</a><span>|</span><a href="#38837935">next</a><span>|</span><label class="collapse" for="c-38838753">[-]</label><label class="expand" for="c-38838753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you don&#x27;t need to code through English there isn&#x27;t much of a point.<p>Disagree. The intent is to think through and write down the requirements unambiguously from problem domain so that it can be mapped easily to solution domain.</div><br/></div></div></div></div></div></div><div id="38837935" class="c"><input type="checkbox" id="c-38837935" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#38821833">prev</a><span>|</span><a href="#38828707">next</a><span>|</span><label class="collapse" for="c-38837935">[-]</label><label class="expand" for="c-38837935">[3 more]</label></div><br/><div class="children"><div class="content">So much of what passes for &#x27;requirements gathering&#x27; in software development historically has consisted of precisely this kind of heuristic-collecting. Trying to come up with rigorous rules for, as here, &#x27;when should we serve cocktails on planes&#x27;, so we can build software that enshrines those rules, so that at some point, someone will be refused a cocktail under circumstances when one might help. Congratulations, software engineers. You made someone&#x27;s day a little worse.<p>The goal of software engineering isn&#x27;t to make rules lawyers that implement the same logic as staff do only with less imagination and discretion. That&#x27;s just a shortcut to reducing staff numbers while making worse decisions and reducing service quality.<p>The goal of software engineering should be to make systems that can support making <i>better</i> decisions. The rules your staff use <i>today</i> to figure out what flights should serve cocktails are themselves policies that evolved in service of some broader business goal, taking into account behind the scenes information like service costs, customer satisfaction, competitive analysis, brand intentions, etc.<p>Build software that supports <i>that</i> process.</div><br/><div id="38838931" class="c"><input type="checkbox" id="c-38838931" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38837935">parent</a><span>|</span><a href="#38838428">next</a><span>|</span><label class="collapse" for="c-38838931">[-]</label><label class="expand" for="c-38838931">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure i understand your argument.<p>The process of &quot;requirements gathering&quot; is by definition heuristic and iterative. The point of encoding it via &quot;Decision Tables&quot; (or any other technique) by a Domain Expert&#x2F;Software Engineer is to be precise&#x2F;rigorous so that it can be easily translated into computer code unambiguously.<p>The usage of the above will vary industry by industry depending upon their needs i.e. &quot;Technical aspects&quot; vs. &quot;Social aspects&quot;. Thus a Nuclear Plant Manager&#x2F;Aeroplane Pilot will be tightly confined within set bounds while Retail industry&#x2F;Customer care will have a lot more leeway to consider the &quot;Social aspects&quot; involved. This can only be solved by &quot;Human Resources Training&quot; over and above Computer-aided support. The field of &quot;Decision Support Systems&quot; (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Decision_support_system" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Decision_support_system</a>) is well established and supports a wide spectrum of both Computer and Human factors.</div><br/></div></div><div id="38838428" class="c"><input type="checkbox" id="c-38838428" checked=""/><div class="controls bullet"><span class="by">tunesmith</span><span>|</span><a href="#38837935">parent</a><span>|</span><a href="#38838931">prev</a><span>|</span><a href="#38828707">next</a><span>|</span><label class="collapse" for="c-38838428">[-]</label><label class="expand" for="c-38838428">[1 more]</label></div><br/><div class="children"><div class="content">I think the article probably used a bad example. I think the intent was to pick an example that is easy to understand even for non-programmers - the rules behind serving cocktails on flights - rather than imply that this technique is intended for social rules that humans should follow.<p>If instead imagined to apply toward some of the complicated logic we regularly come across in actual computer programming, it starts to feel more useful. As programmers we&#x27;ve all come across cases of snarly boolean logic that nests multiple levels deep. In those cases, I&#x27;ve found decision trees very useful. I&#x27;ve taken it to the point of literally listing out every combination of conditions, rather than just the ones that seem to apply. Through that you can sometimes discover corner cases that need to be accounted for. Other times, you realize that you can collapse parts of the state so that your end-result conditional logic becomes much simpler. If you&#x27;ve ever had that case where you realized that your third-level internal condition could be moved to the outermost condition, thereby simplifying the code significantly, then that&#x27;s what the exercise helps with.</div><br/></div></div></div></div><div id="38828707" class="c"><input type="checkbox" id="c-38828707" checked=""/><div class="controls bullet"><span class="by">fredkline</span><span>|</span><a href="#38837935">prev</a><span>|</span><a href="#38838891">next</a><span>|</span><label class="collapse" for="c-38828707">[-]</label><label class="expand" for="c-38828707">[4 more]</label></div><br/><div class="children"><div class="content">It amazes me that there is so little familiarity with Decision Tables. The greatest effort in software development or documenting processes isn’t coding; it’s the effort of covering every possible combination of circumstances – user input, database transaction, or any other events&#x2F;rules – that the program&#x2F;process will encounter. If any combination of inputs&#x2F;events is overlooked, the program will function randomly, or the business process will be incomplete. Here&#x27;s a couple of tutorial videos on an AI enabled Decision Table Processor, LogicGem. It shows how to build a table representing your Program Logic or Business Rules and then how it can find any missing, redundant, contradictory or ambiguous rules and then automatically fix them. It then shows how it generates documentation in English, French, Spanish and German and even generates source code of the validated and complete set of rules in 25 different programming languages for inserting in your application. Check them out at <a href="https:&#x2F;&#x2F;youtube.com&#x2F;@logicgem" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;@logicgem</a></div><br/><div id="38837995" class="c"><input type="checkbox" id="c-38837995" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38828707">parent</a><span>|</span><a href="#38835134">next</a><span>|</span><label class="collapse" for="c-38837995">[-]</label><label class="expand" for="c-38837995">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It amazes me that there is so little familiarity with Decision Tables.<p>They are just another language, overtly verbose, with no opportunity for a clean presentation of your ideas, that convey the exact same information you encode on your code, and isn&#x27;t any more clear to laypeople than code.<p>That stuff has some utility in a place or another, but if you are really thinking about making people fill one up, you should look into letting those people use a real programing language.</div><br/><div id="38839016" class="c"><input type="checkbox" id="c-38839016" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#38828707">root</a><span>|</span><a href="#38837995">parent</a><span>|</span><a href="#38835134">next</a><span>|</span><label class="collapse" for="c-38839016">[-]</label><label class="expand" for="c-38839016">[1 more]</label></div><br/><div class="children"><div class="content">Not quite so simple. Computer Programming involves a lot of state management, book keeping and various other intricacies which many don&#x27;t want&#x2F;learn to do. A person trying to solve his problem should only focus on his problem domain concepts, their relationships and means of expressing them directly. That is why DSLs are a thing. A decision table is such a natural, simple and yet powerful way to model requirements that anybody can learn to do this by themselves.</div><br/></div></div></div></div><div id="38835134" class="c"><input type="checkbox" id="c-38835134" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38828707">parent</a><span>|</span><a href="#38837995">prev</a><span>|</span><a href="#38838891">next</a><span>|</span><label class="collapse" for="c-38835134">[-]</label><label class="expand" for="c-38835134">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.</i> — AJP</div><br/></div></div></div></div><div id="38838891" class="c"><input type="checkbox" id="c-38838891" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38828707">prev</a><span>|</span><a href="#38837174">next</a><span>|</span><label class="collapse" for="c-38838891">[-]</label><label class="expand" for="c-38838891">[1 more]</label></div><br/><div class="children"><div class="content">If &quot;smart contracts&quot; were decision tables, there would be much less trouble from them. Decision tables are exhaustively testable. But no, they had to be Turing-complete.</div><br/></div></div><div id="38837174" class="c"><input type="checkbox" id="c-38837174" checked=""/><div class="controls bullet"><span class="by">omgwtfbyobbq</span><span>|</span><a href="#38838891">prev</a><span>|</span><label class="collapse" for="c-38837174">[-]</label><label class="expand" for="c-38837174">[1 more]</label></div><br/><div class="children"><div class="content">Decision Tables are great. If they get too hairy, consider a suitable rules engine or bpmn.</div><br/></div></div></div></div></div></div></div></body></html>