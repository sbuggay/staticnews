<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693126853352" as="style"/><link rel="stylesheet" href="styles.css?v=1693126853352"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/onnokort/semu-c64">Linux on a Commodore 64</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>johnwbyrd</span> | <span>70 comments</span></div><br/><div><div id="37277908" class="c"><input type="checkbox" id="c-37277908" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37277908">[-]</label><label class="expand" for="c-37277908">[20 more]</label></div><br/><div class="children"><div class="content">Onno Kortman has taken semu, a minimal RISC-V emulator, and cross-compiled it with llvm-mos, an LLVM port to the MOS 6502 processor, in order to run Linux on the Commodore 64.  Kortman writes: &quot;The screenshots took VICE a couple hours in &#x27;warp mode&#x27; to generate. So, as is, a real C64 should be able to boot Linux within a week or so.&quot;</div><br/><div id="37278166" class="c"><input type="checkbox" id="c-37278166" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#37277908">parent</a><span>|</span><a href="#37278292">next</a><span>|</span><label class="collapse" for="c-37278166">[-]</label><label class="expand" for="c-37278166">[8 more]</label></div><br/><div class="children"><div class="content">The 6502 is a notoriously poor target for C compilation, especially C that hasn&#x27;t been written with the 6502&#x27;s limitations in mind. I&#x27;ll bet if you wrote a RISC-V emulator in native 6502 you could get Linux booting on a real machine in a day instead of a week. Think about how many lives that&#x27;d save!<p><a href="https:&#x2F;&#x2F;www.folklore.org&#x2F;StoryView.py?story=Saving_Lives.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.folklore.org&#x2F;StoryView.py?story=Saving_Lives.txt</a></div><br/><div id="37278339" class="c"><input type="checkbox" id="c-37278339" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278166">parent</a><span>|</span><a href="#37278292">next</a><span>|</span><label class="collapse" for="c-37278339">[-]</label><label class="expand" for="c-37278339">[7 more]</label></div><br/><div class="children"><div class="content">Says you.  llvm-mos generates surprisingly efficient 6502 code given its age and maturity.  Don&#x27;t take my word for it, try some experiments with it on godbolt.</div><br/><div id="37278900" class="c"><input type="checkbox" id="c-37278900" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278339">parent</a><span>|</span><a href="#37278932">next</a><span>|</span><label class="collapse" for="c-37278900">[-]</label><label class="expand" for="c-37278900">[3 more]</label></div><br/><div class="children"><div class="content">Sure. Here&#x27;s a couple of functions to iterate over an array of &quot;Ball&quot; objects, as you might do in a Breakout-style game that has a multi-ball powerup. I didn&#x27;t do anything to make it particularly 6502-amenable; it&#x27;s how I&#x27;d write it for a modern machine, probably. Even compiled with -O2: as expected, the code is slow and enormous - a single addition compiles to something like 30 instructions.<p>[0] <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;f6Ysv7nve" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;f6Ysv7nve</a></div><br/><div id="37280138" class="c"><input type="checkbox" id="c-37280138" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278900">parent</a><span>|</span><a href="#37279111">next</a><span>|</span><label class="collapse" for="c-37280138">[-]</label><label class="expand" for="c-37280138">[1 more]</label></div><br/><div class="children"><div class="content">Seems like your problem is more with the venerable 6502 itself rather than the compiler.  Most of that assembly code is spent calculating the offsets inside the Ball struct, which must be done at 16 bits of resolution in every case.  The compiler&#x27;s using the indirect indexed (zero page address with Y offset) 6502 addressing mode to get at all the fields in your struct.  It has placed all the variables in zero page, so no instruction is more than two bytes long; additionally, the code in question is entirely linear, with no JSRs or other subroutines.  Note in particular how it efficiently uses DEY&#x2F;INY pairs of one byte instructions to get at low and high bytes of 16-bit memory.  Hand-written assembly might be speedier, but not by much and still deal with all the corner cases that your generated code does.  &quot;While writing Apple BASIC for a 6502 microprocessor I repeatedly encountered a variant of Murphy&#x27;s Law.  Briefly stated, any routine operating on 16 bit data will require at least twice the code that it should.&quot; -Steve Wozniak</div><br/></div></div></div></div><div id="37278932" class="c"><input type="checkbox" id="c-37278932" checked=""/><div class="controls bullet"><span class="by">classichasclass</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278339">parent</a><span>|</span><a href="#37278900">prev</a><span>|</span><a href="#37278292">next</a><span>|</span><label class="collapse" for="c-37278932">[-]</label><label class="expand" for="c-37278932">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve yet to see the 6502 C compiler that can beat good assembly code. I appreciate the convenience and llvm-mos has certainly improved greatly, but if you want speed on a 6502, there&#x27;s no substitute.</div><br/><div id="37279164" class="c"><input type="checkbox" id="c-37279164" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278932">parent</a><span>|</span><a href="#37278292">next</a><span>|</span><label class="collapse" for="c-37279164">[-]</label><label class="expand" for="c-37279164">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve yet to see a 6502 C compiler get within <i>sight</i> of good assembly code. C makes many assumptions that are slow to implement on a 6502, and are notoriously hard to optimize.</div><br/><div id="37280786" class="c"><input type="checkbox" id="c-37280786" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279164">parent</a><span>|</span><a href="#37278292">next</a><span>|</span><label class="collapse" for="c-37280786">[-]</label><label class="expand" for="c-37280786">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2lW3WHPtmKo">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2lW3WHPtmKo</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37278292" class="c"><input type="checkbox" id="c-37278292" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#37277908">parent</a><span>|</span><a href="#37278166">prev</a><span>|</span><a href="#37277949">next</a><span>|</span><label class="collapse" for="c-37278292">[-]</label><label class="expand" for="c-37278292">[2 more]</label></div><br/><div class="children"><div class="content">Oh wow! This bootstrapping method reminds me of yet another Linux-on-an-8-bit-micro project (<a href="https:&#x2F;&#x2F;dmitry.gr&#x2F;?r=05.Projects&amp;proj=07.%20Linux%20on%208bit" rel="nofollow noreferrer">https:&#x2F;&#x2F;dmitry.gr&#x2F;?r=05.Projects&amp;proj=07.%20Linux%20on%208bi...</a>), which used an 8-bit AVR with an ARMv5 emulator. But, <i>this</i> takes the cake in terms of geek coolness.</div><br/><div id="37280073" class="c"><input type="checkbox" id="c-37280073" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37278292">parent</a><span>|</span><a href="#37277949">next</a><span>|</span><label class="collapse" for="c-37280073">[-]</label><label class="expand" for="c-37280073">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what it reminded me of too; there&#x27;s been plenty of HN discussion about it: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19762928">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19762928</a></div><br/></div></div></div></div><div id="37277949" class="c"><input type="checkbox" id="c-37277949" checked=""/><div class="controls bullet"><span class="by">mattl</span><span>|</span><a href="#37277908">parent</a><span>|</span><a href="#37278292">prev</a><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37277949">[-]</label><label class="expand" for="c-37277949">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be curious to see this running on real hardware. I hope someone&#x27;s able to make it work.</div><br/><div id="37277991" class="c"><input type="checkbox" id="c-37277991" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37277949">parent</a><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37277991">[-]</label><label class="expand" for="c-37277991">[8 more]</label></div><br/><div class="children"><div class="content">It <i>might</i> be more interesting than watching paint dry, just via risk that an old C64 will let the smoke out.</div><br/><div id="37279319" class="c"><input type="checkbox" id="c-37279319" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37277991">parent</a><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37279319">[-]</label><label class="expand" for="c-37279319">[7 more]</label></div><br/><div class="children"><div class="content">Why would it let smoke out? I doubt a C64 has any power management. So whether it idles or boots Linux via a couple of emulation layers, the thermal load will be exactly the same.</div><br/><div id="37279368" class="c"><input type="checkbox" id="c-37279368" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279319">parent</a><span>|</span><a href="#37279363">next</a><span>|</span><label class="collapse" for="c-37279368">[-]</label><label class="expand" for="c-37279368">[4 more]</label></div><br/><div class="children"><div class="content">I know there can be issues with thermal saturation on a heatsink design-- it was expected not just to generate N watts of heat, but to only do so for M hours.  Can you expect to leave a real 64 on for days or weeks and it will stay up?  I wonder if stores that had them as demo units when it was a relevant product, for example, power-cycled them regularly.<p>I know from experience if you block the bottom intake vents on a VIC 20, so it can&#x27;t convect properly, it will eventually start acting funky.<p>On a related note, I understand the 64&#x27;s original power bricks are considered timebombs, they might also not appreciate being left on for weeks at a time.</div><br/><div id="37280143" class="c"><input type="checkbox" id="c-37280143" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279368">parent</a><span>|</span><a href="#37280209">next</a><span>|</span><label class="collapse" for="c-37280143">[-]</label><label class="expand" for="c-37280143">[1 more]</label></div><br/><div class="children"><div class="content"><i>Can you expect to leave a real 64 on for days or weeks and it will stay up?</i><p>Yes. These early computers found their way into various embedded control applications too, and I suspect there&#x27;s quite a few C64s still in operation that way; they would&#x27;ve been replaced long ago if they weren&#x27;t stable. An article occasionally appears when someone discovers this:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12604414">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12604414</a></div><br/></div></div><div id="37280209" class="c"><input type="checkbox" id="c-37280209" checked=""/><div class="controls bullet"><span class="by">exitb</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279368">parent</a><span>|</span><a href="#37280143">prev</a><span>|</span><a href="#37279363">next</a><span>|</span><label class="collapse" for="c-37280209">[-]</label><label class="expand" for="c-37280209">[2 more]</label></div><br/><div class="children"><div class="content">I just saw a museum exhibition that featured a C64C, running all day, with a dust cover on, on what appeared to be the original PSU. I think it makes sense to be cautious about your own unit, but they’re probably not as vulnerable as people assume.</div><br/><div id="37280393" class="c"><input type="checkbox" id="c-37280393" checked=""/><div class="controls bullet"><span class="by">NoZebra120vClip</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37280209">parent</a><span>|</span><a href="#37279363">next</a><span>|</span><label class="collapse" for="c-37280393">[-]</label><label class="expand" for="c-37280393">[1 more]</label></div><br/><div class="children"><div class="content">Definitely the Achilles heel in any C64 setup. Perhaps new PSUs are visually distinct from the old ones, but practically everyone had to replace theirs as they aged.<p>Now the 64C was released in 1986, four years after the 64 and its faulty power supplies came out. I don&#x27;t know whether Commodore had decisively fixed the flawed PSUs by that time, but I know for sure that my second PSU lasted for the lifetime of that device too.</div><br/></div></div></div></div></div></div><div id="37279363" class="c"><input type="checkbox" id="c-37279363" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279319">parent</a><span>|</span><a href="#37279368">prev</a><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37279363">[-]</label><label class="expand" for="c-37279363">[2 more]</label></div><br/><div class="children"><div class="content">Just because it&#x27;s likely an old and long dormant piece of electronics, nothing to do with linux beyond it having to run the machine for multiple days 24x7.  My understanding is they don&#x27;t come out of deep dusty storage in ready for service condition.  Leaky caps.</div><br/><div id="37280537" class="c"><input type="checkbox" id="c-37280537" checked=""/><div class="controls bullet"><span class="by">einr</span><span>|</span><a href="#37277908">root</a><span>|</span><a href="#37279363">parent</a><span>|</span><a href="#37280274">next</a><span>|</span><label class="collapse" for="c-37280537">[-]</label><label class="expand" for="c-37280537">[1 more]</label></div><br/><div class="children"><div class="content">C64 caps are generally fine and do not need replacing. The most common things to spontaneously go bad of ”old age” on a 64 are probably RAM chips and the PLA, and of course the power supply is a time bomb.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37280274" class="c"><input type="checkbox" id="c-37280274" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#37277908">prev</a><span>|</span><a href="#37278989">next</a><span>|</span><label class="collapse" for="c-37280274">[-]</label><label class="expand" for="c-37280274">[2 more]</label></div><br/><div class="children"><div class="content">Very nice, but my first thought was &quot;surely this will not fit in 64k of ram!&quot;. And it doesn&#x27;t. It requires a 16MB REU!<p>To explain for the uninitiated how rare this bit of hardware is. The REU available for the c64 back in the day were 256kB and 512kB. These are most commonly built replicas as there are schematics available for them. Sometime in the late 90s there was also an &quot;expansion&quot; for c64 that contained a completely new CPU (superCPU - 65816) that was code compatible with the original and I believe this device could accommodate up to 16mb.<p>Later reimplementations based purely on fpga popped up including a REU with 16mb. The original SuperCPU schematic was lost to time. Allegedly fpga based expansions are available to buy for few hundred EUR now, but I don&#x27;t know anyone that attempted to buy one or has one.<p>So, although it is a neat trick(still a cool tech achievement) , saying it runs on c64 is akin to saying I got doom3 running on a 386, but my 386 is actually a pci card in a modern pc...<p>If I can&#x27;t pull my c64 with hardware available back in the day (or hardware one could realistically built back in the day) I&#x27;m not sure saying &quot;runs on c64&quot; is correct.<p>Coming back to the subject of a REU, why has no one published a schematic for one yet? There are cheap SRAM chips floating on ebay. It should be trivial to put one together. Unfortunately it isn&#x27;t, because the original (Super Cpu) had two components we need a beefy fpga to emulate. The supercpu itself and it&#x27;s dma controller which was a custom asic I believe.<p>Perhaps as cheap(ER) fpgas or uC with fpga-like functionality become available someone will create an open source &quot;super cpu&quot;. As of yet, everyone I ever heard using these, uses emulation. Nothing wrong with that, but I get the most out of my &quot;retro hobby&quot; by running original hardware. Emulation is very useful for dev, but for general use it&#x27;s a bit &quot;meh&quot; for me.</div><br/><div id="37280619" class="c"><input type="checkbox" id="c-37280619" checked=""/><div class="controls bullet"><span class="by">einr</span><span>|</span><a href="#37280274">parent</a><span>|</span><a href="#37278989">next</a><span>|</span><label class="collapse" for="c-37280619">[-]</label><label class="expand" for="c-37280619">[1 more]</label></div><br/><div class="children"><div class="content"><i>If I can&#x27;t pull my c64 with hardware available back in the day (or hardware one could realistically built back in the day) I&#x27;m not sure saying &quot;runs on c64&quot; is correct.</i><p>A 16MB REU could absolutely have been built in the 80s. It would have been absolutely astronomically expensive, but there’s no technical reason it  could not be done. You seem to be confusing the SuperCPU with a plain REU expansion — the REU is just a bunch of RAM and an ASIC that talks to the 64 and allows it to store or retrieve banks of RAM (because obviously a 6502 cannot address more than 64K so instead you have to tell it to swap out system RAM) — there is no CPU on it.<p>The SuperCPU (65816) can indeed address up to 16MB directly and that is a different thing. The project in the OP runs on a stock C64 on the stock C64 CPU, it just needs a mountain of RAM that would have cost the equivalent of a house back then ;)</div><br/></div></div></div></div><div id="37278989" class="c"><input type="checkbox" id="c-37278989" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#37280274">prev</a><span>|</span><a href="#37278420">next</a><span>|</span><label class="collapse" for="c-37278989">[-]</label><label class="expand" for="c-37278989">[1 more]</label></div><br/><div class="children"><div class="content">Not Linux related, but I&#x27;ve been trying trying recent (at least to me..) C-64 accessories:<p>I&#x27;ve tried the &quot;Kung Fu Flash&quot;- it&#x27;s a software defined cartridge that is cheap- just a single STM32 and can do pretty much everything.  I bought this because I&#x27;m trying to duplicate the developer experience I see on &quot;8-bit show and tell&quot;- it can emulate the &quot;super snapshot&quot;, but not the REU.  It&#x27;s a really nice way to quickly try a lot of C-64 software and games.<p><a href="https:&#x2F;&#x2F;8bithardware.wixsite.com&#x2F;website&#x2F;post&#x2F;kung-fu-flash" rel="nofollow noreferrer">https:&#x2F;&#x2F;8bithardware.wixsite.com&#x2F;website&#x2F;post&#x2F;kung-fu-flash</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;KimJorgensen&#x2F;KungFuFlash">https:&#x2F;&#x2F;github.com&#x2F;KimJorgensen&#x2F;KungFuFlash</a><p>I also have an SD2IEC: what I&#x27;ve learned is that it would have been useful to get a variant with an extra DIN socket.  It&#x27;s nice but I was never a fan of C-64&#x27;s DOS and this reinforces it.  To mount a D64 disk image you have to: OPEN1,8,15,&quot;CD:MYIMAGE.D64&quot;:CLOSE1... yuck..<p>JiffyDOS (replacement ROM for the C-64) improves this (it&#x27;s faster and includes a permanent DOS wedge), I bought one- it&#x27;s on the way.  I&#x27;m curious to try it with the real 1541 drive.<p>What got me started on this recently is the &quot;Penultimate +2&quot; cartridge for the VIC-20:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eNGyneXHKJQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eNGyneXHKJQ</a><p>In this case, I basically bought a VIC-20 just to try out the cartridge.</div><br/></div></div><div id="37278420" class="c"><input type="checkbox" id="c-37278420" checked=""/><div class="controls bullet"><span class="by">Decabytes</span><span>|</span><a href="#37278989">prev</a><span>|</span><a href="#37278349">next</a><span>|</span><label class="collapse" for="c-37278420">[-]</label><label class="expand" for="c-37278420">[12 more]</label></div><br/><div class="children"><div class="content">This begs the question. What is the oldest hardware that can boot modern Linux but still be used as a daily driver?</div><br/><div id="37278887" class="c"><input type="checkbox" id="c-37278887" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37279362">next</a><span>|</span><label class="collapse" for="c-37278887">[-]</label><label class="expand" for="c-37278887">[2 more]</label></div><br/><div class="children"><div class="content">The main &quot;daily driver&quot; constraint is probably the crypto required to access most modern websites. You can make the leanest and meanest system you can to run great on the slowest machine but the internet is nowadays an unforgiving place.</div><br/><div id="37280528" class="c"><input type="checkbox" id="c-37280528" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37278420">root</a><span>|</span><a href="#37278887">parent</a><span>|</span><a href="#37279362">next</a><span>|</span><label class="collapse" for="c-37280528">[-]</label><label class="expand" for="c-37280528">[1 more]</label></div><br/><div class="children"><div class="content">Surely video encoding &#x2F; decoding is more compute intensive than the crypto. Taking video calls is a reasonable part of being daily driver capable.</div><br/></div></div></div></div><div id="37279362" class="c"><input type="checkbox" id="c-37279362" checked=""/><div class="controls bullet"><span class="by">MrRadar</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37278887">prev</a><span>|</span><a href="#37279179">next</a><span>|</span><label class="collapse" for="c-37279362">[-]</label><label class="expand" for="c-37279362">[2 more]</label></div><br/><div class="children"><div class="content">Assuming &quot;daily driver&quot; requires a modern web browser running modern web productivity apps I&#x27;d put the minimum at a Core 2 Duo with 4 GB memory. It wouldn&#x27;t exactly be snappy but with a bit of patience you shouldn&#x27;t be limited by the hardware. Throw in a GPU with hardware video decoding and you might even be able to watch YouTube in above-potato quality.</div><br/><div id="37280062" class="c"><input type="checkbox" id="c-37280062" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37278420">root</a><span>|</span><a href="#37279362">parent</a><span>|</span><a href="#37279179">next</a><span>|</span><label class="collapse" for="c-37280062">[-]</label><label class="expand" for="c-37280062">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got a core 2 duo with 2GB RAM that I used for around 6 hours yesterday to write an application.<p>Only slightly noticeable waiting times when I accessed some sites, but it worked and the application works too.</div><br/></div></div></div></div><div id="37279179" class="c"><input type="checkbox" id="c-37279179" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37279362">prev</a><span>|</span><a href="#37279823">next</a><span>|</span><label class="collapse" for="c-37279179">[-]</label><label class="expand" for="c-37279179">[4 more]</label></div><br/><div class="children"><div class="content">For the sake of argument, let&#x27;s say a computer where you can install Debian 12 and run a WM and a browser, and it&#x27;s not excruciatingly slow.<p>I think you&#x27;d want to aim somewhere around the Pentium 4 &#x2F; Athlon XP era. The docs say it doesn&#x27;t support the original Pentium, so I suppose you could go back as far as the Pentium II if you really want to suffer.</div><br/><div id="37279668" class="c"><input type="checkbox" id="c-37279668" checked=""/><div class="controls bullet"><span class="by">karczex</span><span>|</span><a href="#37278420">root</a><span>|</span><a href="#37279179">parent</a><span>|</span><a href="#37279192">next</a><span>|</span><label class="collapse" for="c-37279668">[-]</label><label class="expand" for="c-37279668">[1 more]</label></div><br/><div class="children"><div class="content">3 years ago I tried to run any modern distro on Pentium 3 (without compiling anything by myself). It appeared I wasn&#x27;t able due to &quot;invalid opcode&quot; error inside systemd. I switched to Devuan (Debian fork without systemd) and it boot and was as usable as first raspberry pie.</div><br/></div></div><div id="37279192" class="c"><input type="checkbox" id="c-37279192" checked=""/><div class="controls bullet"><span class="by">mcmoor</span><span>|</span><a href="#37278420">root</a><span>|</span><a href="#37279179">parent</a><span>|</span><a href="#37279668">prev</a><span>|</span><a href="#37279823">next</a><span>|</span><label class="collapse" for="c-37279192">[-]</label><label class="expand" for="c-37279192">[2 more]</label></div><br/><div class="children"><div class="content">Damn and I still remember when Pentium 4 is the epitome of speed and I have to make do with Pentium 3 and even 2.</div><br/><div id="37279302" class="c"><input type="checkbox" id="c-37279302" checked=""/><div class="controls bullet"><span class="by">p1mrx</span><span>|</span><a href="#37278420">root</a><span>|</span><a href="#37279192">parent</a><span>|</span><a href="#37279823">next</a><span>|</span><label class="collapse" for="c-37279302">[-]</label><label class="expand" for="c-37279302">[1 more]</label></div><br/><div class="children"><div class="content">Pentium 4 was the epitome of heat. The Athlon XP was generally faster and cheaper during that era.</div><br/></div></div></div></div></div></div><div id="37279823" class="c"><input type="checkbox" id="c-37279823" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37279179">prev</a><span>|</span><a href="#37279620">next</a><span>|</span><label class="collapse" for="c-37279823">[-]</label><label class="expand" for="c-37279823">[1 more]</label></div><br/><div class="children"><div class="content">Definitely not modern Linux, when I got Slackware 2.0 in 1995&#x27;s Summer, I owned a Pentium 75Mhz, with 8MB RAM, Trident card capable of 1024x768 (X could only handle 800x600 on it), IDE CD-ROM and HDD.</div><br/></div></div><div id="37279620" class="c"><input type="checkbox" id="c-37279620" checked=""/><div class="controls bullet"><span class="by">sixothree</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37279823">prev</a><span>|</span><a href="#37278911">next</a><span>|</span><label class="collapse" for="c-37279620">[-]</label><label class="expand" for="c-37279620">[1 more]</label></div><br/><div class="children"><div class="content">Probably something with a core 2 duo. Though I’m sure a 230mhz cpu will “run” Linux with desktop just fine.</div><br/></div></div><div id="37278911" class="c"><input type="checkbox" id="c-37278911" checked=""/><div class="controls bullet"><span class="by">teawrecks</span><span>|</span><a href="#37278420">parent</a><span>|</span><a href="#37279620">prev</a><span>|</span><a href="#37278349">next</a><span>|</span><label class="collapse" for="c-37278911">[-]</label><label class="expand" for="c-37278911">[1 more]</label></div><br/><div class="children"><div class="content">The bar for &quot;daily driver&quot; is different for different people&#x27;s requirements. Would streaming Netflix be included? Running simple games?</div><br/></div></div></div></div><div id="37278349" class="c"><input type="checkbox" id="c-37278349" checked=""/><div class="controls bullet"><span class="by">wang_li</span><span>|</span><a href="#37278420">prev</a><span>|</span><a href="#37278191">next</a><span>|</span><label class="collapse" for="c-37278349">[-]</label><label class="expand" for="c-37278349">[4 more]</label></div><br/><div class="children"><div class="content">A demonstration of Turing equivalency. Any Turing complete computer can do what any other Turing complete computer can do if you don’t care about time.</div><br/><div id="37280440" class="c"><input type="checkbox" id="c-37280440" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#37278349">parent</a><span>|</span><a href="#37278596">next</a><span>|</span><label class="collapse" for="c-37280440">[-]</label><label class="expand" for="c-37280440">[1 more]</label></div><br/><div class="children"><div class="content">How do you run Linux in lambda calculus?</div><br/></div></div><div id="37278596" class="c"><input type="checkbox" id="c-37278596" checked=""/><div class="controls bullet"><span class="by">rhplus</span><span>|</span><a href="#37278349">parent</a><span>|</span><a href="#37280440">prev</a><span>|</span><a href="#37278191">next</a><span>|</span><label class="collapse" for="c-37278596">[-]</label><label class="expand" for="c-37278596">[2 more]</label></div><br/><div class="children"><div class="content">Time <i>and</i> memory.</div><br/><div id="37279004" class="c"><input type="checkbox" id="c-37279004" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#37278349">root</a><span>|</span><a href="#37278596">parent</a><span>|</span><a href="#37278191">next</a><span>|</span><label class="collapse" for="c-37279004">[-]</label><label class="expand" for="c-37279004">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, so technically a Turing machine has infinite memory.. so no real-world computer is fully Turing complete.</div><br/></div></div></div></div></div></div><div id="37278191" class="c"><input type="checkbox" id="c-37278191" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#37278349">prev</a><span>|</span><a href="#37279124">next</a><span>|</span><label class="collapse" for="c-37278191">[-]</label><label class="expand" for="c-37278191">[4 more]</label></div><br/><div class="children"><div class="content">Is this different from Lunix?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;LUnix" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;LUnix</a></div><br/><div id="37279137" class="c"><input type="checkbox" id="c-37279137" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#37278191">parent</a><span>|</span><a href="#37278225">next</a><span>|</span><label class="collapse" for="c-37279137">[-]</label><label class="expand" for="c-37279137">[1 more]</label></div><br/><div class="children"><div class="content">LUnix is an actual C64-native operating system that you can write apps for and run on C64 hardware directly. This is a RISC-V emulator running on C64 emulating a Linux boot up.</div><br/></div></div><div id="37278225" class="c"><input type="checkbox" id="c-37278225" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#37278191">parent</a><span>|</span><a href="#37279137">prev</a><span>|</span><a href="#37278232">next</a><span>|</span><label class="collapse" for="c-37278225">[-]</label><label class="expand" for="c-37278225">[1 more]</label></div><br/><div class="children"><div class="content">this is linux</div><br/></div></div></div></div><div id="37279124" class="c"><input type="checkbox" id="c-37279124" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#37278191">prev</a><span>|</span><a href="#37280099">next</a><span>|</span><label class="collapse" for="c-37279124">[-]</label><label class="expand" for="c-37279124">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t Linux running on C64 per se. This is C64 emulating a RISC-V environment on which Linux runs.<p>Still impressive of course, but semantics matter :)</div><br/><div id="37279136" class="c"><input type="checkbox" id="c-37279136" checked=""/><div class="controls bullet"><span class="by">gbraad</span><span>|</span><a href="#37279124">parent</a><span>|</span><a href="#37280099">next</a><span>|</span><label class="collapse" for="c-37279136">[-]</label><label class="expand" for="c-37279136">[1 more]</label></div><br/><div class="children"><div class="content">Semu-ntics to be precise ;-)</div><br/></div></div></div></div><div id="37280099" class="c"><input type="checkbox" id="c-37280099" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37279124">prev</a><span>|</span><a href="#37278780">next</a><span>|</span><label class="collapse" for="c-37280099">[-]</label><label class="expand" for="c-37280099">[1 more]</label></div><br/><div class="children"><div class="content">Now someone needs to do the same with a ZX spectrum ;-)<p>As others have mentioned, a 6502 is very poorly suited to C-style code, but a Z80 should be somewhat better with that.</div><br/></div></div><div id="37278780" class="c"><input type="checkbox" id="c-37278780" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#37280099">prev</a><span>|</span><a href="#37278141">next</a><span>|</span><label class="collapse" for="c-37278780">[-]</label><label class="expand" for="c-37278780">[2 more]</label></div><br/><div class="children"><div class="content">I recently came into possession of a fully-functioning TRS-80 Model 4, and I fantasize regularly about putting some vaguely Unix-esque thing on it. The fantasy continues.</div><br/><div id="37279059" class="c"><input type="checkbox" id="c-37279059" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37278780">parent</a><span>|</span><a href="#37278141">next</a><span>|</span><label class="collapse" for="c-37279059">[-]</label><label class="expand" for="c-37279059">[1 more]</label></div><br/><div class="children"><div class="content">You should be able to boost that up to 128k. Once there you have a solid chance of being able to run Fuzix on it.<p>Start there and you’ll find a rabbit hole of reasonable depth.</div><br/></div></div></div></div><div id="37278141" class="c"><input type="checkbox" id="c-37278141" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#37278780">prev</a><span>|</span><a href="#37279447">next</a><span>|</span><label class="collapse" for="c-37278141">[-]</label><label class="expand" for="c-37278141">[5 more]</label></div><br/><div class="children"><div class="content">Once you add more RAM to a Commodore 64, is it still a Commodore 64?</div><br/><div id="37278165" class="c"><input type="checkbox" id="c-37278165" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37278141">parent</a><span>|</span><a href="#37280119">next</a><span>|</span><label class="collapse" for="c-37278165">[-]</label><label class="expand" for="c-37278165">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if you use an REU, which is a correctly contemporary memory upgrade for the C64.</div><br/></div></div><div id="37280119" class="c"><input type="checkbox" id="c-37280119" checked=""/><div class="controls bullet"><span class="by">mdp2021</span><span>|</span><a href="#37278141">parent</a><span>|</span><a href="#37278165">prev</a><span>|</span><a href="#37278219">next</a><span>|</span><label class="collapse" for="c-37280119">[-]</label><label class="expand" for="c-37280119">[2 more]</label></div><br/><div class="children"><div class="content">Expanding from Johnwbyrd&#x27;s nearby:<p>-- Commodore sold a Ram Expansion Unit named &quot;1764&quot; to bring the C64 to 256kb of RAM;<p>-- it was possible to use the REU for the C128 named &quot;1750&quot; to bring the C64 to 512kb of RAM;<p>-- and it is possible to expand on that to have a 2MB REU for the C64 - see <a href="https:&#x2F;&#x2F;www.neperos.com&#x2F;article&#x2F;rlut8ce90fbb7701" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.neperos.com&#x2F;article&#x2F;rlut8ce90fbb7701</a><p>You can have two megabytes on the C64, pretty &quot;legally&quot;.</div><br/><div id="37280322" class="c"><input type="checkbox" id="c-37280322" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#37278141">root</a><span>|</span><a href="#37280119">parent</a><span>|</span><a href="#37278219">next</a><span>|</span><label class="collapse" for="c-37280322">[-]</label><label class="expand" for="c-37280322">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine &quot;someone&quot; back in the day could take PC SIMM modules and cobble together some monstrosity that would allow one to fill 16MB of RAM on a c64 using simple bank switching. However, the main &quot;innovation&quot; of these original and later REUs wasn&#x27;t the memory amount, but the chip that implemented DMA. That DMA chip could be used to copy ram contents very quickly with minimal CPU involvement. This is why c64 equipped with the REU has much better graphics capabilities (used for background animation etc).<p>As far as I know, we still don&#x27;t have an open source equivalent of that dma chip.</div><br/></div></div></div></div><div id="37278219" class="c"><input type="checkbox" id="c-37278219" checked=""/><div class="controls bullet"><span class="by">tpmx</span><span>|</span><a href="#37278141">parent</a><span>|</span><a href="#37280119">prev</a><span>|</span><a href="#37279447">next</a><span>|</span><label class="collapse" for="c-37278219">[-]</label><label class="expand" for="c-37278219">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s a Commodore 16384.<p>(The max addressable memory with a C64 REU is 16 Megabytes.)</div><br/></div></div></div></div><div id="37279447" class="c"><input type="checkbox" id="c-37279447" checked=""/><div class="controls bullet"><span class="by">vlasky</span><span>|</span><a href="#37278141">prev</a><span>|</span><a href="#37279456">next</a><span>|</span><label class="collapse" for="c-37279447">[-]</label><label class="expand" for="c-37279447">[1 more]</label></div><br/><div class="children"><div class="content">How long does a kernel recompile take?</div><br/></div></div><div id="37279456" class="c"><input type="checkbox" id="c-37279456" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#37279447">prev</a><span>|</span><a href="#37280326">next</a><span>|</span><label class="collapse" for="c-37279456">[-]</label><label class="expand" for="c-37279456">[1 more]</label></div><br/><div class="children"><div class="content">RISC-V is inevitable.</div><br/></div></div><div id="37280326" class="c"><input type="checkbox" id="c-37280326" checked=""/><div class="controls bullet"><span class="by">brazzy</span><span>|</span><a href="#37279456">prev</a><span>|</span><a href="#37279472">next</a><span>|</span><label class="collapse" for="c-37280326">[-]</label><label class="expand" for="c-37280326">[1 more]</label></div><br/><div class="children"><div class="content">That 16MiB memory requirement makes this rather disappointing, given that you can run Linux on machines with only 4 MiB of RAM: <a href="https:&#x2F;&#x2F;tldp.org&#x2F;HOWTO&#x2F;4mb-Laptops.html#toc3" rel="nofollow noreferrer">https:&#x2F;&#x2F;tldp.org&#x2F;HOWTO&#x2F;4mb-Laptops.html#toc3</a></div><br/></div></div><div id="37279472" class="c"><input type="checkbox" id="c-37279472" checked=""/><div class="controls bullet"><span class="by">doctor_radium</span><span>|</span><a href="#37280326">prev</a><span>|</span><a href="#37279910">next</a><span>|</span><label class="collapse" for="c-37279472">[-]</label><label class="expand" for="c-37279472">[1 more]</label></div><br/><div class="children"><div class="content">But will it impact the sales of GEOS?</div><br/></div></div><div id="37279910" class="c"><input type="checkbox" id="c-37279910" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#37279472">prev</a><span>|</span><a href="#37278451">next</a><span>|</span><label class="collapse" for="c-37279910">[-]</label><label class="expand" for="c-37279910">[1 more]</label></div><br/><div class="children"><div class="content">Minimal FORTHs (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)</a>) can run on an unexpanded VIC-20 (5K) or even early TRS-80 Model 1 (4K) -- with room and functionality to spare...<p>On the VIC-20, you even get a few colors!</div><br/></div></div><div id="37278451" class="c"><input type="checkbox" id="c-37278451" checked=""/><div class="controls bullet"><span class="by">erwincoumans</span><span>|</span><a href="#37279910">prev</a><span>|</span><a href="#37278489">next</a><span>|</span><label class="collapse" for="c-37278451">[-]</label><label class="expand" for="c-37278451">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the BogoMips?</div><br/><div id="37278810" class="c"><input type="checkbox" id="c-37278810" checked=""/><div class="controls bullet"><span class="by">johnwbyrd</span><span>|</span><a href="#37278451">parent</a><span>|</span><a href="#37278489">next</a><span>|</span><label class="collapse" for="c-37278810">[-]</label><label class="expand" for="c-37278810">[2 more]</label></div><br/><div class="children"><div class="content">The loading screen reports 130 BogoMIPS, but remember that it&#x27;s emulating the timer as well, so the number is meaningless.</div><br/><div id="37279583" class="c"><input type="checkbox" id="c-37279583" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#37278451">root</a><span>|</span><a href="#37278810">parent</a><span>|</span><a href="#37278489">next</a><span>|</span><label class="collapse" for="c-37279583">[-]</label><label class="expand" for="c-37279583">[1 more]</label></div><br/><div class="children"><div class="content">I assume that&#x27;s the &quot;warp speed&quot; BogoMIPS, on real hardware the number would be around 1.</div><br/></div></div></div></div></div></div><div id="37278489" class="c"><input type="checkbox" id="c-37278489" checked=""/><div class="controls bullet"><span class="by">sys_64738</span><span>|</span><a href="#37278451">prev</a><span>|</span><a href="#37277977">next</a><span>|</span><label class="collapse" for="c-37278489">[-]</label><label class="expand" for="c-37278489">[1 more]</label></div><br/><div class="children"><div class="content">Run Neofetch!</div><br/></div></div><div id="37277977" class="c"><input type="checkbox" id="c-37277977" checked=""/><div class="controls bullet"><span class="by">dusted</span><span>|</span><a href="#37278489">prev</a><span>|</span><label class="collapse" for="c-37277977">[-]</label><label class="expand" for="c-37277977">[7 more]</label></div><br/><div class="children"><div class="content">So, I like Linux and I love my C64, but.. Linux are for computers too primitive to come with their own kernel and.... the C64 comes with a kernel and shell right from the factory :P</div><br/><div id="37278108" class="c"><input type="checkbox" id="c-37278108" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#37277977">parent</a><span>|</span><a href="#37278020">next</a><span>|</span><label class="collapse" for="c-37278108">[-]</label><label class="expand" for="c-37278108">[4 more]</label></div><br/><div class="children"><div class="content">The Commodore 64 doesn&#x27;t come with a mere kernel, it comes with a mighty KERNAL<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;KERNAL" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;KERNAL</a><p>&gt; The KERNAL was known as kernel[6] inside of Commodore since the PET days, but in 1980 Robert Russell misspelled the word as kernal in his notebooks. When Commodore technical writers Neil Harris and Andy Finkel collected Russell&#x27;s notes and used them as the basis for the VIC-20 programmer&#x27;s manual, the misspelling followed them along and stuck.[7]<p>&gt; According to early Commodore myth, and reported by writer&#x2F;programmer Jim Butterfield among others, the &quot;word&quot; KERNAL is an acronym (or, more likely, a backronym) standing for Keyboard Entry Read, Network, And Link, which in fact makes good sense considering its role. Berkeley Softworks later used it when naming the core routines of its GUI OS for 8-bit home computers: the GEOS KERNAL.</div><br/><div id="37280046" class="c"><input type="checkbox" id="c-37280046" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#37277977">root</a><span>|</span><a href="#37278108">parent</a><span>|</span><a href="#37278723">next</a><span>|</span><label class="collapse" for="c-37280046">[-]</label><label class="expand" for="c-37280046">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Jim Butterfield<p>I had a 6502 machine language book of his as a kid. I figured out in my head what I thought I wanted to do with the various instructions, then wrote out on graph paper the (decimal) number for the op or it’s args, then transcribed the whole affair into memory manually via POKEs. Good times.</div><br/></div></div><div id="37278723" class="c"><input type="checkbox" id="c-37278723" checked=""/><div class="controls bullet"><span class="by">westmeal</span><span>|</span><a href="#37277977">root</a><span>|</span><a href="#37278108">parent</a><span>|</span><a href="#37280046">prev</a><span>|</span><a href="#37278020">next</a><span>|</span><label class="collapse" for="c-37278723">[-]</label><label class="expand" for="c-37278723">[2 more]</label></div><br/><div class="children"><div class="content">The mighty KERNAL is how us mere mortals can JSR FFD2. (I think that&#x27;s right)</div><br/><div id="37280079" class="c"><input type="checkbox" id="c-37280079" checked=""/><div class="controls bullet"><span class="by">mdp2021</span><span>|</span><a href="#37277977">root</a><span>|</span><a href="#37278723">parent</a><span>|</span><a href="#37278020">next</a><span>|</span><label class="collapse" for="c-37280079">[-]</label><label class="expand" for="c-37280079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>JSR [$]FFD2. (I think that&#x27;s right)</i><p>Yes, that is the &quot;print char in A and inc screen pos&quot; in the lookup table for the actual subroutine.</div><br/></div></div></div></div></div></div><div id="37278020" class="c"><input type="checkbox" id="c-37278020" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#37277977">parent</a><span>|</span><a href="#37278108">prev</a><span>|</span><a href="#37278002">next</a><span>|</span><label class="collapse" for="c-37278020">[-]</label><label class="expand" for="c-37278020">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but it’s fun :-)</div><br/></div></div></div></div></div></div></div></div></div></body></html>