<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698310857959" as="style"/><link rel="stylesheet" href="styles.css?v=1698310857959"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jsoverson.medium.com/was-rust-worth-it-f43d171fb1b3">Was Rust Worth It?</a> <span class="domain">(<a href="https://jsoverson.medium.com">jsoverson.medium.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>377 comments</span></div><br/><div><div id="38021059" class="c"><input type="checkbox" id="c-38021059" checked=""/><div class="controls bullet"><span class="by">kuon</span><span>|</span><a href="#38019532">next</a><span>|</span><label class="collapse" for="c-38021059">[-]</label><label class="expand" for="c-38021059">[69 more]</label></div><br/><div class="children"><div class="content">I wrote a lot of rust, but after some years it still feels unproductive. I do a lot of zig now and I am like 10 times more productive with it. I can just concentrate on what I want to code and I never have to wonder what tool or what library to use.<p>I know rust gives memory safety and how important that is, but the ergonomic is really bad. Every time I write some rust I feel limited. I always have to search libraries and how to do things. I cannot just &quot;type the code&quot;.<p>Also the type system can get out of control, it can be very hard to actually know what method you can call on a struct.<p>I still think rust is a great tool, and that it solves tons of problem. But I do not think it is a good general purpose language.</div><br/><div id="38021544" class="c"><input type="checkbox" id="c-38021544" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022460">next</a><span>|</span><label class="collapse" for="c-38021544">[-]</label><label class="expand" for="c-38021544">[28 more]</label></div><br/><div class="children"><div class="content">&gt; but the ergonomic is really bad. Every time I write some rust I feel limited.<p>&gt; But I do not think it is a good general purpose language.<p>Remember that this is not a sentiment that&#x27;s shared by everyone. I use Rust for tasks that need anything more complicated than a shell script. Even my window manager is controlled from a Rust program. I say this as someone who has been programming in Python for nearly two decades now. At this point, I&#x27;m about as fast in Rust as I am in Python.</div><br/><div id="38021782" class="c"><input type="checkbox" id="c-38021782" checked=""/><div class="controls bullet"><span class="by">lumost</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021544">parent</a><span>|</span><a href="#38023287">next</a><span>|</span><label class="collapse" for="c-38021782">[-]</label><label class="expand" for="c-38021782">[17 more]</label></div><br/><div class="children"><div class="content">I tried to get into rust for many years, I&#x27;m now in a C&#x2F;CPP job (after Java&#x2F;Python&#x2F;Ruby and other gigs). What I&#x27;ve come to understand is that Rust&#x27;s lifetime model is very difficult to work with whenever you have a cyclic reference. In C&#x2F;CPP the same holds, but you deal with it through clever coding - or ignoring the problem and cleaning up memory later. Java, and other GC&#x27;d languages just work for these structures.<p>While the Rust devs believe such cyclic references are rare - I think this speaks mostly to the problem domain they are focused on. Relational models are everywhere in Apps, they are often common in complex systems software like databases, and they are fairly rare in firmware&#x2F;drivers&#x2F;system code code.<p>There are a few patterns for dealing with cyclic references, but they all end up requiring either unsafe or a main &quot;owner&quot; object which you clean up occassionally (effectively arena allocation). Having now worked in C&#x2F;CPP - the idea of having unsafe blocks sprinkled around the code doesn&#x27;t bother me, and many C&#x2F;CPP components have some form of arena allocation built-in. I just wish Rust learning resources would be more upfront about this.</div><br/><div id="38022005" class="c"><input type="checkbox" id="c-38022005" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021782">parent</a><span>|</span><a href="#38021859">next</a><span>|</span><label class="collapse" for="c-38022005">[-]</label><label class="expand" for="c-38022005">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Relational models are everywhere in Apps, they are often common in complex systems software like databases, and they are fairly rare in firmware&#x2F;drivers&#x2F;system code code.<p>It&#x27;s not like that you can&#x27;t write relational models in the safe Rust. The only forbidden thing is a reference pointing arbitrary memory, which is typically worked around via indices and often more performant in that way. It is much rarer to find applications that need an absolutely random pointer that can&#x27;t be hidden in abstractions in my opinion.</div><br/></div></div><div id="38021859" class="c"><input type="checkbox" id="c-38021859" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021782">parent</a><span>|</span><a href="#38022005">prev</a><span>|</span><a href="#38022119">next</a><span>|</span><label class="collapse" for="c-38021859">[-]</label><label class="expand" for="c-38021859">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I just wish Rust learning resources would be more upfront about this.<p>While beginner resources don&#x27;t dwell too much upon cyclic references, they don&#x27;t consider unsafe blocks as unusual. All the material I&#x27;ve seen say that there are certain domains where Rust&#x27;s compile-time safety model simply won&#x27;t work. What Rust allows you to do instead, is to limit the scope of unsafe blocks. However, the beginner material often won&#x27;t give you too much details on how to analyze and decide on these compromises.<p>Anyway, compile-time safety checks (using borrow checker) and manual safety checks (using unsafe) aren&#x27;t the only way to deal with safety. Cyclic references can be dealt with runtime safety checks too - like Rc and Weak.</div><br/><div id="38022516" class="c"><input type="checkbox" id="c-38022516" checked=""/><div class="controls bullet"><span class="by">mtsr</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021859">parent</a><span>|</span><a href="#38022119">next</a><span>|</span><label class="collapse" for="c-38022516">[-]</label><label class="expand" for="c-38022516">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Cyclic references can be dealt with runtime safety checks too - like Rc and Weak.<p>Indeed. Starting out with code sprinkled with Rc, Weak, RefCell, etc is perfectly fine and performance will probably not be worse than in any other safe languages. And if you do this, Rust is pretty close to those languages in ease of use for what are otherwise complex topics in Rust.<p>A good reference for different approaches is Learn Rust With Entirely Too Many Linked Lists <a href="https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;</a></div><br/><div id="38022803" class="c"><input type="checkbox" id="c-38022803" checked=""/><div class="controls bullet"><span class="by">pncnmnp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022516">parent</a><span>|</span><a href="#38023248">next</a><span>|</span><label class="collapse" for="c-38022803">[-]</label><label class="expand" for="c-38022803">[1 more]</label></div><br/><div class="children"><div class="content">Also, take a look at GhostCell (<a href="https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;ghostcell&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;ghostcell&#x2F;</a> and <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=jIbubw86p0M">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=jIbubw86p0M</a>). If anyone&#x27;s used this in a project or production environment, I&#x27;d love to hear your firsthand experiences and insights.</div><br/></div></div><div id="38023248" class="c"><input type="checkbox" id="c-38023248" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022516">parent</a><span>|</span><a href="#38022803">prev</a><span>|</span><a href="#38022119">next</a><span>|</span><label class="collapse" for="c-38023248">[-]</label><label class="expand" for="c-38023248">[1 more]</label></div><br/><div class="children"><div class="content">Except in those other languages the compiler types .clone() for me.</div><br/></div></div></div></div></div></div><div id="38022119" class="c"><input type="checkbox" id="c-38022119" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021782">parent</a><span>|</span><a href="#38021859">prev</a><span>|</span><a href="#38023287">next</a><span>|</span><label class="collapse" for="c-38022119">[-]</label><label class="expand" for="c-38022119">[11 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a frequently encountered case for such cyclic loops?  Without details I&#x27;m drawn to trying to break the cycle, either by promoting the shared state to a container object for the set, or by breaking it out into it&#x27;s own object that multiple things can point at.</div><br/><div id="38022267" class="c"><input type="checkbox" id="c-38022267" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022119">parent</a><span>|</span><a href="#38022202">next</a><span>|</span><label class="collapse" for="c-38022267">[-]</label><label class="expand" for="c-38022267">[4 more]</label></div><br/><div class="children"><div class="content">a parent field.<p>a doubly linked list</div><br/><div id="38023257" class="c"><input type="checkbox" id="c-38023257" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022267">parent</a><span>|</span><a href="#38022945">next</a><span>|</span><label class="collapse" for="c-38023257">[-]</label><label class="expand" for="c-38023257">[1 more]</label></div><br/><div class="children"><div class="content">Your parent said &quot;frequently encountered&quot; and while it&#x27;s probably true that doubly linked lists may be &quot;frequently encountered&quot; in some people&#x27;s code they&#x27;re usually a bad idea and &quot;don&#x27;t use a list here&quot; is often the right fix, not &quot;conjure a way to make that safe in Rust&quot;.<p>It&#x27;s very noticeable how often people who &quot;need&quot; a linked list actually only wanted a queue (thus Rust&#x27;s VecDeque) or even a growable array (ie Vec).<p>Aria has a long list of excuses people offer for their linked lists, as well as her discussion of the time before Rust 1.0 when she sent lots of Rust&#x27;s standard library collections to that farm up-state but wasn&#x27;t able to send LinkedList.<p><a href="https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;</a></div><br/></div></div><div id="38022945" class="c"><input type="checkbox" id="c-38022945" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022267">parent</a><span>|</span><a href="#38023257">prev</a><span>|</span><a href="#38022202">next</a><span>|</span><label class="collapse" for="c-38022945">[-]</label><label class="expand" for="c-38022945">[2 more]</label></div><br/><div class="children"><div class="content">Doubly-linked list is something you have almost no reason to ever write.<p>Parent field is something where you have a clear hierarchy (it&#x27;s not really “cyclic”, so it&#x27;s the perfect use-case for weak references).<p>When coming from a managed-memory language, this obviously requires some conceptual effort to understand why this is a problem at all and how to deal with it, but when compared to C or C++, the situation is much better in Rust.</div><br/><div id="38023302" class="c"><input type="checkbox" id="c-38023302" checked=""/><div class="controls bullet"><span class="by">jacobgorm</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022945">parent</a><span>|</span><a href="#38022202">next</a><span>|</span><label class="collapse" for="c-38023302">[-]</label><label class="expand" for="c-38023302">[1 more]</label></div><br/><div class="children"><div class="content">Also, a parent field is something you should be able to infer, e.g, keep a stack of parents as you traverse down a search tree following the child pointers, instead of storing parent pointers in the tree nodes.</div><br/></div></div></div></div></div></div><div id="38022202" class="c"><input type="checkbox" id="c-38022202" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022119">parent</a><span>|</span><a href="#38022267">prev</a><span>|</span><a href="#38023287">next</a><span>|</span><label class="collapse" for="c-38022202">[-]</label><label class="expand" for="c-38022202">[6 more]</label></div><br/><div class="children"><div class="content">ASTs</div><br/><div id="38022747" class="c"><input type="checkbox" id="c-38022747" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022202">parent</a><span>|</span><a href="#38022275">next</a><span>|</span><label class="collapse" for="c-38022747">[-]</label><label class="expand" for="c-38022747">[2 more]</label></div><br/><div class="children"><div class="content">An abstract syntax <i>tree</i> can&#x27;t have cycles by definition.</div><br/><div id="38022925" class="c"><input type="checkbox" id="c-38022925" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022747">parent</a><span>|</span><a href="#38022275">next</a><span>|</span><label class="collapse" for="c-38022925">[-]</label><label class="expand" for="c-38022925">[1 more]</label></div><br/><div class="children"><div class="content">Technically true, but sometimes you want parent pointers. You then have a more general graph in the underlying representation, but it still represents a tree structure.</div><br/></div></div></div></div><div id="38022275" class="c"><input type="checkbox" id="c-38022275" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022202">parent</a><span>|</span><a href="#38022747">prev</a><span>|</span><a href="#38022459">next</a><span>|</span><label class="collapse" for="c-38022275">[-]</label><label class="expand" for="c-38022275">[1 more]</label></div><br/><div class="children"><div class="content">ASTs are one of &quot;nicely behaving&quot; data structures. It is like a archetype of abstract data types pervasive in functional programming languages.</div><br/></div></div><div id="38022459" class="c"><input type="checkbox" id="c-38022459" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022202">parent</a><span>|</span><a href="#38022275">prev</a><span>|</span><a href="#38023287">next</a><span>|</span><label class="collapse" for="c-38022459">[-]</label><label class="expand" for="c-38022459">[2 more]</label></div><br/><div class="children"><div class="content">An Abstract Syntax Tree &#x2F; or Double-Linked List both qualify, but they&#x27;re also a lower level implementation detail than I&#x27;d expect to frequently interact with in a reference safety focused language.<p>I&#x27;ve still been meaning to write something in &#x2F; learn Rust&#x27;s ways of thinking; is there not an intended replacement for these data structures?  Or do they expect it all to go under Unsafe?</div><br/><div id="38022999" class="c"><input type="checkbox" id="c-38022999" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022459">parent</a><span>|</span><a href="#38023287">next</a><span>|</span><label class="collapse" for="c-38022999">[-]</label><label class="expand" for="c-38022999">[1 more]</label></div><br/><div class="children"><div class="content">&gt; is there not an intended replacement for these data structures? Or do they expect it all to go under Unsafe?<p>For linked-lists, there&#x27;s one in std and the majority of people should never have to write their own as it&#x27;s error prone and requires unsafe.<p>For graph use-case then you can either use ECS, arena, ref counting or unsafe, but you&#x27;re probably better off using&#x2F;developing a dedicated crate that optimizes it and abstract it away behind an easy to use (and safe) interface.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38023287" class="c"><input type="checkbox" id="c-38023287" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021544">parent</a><span>|</span><a href="#38021782">prev</a><span>|</span><a href="#38022386">next</a><span>|</span><label class="collapse" for="c-38023287">[-]</label><label class="expand" for="c-38023287">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At this point, I&#x27;m about as fast in Rust as I am in Python.<p>This is factually impossible.<p>For anything larger than (very) small programs, Rust requires an upfront design stage, due to ownership, that it&#x27;s not required when developing in GC&#x27;ed languages.<p>This is not even considering more local complexities, like data structures with cyclical references.</div><br/></div></div><div id="38022386" class="c"><input type="checkbox" id="c-38022386" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021544">parent</a><span>|</span><a href="#38023287">prev</a><span>|</span><a href="#38022397">next</a><span>|</span><label class="collapse" for="c-38022386">[-]</label><label class="expand" for="c-38022386">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve finally set my mind to properly learning a new language after Python, Haskell, and typescript. I&#x27;m looking into Rust especially because of how I&#x27;ve heard it interoperates with Python (and also because it&#x27;s maybe being used in the Linux kernel? Is that correct?).</div><br/><div id="38022847" class="c"><input type="checkbox" id="c-38022847" checked=""/><div class="controls bullet"><span class="by">tinco</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022386">parent</a><span>|</span><a href="#38022405">next</a><span>|</span><label class="collapse" for="c-38022847">[-]</label><label class="expand" for="c-38022847">[2 more]</label></div><br/><div class="children"><div class="content">Rust is an excellent follow up to those languages. It&#x27;s got many influences from Haskell, but is designed to solve for a very different task that&#x27;s not yet in your repertoire so you&#x27;ll learn a ton.<p>And yes the Python interop is excellent.</div><br/><div id="38023299" class="c"><input type="checkbox" id="c-38023299" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022847">parent</a><span>|</span><a href="#38022405">next</a><span>|</span><label class="collapse" for="c-38023299">[-]</label><label class="expand" for="c-38023299">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sold, thank you. Yes, it felt like a great &quot;missing quadrant&quot; to my generalist skillset.</div><br/></div></div></div></div><div id="38022405" class="c"><input type="checkbox" id="c-38022405" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022386">parent</a><span>|</span><a href="#38022847">prev</a><span>|</span><a href="#38022397">next</a><span>|</span><label class="collapse" for="c-38022405">[-]</label><label class="expand" for="c-38022405">[3 more]</label></div><br/><div class="children"><div class="content">Linux kernel has support for rust userland drivers, and rust interops with python with pyo3.</div><br/><div id="38022734" class="c"><input type="checkbox" id="c-38022734" checked=""/><div class="controls bullet"><span class="by">maccam94</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022405">parent</a><span>|</span><a href="#38022397">next</a><span>|</span><label class="collapse" for="c-38022734">[-]</label><label class="expand" for="c-38022734">[2 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean by &quot;userland&quot; drivers here, but support for kernel modules written in rust is actively being developed. It&#x27;s already being used for kernel drivers like the Asahi Linux GPU driver for M1 Macs.</div><br/><div id="38022807" class="c"><input type="checkbox" id="c-38022807" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022734">parent</a><span>|</span><a href="#38022397">next</a><span>|</span><label class="collapse" for="c-38022807">[-]</label><label class="expand" for="c-38022807">[1 more]</label></div><br/><div class="children"><div class="content">I am referring to userspace &#x2F; userland drivers.<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;v4.18&#x2F;driver-api&#x2F;uio-howto.html#writing-a-driver-in-userspace" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;v4.18&#x2F;driver-api&#x2F;uio-howto.h...</a></div><br/></div></div></div></div></div></div></div></div><div id="38022397" class="c"><input type="checkbox" id="c-38022397" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021544">parent</a><span>|</span><a href="#38022386">prev</a><span>|</span><a href="#38022460">next</a><span>|</span><label class="collapse" for="c-38022397">[-]</label><label class="expand" for="c-38022397">[3 more]</label></div><br/><div class="children"><div class="content">Surprisingly, I am faster in Rust than any other language. Something about my prior experiences just made it click just the right way.<p>I don&#x27;t want to program in anything else anymore. I don&#x27;t want to deal with obscure C++ error messages, C footguns and lack of ergonomics, I don&#x27;t want to deal with abstraction hell of Java, or the poor person&#x27;s typing that python has.<p>I have been programming in Python for the past 6 years, I know all sorts of obscure details, and with rust, I just don&#x27;t need to think about all of those issues.</div><br/><div id="38023065" class="c"><input type="checkbox" id="c-38023065" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022397">parent</a><span>|</span><a href="#38022460">next</a><span>|</span><label class="collapse" for="c-38023065">[-]</label><label class="expand" for="c-38023065">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Surprisingly, I am faster in Rust than any other language.<p>Not really surprising, given that you have C and C++ background. That&#x27;s what I was trying to highlight. <i>Rust isn&#x27;t a confusing or unproductive language</i> as many project it to be - if you have the conceptual understanding of what happens on the hardware. Especially about stack frames and RAII. If you know those, the borrow checker complaints will immediately make sense and you will know how to resolve them.<p>Add rust-analyzer (Rust&#x27;s language server) to it, you get real-time type annotations and a way to match types correctly in the first attempt. In my experience Rust also helps structure your program correctly and saves a ton of time in debugging. All in all, Rust is a fast way to write correct programs.</div><br/><div id="38023157" class="c"><input type="checkbox" id="c-38023157" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023065">parent</a><span>|</span><a href="#38022460">next</a><span>|</span><label class="collapse" for="c-38023157">[-]</label><label class="expand" for="c-38023157">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add that if you have some understanding of how memory ownership should be such that you don&#x27;t end up with memory leaks, you are fine. The borrow checker just verifies that your mental model is correct, and removes some of the cognitive load from you.</div><br/></div></div></div></div></div></div></div></div><div id="38022460" class="c"><input type="checkbox" id="c-38022460" checked=""/><div class="controls bullet"><span class="by">ostenning</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38021544">prev</a><span>|</span><a href="#38022171">next</a><span>|</span><label class="collapse" for="c-38022460">[-]</label><label class="expand" for="c-38022460">[1 more]</label></div><br/><div class="children"><div class="content">Opposite experience for me. Writing Rust on embedded systems greatly improved my confidence and speed. When using C a small mistake often leads to undefined behaviour and headaches. Rust theres none of that - its been a game changer for me.</div><br/></div></div><div id="38022171" class="c"><input type="checkbox" id="c-38022171" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022460">prev</a><span>|</span><a href="#38022229">next</a><span>|</span><label class="collapse" for="c-38022171">[-]</label><label class="expand" for="c-38022171">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this general feeling, and it is hard to articulate<p>Rust forces you to figure out ahead of time where each bit or byte is going to go and on which thread and using which mutation scheme. I’m happy to play the game, but it feels tedious for anything short of a parser or a microcontroller.<p>It messes with my process because I like to get something working before I determine the best API structure for it<p>I can get 90% of the performance with Swift and it flows much more easily, even though Rust’s type system is more powerful.</div><br/></div></div><div id="38022229" class="c"><input type="checkbox" id="c-38022229" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022171">prev</a><span>|</span><a href="#38021614">next</a><span>|</span><label class="collapse" for="c-38022229">[-]</label><label class="expand" for="c-38022229">[8 more]</label></div><br/><div class="children"><div class="content">Wait, I am a bit confused.  Does Zig have more&#x2F;better libraries than Rust? I thought it&#x27;s a pretty new language. The most limiting thing for me with Rust was the lack of libraries (vs. say Python or Node&#x2F;JavaScript).</div><br/><div id="38022534" class="c"><input type="checkbox" id="c-38022534" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022229">parent</a><span>|</span><a href="#38022759">prev</a><span>|</span><a href="#38022699">next</a><span>|</span><label class="collapse" for="c-38022534">[-]</label><label class="expand" for="c-38022534">[5 more]</label></div><br/><div class="children"><div class="content">It interops seamlessly with C libraries.</div><br/><div id="38022602" class="c"><input type="checkbox" id="c-38022602" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022534">parent</a><span>|</span><a href="#38022699">next</a><span>|</span><label class="collapse" for="c-38022602">[-]</label><label class="expand" for="c-38022602">[4 more]</label></div><br/><div class="children"><div class="content">Depending on what seamlessly means, Rust can also interop with C libraries. I wrapped a bunch of them.</div><br/><div id="38022843" class="c"><input type="checkbox" id="c-38022843" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022602">parent</a><span>|</span><a href="#38022724">next</a><span>|</span><label class="collapse" for="c-38022843">[-]</label><label class="expand" for="c-38022843">[2 more]</label></div><br/><div class="children"><div class="content">Truly seamless because the zig compiler is also a C compiler, so the type information and calling convention works across languages at a level above any other I&#x27;ve encountered.</div><br/><div id="38023070" class="c"><input type="checkbox" id="c-38023070" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022843">parent</a><span>|</span><a href="#38022724">next</a><span>|</span><label class="collapse" for="c-38023070">[-]</label><label class="expand" for="c-38023070">[1 more]</label></div><br/><div class="children"><div class="content">True, but I think that the person you&#x27;re responding argued that rust&#x2F;C integration is also seamless. (In the general discussion I&#x27;d say they&#x27;re right as C to Rust integration isn&#x27;t much of an problem and you can use C libraries relatively easily in Rust as well, but at the same time when talking about Zig I don&#x27;t think it&#x27;s fair to put it on the same ground).</div><br/></div></div></div></div><div id="38022724" class="c"><input type="checkbox" id="c-38022724" checked=""/><div class="controls bullet"><span class="by">hailruda</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022602">parent</a><span>|</span><a href="#38022843">prev</a><span>|</span><a href="#38022699">next</a><span>|</span><label class="collapse" for="c-38022724">[-]</label><label class="expand" for="c-38022724">[1 more]</label></div><br/><div class="children"><div class="content">Seamlessly as in @cInclude(&quot;raylib.h&quot;)</div><br/></div></div></div></div></div></div><div id="38022699" class="c"><input type="checkbox" id="c-38022699" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022229">parent</a><span>|</span><a href="#38022534">prev</a><span>|</span><a href="#38021614">next</a><span>|</span><label class="collapse" for="c-38022699">[-]</label><label class="expand" for="c-38022699">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t. The ecosystem is very immature and even the official tooling is very unstable. It has a bunch of interesting design ideas but at this point it&#x27;s more of an experimental language than a production ready one by most metrics. (And unless it finds some kind of corporate backing, this is unlikely to ever change).</div><br/></div></div></div></div><div id="38021614" class="c"><input type="checkbox" id="c-38021614" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022229">prev</a><span>|</span><a href="#38022217">next</a><span>|</span><label class="collapse" for="c-38021614">[-]</label><label class="expand" for="c-38021614">[2 more]</label></div><br/><div class="children"><div class="content">I am curious what kind of code you are writing? Is it very low level or very high?<p>&gt;I know rust gives memory safety and how important that is, but the ergonomic is really bad. Every time I write some rust I feel limited. I always have to search libraries and how to do things. I cannot just &quot;type the code&quot;.<p>You don&#x27;t have to search libraries and figure out how to do things in Zig?</div><br/><div id="38021958" class="c"><input type="checkbox" id="c-38021958" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021614">parent</a><span>|</span><a href="#38022217">next</a><span>|</span><label class="collapse" for="c-38021958">[-]</label><label class="expand" for="c-38021958">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to describe, but in some languages, you spend a lot less time looking at reference docs and more time just naturally writing the solution. Lisp is a great example of that, if you get through the learning curve.</div><br/></div></div></div></div><div id="38022217" class="c"><input type="checkbox" id="c-38022217" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38021614">prev</a><span>|</span><a href="#38023189">next</a><span>|</span><label class="collapse" for="c-38022217">[-]</label><label class="expand" for="c-38022217">[18 more]</label></div><br/><div class="children"><div class="content">I rather use compiled managed languages like Swift, D and C# instead, they provide enough low level coding knobs for C and C++ style coding, while being high level productive.<p>Would add Go to the list, but only when I really have to.<p>Nim and Crystal could be alternatives, but don&#x27;t seem to have big enough communities, at least for what I do.<p>However I do agree with the conclusion, Rust is a great language for scenarios where no form of automatic memory management is allowed, kernels, specific kinds of drivers, GPGPU programming, as general purpose, there are more productive alternatives, equally safe.</div><br/><div id="38022374" class="c"><input type="checkbox" id="c-38022374" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022217">parent</a><span>|</span><a href="#38023189">next</a><span>|</span><label class="collapse" for="c-38022374">[-]</label><label class="expand" for="c-38022374">[17 more]</label></div><br/><div class="children"><div class="content">C# is underrated by the HN crowd, I find. I quite like how mid sized firms (100-1000 employees) use it.</div><br/><div id="38022498" class="c"><input type="checkbox" id="c-38022498" checked=""/><div class="controls bullet"><span class="by">tkubacki</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022374">parent</a><span>|</span><a href="#38023105">next</a><span>|</span><label class="collapse" for="c-38022498">[-]</label><label class="expand" for="c-38022498">[5 more]</label></div><br/><div class="children"><div class="content">I used to be .NET dev and don&#x27;t agree. Couple of reaons:<p>1) Modern Java is almost as good as C# with some things I can&#x27;t give up in Java (static imports =&gt; succint code, Groovy Spock =&gt; succint tests)<p>2) Kotlin is better than C#<p>3) JVM has <i>much much</i> bigger ecosystem (almost all the apache projects are JVM oriented) and default web framework is much less code to type (SpringBoot) is much more productiv<p>4) JVM has wider variety of langs<p>For those reasons IMHO if you are small-mid company (or startup) it&#x27;s wiser to choose JVM.</div><br/><div id="38023335" class="c"><input type="checkbox" id="c-38023335" checked=""/><div class="controls bullet"><span class="by">mpawelski</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022498">parent</a><span>|</span><a href="#38022764">next</a><span>|</span><label class="collapse" for="c-38023335">[-]</label><label class="expand" for="c-38023335">[1 more]</label></div><br/><div class="children"><div class="content">Java is surely keeping up but I can&#x27;t name single Java feature that I miss in C# or is implemented better in Java. I haven&#x27;t used Java in a long time though, just occasionally I read about new Java features and I&#x27;ve never said to myself &quot;cool, I wish I had it in C#&quot;.<p>Static import are also available in C# for quite some time now (c# 6, released in 2015, and in C# 10 you can even make this import global for for project).<p>I haven&#x27;t used Kotlin, is there any killer feature compared to C#? (except more succinct code in certain cases?)</div><br/></div></div><div id="38022764" class="c"><input type="checkbox" id="c-38022764" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022498">parent</a><span>|</span><a href="#38023335">prev</a><span>|</span><a href="#38023105">next</a><span>|</span><label class="collapse" for="c-38022764">[-]</label><label class="expand" for="c-38022764">[3 more]</label></div><br/><div class="children"><div class="content">Kind of, maybe you need to do some low level coding and don&#x27;t want to wait for Valhala, or make use of JNI and native libraries, GraalVM&#x2F;OpenJ9 still aren&#x27;t as integrated as .NET Native or Native AOT, e.g. writing native shared libraries.<p>Also Java lost the attention span of the gaming industry, besides Android casual games and Minecraft, there are hardly anyone else paying attention to it.</div><br/><div id="38023114" class="c"><input type="checkbox" id="c-38023114" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022764">parent</a><span>|</span><a href="#38023105">next</a><span>|</span><label class="collapse" for="c-38023114">[-]</label><label class="expand" for="c-38023114">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, C# is ok for game dev, but not great. C# libraries are lagging heavily behind Java.<p>Want a fastest possible library? It&#x27;s in C++, and not portable to Win&#x2F;Mac. So good luck with wrap + porting it.<p>Want a decent implementation of an algo? It usually exists for Java but not for C#. Hope you like writing it from scratch.<p>Want a C# implementation of an algo that doesn&#x27;t allocate to the Nth degree. Again, write it yourself.<p>But ok, maybe Unity has a good ecosystem... And they fucked it over a barrel.</div><br/><div id="38023221" class="c"><input type="checkbox" id="c-38023221" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023114">parent</a><span>|</span><a href="#38023105">next</a><span>|</span><label class="collapse" for="c-38023221">[-]</label><label class="expand" for="c-38023221">[1 more]</label></div><br/><div class="children"><div class="content">It is widely better recieved in the AAA gaming developer community than Java, and that is what matters.<p>I also like Java, but c&#x27;mon no decent algorithms being implemented in C#? That is already approaching zealotry.</div><br/></div></div></div></div></div></div></div></div><div id="38023105" class="c"><input type="checkbox" id="c-38023105" checked=""/><div class="controls bullet"><span class="by">leeman2016</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022374">parent</a><span>|</span><a href="#38022498">prev</a><span>|</span><a href="#38022415">next</a><span>|</span><label class="collapse" for="c-38023105">[-]</label><label class="expand" for="c-38023105">[4 more]</label></div><br/><div class="children"><div class="content">C# is a lovely language to work with.<p>The only issue I have is with the .NET ... that is, building self-contained binaries to distribute.<p>For comparison:<p>* Hello World win-x64 binary self-contained in .NET 7 is around 70 MB<p>* The same for Go results in 1.2 MB</div><br/><div id="38023122" class="c"><input type="checkbox" id="c-38023122" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023105">parent</a><span>|</span><a href="#38022415">next</a><span>|</span><label class="collapse" for="c-38023122">[-]</label><label class="expand" for="c-38023122">[3 more]</label></div><br/><div class="children"><div class="content">Usually that means you aren&#x27;t using trimming, .NET speak for dead code removal during linking.<p>Also remember that standard .NET runtime does a little bit more than Go&#x27;s runtime, so it might happen that even with trimming, for basic applications Go ends up having an upper hand on file size.<p>On the other hand, I have had Go static binaries grow up to 200 MB and being require to use UPX to make it manageable, e.g. trivy.</div><br/><div id="38023145" class="c"><input type="checkbox" id="c-38023145" checked=""/><div class="controls bullet"><span class="by">leeman2016</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023122">parent</a><span>|</span><a href="#38022415">next</a><span>|</span><label class="collapse" for="c-38023145">[-]</label><label class="expand" for="c-38023145">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. But even with trimming I get around 10x the size of the Go binary</div><br/><div id="38023175" class="c"><input type="checkbox" id="c-38023175" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023145">parent</a><span>|</span><a href="#38022415">next</a><span>|</span><label class="collapse" for="c-38023175">[-]</label><label class="expand" for="c-38023175">[1 more]</label></div><br/><div class="children"><div class="content">Since I edited my comment, see my additional remarks regarding runtime capabilities, and the counterpoint of big Go binaries.<p>Also note that triming only works properly if the libraries have taken the effort to be trimmable, as the linker errs on the safe side and won&#x27;t trim unless certain that it is really dead code, and not called via reflection.</div><br/></div></div></div></div></div></div></div></div><div id="38022415" class="c"><input type="checkbox" id="c-38022415" checked=""/><div class="controls bullet"><span class="by">eddtries</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022374">parent</a><span>|</span><a href="#38023105">prev</a><span>|</span><a href="#38022692">next</a><span>|</span><label class="collapse" for="c-38022415">[-]</label><label class="expand" for="c-38022415">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found those sort of firms with C#, in my experience, have the best architected code. Proper domain-driven design, onion architectures, clean testable code... Some have legacy issues where they might not have the most cutting edge CI&#x2F;CD pipeline or high automated test coverage, but the code itself can be very nice. I&#x27;ve never really experienced that level of consistency with a different language&#x2F;company size.</div><br/></div></div><div id="38022692" class="c"><input type="checkbox" id="c-38022692" checked=""/><div class="controls bullet"><span class="by">hutattedonmyarm</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022374">parent</a><span>|</span><a href="#38022415">prev</a><span>|</span><a href="#38023158">next</a><span>|</span><label class="collapse" for="c-38022692">[-]</label><label class="expand" for="c-38022692">[4 more]</label></div><br/><div class="children"><div class="content">Is it? Every time I see C# being mentioned here people agree how awesome it is. Not that I&#x27;m complaining, I love C#</div><br/><div id="38022979" class="c"><input type="checkbox" id="c-38022979" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022692">parent</a><span>|</span><a href="#38023222">next</a><span>|</span><label class="collapse" for="c-38022979">[-]</label><label class="expand" for="c-38022979">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. I feel C# is appropriately rated on HN and other programming forums. It has perfomant memory options that other GC languages lack, and great builtin packages to use. Overall, it is a good language.<p>My biggest issue with C# though is how badly exceptions are handled given that it is a statically typed langauge. I wish functions explicitly defined the exceptions it can throw since a minor package bump could add an exception without your compiler warning you that it isn&#x27;t handled. I much prefer Rust, Go and Zig&#x27;s error handling to C#&#x27;s since those kind of issues don&#x27;t happen.</div><br/><div id="38023232" class="c"><input type="checkbox" id="c-38023232" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022979">parent</a><span>|</span><a href="#38023222">next</a><span>|</span><label class="collapse" for="c-38023232">[-]</label><label class="expand" for="c-38023232">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It has perfomant memory options that other GC languages lack, and great builtin packages to use.<p>As clarification for the audience, it isn&#x27;t the only GC enabled language with C and C++ like capabilities, in fact there are several examples since the early 1980&#x27;s.<p>The adoption push for Java and scripting languages distorced the understanding of what was already available out there.</div><br/></div></div></div></div><div id="38023222" class="c"><input type="checkbox" id="c-38023222" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022692">parent</a><span>|</span><a href="#38022979">prev</a><span>|</span><a href="#38023158">next</a><span>|</span><label class="collapse" for="c-38023222">[-]</label><label class="expand" for="c-38023222">[1 more]</label></div><br/><div class="children"><div class="content">Well, I see it as lack of fanboyism which is interesting and almost unique to the Java&#x2F;C# ecosystem. A lot C# experts(and I mean REAL, low level experts) seem to also have very high Java expertise..<p>And those that have Java expertise but not C# seem to demur to those that do; image!<p>But it&#x27;s still niche(around here and in the startup world) and gets lumped in with Java and together they are not &quot;hip&quot; or &quot;agile&quot; or whatever.</div><br/></div></div></div></div><div id="38023158" class="c"><input type="checkbox" id="c-38023158" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022374">parent</a><span>|</span><a href="#38022692">prev</a><span>|</span><a href="#38023189">next</a><span>|</span><label class="collapse" for="c-38023158">[-]</label><label class="expand" for="c-38023158">[2 more]</label></div><br/><div class="children"><div class="content">C# is fine, but it feels like a slightly better Java, just without the huge ecosystem of libraries.</div><br/><div id="38023196" class="c"><input type="checkbox" id="c-38023196" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38023158">parent</a><span>|</span><a href="#38023189">next</a><span>|</span><label class="collapse" for="c-38023196">[-]</label><label class="expand" for="c-38023196">[1 more]</label></div><br/><div class="children"><div class="content">Slightly... The difference in type erasure is pretty huge IMHO.<p>But what libraries are you lacking?</div><br/></div></div></div></div></div></div></div></div><div id="38023189" class="c"><input type="checkbox" id="c-38023189" checked=""/><div class="controls bullet"><span class="by">nlnn</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022217">prev</a><span>|</span><a href="#38021551">next</a><span>|</span><label class="collapse" for="c-38023189">[-]</label><label class="expand" for="c-38023189">[1 more]</label></div><br/><div class="children"><div class="content">I use Rust a lot, and have been really keen on getting into Zig.<p>Not sure if much has changed (it was a while back), but my biggest problem was with finding and using 3rd party libraries (mostly for the boring stuff like DB connectivity, JSON&#x2F;YAML parsing, logging, etc.).<p>E.g. even now if I search for &quot;zig mysql library&quot;, the tops hits are all about people discussing it on reddit, than any actual library.</div><br/></div></div><div id="38021551" class="c"><input type="checkbox" id="c-38021551" checked=""/><div class="controls bullet"><span class="by">push-f</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38023189">prev</a><span>|</span><a href="#38022152">next</a><span>|</span><label class="collapse" for="c-38021551">[-]</label><label class="expand" for="c-38021551">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it can be very hard to actually know what method you can call on a struct<p>The rust-analyzer language server can autocomplete the available methods for a value.</div><br/><div id="38021690" class="c"><input type="checkbox" id="c-38021690" checked=""/><div class="controls bullet"><span class="by">n3storm</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021551">parent</a><span>|</span><a href="#38022152">next</a><span>|</span><label class="collapse" for="c-38021690">[-]</label><label class="expand" for="c-38021690">[2 more]</label></div><br/><div class="children"><div class="content">depending on the autocompleter feels like asking to code to Chatgpt to me.</div><br/><div id="38021700" class="c"><input type="checkbox" id="c-38021700" checked=""/><div class="controls bullet"><span class="by">push-f</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38021690">parent</a><span>|</span><a href="#38022152">next</a><span>|</span><label class="collapse" for="c-38021700">[-]</label><label class="expand" for="c-38021700">[1 more]</label></div><br/><div class="children"><div class="content">I disagree, there&#x27;s a big difference: rust-analyzer is deterministic and 100% accurate while ChatGPT is non-deterministic and hallucinates.</div><br/></div></div></div></div></div></div><div id="38022152" class="c"><input type="checkbox" id="c-38022152" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38021551">prev</a><span>|</span><a href="#38022677">next</a><span>|</span><label class="collapse" for="c-38022152">[-]</label><label class="expand" for="c-38022152">[1 more]</label></div><br/><div class="children"><div class="content">Since you have previously said that you are using Zig to do embedded programming for medical devices, I assume that it is your main pain point. I largely agree that the current Rust embedded story is not exactly for existing embedded programmers (and I guess you are one of them). Rather it looks more like a solution for existing <i>application</i> programmers. I don&#x27;t think it&#x27;s an intrinsic limitation of Rust the programming language, rather a specific community at this point happens to prefer this way. Still it is a weakness in some sense and Zig will be a good alternative.</div><br/></div></div><div id="38022677" class="c"><input type="checkbox" id="c-38022677" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022152">prev</a><span>|</span><a href="#38021476">next</a><span>|</span><label class="collapse" for="c-38022677">[-]</label><label class="expand" for="c-38022677">[1 more]</label></div><br/><div class="children"><div class="content">It somehow seems that Zig has most of the qualities that people like about C: clear, crisp, no huge Stdlib, good old straightforward imperative semantics, and readonably fast. But without lots of the cruft.</div><br/></div></div><div id="38021476" class="c"><input type="checkbox" id="c-38021476" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38022677">prev</a><span>|</span><a href="#38021826">next</a><span>|</span><label class="collapse" for="c-38021476">[-]</label><label class="expand" for="c-38021476">[1 more]</label></div><br/><div class="children"><div class="content">nim could be another option which defaults to c backend with python syntax</div><br/></div></div><div id="38021826" class="c"><input type="checkbox" id="c-38021826" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38021476">prev</a><span>|</span><a href="#38022890">next</a><span>|</span><label class="collapse" for="c-38021826">[-]</label><label class="expand" for="c-38021826">[1 more]</label></div><br/><div class="children"><div class="content">You should try diving into num for like a month and see how you like it. It&#x27;s different enough that you need to go past a certain kind of ledge to start liking it. Or at least that was my experience.<p>For me, it shares the most important benefits of Rust but with quite a lot more ergonomic coding model.</div><br/></div></div><div id="38022890" class="c"><input type="checkbox" id="c-38022890" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#38021059">parent</a><span>|</span><a href="#38021826">prev</a><span>|</span><a href="#38019532">next</a><span>|</span><label class="collapse" for="c-38022890">[-]</label><label class="expand" for="c-38022890">[2 more]</label></div><br/><div class="children"><div class="content">Given that Zig is memory unsafe it isn&#x27;t either a good general purpose language.<p>IMO a good GPR is memory safe (no C, C++, Zig), is easy to use(no Rust), has strong static typing (no Perl, Python, Ruby) and is &quot;stable&quot; (no Scala). Lots of choices remain: Java, Kotlin, Ada, D, OCaml..</div><br/><div id="38022942" class="c"><input type="checkbox" id="c-38022942" checked=""/><div class="controls bullet"><span class="by">AbuAssar</span><span>|</span><a href="#38021059">root</a><span>|</span><a href="#38022890">parent</a><span>|</span><a href="#38019532">next</a><span>|</span><label class="collapse" for="c-38022942">[-]</label><label class="expand" for="c-38022942">[1 more]</label></div><br/><div class="children"><div class="content">c#</div><br/></div></div></div></div></div></div><div id="38019532" class="c"><input type="checkbox" id="c-38019532" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#38021059">prev</a><span>|</span><a href="#38023003">next</a><span>|</span><label class="collapse" for="c-38019532">[-]</label><label class="expand" for="c-38019532">[120 more]</label></div><br/><div class="children"><div class="content">Perhaps my biggest critique is that crates.io has no namespacing. Anyone can just claim a global and generic package name and we mostly have to deal with it (unless you avoid using the crates.io repository, but then you&#x27;ll probably have more problems...). Some of these globally-claimed generic packages are not really the best package to use.<p>Maybe it was a reaction against the Java-style reverse DNS notation, which is verbose and annoying, but a more GitHub-style user&#x2F;group namespace prefixing package names would have been the nice middle ground.</div><br/><div id="38020094" class="c"><input type="checkbox" id="c-38020094" checked=""/><div class="controls bullet"><span class="by">fawadasaurus</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019589">next</a><span>|</span><label class="collapse" for="c-38020094">[-]</label><label class="expand" for="c-38020094">[25 more]</label></div><br/><div class="children"><div class="content">I did some analysis on crates.io to find the top name squatters.  Then I did some calculations and found that the top name squatter created their crates at a rate of about one ever 30 seconds for a period of a week straight.<p>I send the analysis to the crates.io team and pointed that they have a no-automation policy.<p>They told me that it was not sufficient proof that someone was squatting those names. That&#x27;s my problem with crates.io is that they have a clear policy and they don&#x27;t enforce it so all the short&#x2F;easy to remember names for crates are already taken and there is nothing you can do to get it.</div><br/><div id="38022831" class="c"><input type="checkbox" id="c-38022831" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020094">parent</a><span>|</span><a href="#38021729">next</a><span>|</span><label class="collapse" for="c-38022831">[-]</label><label class="expand" for="c-38022831">[1 more]</label></div><br/><div class="children"><div class="content">In July 2023 the crates.io team started asking for feedback around changing their policy around name squatting - <a href="https:&#x2F;&#x2F;rust-lang.zulipchat.com&#x2F;#narrow&#x2F;stream&#x2F;318791-t-crates-io&#x2F;topic&#x2F;policy.20updates&#x2F;near&#x2F;371412272" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-lang.zulipchat.com&#x2F;#narrow&#x2F;stream&#x2F;318791-t-crat...</a></div><br/></div></div><div id="38021729" class="c"><input type="checkbox" id="c-38021729" checked=""/><div class="controls bullet"><span class="by">ogoffart</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020094">parent</a><span>|</span><a href="#38022831">prev</a><span>|</span><a href="#38020117">next</a><span>|</span><label class="collapse" for="c-38021729">[-]</label><label class="expand" for="c-38021729">[3 more]</label></div><br/><div class="children"><div class="content">&gt; they have a no-automation policy<p>What&#x27;s that? 
I have scripts that automate publishing of new release of my crates. And I think many projects have.</div><br/><div id="38021867" class="c"><input type="checkbox" id="c-38021867" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021729">parent</a><span>|</span><a href="#38022647">next</a><span>|</span><label class="collapse" for="c-38021867">[-]</label><label class="expand" for="c-38021867">[1 more]</label></div><br/><div class="children"><div class="content">Of course that&#x27;s permitted.<p>What they stated was only regarding claiming new ownership over crate names:<p>&gt; Using an automated tool to claim ownership of a large number of package names is not permitted.</div><br/></div></div><div id="38022647" class="c"><input type="checkbox" id="c-38022647" checked=""/><div class="controls bullet"><span class="by">serial_dev</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021729">parent</a><span>|</span><a href="#38021867">prev</a><span>|</span><a href="#38020117">next</a><span>|</span><label class="collapse" for="c-38022647">[-]</label><label class="expand" for="c-38022647">[1 more]</label></div><br/><div class="children"><div class="content">Write some automated analysis that looks up popular packages on npm, pub.dev, rubygems, nuget. &quot;Rustify&quot; the package names. Add to it frequently used words, maybe popular names, etc. Then, write a script that creates an empty package, registers a name on crates.io every thirty seconds, and then you have about 20k package names after a week that nobody can use.</div><br/></div></div></div></div><div id="38020117" class="c"><input type="checkbox" id="c-38020117" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020094">parent</a><span>|</span><a href="#38021729">prev</a><span>|</span><a href="#38019589">next</a><span>|</span><label class="collapse" for="c-38020117">[-]</label><label class="expand" for="c-38020117">[20 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a secret effort in the Rust community to supplant Crates.io and create an entirely new package ecosystem with proper namespacing, security, and much better community.<p>Not naming names, but I know several people working to put Crates.io out to pasture.<p>There&#x27;s a level of playing nice with them for the time being (eg. build reproducibility), but it&#x27;s only KTLO.<p>Crates.io <i>needs</i> to die for Rust to thrive. They&#x27;re a bungled, mismanaged liability. New code, new leadership.</div><br/><div id="38020149" class="c"><input type="checkbox" id="c-38020149" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020117">parent</a><span>|</span><a href="#38020126">next</a><span>|</span><label class="collapse" for="c-38020149">[-]</label><label class="expand" for="c-38020149">[1 more]</label></div><br/><div class="children"><div class="content">Crates.io doesn&#x27;t need to die necessarily. It needs some competition as a wake-up call.<p>Once a better alternative is out there, crates.io will either wither and die or improve. If it matches its competition in terms of quality and reliability, everyone is better off. If not, the alternative solution will take over.<p>I&#x27;m eager for this crates.io alternative to land, assuming they don&#x27;t break too many projects in their improvements.</div><br/></div></div><div id="38020126" class="c"><input type="checkbox" id="c-38020126" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020117">parent</a><span>|</span><a href="#38020149">prev</a><span>|</span><a href="#38021139">next</a><span>|</span><label class="collapse" for="c-38020126">[-]</label><label class="expand" for="c-38020126">[6 more]</label></div><br/><div class="children"><div class="content">Why does something like that need to be secret...? Isn&#x27;t it in the community&#x27;s best interest?</div><br/><div id="38020140" class="c"><input type="checkbox" id="c-38020140" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020126">parent</a><span>|</span><a href="#38021139">next</a><span>|</span><label class="collapse" for="c-38020140">[-]</label><label class="expand" for="c-38020140">[5 more]</label></div><br/><div class="children"><div class="content">Drama avoidance and avoiding bikeshedding seem obvious. Much easier to present a working system than a design that will get nitpicked into irrelevancy.</div><br/><div id="38020316" class="c"><input type="checkbox" id="c-38020316" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020140">parent</a><span>|</span><a href="#38020729">next</a><span>|</span><label class="collapse" for="c-38020316">[-]</label><label class="expand" for="c-38020316">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that makes sense.</div><br/></div></div><div id="38020729" class="c"><input type="checkbox" id="c-38020729" checked=""/><div class="controls bullet"><span class="by">sapling-ginger</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020140">parent</a><span>|</span><a href="#38020316">prev</a><span>|</span><a href="#38021139">next</a><span>|</span><label class="collapse" for="c-38020729">[-]</label><label class="expand" for="c-38020729">[3 more]</label></div><br/><div class="children"><div class="content">That quite funny. Just like when some people formed a violent militant group to take down a violent tyranical dictatorship. Of course they would promise that they would absolutely de-arm right after the dictatorship has been overthrown, and immediately establish a peaceful democratic government with fair election. They absolutely would, would they? They would never turn into what they were formed to replace, would they?</div><br/><div id="38020816" class="c"><input type="checkbox" id="c-38020816" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020729">parent</a><span>|</span><a href="#38021139">next</a><span>|</span><label class="collapse" for="c-38020816">[-]</label><label class="expand" for="c-38020816">[2 more]</label></div><br/><div class="children"><div class="content">If one tyranny has namespaces and the other doesn&#x27;t, I&#x27;ll prefer the former.</div><br/><div id="38021391" class="c"><input type="checkbox" id="c-38021391" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020816">parent</a><span>|</span><a href="#38021139">next</a><span>|</span><label class="collapse" for="c-38021391">[-]</label><label class="expand" for="c-38021391">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    pub use std::sic::semper;</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38021139" class="c"><input type="checkbox" id="c-38021139" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020117">parent</a><span>|</span><a href="#38020126">prev</a><span>|</span><a href="#38020181">next</a><span>|</span><label class="collapse" for="c-38021139">[-]</label><label class="expand" for="c-38021139">[2 more]</label></div><br/><div class="children"><div class="content">I find this interersting as most namespacing solutions would need the cargo team involved and I&#x27;ve heard nothing about this.</div><br/><div id="38021446" class="c"><input type="checkbox" id="c-38021446" checked=""/><div class="controls bullet"><span class="by">bluejekyll</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021139">parent</a><span>|</span><a href="#38020181">next</a><span>|</span><label class="collapse" for="c-38021446">[-]</label><label class="expand" for="c-38021446">[1 more]</label></div><br/><div class="children"><div class="content">This was my first thought too. And there are a lot of questions that will get asked, like, will all crate library names start being prefixed as well? So you end up with<p>use::bar; &#x2F;&#x2F; changing to<p>use::foo::bar;<p>I assume the library names that can be overridden in cargo would still be accepted, and then it all gets a little messy. The transition would be very messy.</div><br/></div></div></div></div><div id="38020181" class="c"><input type="checkbox" id="c-38020181" checked=""/><div class="controls bullet"><span class="by">awesome_dude</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020117">parent</a><span>|</span><a href="#38021139">prev</a><span>|</span><a href="#38022239">next</a><span>|</span><label class="collapse" for="c-38020181">[-]</label><label class="expand" for="c-38020181">[9 more]</label></div><br/><div class="children"><div class="content">How secret is it now that you&#x27;ve posted on HN about it?</div><br/><div id="38020422" class="c"><input type="checkbox" id="c-38020422" checked=""/><div class="controls bullet"><span class="by">fullarr</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020181">parent</a><span>|</span><a href="#38020550">next</a><span>|</span><label class="collapse" for="c-38020422">[-]</label><label class="expand" for="c-38020422">[6 more]</label></div><br/><div class="children"><div class="content">Wait I thought only I could read the secret</div><br/><div id="38021063" class="c"><input type="checkbox" id="c-38021063" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020422">parent</a><span>|</span><a href="#38020550">next</a><span>|</span><label class="collapse" for="c-38021063">[-]</label><label class="expand" for="c-38021063">[5 more]</label></div><br/><div class="children"><div class="content">yes, HN hides secrets automatically<p>******* is my password, but you can&#x27;t see it. Type your password back, and I won&#x27;t be able to see it. Try it!</div><br/><div id="38021395" class="c"><input type="checkbox" id="c-38021395" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021063">parent</a><span>|</span><a href="#38020550">next</a><span>|</span><label class="collapse" for="c-38021395">[-]</label><label class="expand" for="c-38021395">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure it&#x27;s working the way you described:<p>hunter2</div><br/><div id="38021730" class="c"><input type="checkbox" id="c-38021730" checked=""/><div class="controls bullet"><span class="by">kaycey2022</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021395">parent</a><span>|</span><a href="#38022376">next</a><span>|</span><label class="collapse" for="c-38021730">[-]</label><label class="expand" for="c-38021730">[1 more]</label></div><br/><div class="children"><div class="content">It’s working. I really can’t see it. All I see is ****</div><br/></div></div><div id="38022376" class="c"><input type="checkbox" id="c-38022376" checked=""/><div class="controls bullet"><span class="by">overtomanu</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021395">parent</a><span>|</span><a href="#38021730">prev</a><span>|</span><a href="#38020550">next</a><span>|</span><label class="collapse" for="c-38022376">[-]</label><label class="expand" for="c-38022376">[2 more]</label></div><br/><div class="children"><div class="content">Maybe you are getting tricked to give out your password...</div><br/><div id="38023255" class="c"><input type="checkbox" id="c-38023255" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38022376">parent</a><span>|</span><a href="#38020550">next</a><span>|</span><label class="collapse" for="c-38023255">[-]</label><label class="expand" for="c-38023255">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;hunter2" rel="nofollow noreferrer">https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;hunter2</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38020550" class="c"><input type="checkbox" id="c-38020550" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020181">parent</a><span>|</span><a href="#38020422">prev</a><span>|</span><a href="#38022239">next</a><span>|</span><label class="collapse" for="c-38020550">[-]</label><label class="expand" for="c-38020550">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an open secret.</div><br/><div id="38021639" class="c"><input type="checkbox" id="c-38021639" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020550">parent</a><span>|</span><a href="#38022239">next</a><span>|</span><label class="collapse" for="c-38021639">[-]</label><label class="expand" for="c-38021639">[1 more]</label></div><br/><div class="children"><div class="content">Hilarious.</div><br/></div></div></div></div></div></div><div id="38022239" class="c"><input type="checkbox" id="c-38022239" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020117">parent</a><span>|</span><a href="#38020181">prev</a><span>|</span><a href="#38019589">next</a><span>|</span><label class="collapse" for="c-38022239">[-]</label><label class="expand" for="c-38022239">[1 more]</label></div><br/><div class="children"><div class="content">crates.io is fine.</div><br/></div></div></div></div></div></div><div id="38019589" class="c"><input type="checkbox" id="c-38019589" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020094">prev</a><span>|</span><a href="#38020112">next</a><span>|</span><label class="collapse" for="c-38019589">[-]</label><label class="expand" for="c-38019589">[32 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe it was a reaction against the Java-style reverse DNS notation<p>I suspect it was less a reaction against anything and more just following the norms established by most other package managers. NPM, PyPI, RubyGems, Elixir&#x27;s Hex, Haskell&#x27;s Cabal... I&#x27;m having a hard time thinking of a non-Java package manager that was around at the time Rust came out that <i>didn&#x27;t</i> have a single, global namespace. Some have tried to fix that since then, but it was just the way package managers worked in 2014&#x2F;2015.</div><br/><div id="38019715" class="c"><input type="checkbox" id="c-38019715" checked=""/><div class="controls bullet"><span class="by">lucideer</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38020092">next</a><span>|</span><label class="collapse" for="c-38019715">[-]</label><label class="expand" for="c-38019715">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;m having a hard time thinking of a non-Java package manager that was around at the time Rust came out that didn&#x27;t have a single, global namespace</i><p>The implication here is that namespaces in package managers weren&#x27;t a known concept. Outside Java, NPM - probably the biggest at the time - not only supported them but was actively encouraging them due to collective regret around going single-global in the beginning. Composer is another popular example that actually enforced them.<p>Not only was namespacing a known widespread option, with well documented benefits, it was one that was enthusiastically argued for within the Rust community, and rejected.</div><br/><div id="38019830" class="c"><input type="checkbox" id="c-38019830" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019715">parent</a><span>|</span><a href="#38022254">next</a><span>|</span><label class="collapse" for="c-38019830">[-]</label><label class="expand" for="c-38019830">[5 more]</label></div><br/><div class="children"><div class="content">NPM added namespaces in version 2, which was released in Sep 2014, just 2 months before cargo was announced. I don&#x27;t remember anyone making a big deal about using scopes in NPM for several years after that, it was just there as an option. The announcement blog post of v2 only gives two paragraphs to scoped packages and explicitly frames the feature as being for enterprises and private modules [0]:<p>&gt; The most prominent feature driving the release of npm 2 didn’t actually need to be in a new major version at all: scoped packages. npm Enterprise is built around them, and they’ll also play a major role when private modules come to the public npm registry.<p>My memory is that the industry as a whole didn&#x27;t really start paying attention to the risks posed by dependencies in package managers until the left pad incident.<p>To be clear, I&#x27;m not saying that it was a good idea to not have a better namespace system or that they were completely ignorant of better options, just that they were very much following the norms at the time.<p>[0] <a href="https:&#x2F;&#x2F;blog.npmjs.org&#x2F;post&#x2F;98131109725&#x2F;npm-2-0-0.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.npmjs.org&#x2F;post&#x2F;98131109725&#x2F;npm-2-0-0.html</a></div><br/><div id="38021335" class="c"><input type="checkbox" id="c-38021335" checked=""/><div class="controls bullet"><span class="by">devman0</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019830">parent</a><span>|</span><a href="#38022254">next</a><span>|</span><label class="collapse" for="c-38021335">[-]</label><label class="expand" for="c-38021335">[4 more]</label></div><br/><div class="children"><div class="content">The left pad issue was kind of wild coming from the enterprise Java space. Supply chain attacks against open source software were already being taken pretty seriously, my last company had it&#x27;s own Maven repository manager running that was used to stage and vet packages before they could be used in production.</div><br/><div id="38021484" class="c"><input type="checkbox" id="c-38021484" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021335">parent</a><span>|</span><a href="#38022369">next</a><span>|</span><label class="collapse" for="c-38021484">[-]</label><label class="expand" for="c-38021484">[2 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s all a bit of revisionist history here, or I guess a bit ignorant. I had a friend who worked at Sonatype from pretty early days and they were, as I understand it, specifically working in this area of infrastructure for vetting, signing, license checking, etc. for corporate environments that needed to be extra careful about this stuff.<p>That crates.io launched without explicitly acknowledging this whole problem is either naivety or worse: already by then Java wasn&#x27;t &quot;cool&quot; and the &quot;cool kids&quot; were not paying attention to what happened over there.<p>It&#x27;s not that the industry wasn&#x27;t paying attention until the &#x27;left pad incident&#x27; -- that only holds if one&#x27;s definition of &quot;the industry&quot; is &quot;full stack developers&quot; under the age of 30; I remember when that happened and I was working in a shop full of Java devs and we all laughed at it...<p>Maven&#x27;s biggest problem was being caked in XML. In other respects it was very well thought out. That and it arrived at the tail-end of the period in which Java was &quot;cool&quot; to work in.</div><br/><div id="38021575" class="c"><input type="checkbox" id="c-38021575" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021484">parent</a><span>|</span><a href="#38022369">next</a><span>|</span><label class="collapse" for="c-38021575">[-]</label><label class="expand" for="c-38021575">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not revisionist history, the wording I chose was meant to acknowledge that there were segments of the industry that <i>did</i> take dependencies seriously. I&#x27;m very much aware that the Java world had a much more robust approach to dependencies before this, but &quot;the industry as a whole&quot; <i>includes</i> all the Node shops that were hit by leftpad as well as all the Python and Ruby shops that were using equally lousy dependency management techniques.<p>Rust chose to follow the majority of languages at the time. Again, as I noted in my previous comment, I&#x27;m not defending that decision, just pointing out that <i>most</i> of the widely-used languages in 2014 had a similar setup with similar weaknesses.</div><br/></div></div></div></div><div id="38022369" class="c"><input type="checkbox" id="c-38022369" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021335">parent</a><span>|</span><a href="#38021484">prev</a><span>|</span><a href="#38022254">next</a><span>|</span><label class="collapse" for="c-38022369">[-]</label><label class="expand" for="c-38022369">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the left-pad problem wasn&#x27;t about package namespacing it was about the ability to unpublish packages as well the prevalence of micropackages caused by lack of a decent standard library.<p>Also npm&#x27;s bad policy&#x2F;decision to transfer control of package in the name of predictability(this should probably be avoided for packages that aren&#x27;t malicious. You could argue for seizing broken&#x2F;trivial and unmaintained packages that have a good name but even then it might be best to leave well enough alone).<p>I suppose you&#x27;re talking about the original dispute which led the developer to unpublish his libraries (which npm stupidly allowed, and cargo didn&#x27;t). There&#x27;s a smaller chance of a company wanting a random package namespace then a package name but its not impossible (think Mike Rowe Soft vs Microsoft)</div><br/></div></div></div></div></div></div><div id="38022254" class="c"><input type="checkbox" id="c-38022254" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019715">parent</a><span>|</span><a href="#38019830">prev</a><span>|</span><a href="#38020092">next</a><span>|</span><label class="collapse" for="c-38022254">[-]</label><label class="expand" for="c-38022254">[2 more]</label></div><br/><div class="children"><div class="content">What are the benefits?</div><br/><div id="38023037" class="c"><input type="checkbox" id="c-38023037" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38022254">parent</a><span>|</span><a href="#38020092">next</a><span>|</span><label class="collapse" for="c-38023037">[-]</label><label class="expand" for="c-38023037">[1 more]</label></div><br/><div class="children"><div class="content">mainly, you can trust that anything under the foo&#x2F; namespace is controlled by only a smaller group of people, as opposed to the current situation on cargo where people pseudo-namespace by making a bunch of packages called foo-bar, foo-baz, and you can&#x27;t trust that foo-bin wasn&#x27;t just inserted by someone else attempting to appear to be part of the foo project. It also helps substantially with naming collisions, especially squatting.</div><br/></div></div></div></div></div></div><div id="38020092" class="c"><input type="checkbox" id="c-38020092" checked=""/><div class="controls bullet"><span class="by">stcroixx</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38019715">prev</a><span>|</span><a href="#38019706">next</a><span>|</span><label class="collapse" for="c-38020092">[-]</label><label class="expand" for="c-38020092">[4 more]</label></div><br/><div class="children"><div class="content">Perl’s CPAN was around in the 90’s and all modules were namespaced.</div><br/><div id="38020129" class="c"><input type="checkbox" id="c-38020129" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020092">parent</a><span>|</span><a href="#38019706">next</a><span>|</span><label class="collapse" for="c-38020129">[-]</label><label class="expand" for="c-38020129">[3 more]</label></div><br/><div class="children"><div class="content">Fair enough. As I noted to another commenter, I&#x27;m not trying to say there was no prior art (if nothing else there was Maven), just that they were following the overwhelming majority of mainstream languages at the time.</div><br/><div id="38020579" class="c"><input type="checkbox" id="c-38020579" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020129">parent</a><span>|</span><a href="#38019706">next</a><span>|</span><label class="collapse" for="c-38020579">[-]</label><label class="expand" for="c-38020579">[2 more]</label></div><br/><div class="children"><div class="content">&gt; just that they were following the overwhelming majority of mainstream languages at the time.<p>They were trying to do better than mainstream languages in other areas and succeeded. IIRC on this front they just decided Ruby&#x27;s bundler was the bee&#x27;s knees.</div><br/><div id="38021668" class="c"><input type="checkbox" id="c-38021668" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020579">parent</a><span>|</span><a href="#38019706">next</a><span>|</span><label class="collapse" for="c-38021668">[-]</label><label class="expand" for="c-38021668">[1 more]</label></div><br/><div class="children"><div class="content">The same developer who worked on bundler also worked on the initial version of cargo. That’s why they’re similar.<p>And at that time, it was a good idea. Ruby was popular and bundler + gem ecosystem was a big reason for its popularity. No one was worried that Rust might become so popular that it might outgrow the bundler model. That was only a remote possibility to begin with.</div><br/></div></div></div></div></div></div></div></div><div id="38019706" class="c"><input type="checkbox" id="c-38019706" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38020092">prev</a><span>|</span><a href="#38019857">next</a><span>|</span><label class="collapse" for="c-38019706">[-]</label><label class="expand" for="c-38019706">[10 more]</label></div><br/><div class="children"><div class="content">Yes, and all of those have had major security issues caused by their lack of foresight.<p>&quot;We&#x27;re pretending security is not an issue.&quot; has been the feedback every time this is raised with the Cargo team.<p>To be honest, it&#x27;s turned me off Rust a little bit.<p>The attitude of &quot;Rust is memory-safe, so we don&#x27;t need any other form of security.&quot; is not a good one.</div><br/><div id="38019949" class="c"><input type="checkbox" id="c-38019949" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019706">parent</a><span>|</span><a href="#38019798">next</a><span>|</span><label class="collapse" for="c-38019949">[-]</label><label class="expand" for="c-38019949">[4 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;We&#x27;re pretending security is not an issue.&quot; has been the feedback every time this is raised with the Cargo team.<p>Literally nobody has said this.<p>&gt; The attitude of &quot;Rust is memory-safe, so we don&#x27;t need any other form of security.&quot; is not a good one.<p>Fortunately it&#x27;s an attitude that nobody in the Rust project has!</div><br/><div id="38021326" class="c"><input type="checkbox" id="c-38021326" checked=""/><div class="controls bullet"><span class="by">Freedom2</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019949">parent</a><span>|</span><a href="#38019798">next</a><span>|</span><label class="collapse" for="c-38021326">[-]</label><label class="expand" for="c-38021326">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Literally nobody has said this.<p>I know of a few people, personally, who have said this.</div><br/><div id="38021482" class="c"><input type="checkbox" id="c-38021482" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021326">parent</a><span>|</span><a href="#38019798">next</a><span>|</span><label class="collapse" for="c-38021482">[-]</label><label class="expand" for="c-38021482">[2 more]</label></div><br/><div class="children"><div class="content">Ok, but like, were any of them people of note, actively working on the project?<p>Because it seems like the people who <i>are</i> working on the project aren’t saying that.</div><br/><div id="38022551" class="c"><input type="checkbox" id="c-38022551" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021482">parent</a><span>|</span><a href="#38019798">next</a><span>|</span><label class="collapse" for="c-38022551">[-]</label><label class="expand" for="c-38022551">[1 more]</label></div><br/><div class="children"><div class="content">The people that are working on the project haven&#x27;t implemented namespaces, or any other security feature really, so what they say is immaterial. What they do is the only thing that matters.</div><br/></div></div></div></div></div></div></div></div><div id="38019798" class="c"><input type="checkbox" id="c-38019798" checked=""/><div class="controls bullet"><span class="by">muldvarp</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019706">parent</a><span>|</span><a href="#38019949">prev</a><span>|</span><a href="#38019857">next</a><span>|</span><label class="collapse" for="c-38019798">[-]</label><label class="expand" for="c-38019798">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;We&#x27;re pretending security is not an issue.&quot; has been the feedback every time this is raised with the Cargo team.<p>Do you have a specific link where I can read this response, because this is not at all the responses I have read.</div><br/><div id="38020600" class="c"><input type="checkbox" id="c-38020600" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019798">parent</a><span>|</span><a href="#38019857">next</a><span>|</span><label class="collapse" for="c-38020600">[-]</label><label class="expand" for="c-38020600">[4 more]</label></div><br/><div class="children"><div class="content">Just some random Cargo security-related issues I noticed:<p>- No strong link between the repo and the published code.<p>- Many crates were spammed that were just a wrapper around a popular C&#x2F;C++ library. There&#x27;s no indication of this, so... &quot;surprise!&quot;... your compiled app is now more unsafe C&#x2F;C++ code than Rust.<p>- Extensive name squatting, to the point that virtual no library uses the obvious name, because someone else got to it first. The aformentioned C&#x2F;C++ libraries were easy to spit out, so they often grabbed the name before a Rust rewrite could be completed and published. So you now go to Cargo to find a Rust library for &#x27;X&#x27; and you instead have to use &#x27;X-rs&#x27; because... ha-ha, it&#x27;s actually a C&#x2F;C++ package manager with some Rust crates in there also.<p>- Transitive dependencies aren&#x27;t shown in the web page.<p>- No enforcement or indication of safe&#x2F;unsafe libs, nostd, etc...<p>- No requirement for MFA, which was a successful attack vector on multiple package managers in the past.<p>DISCLAIMER: Some of the above may have been resolved since I last looked. Other package managers also do these things (but that&#x27;s not a good thing).<p>In my opinion, any package manager that just lets any random person upload &quot;whatever&quot; is outright dangerous and useless to the larger ecosystem of developers in a hurry who don&#x27;t have the time to vet every single transitive dependency every month.<p>Package managers need to <i>grow up</i> and start requiring a direct reference to a specific Git commit -- that they store themselves -- and compile from scratch with an instrumented compiler that spits out metadata such as &quot;connects to the Internet, did you know?&quot; or &quot;is actually 99% C++ code, by the way&quot;.</div><br/><div id="38020745" class="c"><input type="checkbox" id="c-38020745" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020600">parent</a><span>|</span><a href="#38022390">next</a><span>|</span><label class="collapse" for="c-38020745">[-]</label><label class="expand" for="c-38020745">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but all the drawbacks you enumerate are also advantages for gaining critical mass. A free-for-all package repository is attractive to early adopters because they can become the ones to plug the obvious holes in the standard library. Having N developers each trying to make THE datetime&#x2F;logging&#x2F;webframework&#x2F;parsing library for Rust is good for gaining traction. You end up with a lot of bad packages with good names though.</div><br/></div></div><div id="38022390" class="c"><input type="checkbox" id="c-38022390" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020600">parent</a><span>|</span><a href="#38020745">prev</a><span>|</span><a href="#38019857">next</a><span>|</span><label class="collapse" for="c-38022390">[-]</label><label class="expand" for="c-38022390">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Extensive name squatting, to the point that virtual no library uses the obvious name, because someone else got to it first.<p>Maybe the obvious names should have been pre banned. But I don&#x27;t see the issue with non-obvious names either way you&#x27;re going to have to get community recommendation&#x2F;popularity to determine if<p>brandonq&#x2F;xml is better or worse then parsers&#x2F;xml</div><br/><div id="38022585" class="c"><input type="checkbox" id="c-38022585" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38022390">parent</a><span>|</span><a href="#38019857">next</a><span>|</span><label class="collapse" for="c-38022585">[-]</label><label class="expand" for="c-38022585">[1 more]</label></div><br/><div class="children"><div class="content">In ASP.NET land, I regularly work on projects where there is an informal rule that only Microsoft-published packages can be used, unless there&#x27;s good reason.<p>You don&#x27;t want to be using Ivan Vladimir&#x27;s OAUTH package to sign in to Microsoft Entra ID. That probably has an FSB backdoor ready to activate. Why use that, when there&#x27;s an equivalent Microsoft package?<p>When any random Chinese, Russian, or Israeli national can publish &quot;microsoftauth&quot;, you just <i>know</i> that some idiot will use it. That idiot may be me. Or a coworker. Or a transitive dependency. Or a transitive dependency introduced <i>after a critical update to the immediate dependency</i>. Or an external EXE tool deployed as a part of a third-party ISV binary product. Or...<p>Make the only path lead to the pit of success, because the alternative is to let people wander around and fall into the pit of failure.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38019857" class="c"><input type="checkbox" id="c-38019857" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38019706">prev</a><span>|</span><a href="#38019732">next</a><span>|</span><label class="collapse" for="c-38019857">[-]</label><label class="expand" for="c-38019857">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m having a hard time thinking of a non-Java package manager that was around at the time Rust came out that didn&#x27;t have a single, global namespace.<p>Technically not in the same category, but Docker Hub (2014) had namespaces.</div><br/></div></div><div id="38019732" class="c"><input type="checkbox" id="c-38019732" checked=""/><div class="controls bullet"><span class="by">thirdplace_</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38019857">prev</a><span>|</span><a href="#38020256">next</a><span>|</span><label class="collapse" for="c-38019732">[-]</label><label class="expand" for="c-38019732">[2 more]</label></div><br/><div class="children"><div class="content">php&#x27;s composer[0] in 2012 had package namespaces<p>[0] <a href="https:&#x2F;&#x2F;getcomposer.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;getcomposer.org&#x2F;</a></div><br/><div id="38019900" class="c"><input type="checkbox" id="c-38019900" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019732">parent</a><span>|</span><a href="#38020256">next</a><span>|</span><label class="collapse" for="c-38019900">[-]</label><label class="expand" for="c-38019900">[1 more]</label></div><br/><div class="children"><div class="content">Sorta—it looks like they were mostly just using that system by convention until May 2015, when they finally become enforced [0]. Still, that&#x27;s a good one that I hadn&#x27;t thought of, and they at least had the convention in place.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;composer&#x2F;packagist&#x2F;issues&#x2F;163#issuecomment-99673878">https:&#x2F;&#x2F;github.com&#x2F;composer&#x2F;packagist&#x2F;issues&#x2F;163#issuecommen...</a></div><br/></div></div></div></div><div id="38020256" class="c"><input type="checkbox" id="c-38020256" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019589">parent</a><span>|</span><a href="#38019732">prev</a><span>|</span><a href="#38020112">next</a><span>|</span><label class="collapse" for="c-38020256">[-]</label><label class="expand" for="c-38020256">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m honestly astounded at how badly many languages have implemented dependency management, particularly when Java basically got this right almost 20 years ago (Maven) and others have made the mistakes that Java fixed. With Maven you get:<p>1. Flexible version (of requirements) specification;<p>2. Yes, source code had domain names in packages but that came from Java and you can technically separate that in the dependency declaration;<p>3. You can run local repos, which is useful for corporate environments so you can deploy your own internal packages; and<p>4. Source could be included or not, as desired.<p>Yes, it was XML and verbose. Gradle basically fixed that if you really cared (personally, I didn&#x27;t).<p>Later comes along Go. No dependency management at the start. There ended up being two ways of specifying dependencies. At least one included putting github.io&#x2F;username&#x2F;package into your code. That username changes and all your code has to change. Awful design.<p>At least domains forced basically agreed upon namespacing.</div><br/><div id="38021194" class="c"><input type="checkbox" id="c-38021194" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020256">parent</a><span>|</span><a href="#38020363">next</a><span>|</span><label class="collapse" for="c-38021194">[-]</label><label class="expand" for="c-38021194">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Later comes along Go. No dependency management at the start. There ended up being two ways of specifying dependencies. At least one included putting github.io&#x2F;username&#x2F;package into your code. That username changes and all your code has to change. Awful design.<p>&quot;github.io&#x2F;username&#x2F;package&quot; is using a domain name, just like Java. Changing the username part is like changing the domain name--I don&#x27;t see how this is any worse in Go than in Java.<p>If you don&#x27;t like that there&#x27;s a username in there, then don&#x27;t put one in there to begin with. Requiring a username has nothing to do with Go vs. Java, but rather is because the package&#x27;s canonical location is hosted on Github (which requires a username).<p>I don&#x27;t know why so many programmer&#x27;s use a domain they don&#x27;t control as the official home of their projects--it seems silly to me (especially for bigger, more serious projects).</div><br/><div id="38023241" class="c"><input type="checkbox" id="c-38023241" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021194">parent</a><span>|</span><a href="#38021368">next</a><span>|</span><label class="collapse" for="c-38023241">[-]</label><label class="expand" for="c-38023241">[1 more]</label></div><br/><div class="children"><div class="content">Note that in Java it is merely a convention to use domain names as packages. There is no technical requirement to do so. So moving to a different domain has no impact whatsoever on dependency resolution. Many people use non-existent domain names.<p>To be honest I really like how Java  advocated for verbose namespaces. Library authors have this awful idea that their library is a special little snowflake that deserves the shortest name possible, like &quot;http&quot; or &quot;math&quot; (or &quot;_&quot;...).</div><br/></div></div><div id="38021368" class="c"><input type="checkbox" id="c-38021368" checked=""/><div class="controls bullet"><span class="by">devman0</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021194">parent</a><span>|</span><a href="#38023241">prev</a><span>|</span><a href="#38021466">next</a><span>|</span><label class="collapse" for="c-38021368">[-]</label><label class="expand" for="c-38021368">[1 more]</label></div><br/><div class="children"><div class="content">Slight difference is that it wouldn&#x27;t break existing builds if you changed namespaces in Java. The maven central repo does not allow packages to be rescinded once they are published.<p>So that old version of package xyz will still resolve in your tagged build years from now even if the project rebrands&#x2F;changes namespaces.</div><br/></div></div><div id="38021466" class="c"><input type="checkbox" id="c-38021466" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021194">parent</a><span>|</span><a href="#38021368">prev</a><span>|</span><a href="#38020363">next</a><span>|</span><label class="collapse" for="c-38021466">[-]</label><label class="expand" for="c-38021466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know why so many programmer&#x27;s use a domain they don&#x27;t control as the official home of their projects<p>Not only that, but a commercial, for-profit domain that actively reads all the code stored on it to train an AI. Owned and run by one of the worst opponents of the OS community in the history of computing.<p>At least move to Gitlab if you must store your project on someone else&#x27;s domain.</div><br/></div></div></div></div><div id="38020363" class="c"><input type="checkbox" id="c-38020363" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020256">parent</a><span>|</span><a href="#38021194">prev</a><span>|</span><a href="#38020112">next</a><span>|</span><label class="collapse" for="c-38020363">[-]</label><label class="expand" for="c-38020363">[1 more]</label></div><br/><div class="children"><div class="content">Yes, #3 in particular is important for many large corps where one team develops a library that may be pulled in by literally thousands of other developers.</div><br/></div></div></div></div></div></div><div id="38020112" class="c"><input type="checkbox" id="c-38020112" checked=""/><div class="controls bullet"><span class="by">WatchDog</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019589">prev</a><span>|</span><a href="#38019547">next</a><span>|</span><label class="collapse" for="c-38020112">[-]</label><label class="expand" for="c-38020112">[12 more]</label></div><br/><div class="children"><div class="content">Maven and Java really don’t get enough credit for how well it’s dependency management works.<p>So many inferior dependency management systems for other languages have come along later, and learned nothing from those that came before it.</div><br/><div id="38022236" class="c"><input type="checkbox" id="c-38022236" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020112">parent</a><span>|</span><a href="#38020965">next</a><span>|</span><label class="collapse" for="c-38022236">[-]</label><label class="expand" for="c-38022236">[1 more]</label></div><br/><div class="children"><div class="content">And NuGET, which was inspired on them.</div><br/></div></div><div id="38020965" class="c"><input type="checkbox" id="c-38020965" checked=""/><div class="controls bullet"><span class="by">tootie</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020112">parent</a><span>|</span><a href="#38022236">prev</a><span>|</span><a href="#38020156">next</a><span>|</span><label class="collapse" for="c-38020965">[-]</label><label class="expand" for="c-38020965">[4 more]</label></div><br/><div class="children"><div class="content">100% agree. It&#x27;s unbelievable what a PITA it is dealing with pip or npm compared to Maven even 10 years ago. The descriptors could get convoluted but you could also edit them in an IDE that knew the expected tokens to make things happen.</div><br/><div id="38021183" class="c"><input type="checkbox" id="c-38021183" checked=""/><div class="controls bullet"><span class="by">symlinkk</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020965">parent</a><span>|</span><a href="#38020156">next</a><span>|</span><label class="collapse" for="c-38021183">[-]</label><label class="expand" for="c-38021183">[3 more]</label></div><br/><div class="children"><div class="content">What’s so hard about “npm install” and “package.json”. It’s dead simple</div><br/><div id="38021535" class="c"><input type="checkbox" id="c-38021535" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021183">parent</a><span>|</span><a href="#38020156">next</a><span>|</span><label class="collapse" for="c-38021535">[-]</label><label class="expand" for="c-38021535">[2 more]</label></div><br/><div class="children"><div class="content">No you see Java devs have stockholm-syndromed themselves into believe that a giant stack of XML, or some unhinged mini-language are actually good, and much better than something the humans involved can actually read and parse easily and now to compensate with other ecosystems providing 85% of the functionality, with 5% of the pain, they’ve got to find some reason to complain about them.</div><br/><div id="38022198" class="c"><input type="checkbox" id="c-38022198" checked=""/><div class="controls bullet"><span class="by">dingi</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38021535">parent</a><span>|</span><a href="#38020156">next</a><span>|</span><label class="collapse" for="c-38022198">[-]</label><label class="expand" for="c-38022198">[1 more]</label></div><br/><div class="children"><div class="content">what&#x27;s wrong with XML? Maven XML is a configuration not a programming language.</div><br/></div></div></div></div></div></div></div></div><div id="38020156" class="c"><input type="checkbox" id="c-38020156" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020112">parent</a><span>|</span><a href="#38020965">prev</a><span>|</span><a href="#38019547">next</a><span>|</span><label class="collapse" for="c-38020156">[-]</label><label class="expand" for="c-38020156">[6 more]</label></div><br/><div class="children"><div class="content">Is this a joke?</div><br/><div id="38020976" class="c"><input type="checkbox" id="c-38020976" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020156">parent</a><span>|</span><a href="#38020562">next</a><span>|</span><label class="collapse" for="c-38020976">[-]</label><label class="expand" for="c-38020976">[3 more]</label></div><br/><div class="children"><div class="content">Having tried Java and other languages, no, it&#x27;s not a joke. Other than XML Maven got a lot of things right.</div><br/><div id="38021452" class="c"><input type="checkbox" id="c-38021452" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020976">parent</a><span>|</span><a href="#38022298">next</a><span>|</span><label class="collapse" for="c-38021452">[-]</label><label class="expand" for="c-38021452">[1 more]</label></div><br/><div class="children"><div class="content">and i dont particularly think that using xml is that bad. The schema is well defined, and gives you good autocompletion in any competent IDE (such as intellij).<p>It took some iterations before maven 3 became &quot;good&quot;, so people forget that it wasn&#x27;t as nice before now! Unfortunately, it seems that the lessons learned there is never really disseminated to other ecosystems - perhaps due to prejudice against &quot;enterprisey&quot; java. Yet, these package managers are now facing the sorts of problems solved in java.</div><br/></div></div><div id="38022298" class="c"><input type="checkbox" id="c-38022298" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020976">parent</a><span>|</span><a href="#38021452">prev</a><span>|</span><a href="#38020562">next</a><span>|</span><label class="collapse" for="c-38022298">[-]</label><label class="expand" for="c-38022298">[1 more]</label></div><br/><div class="children"><div class="content">And you don&#x27;t even need to use XML with Polyglot Maven<p><a href="https:&#x2F;&#x2F;github.com&#x2F;takari&#x2F;polyglot-maven">https:&#x2F;&#x2F;github.com&#x2F;takari&#x2F;polyglot-maven</a></div><br/></div></div></div></div><div id="38020562" class="c"><input type="checkbox" id="c-38020562" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020156">parent</a><span>|</span><a href="#38020976">prev</a><span>|</span><a href="#38020300">next</a><span>|</span><label class="collapse" for="c-38020562">[-]</label><label class="expand" for="c-38020562">[1 more]</label></div><br/><div class="children"><div class="content">Not even remotely a joke.<p>The inverse-style domain name thing does a really good job of removing the whole issue of squatting from the ecosystem.  You have to demonstrate some level of commitment and identity through control of a domain name in order to publish.<p>I would also say that this puts <i>just enough</i> friction so that people don&#x27;t publish dogshit.<p>crates.io demonstrates quite clearly that you either have to go all the way and take responsibility for curation or you have to get completely out of the way.  There is no inbetween.</div><br/></div></div><div id="38020300" class="c"><input type="checkbox" id="c-38020300" checked=""/><div class="controls bullet"><span class="by">theendisney2</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020156">parent</a><span>|</span><a href="#38020562">prev</a><span>|</span><a href="#38019547">next</a><span>|</span><label class="collapse" for="c-38020300">[-]</label><label class="expand" for="c-38020300">[1 more]</label></div><br/><div class="children"><div class="content">I think the correct approach is to do full-real-name_good-package-name it might not be practical but it would be legendary.</div><br/></div></div></div></div></div></div><div id="38019547" class="c"><input type="checkbox" id="c-38019547" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020112">prev</a><span>|</span><a href="#38022055">next</a><span>|</span><label class="collapse" for="c-38019547">[-]</label><label class="expand" for="c-38019547">[14 more]</label></div><br/><div class="children"><div class="content">URLs for packages makes a lot of sense.  It works well in the land of Go.  It also conveniently eliminates the need for the language to have a global packages database.  Upload your package to example.com&#x2F;your-thing and it&#x27;s released!  (You can, of course, still offer a cache and search engine if you want to.)</div><br/><div id="38019919" class="c"><input type="checkbox" id="c-38019919" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019547">parent</a><span>|</span><a href="#38020237">next</a><span>|</span><label class="collapse" for="c-38019919">[-]</label><label class="expand" for="c-38019919">[10 more]</label></div><br/><div class="children"><div class="content">No, URL&#x27;s don&#x27;t make sense because your application shouldn&#x27;t care where on the internet your dependency happened to be hosted when you integrated it. It&#x27;s location has nothing to do with what it is.<p>By the time you&#x27;re going to production, your vetted and locked dependency should be living in your own cache&#x2F;mirror&#x2F;vendored-repo&#x2F;whatever so that you know <i>exactly</i> what code you built your project around and know <i>exactly</i> what the availability will be when you build&#x2F;instantiate your project.<p>Your project shouldn&#x27;t need to care whether GitHub fell out of fashion and the project moved to GitLab, and <i>definitely</i> shouldn&#x27;t be relying on GitHub being available when you need to build, test, deploy, or scale. That&#x27;s a completely unnecessary failure point for you to introduce.<p>Systems that use URL-identified packages <i>can</i> work around some of this, but just reinforce terrible habits.</div><br/><div id="38020143" class="c"><input type="checkbox" id="c-38020143" checked=""/><div class="controls bullet"><span class="by">andiareso</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020315">next</a><span>|</span><label class="collapse" for="c-38020143">[-]</label><label class="expand" for="c-38020143">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t that why GOPROXY exists though? Not sure why you would need an internet connection. URLs don’t necessarily equate to the internet. Our internal and external packages are all locally hosted and work regardless of the internet being available.</div><br/></div></div><div id="38020315" class="c"><input type="checkbox" id="c-38020315" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020143">prev</a><span>|</span><a href="#38020434">next</a><span>|</span><label class="collapse" for="c-38020315">[-]</label><label class="expand" for="c-38020315">[3 more]</label></div><br/><div class="children"><div class="content">URLs are well structured and unique, with a sensible default - sourcing the file from the internet - and ubiquitous processes for easily mapping the URL to an alternative location.<p>I.e., when you&#x27;re going to run the production build, the URLs are mapped to fetch from the vetted cache and not the internet.<p>I don&#x27;t see any downsides to allowing them as a source, or making them the default approach</div><br/><div id="38020478" class="c"><input type="checkbox" id="c-38020478" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020315">parent</a><span>|</span><a href="#38020434">next</a><span>|</span><label class="collapse" for="c-38020478">[-]</label><label class="expand" for="c-38020478">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and ubiquitous processes for easily mapping the URL to an alternative location.<p>This seems strange to me because the whole point of a Uniform Resource Locator is to specify <i>where</i> a resource can be located.<p>It&#x27;s a bit like saying &quot;My project depends on the binder on shelf 7 in Room 42, sixth binder from the left. Except when I go into production, then use....&quot; Don&#x27;t tell me what binder it&#x27;s in, tell me what it is.<p>I can see a case made for URIs, which is basically what Java did.</div><br/><div id="38021386" class="c"><input type="checkbox" id="c-38021386" checked=""/><div class="controls bullet"><span class="by">devman0</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020478">parent</a><span>|</span><a href="#38020434">next</a><span>|</span><label class="collapse" for="c-38021386">[-]</label><label class="expand" for="c-38021386">[1 more]</label></div><br/><div class="children"><div class="content">This was a big annoyance for me back in the day when I was dealing with XML namespaces. URLs never made sense for that use case and too many tools tried to pull XSDs from the literal URL which was always generally out of date, some projects switch to URIs like tag uris or URNs and it was much better, imo.</div><br/></div></div></div></div></div></div><div id="38020434" class="c"><input type="checkbox" id="c-38020434" checked=""/><div class="controls bullet"><span class="by">jowea</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020315">prev</a><span>|</span><a href="#38020137">next</a><span>|</span><label class="collapse" for="c-38020434">[-]</label><label class="expand" for="c-38020434">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just delegating the problem? URL dependencies do not replace what crates.io does, and a modern language will still want something like it. You&#x27;d just end up with most every dependency being declared as crates.io&#x2F;foo.</div><br/></div></div><div id="38020137" class="c"><input type="checkbox" id="c-38020137" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020434">prev</a><span>|</span><a href="#38020061">next</a><span>|</span><label class="collapse" for="c-38020137">[-]</label><label class="expand" for="c-38020137">[1 more]</label></div><br/><div class="children"><div class="content">URLs form a nice global namespacing system. But yes, I agree that it should be possible to actually get the source from anywhere.<p>Basically the URL of a package name should be primarily the ID, not the locator (even if it is used for location by default).</div><br/></div></div><div id="38020061" class="c"><input type="checkbox" id="c-38020061" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020137">prev</a><span>|</span><a href="#38020273">next</a><span>|</span><label class="collapse" for="c-38020061">[-]</label><label class="expand" for="c-38020061">[2 more]</label></div><br/><div class="children"><div class="content">It worked for the rest of the Internet.</div><br/><div id="38020093" class="c"><input type="checkbox" id="c-38020093" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020061">parent</a><span>|</span><a href="#38020273">next</a><span>|</span><label class="collapse" for="c-38020093">[-]</label><label class="expand" for="c-38020093">[1 more]</label></div><br/><div class="children"><div class="content">There is something to be said for separating {unique piece of content} and {hosted location}.<p>E.g. doi&#x27;s <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Digital_object_identifier" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Digital_object_identifier</a></div><br/></div></div></div></div><div id="38020273" class="c"><input type="checkbox" id="c-38020273" checked=""/><div class="controls bullet"><span class="by">awesome_dude</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019919">parent</a><span>|</span><a href="#38020061">prev</a><span>|</span><a href="#38020237">next</a><span>|</span><label class="collapse" for="c-38020273">[-]</label><label class="expand" for="c-38020273">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By the time you&#x27;re going to production, your vetted and locked dependency should be living in your own cache&#x2F;mirror&#x2F;vendored-repo&#x2F;whatever so that you know exactly what code you built your project around and know exactly what the availability will be when you build&#x2F;instantiate your project.<p>In the Go world this would be &quot;vendored&quot; dependencies, that is, the dependencies are within your source tree, and your CICD can build to its hearts content with no care in the world about the internet because it has the deps.<p>The URL is useful for determining which version of a specific project is being used - &quot;Oh we switched to the one hosted on gitlab because the github one went stale&quot;<p>The advantage of using gitlab, or github, or whatever public code repository is that you get to piggy back off their naming policies which ensure uniqueness.<p>But, at the same time, there&#x27;s no reason that the repo being referred to cannot be in house (bob.local) or private.<p>Having said all of that, the Go module system is a massive improvement on what they did have originally (nothing) and the 3rd party attempts to solve the problem (dep, glide, and the prototype for modules, vgo), but it&#x27;s not without its edge cases.</div><br/></div></div></div></div><div id="38020237" class="c"><input type="checkbox" id="c-38020237" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019547">parent</a><span>|</span><a href="#38019919">prev</a><span>|</span><a href="#38019924">next</a><span>|</span><label class="collapse" for="c-38020237">[-]</label><label class="expand" for="c-38020237">[1 more]</label></div><br/><div class="children"><div class="content">You can, though. From a random Cargo package I have downloaded to my computer:<p><pre><code>    [dependencies]
    uniffi = { git = &quot;https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;uniffi-rs&quot; }
    
</code></pre>
You can also specify revision&#x2F;branch&#x2F;etc.<p>Alternatively, you can do:<p><pre><code>    [registries]
    maven = { index = &quot;https:&#x2F;&#x2F;rust.maven.org&#x2F;git&#x2F;index&quot; }
    [dependencies]
    some-package = { index = &quot;maven&quot;, version = &quot;1.1&quot; }
    
</code></pre>
Obviously Maven doesn&#x27;t host any Rust crates (yet?), this is just a theoretical example. Very few projects bother to host their own registry, partially because crates.io doesn&#x27;t allow packages that load dependencies from other indices (for obvious security reasons). The registry definition can also be done globally through environment variables: CARGO_REGISTRIES_MAVEN=&quot;<a href="https:&#x2F;&#x2F;rust.maven.org&#x2F;git&#x2F;index" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust.maven.org&#x2F;git&#x2F;index</a>&quot;. Furthermore, the default registry can be set in a global config file.<p>In theory, all you need to do is publish a crate is to `git push upstream master`, and your package will become available on <a href="https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;crate-name">https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;crate-name</a> (or example.com&#x2F;your-package if you choose to host your git repo on there).<p>Personally, I don&#x27;t like using other people&#x27;s URL packages, because your website can disappear any moment for any reason. Maybe you decide to call it quits, maybe you get hit by a car, whatever the reason, my build is broken all of the sudden. The probability of crates.io going down is a lot lower than the probability of packages-of-some-random-guy-in-nebraska.ddns.net disappearing</div><br/></div></div><div id="38019924" class="c"><input type="checkbox" id="c-38019924" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019547">parent</a><span>|</span><a href="#38020237">prev</a><span>|</span><a href="#38019651">next</a><span>|</span><label class="collapse" for="c-38019924">[-]</label><label class="expand" for="c-38019924">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t help with the failure mode of dependencies disappearing, which forces people that care about it to vendor, which in turn brings its own set of issues.</div><br/></div></div><div id="38019651" class="c"><input type="checkbox" id="c-38019651" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019547">parent</a><span>|</span><a href="#38019924">prev</a><span>|</span><a href="#38022055">next</a><span>|</span><label class="collapse" for="c-38019651">[-]</label><label class="expand" for="c-38019651">[1 more]</label></div><br/><div class="children"><div class="content">Cargo does support URLs to git repos for dependencies. But crates.io is the official platform and almost every search I do on it returns at least one generically named entry with an empty repository that someone snatched away and never used.</div><br/></div></div></div></div><div id="38022055" class="c"><input type="checkbox" id="c-38022055" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019547">prev</a><span>|</span><a href="#38020846">next</a><span>|</span><label class="collapse" for="c-38022055">[-]</label><label class="expand" for="c-38022055">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a lack of namespace is that much problem. Sure, it is often annoying, but people are creative enough to create a short enough and still available crate name for most cases. Namespacing only makes sense for a large group of related crates---and it wouldn&#x27;t give much benefit over a flat namespace.<p>As other mentioned though, a typosquatting is a much bigger problem and namespacing offers only a partial solution. (You can still create a lookalike organization name, both in npm and in Github.)</div><br/><div id="38022433" class="c"><input type="checkbox" id="c-38022433" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38022055">parent</a><span>|</span><a href="#38020846">next</a><span>|</span><label class="collapse" for="c-38022433">[-]</label><label class="expand" for="c-38022433">[1 more]</label></div><br/><div class="children"><div class="content">Id argue typesquatting a namespace is arguably easier then type squatting a package name since you will often ignore the namespace name</div><br/></div></div></div></div><div id="38020846" class="c"><input type="checkbox" id="c-38020846" checked=""/><div class="controls bullet"><span class="by">corytheboyd</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38022055">prev</a><span>|</span><a href="#38023019">next</a><span>|</span><label class="collapse" for="c-38020846">[-]</label><label class="expand" for="c-38020846">[3 more]</label></div><br/><div class="children"><div class="content">I don’t work with rust on the regular, but this is so annoying with package repositories in general. No don’t use http-server, it’s bad, instead you have to use MuffinTop, it’s better. And then you just have to know that. The concept of sanctioned package names would be interesting, but probably chaotic in practice as the underlying code behind this sort of alias changes over time. This will remain a part of being a domain expert in any given ecosystem forever I think, hooray!</div><br/><div id="38022220" class="c"><input type="checkbox" id="c-38022220" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020846">parent</a><span>|</span><a href="#38021704">next</a><span>|</span><label class="collapse" for="c-38022220">[-]</label><label class="expand" for="c-38022220">[1 more]</label></div><br/><div class="children"><div class="content">(You probably agree with me but I&#x27;m going to just write one big comment instead of replying to every slightly incorrect comment in the thread)<p>Naming things really is one of the hardest problems. This crates thing is a special case of Zooko&#x27;s Triangle: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zooko%27s_triangle" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zooko%27s_triangle</a><p>Crates.io names are human-meaningful and everyone sees the same names, but it&#x27;s vulnerable to squatting, spamming, and Sybil attacks.<p>You could tie a name to a public key, like onion addresses do, but it&#x27;s unwieldy for humans. (NB, nothing stops you from doing this inside of crates.io if you really wanted)<p>You could use pet names where &quot;http-server&quot; and &quot;http-client&quot; locally map to &quot;hyper&quot; and &quot;reqwest&quot;, but nobody likes those, because they don&#x27;t solve the bootstrap problem.<p>It&#x27;s a problem with all repos because when you say &quot;http-server should simply be the best server that everyone likes right now&quot;, you have to decide who is the authority of &quot;best&quot;, and &quot;everyone&quot;, and &quot;now&quot;. Don&#x27;t forget how much useless crap is left in the Python stdlib marked as &quot;don&#x27;t use this as of 2018, use the 3rd-party lib that does it way better.&quot;<p>So yeah... probably will be a problem forever. As a bit of fun here are some un-intuitive names, and my proposed improvements:<p>- Rename Apache to &quot;http-server&quot;<p>- Rename Nginx to &quot;http-server-2&quot;<p>- Rename Caddy to &quot;http-server-2-golang&quot;<p>- Rename libcurl to &quot;http-client&quot;<p>- Rename GTK+ to &quot;linux-gui&quot;<p>- Rename Qt to &quot;linux-gui-2&quot;<p>- Rename xfce4 to &quot;linux-desktop-3&quot;<p>Then you only need to remember which numbers are good and which numbers are bad! Like how IPv4 is the best, IPv6 is okay, but IPV5 isn&#x27;t real, and HTTP 1.1 and 3 are great but 2 kinda sucked.<p>Very simple. If a company as big as Apple can have simple names like &quot;WebKit&quot;, &quot;CoreGraphics&quot;, and &quot;CoreAudio&quot; then surely a million hackers competing in a free marketplace can do the same thing.</div><br/></div></div><div id="38021704" class="c"><input type="checkbox" id="c-38021704" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020846">parent</a><span>|</span><a href="#38022220">prev</a><span>|</span><a href="#38023019">next</a><span>|</span><label class="collapse" for="c-38021704">[-]</label><label class="expand" for="c-38021704">[1 more]</label></div><br/><div class="children"><div class="content">I think if you get three to five developers who are enthusiastic about X language, their collective knowledge will select good packages.</div><br/></div></div></div></div><div id="38023019" class="c"><input type="checkbox" id="c-38023019" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020846">prev</a><span>|</span><a href="#38021812">next</a><span>|</span><label class="collapse" for="c-38023019">[-]</label><label class="expand" for="c-38023019">[1 more]</label></div><br/><div class="children"><div class="content">I like that there are no namespaces, it forces people to come up with unique names rather than naming their calendar crate to be `calendar`.</div><br/></div></div><div id="38021812" class="c"><input type="checkbox" id="c-38021812" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38023019">prev</a><span>|</span><a href="#38020105">next</a><span>|</span><label class="collapse" for="c-38021812">[-]</label><label class="expand" for="c-38021812">[1 more]</label></div><br/><div class="children"><div class="content">CPAN has the best model IMHO. Hierarchy that starts with categories. You build on top of the base stuff and extend it, rather than reinvent&#x2F;fork something with a random name. Result is a lot more improvement and reuse, and more functionality with less duplication. Plus it&#x27;s easy to find stuff.<p>Perl&#x27;s whole ecosystem is amazing compared to other languages. It&#x27;s a shame nobody knows it.</div><br/></div></div><div id="38020105" class="c"><input type="checkbox" id="c-38020105" checked=""/><div class="controls bullet"><span class="by">SCLeo</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38021812">prev</a><span>|</span><a href="#38019540">next</a><span>|</span><label class="collapse" for="c-38020105">[-]</label><label class="expand" for="c-38020105">[1 more]</label></div><br/><div class="children"><div class="content">If you have a namespace, can&#x27;t people just globally-claim namespaces instead? like serde&#x2F;serde or something similar. I feel if you really don&#x27;t want people claim whatever they want, you have to do the Java package style where namespaces are tied to domain names.</div><br/></div></div><div id="38019540" class="c"><input type="checkbox" id="c-38019540" checked=""/><div class="controls bullet"><span class="by">rochak</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020105">prev</a><span>|</span><a href="#38019678">next</a><span>|</span><label class="collapse" for="c-38019540">[-]</label><label class="expand" for="c-38019540">[6 more]</label></div><br/><div class="children"><div class="content">Go made a great decision to namespace packages via this Github style.</div><br/><div id="38019599" class="c"><input type="checkbox" id="c-38019599" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019540">parent</a><span>|</span><a href="#38020165">next</a><span>|</span><label class="collapse" for="c-38019599">[-]</label><label class="expand" for="c-38019599">[3 more]</label></div><br/><div class="children"><div class="content">And the horrible decision to not make library-level (&quot;module&quot;) and code-unit-level (&quot;package&quot;) namespacing orthogonal.  The former was an afterthought tacked on since the package system was designed to be used only within Google&#x27;s monorepo and little care was paid to how it would work when it was released to the public and used more generally.</div><br/><div id="38019862" class="c"><input type="checkbox" id="c-38019862" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019599">parent</a><span>|</span><a href="#38020165">next</a><span>|</span><label class="collapse" for="c-38019862">[-]</label><label class="expand" for="c-38019862">[2 more]</label></div><br/><div class="children"><div class="content">I want to understand what you just said, but I fear watering your language down a bit might be a tall ask with some people. Would you be willing to eli5 what you believe Go did that was a horrible decision with regards to module&#x2F;package namespacing?</div><br/><div id="38020021" class="c"><input type="checkbox" id="c-38020021" checked=""/><div class="controls bullet"><span class="by">cdelsolar</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019862">parent</a><span>|</span><a href="#38020165">next</a><span>|</span><label class="collapse" for="c-38020021">[-]</label><label class="expand" for="c-38020021">[1 more]</label></div><br/><div class="children"><div class="content">I think he wants them to be treated differently for some reason.</div><br/></div></div></div></div></div></div><div id="38020165" class="c"><input type="checkbox" id="c-38020165" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019540">parent</a><span>|</span><a href="#38019599">prev</a><span>|</span><a href="#38019678">next</a><span>|</span><label class="collapse" for="c-38020165">[-]</label><label class="expand" for="c-38020165">[2 more]</label></div><br/><div class="children"><div class="content">How is this a good decision? You have to alias packages when names collide</div><br/><div id="38021427" class="c"><input type="checkbox" id="c-38021427" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020165">parent</a><span>|</span><a href="#38019678">next</a><span>|</span><label class="collapse" for="c-38021427">[-]</label><label class="expand" for="c-38021427">[1 more]</label></div><br/><div class="children"><div class="content">What is the better decision to avoid name colliding?</div><br/></div></div></div></div></div></div><div id="38019678" class="c"><input type="checkbox" id="c-38019678" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019540">prev</a><span>|</span><a href="#38022262">next</a><span>|</span><label class="collapse" for="c-38019678">[-]</label><label class="expand" for="c-38019678">[8 more]</label></div><br/><div class="children"><div class="content">This needs to be resolved by every damned language.
Just make signed dependencies a universal default, point to an https page for the package vendor and use the signing key from there.<p>Neither node nor maven ever bothered to solve this, so we end up wandering the Wild West wondering when it will be that HR, or legal, or architecture comes knocking on the door to ask what we were thinking having a dependency on a dynamic version of Left Pad.<p>I&#x27;d kinda like to see what Cloudflare and Let&#x27;s Encrypt could come up with if they worked together on at very least a white paper and an MVP POC.</div><br/><div id="38019722" class="c"><input type="checkbox" id="c-38019722" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019678">parent</a><span>|</span><a href="#38020546">next</a><span>|</span><label class="collapse" for="c-38019722">[-]</label><label class="expand" for="c-38019722">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s the real solution.<p>Pay somebody either internally or externally to maintain a repo of all your dependencies and point your code at that. You won&#x27;t get a left-pad incident. You won&#x27;t get a malicious .so incident (unless you mirror binaries instead of source code).<p>Like if you ran out of screws to make your product with do you walk around the street and scrounge up some? No, you go to a trusted vendor and buy the screws.</div><br/><div id="38019834" class="c"><input type="checkbox" id="c-38019834" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019722">parent</a><span>|</span><a href="#38021604">next</a><span>|</span><label class="collapse" for="c-38019834">[-]</label><label class="expand" for="c-38019834">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not suggesting scrounging.<p>I&#x27;m suggesting that the guys who&#x27;ve repeatedly proven themselves technically competent around security at scale might have a couple of useful ideas regarding how the industry might go about crawling its way out of this little security clusterfuck.<p>And perhaps even stop treating something as simple as a BOM as an enterprise feature, given that the overhead on such things is damned near zilch and the security implications are staggering.<p><a href="https:&#x2F;&#x2F;www.cisa.gov&#x2F;sbom" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cisa.gov&#x2F;sbom</a></div><br/></div></div><div id="38021604" class="c"><input type="checkbox" id="c-38021604" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019722">parent</a><span>|</span><a href="#38019834">prev</a><span>|</span><a href="#38021910">next</a><span>|</span><label class="collapse" for="c-38021604">[-]</label><label class="expand" for="c-38021604">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s reasons why Google projects don&#x27;t go out on the internet to get their 3rd party deps.<p>They&#x27;re all checked into Google3 (or chromium, etc.). One version only. With internal maintainers responsible for bringing it in and multiple people vetting it, and clear ownership over its management. E.g. you don&#x27;t just get to willy nilly depend on a new version -- if you want to upgrade what&#x27;s there, you gotta put a ring on it. If you upgrade it, you&#x27;re likely going to be upgrading it for <i>everyone</i>, and the build system will run through the dependent tests for them all, etc.<p>And the consequence is more responsible use of third party deps and less sprawling dependency trees and less complexity.<p>And additional less security concerns as the code is checked in, its license vetted, and build systems are hunting around on the Internet for artifacts.</div><br/></div></div></div></div><div id="38020546" class="c"><input type="checkbox" id="c-38020546" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019678">parent</a><span>|</span><a href="#38019722">prev</a><span>|</span><a href="#38019846">next</a><span>|</span><label class="collapse" for="c-38020546">[-]</label><label class="expand" for="c-38020546">[1 more]</label></div><br/><div class="children"><div class="content">Maven has signing and you can check the signatures on your dependencies if you care to. Most don&#x27;t, sadly.</div><br/></div></div><div id="38019846" class="c"><input type="checkbox" id="c-38019846" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019678">parent</a><span>|</span><a href="#38020546">prev</a><span>|</span><a href="#38022262">next</a><span>|</span><label class="collapse" for="c-38019846">[-]</label><label class="expand" for="c-38019846">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, all the dependencies in the maven central repository require a signature to publish them.</div><br/><div id="38019894" class="c"><input type="checkbox" id="c-38019894" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019846">parent</a><span>|</span><a href="#38022262">next</a><span>|</span><label class="collapse" for="c-38019894">[-]</label><label class="expand" for="c-38019894">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a workaround.<p>I&#x27;m not a fan of those - if the engine&#x27;s in the wrong place, then why the hell did you fucking put it there?<p>Don&#x27;t hack a patch into place to stop people from holding it wrong; design it in such a way that it&#x27;s impossible to hold wrong in the first place.</div><br/></div></div></div></div></div></div><div id="38022262" class="c"><input type="checkbox" id="c-38022262" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019678">prev</a><span>|</span><a href="#38020922">next</a><span>|</span><label class="collapse" for="c-38022262">[-]</label><label class="expand" for="c-38022262">[1 more]</label></div><br/><div class="children"><div class="content">While Java made that notation famous, it was already used in NeXTSTEP and Objective-C, hence why you will see this all over the place in macOS and derived platforms, on configuration files and services.</div><br/></div></div><div id="38020922" class="c"><input type="checkbox" id="c-38020922" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38022262">prev</a><span>|</span><a href="#38019581">next</a><span>|</span><label class="collapse" for="c-38020922">[-]</label><label class="expand" for="c-38020922">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some of these globally-claimed generic packages are not really the best package to use.<p>Or it is just a placeholder from a squatter.</div><br/></div></div><div id="38019581" class="c"><input type="checkbox" id="c-38019581" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020922">prev</a><span>|</span><a href="#38020131">next</a><span>|</span><label class="collapse" for="c-38019581">[-]</label><label class="expand" for="c-38019581">[3 more]</label></div><br/><div class="children"><div class="content">Agreed. The other thing I don’t really like is that you can’t split up things in the rust namespace hierarchy between crates (something that’s natural with jars in JVM). I would have liked to have defined things so that I could have the unicode handlers for finl live in finl::unicode, the parser in finl::parser, etc. but because they’re in separate crates rust gets upset about finl being defined twice and there’s no workaround for it. There are likely pitfalls I don’t see in what I want, so I live with it.</div><br/><div id="38019598" class="c"><input type="checkbox" id="c-38019598" checked=""/><div class="controls bullet"><span class="by">ramranch</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019581">parent</a><span>|</span><a href="#38020131">next</a><span>|</span><label class="collapse" for="c-38019598">[-]</label><label class="expand" for="c-38019598">[2 more]</label></div><br/><div class="children"><div class="content">Would re-exporting partially solve your problem?</div><br/><div id="38021295" class="c"><input type="checkbox" id="c-38021295" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019598">parent</a><span>|</span><a href="#38020131">next</a><span>|</span><label class="collapse" for="c-38021295">[-]</label><label class="expand" for="c-38021295">[1 more]</label></div><br/><div class="children"><div class="content">As I recall, I could do something where I could have a common root crate  that would import and re-export the other crates with the namespaces modified on the exports and then control which crates are exported through feature gates, but it just seemed more hassle than it was worth.</div><br/></div></div></div></div></div></div><div id="38020131" class="c"><input type="checkbox" id="c-38020131" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019581">prev</a><span>|</span><a href="#38020307">next</a><span>|</span><label class="collapse" for="c-38020131">[-]</label><label class="expand" for="c-38020131">[2 more]</label></div><br/><div class="children"><div class="content">I love this lack of namespacing personally, because it means that whatever crate you see in a project is going to be the same as the crate your see in another one. Never need to alias crate names. It happens in Golang all the time and I really think namespacing packages was a mistake there.</div><br/><div id="38020177" class="c"><input type="checkbox" id="c-38020177" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020131">parent</a><span>|</span><a href="#38020307">next</a><span>|</span><label class="collapse" for="c-38020177">[-]</label><label class="expand" for="c-38020177">[1 more]</label></div><br/><div class="children"><div class="content">Golang&#x27;s problems aren&#x27;t due to using namespaces, they&#x27;re due to delaying too many decisions until too late.<p>Go has namespacing mostly because for a long time it didn&#x27;t have a package manager at all, so people just used a bunch of ad hoc URL-based solutions mostly revolving around GitHub, which happens to have namespaces and <i>also</i> happened to lend itself to aliasing (because a whole GitHub URL is too long).<p>If you want to look at an actual example of namespacing done well, Maven&#x2F;Java is the place to look. There is no aliasing—the same imports always work across projects.</div><br/></div></div></div></div><div id="38020307" class="c"><input type="checkbox" id="c-38020307" checked=""/><div class="controls bullet"><span class="by">Grimburger</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020131">prev</a><span>|</span><a href="#38019725">next</a><span>|</span><label class="collapse" for="c-38020307">[-]</label><label class="expand" for="c-38020307">[2 more]</label></div><br/><div class="children"><div class="content">Yet to see any proof that namespacing has made things better in other ecosystems, are go style links or other types of namespaced imports any less prone to supply chain risks?<p>It&#x27;s definitely a good thing that people choose new unique names for crates rather than <i>dijan&#x2F;base64</i> vs <i>dljan&#x2F;base64</i><p>Do understand the desire of having a crate for audio manipulation called &quot;audio&quot; but at the same time how often do we end up with &quot;audio2&quot; anyway? It&#x27;s an imperfect solution for an imperfect world and I personally think the crates team got it right on this one.</div><br/><div id="38020916" class="c"><input type="checkbox" id="c-38020916" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38020307">parent</a><span>|</span><a href="#38019725">next</a><span>|</span><label class="collapse" for="c-38020916">[-]</label><label class="expand" for="c-38020916">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yet to see any proof that namespacing has made things better in other ecosystems<p>It&#x27;s really as simple as this: many libraries are generic enough implementing something that already exists. Let&#x27;s say you want a library to manage the SMTP protocol. On crates.io, of course someone has already taken the &quot;smtp&quot; crate (ironically, this one is abandoned, but has the highest download counts, because it&#x27;s the most obvious name). Let&#x27;s say you disagree with the direction this smtp crate has gone, and you make your own. What do you call it?<p>Namespaces solve this problem. You&#x27;d instead of have user1&#x2F;smtp and user2&#x2F;smtp competing in feature sets. You can even be user3&#x2F;smtp if you don&#x27;t like the first two.<p>This is precisely what Java enables too. The standard library is in com.java.*; if you don&#x27;t like how the standard library does something, you can make com.grimburger.smtp and do it yourself. If you choose to publish to the world, all the more power to you. It doesn&#x27;t conflict with the standard library&#x27;s smtp implementation.</div><br/></div></div></div></div><div id="38019725" class="c"><input type="checkbox" id="c-38019725" checked=""/><div class="controls bullet"><span class="by">Jalad</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38020307">prev</a><span>|</span><a href="#38022242">next</a><span>|</span><label class="collapse" for="c-38019725">[-]</label><label class="expand" for="c-38019725">[3 more]</label></div><br/><div class="children"><div class="content">This is a common critique, and although I don&#x27;t have insight into why the original decision to not have namespaces was made, the current outlook is that until issues related to continuity are resolved, it&#x27;s a no go:<p><a href="https:&#x2F;&#x2F;samsieber.tech&#x2F;posts&#x2F;2020&#x2F;09&#x2F;registry-structure-influence&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;samsieber.tech&#x2F;posts&#x2F;2020&#x2F;09&#x2F;registry-structure-infl...</a></div><br/><div id="38019966" class="c"><input type="checkbox" id="c-38019966" checked=""/><div class="controls bullet"><span class="by">sigwinch28</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019725">parent</a><span>|</span><a href="#38022242">next</a><span>|</span><label class="collapse" for="c-38019966">[-]</label><label class="expand" for="c-38019966">[2 more]</label></div><br/><div class="children"><div class="content">That article starts with the premise that “it’s a feature, not a bug” then goes on to describe a whole bunch of things I consider to be anti-features of a packaging system that has a flat namespace.<p>The first section says it discourages forking. I consider this to be bad. Nobody’s code should be more important purely because it squatted a better name.<p>The Identity section actually makes the case that flat registries make naming harder.<p>The section on Continuity is “we’ve tried nothing and we’re all out of ideas”. Make up an org name and grandfather all packages in the flat namespace into that special org. Also this is already a problem because packages in the flat namespace do get abandoned, then forked, and then we have the associated issues.<p>The section on Stability seems to take it as a given that crates.io should be the only registry. I don’t. It also seems to conflate cargo with rustc for the benefit of the argument.<p>The squatting section describes only anti-features and I don’t consider the author’s legitimate use cases to be legitimate reasons to squat.<p>I think the only legitimate problems that need addressing are the ergonomics of accessing namespaced packages throughout transient dependencies and backwards compatibility with non-namespaced code. But the fact that these are real problems does not, to me, make a flat namespace a “feature”. It’s just easier to implement.<p>It’s okay for it to be a mistake that takes effort and time to fix.</div><br/><div id="38020248" class="c"><input type="checkbox" id="c-38020248" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#38019532">root</a><span>|</span><a href="#38019966">parent</a><span>|</span><a href="#38022242">next</a><span>|</span><label class="collapse" for="c-38020248">[-]</label><label class="expand" for="c-38020248">[1 more]</label></div><br/><div class="children"><div class="content">Another option would be to grandfather all packages into their own org. So serde becomes serde&#x2F;serde. This way you don&#x27;t need to manage permission rules in the legacy &quot;all&quot; namespace.<p>You get some oddities such as serde-derive&#x2F;serde-derive but the package owners can choose if they want to move to serde&#x2F;derive or leave it in a separate namespace.</div><br/></div></div></div></div></div></div><div id="38022242" class="c"><input type="checkbox" id="c-38022242" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38019725">prev</a><span>|</span><a href="#38019686">next</a><span>|</span><label class="collapse" for="c-38022242">[-]</label><label class="expand" for="c-38022242">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see the problem. Even with namespaces you&#x27;ll have<p>brandonq&#x2F;xml vs parsers&#x2F;xml with no clue if one is better then another.<p>Also possibly with some confusion over whether things with the same name are forks or not. May make it a little more difficult to Google. Why not just have brandon_xml vs xml-parser and have a community list of best and most popular libraries?<p>I guess the only issue is that some generic&#x2F;obvious package names are bad packages. That can have been avoided if they banned&#x2F;self-squated most of the names. I suppose if you use dns namespaces and actually tie it to ownership of the domain name it might make sense but that would also cause issues(what if you forgot to renew the domain?).</div><br/></div></div><div id="38019686" class="c"><input type="checkbox" id="c-38019686" checked=""/><div class="controls bullet"><span class="by">cetra3</span><span>|</span><a href="#38019532">parent</a><span>|</span><a href="#38022242">prev</a><span>|</span><a href="#38023003">next</a><span>|</span><label class="collapse" for="c-38019686">[-]</label><label class="expand" for="c-38019686">[1 more]</label></div><br/><div class="children"><div class="content">I think most people are in support of namespacing but it&#x27;s a big change and will take a while to see through.</div><br/></div></div></div></div><div id="38023003" class="c"><input type="checkbox" id="c-38023003" checked=""/><div class="controls bullet"><span class="by">q8840</span><span>|</span><a href="#38019532">prev</a><span>|</span><a href="#38022680">next</a><span>|</span><label class="collapse" for="c-38023003">[-]</label><label class="expand" for="c-38023003">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad to see there&#x27;s a wide range of opinions here.<p>I&#x27;m not too concerned with performance or safety (since my code hasn&#x27;t been seen very often).<p>I use rust just because it has a lot of &quot;libraries that help me develop&quot;.<p>While other language libraries have a poor search experience and ranking system, Rust has a great library search system.<p>I use it because I don&#x27;t have to read blog posts like C&#x2F;C++ or java to find libraries that help me develop, or wade through unnecessary libraries like C# or go, I can use the rankings, and it has a good documentation system.</div><br/><div id="38023149" class="c"><input type="checkbox" id="c-38023149" checked=""/><div class="controls bullet"><span class="by">nlnn</span><span>|</span><a href="#38023003">parent</a><span>|</span><a href="#38022680">next</a><span>|</span><label class="collapse" for="c-38023149">[-]</label><label class="expand" for="c-38023149">[1 more]</label></div><br/><div class="children"><div class="content">This has mostly been my experience too. I like using Rust because it reduces the cognitive load I have to deal with for many things (performance&#x2F;safety are nice, but not a priority).<p>As you&#x27;ve said, finding great libraries is easy, and so is adding&#x2F;building them. I find this a nice change from e.g. Python (where there are so many way of different competing ways dealing with packaging&#x2F;dependencies).<p>Also thanks to the error handling, sum types and the like, I don&#x27;t have to worry so much that I&#x27;ve deal with all errors, handled all enum variants, etc., the compiler takes care of that.</div><br/></div></div></div></div><div id="38022680" class="c"><input type="checkbox" id="c-38022680" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38023003">prev</a><span>|</span><a href="#38019985">next</a><span>|</span><label class="collapse" for="c-38022680">[-]</label><label class="expand" for="c-38022680">[5 more]</label></div><br/><div class="children"><div class="content">Some days I have misgivings, but not about the language. About the crate situation. Too many important low-level crates stuck at 0.x. I&#x27;ve previously written about problems with the high-performance 3D graphics libraries, but only game devs care about those.<p>At the language level, the big problem is back references. Sometimes you do need them, and the only safe way to do them at present involves reference counts in the forward direction and weak references in the back direction. Then you have to call .borrow() and .upgrade() too much. I&#x27;d love to see a static analysis solution to that.<p>(Rough outline of such a solution: Owning object belongs to Owner trait. Owned object belongs to Owned trait. Owned object has .owner() and .owner_mut() functions which retrieve references to the owner.
Owners probably have to be pinned, so they can&#x27;t move while a back-reference exists. If an Owner changes a reference to an Owned object, the back reference is automatically updated.<p>That&#x27;s the easy part. Now figure out how to prove by static analysis that a specific use of this does not violate Rust&#x27;s no-aliasing rules (N read-only, or 1 mutable). This looks do-able for the non-mutable case, because having a non-mutable reference to both owned and owner is OK. Mutability, though, is tough. Anybody thinking about this?)</div><br/><div id="38022839" class="c"><input type="checkbox" id="c-38022839" checked=""/><div class="controls bullet"><span class="by">Asraelite</span><span>|</span><a href="#38022680">parent</a><span>|</span><a href="#38022716">next</a><span>|</span><label class="collapse" for="c-38022839">[-]</label><label class="expand" for="c-38022839">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Now figure out how to prove by static analysis that a specific use of this does not violate Rust&#x27;s no-aliasing rules (N read-only, or 1 mutable).<p>Out of curiosity, is there any existing language (including research languages) that can do this already?</div><br/></div></div><div id="38022716" class="c"><input type="checkbox" id="c-38022716" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#38022680">parent</a><span>|</span><a href="#38022839">prev</a><span>|</span><a href="#38019985">next</a><span>|</span><label class="collapse" for="c-38022716">[-]</label><label class="expand" for="c-38022716">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Too many important low-level crates stuck at 0.x.<p>Is it fair to say that Rust failed to supply a robust set of standard libraries comparable to other modern languages? Or was the language aimed at level geared towards implementing rather than providing libraries? If it&#x27;s truly a systems language, then what library features are essential, and what are &#x27;nice to have&#x27;?</div><br/><div id="38022837" class="c"><input type="checkbox" id="c-38022837" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#38022680">root</a><span>|</span><a href="#38022716">parent</a><span>|</span><a href="#38022808">next</a><span>|</span><label class="collapse" for="c-38022837">[-]</label><label class="expand" for="c-38022837">[1 more]</label></div><br/><div class="children"><div class="content">IMHO a lot of these 0.x libraries would be called 3.<i>.</i> In other languages
S.<p>They often have better quality than what I find in &quot;mature&quot; packages in npm or PyPi.<p>Rust kind of has a perfectionist touch to it which makes it really hard to say &quot;this public API is stable&quot;. So people stay at 0.<i>.</i> way longer than normal.<p>I&#x27;m fine with that.<p>The lack of namespacing and heavy namesquatting is rather what&#x27;s annoying.</div><br/></div></div><div id="38022808" class="c"><input type="checkbox" id="c-38022808" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38022680">root</a><span>|</span><a href="#38022716">parent</a><span>|</span><a href="#38022837">prev</a><span>|</span><a href="#38019985">next</a><span>|</span><label class="collapse" for="c-38022808">[-]</label><label class="expand" for="c-38022808">[1 more]</label></div><br/><div class="children"><div class="content">There was a conscious decision to avoid providing a vast standard library because those inevitably become outdated with time. Building a standard library is relatively easy, maintaining for decades is hard.<p>But it’s a trade off because there are concrete upsides to a large standard library. I wrote about this more - Rust has a small standard library (and that’s ok) - <a href="https:&#x2F;&#x2F;blog.nindalf.com&#x2F;posts&#x2F;rust-stdlib&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.nindalf.com&#x2F;posts&#x2F;rust-stdlib&#x2F;</a></div><br/></div></div></div></div></div></div><div id="38019985" class="c"><input type="checkbox" id="c-38019985" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#38022680">prev</a><span>|</span><a href="#38019991">next</a><span>|</span><label class="collapse" for="c-38019985">[-]</label><label class="expand" for="c-38019985">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It also looks like (soon) you’ll finally be able to configure global lints for a project. Until now, you had to hack your solution to keep lints consistent for projects.<p>&gt; I questioned my sanity every time I circled back around to the Clippy issue above. Surely, I was wrong. There must be a configuration I missed. I couldn’t believe it. I still can’t. Surely there must be a way to configure lints globally. I quadruple-checked when I wrote this to make sure I wasn’t delusional.<p>You create a .cargo&#x2F;config.toml in the workspace root so it covers all your crates.<p>inside the file:<p><pre><code>  [build]
  rustflags = [&quot;-Wclippy::lint_name_to_warn&quot;, &quot;-Dclippy::lint_name_to_deny&quot;]
</code></pre>
The only limitation is that rustflags are not additive, so if you have other sources of rustflags like the RUSTFLAGS environment variable it will overwrite this setting.</div><br/><div id="38021208" class="c"><input type="checkbox" id="c-38021208" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#38019985">parent</a><span>|</span><a href="#38019991">next</a><span>|</span><label class="collapse" for="c-38021208">[-]</label><label class="expand" for="c-38021208">[1 more]</label></div><br/><div class="children"><div class="content">We just have a script that adds the lints to any lib.rs or main.rs files that runs on commit. ezpz</div><br/></div></div></div></div><div id="38019991" class="c"><input type="checkbox" id="c-38019991" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38019985">prev</a><span>|</span><a href="#38019671">next</a><span>|</span><label class="collapse" for="c-38019991">[-]</label><label class="expand" for="c-38019991">[14 more]</label></div><br/><div class="children"><div class="content">Programming in Rust is really not like being in an abusive relationship. The compiler is trying to help out as much as possible, especially since rustc has the best error messages in the world.</div><br/><div id="38020326" class="c"><input type="checkbox" id="c-38020326" checked=""/><div class="controls bullet"><span class="by">emporas</span><span>|</span><a href="#38019991">parent</a><span>|</span><a href="#38020949">next</a><span>|</span><label class="collapse" for="c-38020326">[-]</label><label class="expand" for="c-38020326">[2 more]</label></div><br/><div class="children"><div class="content">The OSes want programmers to handle resources correctly, and the Rust compiler makes that task a breeze. We are in a more abusive relationship with our OSes, than the Rust compiler. How about the hardware? Doesn&#x27;t that need to run assembly in a correct way? That counts as an abusive relationship as well.<p>Rust&#x27;s error messages are one of a kind. There no other compiler which comes even close.<p>As a side note, i used latex lately, it&#x27;s error messages are horrendous. What a nightmare to figure out what&#x27;s wrong by inspecting the error.</div><br/><div id="38022952" class="c"><input type="checkbox" id="c-38022952" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#38019991">root</a><span>|</span><a href="#38020326">parent</a><span>|</span><a href="#38020949">next</a><span>|</span><label class="collapse" for="c-38022952">[-]</label><label class="expand" for="c-38022952">[1 more]</label></div><br/><div class="children"><div class="content">Rustc is so good I learnt a lot about the language by just reading errors.</div><br/></div></div></div></div><div id="38020949" class="c"><input type="checkbox" id="c-38020949" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#38019991">parent</a><span>|</span><a href="#38020326">prev</a><span>|</span><a href="#38020114">next</a><span>|</span><label class="collapse" for="c-38020949">[-]</label><label class="expand" for="c-38020949">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The compiler is trying to help out as much as possible, especially since rustc has the best error messages in the world.<p>Generally good, but man do I hate how any error in my async function causes every recursive call site to generate an error about how the Future is no longer Send and Sync. Literally an entire console scrollback of errors with the actual syntax error buried somewhere in the middle.</div><br/><div id="38021255" class="c"><input type="checkbox" id="c-38021255" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38019991">root</a><span>|</span><a href="#38020949">parent</a><span>|</span><a href="#38020114">next</a><span>|</span><label class="collapse" for="c-38021255">[-]</label><label class="expand" for="c-38021255">[2 more]</label></div><br/><div class="children"><div class="content">I believe this is in our radar and waiting on the new trait solver, but just in case if you have a repro I would appreciate a ticket to improve the diagnostic.</div><br/><div id="38023049" class="c"><input type="checkbox" id="c-38023049" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#38019991">root</a><span>|</span><a href="#38021255">parent</a><span>|</span><a href="#38020114">next</a><span>|</span><label class="collapse" for="c-38023049">[-]</label><label class="expand" for="c-38023049">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4c0c32f255e65594369556fb3589d3ae" rel="nofollow noreferrer">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>In this case, the first two errors are clear. The next 3 provide multiple, redundant context blocks. The upshot is that this simple example results in rustc printing 11 lines of useful error messages and 86 lines of useless messages. Add to that the fact that the useful error messages need not be at the top or bottom of the error list, they can be anywhere inside of it, depending on the declaration order.</div><br/></div></div></div></div></div></div></div></div><div id="38019671" class="c"><input type="checkbox" id="c-38019671" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#38019991">prev</a><span>|</span><a href="#38020045">next</a><span>|</span><label class="collapse" for="c-38019671">[-]</label><label class="expand" for="c-38019671">[15 more]</label></div><br/><div class="children"><div class="content">&gt; I started writing tests in Rust as I would in any other language but found that I was writing tests couldn’t fail.<p>This is a common refrain in C++ testing: if it compiles then it&#x27;s probably correct.<p>&gt; Rust has accounted for so many errors that many common test cases become irrelevant<p>In practice, if you think this way I think it&#x27;s a sign that you aren&#x27;t testing the right things in those other languages. You should be testing business logic, not language stuff.<p>If you look at your test code and think &quot;I would test this in JavaScript, but I don&#x27;t need to do that in Rust&quot; then just delete the test.</div><br/><div id="38019763" class="c"><input type="checkbox" id="c-38019763" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38019671">parent</a><span>|</span><a href="#38020030">next</a><span>|</span><label class="collapse" for="c-38019763">[-]</label><label class="expand" for="c-38019763">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is a common refrain in C++ testing: if it compiles then it&#x27;s probably correct.<p>I’ve heard this in Haskell and in Rust. I’ve never heard it applied to C++…</div><br/><div id="38021117" class="c"><input type="checkbox" id="c-38021117" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38019763">parent</a><span>|</span><a href="#38021608">next</a><span>|</span><label class="collapse" for="c-38021117">[-]</label><label class="expand" for="c-38021117">[1 more]</label></div><br/><div class="children"><div class="content">I’ve definitely experienced it in Haskell and Rust. I can believe <i>some</i> C++ could be that way, but I’ve never experienced it, but then again those projects didn’t have useful tests either. I think with C++ a lot of this depends on domain and the quality of the code and libraries.</div><br/></div></div><div id="38021608" class="c"><input type="checkbox" id="c-38021608" checked=""/><div class="controls bullet"><span class="by">xhainingx</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38019763">parent</a><span>|</span><a href="#38021117">prev</a><span>|</span><a href="#38019909">next</a><span>|</span><label class="collapse" for="c-38021608">[-]</label><label class="expand" for="c-38021608">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s truer in C++ than java or similar languages ime since java relies more on exceptions, but it&#x27;s certainly not as true as Haskell or rust</div><br/><div id="38021778" class="c"><input type="checkbox" id="c-38021778" checked=""/><div class="controls bullet"><span class="by">Skunkleton</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38021608">parent</a><span>|</span><a href="#38019909">next</a><span>|</span><label class="collapse" for="c-38021778">[-]</label><label class="expand" for="c-38021778">[1 more]</label></div><br/><div class="children"><div class="content">Is it true enough in c++ to be useful though?</div><br/></div></div></div></div><div id="38019909" class="c"><input type="checkbox" id="c-38019909" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38019763">parent</a><span>|</span><a href="#38021608">prev</a><span>|</span><a href="#38020030">next</a><span>|</span><label class="collapse" for="c-38019909">[-]</label><label class="expand" for="c-38019909">[1 more]</label></div><br/><div class="children"><div class="content">I think they meant Rust? Rust definitely has that property to an extent; C++ is so far from it it’s not even funny.</div><br/></div></div></div></div><div id="38020030" class="c"><input type="checkbox" id="c-38020030" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#38019671">parent</a><span>|</span><a href="#38019763">prev</a><span>|</span><a href="#38020457">next</a><span>|</span><label class="collapse" for="c-38020030">[-]</label><label class="expand" for="c-38020030">[5 more]</label></div><br/><div class="children"><div class="content">A null pointer exception is a bug that breaks business logic. There&#x27;s no &quot;business logic instead of language stuff&quot; because the language stuff is the foundation that business logic rests on. If you don&#x27;t test against failure modes, what&#x27;s even the point in testing?</div><br/><div id="38020152" class="c"><input type="checkbox" id="c-38020152" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020030">parent</a><span>|</span><a href="#38020457">next</a><span>|</span><label class="collapse" for="c-38020152">[-]</label><label class="expand" for="c-38020152">[4 more]</label></div><br/><div class="children"><div class="content">To close the loop, Rust doesn&#x27;t include a `null` type and you wouldn&#x27;t encounter something comparable in idiomatic Rust (because you&#x27;d be using eg Option::map to handle None cases gracefully), so this is a class of test that would be common in Java and C that is close to irrelevant in Rust.</div><br/><div id="38020616" class="c"><input type="checkbox" id="c-38020616" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020152">parent</a><span>|</span><a href="#38020457">next</a><span>|</span><label class="collapse" for="c-38020616">[-]</label><label class="expand" for="c-38020616">[3 more]</label></div><br/><div class="children"><div class="content">To be more specific, Rust <i>does</i> have among other things:<p>std::ptr::null() - an actual null pointer, probably the zero address on your hardware, and this isn&#x27;t even an unsafe function. On the other hand, you won&#x27;t find many uses for a null pointer so, I mean, congrats on obtaining one and good luck with that.<p>std::ptr::null_mut() - a mutable null pointer, similarly unlikely to be of any use to you in safe Rust, but also not an unsafe thing to ask for.<p>But, these are pointers, so they&#x27;re not values that say, a String could take, or a Vec&lt;String&gt; or whatever, only actual raw pointers can be null.</div><br/><div id="38020746" class="c"><input type="checkbox" id="c-38020746" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020616">parent</a><span>|</span><a href="#38020829">prev</a><span>|</span><a href="#38020457">next</a><span>|</span><label class="collapse" for="c-38020746">[-]</label><label class="expand" for="c-38020746">[1 more]</label></div><br/><div class="children"><div class="content">And even for raw pointers you can use NonNull&lt;T&gt;.</div><br/></div></div></div></div></div></div></div></div><div id="38020457" class="c"><input type="checkbox" id="c-38020457" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38019671">parent</a><span>|</span><a href="#38020030">prev</a><span>|</span><a href="#38020045">next</a><span>|</span><label class="collapse" for="c-38020457">[-]</label><label class="expand" for="c-38020457">[4 more]</label></div><br/><div class="children"><div class="content">There is surely something wonderful about the kind of C++ programmer who figures that, since their unusable broken garbage compiled it&#x27;s probably correct.<p>Remember unlike most languages you&#x27;d be familiar with C++ has IFNDR, which has been jokingly referred to as &quot;False positives for the question: Is this a C++ program?&quot;. A conforming C++ compiler is <i>forbidden</i> from telling you in some† unknown number of cases that it suspects what you&#x27;ve written is nonsense, it just has to press on and output... something. Is it a working executable? Could be. Or maybe it&#x27;s exactly like a working executable except it explodes catastrophically on Fridays. No way to know.<p>† The ISO standard does identify these cases, but they&#x27;re so vague that it&#x27;s hard to pin down everything which is covered. My guess is that all or most non-trivial C++ software is actually IFNDR these days. Just say No to the entire language.</div><br/><div id="38020571" class="c"><input type="checkbox" id="c-38020571" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020457">parent</a><span>|</span><a href="#38020629">next</a><span>|</span><label class="collapse" for="c-38020571">[-]</label><label class="expand" for="c-38020571">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A conforming C++ compiler is forbidden from telling you in some† unknown number of cases that it suspects what you&#x27;ve written is nonsense, it just has to press on and output... something.<p>It&#x27;s not quite that bad - a conforming C++ compiler is permitted to error out and not compile the program. It just doesn&#x27;t have to.</div><br/></div></div><div id="38020629" class="c"><input type="checkbox" id="c-38020629" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020457">parent</a><span>|</span><a href="#38020571">prev</a><span>|</span><a href="#38020045">next</a><span>|</span><label class="collapse" for="c-38020629">[-]</label><label class="expand" for="c-38020629">[2 more]</label></div><br/><div class="children"><div class="content">Can you give an example of non-C++ code that a modern compiler (MSVC, clang, g++ or something) successfully compiles with no diagnostics? I’m genuinely curious. If not, this just sounds like more C++ FUD because the spec doesn’t define everything under the sun and allows a certain amount of leeway to compilers for things like emitting different error diagnostics.</div><br/><div id="38021563" class="c"><input type="checkbox" id="c-38021563" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38019671">root</a><span>|</span><a href="#38020629">parent</a><span>|</span><a href="#38020045">next</a><span>|</span><label class="collapse" for="c-38021563">[-]</label><label class="expand" for="c-38021563">[1 more]</label></div><br/><div class="children"><div class="content">Consider:<p><pre><code>  #define _FOO
  int main() {}
</code></pre>
Per the C++ standard ([lex.name]&#x2F;3), this program is ill-formed:<p>&gt; In addition, some identifiers appearing as a <i>token</i> or <i>preprocessing-token</i> are reserved for use by C++ implementations and shall not be used otherwise; no diagnostic is required. [...] Each identifier that contains a double underscore __ or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.<p>Thus, the compiler theoretically has the liberty to emit whatever it wants for this program.<p>Neither GCC nor Clang produces a warning under -std=c++20 -Wall -Wextra (Clang only produces a -Wreserved-macro-identifier under -Weverything), and MSVC doesn&#x27;t produce a warning under &#x2F;std:c++20 &#x2F;Wall.<p>In practice, most examples of ill-formed programs where compilers issue no warnings occur with discrepancies between different source files that are linked together; e.g., declaring a function as inline in one file but non-inline in another, or declaring a function with two different sets of default arguments in different files, or defining the same non-inline variable or function in different files, or defining the same inline function differently in different files.</div><br/></div></div></div></div></div></div></div></div><div id="38020045" class="c"><input type="checkbox" id="c-38020045" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38019671">prev</a><span>|</span><a href="#38019584">next</a><span>|</span><label class="collapse" for="c-38020045">[-]</label><label class="expand" for="c-38020045">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;m learning Rust because it seems clear that it&#x27;s going to be important professionally. I wish I loved it, I really do. I see the benefits. But, at least so far, it&#x27;s one of the most unpleasant languages I&#x27;ve used. I keep hoping that as I gain proficiency, I&#x27;ll stop disliking it, but as I climb higher on the learning curve, I&#x27;m not really warming to it.<p>It&#x27;s fine. It won&#x27;t be the only language I&#x27;ll be proficient in while being averse to it at the same time. But I heard so many people proclaiming their love for it that I expected to enjoy it, too.</div><br/><div id="38021318" class="c"><input type="checkbox" id="c-38021318" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38020836">next</a><span>|</span><label class="collapse" for="c-38021318">[-]</label><label class="expand" for="c-38021318">[1 more]</label></div><br/><div class="children"><div class="content">As a counter example, I love programming in Rust. Fighting the borrow checker ended a long time ago. Even the errors are rare these days, except in cases I trigger them in order to examine the types. Rust compiler also seems to have improved in accepting broader cases that are valid.<p>For me, the key to understanding the borrow checker was understanding the underlying memory model. Rust memory model is the same as that of C, with some extensions for abstractions like generics. The borrow checker rules seem arbitrary at first. But it&#x27;s deeply correlated to this memory model. The real value of the borrow checker is when I trigger it unintentionally. Those are bugs that I made due to lapse in attention. What scares me is that another language like C or C++ might simply accept it and proceed.<p>Yet another pleasant side effect of Rust&#x27;s strict type system and borrow checker is that they gently nudge you to properly structure your code. I can say for certain that Rust has improved my code design in all the languages that I use.</div><br/></div></div><div id="38020836" class="c"><input type="checkbox" id="c-38020836" checked=""/><div class="controls bullet"><span class="by">peterashford</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38021318">prev</a><span>|</span><a href="#38021271">next</a><span>|</span><label class="collapse" for="c-38020836">[-]</label><label class="expand" for="c-38020836">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried several times to get into Rust and keep bouncing off it. It just feels so non-ergonomic.</div><br/></div></div><div id="38021271" class="c"><input type="checkbox" id="c-38021271" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38020836">prev</a><span>|</span><a href="#38020138">next</a><span>|</span><label class="collapse" for="c-38021271">[-]</label><label class="expand" for="c-38021271">[2 more]</label></div><br/><div class="children"><div class="content">The lack of default&#x2F;named function arguments is what still gets me. It&#x27;s such an absolute basic programmer ergonomics feature shared by most popular languages; even C++ has had defaults since forever.</div><br/><div id="38021403" class="c"><input type="checkbox" id="c-38021403" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38021271">parent</a><span>|</span><a href="#38020138">next</a><span>|</span><label class="collapse" for="c-38021403">[-]</label><label class="expand" for="c-38021403">[1 more]</label></div><br/><div class="children"><div class="content">It would have been nice for Rust to have Default&#x2F;named&#x2F;optional function arguments because the proliferation of slightly differently named functions that do the same thing would go away.</div><br/></div></div></div></div><div id="38020138" class="c"><input type="checkbox" id="c-38020138" checked=""/><div class="controls bullet"><span class="by">fawadasaurus</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38021271">prev</a><span>|</span><a href="#38020538">next</a><span>|</span><label class="collapse" for="c-38020138">[-]</label><label class="expand" for="c-38020138">[1 more]</label></div><br/><div class="children"><div class="content">The beatings will continue until morale improves.</div><br/></div></div><div id="38020538" class="c"><input type="checkbox" id="c-38020538" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38020138">prev</a><span>|</span><a href="#38020770">next</a><span>|</span><label class="collapse" for="c-38020538">[-]</label><label class="expand" for="c-38020538">[3 more]</label></div><br/><div class="children"><div class="content">Well, what do you dislike about it?</div><br/><div id="38021577" class="c"><input type="checkbox" id="c-38021577" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38020538">parent</a><span>|</span><a href="#38020770">next</a><span>|</span><label class="collapse" for="c-38021577">[-]</label><label class="expand" for="c-38021577">[2 more]</label></div><br/><div class="children"><div class="content">Good question! There&#x27;s no single thing, I think, and the things I dislike about it aren&#x27;t even really technical criticism or the like. They&#x27;re more... aesthetic? I find the syntax unpleasant, for instance. It&#x27;s extremely opinionated and a few of those opinions are ones I disagree with.<p>Also, just generally, it tends to make even simple things pretty complex. I understand why and am not really objecting to that, but it does make using it a bit like running with lead shoes.<p>I expect that the latter part may get better as I use it more (but perhaps not -- there are other languages I&#x27;m fully competent in but dislike for similar reasons).</div><br/><div id="38023099" class="c"><input type="checkbox" id="c-38023099" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38021577">parent</a><span>|</span><a href="#38020770">next</a><span>|</span><label class="collapse" for="c-38023099">[-]</label><label class="expand" for="c-38023099">[1 more]</label></div><br/><div class="children"><div class="content">I share your sentiment about Rust. Fine language for sure, I just don&#x27;t enjoy programming in it. Simply put, I don&#x27;t like using the abstractions that the language encourages.<p>For what it is worth, I found pursuing Zig to be a breath of fresh air. It&#x27;s a promising alternative in the same space as C (and also Cpp and Rust). Checkout Andrew Kelley&#x27;s introduction to the language.</div><br/></div></div></div></div></div></div><div id="38020770" class="c"><input type="checkbox" id="c-38020770" checked=""/><div class="controls bullet"><span class="by">two_handfuls</span><span>|</span><a href="#38020045">parent</a><span>|</span><a href="#38020538">prev</a><span>|</span><a href="#38019584">next</a><span>|</span><label class="collapse" for="c-38020770">[-]</label><label class="expand" for="c-38020770">[5 more]</label></div><br/><div class="children"><div class="content">Find a tutor or mentor. It can make a huge difference.</div><br/><div id="38021588" class="c"><input type="checkbox" id="c-38021588" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38020770">parent</a><span>|</span><a href="#38021631">next</a><span>|</span><label class="collapse" for="c-38021588">[-]</label><label class="expand" for="c-38021588">[1 more]</label></div><br/><div class="children"><div class="content">In what way? I&#x27;m not really struggling much with the mechanics or logic of it...</div><br/></div></div><div id="38021631" class="c"><input type="checkbox" id="c-38021631" checked=""/><div class="controls bullet"><span class="by">mamp</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38020770">parent</a><span>|</span><a href="#38021588">prev</a><span>|</span><a href="#38019584">next</a><span>|</span><label class="collapse" for="c-38021631">[-]</label><label class="expand" for="c-38021631">[3 more]</label></div><br/><div class="children"><div class="content">ChatGPT has helped me survive learning Rust.</div><br/><div id="38021753" class="c"><input type="checkbox" id="c-38021753" checked=""/><div class="controls bullet"><span class="by">63</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38021631">parent</a><span>|</span><a href="#38019584">next</a><span>|</span><label class="collapse" for="c-38021753">[-]</label><label class="expand" for="c-38021753">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the opposite of my experience. The Rust book helped a lot and going to chatGPT for additional questions usually ended up with bad answers.</div><br/><div id="38022962" class="c"><input type="checkbox" id="c-38022962" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#38020045">root</a><span>|</span><a href="#38021753">parent</a><span>|</span><a href="#38019584">next</a><span>|</span><label class="collapse" for="c-38022962">[-]</label><label class="expand" for="c-38022962">[1 more]</label></div><br/><div class="children"><div class="content">People should specify which version of GPT they are using.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38019584" class="c"><input type="checkbox" id="c-38019584" checked=""/><div class="controls bullet"><span class="by">throwaway914</span><span>|</span><a href="#38020045">prev</a><span>|</span><a href="#38019603">next</a><span>|</span><label class="collapse" for="c-38019584">[-]</label><label class="expand" for="c-38019584">[26 more]</label></div><br/><div class="children"><div class="content">I feel like Rust finally broke the idea that programmers should be in complete control and completely conscious of everything the compiler is doing.  It hasn&#x27;t been that way in decades, compilers are freaking magic.  But Rust undid a lot of that with borrowing.  People became comfortable with the compiler knowing better than them.  I just wish we could relax further:  We should never be explicitly iterating forward over a collection unless we need this behavior for the algorithm.  Things should be implicitly parallel.  Etc.  Give me rusty bash.</div><br/><div id="38020815" class="c"><input type="checkbox" id="c-38020815" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38019687">next</a><span>|</span><label class="collapse" for="c-38020815">[-]</label><label class="expand" for="c-38020815">[1 more]</label></div><br/><div class="children"><div class="content">That seems entirely opposite to my Rust experience.<p>Rust is quite transparent in what it does, and is very conservative with compiler magic. The language doesn’t do heap allocations, doesn’t do reference counting, it doesn’t even have implicit numeric type conversion. It won’t implicitly copy types that did not ask to be implicitly copyable, and even that is only legal for types that can be copied with a simple shallow memcpy.<p>Rust uses zero-cost abstractions all over the place, which means it’s predictable what code they will compile to, and that will be typically something simple. Std types have well-known basic layout, so you know that e.g. iteration over a Vec is going to be a loop incrementing a pointer, and there’s no implicit parallelism.<p>Describing borrowing as “compiler knowing better than the programmer” is a weird way of looking at it. Borrowing is like type checking. You declare a type to be temporary, and try to use it as long-lived, you get an error. It’s the same as if you declare function to return struct Foo, but returned struct Bar instead. Yes, compiler “knows better than you”, because you just wrote a bug.<p>Borrowing still compiles to direct pointer usage without a GC (it’s literally guaranteed to be identical to a C pointer in C ABI structs and functions), and you can override lifetimes with unsafe if you think know better than the compiler.</div><br/></div></div><div id="38019687" class="c"><input type="checkbox" id="c-38019687" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38020815">prev</a><span>|</span><a href="#38019731">next</a><span>|</span><label class="collapse" for="c-38019687">[-]</label><label class="expand" for="c-38019687">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  We should never be explicitly iterating forward over a collection unless we need this behavior for the algorithm. Things should be implicitly parallel<p>There is already a crate providing parallel iterators. You just rename the iter() call and that&#x27;s it. I don&#x27;t agree it should be implicit though.</div><br/><div id="38019933" class="c"><input type="checkbox" id="c-38019933" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38019687">parent</a><span>|</span><a href="#38019731">next</a><span>|</span><label class="collapse" for="c-38019933">[-]</label><label class="expand" for="c-38019933">[1 more]</label></div><br/><div class="children"><div class="content">It’s called Rayon for anyone who wants to know.</div><br/></div></div></div></div><div id="38019731" class="c"><input type="checkbox" id="c-38019731" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38019687">prev</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38019731">[-]</label><label class="expand" for="c-38019731">[7 more]</label></div><br/><div class="children"><div class="content">I think &quot;not in control of what the compiler is doing&quot; is overstating things a little bit. In some ways, Rust gives the programmer more control than C does. For example, Rust has standardized support for inline assembly, but inline assembly in C relies on vendor-specific extensions.<p>But to your point, the <i>convenient defaults</i> are very different. Unsafe typecasts require a lot of ceremony and careful thought in Rust, and they have to follow more rules than in C. In particular, references are all effectively &quot;restrict&quot; in Rust, and it&#x27;s really easy to screw that up when you do unsafe cast from raw pointers to safe references, which is a big incentive not to write code like that if you have a choice.</div><br/><div id="38020632" class="c"><input type="checkbox" id="c-38020632" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38019731">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38020632">[-]</label><label class="expand" for="c-38020632">[6 more]</label></div><br/><div class="children"><div class="content">&gt; but inline assembly in C relies on vendor-specific extensions.<p>Whereas Rust is a standard with multiple implementations?</div><br/><div id="38020688" class="c"><input type="checkbox" id="c-38020688" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020632">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38020688">[-]</label><label class="expand" for="c-38020688">[5 more]</label></div><br/><div class="children"><div class="content">I should&#x27;ve said &quot;stabilized&quot; instead of &quot;standardized&quot; to avoid stepping on this conversational landmine. But an important practical difference is that Rust supports inline assembly on Windows. (Correct me if I&#x27;m wrong, but I think MSVC mostly does not support inline asm.)</div><br/><div id="38020898" class="c"><input type="checkbox" id="c-38020898" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020688">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38020898">[-]</label><label class="expand" for="c-38020898">[4 more]</label></div><br/><div class="children"><div class="content">It does support inline assembly [1]. However, it&#x27;s different than the way GCC supports inline assembly. It seems nicer, TBH.<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;assembler&#x2F;inline&#x2F;inline-assembler?view=msvc-170" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;assembler&#x2F;inline&#x2F;inlin...</a></div><br/><div id="38020942" class="c"><input type="checkbox" id="c-38020942" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020898">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38020942">[-]</label><label class="expand" for="c-38020942">[3 more]</label></div><br/><div class="children"><div class="content">From that source:<p>&gt; Inline assembly is not supported on the ARM and x64 processors.</div><br/><div id="38021070" class="c"><input type="checkbox" id="c-38021070" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020942">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38021070">[-]</label><label class="expand" for="c-38021070">[2 more]</label></div><br/><div class="children"><div class="content">Oh, my bad. I should have read the source more closely. I hadn&#x27;t realized only 32-bit x86 processors were supported.</div><br/><div id="38021163" class="c"><input type="checkbox" id="c-38021163" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38021070">parent</a><span>|</span><a href="#38019782">next</a><span>|</span><label class="collapse" for="c-38021163">[-]</label><label class="expand" for="c-38021163">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s hilarious. Like, the compiler team had ONE GUY that believed in and developed this feature and retired in 1999.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38019782" class="c"><input type="checkbox" id="c-38019782" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38019731">prev</a><span>|</span><a href="#38020359">next</a><span>|</span><label class="collapse" for="c-38019782">[-]</label><label class="expand" for="c-38019782">[3 more]</label></div><br/><div class="children"><div class="content">As someone who does a lot of unsafe rust, including tagged pointer foo, I strongly disagree.<p>If anything I want more explicit control, alleviated with an even more expressive type system. Ideally rusts type system would just be a prolog variant imho.</div><br/><div id="38022101" class="c"><input type="checkbox" id="c-38022101" checked=""/><div class="controls bullet"><span class="by">throwaway914</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38019782">parent</a><span>|</span><a href="#38020078">next</a><span>|</span><label class="collapse" for="c-38022101">[-]</label><label class="expand" for="c-38022101">[1 more]</label></div><br/><div class="children"><div class="content">Anyone that can reliably and off-the-cuff do all of these can have complete control back:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Category:Compiler_optimizations" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Category:Compiler_optimization...</a><p>Otherwise we should trust compilers to know better.</div><br/></div></div><div id="38020078" class="c"><input type="checkbox" id="c-38020078" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38019782">parent</a><span>|</span><a href="#38022101">prev</a><span>|</span><a href="#38020359">next</a><span>|</span><label class="collapse" for="c-38020078">[-]</label><label class="expand" for="c-38020078">[1 more]</label></div><br/><div class="children"><div class="content">No thanks. Rust compile times are already too slow.</div><br/></div></div></div></div><div id="38020359" class="c"><input type="checkbox" id="c-38020359" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38019782">prev</a><span>|</span><a href="#38020841">next</a><span>|</span><label class="collapse" for="c-38020359">[-]</label><label class="expand" for="c-38020359">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Give me rusty bash.<p>Bash with types (especially floats), fewer edge cases, functions with explicit parameters, simple command line flags...</div><br/><div id="38020429" class="c"><input type="checkbox" id="c-38020429" checked=""/><div class="controls bullet"><span class="by">AgentME</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020359">parent</a><span>|</span><a href="#38022631">next</a><span>|</span><label class="collapse" for="c-38020429">[-]</label><label class="expand" for="c-38020429">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re skipping the most needed improvement of all: fixing the issue where scripts with unquoted variables will seem to work until they contain a space. Almost every single bash script of more than a dozen lines I&#x27;ve seen outside of large open-source projects fails if a user puts a space in a file path, because the programmer didn&#x27;t understand the insanity of variable quoting rules! I don&#x27;t know of any programming language with a more common major footgun.</div><br/><div id="38020592" class="c"><input type="checkbox" id="c-38020592" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020429">parent</a><span>|</span><a href="#38022631">next</a><span>|</span><label class="collapse" for="c-38020592">[-]</label><label class="expand" for="c-38020592">[1 more]</label></div><br/><div class="children"><div class="content">Shellcheck does cover that. I think the bigger problem is people programming without warnings (in any language).<p>edit: Although I can see that if they hadn&#x27;t made string splitting the default, it would have saved a lot of headaches.</div><br/></div></div></div></div><div id="38022631" class="c"><input type="checkbox" id="c-38022631" checked=""/><div class="controls bullet"><span class="by">rustshellscript</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020359">parent</a><span>|</span><a href="#38020429">prev</a><span>|</span><a href="#38021177">next</a><span>|</span><label class="collapse" for="c-38022631">[-]</label><label class="expand" for="c-38022631">[1 more]</label></div><br/><div class="children"><div class="content">You can check <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-shell-script&#x2F;rust_cmd_lib">https:&#x2F;&#x2F;github.com&#x2F;rust-shell-script&#x2F;rust_cmd_lib</a></div><br/></div></div><div id="38021177" class="c"><input type="checkbox" id="c-38021177" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020359">parent</a><span>|</span><a href="#38022631">prev</a><span>|</span><a href="#38021322">next</a><span>|</span><label class="collapse" for="c-38021177">[-]</label><label class="expand" for="c-38021177">[2 more]</label></div><br/><div class="children"><div class="content">Now you have me curious - where do you see the need for floats in shell? You are more creative than myself, because I am struggling to come up with a situation where I would lean on this. A &quot;path&quot; type would be by far more useful to my work.</div><br/><div id="38022482" class="c"><input type="checkbox" id="c-38022482" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38021177">parent</a><span>|</span><a href="#38021322">next</a><span>|</span><label class="collapse" for="c-38022482">[-]</label><label class="expand" for="c-38022482">[1 more]</label></div><br/><div class="children"><div class="content">I have a script which uses wmctrl to tile windows when I press a shortcut key (for when I&#x27;m using an editor and want the editor window to take up most of the screen).<p>I guess I could avoid floats using multiplication, but I would rather keep the code as simple as possible.</div><br/></div></div></div></div><div id="38021322" class="c"><input type="checkbox" id="c-38021322" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020359">parent</a><span>|</span><a href="#38021177">prev</a><span>|</span><a href="#38022978">next</a><span>|</span><label class="collapse" for="c-38021322">[-]</label><label class="expand" for="c-38021322">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like nushell: <a href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;case-for-nushell&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jntrnr.com&#x2F;case-for-nushell&#x2F;</a></div><br/></div></div><div id="38022978" class="c"><input type="checkbox" id="c-38022978" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020359">parent</a><span>|</span><a href="#38021322">prev</a><span>|</span><a href="#38020841">next</a><span>|</span><label class="collapse" for="c-38022978">[-]</label><label class="expand" for="c-38022978">[1 more]</label></div><br/><div class="children"><div class="content">Check out nushell, the Rust of the shells.<p>I know it’s still not 1.0. Then just get fish. At least would save some keystrokes.</div><br/></div></div></div></div><div id="38020841" class="c"><input type="checkbox" id="c-38020841" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38020359">prev</a><span>|</span><a href="#38019664">next</a><span>|</span><label class="collapse" for="c-38020841">[-]</label><label class="expand" for="c-38020841">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the approach Haskell took. Didn&#x27;t work since they didn&#x27;t realize that waiting for your program to respond is a pretty effing huge side effect.</div><br/><div id="38020935" class="c"><input type="checkbox" id="c-38020935" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38019584">root</a><span>|</span><a href="#38020841">parent</a><span>|</span><a href="#38019664">next</a><span>|</span><label class="collapse" for="c-38020935">[-]</label><label class="expand" for="c-38020935">[1 more]</label></div><br/><div class="children"><div class="content">It has unpredictable performance because of lazy evaluation. Other high-level functional programming languages like OCaml, Standard ML, and Scheme can be compiled and achieve fairly high performance.</div><br/></div></div></div></div><div id="38019664" class="c"><input type="checkbox" id="c-38019664" checked=""/><div class="controls bullet"><span class="by">jjn2009</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38020841">prev</a><span>|</span><a href="#38022616">next</a><span>|</span><label class="collapse" for="c-38019664">[-]</label><label class="expand" for="c-38019664">[1 more]</label></div><br/><div class="children"><div class="content">Arguably memory managed languages are the same or are you speaking to some specific slice of the available programming languages?</div><br/></div></div><div id="38022616" class="c"><input type="checkbox" id="c-38022616" checked=""/><div class="controls bullet"><span class="by">rustshellscript</span><span>|</span><a href="#38019584">parent</a><span>|</span><a href="#38019664">prev</a><span>|</span><a href="#38019603">next</a><span>|</span><label class="collapse" for="c-38022616">[-]</label><label class="expand" for="c-38022616">[1 more]</label></div><br/><div class="children"><div class="content">Here: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-shell-script&#x2F;rust_cmd_lib">https:&#x2F;&#x2F;github.com&#x2F;rust-shell-script&#x2F;rust_cmd_lib</a></div><br/></div></div></div></div><div id="38019603" class="c"><input type="checkbox" id="c-38019603" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#38019584">prev</a><span>|</span><a href="#38020005">next</a><span>|</span><label class="collapse" for="c-38019603">[-]</label><label class="expand" for="c-38019603">[1 more]</label></div><br/><div class="children"><div class="content">Learning when to invest in type constraints and when not to is an important lesson. It’s not unique to rust, though it might express a little differently. I’ve dealt with excessively typed c++ and excessively abstracted and typed Java and they have the same class of refactoring problems. I’ve also dealt with plenty of undertyped and under documented go, where there are specific values all over the place which turn into runtime footguns - and these can be truly dire to refactor as well, you get an earlier sense of progress but you ship bugs to users most of the time. There’s no magic answer to this set of trade offs. Rust gives you tools to mostly pick your place, on this specific axis it provides an unusually broad choice.</div><br/></div></div><div id="38020005" class="c"><input type="checkbox" id="c-38020005" checked=""/><div class="controls bullet"><span class="by">dilippkumar</span><span>|</span><a href="#38019603">prev</a><span>|</span><a href="#38019965">next</a><span>|</span><label class="collapse" for="c-38020005">[-]</label><label class="expand" for="c-38020005">[17 more]</label></div><br/><div class="children"><div class="content">&gt; After two decades of JavaScript and decent experience with Go, this is the most significant source of frustration and friction with Rust. It’s not an insurmountable problem, but you must always be ready to deal with the async monster when it rears its head. In other languages, async is almost invisible.<p>I am a former C and C++ programmer who lived calling into pthread almost every week for a decade. I use async rust everywhere now.<p>I don’t get the hate that async gets. In my opinion, everyone should be using async for everything. Including stuff that’s seemingly single threaded “simple” stuff.</div><br/><div id="38020875" class="c"><input type="checkbox" id="c-38020875" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#38020005">parent</a><span>|</span><a href="#38020405">next</a><span>|</span><label class="collapse" for="c-38020875">[-]</label><label class="expand" for="c-38020875">[1 more]</label></div><br/><div class="children"><div class="content">I think it is the infectiousness of it. Especially in embedded or wasm contexts, the predominant async may not be the async you want. Wasm being the author&#x27;s use case would definitely have provided a different perspective.<p>Similarly, I find tasks that use or reuse large buffers to avoid the performance hits from allocation, often benefit from old fashioned thread pools. Bump or shard allocators can make this work ok, but in the cases where you are cpu bound on tight loops of vectorizable operations, thread pools perform better. Async is a good tool, but there are contexts it isn&#x27;t optimal for.</div><br/></div></div><div id="38020405" class="c"><input type="checkbox" id="c-38020405" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#38020005">parent</a><span>|</span><a href="#38020875">prev</a><span>|</span><a href="#38022240">next</a><span>|</span><label class="collapse" for="c-38020405">[-]</label><label class="expand" for="c-38020405">[5 more]</label></div><br/><div class="children"><div class="content">Recently tried writing some async Rust to compare the error handling when nested async calls are made to how errors are handled in Go, and it seemed like the trivial example I was trying to write up simply couldn&#x27;t be done without involving Tokio. That barrier simply doesn&#x27;t exist in Go, or C#, or Typescript.<p>For instance, you apparently cannot `await` in the main function without a decorator you import from, you guessed it: Tokio.</div><br/><div id="38020583" class="c"><input type="checkbox" id="c-38020583" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020405">parent</a><span>|</span><a href="#38020723">next</a><span>|</span><label class="collapse" for="c-38020583">[-]</label><label class="expand" for="c-38020583">[1 more]</label></div><br/><div class="children"><div class="content">You need an async runtime to run async code yes, and Rust&#x27;s isn&#x27;t built in. Why does that matter though? Rust has a decent package manager; add the dependency and move on.</div><br/></div></div><div id="38020723" class="c"><input type="checkbox" id="c-38020723" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020405">parent</a><span>|</span><a href="#38020583">prev</a><span>|</span><a href="#38022240">next</a><span>|</span><label class="collapse" for="c-38020723">[-]</label><label class="expand" for="c-38020723">[3 more]</label></div><br/><div class="children"><div class="content">Why are you trying to avoid Tokio lol, tokio is the defacto async runtime in rust, saying you&#x27;re trying to avoid it is like saying you&#x27;re trying to avoid async while writing async, somehow people act like if they merged tokio into std and instead of #[tokio::main] or whatever you had to do #[async::main] it would somehow be better.<p>Once you stop fighting the fact that tokio = async rust for 99% of cases, things are quite smooth.</div><br/><div id="38020896" class="c"><input type="checkbox" id="c-38020896" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020723">parent</a><span>|</span><a href="#38021682">next</a><span>|</span><label class="collapse" for="c-38020896">[-]</label><label class="expand" for="c-38020896">[1 more]</label></div><br/><div class="children"><div class="content">Tokio simply doesn&#x27;t meet the ise case of some people doing wasm, and many people doing embedded. That isn&#x27;t a huge deal, just don&#x27;t use it right?  Except many otherwise usable crates seem to adopt tokio unnecessarily.</div><br/></div></div><div id="38021682" class="c"><input type="checkbox" id="c-38021682" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020723">parent</a><span>|</span><a href="#38020896">prev</a><span>|</span><a href="#38022240">next</a><span>|</span><label class="collapse" for="c-38021682">[-]</label><label class="expand" for="c-38021682">[1 more]</label></div><br/><div class="children"><div class="content">Your &quot;lol&quot; is entirely inappropriate.</div><br/></div></div></div></div></div></div><div id="38020124" class="c"><input type="checkbox" id="c-38020124" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#38020005">parent</a><span>|</span><a href="#38022240">prev</a><span>|</span><a href="#38020810">next</a><span>|</span><label class="collapse" for="c-38020124">[-]</label><label class="expand" for="c-38020124">[6 more]</label></div><br/><div class="children"><div class="content">The problem that I am running into at the moment is that a few things like the rhai Engine aren&#x27;t Send and I am trying to use them in an async closure. What GPT-4 suggested was creating a tokio Runtime inside the thread and then block_on(). I will try it tomorrow. (This is the first significant Rust project for me.)</div><br/><div id="38020266" class="c"><input type="checkbox" id="c-38020266" checked=""/><div class="controls bullet"><span class="by">codys</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020124">parent</a><span>|</span><a href="#38022062">next</a><span>|</span><label class="collapse" for="c-38020266">[-]</label><label class="expand" for="c-38020266">[3 more]</label></div><br/><div class="children"><div class="content">The answer here is almost certainly one of these:<p>1. Fix rhai::Engine so it is Send (if !Send is unintentional)<p>2. Use tokio::spawn_blocking or normal threads to run the rhai::Engine bits<p>3. Don&#x27;t hold the rhai::Engine across an await point.<p>Which one depends on rhai Engine details and what you want to accomplish.<p>Doing a block on inside a new thread seems unlikely to do anything useful (unless there&#x27;s some undisclosed detail that makes it reasonable).<p>I encourage you to ask about this in the rhai repo in a discussion or issue.</div><br/><div id="38020548" class="c"><input type="checkbox" id="c-38020548" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020266">parent</a><span>|</span><a href="#38022062">next</a><span>|</span><label class="collapse" for="c-38020548">[-]</label><label class="expand" for="c-38020548">[2 more]</label></div><br/><div class="children"><div class="content">1. Not applicable unless it is absolutely required, and not something I will consider until I have exhausted other options, since there is a reason they have not made it Send already. It will likely be quite complex and enlarge the scope.<p>2. I am using a normal thread but when I make it async the compiler wants Send.<p>3. The await point is in code that uses the engine. I am not sure there is another good option, since I need to use an API that has several libraries all of which are async.<p>The block_on is to allow the tokio Runtime created in that thread to execute&#x2F;poll it<p>So, thank you for your input, I will test out the suggestion that I mentioned above, and then maybe look into spawn_blocking if that doesn&#x27;t work.</div><br/><div id="38021134" class="c"><input type="checkbox" id="c-38021134" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020548">parent</a><span>|</span><a href="#38022062">next</a><span>|</span><label class="collapse" for="c-38021134">[-]</label><label class="expand" for="c-38021134">[1 more]</label></div><br/><div class="children"><div class="content">That ChatGPT suggestion is dodgy. Tokio is going to complain when you create a runtime while in async runtime, and refuse block_on in an async context.<p>You can have multiple runtimes, but create them ahead of time, in synchronous main, and keep a Handle to them.<p>But you probably need: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;struct.LocalSet.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;struct.LocalSet.html</a></div><br/></div></div></div></div></div></div><div id="38022062" class="c"><input type="checkbox" id="c-38022062" checked=""/><div class="controls bullet"><span class="by">brochington</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020124">parent</a><span>|</span><a href="#38020266">prev</a><span>|</span><a href="#38020731">next</a><span>|</span><label class="collapse" for="c-38022062">[-]</label><label class="expand" for="c-38022062">[1 more]</label></div><br/><div class="children"><div class="content">From the rhai Engine docs: `Currently, Engine is neither Send nor Sync. Use the sync feature to make it Send + Sync.`</div><br/></div></div><div id="38020731" class="c"><input type="checkbox" id="c-38020731" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020124">parent</a><span>|</span><a href="#38022062">prev</a><span>|</span><a href="#38020810">next</a><span>|</span><label class="collapse" for="c-38020731">[-]</label><label class="expand" for="c-38020731">[1 more]</label></div><br/><div class="children"><div class="content">It being !Send means its not safe to be sent lol, that&#x27;s down to the way they implemented rhai engine not rust. It&#x27;s just that rust catches that it&#x27;s not safe to send because of the trait bounds.</div><br/></div></div></div></div><div id="38020810" class="c"><input type="checkbox" id="c-38020810" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38020005">parent</a><span>|</span><a href="#38020124">prev</a><span>|</span><a href="#38020459">next</a><span>|</span><label class="collapse" for="c-38020810">[-]</label><label class="expand" for="c-38020810">[2 more]</label></div><br/><div class="children"><div class="content">Can you please elaborate on this? What&#x27;s an example of a seemingly single threaded simple task where you would turn to async?<p>Does &quot;use async rust everywhere now&quot; imply &quot;use tokio everywhere now?&quot; Honest question.</div><br/><div id="38021072" class="c"><input type="checkbox" id="c-38021072" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38020005">root</a><span>|</span><a href="#38020810">parent</a><span>|</span><a href="#38020459">next</a><span>|</span><label class="collapse" for="c-38021072">[-]</label><label class="expand" for="c-38021072">[1 more]</label></div><br/><div class="children"><div class="content">The way closures made it easy to encapsulate code and state in an object you can run at any time, async encapsulates code and state for ability to run <i>and pause or cancel</i> at any time.<p>This is handy for I&#x2F;O that can be interleaved and cancelled. You can (ab)use it for other things like generators or various DIY multitasking operations. It can also be a state machine generator (e.g. AI of actors in a game).<p>But I think OP just meant async for typical networking and DB interfaces. And yes, this usually implies the Tokio dependency.</div><br/></div></div></div></div></div></div><div id="38019965" class="c"><input type="checkbox" id="c-38019965" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#38020005">prev</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38019965">[-]</label><label class="expand" for="c-38019965">[17 more]</label></div><br/><div class="children"><div class="content">&quot;Rust screams at you all day, every day, often about things that you would have considered perfectly normal in another life.&quot;<p>A good C compiler does this when you turn on all the flags. I like languages&#x2F;compilers that let you selectively disable the screaming and let you write bad code on purpose. Bad code that works but can be written fast is often better than perfect code that takes forever to write. Once you have a bad but working POC, you can make it less bad.<p>&quot;It’s got no problem attracting new users, but it’s not resulting in dramatically improved libraries or tools. It’s resulting in one-off forks that handle specific use cases.&quot;<p>Age has nothing to do with that. Attracting core devs is hard, and putting lots of effort into making it attractive is necessary. On top of that, cultural conventions are set by the early adopters, and a lack of convention is often just as sinful as a bad existing convention.<p>Take Python for example. They took a lackadaisical approach to development and runtime environments, and as a result there&#x27;s 50 competing ways to develop or run a Python program. Their most-used package repository, PyPI, has been a mess for years. Nobody builds on top of existing packages, names make as much sense as a random word generator, the ecosystem is rife with malware, you can&#x27;t even search for a package on the command line, etc etc. None of that is the language&#x27;s fault, it&#x27;s the community and core team&#x27;s fault for sitting on the sidelines rather than leading. Culture matters more than the tech it&#x27;s centered around.<p>(I&#x27;m not trying to pick on them, I just know their problems better. C has been around for a half century and its community never really put together half the solutions more modern languages did)</div><br/><div id="38020121" class="c"><input type="checkbox" id="c-38020121" checked=""/><div class="controls bullet"><span class="by">ajhurliman</span><span>|</span><a href="#38019965">parent</a><span>|</span><a href="#38020740">next</a><span>|</span><label class="collapse" for="c-38020121">[-]</label><label class="expand" for="c-38020121">[1 more]</label></div><br/><div class="children"><div class="content">At the risk of getting downvoted into oblivion, that sounds a lot like TypeScript (compiler yelling at you to fix things but you just want to try an idea without perfecting it).</div><br/></div></div><div id="38020740" class="c"><input type="checkbox" id="c-38020740" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38019965">parent</a><span>|</span><a href="#38020121">prev</a><span>|</span><a href="#38020026">next</a><span>|</span><label class="collapse" for="c-38020740">[-]</label><label class="expand" for="c-38020740">[1 more]</label></div><br/><div class="children"><div class="content">Ya i&#x27;m sure &quot;no improved libraries&quot; is why linux and even windows have started porting components over to rust.</div><br/></div></div><div id="38020026" class="c"><input type="checkbox" id="c-38020026" checked=""/><div class="controls bullet"><span class="by">Someone1234</span><span>|</span><a href="#38019965">parent</a><span>|</span><a href="#38020740">prev</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38020026">[-]</label><label class="expand" for="c-38020026">[14 more]</label></div><br/><div class="children"><div class="content">&gt; A good C compiler does this when you turn on all the flags. I like languages&#x2F;compilers that let you selectively disable the screaming and let you write bad code on purpose. Bad code that works but can be written fast is often better than perfect code that takes forever to write. Once you have a bad but working POC, you can make it less bad.<p>Rust supports that. Just mark everything unsafe.</div><br/><div id="38020220" class="c"><input type="checkbox" id="c-38020220" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020026">parent</a><span>|</span><a href="#38020132">next</a><span>|</span><label class="collapse" for="c-38020220">[-]</label><label class="expand" for="c-38020220">[4 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t really work. All unsafe lets you do is dereference pointers or call unsafe functions. That&#x27;s not gonna speed your development up during prototyping.<p>You can instead wrap everything in Arc&lt;Mutex&lt;T&gt;&gt; and .clone() liberally, though.</div><br/><div id="38021781" class="c"><input type="checkbox" id="c-38021781" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020220">parent</a><span>|</span><a href="#38021005">next</a><span>|</span><label class="collapse" for="c-38021781">[-]</label><label class="expand" for="c-38021781">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All unsafe lets you do is dereference pointers or call unsafe functions.<p>And all those let you do is drop lifetimes and wave goodbye to the borrow checker. You just have to be explicit about it.<p>(What I mean is, the borrow checker checks borrows, it checks references. In unsafe you can make a reference forget what it&#x27;s referring to. Just change &amp;&#x27;a T to &amp;&#x27;static T, and then the borrow checker is doing nothing.)</div><br/></div></div><div id="38021005" class="c"><input type="checkbox" id="c-38021005" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020220">parent</a><span>|</span><a href="#38021781">prev</a><span>|</span><a href="#38020743">next</a><span>|</span><label class="collapse" for="c-38021005">[-]</label><label class="expand" for="c-38021005">[1 more]</label></div><br/><div class="children"><div class="content">It will work if you only use raw pointers everywhere, like it&#x27;s C. Don&#x27;t use slices or strings; just pass a pointer to the first element of an array, and either pass its length separately or provide a sentinel value (like C&#x27;s null terminated strings). Navigate balanced search trees using aliasing, raw, mutable pointers. Etc. This person compares the translation of C to Rust, literally versus idiomatically: <a href="https:&#x2F;&#x2F;cliffle.com&#x2F;p&#x2F;dangerust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cliffle.com&#x2F;p&#x2F;dangerust&#x2F;</a><p>There will probably be weird behavior, though, because Rust optimizes based on assumptions about boxes and references. For example, if you have 3 raw pointers to some object live at once, and you give some library function a mutable reference made from one of those pointers, the compiler will optimize assuming it has exclusive access to that object, and it may make incorrect assumptions.</div><br/></div></div><div id="38020743" class="c"><input type="checkbox" id="c-38020743" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020220">parent</a><span>|</span><a href="#38021005">prev</a><span>|</span><a href="#38020132">next</a><span>|</span><label class="collapse" for="c-38020743">[-]</label><label class="expand" for="c-38020743">[1 more]</label></div><br/><div class="children"><div class="content">Always find it funny that people think unsafe {} means that rust ignores everything in the block, it just enables 4-5 additional abilities that are well documented, it&#x27;s still doing most of its safety checks.</div><br/></div></div></div></div><div id="38020132" class="c"><input type="checkbox" id="c-38020132" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020026">parent</a><span>|</span><a href="#38020220">prev</a><span>|</span><a href="#38021124">next</a><span>|</span><label class="collapse" for="c-38020132">[-]</label><label class="expand" for="c-38020132">[1 more]</label></div><br/><div class="children"><div class="content">That doesn’t turn off the overwhelming majority of Rust’s soundness checks. `unsafe` isn’t a magic “let anything fly” switch.</div><br/></div></div><div id="38021124" class="c"><input type="checkbox" id="c-38021124" checked=""/><div class="controls bullet"><span class="by">sidlls</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38020026">parent</a><span>|</span><a href="#38020132">prev</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38021124">[-]</label><label class="expand" for="c-38021124">[8 more]</label></div><br/><div class="children"><div class="content">&quot;Just mark everything unsafe&quot; seems to be the motto of many (most?) crate developers. There&#x27;s so much &quot;unsafe&quot; in dependencies used by so many Rust programs. It&#x27;s a timebomb waiting to go off.</div><br/><div id="38021288" class="c"><input type="checkbox" id="c-38021288" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021124">parent</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38021288">[-]</label><label class="expand" for="c-38021288">[7 more]</label></div><br/><div class="children"><div class="content">80% of crates have no unsafe code in them.</div><br/><div id="38021965" class="c"><input type="checkbox" id="c-38021965" checked=""/><div class="controls bullet"><span class="by">chandlerswift</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021288">parent</a><span>|</span><a href="#38021971">next</a><span>|</span><label class="collapse" for="c-38021965">[-]</label><label class="expand" for="c-38021965">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in what went into this number.<p>I checked the six most recently published crates on crates.io (blablabla, nutp, tord, g2d, testpublishtesttest, hellochi, at the time of writing). Three of those (blablabla, testpublishtesttest, and hellochi) did some variation on printing `hello world`. g2d seems like an interesting graphics library. tord provides a data structure for transitive relations, which is also neat. No crate contained over 250 lines of code. Unsurprisingly, none of them contained unsafe code.<p>Elsewhere in this thread, it&#x27;s been pointed out that as a consequence of crates.io having a global namespace, plus lax enforcement of an anti-squatting policy, there are a lot of namesquatting packages. Those presumably contain no unsafe code.<p>tokio contains unsafe code. rand contains unsafe code. regex contains unsafe code. time contains unsafe code. (method: a smattering of packages chosen from blessed.rs; result: every one that I checked except serde containing unsafe code; epistemic status: eh -- I grepped the codebases, ignoring things that were pretty clearly tests, but might have accidentally included some example code or something that&#x27;s not part of the core library? Please let me know if I&#x27;ve misattributed unsafe usage to one of these projects, or if I&#x27;ve managed to select a biased sample!)<p>I&#x27;d certainly believe a straightforward reading of the claim &quot;80% of crates have no unsafe code&quot;...but that seems almost meaningless, given that a not-insignificant portion of crates contain basically no code at all? I&#x27;d be much more interested in a weighted percentage by downloads: I&#x27;d be wildly impressed if 80% of crate _downloads_ contained no unsafe code, and would be somewhat unsurprised if the number was well below 50% -- crates with more functionality would be more useful and therefore more download, but also more likely to use unsafe code, I&#x27;d imagine.<p>Edit: I just noticed crates.io has a most-downloaded list[0] -- I might end up running some numbers on top packages there tomorrow morning, for some more solid data.<p>[0]: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates?sort=downloads" rel="nofollow noreferrer">https:&#x2F;&#x2F;crates.io&#x2F;crates?sort=downloads</a></div><br/><div id="38022525" class="c"><input type="checkbox" id="c-38022525" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021965">parent</a><span>|</span><a href="#38022658">next</a><span>|</span><label class="collapse" for="c-38022525">[-]</label><label class="expand" for="c-38022525">[1 more]</label></div><br/><div class="children"><div class="content">What is the fact that many foundational ecosystem crate contain unsafe code supposed to prove? That&#x27;s the entire point of the language. That someone writes a really good regex crate once and then the rest of us don&#x27;t have to write unsafe to use it. It seems like you have a fundamental misunderstanding about the goals and purpose of rust.</div><br/></div></div><div id="38022658" class="c"><input type="checkbox" id="c-38022658" checked=""/><div class="controls bullet"><span class="by">dingi</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021965">parent</a><span>|</span><a href="#38022525">prev</a><span>|</span><a href="#38021971">next</a><span>|</span><label class="collapse" for="c-38022658">[-]</label><label class="expand" for="c-38022658">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget to include transitive dependencies as well.</div><br/></div></div></div></div><div id="38021971" class="c"><input type="checkbox" id="c-38021971" checked=""/><div class="controls bullet"><span class="by">sidlls</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021288">parent</a><span>|</span><a href="#38021965">prev</a><span>|</span><a href="#38021769">next</a><span>|</span><label class="collapse" for="c-38021971">[-]</label><label class="expand" for="c-38021971">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what the ratio of utilization of that 80% is compared to the 20% that do have `unsafe` all over the place.</div><br/></div></div><div id="38021769" class="c"><input type="checkbox" id="c-38021769" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021288">parent</a><span>|</span><a href="#38021971">prev</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38021769">[-]</label><label class="expand" for="c-38021769">[2 more]</label></div><br/><div class="children"><div class="content">So only 1&#x2F;5 of Rust code is unsafe? Isn&#x27;t safety, like, the point of the language?</div><br/><div id="38022950" class="c"><input type="checkbox" id="c-38022950" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#38019965">root</a><span>|</span><a href="#38021769">parent</a><span>|</span><a href="#38022170">next</a><span>|</span><label class="collapse" for="c-38022950">[-]</label><label class="expand" for="c-38022950">[1 more]</label></div><br/><div class="children"><div class="content">No, 1&#x2F;5 of Rust code contains unsafe directly. Also, &quot;the&quot; point (in the area of safe&#x2F;unsafe) is to manage unsafety and provide safe abstractions from unsafe foundations. If you go deep enough there&#x27;s always something which will be unsafe (the type system would have to able to proof the whole universe otherwise), but most programmers will not have to write such code themselves (no, most of use do not write double-linked lists each day) - they can just use it (e.g. by using the standard library). And if they have to write unsafe code the unsafe parts are restricted to certain areas of their code. Areas they can then invest extra time and care to make certain their assumptions hold true.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38022170" class="c"><input type="checkbox" id="c-38022170" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38019965">prev</a><span>|</span><a href="#38020394">next</a><span>|</span><label class="collapse" for="c-38022170">[-]</label><label class="expand" for="c-38022170">[2 more]</label></div><br/><div class="children"><div class="content">The clippy bit is a little confusing:<p>&gt; It also looks like (soon) you’ll finally be able to configure global lints for a project. Until now, you had to hack your solution to keep lints consistent for projects. In Wick, we use a script to automatically update inline lint configurations for a few dozen crates.<p>It&#x27;s trivial to configure global lints per <i>crate</i>. The author&#x27;s problem comes down to having multiple crates per <i>project</i>. Which is something people do sometimes, and should be supported, but there&#x27;s a big difference between the two interpretations. I would go so far as to say <i>most</i> Rust projects are only one crate (and so support &quot;global&quot; linter configuration)</div><br/><div id="38022286" class="c"><input type="checkbox" id="c-38022286" checked=""/><div class="controls bullet"><span class="by">xvedejas</span><span>|</span><a href="#38022170">parent</a><span>|</span><a href="#38020394">next</a><span>|</span><label class="collapse" for="c-38022286">[-]</label><label class="expand" for="c-38022286">[1 more]</label></div><br/><div class="children"><div class="content">I believe procedural macros always need to be defined in a separate crate, so at least all projects that use procedural macros will have multiple crates</div><br/></div></div></div></div><div id="38020394" class="c"><input type="checkbox" id="c-38020394" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38022170">prev</a><span>|</span><a href="#38020651">next</a><span>|</span><label class="collapse" for="c-38020394">[-]</label><label class="expand" for="c-38020394">[7 more]</label></div><br/><div class="children"><div class="content">&quot;Want to use an async library? There’s a chance you can’t use it outside of a specific async runtime.&quot;<p>I complained about this here[1].  I&#x27;m told &quot;Tokio won, it&#x27;s not a problem anymore.&quot;  Wrong.  It&#x27;s still a problem and it&#x27;s a killer.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37892655">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37892655</a></div><br/><div id="38020458" class="c"><input type="checkbox" id="c-38020458" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#38020394">parent</a><span>|</span><a href="#38020444">next</a><span>|</span><label class="collapse" for="c-38020458">[-]</label><label class="expand" for="c-38020458">[2 more]</label></div><br/><div class="children"><div class="content">Can you help understand why somebody wouldn&#x27;t use Tokio&#x2F;why it didn&#x27;t &quot;win&quot;?</div><br/><div id="38020782" class="c"><input type="checkbox" id="c-38020782" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38020394">root</a><span>|</span><a href="#38020458">parent</a><span>|</span><a href="#38020444">next</a><span>|</span><label class="collapse" for="c-38020782">[-]</label><label class="expand" for="c-38020782">[1 more]</label></div><br/><div class="children"><div class="content">Tokio isn&#x27;t the fastest conceivable runtime.  Tokio isn&#x27;t the smallest conceivable runtime.  Tokio isn&#x27;t the simpilist conceivable runtime.  Tokio does not port to all conceivable environments.  Tokio isn&#x27;t the async-std runtime.<p>And so, for some or all of these reasons, right or wrong, various Rust libraries wed themselves to runtimes other than Tokio.<p>You can thunk around these things, but it&#x27;s miserable, yielding subtle, inscrutable code that you will <i>not</i> understand in six months when you have to maintain it.  And the real fun begins when you need to handle Err, and all the abstraction leaks around Send and threads ruin your day; more thunking, Boxing errors (omfg) and even subtler and more inscrutable code.</div><br/></div></div></div></div><div id="38020444" class="c"><input type="checkbox" id="c-38020444" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38020394">parent</a><span>|</span><a href="#38020458">prev</a><span>|</span><a href="#38020651">next</a><span>|</span><label class="collapse" for="c-38020444">[-]</label><label class="expand" for="c-38020444">[4 more]</label></div><br/><div class="children"><div class="content">Yeah those are terrible responses.<p>Tokio monoculture is a serious problem.</div><br/><div id="38021107" class="c"><input type="checkbox" id="c-38021107" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38020394">root</a><span>|</span><a href="#38020444">parent</a><span>|</span><a href="#38020651">next</a><span>|</span><label class="collapse" for="c-38021107">[-]</label><label class="expand" for="c-38021107">[3 more]</label></div><br/><div class="children"><div class="content">On the supposed &quot;monoculture&quot;:<p>First, I have to wonder whether any of this can be legitimately elevated to the level of a &quot;culture.&quot;  Right now, according to GitHub &quot;insights,&quot; tokio-rs has approximately 2.0 regular, every day contributors.  And that&#x27;s the most widely used Rust async runtime.  Everything else is likely even more thin.<p>Second, Tokio has a lot of share because it was early and aggressive in actually delivering usable async documentation and code.  I recall, years ago, reading Tokio documentation on how futures worked and grasping these concepts all the way from file descriptors one might epoll() in C, up to the Rust abstractions, and thinking &quot;hell, I could write an executor from first principles based on this.&quot;  Tokio earned the advocates it has, as oblivious to the real state of things as some of them might be.<p>I think the real problem is that async Rust is incomplete.  As I said elsewhere, async Rust syntax is fine.  The implications of async Rust exposed some papercuts in the language that have had to be dealt with since, but the core syntax is fine.  I believe that can be attributed to the serious minded attention that the syntax received from people way, waaay up the cognition curve.  The part that didn&#x27;t get enough thought was async runtimes.  In an ideal world, one would develop a Rust library that utilizes and&#x2F;or implements asynchronous calls and transparently, flawlessly run on any correctly implemented runtime alongside any other number of libraries also utilizing and&#x2F;or implementing async calls.<p>That is not the case, and the damage that&#x27;s doing is severe.  For every one person, such as myself, that will dare attempt to articulate this pain and, in the process, certainly revealing clear evidence of blatant ignorance, a thousand others just silently gave up.</div><br/><div id="38021457" class="c"><input type="checkbox" id="c-38021457" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38020394">root</a><span>|</span><a href="#38021107">parent</a><span>|</span><a href="#38020651">next</a><span>|</span><label class="collapse" for="c-38021457">[-]</label><label class="expand" for="c-38021457">[2 more]</label></div><br/><div class="children"><div class="content">Yes I think we agree, though I&#x27;d quibble about the async syntax; I use it but I have philosophical concerns about it. But I do think tokio is on the whole well implemented.  But it is not a good thing for a single runtime to dominate the language like that.<p>I&#x27;ve at least thought-experimented with what it would take to write my own code agnostic enough that it could run on both e.g. tokio and e.g. monoio etc. and, well, it just can&#x27;t happen. Even if you find neutral&#x2F;unbundled implementations of locks, channels, utilities, to depend on instead, you end up stuck at: task spawning, and any kind of I&#x2F;O. The former, to me, is a glaring absence from the language standard; async should not have gone out the door without support for it.</div><br/><div id="38021548" class="c"><input type="checkbox" id="c-38021548" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#38020394">root</a><span>|</span><a href="#38021457">parent</a><span>|</span><a href="#38020651">next</a><span>|</span><label class="collapse" for="c-38021548">[-]</label><label class="expand" for="c-38021548">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t argue too much on your view of the syntax.  I employ the weasel word &quot;fine&quot; because my experience with it is that I have little to no trouble understanding and using async Rust syntax: I can read and write async Rust and conceptually grasp what is likely going on in the runtime.  I have to allow that perhaps it isn&#x27;t sufficient, and maybe even that this is a factor in the runtime problem.<p>But there are other, non-syntax issues, such as synchronization primitives, IO events, etc. that are clearly underspecified.  No maybes about it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38020651" class="c"><input type="checkbox" id="c-38020651" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#38020394">prev</a><span>|</span><a href="#38019726">next</a><span>|</span><label class="collapse" for="c-38020651">[-]</label><label class="expand" for="c-38020651">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I am a massive proponent of test-driven development. I got used to testing in languages like Java and JavaScript. I started writing tests in Rust as I would in any other language but found that I was writing tests couldn’t fail. Once you get to the point where your tests can run – that is, where your Rust code compiles – Rust has accounted for so many errors that many common test cases become irrelevant.<p>I wonder what <i>kind</i> of tests the author was writing? The test cases I write for my code is for weird edge cases I detect during testing, like parameter over or underflows, correctness of parsing functions, etc. Things that do fail. I don&#x27;t get why you&#x27;d write tests for trivial things that <i>can&#x27;t</i> fail.</div><br/><div id="38022955" class="c"><input type="checkbox" id="c-38022955" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#38020651">parent</a><span>|</span><a href="#38020658">next</a><span>|</span><label class="collapse" for="c-38022955">[-]</label><label class="expand" for="c-38022955">[1 more]</label></div><br/><div class="children"><div class="content">When writing in loosely typed languages, some folks aim for 100% line coverage, to make it more feasible to refactor down the line. Which then of course ends up being a lot of tests for fairly basic stuff that the type system could help you with...</div><br/></div></div><div id="38020658" class="c"><input type="checkbox" id="c-38020658" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#38020651">parent</a><span>|</span><a href="#38022955">prev</a><span>|</span><a href="#38019726">next</a><span>|</span><label class="collapse" for="c-38020658">[-]</label><label class="expand" for="c-38020658">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, those are usually the kinds of tests people write. Rust just makes the uselessness more obvious.</div><br/></div></div></div></div><div id="38019726" class="c"><input type="checkbox" id="c-38019726" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#38020651">prev</a><span>|</span><a href="#38019652">next</a><span>|</span><label class="collapse" for="c-38019726">[-]</label><label class="expand" for="c-38019726">[1 more]</label></div><br/><div class="children"><div class="content">Side comment but I looked at the documentation, github repo and even code for wick and I still have zero idea what it does. And I am rust developper full time...</div><br/></div></div><div id="38019652" class="c"><input type="checkbox" id="c-38019652" checked=""/><div class="controls bullet"><span class="by">ayakang31415</span><span>|</span><a href="#38019726">prev</a><span>|</span><a href="#38019904">next</a><span>|</span><label class="collapse" for="c-38019652">[-]</label><label class="expand" for="c-38019652">[16 more]</label></div><br/><div class="children"><div class="content">I never programmed in Rust, but I had enough experience in C programming to know that segmentation faults are annoying to debug. I heard Rust prevents memory management problems at compilation level, so it forces you to create safer program. Given this, I want to ask Rust programmers here: For people who have no experience in managing memory at coding stage (basically programmer who have no experience in C-like language), can such people appreciate what Rust aims to deliver?</div><br/><div id="38019777" class="c"><input type="checkbox" id="c-38019777" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019836">next</a><span>|</span><label class="collapse" for="c-38019777">[-]</label><label class="expand" for="c-38019777">[2 more]</label></div><br/><div class="children"><div class="content">For people who&#x27;ve never written C or C++, Rust&#x27;s biggest selling point is usually performance. Porting code from Python to Rust for example often gives 10-100x speedups right off the bat. You could get the same speedups by porting to C too, but Rust lets you do that without giving up the memory safety and package management convenience that you&#x27;re used to.<p>Even when you don&#x27;t care about performance, another issue that comes up sometimes is keeping track of mutable state. If you&#x27;ve ever relied on bytes instead of bytearray or tuple instead of list* to guarantee that no mutation is happening in some Python code, you know what I&#x27;m talking about. Rust can give you a similar level of control over who gets to mutate what, without making you change the type of your data or pay the cost of copies. It&#x27;s basically the const&#x2F;non-const distinction from C, but much stricter. Another way of saying the same thing is that Rust gives you a lot of the legibility&#x2F;correctness benefits that you&#x27;d expect from a functional programming language, but you get to code in the usual imperative style.<p>* And even then, that only prevents assignment to the elements of the tuple. You can still mutate an element internally if it&#x27;s not also an immutable type.</div><br/><div id="38020564" class="c"><input type="checkbox" id="c-38020564" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#38019652">root</a><span>|</span><a href="#38019777">parent</a><span>|</span><a href="#38019836">next</a><span>|</span><label class="collapse" for="c-38020564">[-]</label><label class="expand" for="c-38020564">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Porting code from Python to Rust for example often gives 10-100x speedups right off the bat.<p>As long as you don&#x27;t do a couple of things that, while easy to remember not to do once you know them, a programmer used to languages like Python and Javascript might be oblivious to.  Things like:<p>* Forgetting to use buffered IO wrappers<p>* Using println!() for high-volume console printing rather than locking stdout and writing to it manually</div><br/></div></div></div></div><div id="38019836" class="c"><input type="checkbox" id="c-38019836" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019777">prev</a><span>|</span><a href="#38019755">next</a><span>|</span><label class="collapse" for="c-38019836">[-]</label><label class="expand" for="c-38019836">[5 more]</label></div><br/><div class="children"><div class="content">I’m not sure.  Looking through different Rust libraries, I tend to see three different styles, depending on previous programming experience.  Each mimics the prior experience, with benefits.<p>* Everything is a struct with concrete types.  This is closest to C.  It benefits from the improved memory safety, without sacrificing speed.<p>* Everything is a Box&lt;Rc&lt;T&gt;&gt;.  This is closest to dynamic garbage-collected languages, but with vastly improved performance.<p>* Everything is an “impl Trait”.  This is closest to templated C++, but with much better ergonomics.<p>So, while I think I agree with your specific statement that the improved memory management may only be fully appreciated by those that cut their teeth on C’s segfaults and dangling pointers, I don’t think that’s the only benefit of Rust as a language.</div><br/><div id="38020561" class="c"><input type="checkbox" id="c-38020561" checked=""/><div class="controls bullet"><span class="by">jowea</span><span>|</span><a href="#38019652">root</a><span>|</span><a href="#38019836">parent</a><span>|</span><a href="#38019755">next</a><span>|</span><label class="collapse" for="c-38020561">[-]</label><label class="expand" for="c-38020561">[4 more]</label></div><br/><div class="children"><div class="content">&gt; * Everything is a Box&lt;Rc&lt;T&gt;&gt;. This is closest to dynamic garbage-collected languages, but with vastly improved performance.<p>Wait, reference counting everything all the time is faster than normal garbage collection?</div><br/><div id="38021382" class="c"><input type="checkbox" id="c-38021382" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#38019652">root</a><span>|</span><a href="#38020561">parent</a><span>|</span><a href="#38020971">next</a><span>|</span><label class="collapse" for="c-38021382">[-]</label><label class="expand" for="c-38021382">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably slower, but unlike normal GCed languages, it&#x27;s not actually anywhere close to <i>everything</i>.</div><br/></div></div><div id="38020971" class="c"><input type="checkbox" id="c-38020971" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#38019652">root</a><span>|</span><a href="#38020561">parent</a><span>|</span><a href="#38021382">prev</a><span>|</span><a href="#38019755">next</a><span>|</span><label class="collapse" for="c-38020971">[-]</label><label class="expand" for="c-38020971">[2 more]</label></div><br/><div class="children"><div class="content">I think more importantly it is reference counting across threads, meaning mutexes and breaking memory barrier with large performance penalty.</div><br/></div></div></div></div></div></div><div id="38019755" class="c"><input type="checkbox" id="c-38019755" checked=""/><div class="controls bullet"><span class="by">evrimoztamur</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019836">prev</a><span>|</span><a href="#38020615">next</a><span>|</span><label class="collapse" for="c-38019755">[-]</label><label class="expand" for="c-38019755">[1 more]</label></div><br/><div class="children"><div class="content">I think so, I wrote an entire video game from scratch in Rust and my experience has been absolutely delightful. I have to manage nulls via Options, cast things explicitly, cannot do dumb stuff like modifying an array while iterating it, etcetera. It’s guiding my code in ways that I wasn’t able to myself, and eventually leading to essentially what is a bug-free game. Imagine!<p>The experience has been far more than just borrow checking, it’s opened up my mind to a lot of concepts that my previous trials with Java, JavaScript, and Python fully obscured in arcane ways. Rust’s compiler is wonderful, and once you get past the ergonomic struggles (which I did by just going through Advent of Code), you’re set.</div><br/></div></div><div id="38020615" class="c"><input type="checkbox" id="c-38020615" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019755">prev</a><span>|</span><a href="#38020761">next</a><span>|</span><label class="collapse" for="c-38020615">[-]</label><label class="expand" for="c-38020615">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re used to e.g. OCaml, and the problem you&#x27;re solving does not require avoiding GC, then Rust is a more cumbersome language for no real benefit.<p>If you&#x27;ve never used an ML family language then Rust might still be a breath of fresh air even if you don&#x27;t care about memory management.</div><br/></div></div><div id="38020761" class="c"><input type="checkbox" id="c-38020761" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38020615">prev</a><span>|</span><a href="#38020173">next</a><span>|</span><label class="collapse" for="c-38020761">[-]</label><label class="expand" for="c-38020761">[1 more]</label></div><br/><div class="children"><div class="content">I dunno if it&#x27;s just me but coming from typescript and c# background it honestly wasn&#x27;t that hard to grasp things, Maybe it&#x27;s just me but it seems so much easier to grasp than C.</div><br/></div></div><div id="38020173" class="c"><input type="checkbox" id="c-38020173" checked=""/><div class="controls bullet"><span class="by">doubloon</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38020761">prev</a><span>|</span><a href="#38019752">next</a><span>|</span><label class="collapse" for="c-38020173">[-]</label><label class="expand" for="c-38020173">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion, until you have spent a lot of time debugging C&#x2F;C++&#x2F;assembly issues (memory corruption, null pointer crashes, segfaults, build system problems, exception inception, etc),  Rust would probably seem like a total waste of time.</div><br/></div></div><div id="38019752" class="c"><input type="checkbox" id="c-38019752" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38020173">prev</a><span>|</span><a href="#38019735">next</a><span>|</span><label class="collapse" for="c-38019752">[-]</label><label class="expand" for="c-38019752">[1 more]</label></div><br/><div class="children"><div class="content">In that scenario Rust can be attractive because of its high performance compared to languages with a garbage collector. No matter what Java fans will tell you, any runtime with a GC will have worse overall performance for most large codebases than a compiled language with no GC. Sure, microbenchmarks might not look too bad, but complex software is a different matter.<p>Rust is great for services such as API endpoints, where low latency and high throughput at a low cost are more important that hot reload during development.</div><br/></div></div><div id="38019735" class="c"><input type="checkbox" id="c-38019735" checked=""/><div class="controls bullet"><span class="by">love2read</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019752">prev</a><span>|</span><a href="#38019721">next</a><span>|</span><label class="collapse" for="c-38019735">[-]</label><label class="expand" for="c-38019735">[1 more]</label></div><br/><div class="children"><div class="content">I heavily appreciate the simplification of the memory model. I was able to go from comfortable with typescript&#x2F;js to comfortable with rust with essentially zero knowledge of manual memory allocation in just a few months.</div><br/></div></div><div id="38019721" class="c"><input type="checkbox" id="c-38019721" checked=""/><div class="controls bullet"><span class="by">kag0</span><span>|</span><a href="#38019652">parent</a><span>|</span><a href="#38019735">prev</a><span>|</span><a href="#38021376">next</a><span>|</span><label class="collapse" for="c-38019721">[-]</label><label class="expand" for="c-38019721">[1 more]</label></div><br/><div class="children"><div class="content">disclaimer: I&#x27;m not a big rust programmer, but I appreciate it.<p>I think it&#x27;s a matter of perspective&#x2F;background. Depending what language you&#x27;re coming from you might appreciate a lot of the more modern language features, or binary size, or performance. On the other hand, you might already be working with a pretty cutting edge language with a garbage collector or other and decide that Rust has some cool benefits but not worth the switch.</div><br/></div></div></div></div><div id="38019904" class="c"><input type="checkbox" id="c-38019904" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#38019652">prev</a><span>|</span><a href="#38020292">next</a><span>|</span><label class="collapse" for="c-38019904">[-]</label><label class="expand" for="c-38019904">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only mentioned off hand in one sentence at the end, but have people found that Rust is hard to hire for? In my experience it&#x27;s relatively easy to filter for good candidates when you&#x27;re hiring for Rust, whereas, just as a point of contrast, I&#x27;ve noticed it&#x27;s more difficult to find frontend developers who are good at TypeScript (since a lot of frontend developers just use plain JavaScript).</div><br/><div id="38020504" class="c"><input type="checkbox" id="c-38020504" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38019904">parent</a><span>|</span><a href="#38020292">next</a><span>|</span><label class="collapse" for="c-38020504">[-]</label><label class="expand" for="c-38020504">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is unusually difficult to find Rust programmers. The challenge is finding Rust programmers who also have expertise in systems software development. Rust was designed to be a systems language but ironically it primarily seems to attract developers that do not have expertise in systems software.<p>This isn&#x27;t necessarily a problem. C++ and Rust can coexist pretty well in practice, and Rust is a good entry point for learning how to write systems software.</div><br/><div id="38021695" class="c"><input type="checkbox" id="c-38021695" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38019904">root</a><span>|</span><a href="#38020504">parent</a><span>|</span><a href="#38020292">next</a><span>|</span><label class="collapse" for="c-38021695">[-]</label><label class="expand" for="c-38021695">[1 more]</label></div><br/><div class="children"><div class="content">Sadly I have found the flip side, too: as someone with a systems software interest&#x2F;background (I wouldn&#x27;t say expert), the # of jobs in the Rust ecosystem that are not glorified webdev&#x2F;microservicing (or worse, crypto) is actually quite small.<p>So I guess I wouldn&#x27;t be surprised that the applications are trending that way, too, as that is where growth is happening right now it seems.</div><br/></div></div></div></div></div></div><div id="38020292" class="c"><input type="checkbox" id="c-38020292" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#38019904">prev</a><span>|</span><a href="#38019708">next</a><span>|</span><label class="collapse" for="c-38020292">[-]</label><label class="expand" for="c-38020292">[2 more]</label></div><br/><div class="children"><div class="content">Use Rust like ADA, or use it for OS yes.<p>For typical applications I am learning nim, which has python syntax, c speed and size, and could be memory safe too.<p>I really feel nim deserves more love, for that you can balance coding-speed(write like python script), size , performance and security, and cal leverage c and c++ libraries without FFI,  no other languages can have those at the same time.</div><br/><div id="38021352" class="c"><input type="checkbox" id="c-38021352" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38020292">parent</a><span>|</span><a href="#38019708">next</a><span>|</span><label class="collapse" for="c-38021352">[-]</label><label class="expand" for="c-38021352">[1 more]</label></div><br/><div class="children"><div class="content">Or crystal which looks more like ruby than Nim looks like python.</div><br/></div></div></div></div><div id="38019708" class="c"><input type="checkbox" id="c-38019708" checked=""/><div class="controls bullet"><span class="by">clumsysmurf</span><span>|</span><a href="#38020292">prev</a><span>|</span><a href="#38019853">next</a><span>|</span><label class="collapse" for="c-38019708">[-]</label><label class="expand" for="c-38019708">[14 more]</label></div><br/><div class="children"><div class="content">As an outsider, I often hear about async Rust being less than ideal. Perhaps I don&#x27;t understand, because I haven&#x27;t dipped my toes in the water yet... but I do most of my work in Kotlin with Coroutines, and concurrency is everywhere in the UI. I can&#x27;t imagine working in a language having a major deficit in this space.<p>Are there any efforts to overhaul or completely rethink this?</div><br/><div id="38019784" class="c"><input type="checkbox" id="c-38019784" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38019708">parent</a><span>|</span><a href="#38020104">next</a><span>|</span><label class="collapse" for="c-38019784">[-]</label><label class="expand" for="c-38019784">[7 more]</label></div><br/><div class="children"><div class="content">It’s pretty much the same issue all languages have, that async functions are colored. I don’t think it is unique to rust.<p>Algebraic effects would solve this, but I don’t know any language other than OCaml that is working on that approach.</div><br/><div id="38020036" class="c"><input type="checkbox" id="c-38020036" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38019784">parent</a><span>|</span><a href="#38020018">next</a><span>|</span><label class="collapse" for="c-38020036">[-]</label><label class="expand" for="c-38020036">[2 more]</label></div><br/><div class="children"><div class="content">It’s not just that. There’s a few big problems with Rust async aside from the normal coloring problem that is inherent to async and not worth talking about.<p>* The async runtime and async functions are decomposed but tightly coupled. That means while you could swap out runtimes, a crate built against one runtime can’t generally be used with another unless explicitly designed to support multiple. I believe C++ has a similar problem but no other major language I’m aware of has this problem - that’s typically because there’s only a single runtime and it’s embedded in the language. Things like timers and I&#x2F;O are not interoperable because the API you use has to be for the runtime you’re running under. I believe there’s work ongoing to try to remedy this although in practice I think that’s difficult (eg what if you’re using a crate relying on epoll-based APIs but the runtime is io_uring).<p>* async in traits. I believe that’s coming this year although the extra boxing it forces to make that work makes that not something 0-cost you can adopt in a super hot path.<p>* async requires pinned types which makes things very complex to manage and is a uniquely Rust concept (in fact I read a conceptually better alternative proposal for how to have solved the pin&#x2F;unpin problem on HN not too long ago, but that ship has long sailed I fear).<p>* The borrow checker doesn’t know if your async function is running on a work stealing runtime or not which means there’s a lot more hoop jumping via unsafe if you want optimal performance.<p>* async functions are lazy and require polling before they do anything. That can be a bit surprising and require weird patterns.<p>Don’t get me wrong. The effing-mad crate is a fantastic demonstration of the power of algebraic effects to comprehensively solve coloring issues (async, failability, etc). But I think there’s stuff with runtime interop that’s also important. I don’t think anyone is yet seriously tackling improving the borrow checker for thread per core async.</div><br/><div id="38022982" class="c"><input type="checkbox" id="c-38022982" checked=""/><div class="controls bullet"><span class="by">Alyan</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38020036">parent</a><span>|</span><a href="#38020018">next</a><span>|</span><label class="collapse" for="c-38022982">[-]</label><label class="expand" for="c-38022982">[1 more]</label></div><br/><div class="children"><div class="content">Async in traits feature doesn’t use boxing (which is coming in 28 December), only async-trait crate use boxing.</div><br/></div></div></div></div><div id="38020018" class="c"><input type="checkbox" id="c-38020018" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38019784">parent</a><span>|</span><a href="#38020036">prev</a><span>|</span><a href="#38019982">next</a><span>|</span><label class="collapse" for="c-38020018">[-]</label><label class="expand" for="c-38020018">[1 more]</label></div><br/><div class="children"><div class="content">I mean... that&#x27;s not really the pain that people are referring to when they are struggling with async Rust, especially when you compare it other languages like JavaScript that also have a difference between async and regular functions.</div><br/></div></div><div id="38019982" class="c"><input type="checkbox" id="c-38019982" checked=""/><div class="controls bullet"><span class="by">adamgordonbell</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38019784">parent</a><span>|</span><a href="#38020018">prev</a><span>|</span><a href="#38020375">next</a><span>|</span><label class="collapse" for="c-38019982">[-]</label><label class="expand" for="c-38019982">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t scala, haskell, (kotlin?) you just lift functions into Async?<p>You can convert colors simply but only one way, and practically that works, functional core imperative shell, etc.</div><br/></div></div><div id="38020375" class="c"><input type="checkbox" id="c-38020375" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38019784">parent</a><span>|</span><a href="#38019982">prev</a><span>|</span><a href="#38020104">next</a><span>|</span><label class="collapse" for="c-38020375">[-]</label><label class="expand" for="c-38020375">[2 more]</label></div><br/><div class="children"><div class="content">Unison [1] has algebraic effects as a first-class feature. They call them &quot;abilities&quot; there. You can make async about as transparent&#x2F;opaque as you want it. Docs on abilities in [2].<p>[1]: <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;learn&#x2F;language-reference&#x2F;abilities-and-ability-handlers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;learn&#x2F;language-reference&#x2F;abiliti...</a></div><br/><div id="38021197" class="c"><input type="checkbox" id="c-38021197" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38020375">parent</a><span>|</span><a href="#38020104">next</a><span>|</span><label class="collapse" for="c-38021197">[-]</label><label class="expand" for="c-38021197">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone actually use unison in real life?</div><br/></div></div></div></div></div></div><div id="38020104" class="c"><input type="checkbox" id="c-38020104" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#38019708">parent</a><span>|</span><a href="#38019784">prev</a><span>|</span><a href="#38020004">next</a><span>|</span><label class="collapse" for="c-38020104">[-]</label><label class="expand" for="c-38020104">[2 more]</label></div><br/><div class="children"><div class="content">For me I am working on a side project in Rust and had very few issues, Rust felt quite straight forward up until the point where I had to mess around with async. For my domain I need to use a framework that expects you to set up a shared mutable state for the connection pooling in an opinionated way. Suddenly I encountered arc and mutex and very cryptic trait error messages for code doing way too much magic. All I wanted was to share a SQLite connection in an ugly way to get my mvp out but I was dealing with absolutely incomprehensible trait issues.<p>In general I’ve noticed that there are a lot of code generation modules that can generate very cryptic error messages if you stay clear of their happy paths.</div><br/><div id="38020535" class="c"><input type="checkbox" id="c-38020535" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38020104">parent</a><span>|</span><a href="#38020004">next</a><span>|</span><label class="collapse" for="c-38020535">[-]</label><label class="expand" for="c-38020535">[1 more]</label></div><br/><div class="children"><div class="content">You would run into the same issues if you tried to do it with threads and rust too.<p>Any kind of shared resource is a tedious experience, that&#x27;s basically it&#x27;s selling point.<p>It is frustrating becasue if you go look for help, people are always condescending about global shared resources like that but there really isn&#x27;t a better way.</div><br/></div></div></div></div><div id="38020004" class="c"><input type="checkbox" id="c-38020004" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#38019708">parent</a><span>|</span><a href="#38020104">prev</a><span>|</span><a href="#38020155">next</a><span>|</span><label class="collapse" for="c-38020004">[-]</label><label class="expand" for="c-38020004">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s efforts to overhaul it, basically there&#x27;s a lot of stuff that has to be more complicated (as you&#x27;d expect) if you want to add support for async somewhere, and understanding the error messages can be pretty mentally taxing when you get it wrong; and then there&#x27;s a lot of cases where the async version of some pattern just doesn&#x27;t work right now due to limitations in the compiler or the language itself, and hopefully it&#x27;ll work someday, but in the meantime you need to use workarounds.</div><br/></div></div><div id="38020155" class="c"><input type="checkbox" id="c-38020155" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38019708">parent</a><span>|</span><a href="#38020004">prev</a><span>|</span><a href="#38020751">next</a><span>|</span><label class="collapse" for="c-38020155">[-]</label><label class="expand" for="c-38020155">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a better explanation by somebody smarter than me about why Rust chooses what it does, what else you could choose and what the price is: <a href="https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;why-async-rust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;why-async-rust&#x2F;</a><p>tl;dr: You can have different (nicer to program) abstractions, but you can&#x27;t have them in the same language you use to write firmware for a $10 electronic device, or Linux drivers, and we already have languages like Go and Javascript whereas we did not have a safer alternative to C++.</div><br/></div></div><div id="38020751" class="c"><input type="checkbox" id="c-38020751" checked=""/><div class="controls bullet"><span class="by">cchance</span><span>|</span><a href="#38019708">parent</a><span>|</span><a href="#38020155">prev</a><span>|</span><a href="#38019853">next</a><span>|</span><label class="collapse" for="c-38020751">[-]</label><label class="expand" for="c-38020751">[2 more]</label></div><br/><div class="children"><div class="content">It feels like most of the hatred for rust async is for people that try to act like Tokio isn&#x27;t async rust and that for some reason you should try to randomly avoid tokio for some reason.</div><br/><div id="38021122" class="c"><input type="checkbox" id="c-38021122" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#38019708">root</a><span>|</span><a href="#38020751">parent</a><span>|</span><a href="#38019853">next</a><span>|</span><label class="collapse" for="c-38021122">[-]</label><label class="expand" for="c-38021122">[1 more]</label></div><br/><div class="children"><div class="content">Maybe because you want to keep the dependency tree under control and bringing in tokio suddenly adds fifty crates you never asked for. Every crate is a potential liability!</div><br/></div></div></div></div></div></div><div id="38019853" class="c"><input type="checkbox" id="c-38019853" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#38019708">prev</a><span>|</span><a href="#38022774">next</a><span>|</span><label class="collapse" for="c-38019853">[-]</label><label class="expand" for="c-38019853">[15 more]</label></div><br/><div class="children"><div class="content">Do you need memory safety? Then why use Rust when you could use Java, JS, Python, etc? You can&#x27;t &quot;disable&quot; memory safety in those languages.<p>Do you need bare metal performance? Then why use Rust when you could use C or C++, which have much larger ecosystems, platform support, more mature tooling, etc.<p>Do you need BOTH memory safety and baremetal performance at the same time? Then there really aren&#x27;t many other options besides Rust.<p>But what I&#x27;ve started wondering lately is: are there really that many situations where you actually need both of those things at the same time? C++ tends to get misused a lot, but I feel like the same thing is happening with Rust.</div><br/><div id="38019992" class="c"><input type="checkbox" id="c-38019992" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#38019853">parent</a><span>|</span><a href="#38020002">next</a><span>|</span><label class="collapse" for="c-38019992">[-]</label><label class="expand" for="c-38019992">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re remotely sane, you&#x27;ll <i>always</i> want memory safety. That&#x27;s not really an optional property, because even in C&#x2F;C++ compromising memory safety throws you straight into the land of nasal demons. The question is whether you want the compiler to ensure memory safety, or to do it completely on your own without language support.<p>Personally, I&#x27;ve never met anyone who can ensure memory safety in their C&#x2F;C++ without onerous restrictions even more severe than those rust imposes, but maybe you&#x27;re superhuman.</div><br/><div id="38021519" class="c"><input type="checkbox" id="c-38021519" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38019992">parent</a><span>|</span><a href="#38020002">next</a><span>|</span><label class="collapse" for="c-38021519">[-]</label><label class="expand" for="c-38021519">[2 more]</label></div><br/><div class="children"><div class="content">And saying c++ has more mature tooling seems insane too. Anyone who has had to mess with depedency trees using git submodules and cmake, conan, bazel, vcpkg, and meson would not call the tooling, oh and hunter too!, mature.</div><br/><div id="38023045" class="c"><input type="checkbox" id="c-38023045" checked=""/><div class="controls bullet"><span class="by">yagni_dev</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38021519">parent</a><span>|</span><a href="#38020002">next</a><span>|</span><label class="collapse" for="c-38023045">[-]</label><label class="expand" for="c-38023045">[1 more]</label></div><br/><div class="children"><div class="content">You have no idea what tooling means in this context!</div><br/></div></div></div></div></div></div><div id="38020002" class="c"><input type="checkbox" id="c-38020002" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38019853">parent</a><span>|</span><a href="#38019992">prev</a><span>|</span><a href="#38020479">next</a><span>|</span><label class="collapse" for="c-38020002">[-]</label><label class="expand" for="c-38020002">[6 more]</label></div><br/><div class="children"><div class="content">A full 70% of security vulnerabilities are caused by memory safety issues. As professionals we need to get serious and have memory safety as a baseline requirement.</div><br/><div id="38020054" class="c"><input type="checkbox" id="c-38020054" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38020002">parent</a><span>|</span><a href="#38020479">next</a><span>|</span><label class="collapse" for="c-38020054">[-]</label><label class="expand" for="c-38020054">[5 more]</label></div><br/><div class="children"><div class="content">So we shouldn&#x27;t use Rust at all, since Rust is not completely memory safe since it let&#x27;s you disable the borrow checker. We should be serious as professionals and use safe languages like Java, JS, Python, etc.<p>But of course there are use cases where you need memory safety guarantees and bare metal performance. In those cases, sacrificing some memory safety by using Rust is an acceptable tradeoff I think.</div><br/><div id="38020304" class="c"><input type="checkbox" id="c-38020304" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38020054">parent</a><span>|</span><a href="#38020087">next</a><span>|</span><label class="collapse" for="c-38020304">[-]</label><label class="expand" for="c-38020304">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is not completely memory safe since it let&#x27;s you disable the borrow checker.<p>No, it doesn&#x27;t. What&#x27;s interesting isn&#x27;t so much that random HN posters believe this sort of thing, because hey, who needs to know anything about a topic to post their opinion on a forum right? No, what&#x27;s fascinating is that this applies to people like Herb Sutter in his &quot;cpp2&quot; language, here&#x27;s Herb:<p>&gt; I don’t like monolithic &quot;unsafe&quot; that turns off checking for all rules<p>Nobody does that. It&#x27;s possible Herb knows that and is being deceitful but honestly I think it&#x27;s more likely that without investigating at all Herb has just decided everybody else is an idiot...</div><br/></div></div><div id="38020087" class="c"><input type="checkbox" id="c-38020087" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38020054">parent</a><span>|</span><a href="#38020304">prev</a><span>|</span><a href="#38020575">next</a><span>|</span><label class="collapse" for="c-38020087">[-]</label><label class="expand" for="c-38020087">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I forgot I was on Hacker News.<p>All memory-safe languages are built on an unsafe foundation. The Java HotSpot VM is <i>very</i> unsafe C++. That&#x27;s just how computers work.<p>You aren&#x27;t meaningfully sacrificing memory safety by using Rust because the unsafe sections are clearly marked out. That&#x27;s similar to unsafe C#, Python with ctypes, and many other memory-safe languages.</div><br/></div></div><div id="38020575" class="c"><input type="checkbox" id="c-38020575" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38020054">parent</a><span>|</span><a href="#38020087">prev</a><span>|</span><a href="#38021494">next</a><span>|</span><label class="collapse" for="c-38020575">[-]</label><label class="expand" for="c-38020575">[1 more]</label></div><br/><div class="children"><div class="content">Marking code unsafe lets you write memory-safe code that the borrow checker can&#x27;t verify. That increases the risk of bugs but it is not the same as disabling memory safety. It is a subtle distinction.</div><br/></div></div><div id="38021494" class="c"><input type="checkbox" id="c-38021494" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38020054">parent</a><span>|</span><a href="#38020575">prev</a><span>|</span><a href="#38020479">next</a><span>|</span><label class="collapse" for="c-38021494">[-]</label><label class="expand" for="c-38021494">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget safety from data races. Rust&#x27;s borrow checking provides much stronger protection against those than java, go, c# etc. So we shouldn&#x27;t use them either.</div><br/></div></div></div></div></div></div><div id="38020479" class="c"><input type="checkbox" id="c-38020479" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38019853">parent</a><span>|</span><a href="#38020002">prev</a><span>|</span><a href="#38019958">next</a><span>|</span><label class="collapse" for="c-38020479">[-]</label><label class="expand" for="c-38020479">[1 more]</label></div><br/><div class="children"><div class="content">Beyond memory safety, Rust&#x27;s other advantages over C++ are simply that it has a far better type system (by nature of ADTs), cleaner and more consistent syntax, cleaner tooling overall, and a far better module&#x2F;modularity story.<p>That, and the borrowing&#x2F;safety aspects of Rust also shake out into threading&#x2F;concurrency, where the compiler does a pretty good job of forcing you to adopt better practices in regards to state sharing, locking, concurrency.<p>Cargo, though... I am coming around to thinking isn&#x27;t great -- workspace support remains half-assed, especially... and crates.io is amateur-hour for reasons many people have pointed out elsewhere on this post. I have been tempted to switch my personal projects to bazel, with 3rd-party deps checked in&#x2F;submoduled.</div><br/></div></div><div id="38019958" class="c"><input type="checkbox" id="c-38019958" checked=""/><div class="controls bullet"><span class="by">jackpeterfletch</span><span>|</span><a href="#38019853">parent</a><span>|</span><a href="#38020479">prev</a><span>|</span><a href="#38019948">next</a><span>|</span><label class="collapse" for="c-38019958">[-]</label><label class="expand" for="c-38019958">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Do you need memory safety?<p>I think that’s an unusual way frame that requirement.<p>All programs need to handle memory _correctly_. Very few seg fault as part of expected operation.</div><br/><div id="38020172" class="c"><input type="checkbox" id="c-38020172" checked=""/><div class="controls bullet"><span class="by">jrpelkonen</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38019958">parent</a><span>|</span><a href="#38020027">next</a><span>|</span><label class="collapse" for="c-38020172">[-]</label><label class="expand" for="c-38020172">[1 more]</label></div><br/><div class="children"><div class="content">Segfaults are not actually even the worst outcome, corrupting the program state yet still trucking along can lead to far worse consequences.</div><br/></div></div><div id="38020027" class="c"><input type="checkbox" id="c-38020027" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#38019853">root</a><span>|</span><a href="#38019958">parent</a><span>|</span><a href="#38020172">prev</a><span>|</span><a href="#38019948">next</a><span>|</span><label class="collapse" for="c-38020027">[-]</label><label class="expand" for="c-38020027">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you need memory safety guarantees?<p>Is that better?</div><br/></div></div></div></div></div></div><div id="38022774" class="c"><input type="checkbox" id="c-38022774" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#38019853">prev</a><span>|</span><a href="#38019795">next</a><span>|</span><label class="collapse" for="c-38022774">[-]</label><label class="expand" for="c-38022774">[1 more]</label></div><br/><div class="children"><div class="content">I tried Rust briefly and it had that &quot;Ocaml&quot; feel of solving a puzzle.</div><br/></div></div><div id="38019795" class="c"><input type="checkbox" id="c-38019795" checked=""/><div class="controls bullet"><span class="by">strangescript</span><span>|</span><a href="#38022774">prev</a><span>|</span><a href="#38019717">next</a><span>|</span><label class="collapse" for="c-38019795">[-]</label><label class="expand" for="c-38019795">[1 more]</label></div><br/><div class="children"><div class="content">I love Rust but saying your aren&#x27;t sure if its worth it after three years is a red flag.</div><br/></div></div><div id="38019717" class="c"><input type="checkbox" id="c-38019717" checked=""/><div class="controls bullet"><span class="by">jjn2009</span><span>|</span><a href="#38019795">prev</a><span>|</span><a href="#38022365">next</a><span>|</span><label class="collapse" for="c-38019717">[-]</label><label class="expand" for="c-38019717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I code better in other languages now<p>I feel this one, something about spending too much time in JS makes me not want to write clean software..</div><br/></div></div><div id="38022365" class="c"><input type="checkbox" id="c-38022365" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#38019717">prev</a><span>|</span><a href="#38022361">next</a><span>|</span><label class="collapse" for="c-38022365">[-]</label><label class="expand" for="c-38022365">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The Rust standard library is enormous.&quot;<p>Years ago I tried compiling a rust sample program.  The binary size was one thing that put me off.<p>Today, I see the issue of large binary size has been addressed.  The binary I get is sufficiently small.<p>If this issue of ~500M standard library is fixed, e.g., if some of it is made optional not mandatory, I will give rust another try.</div><br/></div></div><div id="38022361" class="c"><input type="checkbox" id="c-38022361" checked=""/><div class="controls bullet"><span class="by">blackoil</span><span>|</span><a href="#38022365">prev</a><span>|</span><a href="#38022732">next</a><span>|</span><label class="collapse" for="c-38022361">[-]</label><label class="expand" for="c-38022361">[1 more]</label></div><br/><div class="children"><div class="content">Is Rust a replacement for only C&#x2F;C++ or also Java&#x2F;Python&#x2F;C#&#x2F;TS? In the latter, I already get some memory safety which I believe is one of the biggest selling points of Rust. Are other benefits of language strong enough that we look into it to develop projects traditionally built in Java or Node?</div><br/></div></div><div id="38022732" class="c"><input type="checkbox" id="c-38022732" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#38022361">prev</a><span>|</span><a href="#38020198">next</a><span>|</span><label class="collapse" for="c-38022732">[-]</label><label class="expand" for="c-38022732">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Refactoring can be a slog<p>This made me not want to try Rust. I was coding vanilla JavaScript for a very long time before trying TypeScript but when I did I was amazed at how much easier refactoring became. That alone made me very excited about type systems and I instantly started looking at Rust, thinking it would be even better. Apparently not. Maybe the sweet spot (for me) is TypeScript.</div><br/><div id="38023047" class="c"><input type="checkbox" id="c-38023047" checked=""/><div class="controls bullet"><span class="by">muixoozie</span><span>|</span><a href="#38022732">parent</a><span>|</span><a href="#38020198">next</a><span>|</span><label class="collapse" for="c-38023047">[-]</label><label class="expand" for="c-38023047">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, I find refactoring in Rust a joy.</div><br/></div></div></div></div><div id="38020198" class="c"><input type="checkbox" id="c-38020198" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#38022732">prev</a><span>|</span><a href="#38020167">next</a><span>|</span><label class="collapse" for="c-38020198">[-]</label><label class="expand" for="c-38020198">[1 more]</label></div><br/><div class="children"><div class="content">Why each article about project completion in Rust is read as ex-husband words about his ex-wife:<p>- I loved here. I am still is. But we needed a divorce.</div><br/></div></div><div id="38020167" class="c"><input type="checkbox" id="c-38020167" checked=""/><div class="controls bullet"><span class="by">RantyDave</span><span>|</span><a href="#38020198">prev</a><span>|</span><a href="#38021025">next</a><span>|</span><label class="collapse" for="c-38020167">[-]</label><label class="expand" for="c-38020167">[2 more]</label></div><br/><div class="children"><div class="content">Re: async, rust is a down to the metal language. IE library yes, runtime no. Async implementations are all either runtimes (Javascript), or libraries that implement a runtime (Python). Under the circumstances I think it&#x27;s fair that rust has less than ideal async.<p>I still like threads, but the I&#x27;m old and uncool.</div><br/><div id="38020660" class="c"><input type="checkbox" id="c-38020660" checked=""/><div class="controls bullet"><span class="by">rstuart4133</span><span>|</span><a href="#38020167">parent</a><span>|</span><a href="#38021025">next</a><span>|</span><label class="collapse" for="c-38020660">[-]</label><label class="expand" for="c-38020660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I still like threads, but the I&#x27;m old and uncool.<p>Hey, I resemble that remark.<p>But I disagree with it.  Green threads give you all the advantages of async, but with less of the hairs.  In particular no special syntax or change of programming style is required.  Yet underneath green threads and async just different styles of event driven I&#x2F;O, so both run at similar speeds and excel at the same tasks.  (Actually green threads should run faster, as storing state on a stack is generally faster than malloc.)<p>I have no idea why Rust abandoned green threads in favour of async.  Actually, that&#x27;s a partial lie - there have been far too many words wasted on explaining why.  The problem is the reasons they give look to be an caused by design decisions they made in their implementation.  The primary objection seems to be speed.  The current async is indeed faster than their old green thread implementation.  But that was caused by their choosing to avoid coloured code in their green threads (maybe they were copying Go?).  Other objections were similarly to do with the implementation they threw away, not green threads themselves.</div><br/></div></div></div></div><div id="38021025" class="c"><input type="checkbox" id="c-38021025" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#38020167">prev</a><span>|</span><label class="collapse" for="c-38021025">[-]</label><label class="expand" for="c-38021025">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It also looks like (soon) you’ll finally be able to configure global lints for a project. Until now, you had to hack your solution to keep lints consistent for projects. In Wick, we use a script to automatically update inline lint configurations for a few dozen crates. It took years for the Rust community to land on a solution for this, which brings us to…<p>Wow, as the author of that feature, I&#x27;m surprised to see someone was so passionate about it.  I&#x27;ve found that many times I&#x27;ve been having to tell people why they should care about it.<p>&gt; I don’t know why. Maybe the pressure to maintain stable APIs, along with Rust’s granular type system, makes it difficult for library owners to iterate. It’s hard to accept a minor change if it would result in a major version bump.<p>There is a tension between people wanting features and people not wanting to deal with version bumps.  I&#x27;ve seen this a lot in maintaining clap, especially when it went from unmaintained for years to having active releases.<p>As for cargo, the compatibility guarantees are tough.  Take the lints table.  We can&#x27;t throw in a first try, knowing we can fix in in a cargo 2.0.  We are tied into the rust project itself which means we have the same compatibility guarantees.  This is one reason we generally encourage trying ideas out in third-party plugins before we integrate them in directly since they can break compatibility.<p>&gt; You can’t even publish a crate that has local dev dependencies<p>You can; cargo automatically strips them.  However, if you tell cargo that there is a version of it in the registry (by setting the version), then it must be published.  This is why when I redesigned `cargo add` for being merged into cargo, I made it so `cargo add --path ..&#x2F;foo --dev` will not add the `version` field.  We do need to find ways to clarify that the purpose of the version field is for looking it up in the registry.<p>Allowing the dev dependencies to be stripped also helps with issues of circular dev-dependencies.<p>&gt; However, many developers break large projects down into smaller modules naturally, and you can’t publish a parent crate that has sub-crates that only exist within itself.<p>We do have an RFC for this: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3452">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3452</a><p>The most complex part is the Index, figuring out how to represent it in the metadata tables we maintain so we avoid having to download every `.crate` file.<p>I also worry there might be tech debt around assumptions of there being a single version of a package when nested packages will easily break that.<p>&gt; You can see the problem manifest in the sheer number of utility crates designed to simplify publishing workspaces. Each works with a subset of configurations, and the “one true way” of setting workspaces up still eludes me. When I publish Wick, it’s frequently an hour+ of effort combining manual, repetitive tasks with tools that only partially work.<p>I&#x27;m a bit confused on this point.  While there are things to improve around publishing workspaces, I&#x27;m not sure how this relates to setting workspaces up or what problems they&#x27;ve had with that.  I&#x27;d also be curious what problems they had with releasing packages.  I don&#x27;t think I&#x27;ve seen issues from them in cargo-release&#x27;s Issues.</div><br/></div></div></div></div></div></div></div></body></html>