<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683536457102" as="style"/><link rel="stylesheet" href="styles.css?v=1683536457102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://adrianco.medium.com/so-many-bad-takes-what-is-there-to-learn-from-the-prime-video-microservices-to-monolith-story-4bd0970423d4">The Prime Video microservices to monolith story</a> <span class="domain">(<a href="https://adrianco.medium.com">adrianco.medium.com</a>)</span></div><div class="subtext"><span>mparnisari</span> | <span>283 comments</span></div><br/><div><div id="35854555" class="c"><input type="checkbox" id="c-35854555" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35858235">next</a><span>|</span><label class="collapse" for="c-35854555">[-]</label><label class="expand" for="c-35854555">[36 more]</label></div><br/><div class="children"><div class="content">I completed my role as a CTO for a company several years ago. I chose a boring stack with plenty of developers available: MySQL, PHP with Laravel, and Angular 2. Since then, I&#x27;ve been a founding engineer at some startups using the latest, cutting-edge tech stacks. I&#x27;m proud to announce that the stack I managed as CTO is still running stable and smooth with minimal intervention, and it remains easy to modify. Meanwhile, the startups with flashy stacks and nearly impossible-to-debug architectures have gone out of business.<p>It amazes me how some companies still adopt the &quot;build it and they will come&quot; approach, and when confronted with harsh reality, they double down on building (and especially increasing architectural complexity). CEOs, if you can&#x27;t attract customers with an idea or don&#x27;t have a vertical that people are eager to pay for, cramming 1000 half-baked features into a microservice architecture and using the latest programming language &#x2F; paradigm won&#x27;t save your company!</div><br/><div id="35859101" class="c"><input type="checkbox" id="c-35859101" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#35854555">parent</a><span>|</span><a href="#35855036">next</a><span>|</span><label class="collapse" for="c-35859101">[-]</label><label class="expand" for="c-35859101">[3 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;boringtechnology.club&#x2F;" rel="nofollow">http:&#x2F;&#x2F;boringtechnology.club&#x2F;</a> remains relevant, and I try to apply it wherever I go with... varying results.<p>One issue though is that it seems more difficult to find competent developers for boring stacks, because they&#x27;re always looking for the next challenge, the next thing they consider interesting or what looks good on their profile (vs what is best for their employer).</div><br/><div id="35859454" class="c"><input type="checkbox" id="c-35859454" checked=""/><div class="controls bullet"><span class="by">Volrath89</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35859101">parent</a><span>|</span><a href="#35859455">next</a><span>|</span><label class="collapse" for="c-35859454">[-]</label><label class="expand" for="c-35859454">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to work on a &quot;boring&quot; stack and just ship features and build stuff but... companies are like a herd, and they all ask for the same microservices&#x27; technologies when interviewing, no matter what they are building.<p>So if I stay with a boring stack, I&#x27;d lose competitive advantage and face the potential of being &quot;un-hirable&quot; in the not-so-distant future.</div><br/></div></div><div id="35859455" class="c"><input type="checkbox" id="c-35859455" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35859101">parent</a><span>|</span><a href="#35859454">prev</a><span>|</span><a href="#35855036">next</a><span>|</span><label class="collapse" for="c-35859455">[-]</label><label class="expand" for="c-35859455">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the word &quot;boring&quot; scare some people away, but it is a good contrast to exciting new technology anyway. &quot;Mature&quot; would probably the more appropriate term. Many times the exciting stuff is the problem domain itself. But developers tend to be more excited about new technologies than about customer needs.</div><br/></div></div></div></div><div id="35855036" class="c"><input type="checkbox" id="c-35855036" checked=""/><div class="controls bullet"><span class="by">goodrubyist</span><span>|</span><a href="#35854555">parent</a><span>|</span><a href="#35859101">prev</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35855036">[-]</label><label class="expand" for="c-35855036">[27 more]</label></div><br/><div class="children"><div class="content">Were those startups that went out of business did so because of their stacks&#x2F;architecture, or are you confusing correlation with causation? And, there is a good reason people shy away from PHP, and it has nothing to do with trying to be &quot;flashy.&quot; There should be a name for this kind of fallacy.</div><br/><div id="35855994" class="c"><input type="checkbox" id="c-35855994" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855036">parent</a><span>|</span><a href="#35858496">next</a><span>|</span><label class="collapse" for="c-35855994">[-]</label><label class="expand" for="c-35855994">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Were those startups that went out of business did so because of their stacks&#x2F;architecture, or are you confusing correlation with causation?<p>As far as I am aware, and I can tell, it wasn&#x27;t because of the stacks &#x2F; architecture, but lack of product market fit. The fact that the response to lack of PMF was to double down on product features and tech (instead of a business pivot), in my opinion, was what made the investor money go poof and the startup die down. I&#x27;ve seen this happen&#x27; in too many places (as an employee or consultant) to be a coincidence.<p>&gt; And, there is a good reason people shy away from PHP, and it has nothing to do with trying to be &quot;flashy.&quot; There should be a name for this kind of fallacy.<p>Different stacks for different use cases. If I can&#x27;t get money with a shitty PHP product offering, it&#x27;s probably best to figure out why instead of attributing it to my tech stack.</div><br/><div id="35857457" class="c"><input type="checkbox" id="c-35857457" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855994">parent</a><span>|</span><a href="#35858496">next</a><span>|</span><label class="collapse" for="c-35857457">[-]</label><label class="expand" for="c-35857457">[1 more]</label></div><br/><div class="children"><div class="content">I have totally seen that too. For me one of the biggest dangers in any tech project, startups especially is caring about outputs more than outcomes. &quot;Look at all the things we&#x27;re building! Look at how hard we&#x27;re working!&quot; But those outputs don&#x27;t matter if they aren&#x27;t creating more value for the customer.</div><br/></div></div></div></div><div id="35858496" class="c"><input type="checkbox" id="c-35858496" checked=""/><div class="controls bullet"><span class="by">jaapbadlands</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855036">parent</a><span>|</span><a href="#35855994">prev</a><span>|</span><a href="#35855482">next</a><span>|</span><label class="collapse" for="c-35858496">[-]</label><label class="expand" for="c-35858496">[1 more]</label></div><br/><div class="children"><div class="content">The point wasn&#x27;t that you should use PHP, it was to not jump on stack trends. There is a name for your kind of fallacy.</div><br/></div></div><div id="35855482" class="c"><input type="checkbox" id="c-35855482" checked=""/><div class="controls bullet"><span class="by">iLoveOncall</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855036">parent</a><span>|</span><a href="#35858496">prev</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35855482">[-]</label><label class="expand" for="c-35855482">[23 more]</label></div><br/><div class="children"><div class="content">&gt; there is a good reason people shy away from PHP<p>Please share it. And don&#x27;t rely on articles that are more than a decade and 3 or 4 versions of PHP old.</div><br/><div id="35859321" class="c"><input type="checkbox" id="c-35859321" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855482">parent</a><span>|</span><a href="#35855656">next</a><span>|</span><label class="collapse" for="c-35859321">[-]</label><label class="expand" for="c-35859321">[1 more]</label></div><br/><div class="children"><div class="content">IMHO this very discussion factors in whether you&#x27;ll want a PHP stack or not.<p>If you&#x27;re looking for pragmatic devs that don&#x27;t care much about the trends, the community or peers&#x27; general opinion about a technology, going with PHP will get you this type in spades. Especially if you&#x27;re looking for experienced engineers.<p>If you want devs that care about thoughtful designs, elegant solutions and want to enjoy the community, it will be a lot more difficult (not impossible, but it&#x27;s an uphill battle)<p>And this has little to do with PHP&#x27;s viability per se, there&#x27;s just so much baggage that most devs will self select in one side or another. A language&#x27;s base design philosophy matters, and it&#x27;s always better to chose a stack that matches your own philosophy.</div><br/></div></div><div id="35855656" class="c"><input type="checkbox" id="c-35855656" checked=""/><div class="controls bullet"><span class="by">5Qn8mNbc2FNCiVV</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855482">parent</a><span>|</span><a href="#35859321">prev</a><span>|</span><a href="#35856708">next</a><span>|</span><label class="collapse" for="c-35855656">[-]</label><label class="expand" for="c-35855656">[6 more]</label></div><br/><div class="children"><div class="content">Afaik you cannot discern null and undefined. So, not there and &quot;null&quot;? Either that or I&#x27;m going to have to have a good talk with my colleague</div><br/><div id="35858108" class="c"><input type="checkbox" id="c-35858108" checked=""/><div class="controls bullet"><span class="by">skinkestek</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855656">parent</a><span>|</span><a href="#35856001">next</a><span>|</span><label class="collapse" for="c-35858108">[-]</label><label class="expand" for="c-35858108">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6905491&#x2F;how-to-tell-whether-a-variable-is-null-or-undefined-in-php" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6905491&#x2F;how-to-tell-whet...</a><p>At the language level PHP has about the same problems as JS.<p>Thankfully it looks uglier so people get an early warning before using it for everything.</div><br/></div></div><div id="35856001" class="c"><input type="checkbox" id="c-35856001" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855656">parent</a><span>|</span><a href="#35858108">prev</a><span>|</span><a href="#35855854">next</a><span>|</span><label class="collapse" for="c-35856001">[-]</label><label class="expand" for="c-35856001">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Afaik you cannot discern null and undefined.<p>This is a discussion for us tech folks. When it comes to business. Customers don&#x27;t give a rat&#x27;s ass about this as long as the product provides them with value.<p>If you&#x27;re flooded with customers and the tech stack is a pain in the ass, perhaps it would be a good time to start considering this, but until you have this problem, the technical aspects are just wasting investor money and &#x2F; or engineering time.</div><br/><div id="35858671" class="c"><input type="checkbox" id="c-35858671" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856001">parent</a><span>|</span><a href="#35855854">next</a><span>|</span><label class="collapse" for="c-35858671">[-]</label><label class="expand" for="c-35858671">[2 more]</label></div><br/><div class="children"><div class="content">When I (an average developer) accidentally check for null but not undefined in the code and it causes a bug, the customer might care a lot.</div><br/><div id="35858931" class="c"><input type="checkbox" id="c-35858931" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858671">parent</a><span>|</span><a href="#35855854">next</a><span>|</span><label class="collapse" for="c-35858931">[-]</label><label class="expand" for="c-35858931">[1 more]</label></div><br/><div class="children"><div class="content">There is always a balance to strike between development and delivery. When creating a system with high potential failure costs, it&#x27;s important to select a technology stack that minimizes common errors for developers.<p>For most companies, issues like `undefined | null` bugs can be resolved with just a few code adjustments, resulting in only minor inconvenience for customers. As long as problems are addressed and the product provides value, customers will continue to support it.<p>There are CEOs and CTOs that feel differently. I wish them luck.</div><br/></div></div></div></div></div></div><div id="35855854" class="c"><input type="checkbox" id="c-35855854" checked=""/><div class="controls bullet"><span class="by">iLoveOncall</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855656">parent</a><span>|</span><a href="#35856001">prev</a><span>|</span><a href="#35856708">next</a><span>|</span><label class="collapse" for="c-35855854">[-]</label><label class="expand" for="c-35855854">[1 more]</label></div><br/><div class="children"><div class="content">Go have your talk [1]. But that&#x27;s a pretty weak argument anyway given that:<p>1. Other languages also do not have this distinction (Python for example AFAIK),<p>2. It&#x27;s relatively useless. I get the value of it in JavaScript which has a lot of asynchronous code and frontend where the behavior may indeed be very different between null and undefined, but in a server-side application I don&#x27;t think the nuance is necessary at runtime, and potential programming mistakes involving that can be caught by a linter.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6905491&#x2F;how-to-tell-whether-a-variable-is-null-or-undefined-in-php" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6905491&#x2F;how-to-tell-whet...</a></div><br/></div></div></div></div><div id="35856708" class="c"><input type="checkbox" id="c-35856708" checked=""/><div class="controls bullet"><span class="by">proxyon</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855482">parent</a><span>|</span><a href="#35855656">prev</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35856708">[-]</label><label class="expand" for="c-35856708">[15 more]</label></div><br/><div class="children"><div class="content">How about the fact that most of us are experienced and can attest that PHP is the worst language we&#x27;ve ever used in our careers?</div><br/><div id="35858917" class="c"><input type="checkbox" id="c-35858917" checked=""/><div class="controls bullet"><span class="by">coolg54321</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35859117">next</a><span>|</span><label class="collapse" for="c-35858917">[-]</label><label class="expand" for="c-35858917">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so, i&#x27;ve used PHP at work for more than 10 years till 7.4 point mostly Symfony, it has it&#x27;s own quirks but i still feel PHP really pragmatic. I don&#x27;t have any strong feelings against it.<p>Nowadays im on django&#x2F;python because im in a python shop and I like python too.</div><br/></div></div><div id="35859117" class="c"><input type="checkbox" id="c-35859117" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35858917">prev</a><span>|</span><a href="#35858597">next</a><span>|</span><label class="collapse" for="c-35859117">[-]</label><label class="expand" for="c-35859117">[2 more]</label></div><br/><div class="children"><div class="content">I disagree; it&#x27;s not the language that&#x27;s bad, it&#x27;s the community. Too much tech debt that was never removed, too many people that profess to be experts on the internet and give bad examples, and too many people full of themselves building and rebuilding their own frameworks. That was the issue 10, 15 years ago anyway, things have improved but it means people have to pick established frameworks like Laravel.</div><br/><div id="35859201" class="c"><input type="checkbox" id="c-35859201" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35859117">parent</a><span>|</span><a href="#35858597">next</a><span>|</span><label class="collapse" for="c-35859201">[-]</label><label class="expand" for="c-35859201">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really separate a language from its community, though.<p>You&#x27;re getting paid to deliver business logic, which means most work is going to be gluing together libraries. This inherently means relying on community-written code, and related stuff like documentation and StackOverflow answers.<p>If the community is bad, the language isn&#x27;t worth using.</div><br/></div></div></div></div><div id="35858597" class="c"><input type="checkbox" id="c-35858597" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35859117">prev</a><span>|</span><a href="#35857997">next</a><span>|</span><label class="collapse" for="c-35858597">[-]</label><label class="expand" for="c-35858597">[2 more]</label></div><br/><div class="children"><div class="content">I can think of far worse fates<p>Some people write whole-ass applications in bash, the psychopaths</div><br/><div id="35858614" class="c"><input type="checkbox" id="c-35858614" checked=""/><div class="controls bullet"><span class="by">proxyon</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858597">parent</a><span>|</span><a href="#35857997">next</a><span>|</span><label class="collapse" for="c-35858614">[-]</label><label class="expand" for="c-35858614">[1 more]</label></div><br/><div class="children"><div class="content">Ok that&#x27;s even worse</div><br/></div></div></div></div><div id="35857997" class="c"><input type="checkbox" id="c-35857997" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35858597">prev</a><span>|</span><a href="#35858867">next</a><span>|</span><label class="collapse" for="c-35857997">[-]</label><label class="expand" for="c-35857997">[5 more]</label></div><br/><div class="children"><div class="content">Spoken like someone who&#x27;s never used Matlab :)</div><br/><div id="35858542" class="c"><input type="checkbox" id="c-35858542" checked=""/><div class="controls bullet"><span class="by">itake</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35857997">parent</a><span>|</span><a href="#35858867">next</a><span>|</span><label class="collapse" for="c-35858542">[-]</label><label class="expand" for="c-35858542">[4 more]</label></div><br/><div class="children"><div class="content">&gt; indexes start at 1<p>- no one<p>-- Matlab</div><br/><div id="35858642" class="c"><input type="checkbox" id="c-35858642" checked=""/><div class="controls bullet"><span class="by">MiyamotoAkira</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858542">parent</a><span>|</span><a href="#35858867">next</a><span>|</span><label class="collapse" for="c-35858642">[-]</label><label class="expand" for="c-35858642">[3 more]</label></div><br/><div class="children"><div class="content">Pascal had indexes starting at 1 too.<p>Starting indexes at 0 makes sense when you want to enable the developer to manipulate memory (for example, C)<p>Indexes starting at 1 matches with a more natural ordinal sequencing.</div><br/><div id="35859356" class="c"><input type="checkbox" id="c-35859356" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858642">parent</a><span>|</span><a href="#35859308">next</a><span>|</span><label class="collapse" for="c-35859356">[-]</label><label class="expand" for="c-35859356">[1 more]</label></div><br/><div class="children"><div class="content">The most evil was Visual Basic where you could configure the default starting index (OPTION BASE 1), leading to weird bugs when multiple people worked on the same codebase.</div><br/></div></div><div id="35859308" class="c"><input type="checkbox" id="c-35859308" checked=""/><div class="controls bullet"><span class="by">haspok</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858642">parent</a><span>|</span><a href="#35859356">prev</a><span>|</span><a href="#35858867">next</a><span>|</span><label class="collapse" for="c-35859308">[-]</label><label class="expand" for="c-35859308">[1 more]</label></div><br/><div class="children"><div class="content">&gt; indexes starting at...<p>&quot;I don&#x27;t understand the word &#x27;index&#x27;&quot;.<p>- a functional programmer</div><br/></div></div></div></div></div></div></div></div><div id="35858867" class="c"><input type="checkbox" id="c-35858867" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35857997">prev</a><span>|</span><a href="#35856871">next</a><span>|</span><label class="collapse" for="c-35858867">[-]</label><label class="expand" for="c-35858867">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I feel like PHP is a massive hiring risk. I personally wouldn&#x27;t want to touch any PHP code unless I&#x27;m paid a massive premium for it.<p>(I mostly write Python professionally, and use Python, Swift and Rust in personal projects in case anyone is wondering.)</div><br/></div></div><div id="35856871" class="c"><input type="checkbox" id="c-35856871" checked=""/><div class="controls bullet"><span class="by">aarondf</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856708">parent</a><span>|</span><a href="#35858867">prev</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35856871">[-]</label><label class="expand" for="c-35856871">[3 more]</label></div><br/><div class="children"><div class="content">Genuine question, when was the last time you wrote PHP?</div><br/><div id="35857022" class="c"><input type="checkbox" id="c-35857022" checked=""/><div class="controls bullet"><span class="by">proxyon</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35856871">parent</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35857022">[-]</label><label class="expand" for="c-35857022">[2 more]</label></div><br/><div class="children"><div class="content">5 years ago and I wish I hadn&#x27;t.</div><br/><div id="35859179" class="c"><input type="checkbox" id="c-35859179" checked=""/><div class="controls bullet"><span class="by">chalcolithic</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35857022">parent</a><span>|</span><a href="#35858685">next</a><span>|</span><label class="collapse" for="c-35859179">[-]</label><label class="expand" for="c-35859179">[1 more]</label></div><br/><div class="children"><div class="content">It was fine in the late 90s.
Very adequate for the hosting landscape.
I have not touched it since that time</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="35858685" class="c"><input type="checkbox" id="c-35858685" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#35854555">parent</a><span>|</span><a href="#35855036">prev</a><span>|</span><a href="#35858818">next</a><span>|</span><label class="collapse" for="c-35858685">[-]</label><label class="expand" for="c-35858685">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you that choosing a boring stack and focusing on down to earth, understandable and pragmatic architectural principles offers good probabilities to get a maintainable product.<p>I would like to interject, though, that stack and architecture do not weigh equally on these probabilities. My observation has been that tech organizations fail when they loose their grip on pragmatism, regardless the stack.<p>That doesn&#x27;t mean that you should force the latest, unproven, JS framework on 200 engineers but if you have the culture for it one can easily succeed with react+JVM, elm+Haskell, etc.<p>One interesting thing also is access to devs as each tech stack will attract different groups of the Dev society which will in turn affect your success chances.</div><br/></div></div><div id="35858818" class="c"><input type="checkbox" id="c-35858818" checked=""/><div class="controls bullet"><span class="by">yread</span><span>|</span><a href="#35854555">parent</a><span>|</span><a href="#35858685">prev</a><span>|</span><a href="#35855633">next</a><span>|</span><label class="collapse" for="c-35858818">[-]</label><label class="expand" for="c-35858818">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s because it&#x27;s fun to work at a company that is tech-first (as opposed to just using tech as a tool for growing business) but it leads to doing things in complicated and risky ways &quot;because we&#x27;re a tech company&quot;</div><br/><div id="35859016" class="c"><input type="checkbox" id="c-35859016" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35858818">parent</a><span>|</span><a href="#35855633">next</a><span>|</span><label class="collapse" for="c-35859016">[-]</label><label class="expand" for="c-35859016">[1 more]</label></div><br/><div class="children"><div class="content">I guess it also depends on the person. I get off on providing customer value by addressing business needs. I scratch the other itch late at night with unspeakable horrors that never see the light of day.</div><br/></div></div></div></div><div id="35855633" class="c"><input type="checkbox" id="c-35855633" checked=""/><div class="controls bullet"><span class="by">o_m</span><span>|</span><a href="#35854555">parent</a><span>|</span><a href="#35858818">prev</a><span>|</span><a href="#35858235">next</a><span>|</span><label class="collapse" for="c-35855633">[-]</label><label class="expand" for="c-35855633">[2 more]</label></div><br/><div class="children"><div class="content">There is a middle ground to this. Sooner or later you have to upgrade. There might be a security upgrade or the old system doesn&#x27;t play nice with other systems. So you are forced to upgrade to something more non-boring, even if you are using the same tech. It also get harded to hire developers. I doubt there is many devs that want to work on Angular 2 these days.</div><br/><div id="35856034" class="c"><input type="checkbox" id="c-35856034" checked=""/><div class="controls bullet"><span class="by">ThalesX</span><span>|</span><a href="#35854555">root</a><span>|</span><a href="#35855633">parent</a><span>|</span><a href="#35858235">next</a><span>|</span><label class="collapse" for="c-35856034">[-]</label><label class="expand" for="c-35856034">[1 more]</label></div><br/><div class="children"><div class="content">The middle ground is that once the tech becomes the <i>actual</i> problem, it might be time to investigate possibilities, until then, customers don&#x27;t care, business people doesn&#x27;t care and the bottom line doesn&#x27;t care. There are not that many companies in the world where the tech stack is their competitive advantage.<p>&gt; I doubt there is many devs that want to work on Angular 2 these days.<p>From my experience, a product that makes money and is able to pay people at market rates, will find said people. Not everyone is an EMACS wielding, Linux wizard that refuses to touch tech out of idealistic concerns.<p>The problem, in my experience, is more often lack of PMF than tech stack (I&#x27;ve seen customers give insane leeway to actually valuable products).</div><br/></div></div></div></div></div></div><div id="35858235" class="c"><input type="checkbox" id="c-35858235" checked=""/><div class="controls bullet"><span class="by">vaidhy</span><span>|</span><a href="#35854555">prev</a><span>|</span><a href="#35854132">next</a><span>|</span><label class="collapse" for="c-35858235">[-]</label><label class="expand" for="c-35858235">[5 more]</label></div><br/><div class="children"><div class="content">I see a lot of about architecture, service design and complexity. One of the key missing piece is around Amazon culture. Promo-driven design is a real deal at Amazon. I am sure this design got someone promoted to principal engineer or higher. If you cannot build complexity into the design, how can you prove your caliber and get promoted.</div><br/><div id="35858772" class="c"><input type="checkbox" id="c-35858772" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#35858235">parent</a><span>|</span><a href="#35858736">next</a><span>|</span><label class="collapse" for="c-35858772">[-]</label><label class="expand" for="c-35858772">[2 more]</label></div><br/><div class="children"><div class="content">Definitely a real phenomenon. Obscure overengineering also serves another purpose: if you want to build a mini-empire, people leave you alone because they don’t have time to fully grok your design, so they can’t provide meaningful feedback. In these companies the burden-of-proof falls on the critic of a design, not the designer. Simply saying “this looks too complex” is treated as “oh, they couldn’t understand this sophisticated piece of engineering”. This is a cultural issue. If your peers don’t grok it quickly, you should return to the drawing board, or at least provide evidence for the extraordinary circumstances that warrants all that complexity.</div><br/><div id="35859149" class="c"><input type="checkbox" id="c-35859149" checked=""/><div class="controls bullet"><span class="by">ownagefool</span><span>|</span><a href="#35858235">root</a><span>|</span><a href="#35858772">parent</a><span>|</span><a href="#35858736">next</a><span>|</span><label class="collapse" for="c-35859149">[-]</label><label class="expand" for="c-35859149">[1 more]</label></div><br/><div class="children"><div class="content">The problem with statement like &quot;this looks too complex&quot; is that it lacks substance and is used as a stick to beat people with, and often has alternative meanings.<p>To combat this, you need to justify the complaint.<p>In the case of lambda, I think being tied into an ecosystem of things that you can&#x27;t run locally is a net loss, but Amazon has done a terrific job at making a bunch of people not super comfortable with compute, see just running a share-nothing process as the way to bridge the gap, like PHP never existed.<p>Same thing happens with IT orgs that end up owning cloud.  You get azure, regardless of whether you want such a thing.</div><br/></div></div></div></div><div id="35858736" class="c"><input type="checkbox" id="c-35858736" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#35858235">parent</a><span>|</span><a href="#35858772">prev</a><span>|</span><a href="#35854132">next</a><span>|</span><label class="collapse" for="c-35858736">[-]</label><label class="expand" for="c-35858736">[2 more]</label></div><br/><div class="children"><div class="content">The article is more about bundling together lambda functions into horizontally scalable containers. Paraphrasing the author:<p>&gt; I think the prime video team&#x27;s presentation should have been called &quot;Moving from lambda to container microservices&quot;<p>There is nothing particularly bad about this move. Prototype something in a FaaS, move it to a container based microservices when you know which features you want and how they perform.<p>Not doing much FaaS prototyping myself but I agree with the author that FaaS beats containers in time to production (even if the difference might be negligible in some cases)</div><br/><div id="35859542" class="c"><input type="checkbox" id="c-35859542" checked=""/><div class="controls bullet"><span class="by">disruptiveink</span><span>|</span><a href="#35858235">root</a><span>|</span><a href="#35858736">parent</a><span>|</span><a href="#35854132">next</a><span>|</span><label class="collapse" for="c-35859542">[-]</label><label class="expand" for="c-35859542">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. The article is stating that there is nothing wrong with the move Prime Video did, and that it was a &quot;serverless to containers&quot; refactoring that somehow the Internet misrepresented as &quot;microservices to monolith&quot; and kicked up entire viral &quot;even Amazon admits that microservices is overengineering!&quot; meme discussions. Which was obvious to anyone who had read the original post, but most people were commenting on what they thought the (incorrect) title meant.<p>I am disappointed that the top comment and all of the discussion is once again not related to the article at hand in the slightest and just focused on the easy &quot;complex is bad, guys!&quot; dunk.</div><br/></div></div></div></div></div></div><div id="35854132" class="c"><input type="checkbox" id="c-35854132" checked=""/><div class="controls bullet"><span class="by">iamleppert</span><span>|</span><a href="#35858235">prev</a><span>|</span><a href="#35854976">next</a><span>|</span><label class="collapse" for="c-35854132">[-]</label><label class="expand" for="c-35854132">[5 more]</label></div><br/><div class="children"><div class="content">If you have a predictable workload (i.e. we ingest 100,000 videos a month with n size) you should be looking at it from that perspective -- how much compute you are going to need, and when. Serverless works well for predictably unpredictable, infrequent workloads that don&#x27;t need to have perfect output (&quot;good enough&quot;).<p>The big mistake I see people make is trying to be overly clever and predict the future workload needs. It never works out like that. Design for your current workload now, if your architecture can handle 10x of that great! Each time your scale from 10x workload you will likely need to redesign the system anyway, so you shouldn&#x27;t pay that tax unless you absolutely have to.<p>There are a lot of limitations of serverless, the big one I experienced was inability to control the host environment and limitations on the slice of memory&#x2F;CPU you get, such that you must take that into consideration when designing your atomic work units. Also paying the distributed computing tax is real and occurs at development and runtime -- things like job tracking and monitoring are important when you have 10,000 processes running -- you start to get into the territory of things that basically never happen on a single machine or small cluster, but become problems with thousands of disparate machines &#x2F; processes.</div><br/><div id="35854784" class="c"><input type="checkbox" id="c-35854784" checked=""/><div class="controls bullet"><span class="by">goostavos</span><span>|</span><a href="#35854132">parent</a><span>|</span><a href="#35854976">next</a><span>|</span><label class="collapse" for="c-35854784">[-]</label><label class="expand" for="c-35854784">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Design for your current workload<p>Please be my friend.<p>The bulk of my job these days is sitting in design reviews trying to convince people that just making up scenarios where you need to scale to 100x isn&#x27;t actually engineering. It&#x27;s exhausting self-indulgence. Nothing is easier than inventing scenarios where you&#x27;ll need to &quot;scale&quot;. It&#x27;s borderline impossible to get software folks to just live in the world that exists in front of their eyes.<p>&quot;Scale&quot; should go back to its original meaning: change relative to some starting point. Slap a trend line on what you know. Do some estimation for what you don&#x27;t. Design accordingly.</div><br/><div id="35859138" class="c"><input type="checkbox" id="c-35859138" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#35854132">root</a><span>|</span><a href="#35854784">parent</a><span>|</span><a href="#35856384">next</a><span>|</span><label class="collapse" for="c-35859138">[-]</label><label class="expand" for="c-35859138">[1 more]</label></div><br/><div class="children"><div class="content">This has been a problem in a few places I&#x27;ve worked at that decided to build &quot;microservices&quot; (read: simple apps that moved the complexity to a higher architectural level, i.e. by having every service talk to every other service over a REST API or event bus), not because it solved a problem they had, but because it MIGHT solve a problem they&#x27;d LIKE to have. Cargo cult, in a nutshell.<p>My current employer is going all-in on serverless because it solved a problem they had with performance. The problem wasn&#x27;t solved by serverless, but by moving away from an old fashioned and unscalable solution. The real problem or bottleneck - a centralized SAP database - has not been solved yet. They would have achieved the same results if they rebuilt their API in a generic Java monolith.<p>Here&#x27;s my prediction: when the crack team of consultants that powered through building a serverless architecture leaves (because they will, one because they&#x27;re consultants and two because they get bored when the problem has been solved), they won&#x27;t be able to find competent developers to take over and the whole thing will be rebuilt again in something they CAN find developers for. I mean it&#x27;s just NodeJS, but the architecture is distributed and much harder to manage than in a simple monolithic app.</div><br/></div></div><div id="35856384" class="c"><input type="checkbox" id="c-35856384" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#35854132">root</a><span>|</span><a href="#35854784">parent</a><span>|</span><a href="#35859138">prev</a><span>|</span><a href="#35854971">next</a><span>|</span><label class="collapse" for="c-35856384">[-]</label><label class="expand" for="c-35856384">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just making up scenarios where you need to scale to 100x isn&#x27;t actually engineering.<p>Even for &quot;peak&quot; Amazon&#x27;s concern seemed limited to about ~5x daily TPS maximums unless one had extraordinary evidence.<p>The counter-balance to limiting resource balooning to 5x scale is introducing Erlang-B modelling. Depending on how many 9s you require, you may need way more service availability than expected.<p>The 100x calculations are probably doubly wrong (both too large and too small), providing negative value false confidence.</div><br/></div></div><div id="35854971" class="c"><input type="checkbox" id="c-35854971" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35854132">root</a><span>|</span><a href="#35854784">parent</a><span>|</span><a href="#35856384">prev</a><span>|</span><a href="#35854976">next</a><span>|</span><label class="collapse" for="c-35854971">[-]</label><label class="expand" for="c-35854971">[1 more]</label></div><br/><div class="children"><div class="content">Yeah unless you are designing the replacement for a system that has already reached it&#x27;s scalability limits you shouldn&#x27;t be worrying too much other than not doing very silly things architecturally.<p>When you are designing replacements though you need to have an idea of what your scalability runway is before the next re-design will be possible. Sometimes that is just 2x, often times it&#x27;s 10x, occasionally it&#x27;s 100x but it&#x27;s all situational.</div><br/></div></div></div></div></div></div><div id="35854976" class="c"><input type="checkbox" id="c-35854976" checked=""/><div class="controls bullet"><span class="by">bhauer</span><span>|</span><a href="#35854132">prev</a><span>|</span><a href="#35854585">next</a><span>|</span><label class="collapse" for="c-35854976">[-]</label><label class="expand" for="c-35854976">[5 more]</label></div><br/><div class="children"><div class="content">Obviously, the article is microservice apologia, but...<p>&gt; <i>They were able to re-use most of their working code by combining it into a single long running microservice that is horizontally scaled using ECS...</i><p>No, it was no longer a microservice; it became a plain service, as in SOA. It was no longer <i>micro</i>. That&#x27;s the whole point.<p>They could have saved time and money had they just made the thing a plain service to begin with. This thing was not sufficiently complicated to warrant the complexity of starting with a bunch of microservices.<p>The article says many hot takes have missed the point, but I think what we&#x27;re seeing here is an example of the two sides talking past one another since the author hasn&#x27;t appreciated the opposition&#x27;s arguments at all.</div><br/><div id="35858707" class="c"><input type="checkbox" id="c-35858707" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#35854976">parent</a><span>|</span><a href="#35858555">next</a><span>|</span><label class="collapse" for="c-35858707">[-]</label><label class="expand" for="c-35858707">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and that’s not the only example of microservice apologia:<p>&gt; They state in the blog that this was quick to build, which is the point. When you are exploring how to construct something, building a prototype in a few days or weeks is a good approach.<p>First, it’s a huge stretch to say its simpler to use microservices. Anything distributed has to deal with consistency, dropped messages, serialization, propagation latency etc. If you choose to ignore those aspects, that doesn’t make it simpler, it just leaves a wrapped gift of complexity to your future coworkers who will have to maintain it.<p>Secondly, this wasn’t the case of building something exploratory for future unpredictable workloads. All the requirements were already available. This tells you an important story: Amazon engineers were not able to estimate upfront how much “serverless” resources were needed, and how this “microservice mesh” would perform. This isn’t surprising, because the more complex a system is, the harder it is to predict how it’ll work under some workload. And it doesn’t help that the microservice preachers have been actively discouraging developers to think about infrastructure.<p>I don’t have a horse in this race. I often hold off with judgment until I have seen the defending side speak. In this case, the defense only strengthens the cause for concern.</div><br/></div></div><div id="35858555" class="c"><input type="checkbox" id="c-35858555" checked=""/><div class="controls bullet"><span class="by">m_mueller</span><span>|</span><a href="#35854976">parent</a><span>|</span><a href="#35858707">prev</a><span>|</span><a href="#35854585">next</a><span>|</span><label class="collapse" for="c-35858555">[-]</label><label class="expand" for="c-35858555">[3 more]</label></div><br/><div class="children"><div class="content">One thing to note is that the transition from smaller to larger services tends to be straight forward, while cutting into smaller can be tricky. Thus IMO there is some merit to keeping them small in the beginning until you can analyse them under production workloads.<p>That being said, in this case here I think some very simple performance &#x2F; cost modelling would have shown the issues with serverless already in the beginning. I do find serverless architecture useful, but not for such a case with heavy base load. Furthermore, data locality is also an important aspect to consider in anything with strong latency or throughput requirements - serverless or not.</div><br/><div id="35858719" class="c"><input type="checkbox" id="c-35858719" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#35854976">root</a><span>|</span><a href="#35858555">parent</a><span>|</span><a href="#35854585">next</a><span>|</span><label class="collapse" for="c-35858719">[-]</label><label class="expand" for="c-35858719">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the other way around - start with monolith (because it&#x27;s easier to change things, it&#x27;s just single pr addressing all places at once) and then, possibly few years later, whatever has crystalized and has clear boundaries with little to no changes coming in or changes contained within this boundary - can be potentially extracted.<p>Just look how over-represented RoR is&#x2F;was as bootstrap tech in known, successful companies.<p>Microservices is not yes&#x2F;no - it&#x27;s a slider. You may find sweet spot at ie. 50&#x2F;50 split like ie. github does, have more or less microservices while keeping core in monolith or services under single versioned monorepo.<p>Microservices are good for satellite services like system integration, pre&#x2F;post-processing, gateways etc.<p>As a rule of thumb whatever can fit single (tech lead + team)&#x27;s &quot;head&quot; - can be monolithic (single monolith or set of services under single versioned monorepo managed by that team). Their job is to provide stable apis&#x2F;uis - otherwise it can be seen as black box by other teams.<p>This is natural way things evolve (teams are created around naturally bounded concepts) and the suggestion is - don&#x27;t break it by creating mismatches, keep it in harmony. If something creates measurable problems, slowly form team around it with new tech lead from existing team and let it grow on it&#x27;s own - it&#x27;ll extract itself to separate subsystem by itself. It doesn&#x27;t have to be done overnight.<p>It&#x27;s astounding how many people use &quot;scale&quot; as chupacabra to scare everybody in the meeting room without clearly defining what they mean by &quot;scale&quot;. To make decision around changing architecture to scale you need to precisely define what it means, have metrics, have benchmarks showing current limits, proof it&#x27;s a problem now or near future and focus just on those actual issues, if they even exist.</div><br/><div id="35859177" class="c"><input type="checkbox" id="c-35859177" checked=""/><div class="controls bullet"><span class="by">m_mueller</span><span>|</span><a href="#35854976">root</a><span>|</span><a href="#35858719">parent</a><span>|</span><a href="#35854585">next</a><span>|</span><label class="collapse" for="c-35859177">[-]</label><label class="expand" for="c-35859177">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (because it&#x27;s easier to change things, it&#x27;s just single pr addressing all places at once) and then, possibly few years later, whatever has crystalized and has clear boundaries with little to no changes coming in or changes contained within this boundary - can be potentially extracted.<p>From my experience you get the best of both worlds by having a mono-repo but try to keep your services small-ish. E.g. for a reporting framework we have separate services for source data extraction, one for view transformations and one for exports. We can always recombine that (and we do actually integrate it locally in a single process for dev&#x2F;debugging purposes), but it does enforce some good practices in keeping the boundaries clean IMO.<p>Note that I wasn&#x27;t arguing at all to just go blindly all-in on Microservices, I was just saying there is some merit and YMMV.</div><br/></div></div></div></div></div></div></div></div><div id="35854585" class="c"><input type="checkbox" id="c-35854585" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#35854976">prev</a><span>|</span><a href="#35859078">next</a><span>|</span><label class="collapse" for="c-35854585">[-]</label><label class="expand" for="c-35854585">[3 more]</label></div><br/><div class="children"><div class="content">&gt; they had some overly chatty calls between AWS lambda functions and S3. They were able to re-use most of their working code by combining it into a single long running microservice that is horizontally scaled using ECS, and which is invoked via a lambda function. This is only one of many microservices that make up the Prime Video application. The problem is that they called this refactoring a microservice to monolith transition, when it’s clearly a microservice refactoring step<p>If I understood the post at all, I disagree.<p>One can spend hundreds of HN comments discussing technology stacks, monoliths, etc, and this is important: it affects maintainability, developer hours, and money spent on orchestration. For some applications, almost the entire workload is orchestration, and this discussion makes sense.<p>But for this workload, actual work is being done, and it can be quantified and priced.  So let’s get to the basics: an uncompressed 1080p video stream is something like 3 Gbps. It costs a certain amount of CPU to decompress. It costs a certain amount of CPU to analyze.<p>These have price tags. You can pay for that CPU at EC2 rates or on-prem rates or Lambda rates or whatever. You can calculate this! And you pay for that bandwidth.  You can pay for 3Gbps per stream using S3: you pay S3 and you pay EC2 (or whatever) because that uses 1&#x2F;10th of the practical maximum EC2 &lt;-&gt; S3 bandwidth per instance. Or you pay for the fraction of main memory bandwidth used if you decode and analyze on the same EC2 instance (or Lambda function or whatever). Or you pay for the fraction of cache bandwidth used if you decide partial frames and analyze without ever sending to memory.<p>And you’ll find that S3 is not “chatty”. It’s catastrophic. In fact, any use of microservices here is likely catastrophic if not carefully bound to the same machine.</div><br/><div id="35858492" class="c"><input type="checkbox" id="c-35858492" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#35854585">parent</a><span>|</span><a href="#35858182">next</a><span>|</span><label class="collapse" for="c-35858492">[-]</label><label class="expand" for="c-35858492">[1 more]</label></div><br/><div class="children"><div class="content">This is called <i>mechanical sympathy</i> and most architects and developers do not have it.<p>Computer architectures encompass 13 orders of magnitude of performance! That&#x27;s roughly the difference between something like a trivial function call processing data in L1 cache to a remote call out to something in another region.<p>People often make relatively &quot;small&quot; mistakes of 3 or 4 orders of magnitude, which is still crazy if you think about it, but that&#x27;s considered to be a minor sin relative to making the architecture diagram look pretty.</div><br/></div></div><div id="35858182" class="c"><input type="checkbox" id="c-35858182" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#35854585">parent</a><span>|</span><a href="#35858492">prev</a><span>|</span><a href="#35859078">next</a><span>|</span><label class="collapse" for="c-35858182">[-]</label><label class="expand" for="c-35858182">[1 more]</label></div><br/><div class="children"><div class="content">So it didn&#x27;t make sense to separate some functionality.  So what?  No one who advocates microservices would say you can cut a service along any arbitrary line and expect good results.</div><br/></div></div></div></div><div id="35859078" class="c"><input type="checkbox" id="c-35859078" checked=""/><div class="controls bullet"><span class="by">kierank</span><span>|</span><a href="#35854585">prev</a><span>|</span><a href="#35856420">next</a><span>|</span><label class="collapse" for="c-35859078">[-]</label><label class="expand" for="c-35859078">[1 more]</label></div><br/><div class="children"><div class="content">I do wonder if anyone actually read the Amazon post before creating their hot takes.<p>The crux of the post is simple and obvious to anyone who&#x27;s ever actually developed &quot;low-level&quot; (used loosely) video libraries. Microservices are not suited for video because exchange of video between microservices is substantially more costly than bits of JSON.</div><br/></div></div><div id="35856420" class="c"><input type="checkbox" id="c-35856420" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#35859078">prev</a><span>|</span><a href="#35854845">next</a><span>|</span><label class="collapse" for="c-35856420">[-]</label><label class="expand" for="c-35856420">[1 more]</label></div><br/><div class="children"><div class="content">I am so baffled by this whole discussion. Isn’t serverless (aka event-driven distributed systems made up of small components, with no reserved capacity) just one of many options? I write code for 8-bit controllers that I’d never run on Lambda (even though I’m a Lambda&#x2F;Step Functions freak). I need 90s server software that can only run in a VM.<p>It’s a complicated world and your favorite tool&#x2F;model just isn’t going to cut it everywhere. Move on maybe?</div><br/></div></div><div id="35854845" class="c"><input type="checkbox" id="c-35854845" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#35856420">prev</a><span>|</span><a href="#35856650">next</a><span>|</span><label class="collapse" for="c-35854845">[-]</label><label class="expand" for="c-35854845">[5 more]</label></div><br/><div class="children"><div class="content">Look, the point is simple, AWS marketing says you can do everything all the time with microservices and their &#x27;DevOps&#x27; infrastructure to &quot;abstract away&quot; all the complex you know - engineering - that you cannot automate effectively and have a long running robust system.<p>So it&#x27;s humorous to see an Amazon team that is doing things correct and holistically <i>in contrast to the sales and marketing bullshit</i> that AWS and Cloud evangelists spew.<p>Us nerds have a great way of missing the point and bikeshedding on the technicals (which is also great sometimes!)</div><br/><div id="35856053" class="c"><input type="checkbox" id="c-35856053" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#35854845">parent</a><span>|</span><a href="#35857339">next</a><span>|</span><label class="collapse" for="c-35856053">[-]</label><label class="expand" for="c-35856053">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s amazing how cloud companies managed to convince so many people in software engineering that software engineering wasn&#x27;t a core competence in producing software.</div><br/><div id="35856643" class="c"><input type="checkbox" id="c-35856643" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#35854845">root</a><span>|</span><a href="#35856053">parent</a><span>|</span><a href="#35857339">next</a><span>|</span><label class="collapse" for="c-35856643">[-]</label><label class="expand" for="c-35856643">[2 more]</label></div><br/><div class="children"><div class="content">Yeah cause engineers aren’t ones typically doing the buying</div><br/><div id="35858696" class="c"><input type="checkbox" id="c-35858696" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#35854845">root</a><span>|</span><a href="#35856643">parent</a><span>|</span><a href="#35857339">next</a><span>|</span><label class="collapse" for="c-35858696">[-]</label><label class="expand" for="c-35858696">[1 more]</label></div><br/><div class="children"><div class="content">Same reason MSFT SWEs use Mac over Windows -- they&#x27;ve seen too much.</div><br/></div></div></div></div></div></div><div id="35857339" class="c"><input type="checkbox" id="c-35857339" checked=""/><div class="controls bullet"><span class="by">scarface74</span><span>|</span><a href="#35854845">parent</a><span>|</span><a href="#35856053">prev</a><span>|</span><a href="#35856650">next</a><span>|</span><label class="collapse" for="c-35857339">[-]</label><label class="expand" for="c-35857339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Look, the point is simple, AWS marketing says you can do everything all the time with microservices and their &#x27;DevOps&#x27; infrastructure to &quot;abstract away&quot; all the complex you know - engineering - that you cannot automate effectively and have a long running robust system.<p>As someone who knows a little bit about what AWS recommends to customers when first hand, I can absolutely guarantee you that AWS does not recommend serverless to everyone.<p>The vast majority of projects that consultants do by revenue at any cloud consulting company (including AWS’s own internal company)  is regular old VMs.</div><br/></div></div></div></div><div id="35856650" class="c"><input type="checkbox" id="c-35856650" checked=""/><div class="controls bullet"><span class="by">GabeIsko</span><span>|</span><a href="#35854845">prev</a><span>|</span><a href="#35853561">next</a><span>|</span><label class="collapse" for="c-35856650">[-]</label><label class="expand" for="c-35856650">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I don&#x27;t really understand why people are making a big deal about this. Two lambda functions passing data to step functions? Not exactly the best serverless architecture. And if you think about the problem of checking video streams, there is really no reason to scale different parts of it independently because you just need one process to watch the video and check for errors. Plus they still deployed the new solution on ECS, so it isn&#x27;t really a monolith application that runs on a fixed number of servers. It&#x27;s a real nothing story - the Prime Video team was just doing some engineering maintenance.<p>Honestly the bigger story is that it was mischaracterized from the beginning, but I would imagine that is more a result of things coming together from multiple different systems and teams more than the way someone designed this stuff.</div><br/></div></div><div id="35853561" class="c"><input type="checkbox" id="c-35853561" checked=""/><div class="controls bullet"><span class="by">zwischenzug</span><span>|</span><a href="#35856650">prev</a><span>|</span><a href="#35854453">next</a><span>|</span><label class="collapse" for="c-35853561">[-]</label><label class="expand" for="c-35853561">[5 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t really get it. There are so many simple, easy to build, cheap to run three tier frameworks out there so why bother with all the hassle of porting at all? If your system gets super busy then you can repurpose the code with higher performance and well tuned DBs later. I spent 15 years doing that for some of the busiest systems in the world, but those started on a single cpu.</div><br/><div id="35853623" class="c"><input type="checkbox" id="c-35853623" checked=""/><div class="controls bullet"><span class="by">gregoriol</span><span>|</span><a href="#35853561">parent</a><span>|</span><a href="#35854151">next</a><span>|</span><label class="collapse" for="c-35853623">[-]</label><label class="expand" for="c-35853623">[1 more]</label></div><br/><div class="children"><div class="content">The point is: managers and keywords</div><br/></div></div><div id="35854151" class="c"><input type="checkbox" id="c-35854151" checked=""/><div class="controls bullet"><span class="by">gadflyinyoureye</span><span>|</span><a href="#35853561">parent</a><span>|</span><a href="#35853623">prev</a><span>|</span><a href="#35854453">next</a><span>|</span><label class="collapse" for="c-35854151">[-]</label><label class="expand" for="c-35854151">[3 more]</label></div><br/><div class="children"><div class="content">At my client, we go Serverless first in a bastardized state, NestJS. The benefit is quick development at a low cost. We have a series of calculations. Each read from a common S3 and write to it. This allows the teams to do their work with independent deployments.<p>Each one costs about $5 a month. That’s rather hard to get in the AWS EC2 world. They are also easier to manage. We don’t have to manage keys or certain. There is no redeploy after 90s that comes with EC2.<p>However these are low access, slowish apps. Maybe a 1,000 calls a day. They can take a minute to do their thing. Seems like a nice match for lambdas.<p>Benefit of NestJS is if we ever needed to move out of lambda we have a tradition all Express app.</div><br/><div id="35854542" class="c"><input type="checkbox" id="c-35854542" checked=""/><div class="controls bullet"><span class="by">zwischenzug</span><span>|</span><a href="#35853561">root</a><span>|</span><a href="#35854151">parent</a><span>|</span><a href="#35854453">next</a><span>|</span><label class="collapse" for="c-35854542">[-]</label><label class="expand" for="c-35854542">[2 more]</label></div><br/><div class="children"><div class="content">Useful insight, but whether it&#x27;s 5$ or 50$ a month, compared to dev costs that&#x27;s a rounding error pretty much everywhere.</div><br/><div id="35855084" class="c"><input type="checkbox" id="c-35855084" checked=""/><div class="controls bullet"><span class="by">gadflyinyoureye</span><span>|</span><a href="#35853561">root</a><span>|</span><a href="#35854542">parent</a><span>|</span><a href="#35854453">next</a><span>|</span><label class="collapse" for="c-35855084">[-]</label><label class="expand" for="c-35855084">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why we went with NestJS. It&#x27;s like Spring but for TypeScript. We can run everything locally. Boot up the NestJS service at localhost:8080 with LocalStack running on the side for access to S3 and DynamoDB compatible, working services.</div><br/></div></div></div></div></div></div></div></div><div id="35854453" class="c"><input type="checkbox" id="c-35854453" checked=""/><div class="controls bullet"><span class="by">mr_tristan</span><span>|</span><a href="#35853561">prev</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35854453">[-]</label><label class="expand" for="c-35854453">[9 more]</label></div><br/><div class="children"><div class="content">What&#x27;s funny to me, is that I focused on something completely different; how independent these teams at Amazon are. The move from pretty different infrastructure services, all at the same company. I can&#x27;t think of a single place I&#x27;ve worked at in 20 years where these infra teams wouldn&#x27;t be either: a.) mandated, i.e., &quot;you will stick with lambda&#x2F;kubernetes&#x2F;whatever&quot;, or b.) review and be involved in the architectural decisionmaking of the video service approach, i.e., have to politick your way around any deviation.<p>I guess the shift from &quot;mono to micro&quot; just isn&#x27;t very interesting to me. You can usually change your definition of either concept to fit your architecture. This just seemed like the team did the math and revised their approach. Good for them!</div><br/><div id="35856113" class="c"><input type="checkbox" id="c-35856113" checked=""/><div class="controls bullet"><span class="by">beastcoast</span><span>|</span><a href="#35854453">parent</a><span>|</span><a href="#35854948">next</a><span>|</span><label class="collapse" for="c-35856113">[-]</label><label class="expand" for="c-35856113">[2 more]</label></div><br/><div class="children"><div class="content">Amazon is actually better thought of as a collection of independent startups with their own software architectures, roadmaps and P&amp;Ls. There’s commonly used infrastructure but very little is really mandated at the company level.</div><br/><div id="35858609" class="c"><input type="checkbox" id="c-35858609" checked=""/><div class="controls bullet"><span class="by">zoover2020</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35856113">parent</a><span>|</span><a href="#35854948">next</a><span>|</span><label class="collapse" for="c-35858609">[-]</label><label class="expand" for="c-35858609">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. I&#x27;d say the enforcement is on org&#x2F;PE (Principal Engineer) level, cascading down to Senior engineers.<p>Once you&#x27;re designing something beyond a small app, you&#x27;d have to pass PE review anyway.</div><br/></div></div></div></div><div id="35854948" class="c"><input type="checkbox" id="c-35854948" checked=""/><div class="controls bullet"><span class="by">iLoveOncall</span><span>|</span><a href="#35854453">parent</a><span>|</span><a href="#35856113">prev</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35854948">[-]</label><label class="expand" for="c-35854948">[6 more]</label></div><br/><div class="children"><div class="content">This is in part where the &quot;It&#x27;s always Day 1&quot; mentality manifests at Amazon.<p>There&#x27;s only one programming language that is forbidden (PHP - for wrong reasons), and only one cloud vendor that is mandated (obvious). But beside that, teams are able to use literally whatever technology they want. There are some technologies that impose themselves because of the ecosystem, but you can always do your own sauce if needed.<p>I&#x27;ve been in two teams that had basically 90% different tech stacks, but it&#x27;s never a problem, and it doesn&#x27;t really ever come up in design reviews (unless there&#x27;s a real reason, not for personal preferences).</div><br/><div id="35854986" class="c"><input type="checkbox" id="c-35854986" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35854948">parent</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35854986">[-]</label><label class="expand" for="c-35854986">[5 more]</label></div><br/><div class="children"><div class="content">Curious though, what is the reason for banning PHP? It must be pretty specific if they singled out just PHP.</div><br/><div id="35855270" class="c"><input type="checkbox" id="c-35855270" checked=""/><div class="controls bullet"><span class="by">iLoveOncall</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35854986">parent</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35855270">[-]</label><label class="expand" for="c-35855270">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the full history because it&#x27;s from way before I joined, but it is honestly a terrible take (by a guy who&#x27;s now Distinguished Engineer at Apple, no less!) explaining that it is impossible to write secure applications in PHP.<p>Basically, they used &quot;the historical number of vulnerabilities identified in applications developed using a technology&quot; as metric to determine how insecure a technology is.<p>For the argument here, they looked at the CVE list, where at the time (in 2012, with the list existing since 1999) 40% of all software vulnerabilities recorded were in PHP applications. This led to the conclusion that PHP is insecure by nature.<p>Of course, he didn&#x27;t mention that at the time, PHP was also used by 80% of all websites, because that would have made his argument worthless.<p>That wiki page explaining that is still up. It&#x27;s so baffling to me when the argument violates so many of Amazon&#x27;s leadership principles.</div><br/><div id="35855309" class="c"><input type="checkbox" id="c-35855309" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35855270">parent</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35855309">[-]</label><label class="expand" for="c-35855309">[3 more]</label></div><br/><div class="children"><div class="content">Yeah that is a pretty poor reason, thanks for the nugget though that is pretty interesting.<p>I could think of a bunch of legitimate reasons to want to ban it but they would also hit a bunch of other languages as a result - hence why I was curious how it could be so specific.<p>It wouldn&#x27;t surprise me if LOC for LOC PHP written today is much more secure than JS because of the same dynamic, just JS is the one that is now on 80% of new code written by beginners.</div><br/><div id="35856262" class="c"><input type="checkbox" id="c-35856262" checked=""/><div class="controls bullet"><span class="by">beastcoast</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35855309">parent</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35856262">[-]</label><label class="expand" for="c-35856262">[2 more]</label></div><br/><div class="children"><div class="content">Even worse than that - Amazon spent dozens of engineer years migrating their wiki from PHP MediaWiki to Java XWiki, pretty much for that reason only, and for dubious customer benefit. There was a very epic post mortem at the end of it.</div><br/><div id="35856480" class="c"><input type="checkbox" id="c-35856480" checked=""/><div class="controls bullet"><span class="by">iLoveOncall</span><span>|</span><a href="#35854453">root</a><span>|</span><a href="#35856262">parent</a><span>|</span><a href="#35853632">next</a><span>|</span><label class="collapse" for="c-35856480">[-]</label><label class="expand" for="c-35856480">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mention that in my original response, but the guy that wrote this document putting the nail in the coffin for PHP at Amazon said that ultimately it was too expensive to even TRY to assess PHP&#x27;s safety. The amount he quoted was only 250,000$.<p>Looking back it&#x27;s so obvious that it was an opinionated crusade from one guy, I simply don&#x27;t understand how one of the most influential programming languages ever got dismissed by a single dude with fallacious arguments in less than a thousand words.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35853632" class="c"><input type="checkbox" id="c-35853632" checked=""/><div class="controls bullet"><span class="by">jack_squat</span><span>|</span><a href="#35854453">prev</a><span>|</span><a href="#35859062">next</a><span>|</span><label class="collapse" for="c-35853632">[-]</label><label class="expand" for="c-35853632">[9 more]</label></div><br/><div class="children"><div class="content">Am I alone in feeling there is nothing left to be said on this topic? Correct application design, and balancing that against the constraints of getting a product out the door, the requirements of a particular application, and the resources on hand (skill-sets, developers, infrastructure) does not in my opinion boil down to &quot;microservices vs monolith&quot;.<p>Both strategies have tradeoffs, both have produced successes and failures, and choice of approach seems (obviously) too specific to a given context and application for general advice to apply.</div><br/><div id="35857276" class="c"><input type="checkbox" id="c-35857276" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#35853632">parent</a><span>|</span><a href="#35854089">next</a><span>|</span><label class="collapse" for="c-35857276">[-]</label><label class="expand" for="c-35857276">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not alone. What doesn&#x27;t get said enough about this topic is &quot;it doesn&#x27;t matter&quot;. The architecture and design, for the most part, doesn&#x27;t matter. Because no matter what is chosen, there will be pitfalls. Failing to account for those pitfalls will lead to problems, and changing the design or architecture to avoid the pitfalls will just introduce new pitfalls.<p>IMHO, the right path is to first become educated about each design and its pitfalls, so that when the time comes, you can quickly pick a design, and move swiftly onto dealing with the pitfalls, because that&#x27;s where the actual problems lie.<p><pre><code>  Among the maxims on Lord Naoshige&#x27;s wall there was this one: 
       &quot;Matters of great concern should be treated lightly.&quot;
  
  Master Ittei commented,
       &quot;Matters of small concern should be treated seriously.&quot;</code></pre></div><br/></div></div><div id="35854089" class="c"><input type="checkbox" id="c-35854089" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#35853632">parent</a><span>|</span><a href="#35857276">prev</a><span>|</span><a href="#35855716">next</a><span>|</span><label class="collapse" for="c-35854089">[-]</label><label class="expand" for="c-35854089">[3 more]</label></div><br/><div class="children"><div class="content">Exactly, tool vs hammer. Sometimes you made the wrong choice in tool, and then you switch tools.. Nothing wrong with that. A craftman just knows its tools better. There is no magic bullet here.</div><br/><div id="35855256" class="c"><input type="checkbox" id="c-35855256" checked=""/><div class="controls bullet"><span class="by">matisseverduyn</span><span>|</span><a href="#35853632">root</a><span>|</span><a href="#35854089">parent</a><span>|</span><a href="#35855716">next</a><span>|</span><label class="collapse" for="c-35855256">[-]</label><label class="expand" for="c-35855256">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Exactly, tool vs hammer. Sometimes you made the wrong choice in tool, and then you switch tools.. Nothing wrong with that. A craftsman just knows its tools better. There is no magic bullet here.<p>Rational take, but I see the debate similar to Roman vs Arabic numerals.<p>Keeping a tally? Roman. Need to use operators? Arabic. Sometimes you can keep a tally in Arabic (not ideal), and sometimes you can do basic operations on Roman numerals (not ideal).<p>However, when you want to start using variables, only one tool enables this easily.<p>I can&#x27;t architect the types of redundant and properly separated interoperable systems with a monolith that microservices otherwise enable.<p>So the desire to move forward isn&#x27;t the need to find a magic bullet, but the next evolution of an existing ability that unlocks new capabilities...<p>(I don&#x27;t think calculus would have been discovered using Roman numerals)</div><br/><div id="35855417" class="c"><input type="checkbox" id="c-35855417" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#35853632">root</a><span>|</span><a href="#35855256">parent</a><span>|</span><a href="#35855716">next</a><span>|</span><label class="collapse" for="c-35855417">[-]</label><label class="expand" for="c-35855417">[1 more]</label></div><br/><div class="children"><div class="content">No, but you can start a business with a singlesystem, keep things well decoupled (hard &#x2F; software engineer is hard).. Then you gradually run some parts of the systems in different docker containers, then at some point you completely decoupled systems and have different teams handle different service boundaries. You could still have the core system be a big bigger, and sometimes referred to as monolith. But monolith vs microservices is a polarises the discussion, its a gradual scale. Its the engineering, and keeping things separated that matters.</div><br/></div></div></div></div></div></div><div id="35855716" class="c"><input type="checkbox" id="c-35855716" checked=""/><div class="controls bullet"><span class="by">mattmanser</span><span>|</span><a href="#35853632">parent</a><span>|</span><a href="#35854089">prev</a><span>|</span><a href="#35853880">next</a><span>|</span><label class="collapse" for="c-35855716">[-]</label><label class="expand" for="c-35855716">[1 more]</label></div><br/><div class="children"><div class="content">I think there are an increasing number of people that believe that microservice is not in the same risk category as a normal application design. A design we really need to stop calling &quot;monolith&quot; as to PMs, management, etc. it sounds ancient.<p>So the claim that &quot;both strategies have tradeoffs&quot; is not true for a lot of people. Microservies have bigger tradeoffs and consequences than a normal application design.</div><br/></div></div><div id="35855826" class="c"><input type="checkbox" id="c-35855826" checked=""/><div class="controls bullet"><span class="by">alexashka</span><span>|</span><a href="#35853632">parent</a><span>|</span><a href="#35853880">prev</a><span>|</span><a href="#35859062">next</a><span>|</span><label class="collapse" for="c-35855826">[-]</label><label class="expand" for="c-35855826">[2 more]</label></div><br/><div class="children"><div class="content">Of course there is nothing <i>technical</i> to be said. There is plenty of personal anecdote and associated feelings to be shared however, which is what homo sapiens primarily enjoy :)<p>You get double the thrill if you <i>think</i> you are engaging in a technical conversation all the while arguing anecdotal experiences, beliefs and biases.</div><br/><div id="35858971" class="c"><input type="checkbox" id="c-35858971" checked=""/><div class="controls bullet"><span class="by">nialse</span><span>|</span><a href="#35853632">root</a><span>|</span><a href="#35855826">parent</a><span>|</span><a href="#35859062">next</a><span>|</span><label class="collapse" for="c-35858971">[-]</label><label class="expand" for="c-35858971">[1 more]</label></div><br/><div class="children"><div class="content">What an excellent observation! I will quote this often. Thank you! I’d even generalize it a bit further.<p>“You get double the thrill if you think you are engaging in logical reasoning, all the while arguing anecdotal experiences, beliefs and biases.”</div><br/></div></div></div></div></div></div><div id="35859062" class="c"><input type="checkbox" id="c-35859062" checked=""/><div class="controls bullet"><span class="by">retrac98</span><span>|</span><a href="#35853632">prev</a><span>|</span><a href="#35855686">next</a><span>|</span><label class="collapse" for="c-35859062">[-]</label><label class="expand" for="c-35859062">[1 more]</label></div><br/><div class="children"><div class="content">Added to <a href="https:&#x2F;&#x2F;www.microservice-stories.com" rel="nofollow">https:&#x2F;&#x2F;www.microservice-stories.com</a></div><br/></div></div><div id="35855686" class="c"><input type="checkbox" id="c-35855686" checked=""/><div class="controls bullet"><span class="by">kennu</span><span>|</span><a href="#35859062">prev</a><span>|</span><a href="#35853640">next</a><span>|</span><label class="collapse" for="c-35855686">[-]</label><label class="expand" for="c-35855686">[1 more]</label></div><br/><div class="children"><div class="content">Many comments seem to miss the point that nowadays native AWS cloud applications are meant to be built by combining various AWS services using Lambda as the glue between them. It&#x27;s not about serverless vs non-serverless: it&#x27;s about using cloud services for the purpose they are each good at. In many cases you might actually have more IaC code than Lambda handler code, especially if you can leverage services like AppSync and Step Functions. The application is no longer a set of microservices; it&#x27;s a set of CDK &#x2F; CloudFormation stacks and the resources that they define, some of which might be microservices.</div><br/></div></div><div id="35853640" class="c"><input type="checkbox" id="c-35853640" checked=""/><div class="controls bullet"><span class="by">balls187</span><span>|</span><a href="#35855686">prev</a><span>|</span><a href="#35857916">next</a><span>|</span><label class="collapse" for="c-35853640">[-]</label><label class="expand" for="c-35853640">[2 more]</label></div><br/><div class="children"><div class="content">I don’t quite understand the point in all this. Design tradeoffs are still a thing; did we all just forget?<p>“Abortions for some... miniature American flags for others!”</div><br/><div id="35854881" class="c"><input type="checkbox" id="c-35854881" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#35853640">parent</a><span>|</span><a href="#35857916">next</a><span>|</span><label class="collapse" for="c-35854881">[-]</label><label class="expand" for="c-35854881">[1 more]</label></div><br/><div class="children"><div class="content">Software architecture is (incorrectly) seen as NP-hard by practitioners, so they avoid it, and instead focus on implementing the current &quot;best practices.&quot; However, &quot;best practices&quot; can&#x27;t be best if they&#x27;re situational, so we arrive at very local maxima, such as microservices for all.</div><br/></div></div></div></div><div id="35857916" class="c"><input type="checkbox" id="c-35857916" checked=""/><div class="controls bullet"><span class="by">hnaccountme</span><span>|</span><a href="#35853640">prev</a><span>|</span><a href="#35855017">next</a><span>|</span><label class="collapse" for="c-35857916">[-]</label><label class="expand" for="c-35857916">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised Amazon published what they did. AWS make a lot of money selling hyped up buzz word tech to incompetent companies.</div><br/></div></div><div id="35855017" class="c"><input type="checkbox" id="c-35855017" checked=""/><div class="controls bullet"><span class="by">EMM_386</span><span>|</span><a href="#35857916">prev</a><span>|</span><a href="#35855862">next</a><span>|</span><label class="collapse" for="c-35855017">[-]</label><label class="expand" for="c-35855017">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I do think microservices were over sold as the answer to everything, and I think this may have arisen from vendors who wanted to sell Kubernetes with a simple marketing message that enterprises needed to modernize by using Kubernetes to do cloud native microservices for everything<p>Yes, they absolutely were oversold, Kubernetes marketing was part of it.  There was also <i>a lot</i> of resume-driven development, and simply &quot;look, new shiny object!&quot;.  A lot of young engineers entered the workforce over the last couple of decades.  That often comes along with &quot;forget this old stuff, what&#x27;s the new stuff?&quot;.<p>I use KISS as much as possible with every project I&#x27;m involved in desinging.<p>The microservices push got the point where a dev shops with 10 people had it all broken into microservices and running Kubernetes to manage low-traffic front ends, an API and a database.  I would see some of these systems and the only thing I could think was &quot;... but why?&quot;.<p>Do microservices have a place?  Yes.  Have I seen them used where they shouldn&#x27;t be?   Yes. Have I seen more poorly implemented microservices architecture than good ones.  <i>Yes</i>.<p>Over-engineering the tech stack, or selecting one part of it vs. another based on which is trendier, only leads to more frusturation, difficulty reasoning about it, added development time ... all of which means it will cost more.</div><br/></div></div><div id="35855862" class="c"><input type="checkbox" id="c-35855862" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#35855017">prev</a><span>|</span><a href="#35856658">next</a><span>|</span><label class="collapse" for="c-35855862">[-]</label><label class="expand" for="c-35855862">[1 more]</label></div><br/><div class="children"><div class="content">Serverless isn&#x27;t &quot;cheap&quot;. It&#x27;s rightsized. If you aren&#x27;t serving 24&#x2F;7, it makes sense to move to an on-demand model. However if you compare the unit of compute pricing, Lambda is comparable to other services, and likely more expensive than buying compute wholesale. You can just buy it in smaller portions.</div><br/></div></div><div id="35856658" class="c"><input type="checkbox" id="c-35856658" checked=""/><div class="controls bullet"><span class="by">chrismsimpson</span><span>|</span><a href="#35855862">prev</a><span>|</span><a href="#35857273">next</a><span>|</span><label class="collapse" for="c-35856658">[-]</label><label class="expand" for="c-35856658">[1 more]</label></div><br/><div class="children"><div class="content">Seeing all the acolytes of serverless get triggered by this has been enjoyable to watch</div><br/></div></div><div id="35857273" class="c"><input type="checkbox" id="c-35857273" checked=""/><div class="controls bullet"><span class="by">carabiner</span><span>|</span><a href="#35856658">prev</a><span>|</span><a href="#35856459">next</a><span>|</span><label class="collapse" for="c-35857273">[-]</label><label class="expand" for="c-35857273">[1 more]</label></div><br/><div class="children"><div class="content">I think Agile workflow has a part to play in this. It embraces complexity and moving fast to build out buggy features, where every new bug becomes a new user story. It feels productive but it just creates more work than you need.</div><br/></div></div><div id="35856459" class="c"><input type="checkbox" id="c-35856459" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#35857273">prev</a><span>|</span><a href="#35854002">next</a><span>|</span><label class="collapse" for="c-35856459">[-]</label><label class="expand" for="c-35856459">[1 more]</label></div><br/><div class="children"><div class="content">Nothing is ever truly a mistake, it&#x27;s much more about understanding what you are trading off between real hardware, cloud servers, something like fly or heroku or vercel and purer serverless functions on AWS or whatever.</div><br/></div></div><div id="35854002" class="c"><input type="checkbox" id="c-35854002" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#35856459">prev</a><span>|</span><a href="#35856099">next</a><span>|</span><label class="collapse" for="c-35854002">[-]</label><label class="expand" for="c-35854002">[1 more]</label></div><br/><div class="children"><div class="content">The original, unedited title is &quot;So many bad takes — What is there to learn from the Prime Video microservices to monolith story&quot;</div><br/></div></div><div id="35856099" class="c"><input type="checkbox" id="c-35856099" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#35854002">prev</a><span>|</span><a href="#35854785">next</a><span>|</span><label class="collapse" for="c-35856099">[-]</label><label class="expand" for="c-35856099">[1 more]</label></div><br/><div class="children"><div class="content">Seeing as how a lot of players are going in on serverless (vercel, netlify, deno, cloudflare) the cynic in me wonders if this is a calculated move on part of Amazon to bring people back to using ec2 .. etc</div><br/></div></div><div id="35854785" class="c"><input type="checkbox" id="c-35854785" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#35856099">prev</a><span>|</span><a href="#35855528">next</a><span>|</span><label class="collapse" for="c-35854785">[-]</label><label class="expand" for="c-35854785">[1 more]</label></div><br/><div class="children"><div class="content">Cant&#x27; we just ask the &quot;Application Deployer&quot; to upload an EAR, published by the &quot;Application Assembler&quot;, and run it on any of the spec-compatible servers?<p>These problems have been solved decades ago.. 2.5 to be exact</div><br/></div></div><div id="35855528" class="c"><input type="checkbox" id="c-35855528" checked=""/><div class="controls bullet"><span class="by">lr1970</span><span>|</span><a href="#35854785">prev</a><span>|</span><a href="#35854123">next</a><span>|</span><label class="collapse" for="c-35855528">[-]</label><label class="expand" for="c-35855528">[2 more]</label></div><br/><div class="children"><div class="content">Dup. Already discussed on HN less than a day ago [0].<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35847988" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35847988</a></div><br/><div id="35855660" class="c"><input type="checkbox" id="c-35855660" checked=""/><div class="controls bullet"><span class="by">jlund-molfese</span><span>|</span><a href="#35855528">parent</a><span>|</span><a href="#35854123">next</a><span>|</span><label class="collapse" for="c-35855660">[-]</label><label class="expand" for="c-35855660">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s a different link. The one in this topic is addressing the link you posted.</div><br/></div></div></div></div><div id="35854123" class="c"><input type="checkbox" id="c-35854123" checked=""/><div class="controls bullet"><span class="by">qwertywert_</span><span>|</span><a href="#35855528">prev</a><span>|</span><a href="#35854547">next</a><span>|</span><label class="collapse" for="c-35854123">[-]</label><label class="expand" for="c-35854123">[1 more]</label></div><br/><div class="children"><div class="content">This has been posted like 6 times already man.</div><br/></div></div><div id="35854547" class="c"><input type="checkbox" id="c-35854547" checked=""/><div class="controls bullet"><span class="by">enterthestartup</span><span>|</span><a href="#35854123">prev</a><span>|</span><a href="#35854810">next</a><span>|</span><label class="collapse" for="c-35854547">[-]</label><label class="expand" for="c-35854547">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting that they were able to reduce costs by 90%, though also agree with the opinions mentioned here.</div><br/></div></div><div id="35854810" class="c"><input type="checkbox" id="c-35854810" checked=""/><div class="controls bullet"><span class="by">th3h4mm3r</span><span>|</span><a href="#35854547">prev</a><span>|</span><a href="#35853565">next</a><span>|</span><label class="collapse" for="c-35854810">[-]</label><label class="expand" for="c-35854810">[1 more]</label></div><br/><div class="children"><div class="content">What if Amazon take bad choices in &quot;something&quot; and my company is tied up with its services? I know that Prime is always &quot;Amazon&quot; and that&#x27;s okay. But for a startup (but not only) imho it&#x27;s better starts with something more &quot;standard&quot; than something as serverless that is obviously an abstraction above other tecnologies.</div><br/></div></div><div id="35853565" class="c"><input type="checkbox" id="c-35853565" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35854810">prev</a><span>|</span><a href="#35854059">next</a><span>|</span><label class="collapse" for="c-35853565">[-]</label><label class="expand" for="c-35853565">[178 more]</label></div><br/><div class="children"><div class="content">Serverless first is a mistake. It should be &quot;serverless where it&#x27;s distinct advantages are actually useful&quot; which is way less common than people think.<p>Also generally the conception that building things with containers + k8s actually takes more time than serverless is a horseshit take IMO.
It doesn&#x27;t and if it&#x27;s taking you longer you are probably doing something wrong.<p>All the points noted in the slides etc just come from poor engineering leadership. i.e decisions&#x2F;choices, etc. Constaints do speed up development but they can be enforced by leadership, not by putting yourself in an endless pit of technical debt.<p>The only world where I can make a good case for serverless for small teams is if you have said poor leadership and serverless helps you escape their poor decision making.<p>Otherwise assuming you have the mandate necessary to get stuff built the right way just stick with the Boring Tech stack of JVM + PG + k8s. It solves all problems regardless of size, there are minimal decisions to be made (really just Spring or Quarkus atm) and you won&#x27;t spend time dicking around with half-baked serverless integration crap. Instead you can just use battle tested high performance libraries for literally everything.<p>Don&#x27;t get sucked into this serverless nonsense. It&#x27;s always been bad and it probably always will be. When it&#x27;s out of fashion Boring Tech will still be here.</div><br/><div id="35853681" class="c"><input type="checkbox" id="c-35853681" checked=""/><div class="controls bullet"><span class="by">sfvisser</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35854580">next</a><span>|</span><label class="collapse" for="c-35853681">[-]</label><label class="expand" for="c-35853681">[18 more]</label></div><br/><div class="children"><div class="content">Really strong language without any backing arguments whatsoever. You can’t just pick some random tech and decide this is boring tech so it’s good and so the other is bad and has always been. This type of comment is so incredibly meaningless and infuriating.<p>Please explain <i>why</i> you are saying what you’re saying so at least we can learn from it.</div><br/><div id="35853781" class="c"><input type="checkbox" id="c-35853781" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853681">parent</a><span>|</span><a href="#35854817">next</a><span>|</span><label class="collapse" for="c-35853781">[-]</label><label class="expand" for="c-35853781">[3 more]</label></div><br/><div class="children"><div class="content">I do think specifying JVM&#x2F;PG&#x2F;k8s in that comment was a mistake. Boring tech will be different for different people and companies. Boring tech doesn&#x27;t just mean it&#x27;s time-tested and battle-hardened, it means you have deep knowledge across the company because you&#x27;ve used it for so long. I&#x27;m in a Python shop, so Python is my boring default tech stack choice. If I introduced C++ into our tech stack, it would be not-boring tech for us, despite C++ not being a cutting edge language.<p>k8s is funny to call &quot;boring tech&quot; because it&#x27;s notoriously complex. <i>But</i> if your company has set up dozens of k8s clusters and has a bunch of k8s experts on staff, it <i>can</i> be considered &quot;boring tech.&quot; It&#x27;s all relative.</div><br/><div id="35853873" class="c"><input type="checkbox" id="c-35853873" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853781">parent</a><span>|</span><a href="#35854817">next</a><span>|</span><label class="collapse" for="c-35853873">[-]</label><label class="expand" for="c-35853873">[2 more]</label></div><br/><div class="children"><div class="content">Yeah probably. I should have specified &quot;sufficiently boring tech stack of choice&quot;.</div><br/><div id="35853910" class="c"><input type="checkbox" id="c-35853910" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853873">parent</a><span>|</span><a href="#35854817">next</a><span>|</span><label class="collapse" for="c-35853910">[-]</label><label class="expand" for="c-35853910">[1 more]</label></div><br/><div class="children"><div class="content">or append &quot;for example&quot;</div><br/></div></div></div></div></div></div><div id="35854817" class="c"><input type="checkbox" id="c-35854817" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853681">parent</a><span>|</span><a href="#35853781">prev</a><span>|</span><a href="#35853811">next</a><span>|</span><label class="collapse" for="c-35854817">[-]</label><label class="expand" for="c-35854817">[1 more]</label></div><br/><div class="children"><div class="content">I think the big thing with &quot;boring&quot; vs &quot;exciting&quot; tech is people pick exciting tech for reasons other than it being a good technical fit (lets board the hype train!!!). Bad results then happen.<p>Boring tech is usually more stable and more mapped out. Everyone knows where its good and where its not. Other people have already had whatever problems you have.<p>I&#x27;ll always bet on the boring tech over the hyped exciting tech.</div><br/></div></div><div id="35853811" class="c"><input type="checkbox" id="c-35853811" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853681">parent</a><span>|</span><a href="#35854817">prev</a><span>|</span><a href="#35854580">next</a><span>|</span><label class="collapse" for="c-35853811">[-]</label><label class="expand" for="c-35853811">[13 more]</label></div><br/><div class="children"><div class="content">Serverless actual pros:<p>&quot;infinite&quot; (meaning wallet level) scalability.<p>Integrated deployment tooling usually.<p>Integrated ingress usually.<p>Those last 2 really don&#x27;t matter though as neither problem is that difficult if you know what you are doing. They both would have been a huge selling point in a world where k8s doesn&#x27;t exist. Alas it does and thus mostly moot.<p>The first however is a big deal as managing very bursty loads on k8s can actually be a bit of a challenge. This is doubly true when you are using some sort of queue and don&#x27;t have good queue scaling metrics for whatever reason. Serverless lets you cop out of managing that by using infinite concurrency.<p>Ok so now cons of serverless:<p>Turns all your code into spaghetti, this is probably the biggest one.<p>Cold boot performance is highly varible and generally worsens with added function complexity but this depends on tech choice.<p>Infinite concurrency is a bit of a curse. Want to use that MySQL DB that contains all your business critical data? Better use some MySQL Serverless proxy nonsense because unbounded connections isn&#x27;t fun.<p>Lock-in is awful, migration story is awful.<p>Amount of Infrastructure as Code overhead, ala Terraform, CloudFormation, whatever else floats your boat to support serverless is insane. The sheer number of objects that need to defined, kept in sync etc is just bonkers. Not to mention if you have multiple services setup like this it&#x27;s all boilerplate you either need to abstract or carry around.<p>Hides serious programming deficiencies like memory leaks because context is thrown away after servicing request.<p>Unpredictable runtime makes observability more complicated, probably forcing you into poor decisions as a result, i.e prom push gateway.<p>Runtime&#x2F;execution time limits mean people trying to do all-serverless end up doing horrible things to accomplish long-running tasks.<p>All of the above leads to increasing pressure to make poor architectural decisions to work around limitations of the runtime.<p>I could probably go on but that is a reasonable set for you.<p>EDIT: Actually I forgot the worst con. The cost. The $&#x2F;CPU&#x2F;RAM cost of Serverless is beyond bonkers. When I was pricing up Cloud Functions vs Spot instances on GKE I think I came to the conclusion Cloud Functions are about 300x as expensive. If your code can run on serverless it can probably run on Spot instances which you can just add to your GKE deployment using another node pool and only schedule things that can handle nodes going away within 60s there and instantly reap 300x cost savings. This is because Serverless is sold at a massive premium to CPU list prices and Spot is sold at like ~30-40% of list prices depending on machine type (for those curious when I last checked T2D was the best for price&#x2F;performance for highly single thread performance dependent workloads, ala Node.js)</div><br/><div id="35853928" class="c"><input type="checkbox" id="c-35853928" checked=""/><div class="controls bullet"><span class="by">kpw94</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853811">parent</a><span>|</span><a href="#35857241">next</a><span>|</span><label class="collapse" for="c-35853928">[-]</label><label class="expand" for="c-35853928">[9 more]</label></div><br/><div class="children"><div class="content">&gt; cons of serverless:<p>&gt; Turns all your code into spagetti, this is probably the biggest one.<p>Overall agree with you, but I don&#x27;t think spaghetti is the right term here - even if the typo is corrected :)<p>Spaghetti code is more of a term for monolithic mess where you have a hard time following all the code logic (cyclomatic complexity) and dependencies.<p>Understanding &amp; tracking dependencies is actually easier with serveless, it&#x27;s pretty clear what dependency that one tiny micro service has.<p>But where it becomes worse is regarding the code logic mess, you&#x27;ve now turned it in a distributed system problem where, in addition to having a even hard time with cyclomatic complexity, you also have to think about transient failures&#x2F;retries at each service boundaries.<p>That and the other problems you describe (performance hit etc)</div><br/><div id="35854442" class="c"><input type="checkbox" id="c-35854442" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853928">parent</a><span>|</span><a href="#35856142">next</a><span>|</span><label class="collapse" for="c-35854442">[-]</label><label class="expand" for="c-35854442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Spaghetti code is more of a term for monolithic mess where you have a hard time following all the code logic (cyclomatic complexity) and dependencies.<p>I started using distributed monolith.</div><br/></div></div><div id="35856142" class="c"><input type="checkbox" id="c-35856142" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853928">parent</a><span>|</span><a href="#35854442">prev</a><span>|</span><a href="#35854722">next</a><span>|</span><label class="collapse" for="c-35856142">[-]</label><label class="expand" for="c-35856142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Spaghetti code is more of a term for monolithic mess where you have a hard time following all the code logic (cyclomatic complexity) and dependencies.<p>The only thing worse than a monolithic mess, is the same thing but distributed</div><br/></div></div><div id="35854722" class="c"><input type="checkbox" id="c-35854722" checked=""/><div class="controls bullet"><span class="by">ohmahjong</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853928">parent</a><span>|</span><a href="#35856142">prev</a><span>|</span><a href="#35854118">next</a><span>|</span><label class="collapse" for="c-35854722">[-]</label><label class="expand" for="c-35854722">[2 more]</label></div><br/><div class="children"><div class="content">I saw this described recently as the &quot;Lambda Pinball&quot; architecture.<p>* <a href="https:&#x2F;&#x2F;www.thoughtworks.com&#x2F;radar&#x2F;techniques?blipid=201911055" rel="nofollow">https:&#x2F;&#x2F;www.thoughtworks.com&#x2F;radar&#x2F;techniques?blipid=2019110...</a></div><br/><div id="35855264" class="c"><input type="checkbox" id="c-35855264" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854722">parent</a><span>|</span><a href="#35854118">next</a><span>|</span><label class="collapse" for="c-35855264">[-]</label><label class="expand" for="c-35855264">[1 more]</label></div><br/><div class="children"><div class="content">When even Thoughtworks thinks you are doing it wrong you know you are in trouble.</div><br/></div></div></div></div><div id="35854118" class="c"><input type="checkbox" id="c-35854118" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853928">parent</a><span>|</span><a href="#35854722">prev</a><span>|</span><a href="#35853982">next</a><span>|</span><label class="collapse" for="c-35854118">[-]</label><label class="expand" for="c-35854118">[3 more]</label></div><br/><div class="children"><div class="content">How about spaghetti architecture.</div><br/><div id="35854429" class="c"><input type="checkbox" id="c-35854429" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854118">parent</a><span>|</span><a href="#35854173">next</a><span>|</span><label class="collapse" for="c-35854429">[-]</label><label class="expand" for="c-35854429">[1 more]</label></div><br/><div class="children"><div class="content">Prior art:<p><a href="https:&#x2F;&#x2F;preview.redd.it&#x2F;y3pw78z0s3oz.jpg?auto=webp&amp;v=enabled&amp;s=6d65658e38c993ea7bccfc6c0b378262ee98bcd9" rel="nofollow">https:&#x2F;&#x2F;preview.redd.it&#x2F;y3pw78z0s3oz.jpg?auto=webp&amp;v=enabled...</a></div><br/></div></div><div id="35854173" class="c"><input type="checkbox" id="c-35854173" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854118">parent</a><span>|</span><a href="#35854429">prev</a><span>|</span><a href="#35853982">next</a><span>|</span><label class="collapse" for="c-35854173">[-]</label><label class="expand" for="c-35854173">[1 more]</label></div><br/><div class="children"><div class="content">I like that one.</div><br/></div></div></div></div><div id="35853982" class="c"><input type="checkbox" id="c-35853982" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853928">parent</a><span>|</span><a href="#35854118">prev</a><span>|</span><a href="#35857241">next</a><span>|</span><label class="collapse" for="c-35853982">[-]</label><label class="expand" for="c-35853982">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I completely agree with all of that.</div><br/></div></div></div></div><div id="35857241" class="c"><input type="checkbox" id="c-35857241" checked=""/><div class="controls bullet"><span class="by">empthought</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853811">parent</a><span>|</span><a href="#35853928">prev</a><span>|</span><a href="#35858212">next</a><span>|</span><label class="collapse" for="c-35857241">[-]</label><label class="expand" for="c-35857241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Infinite concurrency is a bit of a curse. Want to use that MySQL DB that contains all your business critical data? Better use some MySQL Serverless proxy nonsense because unbounded connections isn&#x27;t fun.<p>Or just set the Lambda concurrency to a fixed value proportional to your MySQL DB&#x27;s capacity. It&#x27;s an easy parameter.<p>&gt; Unpredictable runtime makes observability more complicated, probably forcing you into poor decisions as a result, i.e prom push gateway.<p>This is just nonsense. What is &quot;unpredictable&quot; about the runtime? What is difficult about enabling X-Ray?<p>&gt; Runtime&#x2F;execution time limits mean people trying to do all-serverless end up doing horrible things to accomplish long-running tasks.<p>&quot;All-serverless&quot; is just as stupid an idea as &quot;no-serverless.&quot;<p>Aside from lock-in, your &quot;cons&quot; are just the cons of anyone trying to build large-scale systems without knowing what they are doing. There is absolutely no way anyone who read the documentation would run into your cons of serverless.<p><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;wellarchitected&#x2F;latest&#x2F;serverless-applications-lens&#x2F;welcome.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;wellarchitected&#x2F;latest&#x2F;serverles...</a></div><br/></div></div><div id="35858212" class="c"><input type="checkbox" id="c-35858212" checked=""/><div class="controls bullet"><span class="by">unusualmonkey</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853811">parent</a><span>|</span><a href="#35857241">prev</a><span>|</span><a href="#35857272">next</a><span>|</span><label class="collapse" for="c-35858212">[-]</label><label class="expand" for="c-35858212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Turns all your code into spaghetti, this is probably the biggest one.<p>This is a nonsensical claim. Nothing about serverless requires &#x27;spaghetti&#x27; code. Vice versa, nothing aboud non-serverless deployments suddenly ensures well written code.<p>&gt; Cold boot performance is highly varible and generally worsens with added function complexity but this depends on tech choice.<p>For many use-cases this isn&#x27;t a problem. If it is a problem, then sure, don&#x27;t use serverless.<p>&gt; Infinite concurrency is a bit of a curse. Want to use that MySQL DB that contains all your business critical data? Better use some MySQL Serverless proxy nonsense because unbounded connections isn&#x27;t fun.<p>Sure, but:<p>A) You get a lot of scalability before that becomes an issue.
B) Setting up a proxy isn&#x27;t exactly hard. (I get one for free since we use Hasura).<p>&gt; Lock-in is awful, migration story is awful.<p>This is nonsense.<p>Our serverless code runs in docker containers, running perfectly normal ASP.net code. This code could be deployed to a VM, appengine, or k8s in less than a day if needed.<p>&gt; Amount of Infrastructure as Code overhead, ala Terraform, CloudFormation, whatever else floats your boat to support serverless is insane. The sheer number of objects that need to defined, kept in sync etc is just bonkers. Not to mention if you have multiple services setup like this it&#x27;s all boilerplate you either need to abstract or carry around.<p>One of the advantages of our use of serverless is that we don&#x27;t yet need any of that complexity.<p>&gt; Hides serious programming deficiencies like memory leaks because context is thrown away after servicing request.<p>What you descried is literally not a serious deficiencies. If you code leaks memory, but never runs long enough for that to have meaningful impact, it&#x27;s not a problem.<p>&gt; Unpredictable runtime makes observability more complicated, probably forcing you into poor decisions as a result, i.e prom push gateway.<p>The serverless solutions we use have observability built in for free... and datadog automatically can pull that in if you wnat a starting point for more.<p>&gt; Runtime&#x2F;execution time limits mean people trying to do all-serverless end up doing horrible things to accomplish long-running tasks.<p>If you have something that <i>must</i> be long running, serveless isn&#x27;t a great pick for that one thing (at least, witht he solutions I&#x27;m aware of).<p>That said, there are some elegant ways to handle that using serverless (e.g. by breaking it into smaller tasks with shorter durations)... and going non-serverless isn&#x27;t a silver bullet, I&#x27;ve seen terrible architectures for long-running code in all kinds of deployments.<p>&gt; All of the above leads to increasing pressure to make poor architectural decisions to work around limitations of the runtime.<p>Completely ignoring that serverless can encourage better architectural decisions.<p>&gt; EDIT: Actually I forgot the worst con. The cost. The $&#x2F;CPU&#x2F;RAM cost of Serverless is beyond bonkers. When I was pricing up Cloud Functions vs Spot instances on GKE I think I came to the conclusion Cloud Functions are about 300x as expensive.<p>Curious.<p>Let&#x27;s have a 1s task on Cloud Run with 1 CPU and 1GB of memory:<p>CPU: $0.00002400&#x2F;s
Memory: $0.00000250&#x2F;s
Request: $0.40 &#x2F; million<p>Total = $0.0000269 for 1 request lasting 1s.<p>Current spot pricing for C3 instances is:<p>$0.003086 &#x2F; vCPU hour
$0.000413 &#x2F; GB hour<p>Or for 1s that would be:
0.00000097&#x2F;s<p>Which is 27x cheaper - so you&#x27;re already off by an order of a magnitude.<p>It gets worse - that&#x27;s 1GB of RAM, however the VM needs RAM for it&#x27;s own OS etc, so maybe you need to provision 2GB of memory, a bit more CPU etc.<p>The minimum billing time for compute instances according to docs is 60s... so 60x cost if you only need to do this hourly or less.<p>You&#x27;re entirely responsible for <i>all</i> time spent, including startup, shut down, idle etc. This just adds more and more cost.<p>The expected availability model is completely different - serverless should be available in milliseconds, seconds at the worst. Spot instances have no such expectations.<p>It&#x27;s a fundamentally different model - a spot VM can&#x27;t loadbalance, serve code or anything without devops. So now we&#x27;re spending likely $XXX&#x2F;hour on devops to try to save fractions of pennies an hour.<p>When this is all said and done, I don&#x27;t think you really understand the cost or use-cases of serverless well - and dramatically underestimate the costs of the solutions you present.</div><br/></div></div><div id="35857272" class="c"><input type="checkbox" id="c-35857272" checked=""/><div class="controls bullet"><span class="by">scarface74</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853811">parent</a><span>|</span><a href="#35858212">prev</a><span>|</span><a href="#35854580">next</a><span>|</span><label class="collapse" for="c-35857272">[-]</label><label class="expand" for="c-35857272">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Infinite concurrency is a bit of a curse. Want to use that MySQL DB that contains all your business critical data? Better use some MySQL Serverless proxy nonsense because unbounded connections isn&#x27;t fun.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;compute&#x2F;using-amazon-rds-proxy-with-aws-lambda&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;compute&#x2F;using-amazon-rds-proxy-...</a></div><br/></div></div></div></div></div></div><div id="35854580" class="c"><input type="checkbox" id="c-35854580" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853681">prev</a><span>|</span><a href="#35853740">next</a><span>|</span><label class="collapse" for="c-35854580">[-]</label><label class="expand" for="c-35854580">[3 more]</label></div><br/><div class="children"><div class="content">Your comment highlights that you really don&#x27;t understand what &quot;serverless&quot; is. We run a monolith running on App Engine &quot;NodeJS Flexible&quot;. All of our code is basically a single Node monolith, and under the covers many of GCP&#x27;s newer serverless options (like Cloud Run and Cloud Functions V2) run on the same infrastructure -it&#x27;s basically just containers, and they even offer versions that let you simply deploy any Docker containerized app.<p>But compared to the maintenance burden I&#x27;ve seen with other similarly sized startups that use k8s, we just spend way, way less time on infrastructure management.<p>On a related note, this kind of language, &quot;The only world where I can make a good case for serverless for small teams is if you have said poor leadership and serverless helps you escape their poor decision making.&quot; which is basically &quot;if you don&#x27;t agree with me you&#x27;re an idiot&quot;, says a lot more about the speaker than the speakers usually realize, and it&#x27;s a huge, giant red flag.</div><br/><div id="35854820" class="c"><input type="checkbox" id="c-35854820" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854580">parent</a><span>|</span><a href="#35853740">next</a><span>|</span><label class="collapse" for="c-35854820">[-]</label><label class="expand" for="c-35854820">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I am familiar with those (Cloud Run, Fargate et al) and they are much less egregious than Lambda and Cloud Functions. As for if they qualify as Serverless though I don&#x27;t know, it seems poorly defined.<p>How about I clarify that my stance mostly relates to Functions as a Service so it&#x27;s clear that while I wouldn&#x27;t choose Cloud Run over GKE that is hugely different to FaaS.</div><br/><div id="35854999" class="c"><input type="checkbox" id="c-35854999" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854820">parent</a><span>|</span><a href="#35853740">next</a><span>|</span><label class="collapse" for="c-35854999">[-]</label><label class="expand" for="c-35854999">[1 more]</label></div><br/><div class="children"><div class="content">I think Cloud Run, Fargate and Azure Container Apps all fall more into the category of &quot;platform-as-a-service&quot; rather than &quot;function-as-a-service&quot;, in the same way that EKS or GKE could be categorised as a PAAS.<p>EDIT: I also think they&#x27;re _excellent_ to use for development. The migration from ECS + Fargate to EKS + EC2 is not a difficult migration from the application side, and can be done relatively piecemeal, in my experience.</div><br/></div></div></div></div></div></div><div id="35853740" class="c"><input type="checkbox" id="c-35853740" checked=""/><div class="controls bullet"><span class="by">romanhn</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35854580">prev</a><span>|</span><a href="#35854803">next</a><span>|</span><label class="collapse" for="c-35853740">[-]</label><label class="expand" for="c-35853740">[14 more]</label></div><br/><div class="children"><div class="content">As someone who went with Lambda for my current project, I don&#x27;t agree with this take at all. In fact, it&#x27;s as boring of an implementation as you can imagine - a single &quot;fat function&quot; developed in .NET serving the entire web application. Can be easily transplanted onto any other hosting paradigm, but Lambda is incredibly cheap (free at my current usage) and incredibly scalable should I hit some inflection point. Learning K8s would have been quite an overkill.</div><br/><div id="35853816" class="c"><input type="checkbox" id="c-35853816" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853740">parent</a><span>|</span><a href="#35853831">next</a><span>|</span><label class="collapse" for="c-35853816">[-]</label><label class="expand" for="c-35853816">[7 more]</label></div><br/><div class="children"><div class="content">We are thinking the exact same thing (w&#x2F; Az Functions). Keeping it simple as possible means you can forklift the whole thing in one afternoon to a different provider. It also means you could potentially even go back to an on-prem stack or whatever.<p>We are looking at taking our .NET6 monolith and &quot;inverting&quot; it so the entry point  is our logical HTTP resources instead of the various DI monstrosities that emerge from main.<p>The reasoning for us is that we don&#x27;t want ownership over all of the horrible things we could get wrong. If a &lt;TLS1.2 connection some how gets established and something naughty happens because we forgot to update some startup.cs boilerplate, it&#x27;s currently our pain today. Like legally. If we are just eating pre-approved&#x2F;filtered&#x2F;etc HTTP requests from inside our hermetically-sealed function environment, we get to cast a lot more blame than we otherwise would be able to.<p>I really don&#x27;t get why you&#x27;d go to serverless and then shit it up with a lot of extra complexity. The whole point in my view is to inherit the compliance packages of your hyperscalar by way of directly using their native primitives in as standard a way as possible. This means you get to &#x27;sail&#x27; through audits and engage up-market clients that are typically out of reach for everyone else.</div><br/><div id="35854402" class="c"><input type="checkbox" id="c-35854402" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853816">parent</a><span>|</span><a href="#35853920">next</a><span>|</span><label class="collapse" for="c-35854402">[-]</label><label class="expand" for="c-35854402">[5 more]</label></div><br/><div class="children"><div class="content">If you have a monolithic entrypoint, is it really serverless? You&#x27;re simply using the Lambda infra as a run-on-demand server, something Heroku has been offering for 10+ years. Why would you pay extra when you can deploy to a simple VM or managed platform costing 100x less?</div><br/><div id="35855285" class="c"><input type="checkbox" id="c-35855285" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854402">parent</a><span>|</span><a href="#35855381">next</a><span>|</span><label class="collapse" for="c-35855285">[-]</label><label class="expand" for="c-35855285">[2 more]</label></div><br/><div class="children"><div class="content">What you described would be more akin to using ECS Fargate to run the workload. What they described sounds like a single .NET lambda behind API Gateway, so the infrastructure of ingesting requests (and handling TLS termination, DDoS mitigation, WAF, etc.) all happens on the AWS side. All you have to do is handle the routing inside of the lambda using regular ASP.NET Core. It would also scale up infinitely and down to zero with no work on their end. This isn’t similar to running something on Heroku on an allocated server with fixed overhead at all.</div><br/><div id="35857730" class="c"><input type="checkbox" id="c-35857730" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855285">parent</a><span>|</span><a href="#35855381">next</a><span>|</span><label class="collapse" for="c-35857730">[-]</label><label class="expand" for="c-35857730">[1 more]</label></div><br/><div class="children"><div class="content">Indeed it would be more like Fargate in terms of container runtime vs lambda runtime, but the line between those is pretty blurry. Fly.io for example does containers but they spawn faster than some cloud function platforms. It&#x27;s not really relevant for the discussion.<p>&gt; Heroku on an allocated server with fixed overhead at all<p>I don&#x27;t think you&#x27;re familiar with Heroku then? I&#x27;m not talking about dedicated or managed servers. That&#x27;s exactly what their &#x27;dynos&#x27; platform has been doing since ~2008, though less granular: <a href="https:&#x2F;&#x2F;www.heroku.com&#x2F;dynos&#x2F;scaling" rel="nofollow">https:&#x2F;&#x2F;www.heroku.com&#x2F;dynos&#x2F;scaling</a><p>&quot;All you have to do is handle the routing inside of the lambda using regular ASP.NET Core&quot; also applies to both fly.io and Heroku. That&#x27;s what I&#x27;m getting at. If you don&#x27;t have a collection of independent cloud functions to execute, and you are spinning up a little monolith for every request, the platform seems like overkill.</div><br/></div></div></div></div><div id="35855381" class="c"><input type="checkbox" id="c-35855381" checked=""/><div class="controls bullet"><span class="by">romanhn</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854402">parent</a><span>|</span><a href="#35855285">prev</a><span>|</span><a href="#35855259">next</a><span>|</span><label class="collapse" for="c-35855381">[-]</label><label class="expand" for="c-35855381">[1 more]</label></div><br/><div class="children"><div class="content">What makes it serverless is the ability to spin up instances on demand (including down to zero when not in use), while paying only when the resources are in use. Given Lambda&#x27;s generous free tier, I&#x27;m literally paying nothing for it. That would not be the case for any other platform.</div><br/></div></div><div id="35855259" class="c"><input type="checkbox" id="c-35855259" checked=""/><div class="controls bullet"><span class="by">rhodysurf</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854402">parent</a><span>|</span><a href="#35855381">prev</a><span>|</span><a href="#35853920">next</a><span>|</span><label class="collapse" for="c-35855259">[-]</label><label class="expand" for="c-35855259">[1 more]</label></div><br/><div class="children"><div class="content">Because it doesn’t actually cost less? You have to have a LOT of invocations to match the cost of the entry level 6 dollar digital ocean box. And with that you have to manage that box vs serverless you don’t have to spend engineering time (which costs an order of magnitude more) on maintenance, a big deal for small shops without dedicated&#x2F;capable ops teams.</div><br/></div></div></div></div></div></div><div id="35853831" class="c"><input type="checkbox" id="c-35853831" checked=""/><div class="controls bullet"><span class="by">fallat</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853740">parent</a><span>|</span><a href="#35853816">prev</a><span>|</span><a href="#35854803">next</a><span>|</span><label class="collapse" for="c-35853831">[-]</label><label class="expand" for="c-35853831">[6 more]</label></div><br/><div class="children"><div class="content">k8s is not as hard as its advertised</div><br/><div id="35854413" class="c"><input type="checkbox" id="c-35854413" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853831">parent</a><span>|</span><a href="#35853952">next</a><span>|</span><label class="collapse" for="c-35854413">[-]</label><label class="expand" for="c-35854413">[2 more]</label></div><br/><div class="children"><div class="content">I implemented self-hosted k8s in my current company and had to learn it from the ground. I&#x27;m not a professional, but I learned a thing or two.<p>My opinion is as follows:<p>Installing kubernetes with kubeadm is easy. You can do it in few hours if you&#x27;re fluent with Linux.<p>Kubernetes storage is where it starts to be hard. We were lucky to have OpenStack hosting which allows to use network block storage (ceph) without any additional work. Using kubernetes without any storage might severely limits apps you can run there, although it&#x27;s possible. Using local storage is an option but also with many &quot;but&quot;. Rolling out ceph: I&#x27;ve heard it&#x27;s hard.<p>Load balancing: again I was lucky to have OpenStack load balancer. Otherwise, I think that it&#x27;s possible, but definitely not within a few hours, unless you did it before.<p>Kubernetes networking might be tricky. I wasn&#x27;t able to implement it in a way I like. I used calico with overlay mode in the end, but I&#x27;d prefer &quot;flat&quot; network. Calico overlay mode was easy.<p>Upgrading kubernetes manually is easy. At least until it breaks, it didn&#x27;t break for me yet. kubeadm just works.<p>Node autoscaling is hard. There&#x27;re no simple solutions, at least I didn&#x27;t find any. Our cluster does not autoscale. Manual scaling is not hard, though. I can implement autoscaling with loads of bash&#x2F;terraform&#x2F;cloudinit scripts but I&#x27;d rather not to. I think that node autoscaling is what managed kubernetes offering do well.<p>Now that we have kubernetes, story is not really over. We need to collect logs for nodes, for services, for pods. We need to collect metrics. We need to set up alerts. We need to have traces. Service mesh looks really nice so you can see how services interact with each other. Those things are not for given. They take lot of time and expertise. And while they&#x27;re not strictly about kubernetes, usually you need them.</div><br/><div id="35856217" class="c"><input type="checkbox" id="c-35856217" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854413">parent</a><span>|</span><a href="#35853952">next</a><span>|</span><label class="collapse" for="c-35856217">[-]</label><label class="expand" for="c-35856217">[1 more]</label></div><br/><div class="children"><div class="content">Agree on storage being the hard part. You either need a robust SAN to store persistent volumes or you need to store persistent volumes on the local storage of kubelets which is a major pain. Once a pod binds a local pvc to a kubelet that pod must now run on that kubelet for the rest of eternity. If you want to get rid of a kubelet with a local pvc you either need the application be durable to data loss (which many are not) or you need to implement some sort of stateful pod draining logic.<p>When rolling your own, I think you need to invest in a battle tested SAN or just not do stateful on k8s. For the handful of stateful services I  have run on k8s it would have been better to just use a managed stateful solution.</div><br/></div></div></div></div><div id="35853952" class="c"><input type="checkbox" id="c-35853952" checked=""/><div class="controls bullet"><span class="by">ghaff</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853831">parent</a><span>|</span><a href="#35854413">prev</a><span>|</span><a href="#35854803">next</a><span>|</span><label class="collapse" for="c-35853952">[-]</label><label class="expand" for="c-35853952">[3 more]</label></div><br/><div class="children"><div class="content">One of my recent conclusions is that it&#x27;s not so much that Kubernetes on its own is so very complicated; it&#x27;s that if someone tries to glue their own container platform together from Kubernetes plus another dozen or so cloud-native projects and integrate the whole thing, it can get wickedly complex very quickly.</div><br/><div id="35854109" class="c"><input type="checkbox" id="c-35854109" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853952">parent</a><span>|</span><a href="#35854803">next</a><span>|</span><label class="collapse" for="c-35854109">[-]</label><label class="expand" for="c-35854109">[2 more]</label></div><br/><div class="children"><div class="content">Right — Kubernetes was evolved in the context of being a Google Cloud service, and despite now having other deployments, still is mostly architected around the assumption that your Kubernetes cluster is surrounded by a featureful IaaS platform providing things like managed load balancers, VM auto-scaling pools, iSCSI volumes on a dedicated SAN network, non-throughput-bottlenecked object storage (and a container image repo on top of that!), a centralized logs and metrics sink, etc. A k8s cluster expects these like a computer expects a bootable storage device.<p>If you&#x27;re using a <i>managed</i> Kubernetes (in GCP, or AWS, or Azure, etc) then the owner of the platform presumably has all this stuff going on somewhere (whether they expose it to you or not), and so is solving all these problems for you. But if you&#x27;re <i>not</i> using managed Kubernetes — i.e. if you&#x27;re ever typing `k3s deploy` or whatever equivalent — then you&#x27;d better realize that you&#x27;re signing up to either <i>also</i> deploy and manage your own bare-metal OpenStack deployment for your k8s cluster to plug into; or to tediously glue together a grab-bag of services from your hosting provider + third-parties to achieve the same effects.<p>(And this is why Google&#x27;s &quot;Anthos&quot; is an interesting offering to many enterprises: rather than running your own on-prem k8s cluster implying the need to own+manage on-prem supporting infra, you can instead have a GCP project that has all the managed supporting infra, and maybe some hosted k8s clusters; and then your on-prem k8s nodes can just think of themselves as part of that GCP project, relying on the same cloud infra that the hosted clusters are relying on — while still being on-prem nodes, and so still having data security guarantees, low-latency links to your other on-prem systems, etc.)</div><br/><div id="35854213" class="c"><input type="checkbox" id="c-35854213" checked=""/><div class="controls bullet"><span class="by">ghaff</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854109">parent</a><span>|</span><a href="#35854803">next</a><span>|</span><label class="collapse" for="c-35854213">[-]</label><label class="expand" for="c-35854213">[1 more]</label></div><br/><div class="children"><div class="content">There are other container platforms like Red Hat OpenShift as well (disclaimer: I work there) either operated for you or on-prem (doesn&#x27;t need to be on top of OpenStack and typically isn&#x27;t these days). I&#x27;m biased but Kubernetes complexity tends to be conflated with the complexity of a DIY container platform which can be significant, especially given that Kubernetes itself has generally made the decision to keep its scope relatively narrow.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35854803" class="c"><input type="checkbox" id="c-35854803" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853740">prev</a><span>|</span><a href="#35855392">next</a><span>|</span><label class="collapse" for="c-35854803">[-]</label><label class="expand" for="c-35854803">[2 more]</label></div><br/><div class="children"><div class="content">JVM+PG+k8s is absolutely not &quot;boring tech&quot; to me.<p>LAMP, this is boring tech. You can switch Apache for Nginx, and MySQL for another SQL database, but that&#x27;s the idea. People still develop in PHP today, and performance-wise, assuming you follow standard good development practices, and good servers, it can take a lot. If it was good enough to get Facebook started, it is most likely good enough for you, and the situation has much improved since the early days of Facebook, a lot of it thanks to Facebook itself, and also better hardware. PHP security is not as terrible as it once was too.<p>At work we have a couple of Spring projects, and I don&#x27;t think I have hated a tech stack more than that. If you to illustrate the &quot;action at a distance&quot; anti-pattern, look no further. I&#x27;m sure most Spring web apps could be implement in PHP for a fraction of the size, both in terms of application code and memory. I don&#x27;t do k8s, so I have no real opinion except that it looks like overkill in many cases. As for Postgres, nothing against it, it is a very good SQL database, though my opinion is that you should limit yourself to basic SQL as much as you can, so that you are not dependent on a particular database.</div><br/><div id="35856783" class="c"><input type="checkbox" id="c-35856783" checked=""/><div class="controls bullet"><span class="by">cutler</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854803">parent</a><span>|</span><a href="#35855392">next</a><span>|</span><label class="collapse" for="c-35856783">[-]</label><label class="expand" for="c-35856783">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get how a Spring app rewritten in PHP, assuming a framework is used, reduces code significantly given that PHP5+ is a dynamically-typed Java clone with the same mind-numbing boilerplate.</div><br/></div></div></div></div><div id="35855392" class="c"><input type="checkbox" id="c-35855392" checked=""/><div class="controls bullet"><span class="by">websap</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35854803">prev</a><span>|</span><a href="#35853690">next</a><span>|</span><label class="collapse" for="c-35855392">[-]</label><label class="expand" for="c-35855392">[1 more]</label></div><br/><div class="children"><div class="content">Serverless first is a great way to start building your business. As long as you don’t have strict latency requirements. You focus on your business, while the infrastructure requirements are handled for you.<p>The point of engineering is to deliver the best solution and the right cost. Cost needs to be evaluated on multiple dimensions - actual dollars, time required to build, time required to maintain.<p>Nothing stops you from using Postgres with Lambda. AWS has done a bunch of work to make this possible.<p>I would recommend, creating the correct layer of separation in your code, so that when the times comes to migrate from Lambda or other serverless functions to Fargate, cloudrun, or even containers run on VMs managed by K8S, you have to make minimal changes to get up and running.</div><br/></div></div><div id="35853690" class="c"><input type="checkbox" id="c-35853690" checked=""/><div class="controls bullet"><span class="by">opmelogy</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35855392">prev</a><span>|</span><a href="#35853607">next</a><span>|</span><label class="collapse" for="c-35853690">[-]</label><label class="expand" for="c-35853690">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All the points noted in the slides etc just come from poor engineering leadership. i.e decisions&#x2F;choices, etc.<p>Hindsight is 20&#x2F;20. It&#x27;s easy to make these claims after the fact. In the moment it&#x27;s far more complex and the decisions made at the time take in a lot of factors. Oversimplifying things and placing blame on a tiny thing doesn&#x27;t push the discussion and learnings forward.<p>Lambda came out in late 2014 and Step Functions came out in late 2016. It&#x27;s entirely likely that this team was an early adopter of the tech. Internally a lot of these AWS technologies have a roadmap that sound like they will solve a lot of your issues but those roadmaps get tossed fairly regularly as priorities shift at the product level and AWS-wide level.<p>We won&#x27;t be able to get the info on what went on here (likely the team that improved things doesn&#x27;t even know due to turn over). But watering it down to be &quot;poor engineering leadership&quot; is off the mark and way too simplistic.</div><br/><div id="35854029" class="c"><input type="checkbox" id="c-35854029" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853690">parent</a><span>|</span><a href="#35853607">next</a><span>|</span><label class="collapse" for="c-35854029">[-]</label><label class="expand" for="c-35854029">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t talking about the Prime Video case, I was talking about the slides in Adrians blog post which compare Serverless with traditional development.<p>IMO if you are facing those problems it has to be poor leadership, there is no excuse for why you shouldn&#x27;t be able to make effective decisions if you know what you are doing.</div><br/></div></div></div></div><div id="35853607" class="c"><input type="checkbox" id="c-35853607" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853690">prev</a><span>|</span><a href="#35853650">next</a><span>|</span><label class="collapse" for="c-35853607">[-]</label><label class="expand" for="c-35853607">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t care for serverless, but your suggestion that the only right way to build software is by using the JVM, and the only right way to use the JVM is to use Spring or Quarkus is... puzzling to say the least.<p>I might as well say that you should run everything on PHP. I guess that&#x27;s boring too?</div><br/><div id="35853646" class="c"><input type="checkbox" id="c-35853646" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853607">parent</a><span>|</span><a href="#35853649">next</a><span>|</span><label class="collapse" for="c-35853646">[-]</label><label class="expand" for="c-35853646">[7 more]</label></div><br/><div class="children"><div class="content">You can sub JVM for something else but you should probably stick with PG and k8s.<p>What I am saying is the highest quality tools are still the best and will remain that way. As other things come and go they absorb the best ideas from the new stuff without losing what makes them good.<p>Sometimes the new stuff survives (Node&#x2F;TS&#x2F;Go&#x2F;Rust) sometimes it doesn&#x27;t (Clojure, Scala, arguably Ruby), some we are waiting to find out.<p>But betting on JVM and .NET has been winning strategy from a technical perspective for a long time now.<p>Also worth mentioning no, PHP probably doesn&#x27;t work here because it&#x27;s not &quot;general purpose&quot; enough IMO.
JVM can handle almost any workload shape, the main one it doesn&#x27;t do well in is memory constrained environments (though it&#x27;s possible if you really want to).
PHP, Node&#x2F;TS, Python, Ruby all suffer from being single threaded so can&#x27;t take advantage of properly large machines without a ton of extra complexity and you pay a high memory overhead for most of those strategies.<p>Go is OK, I hate writing it but it can do all the things so if that floats your boat go for it. Rust is also perfectly fine, I just find it is actually pretty slow to write because changing requirements often mean changing structure which can be harder to manage in Rust vs Java&#x2F;Kotlin&#x2F;C#.<p>Anyways, wasn&#x27;t meant to be a thing about languages. Just pick a good runtime or AoT lang of choice, write everything in it, stick to conventional frameworks, choose PostgreSQL, run the lot on k8s. That is the core takeaway.</div><br/><div id="35853876" class="c"><input type="checkbox" id="c-35853876" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853646">parent</a><span>|</span><a href="#35856795">next</a><span>|</span><label class="collapse" for="c-35853876">[-]</label><label class="expand" for="c-35853876">[3 more]</label></div><br/><div class="children"><div class="content">I mean, I currently work on the JVM, I just have enough experience with different languages (including Ruby, which I don&#x27;t think is quite dead yet) and tech stacks to know that they all suck in their own way. The JVM, and specifically Java, and even more specifically Spring, have a lot of annoying warts, it&#x27;s just that other languages have different warts. I agree that you shouldn&#x27;t try to rewrite everything in an obscure, untested technology, but beyond that, there&#x27;s a number of options with enough tradeoffs. But it seems we&#x27;re largely in agreement there.<p>I don&#x27;t necessarily agree with the &quot;keep everything in one language &#x2F; stack&quot; sentiment. There&#x27;s certainly companies that overdo it, having 20 different languages at the same time. But there&#x27;s also valid reasons for keeping certain tech stacks separate (e.g. having to do ML &#x2F; data analysis stuff in Python). In the worst case, the &quot;use only a single language&quot; mindset leads to disasters like GWT, which is something that my current company unfortunately still uses because some Java developers (that don&#x27;t work for the company any more) thought that JavaScript was beneath them.<p>I also wouldn&#x27;t choose PHP, for the record. I would like to trash it here, but I&#x27;ve never actually been forced to use it, so I can&#x27;t even comment on it.<p>I&#x27;m not so sure about k8s. I think you can get away with much simpler deployment models, too. At some point the overhead of having to manage everything manually (or a need for zero-downtime deployments) might make the added complexity of k8s more bearable, but it&#x27;s certainly added complexity and not necessary everywhere and all the time.<p>I 100% agree about postgres, it&#x27;s so good and feature-rich that you should probably really only ever use another database if you have very specific needs (except maybe also adding redis as a cache, because redis is also very good).</div><br/><div id="35855972" class="c"><input type="checkbox" id="c-35855972" checked=""/><div class="controls bullet"><span class="by">DanHulton</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853876">parent</a><span>|</span><a href="#35856795">next</a><span>|</span><label class="collapse" for="c-35855972">[-]</label><label class="expand" for="c-35855972">[2 more]</label></div><br/><div class="children"><div class="content">Quarkus also has a lot of annoying warts, as does just plain ol&#x27; Java.<p>Lord, if I never see another Builder pattern again in my life, I may die a happy man.</div><br/><div id="35856807" class="c"><input type="checkbox" id="c-35856807" checked=""/><div class="controls bullet"><span class="by">cutler</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855972">parent</a><span>|</span><a href="#35856795">next</a><span>|</span><label class="collapse" for="c-35856807">[-]</label><label class="expand" for="c-35856807">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Builder.build() wtf!!?</div><br/></div></div></div></div></div></div><div id="35856795" class="c"><input type="checkbox" id="c-35856795" checked=""/><div class="controls bullet"><span class="by">cutler</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853646">parent</a><span>|</span><a href="#35853876">prev</a><span>|</span><a href="#35853724">next</a><span>|</span><label class="collapse" for="c-35856795">[-]</label><label class="expand" for="c-35856795">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about absorbing the best ideas. Java, even after the introduction of raw string literals, still can&#x27;t handle a regex without escaping metacharacters. Perl had that one solved in the 90s.</div><br/></div></div><div id="35853724" class="c"><input type="checkbox" id="c-35853724" checked=""/><div class="controls bullet"><span class="by">foffoofof</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853646">parent</a><span>|</span><a href="#35856795">prev</a><span>|</span><a href="#35853649">next</a><span>|</span><label class="collapse" for="c-35853724">[-]</label><label class="expand" for="c-35853724">[2 more]</label></div><br/><div class="children"><div class="content">Agreed re: jvm and .net.<p>It’s easy to imagine a resurgence in the future.</div><br/><div id="35856664" class="c"><input type="checkbox" id="c-35856664" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853724">parent</a><span>|</span><a href="#35853649">next</a><span>|</span><label class="collapse" for="c-35856664">[-]</label><label class="expand" for="c-35856664">[1 more]</label></div><br/><div class="children"><div class="content">Java by all accounts and if jvm include Kotlin is 1 of the most widely used. Do you still want a resurgence? :)</div><br/></div></div></div></div></div></div><div id="35856670" class="c"><input type="checkbox" id="c-35856670" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853607">parent</a><span>|</span><a href="#35853649">prev</a><span>|</span><a href="#35853650">next</a><span>|</span><label class="collapse" for="c-35856670">[-]</label><label class="expand" for="c-35856670">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I might as well say that you should run everything on PHP. I guess that&#x27;s boring too?<p>PHP can&#x27;t run everything though. If we go by the traditional model it&#x27;s per request and fails at things like websockets. It&#x27;s also less performant than a JVM solution, so definitely can&#x27;t serve every use case.</div><br/></div></div></div></div><div id="35853650" class="c"><input type="checkbox" id="c-35853650" checked=""/><div class="controls bullet"><span class="by">afandian</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853607">prev</a><span>|</span><a href="#35855638">next</a><span>|</span><label class="collapse" for="c-35853650">[-]</label><label class="expand" for="c-35853650">[6 more]</label></div><br/><div class="children"><div class="content">I’m building something with Spring Boot, Kotlin, Postgres and containers, with a small team. It’s far from boring, it’s the most fun I’ve had in ages.</div><br/><div id="35854252" class="c"><input type="checkbox" id="c-35854252" checked=""/><div class="controls bullet"><span class="by">switch007</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853650">parent</a><span>|</span><a href="#35853897">next</a><span>|</span><label class="collapse" for="c-35854252">[-]</label><label class="expand" for="c-35854252">[2 more]</label></div><br/><div class="children"><div class="content">Spring is fun until you need to do anything mildly complex and then you tear your hair out trying to find the right documentation. You have to navigate myriad of sub projects. They really really need to sort out the SEO. It’s atrocious.<p>The only way to learn Spring is to read the latest manuals of every subproject you think you might need, cover to cover.<p>Even then you might not figure out what awkward collection of beans you need to override the magic Spring does.</div><br/><div id="35854540" class="c"><input type="checkbox" id="c-35854540" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854252">parent</a><span>|</span><a href="#35853897">next</a><span>|</span><label class="collapse" for="c-35854540">[-]</label><label class="expand" for="c-35854540">[1 more]</label></div><br/><div class="children"><div class="content">I found Spring to have a little bit of an understandability cliff. Coming from Guice though once I understood the container and had a feel for the general patterns it was easy.<p>I think if you try to use it without understanding the magic you can probably get pretty far but you will always feel lost when things don&#x27;t work just like the example. Understanding how all the runtime wiring works at the DI&#x2F;IoC layer generally makes it pretty easy to work out what is going on though.</div><br/></div></div></div></div><div id="35853897" class="c"><input type="checkbox" id="c-35853897" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853650">parent</a><span>|</span><a href="#35854252">prev</a><span>|</span><a href="#35855638">next</a><span>|</span><label class="collapse" for="c-35853897">[-]</label><label class="expand" for="c-35853897">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I very much prefer Kotlin now. It&#x27;s Boring Tech but at the same time pleasant because of it&#x27;s high expressivity and tooling.<p>Also I find it way easier to convince people coming from a dynamic language background to try it out vs Java which they find less approachable. Which is ironic as Kotlin is by far the more complicated language vs Java.</div><br/><div id="35856683" class="c"><input type="checkbox" id="c-35856683" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853897">parent</a><span>|</span><a href="#35855638">next</a><span>|</span><label class="collapse" for="c-35856683">[-]</label><label class="expand" for="c-35856683">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Also I find it way easier to convince people coming from a dynamic language background to try it out vs Java which they find less approachable.<p>It&#x27;s just a sad fact of Kotlin is not Java. There are lots of people out there that just hate on Java as a hype train.</div><br/><div id="35857560" class="c"><input type="checkbox" id="c-35857560" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856683">parent</a><span>|</span><a href="#35855638">next</a><span>|</span><label class="collapse" for="c-35857560">[-]</label><label class="expand" for="c-35857560">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s sad. Java is really really good these days.</div><br/></div></div></div></div></div></div></div></div><div id="35855638" class="c"><input type="checkbox" id="c-35855638" checked=""/><div class="controls bullet"><span class="by">richardw</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853650">prev</a><span>|</span><a href="#35857010">next</a><span>|</span><label class="collapse" for="c-35855638">[-]</label><label class="expand" for="c-35855638">[3 more]</label></div><br/><div class="children"><div class="content">Stop with the confident silver bullets. There are effective teams using every stack out there, including serverless. The professional chooses the right tool for the job and team. This is an instance of one change between options that happened to blow in the direction you like, but there are good options at all points of the continuum.<p>I&#x27;ve used most languages in on-prem and distributed settings, from app to web app to micro services to serverless to single DB&#x27;s of all kinds to distributed everything, in all clouds, and all have their place and time and team.  Sometimes I&#x27;d arrive with a perfectly confident view and then learn that actually there is another truth.  Sometimes a 50-page stored procedure is perfect.  Microservices is awesome in the right context, monolith in the right context, just stop with the simple answers because you have a particular lens that works for you.<p>What a single lens does really well is that it removes options and that makes you faster at how you solve most problems.  Good for you, simplicity is excellent.  But don&#x27;t diss professionals and their leaders who have made choices and then adjust them based on the data.</div><br/><div id="35856081" class="c"><input type="checkbox" id="c-35856081" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855638">parent</a><span>|</span><a href="#35857010">next</a><span>|</span><label class="collapse" for="c-35856081">[-]</label><label class="expand" for="c-35856081">[2 more]</label></div><br/><div class="children"><div class="content">There is a big difference between learning the nuances of engineering as you go and re-adjusting your viewpoint vs bandwagoning on a new tool because it&#x27;s cool even though you can&#x27;t tie any of it&#x27;s advantages back to your problem statement.<p>That isn&#x27;t making a choice and adjusting based on the data, that is just shoddy engineering.<p>It should have been obvious to anyone at a cursory glance that not only did serverless not offer anything to this application it would be actively detrimental. Simple napkin math of data rate of a 1080p video stream should have made that immediately clear.<p>Just because you can use something to get a task done doesn&#x27;t make it a good choice. I can still write pretty decent Perl. It gets the job done and for some protocols that haven&#x27;t changed in a long time like LDAP the existing CPAN libraries are still some of the best. But that isn&#x27;t the right choice is it?<p>I don&#x27;t think it&#x27;s defensible to argue that we should build thing sub-standardly just to give people more choice. That is like arguing that real engineers should have more freedom in choice in how they design bridges. No one would agree with that.<p>We get away with it because our bridges are much cheaper to replace and noone dies if they break or have to be rewritten because they rotted too much to run anymore.<p>Right now as it stands arguments for serverless aren&#x27;t technical in nature. They are a best an appeal to &quot;the traditional way is slow&quot; or some notion of &quot;infinite scalability&quot;, the first of which isn&#x27;t true at all and the latter doesn&#x27;t matter for anyone that is arguing in favor of serverless.<p>Also even if it was &quot;faster&quot; (I don&#x27;t agree but lets postulate) that probably wouldn&#x27;t make it a good decision either unless it was proportionally faster vs it&#x27;s costs (not just dollar costs, architecture, complexity of managed objects, etc). Which I highly doubt would be the case.<p>As you can see from a technical POV it&#x27;s just very very hard to rationalise a position for serverless &gt; Boring Tech. For me it would take too much mental gymnastics.<p>I was perhaps a little strong but my points are solid.<p>If it was good it would have proven advantages by now. K8s adoption curve vs serverless adoption curve tells the real story of quality IMO, especially given how much bigger of a move it was to k8s from what preceeded it.</div><br/><div id="35856572" class="c"><input type="checkbox" id="c-35856572" checked=""/><div class="controls bullet"><span class="by">richardw</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856081">parent</a><span>|</span><a href="#35857010">next</a><span>|</span><label class="collapse" for="c-35856572">[-]</label><label class="expand" for="c-35856572">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think it&#x27;s defensible to argue that we should build thing sub-standardly just to give people more choice<p>That&#x27;s like a village of straw men.  Stop going around telling everyone they&#x27;re fucking idiots.  We&#x27;d probably agree 90% of the time, dealing down the intensity just makes for a better discussion.<p>They &quot;already owned a tool for audio&#x2F;video quality inspection, but we never intended nor designed it to run at high scale (our target was to monitor thousands of concurrent streams and grow that number over time)&quot;<p>Good principle #1, reuse. They launched faster than starting from scratch.  They changed direction and modified some components, and then published, against what marketing would probably have wanted. Real problems are when you paint yourself into a corner and can&#x27;t fix it. They fixed it.<p>Amazon, keep telling us what lessons you&#x27;ve learned because it helps the whole industry.<p>(Edited to remove some of my own incendiary annoyance.)</div><br/></div></div></div></div></div></div><div id="35857010" class="c"><input type="checkbox" id="c-35857010" checked=""/><div class="controls bullet"><span class="by">siliconc0w</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35855638">prev</a><span>|</span><a href="#35853703">next</a><span>|</span><label class="collapse" for="c-35857010">[-]</label><label class="expand" for="c-35857010">[1 more]</label></div><br/><div class="children"><div class="content">+1 that k8s really isn&#x27;t that much more challenging configuration syntax than most &#x27;serverless&#x27; solutions (which is a bit different than FaaS as in the article).   The difficulty with k8s is (w&#x2F; a managed solution) generally the cost of running the control plane though most IaaS will &#x27;give&#x27; you a zonal one for free to encourage more spend because inevitably you don&#x27;t just need one, but ideally one per environment per app&#x2F;product maybe even per engineer if you want eng to be able to stand up their own &#x27;full&#x27; environments of beefier apps w&#x2F; lots of components and dependencies.</div><br/></div></div><div id="35853703" class="c"><input type="checkbox" id="c-35853703" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35857010">prev</a><span>|</span><a href="#35853639">next</a><span>|</span><label class="collapse" for="c-35853703">[-]</label><label class="expand" for="c-35853703">[2 more]</label></div><br/><div class="children"><div class="content">Hearing K8s described as &quot;boring&quot; made me chuckle.</div><br/><div id="35854025" class="c"><input type="checkbox" id="c-35854025" checked=""/><div class="controls bullet"><span class="by">NickBusey</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853703">parent</a><span>|</span><a href="#35853639">next</a><span>|</span><label class="collapse" for="c-35854025">[-]</label><label class="expand" for="c-35854025">[1 more]</label></div><br/><div class="children"><div class="content">It’s just yaml. It’s pretty boring.</div><br/></div></div></div></div><div id="35853639" class="c"><input type="checkbox" id="c-35853639" checked=""/><div class="controls bullet"><span class="by">erulabs</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853703">prev</a><span>|</span><a href="#35853807">next</a><span>|</span><label class="collapse" for="c-35853639">[-]</label><label class="expand" for="c-35853639">[6 more]</label></div><br/><div class="children"><div class="content">The amount of complexity created in the desperate attempt to avoid learning k8s APIs has at this point, dramatically out complexified k8s itself.</div><br/><div id="35853968" class="c"><input type="checkbox" id="c-35853968" checked=""/><div class="controls bullet"><span class="by">Arbortheus</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853639">parent</a><span>|</span><a href="#35853834">next</a><span>|</span><label class="collapse" for="c-35853968">[-]</label><label class="expand" for="c-35853968">[3 more]</label></div><br/><div class="children"><div class="content">I see the anti-K8S sentiment so much on hackernews. Sure, there’s a time and a place for K8S, but I see a lot of point-blank objection to it for often weak reasons.</div><br/><div id="35854012" class="c"><input type="checkbox" id="c-35854012" checked=""/><div class="controls bullet"><span class="by">nova22033</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853968">parent</a><span>|</span><a href="#35853834">next</a><span>|</span><label class="collapse" for="c-35854012">[-]</label><label class="expand" for="c-35854012">[2 more]</label></div><br/><div class="children"><div class="content"><i>It&#x27;s bloated</i><p>Often this translate to &quot;It has features I PERSONALLY don&#x27;t need or understand&quot;</div><br/><div id="35854082" class="c"><input type="checkbox" id="c-35854082" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854012">parent</a><span>|</span><a href="#35853834">next</a><span>|</span><label class="collapse" for="c-35854082">[-]</label><label class="expand" for="c-35854082">[1 more]</label></div><br/><div class="children"><div class="content">I generally find people that don&#x27;t like k8s don&#x27;t understand it or more commonly even the reasons why it exists.<p>If your job hasn&#x27;t been to write Cloudformation&#x2F;Terraform&#x2F;Pulumi&#x2F;Chef&#x2F;Puppet&#x2F;Salt&#x2F;Ansible&#x2F;Capistrano&#x2F;Packer for a living, you might not appreciate it.<p>As someone that has been around the block I think k8s is the best thing since sliced bread.</div><br/></div></div></div></div></div></div><div id="35853834" class="c"><input type="checkbox" id="c-35853834" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853639">parent</a><span>|</span><a href="#35853968">prev</a><span>|</span><a href="#35853807">next</a><span>|</span><label class="collapse" for="c-35853834">[-]</label><label class="expand" for="c-35853834">[2 more]</label></div><br/><div class="children"><div class="content">The quadratic function that represents the hand waving away of k8s complexities causes a stack overflow exception.</div><br/></div></div></div></div><div id="35853807" class="c"><input type="checkbox" id="c-35853807" checked=""/><div class="controls bullet"><span class="by">waboremo</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853639">prev</a><span>|</span><a href="#35856621">next</a><span>|</span><label class="collapse" for="c-35853807">[-]</label><label class="expand" for="c-35853807">[87 more]</label></div><br/><div class="children"><div class="content">Actually your comment is a great demonstration of poor engineering leadership. You&#x27;ve already decided on an outcome and are shifting the narrative to adhere to this outcome.<p>The labelling of JVM + K8 as boring, to posture why it&#x27;s automatically superior to &quot;serverless integration crap&quot; is exactly the sort of thing poor engineering leadership does to avoid having the sort of difficult conversations necessary. There&#x27;s no metrics involved, no studies, no prototypes, no financial assessments, none of that it&#x27;s purely based on emotion.<p>You can envision the same exact thing happening (but to the preference of serverless) on the Prime Video team.</div><br/><div id="35853842" class="c"><input type="checkbox" id="c-35853842" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35854246">next</a><span>|</span><label class="collapse" for="c-35853842">[-]</label><label class="expand" for="c-35853842">[64 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not emotion. I make money from porting people off of poor technical choices onto solid ones. It comes from experience working with all these various systems.<p>I have used (at large scale) GAE, Google Cloud Functions and Lambda, before that I also used all the previous &quot;serverless-like&quot; things including Beanstalk (anyone else even remember that?), Heroku and bunch of other PaaS things for various stuff.<p>It&#x27;s all come and gone. To me serverless is just the latest in a long line of things that I get paid to replace with things that actually solve the problem and doesn&#x27;t turn into a ball of spaghetti that no one is able to modify anymore.</div><br/><div id="35854839" class="c"><input type="checkbox" id="c-35854839" checked=""/><div class="controls bullet"><span class="by">grogenaut</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35855404">next</a><span>|</span><label class="collapse" for="c-35854839">[-]</label><label class="expand" for="c-35854839">[1 more]</label></div><br/><div class="children"><div class="content">I remember beanstalk. We used it for years at twitch. We got a shit ton of mileage out of it. It&#x27;s easy to talk shit about the problems of the old tech, and beanstalk has a lot of issues. But it also let us build a ton of stuff much easier than the alternatives.<p>This cycle will forever be this way. You only think that the new stuff is the best if this is your first rodeo. If it&#x27;s not, it&#x27;s just the right or wrong tradeoff for the point in time you are at.</div><br/></div></div><div id="35855404" class="c"><input type="checkbox" id="c-35855404" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35854839">prev</a><span>|</span><a href="#35856137">next</a><span>|</span><label class="collapse" for="c-35855404">[-]</label><label class="expand" for="c-35855404">[18 more]</label></div><br/><div class="children"><div class="content">&gt;  I make money from porting people off of poor technical choices onto solid ones<p>So it was successful enough for long enough to get them to the point where someone cared about optimizing and paid you to come in, right?  I don&#x27;t see how you are disproving the article&#x27;s argument that this is a great way to prototype ideas or get a first version of the product out there.</div><br/><div id="35855512" class="c"><input type="checkbox" id="c-35855512" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855404">parent</a><span>|</span><a href="#35855508">next</a><span>|</span><label class="collapse" for="c-35855512">[-]</label><label class="expand" for="c-35855512">[8 more]</label></div><br/><div class="children"><div class="content">My opinion from doing both these ports and greenfield is this:<p>None of the tools that say they help you move faster matter after the first 3 months.<p>It&#x27;s true they take less code and pieces to get started with. No k8s manifests, no Dockerfiles (usually) but if you don&#x27;t hate your future self you will still use IaC to create the API Gateways&#x2F;function contexts&#x2F;DynamoDB&#x2F;whatever, so you will still be dicking around with at least one of Terraform&#x2F;Pulumi&#x2F;similar.<p>The thing is the setup cost of a traditional lang + pg + k8s setup amortised over 3 months is essentially nothing and yet you have a setup that will last you effectively forever.<p>If your company wasn&#x27;t going to die because of being a few days slower in that initial 3 month period you have came out ahead. You have a forever architecture and you avoided a whole bunch of costs and technical debt in the process.<p>Maybe the calculus is different if you don&#x27;t have the same depth of infrastructure experience I do but for me it&#x27;s obvious this is a faster and better way of delivering a prototype that gives it proper room to grow into production software.</div><br/><div id="35855584" class="c"><input type="checkbox" id="c-35855584" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855512">parent</a><span>|</span><a href="#35855785">next</a><span>|</span><label class="collapse" for="c-35855584">[-]</label><label class="expand" for="c-35855584">[6 more]</label></div><br/><div class="children"><div class="content">I am more of a generalist than you are but I have worked with a Kubernetes setup and I&#x27;ve also worked with going all-in on Lambda and other AWS services managed by CDK and I don&#x27;t share your intuition.  Besides the initial setup, the former also has other ongoing maintenance things that are harder to deal with.  It does give you more flexibility if whatever you&#x27;re doing isn&#x27;t a good fit for those tools, though (though obviously nothing stops you from provisioning EC2 instances or whatever through other tools).</div><br/><div id="35857505" class="c"><input type="checkbox" id="c-35857505" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855584">parent</a><span>|</span><a href="#35855785">next</a><span>|</span><label class="collapse" for="c-35857505">[-]</label><label class="expand" for="c-35857505">[5 more]</label></div><br/><div class="children"><div class="content">I have a hard time imagining anyone doing anything non trivial with CDK and walking away happy.</div><br/><div id="35857882" class="c"><input type="checkbox" id="c-35857882" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857505">parent</a><span>|</span><a href="#35855785">next</a><span>|</span><label class="collapse" for="c-35857882">[-]</label><label class="expand" for="c-35857882">[4 more]</label></div><br/><div class="children"><div class="content">Why? Do you have something specific to say about why you dislike it? I think it’s pretty good.</div><br/><div id="35858055" class="c"><input type="checkbox" id="c-35858055" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857882">parent</a><span>|</span><a href="#35857990">next</a><span>|</span><label class="collapse" for="c-35858055">[-]</label><label class="expand" for="c-35858055">[2 more]</label></div><br/><div class="children"><div class="content">Oddly I&#x27;m not able to reply directly to re-thc, so I hope you don&#x27;t mind me commenting here that - I suspect that they&#x27;re not deploying with a CDK-defined Code Pipeline (starter article[0], in-depth example[1]), which makes cross account&#x2F;region deployments so ludicrously smooth and simple that it often has newbies refuse to believe that it can have worked _that_ easily.<p>It is true that _some_ resources don&#x27;t have L2 constructs, but there&#x27;s pretty damn good coverage of the most popular services - and, even when you have to drop back to L1, that&#x27;s still better than hand-written CFN templates or abandoning IaC entirely!<p>[0] <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;cdk&#x2F;v2&#x2F;guide&#x2F;cdk_pipeline.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;cdk&#x2F;v2&#x2F;guide&#x2F;cdk_pipeline.html</a><p>[1] <a href="https:&#x2F;&#x2F;pipelines.devops.aws.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pipelines.devops.aws.dev&#x2F;</a></div><br/><div id="35858067" class="c"><input type="checkbox" id="c-35858067" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35858055">parent</a><span>|</span><a href="#35857990">next</a><span>|</span><label class="collapse" for="c-35858067">[-]</label><label class="expand" for="c-35858067">[1 more]</label></div><br/><div class="children"><div class="content">If the reply link doesn&#x27;t appear you can still reply by clicking on the timestamp.  I don&#x27;t know why it works that way.</div><br/></div></div></div></div><div id="35857990" class="c"><input type="checkbox" id="c-35857990" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857882">parent</a><span>|</span><a href="#35858055">prev</a><span>|</span><a href="#35855785">next</a><span>|</span><label class="collapse" for="c-35857990">[-]</label><label class="expand" for="c-35857990">[1 more]</label></div><br/><div class="children"><div class="content">Cross region&#x2F;account usage is terrible. It&#x27;s also 1&#x2F;2 baked. Some things have higher level constructs but some don&#x27;t. Lots of things have to be &quot;escaped&quot; to get it to work.<p>If you&#x27;re just on a single region&#x2F;account then yes it&#x27;s better than alternatives.</div><br/></div></div></div></div></div></div></div></div><div id="35855785" class="c"><input type="checkbox" id="c-35855785" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855512">parent</a><span>|</span><a href="#35855584">prev</a><span>|</span><a href="#35855508">next</a><span>|</span><label class="collapse" for="c-35855785">[-]</label><label class="expand" for="c-35855785">[1 more]</label></div><br/><div class="children"><div class="content">The IAC piece is the same across both. Except with k8s you’re managing infrastructure across cloud, k8s, potentially frameworks like helm, etc.<p>And on a large team there’s very little likelihood that everyone understands the different configuration layers. There’s very little likelihood that people understand the scope that changes to configuration might touch either. But when you work with CDK, it’s one tool to understand.<p>Faster and better way to grow into production ignores team level problems and team level constraints. At 10, 20, 100 engineers this is fine. But when you have dozens of teams you’re almost certainly losing efficiency by being prescriptive.<p>I find that this type of pedantry really surrounds the k8s ecosystem. I think k8s is an enterprise scale tool that has uses in enterprise applications. But the idea of suggesting it to everyone is lunacy</div><br/></div></div></div></div><div id="35855508" class="c"><input type="checkbox" id="c-35855508" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855404">parent</a><span>|</span><a href="#35855512">prev</a><span>|</span><a href="#35857436">next</a><span>|</span><label class="collapse" for="c-35855508">[-]</label><label class="expand" for="c-35855508">[7 more]</label></div><br/><div class="children"><div class="content">&quot;So it was successful enough for long enough &quot; Which doesn&#x27;t necessarily make it a good choice at any point. It just says it wasn&#x27;t enough of a bad technical choice to make the product sink.</div><br/><div id="35855557" class="c"><input type="checkbox" id="c-35855557" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855508">parent</a><span>|</span><a href="#35857436">next</a><span>|</span><label class="collapse" for="c-35855557">[-]</label><label class="expand" for="c-35855557">[6 more]</label></div><br/><div class="children"><div class="content">OK, sure, it&#x27;s not ironclad proof that it was the right decision.  But it&#x27;s certainly not proof it was the wrong decision when it was made.</div><br/><div id="35855695" class="c"><input type="checkbox" id="c-35855695" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855557">parent</a><span>|</span><a href="#35857436">next</a><span>|</span><label class="collapse" for="c-35855695">[-]</label><label class="expand" for="c-35855695">[5 more]</label></div><br/><div class="children"><div class="content">&quot;It works and makes money&quot; is at the root of so much shoddy workmanship in software I think you&#x27;re making a different point than what you&#x27;re trying to.</div><br/><div id="35857894" class="c"><input type="checkbox" id="c-35857894" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855695">parent</a><span>|</span><a href="#35858004">next</a><span>|</span><label class="collapse" for="c-35857894">[-]</label><label class="expand" for="c-35857894">[3 more]</label></div><br/><div class="children"><div class="content">The argument of TFA is that starting with serverless and evolving away from it bit by bit as it is revealed to be necessary is a sound strategy most of the time. Whatever you may think of that argument, “I have been hired to optimize projects built using serverless and get them off of it” is not a rebuttal.</div><br/><div id="35858700" class="c"><input type="checkbox" id="c-35858700" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857894">parent</a><span>|</span><a href="#35858004">next</a><span>|</span><label class="collapse" for="c-35858700">[-]</label><label class="expand" for="c-35858700">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for rehashing how this thread got started for me?</div><br/><div id="35858926" class="c"><input type="checkbox" id="c-35858926" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35858700">parent</a><span>|</span><a href="#35858004">next</a><span>|</span><label class="collapse" for="c-35858926">[-]</label><label class="expand" for="c-35858926">[1 more]</label></div><br/><div class="children"><div class="content">What is this different point you think I’m making then?</div><br/></div></div></div></div></div></div><div id="35858004" class="c"><input type="checkbox" id="c-35858004" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855695">parent</a><span>|</span><a href="#35857894">prev</a><span>|</span><a href="#35857436">next</a><span>|</span><label class="collapse" for="c-35858004">[-]</label><label class="expand" for="c-35858004">[1 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with software. Same applies for things like buildings where the developers get away with so many defects even after people pay huge $$$ for it.</div><br/></div></div></div></div></div></div></div></div><div id="35857436" class="c"><input type="checkbox" id="c-35857436" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855404">parent</a><span>|</span><a href="#35855508">prev</a><span>|</span><a href="#35856137">next</a><span>|</span><label class="collapse" for="c-35857436">[-]</label><label class="expand" for="c-35857436">[2 more]</label></div><br/><div class="children"><div class="content">If you consider building your service that should take 3000 man hours to build in 300k instead, overspending by a factor if a 100, and then still succeeding, then yeah, you could consider that a success.<p>I’d consider it a massive, massive waste.</div><br/><div id="35857870" class="c"><input type="checkbox" id="c-35857870" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857436">parent</a><span>|</span><a href="#35856137">next</a><span>|</span><label class="collapse" for="c-35857870">[-]</label><label class="expand" for="c-35857870">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea what you’re arguing with this one.</div><br/></div></div></div></div></div></div><div id="35856137" class="c"><input type="checkbox" id="c-35856137" checked=""/><div class="controls bullet"><span class="by">unusualmonkey</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35855404">prev</a><span>|</span><a href="#35854312">next</a><span>|</span><label class="collapse" for="c-35856137">[-]</label><label class="expand" for="c-35856137">[4 more]</label></div><br/><div class="children"><div class="content">Bit of survivorship bias there! No-one is going to hire you to port off of serverless, if they&#x27;re happy with it.<p>Ergo you only see cases where it isn&#x27;t working well.</div><br/><div id="35856147" class="c"><input type="checkbox" id="c-35856147" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856137">parent</a><span>|</span><a href="#35854312">next</a><span>|</span><label class="collapse" for="c-35856147">[-]</label><label class="expand" for="c-35856147">[3 more]</label></div><br/><div class="children"><div class="content">Yeah that is fair. There is probably serverless chugging away fine in lots of places.<p>Doesn&#x27;t make it better than alternatives but still a valid point.</div><br/><div id="35856369" class="c"><input type="checkbox" id="c-35856369" checked=""/><div class="controls bullet"><span class="by">unusualmonkey</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856147">parent</a><span>|</span><a href="#35858474">next</a><span>|</span><label class="collapse" for="c-35856369">[-]</label><label class="expand" for="c-35856369">[1 more]</label></div><br/><div class="children"><div class="content">I use serverless successfully - handing tens of millions of annual revenue.<p>We do this in a handful of small services, none of which gets much traffic. The alternatives (e.g. app-engine, container in vm, or k8s) all require more infrastructure, would cost more (no scaling to zero), and are overall less suited for the kinds of problems we expect to see.</div><br/></div></div><div id="35858474" class="c"><input type="checkbox" id="c-35858474" checked=""/><div class="controls bullet"><span class="by">slrainka</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856147">parent</a><span>|</span><a href="#35856369">prev</a><span>|</span><a href="#35854312">next</a><span>|</span><label class="collapse" for="c-35858474">[-]</label><label class="expand" for="c-35858474">[1 more]</label></div><br/><div class="children"><div class="content">I too have a small team that built a greenfield application that generates about $100M annually for a large hotel chain. Serverless allowed us to get to market fast and everyone in the team is a feature developer — 0 infra folks. I think that’s the biggest value we have been able to derive from this compared all the other internal App teams who struggle with release cadences, experimentation and TTV.<p>But I fully acknowledge this is not the ideal and optimal setup and we are paying more to AWS on the OpEx. However, we have gone 3 years without any downtime at full speed, and the fact that we were able to unlock net new revenue very quickly has made all project costs and OpEx very minuscule.<p>But I think once the application boundaries stabilize and we are able to take a breather from full on feature development, hope to migrate some of this to simpler containerized infrastructure.<p>To make this transition easier, we use Serverless-framework and decouple the app component architecture from deployment architecture, so developers don’t worry whether this is getting deployed to a lambda or container.</div><br/></div></div></div></div></div></div><div id="35854312" class="c"><input type="checkbox" id="c-35854312" checked=""/><div class="controls bullet"><span class="by">babyshake</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35856137">prev</a><span>|</span><a href="#35855279">next</a><span>|</span><label class="collapse" for="c-35854312">[-]</label><label class="expand" for="c-35854312">[20 more]</label></div><br/><div class="children"><div class="content">One potential reason to advocate for serverless architecture is it is relatively stateless and event-driven and therefore modular and easy to reason about.<p>Can you be more specific about how serverless tends to turn into a ball of spaghetti? It is simply because the lack of state becomes more of a bug than a feature?</div><br/><div id="35854447" class="c"><input type="checkbox" id="c-35854447" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854312">parent</a><span>|</span><a href="#35855106">next</a><span>|</span><label class="collapse" for="c-35854447">[-]</label><label class="expand" for="c-35854447">[9 more]</label></div><br/><div class="children"><div class="content">State can be part of it. For example it can be way simpler to use a in-memory cache than a network attached cache and by doing so you save yourself a dependency, a potential network request that can fail, etc.<p>Also for event processing consider the case you need to process events in order for instance. That is a ton easier with stateful consumers, batching etc which while possible in serverless is usually more difficult&#x2F;off the beaten path.<p>However by spaghetti I&#x27;m more referring to the architecture of your application being turned into networked components, i.e a distributed system.<p>It&#x27;s pretty much accepted fact now that distributed systems are by far the most challenging area of both computer science and software engineering.<p>Serverless doesn&#x27;t technically -mandate- this, you could put all your code in a giant function. However it strongly incentivises you not to. a) generally it&#x27;s deployment times and cold start issues get worse with function size and b) it pushes you to adopt other &quot;building blocks&quot; which are themselves network attached.<p>Essentially it leads people into a massively distributed micro-service architecture right out of the gate. For most applications this is definitely the wrong choice even if you have the folks on staff that specialise in distributed systems, usually those folk are the last to advocate for anything distributed ironically.<p>Getting into the weeds as for why this is hard and all the problems you can run into is probably a bit much for a single HN comment but if you really are curious I suggest reading Leslie Lamport and John Ousterhout. Both have covered the problem space in depth with foundational papers, Leslies &quot;Time, Clocks, and the Ordering of Events in a Distributed System&quot; in particular is foundational.</div><br/><div id="35856020" class="c"><input type="checkbox" id="c-35856020" checked=""/><div class="controls bullet"><span class="by">scarface74</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854447">parent</a><span>|</span><a href="#35855569">next</a><span>|</span><label class="collapse" for="c-35856020">[-]</label><label class="expand" for="c-35856020">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Also for event processing consider the case you need to process events in order for instance. That is a ton easier with stateful consumers, batching etc which while possible in serverless is usually more difficult&#x2F;off the beaten path<p>By off the beaten path you mean a few lines of yaml to configure a FIFO SQS queue and have it trigger a Lambda?</div><br/><div id="35857151" class="c"><input type="checkbox" id="c-35857151" checked=""/><div class="controls bullet"><span class="by">empthought</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856020">parent</a><span>|</span><a href="#35855569">next</a><span>|</span><label class="collapse" for="c-35857151">[-]</label><label class="expand" for="c-35857151">[1 more]</label></div><br/><div class="children"><div class="content">I notice the GP hasn&#x27;t responded to this. If Lambdas couldn&#x27;t be a target for SNS or SQS, I wouldn&#x27;t bother with them either. But that has been a core architectural pattern since 2018.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;aws&#x2F;aws-lambda-adds-amazon-simple-queue-service-to-supported-event-sources&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;aws&#x2F;aws-lambda-adds-amazon-simp...</a></div><br/></div></div></div></div><div id="35855569" class="c"><input type="checkbox" id="c-35855569" checked=""/><div class="controls bullet"><span class="by">eternalban</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854447">parent</a><span>|</span><a href="#35856020">prev</a><span>|</span><a href="#35855106">next</a><span>|</span><label class="collapse" for="c-35855569">[-]</label><label class="expand" for="c-35855569">[6 more]</label></div><br/><div class="children"><div class="content">(quite impressed by the sheer number of comments you have made in this thread, btw)<p>&gt; For example it can be way simpler to use a in-memory cache than a network attached cache and by doing so you save yourself a dependency, a potential network request that can fail, etc.<p>Elsewhere you decided against using cloudflare&#x27;s kv because it was a poor fit for &quot;cache invalidation&quot; -- &quot;way simpler&quot;? -- and then of course turns out you really don&#x27;t know if it&#x27;s a bad fit.<p>&gt; by spaghetti I&#x27;m more referring to the architecture of your application being turned into networked components, i.e a distributed system.<p>That is a novel definition of &quot;spagetti&quot;. It&#x27;s a pejorative term in software sense. Why?<p>&gt; It&#x27;s pretty much accepted fact now that distributed systems are by far the most challenging area of both computer science and software engineering.<p>Ahem. So it caching and cache invalidation. But that didn&#x27;t stop you, so exactly how is this line you seem to draw with such vocal authority regarding &quot;bad hard&quot;, &quot;good hard&quot; <i>informed technically</i>?</div><br/><div id="35855769" class="c"><input type="checkbox" id="c-35855769" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855569">parent</a><span>|</span><a href="#35856189">next</a><span>|</span><label class="collapse" for="c-35855769">[-]</label><label class="expand" for="c-35855769">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That is a novel definition of &quot;spagetti&quot;. It&#x27;s a pejorative term in software sense. Why?<p>I don&#x27;t necessarily agree with everything OP is saying, and I certainly don&#x27;t speak for them, but I completely understand what they mean by a big ball of microservice spaghetti. The spaghetti is distributed across a massive literal network of dependencies instead of being distributed off a giant graph of object dependencies, or goto statements or something. The spaghetti is real and just as messy in the microservice world as the monolith world. I should know, we inherited a massive one.<p>But this shouldn&#x27;t be too much of a revelation since there is no silver bullet in taming software architecture. Architecting software is very subjective, and more often than not we make the wrong decisions and have to untangle the mistakes further down the road.</div><br/><div id="35856023" class="c"><input type="checkbox" id="c-35856023" checked=""/><div class="controls bullet"><span class="by">eternalban</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855769">parent</a><span>|</span><a href="#35856189">next</a><span>|</span><label class="collapse" for="c-35856023">[-]</label><label class="expand" for="c-35856023">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I completely understand what they mean by a big ball of microservice spaghetti<p>Sure, I understand that too, but that&#x27;s not what was said. Here it is again:<p>&gt; by spaghetti I&#x27;m more referring to the architecture of your application being turned into networked components, i.e a distributed system.</div><br/><div id="35857558" class="c"><input type="checkbox" id="c-35857558" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856023">parent</a><span>|</span><a href="#35856189">next</a><span>|</span><label class="collapse" for="c-35857558">[-]</label><label class="expand" for="c-35857558">[1 more]</label></div><br/><div class="children"><div class="content">How is that not what was said. Your application is going to be spaghetti anyway, networked spaghetti is orders of magnitude worse.<p>I should know, I have a ball of networked spaghetti.</div><br/></div></div></div></div></div></div><div id="35856189" class="c"><input type="checkbox" id="c-35856189" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855569">parent</a><span>|</span><a href="#35855769">prev</a><span>|</span><a href="#35855106">next</a><span>|</span><label class="collapse" for="c-35856189">[-]</label><label class="expand" for="c-35856189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Elsewhere you decided against using cloudflare&#x27;s kv because it was a poor fit for &quot;cache invalidation&quot; -- &quot;way simpler&quot;? -- and then of course turns out you really don&#x27;t know if it&#x27;s a bad fit.<p>I evaluated it at the time. I don&#x27;t have the context loaded to remember exactly why it didn&#x27;t work for my use-case but I&#x27;m going to look again because CFs platform moves pretty fast and perhaps it could be simpler than what we are currently doing.<p>&gt; That is a novel definition of &quot;spagetti&quot;. It&#x27;s a pejorative term in software sense. Why?<p>Elsewhere it&#x27;s been coined Lambda Pinball, perhaps you find that a more pleasing description?<p>&gt; Ahem. So it caching and cache invalidation. But that didn&#x27;t stop you, so exactly how is this line you seem to draw with such vocal authority regarding &quot;bad hard&quot;, &quot;good hard&quot; informed technically?<p>Yes, both of which are generally necessary in distributed systems. i.e not only is it a hard problem in and of itself it requires solving sub-problems which are also some of the hardest problems.<p>I think you may have made my points for me.</div><br/><div id="35858036" class="c"><input type="checkbox" id="c-35858036" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856189">parent</a><span>|</span><a href="#35855106">next</a><span>|</span><label class="collapse" for="c-35858036">[-]</label><label class="expand" for="c-35858036">[1 more]</label></div><br/><div class="children"><div class="content">I think in general you’re right on the money and have been throughout your comments here. Lambda pinball is a great term as well. I agree that serverless incentivizes a “nanoservice” approach that flies in the face of patterns like classes&#x2F;factories or DDD, since everything is atomic you lose the concept of a service or domain boundary and everything can get muddled as hell.</div><br/></div></div></div></div></div></div></div></div><div id="35855106" class="c"><input type="checkbox" id="c-35855106" checked=""/><div class="controls bullet"><span class="by">xvinci</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854312">parent</a><span>|</span><a href="#35854447">prev</a><span>|</span><a href="#35854841">next</a><span>|</span><label class="collapse" for="c-35855106">[-]</label><label class="expand" for="c-35855106">[2 more]</label></div><br/><div class="children"><div class="content">Statelessnes is really a prerequisite for proper horizontal scaling (with small exceptions), so best practices for e.g. spring boot web applications will lead to a stateless architecture as well. Same goes for event-driven -&gt; amqp, mqtt (and jms for java) plug easily into most modern web-frameworks, you can be as event-driven as you want to (which in my experience is an overhead to plain http &#x2F; rest which needs to be justified)</div><br/><div id="35855855" class="c"><input type="checkbox" id="c-35855855" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855106">parent</a><span>|</span><a href="#35854841">next</a><span>|</span><label class="collapse" for="c-35855855">[-]</label><label class="expand" for="c-35855855">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Statelessnes is really a prerequisite for proper horizontal scaling<p>I could understand making this claim w.r.t. Idempotence. Claiming statelessnes as a requirement strikes me as non-trivial enough to require some evidence or a citation thereto.</div><br/></div></div></div></div><div id="35854841" class="c"><input type="checkbox" id="c-35854841" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854312">parent</a><span>|</span><a href="#35855106">prev</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35854841">[-]</label><label class="expand" for="c-35854841">[7 more]</label></div><br/><div class="children"><div class="content">Modular, maybe (though sometimes it&#x27;s just introducing a network hop in between dependencies). Event-driven being easy to reason about? No way, never.</div><br/><div id="35855389" class="c"><input type="checkbox" id="c-35855389" checked=""/><div class="controls bullet"><span class="by">erikpukinskis</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854841">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35855389">[-]</label><label class="expand" for="c-35855389">[6 more]</label></div><br/><div class="children"><div class="content">Yah, I was confused by that too. Out of:<p>1) event-driven<p>2) procedural<p>3) functional<p>4) inheritance<p>I would say event-driven is tied for last as the hardest to reason about.</div><br/><div id="35855425" class="c"><input type="checkbox" id="c-35855425" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855389">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35855425">[-]</label><label class="expand" for="c-35855425">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say it comes down to your choice of events.  I also find these systems very easy to reason about.</div><br/><div id="35855767" class="c"><input type="checkbox" id="c-35855767" checked=""/><div class="controls bullet"><span class="by">tharkun__</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855425">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35855767">[-]</label><label class="expand" for="c-35855767">[4 more]</label></div><br/><div class="children"><div class="content">Instead of your IDE very easily telling you on click the callers or callees of things you&#x27;d rather have events where you have no idea who might be processing or sending a particular event in your system of hundreds of microservices?<p>Yeah, totally easy!</div><br/><div id="35855995" class="c"><input type="checkbox" id="c-35855995" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855767">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35855995">[-]</label><label class="expand" for="c-35855995">[3 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re conflating problems here. IDLs allow interface definitions for interactions that cross compute and administrative boundaries, and event-driven architectures do not require compute distribution (Erlang&#x2F;beam).<p>Different people have different strengths and anxieties. The suggestion that, with some regularity, the lack of (local) ambiguity of event message arrival may be of higher leverage relative to complexity than increasing the surface of an invokable interface does not seem beyond the pale.<p>Ultimately relinquishing a total temporal ordering is going to be painful regardless of whether it&#x27;s local or distributed.</div><br/><div id="35856768" class="c"><input type="checkbox" id="c-35856768" checked=""/><div class="controls bullet"><span class="by">tharkun__</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855995">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35856768">[-]</label><label class="expand" for="c-35856768">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair enough if you use something that actually does this and also keeps track of users of your event. Not saying it is unsolvable.<p>What I&#x27;ve seen though is that in many cases it is unsolved for and it&#x27;s very hard to reason about &quot;if I remove this event because it&#x27;s 5 versions too old already and I don&#x27;t want to keep this backwards compatibility layer, will something &quot;at the other end of our system I never even interact with&quot; puke?<p>Granted some orgs are so big that it makes sense to solve for these large landscapes of services with backwards compatibility ad absurdum in order to allow anything to get done (been at that bank, done that). But reason about the entire system it does not make easier.<p>At many smaller orgs these services were also not built because of organizational issues that needed to be solved but because &quot;everyone does this now&quot; and there&#x27;s no proper registry of properly defined interfaces and trying to find out if a change you were going to make is going to take you forever because you do need to version something or if you can just change things as needed is way harder than it&#x27;s supposed to be at that size org.</div><br/><div id="35858074" class="c"><input type="checkbox" id="c-35858074" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856768">parent</a><span>|</span><a href="#35855705">next</a><span>|</span><label class="collapse" for="c-35858074">[-]</label><label class="expand" for="c-35858074">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s freeing you to reason about only one step rather than the entire system at all times.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35855705" class="c"><input type="checkbox" id="c-35855705" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854312">parent</a><span>|</span><a href="#35854841">prev</a><span>|</span><a href="#35855279">next</a><span>|</span><label class="collapse" for="c-35855705">[-]</label><label class="expand" for="c-35855705">[1 more]</label></div><br/><div class="children"><div class="content">&gt;stateless and event-driven and therefore modular<p>Non-sequitur</div><br/></div></div></div></div><div id="35855279" class="c"><input type="checkbox" id="c-35855279" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35854312">prev</a><span>|</span><a href="#35856771">next</a><span>|</span><label class="collapse" for="c-35855279">[-]</label><label class="expand" for="c-35855279">[5 more]</label></div><br/><div class="children"><div class="content">As a one man shop, I made a decision years ago to try Beanstalk for a particular app backend &#x2F; API. It&#x27;s the only &quot;serverless&quot; deployment I&#x27;ve done. It still works fine for that purpose, and it&#x27;s less trouble than manually deploying to multiple servers. Forced updates are an occasional headache but at least they&#x27;re all in one place. The code does a lot of serverside computation for a lot of client connections, so that part needs to scale, and since there&#x27;s relatively little database stuff it just connects to a single RDS instance.<p>I can&#x27;t think of any other code of mine for which I&#x27;d use Beanstalk or something similar now, but it doesn&#x27;t hurt to evaluate each project independently and pick the right tools for the job.</div><br/><div id="35855354" class="c"><input type="checkbox" id="c-35855354" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855279">parent</a><span>|</span><a href="#35856771">next</a><span>|</span><label class="collapse" for="c-35855354">[-]</label><label class="expand" for="c-35855354">[4 more]</label></div><br/><div class="children"><div class="content">Yeah Beanstalk was pretty simple and decent for it&#x27;s time.<p>I told anyone that wasn&#x27;t comfortable with Cloudformation + Packer and wanted to be on AWS to use it during that era. At that time things were pretty binary, you used PaaS like Beanstalk or Heroku or you were off in the wild west where there was no standards at all. People were doing immutable AMIs on ASGs at the high end and then everything down to pet AWS instances w&#x2F;Capistrano or similar tools at the low end.<p>These days things are different, containers were a big deal. If you target k8s your application is pretty portable, can be run locally in something like kind to integration test the infra components, etc. You can take it to the 3 major clouds and bring most of your ingress, secrets, volume, etc configuration with you.<p>For me k8s has been a godsend because for once I haven&#x27;t had to learn a whole new set of idioms each new place that are all equivalent but different in their own special snowflake ways.</div><br/><div id="35855391" class="c"><input type="checkbox" id="c-35855391" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855354">parent</a><span>|</span><a href="#35857391">next</a><span>|</span><label class="collapse" for="c-35855391">[-]</label><label class="expand" for="c-35855391">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can take it to the 3 major clouds and bring most of your ingress, secrets, volume, etc configuration with you.<p>How often have you seen someone actually do this, and was it ever actually as &quot;easy&quot; as they imagined?  I feel like the advantages of &quot;going with the flow&quot; and using the stuff specific to the cloud environment you&#x27;re in are substantial and I feel like the efforts to avoid vendor lock-in start to look insufficient once you try to actually execute most of the time.</div><br/><div id="35855598" class="c"><input type="checkbox" id="c-35855598" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855391">parent</a><span>|</span><a href="#35857391">next</a><span>|</span><label class="collapse" for="c-35855598">[-]</label><label class="expand" for="c-35855598">[1 more]</label></div><br/><div class="children"><div class="content">I have done one massive AWS + kops &gt; GKE migration and several smaller migrations between AWS&#x2F;GCP&#x2F;Azure.<p>My experience leads me to believe the main problems stem from adopting IaaS&#x2F;PaaS specific stuff outside of k8s. If you aren&#x27;t doing that they are very portable and even if you are if you are using standard stuff like managed PostgreSQL&#x2F;MySQL then it&#x27;s still easy.<p>Where that breaks down is very vendor specific stuff, ala Spanner, queues&#x2F;logs like SQS&#x2F;PubSub etc. If you are using those and your architecture is tied to specific semantics of them you are in for a rough time.<p>I personally try to avoid any and all of those. Not for vendor lock-in reasons but because I greatly dislike not being able to run everything locally in exactly the same configuration it will be deployed in.<p>So I run PostgreSQL in k8s using Patroni, Kafka or Pulsar for queue&#x2F;log, etc and that is about it usually. I generally don&#x27;t need&#x2F;use other things. Maybe memcached if there is a good need for it over say Caffiene (in-memory cache).<p>This is awesome because it means it&#x27;s super super easy to have staging&#x2F;UAT environment or even preview environments on PRs and I can run integration tests against the whole stack E2E without spinning up&#x2F;manipulating cloud provider resources.</div><br/></div></div></div></div><div id="35857391" class="c"><input type="checkbox" id="c-35857391" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855354">parent</a><span>|</span><a href="#35855391">prev</a><span>|</span><a href="#35856771">next</a><span>|</span><label class="collapse" for="c-35857391">[-]</label><label class="expand" for="c-35857391">[1 more]</label></div><br/><div class="children"><div class="content">One nice thing about Beanstalk was that you didn&#x27;t (don&#x27;t) have to deal with containers on the toolchain at all. You basically zip the directory structure you&#x27;d normally serve and it just gets rolled out to all the instances. What I figured out early (the hard way) was that it wasn&#x27;t worth the time trying to screw around with leader instances that installed and ran cron jobs or anything like that. I just have an little separate ec2 instance that acts as a heartbeat for cleaning up the DB and buckets, rather than trying to get Beanstalk to do that consistently. I think it&#x27;s extremely well suited for <i>one layer</i>, the API; and counterintuitively I find it easier not to containerize that, because it gives me more flexibility to switch DBs or storage engines without touching the API, and without having to rework a container and redeploy the API itself.</div><br/></div></div></div></div></div></div><div id="35854746" class="c"><input type="checkbox" id="c-35854746" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35856771">prev</a><span>|</span><a href="#35856372">next</a><span>|</span><label class="collapse" for="c-35854746">[-]</label><label class="expand" for="c-35854746">[5 more]</label></div><br/><div class="children"><div class="content">Have you tried Cloudflare Workers? I work at Cloudflare but I’m genuinely curious what your feedback is on it as it does work quite differently from Lambda&#x2F;Cloudflare functions.</div><br/><div id="35854850" class="c"><input type="checkbox" id="c-35854850" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854746">parent</a><span>|</span><a href="#35856510">next</a><span>|</span><label class="collapse" for="c-35854850">[-]</label><label class="expand" for="c-35854850">[3 more]</label></div><br/><div class="children"><div class="content">Yes actually, currently using in production. I actually advocated for the move to Cloudflare and we ended up adopting workers because Cloudflare unfortunately has broken stale-while-revalidate support. So I built an implementation in Workers that abuses the Cache API to store our own TTLs and also our revalidating state. It works pretty well as we don&#x27;t end up with too many isolates per POP but it&#x27;s not perfect.<p>I didn&#x27;t end up using KV or other features yet, they weren&#x27;t a good fit for the cache revalidation implementation.<p>I think at-least for now I see it differently to FaaS services like Lambda&#x2F;CloudFunctions because I don&#x27;t intend to use it to implement application logic, rather just augment (or in this case shore up deficiencies) in the edge.<p>We may consider doing more stuff at the edge later for latency advantages.
This to me changes the calculus because Lamba (well vanilla, not Lamda@Edge) and CF solve my usual problems just with higher costs.
CloudFlare workers actually let me do things I couldn&#x27;t do.
So the cost is still just as high as FaaS platforms BUT importantly I actually get something for it, something I can&#x27;t otherwise have and important enough I am willing to pay the costs and overheads for.<p>Please advocate for real state-while-revalidate support internally! It would make tons of folks super happy.</div><br/><div id="35854966" class="c"><input type="checkbox" id="c-35854966" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854850">parent</a><span>|</span><a href="#35856510">next</a><span>|</span><label class="collapse" for="c-35854966">[-]</label><label class="expand" for="c-35854966">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. Since I TL KV currently I’m particularly interested in the ways it’s not working for you. We’re in the process of rolling out major changes here that might help you here so hit me up on the KV Discord or my username at cloudflare.com. I actually do have a meeting with the Cache team on Monday about something related and I’ll ask about it if you could message me what specifically is broke &#x2F; what the semantics you want are (I’m not intimately familiar with all the HTTP semantics).</div><br/><div id="35855157" class="c"><input type="checkbox" id="c-35855157" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854966">parent</a><span>|</span><a href="#35856510">next</a><span>|</span><label class="collapse" for="c-35855157">[-]</label><label class="expand" for="c-35855157">[1 more]</label></div><br/><div class="children"><div class="content">Shot you an email.<p>I must admit I didn&#x27;t go super deep on KV so I will come by discord at some point. I can share what we are doing and maybe it turns out KV is better suited.</div><br/></div></div></div></div></div></div><div id="35856510" class="c"><input type="checkbox" id="c-35856510" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854746">parent</a><span>|</span><a href="#35854850">prev</a><span>|</span><a href="#35856372">next</a><span>|</span><label class="collapse" for="c-35856510">[-]</label><label class="expand" for="c-35856510">[1 more]</label></div><br/><div class="children"><div class="content">Grrrt autocomplete. Lambda&#x2F;CloudFunctions.</div><br/></div></div></div></div><div id="35856372" class="c"><input type="checkbox" id="c-35856372" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35854746">prev</a><span>|</span><a href="#35854530">next</a><span>|</span><label class="collapse" for="c-35856372">[-]</label><label class="expand" for="c-35856372">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I make money from porting people off of poor technical choices<p>I make money by delivering features my customers care about.<p>We tried k8s, it was a ton of mental effort and time wasted when we could have been building more features. That particular bit of infrastructure is currently running in elastic beanstalk, where it&#x27;s cheap and I don&#x27;t have to think about it.</div><br/><div id="35856759" class="c"><input type="checkbox" id="c-35856759" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856372">parent</a><span>|</span><a href="#35854530">next</a><span>|</span><label class="collapse" for="c-35856759">[-]</label><label class="expand" for="c-35856759">[1 more]</label></div><br/><div class="children"><div class="content">I actually think Beanstalk&#x2F;Cloud Run&#x2F;friends are fine. I should have specified that Functions as a Service is the main mess I think people should be avoiding.<p>If Beanstalk + ELB + RDS or whatever is getting you by just fine then by all means. It&#x27;s super easy to port that to k8s whenever you end up needing what it does, which might be never if your money&#x2F;business scales well vs infra complexity.</div><br/></div></div></div></div><div id="35854530" class="c"><input type="checkbox" id="c-35854530" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35856372">prev</a><span>|</span><a href="#35854255">next</a><span>|</span><label class="collapse" for="c-35854530">[-]</label><label class="expand" for="c-35854530">[2 more]</label></div><br/><div class="children"><div class="content">Has GAE come and gone? Surely it’s still there, and capable of running the JVM? K8s seems like overkill for small teams which don’t already have experience</div><br/><div id="35854675" class="c"><input type="checkbox" id="c-35854675" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854530">parent</a><span>|</span><a href="#35854255">next</a><span>|</span><label class="collapse" for="c-35854675">[-]</label><label class="expand" for="c-35854675">[1 more]</label></div><br/><div class="children"><div class="content">GAE is actually still pretty good tbh. However it has it&#x27;s limitations and even though there are things like Cloud Run et al I still find GKE is the best option.</div><br/></div></div></div></div><div id="35854255" class="c"><input type="checkbox" id="c-35854255" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35854530">prev</a><span>|</span><a href="#35855480">next</a><span>|</span><label class="collapse" for="c-35854255">[-]</label><label class="expand" for="c-35854255">[2 more]</label></div><br/><div class="children"><div class="content">Seconded, just got done with one of these. Literally 1200 separate lambdas, step functions, hundreds of kinesis streams, and sqs topics plus a smattering of ecs fargate tasks for when invariably something takes longer than the max lambda time. And oh god all the stupid supporting infrastructure to build layers.<p>There primary app was Rails, you know what replaced all of it? Running the synchronous tasks on the app servers themselves, the async ones on Sidekiq and changing the max instances on the two ASGs.<p>The only downside has been not being able to meme about how we&#x27;re web scale anymore.</div><br/><div id="35854326" class="c"><input type="checkbox" id="c-35854326" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854255">parent</a><span>|</span><a href="#35855480">next</a><span>|</span><label class="collapse" for="c-35854326">[-]</label><label class="expand" for="c-35854326">[1 more]</label></div><br/><div class="children"><div class="content">Not being able to make jokes about how fast it is to serve requests from &#x2F;dev&#x2F;zero must be absolutely killing your team.<p>However, great job. Once they get to that scale of objects it becomes really hard to clean it up - especially if most the people that wrote them have already left the company for example.<p>Curious if you ended up also saving money in the process?</div><br/></div></div></div></div><div id="35855480" class="c"><input type="checkbox" id="c-35855480" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35854255">prev</a><span>|</span><a href="#35857325">next</a><span>|</span><label class="collapse" for="c-35855480">[-]</label><label class="expand" for="c-35855480">[1 more]</label></div><br/><div class="children"><div class="content">Amen, brother. Love you.</div><br/></div></div><div id="35857325" class="c"><input type="checkbox" id="c-35857325" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853842">parent</a><span>|</span><a href="#35855480">prev</a><span>|</span><a href="#35855607">next</a><span>|</span><label class="collapse" for="c-35857325">[-]</label><label class="expand" for="c-35857325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I make money from porting people off of poor technical choices onto solid ones.<p>Is this not just openly broadcasting your financial incentive to say “Whatever is popular is bad, pay me and I’ll make it good” ?</div><br/></div></div></div></div><div id="35854246" class="c"><input type="checkbox" id="c-35854246" checked=""/><div class="controls bullet"><span class="by">mk89</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35853842">prev</a><span>|</span><a href="#35855159">next</a><span>|</span><label class="collapse" for="c-35854246">[-]</label><label class="expand" for="c-35854246">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Actually your comment is a great demonstration of poor engineering leadership. You&#x27;ve already decided on an outcome and are shifting the narrative to adhere to this outcome.<p>For me it&#x27;s actually the decision of a CTO of one of top 10 companies in the world in terms of software size&#x2F;value&#x2F;etc. to push it down to very smart people - that&#x27;s bad leadership.<p>Why? Because I guess this thing didn&#x27;t go as planned - a self fulfilling prophecy that shows how awesome serverless is. It backfired in a period where people are questioning whether all these megahypes are not actually just some marketing. Yes, he is responsible for that, for pushing it down to his people that &quot;everything new must be started with serverless&quot; first. When actually in some situations, as the article showed, a monolith or a (big) microservice would do the job better.<p>Why the hell hire super smart people when you have to tell them how to do things?</div><br/><div id="35855125" class="c"><input type="checkbox" id="c-35855125" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854246">parent</a><span>|</span><a href="#35854389">next</a><span>|</span><label class="collapse" for="c-35855125">[-]</label><label class="expand" for="c-35855125">[2 more]</label></div><br/><div class="children"><div class="content">Those smart engineers should be encouraged to devote their brainpower to other aspects of the business and technology stack.<p>Far too often teams use an opportunity to build something new as a science project to use all the latest wiz bang cloud features when the boring stack would work just fine.<p>For those that truly want to innovate on that aspect of the stack, they should be part of a central infrastructure team, whose job it is to build scalable solutions for the group.</div><br/><div id="35857217" class="c"><input type="checkbox" id="c-35857217" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855125">parent</a><span>|</span><a href="#35854389">next</a><span>|</span><label class="collapse" for="c-35857217">[-]</label><label class="expand" for="c-35857217">[1 more]</label></div><br/><div class="children"><div class="content">You can hire anyone for postgres and k8s.<p>Not so much the fancy new hotness that will be weirdware in three years.</div><br/></div></div></div></div><div id="35854389" class="c"><input type="checkbox" id="c-35854389" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854246">parent</a><span>|</span><a href="#35855125">prev</a><span>|</span><a href="#35855159">next</a><span>|</span><label class="collapse" for="c-35854389">[-]</label><label class="expand" for="c-35854389">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Why the hell hire super smart people when you have to tell them how to do things?<p>A very hard question. One side is that every smart engineer will do what&#x27;s best for their use case.<p>The other is now you might have 100 smart engineers with 100 smart different solutions which can cause repeated work, integration issues, missed common solutions, etc.<p>Both approaches have lots of pros cons and tradeoffs</div><br/><div id="35854498" class="c"><input type="checkbox" id="c-35854498" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854389">parent</a><span>|</span><a href="#35857059">next</a><span>|</span><label class="collapse" for="c-35854498">[-]</label><label class="expand" for="c-35854498">[2 more]</label></div><br/><div class="children"><div class="content">Generally the best approach there is to elevate a bunch of your smartest engineers into an architecture team that a) set good standards but also b) appreciates the nuance of problems sufficiently to know when to deviate.<p>A small team can probably only handle one tech stack, an org with 10 teams can probably handle 10 stacks if they needed to but can get efficiency by standardising on some number less than 10.<p>However making those calls shouldn&#x27;t be coming down from the CTO, it should be made among the architects that actually design and build the systems.</div><br/><div id="35854967" class="c"><input type="checkbox" id="c-35854967" checked=""/><div class="controls bullet"><span class="by">phil-m</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854498">parent</a><span>|</span><a href="#35857059">next</a><span>|</span><label class="collapse" for="c-35854967">[-]</label><label class="expand" for="c-35854967">[1 more]</label></div><br/><div class="children"><div class="content">Where I&#x27;d consider a (good) CTO should be somehow responsible for the high-level architectural decisions. Accumulate enough expertise and know-how (via &quot;architects&quot; or rather very senior engineers) and then discuss the pros&#x2F;cons and at the end weigh each argument and decide what may work best.</div><br/></div></div></div></div><div id="35857059" class="c"><input type="checkbox" id="c-35857059" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854389">parent</a><span>|</span><a href="#35854498">prev</a><span>|</span><a href="#35855159">next</a><span>|</span><label class="collapse" for="c-35857059">[-]</label><label class="expand" for="c-35857059">[1 more]</label></div><br/><div class="children"><div class="content">The smart have to design for the average of devs and not the smartest.<p>The smart design for easily creating beginners in thenfuture to work with what exists.<p>Too often smart devs have to be clever with coding, where clever architecture can often be more flexible.</div><br/></div></div></div></div></div></div><div id="35855159" class="c"><input type="checkbox" id="c-35855159" checked=""/><div class="controls bullet"><span class="by">stcroixx</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35854246">prev</a><span>|</span><a href="#35854796">next</a><span>|</span><label class="collapse" for="c-35855159">[-]</label><label class="expand" for="c-35855159">[4 more]</label></div><br/><div class="children"><div class="content">I agree with him that serverless should not be the default and there should be a clear justification for needing those features.<p>He then fails to apply the same rule to k8.  Almost nobody needs that either and treating it as the default not a good strategy.</div><br/><div id="35858051" class="c"><input type="checkbox" id="c-35858051" checked=""/><div class="controls bullet"><span class="by">jasonm23</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855159">parent</a><span>|</span><a href="#35857324">next</a><span>|</span><label class="collapse" for="c-35858051">[-]</label><label class="expand" for="c-35858051">[1 more]</label></div><br/><div class="children"><div class="content">Yes, to call Serverless hype train and then talk of K8s as the &quot;boring solid choice&quot; is pretty funny.</div><br/></div></div><div id="35857324" class="c"><input type="checkbox" id="c-35857324" checked=""/><div class="controls bullet"><span class="by">Aperocky</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855159">parent</a><span>|</span><a href="#35858051">prev</a><span>|</span><a href="#35854796">next</a><span>|</span><label class="collapse" for="c-35857324">[-]</label><label class="expand" for="c-35857324">[2 more]</label></div><br/><div class="children"><div class="content">Exactly, not everything needs scale.<p>For a low traffic, low use system, lambda + dynamo might just be the cheapest and easiest to implement and maintain.<p>And there are generally more of those type of systems.</div><br/><div id="35857614" class="c"><input type="checkbox" id="c-35857614" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857324">parent</a><span>|</span><a href="#35854796">next</a><span>|</span><label class="collapse" for="c-35857614">[-]</label><label class="expand" for="c-35857614">[1 more]</label></div><br/><div class="children"><div class="content">Depends? Is your load consistent and latency sensitive? Then having a small ECS instance may be a lot better.</div><br/></div></div></div></div></div></div><div id="35854796" class="c"><input type="checkbox" id="c-35854796" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35855159">prev</a><span>|</span><a href="#35857424">next</a><span>|</span><label class="collapse" for="c-35854796">[-]</label><label class="expand" for="c-35854796">[5 more]</label></div><br/><div class="children"><div class="content">Fully agree with this - it completely ignores the context and domain for a one size fits all solution, which is precisely what is wrong with engineering today - lack of holism.<p>The OP&#x27;s comment &quot;Also generally the conception that building things with containers + k8s actually takes more time than serverless is a horseshit take IMO. It doesn&#x27;t and if it&#x27;s taking you longer you are probably doing something wrong.&quot;<p>I couldn&#x27;t disagree with more from a hands on practical perspective. That will 100% take anyone longer to spin up for an MVP (for more cost) than spinning up a FreeBSD server and I&#x27;m unaware of anything that needs more than that for an MVP.<p>This isn&#x27;t even mentioning the fact that every second your data sits in an AWS&#x2F;CGP&#x2F;Azure datacenter - you are not only telling them what kind of data you have (don&#x27;t pretend like the hosts don&#x27;t know and can&#x27;t tell) but you&#x27;re increasing your switching&#x2F;egress costs</div><br/><div id="35854964" class="c"><input type="checkbox" id="c-35854964" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854796">parent</a><span>|</span><a href="#35857424">next</a><span>|</span><label class="collapse" for="c-35854964">[-]</label><label class="expand" for="c-35854964">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I couldn&#x27;t disagree with more from a hands on practical perspective. That will 100% take anyone longer to spin up for an MVP (for more cost) than spinning up a FreeBSD server and I&#x27;m unaware of anything that needs more than that for an MVP.<p>I agree with OP. If you hand me a binary and instructions on how to run it, I can have it running on either AWS or DO in a container, connected to a managed database with snapshots enabled in about 30 minutes. If the toolchain is easy to set up, I can have CI&#x2F;CD with 0-downtime deployments with auto-rollback in another 30 minutes, and you won&#x27;t need to touch either of those until you&#x27;re hitting thousands of concurrent users for a typical web app.<p>&gt;  you are not only telling them what kind of data you have (don&#x27;t pretend like the hosts don&#x27;t know and can&#x27;t tell)<p>this is FUD of the n&#x27;th degree - if you suspect AWS are spying on your managed RDS data, I don&#x27;t know what to tell you.</div><br/><div id="35855489" class="c"><input type="checkbox" id="c-35855489" checked=""/><div class="controls bullet"><span class="by">AndrewKemendo</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854964">parent</a><span>|</span><a href="#35857424">next</a><span>|</span><label class="collapse" for="c-35855489">[-]</label><label class="expand" for="c-35855489">[3 more]</label></div><br/><div class="children"><div class="content">Great…So you quickly put yourself in a position where the longer you’re on the service the more expensive it will be to migrate<p>And yes Amazon uses AWS utilization to keep track of promising startups or places that they want signal about market changes.</div><br/><div id="35855637" class="c"><input type="checkbox" id="c-35855637" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855489">parent</a><span>|</span><a href="#35857424">next</a><span>|</span><label class="collapse" for="c-35855637">[-]</label><label class="expand" for="c-35855637">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Great…So you quickly put yourself in a position where the longer you’re on the service the more expensive it will be to migrate<p>With 30 minutes work, I&#x27;ve set up a production quality solution that I won&#x27;t have to touch for months&#x2F;years, and has almost no vendor lock-in. Containers are portable, you can run them on AWS, DO, GCP, or install docker on a bare metal instance, it&#x27;s up to you. Until you _do_ decide to migrate, it&#x27;s pretty much 0 upkeep (I checked one of the work projects I stood up and we haven&#x27;t touched the infrastructure side of it for 9 months).<p>&gt; And yes Amazon uses AWS utilization to keep track of promising startups or places that they want signal about market changes.<p>That&#x27;s not what you said at first, you said &quot;you are not only telling them what kind of data you have (don&#x27;t pretend like the hosts don&#x27;t know and can&#x27;t tell)&quot;. You&#x27;re telling AWS that you&#x27;re running containers and a database.</div><br/><div id="35856055" class="c"><input type="checkbox" id="c-35856055" checked=""/><div class="controls bullet"><span class="by">scarface74</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855637">parent</a><span>|</span><a href="#35857424">next</a><span>|</span><label class="collapse" for="c-35856055">[-]</label><label class="expand" for="c-35856055">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and I’m sure after you set things up with “no vendor lock in”, you came back years later when the company grew and organized a large migration where you had to deal with budgets, transferring data, regression testing, going through architecture review boards, the PMO, permissions, compliance, training, etc.<p>I’m also sure after many years no vendor specific corner cases snuck in that  you didn’t realize were there</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35857424" class="c"><input type="checkbox" id="c-35857424" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35854796">prev</a><span>|</span><a href="#35854935">next</a><span>|</span><label class="collapse" for="c-35857424">[-]</label><label class="expand" for="c-35857424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s purely based on emotion<p>Maybe charitably assume it’s based on years of experience doing this exact thing?<p>It’s certainly my experience.</div><br/></div></div><div id="35854935" class="c"><input type="checkbox" id="c-35854935" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853807">parent</a><span>|</span><a href="#35857424">prev</a><span>|</span><a href="#35856621">next</a><span>|</span><label class="collapse" for="c-35854935">[-]</label><label class="expand" for="c-35854935">[5 more]</label></div><br/><div class="children"><div class="content">&gt; poor engineering leadership.<p>Or fantastic engineering leadership.<p>OP has constrained the technology choices of the org into a very capable set of primitives. The entire org can move faster by sitting atop the same rails.<p>K8s + tried and true tech lets the org spin up additional compute anywhere and easily migrate off a particular vendor. Lift and shift is work, but not nearly as bad when the rails are simple.</div><br/><div id="35855181" class="c"><input type="checkbox" id="c-35855181" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854935">parent</a><span>|</span><a href="#35855465">next</a><span>|</span><label class="collapse" for="c-35855181">[-]</label><label class="expand" for="c-35855181">[1 more]</label></div><br/><div class="children"><div class="content">Having done the dreaded AWS + kops -&gt; GKE migration I must agree, it was hard but nowhere near as hard as it could have been.</div><br/></div></div><div id="35855465" class="c"><input type="checkbox" id="c-35855465" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854935">parent</a><span>|</span><a href="#35855181">prev</a><span>|</span><a href="#35856621">next</a><span>|</span><label class="collapse" for="c-35855465">[-]</label><label class="expand" for="c-35855465">[3 more]</label></div><br/><div class="children"><div class="content">&gt; simple<p>&gt; k8s<p>Pick one</div><br/><div id="35855556" class="c"><input type="checkbox" id="c-35855556" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855465">parent</a><span>|</span><a href="#35856621">next</a><span>|</span><label class="collapse" for="c-35855556">[-]</label><label class="expand" for="c-35855556">[2 more]</label></div><br/><div class="children"><div class="content">Eh. There are different types of complexity.<p>k8s has a nice contained local complexity that I prefer.<p>It&#x27;s not simple internally but it&#x27;s simple to use if you know how it works.<p>So really it&#x27;s not &quot;k8s isn&#x27;t simple&quot; it&#x27;s more &quot;nothing is simple&quot; so pick your preferred type of complexity.</div><br/><div id="35857262" class="c"><input type="checkbox" id="c-35857262" checked=""/><div class="controls bullet"><span class="by">scarface74</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855556">parent</a><span>|</span><a href="#35856621">next</a><span>|</span><label class="collapse" for="c-35857262">[-]</label><label class="expand" for="c-35857262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not simple internally but it&#x27;s simple to use if you know how it works.<p>Isn’t that literally true about anything?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35856621" class="c"><input type="checkbox" id="c-35856621" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853807">prev</a><span>|</span><a href="#35853744">next</a><span>|</span><label class="collapse" for="c-35856621">[-]</label><label class="expand" for="c-35856621">[3 more]</label></div><br/><div class="children"><div class="content">Serverless first is probably not a mistake in general. But we may have a different definition? For me Serverless means no need to administer a server (in the sense of &quot;an operating system&quot;).<p>So baremetal, vps, = serverful<p>And lambdas, app engines, firebase, ... = serverless<p>There is a space where you are deploying a monolith app, and letting the cloud provider do the scaling, server management, environment management. But at any time you could run that same app happily on a server.<p>I think starting off there is not a mistake.<p>I think k8s is an advanced move. You can start off with the cloud built-in container management solution, then move to k8s later if you really need it.</div><br/><div id="35857181" class="c"><input type="checkbox" id="c-35857181" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856621">parent</a><span>|</span><a href="#35853744">next</a><span>|</span><label class="collapse" for="c-35857181">[-]</label><label class="expand" for="c-35857181">[2 more]</label></div><br/><div class="children"><div class="content">yeah, I think I should have said something along the lines &quot;Functions as a Service first is a mistake&quot; but whatever, I didn&#x27;t think people would focus so much on what they consider serverless is.<p>IMO managed container runtimes are PaaS, are both FaaS and PaaS serverless? Who knows, we don&#x27;t seem to have hard definitions but in my mind PaaS predates serverless becoming a fashionable word so I associate with FaaS and FaaS-like things only.</div><br/><div id="35857288" class="c"><input type="checkbox" id="c-35857288" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35857181">parent</a><span>|</span><a href="#35853744">next</a><span>|</span><label class="collapse" for="c-35857288">[-]</label><label class="expand" for="c-35857288">[1 more]</label></div><br/><div class="children"><div class="content">Safest to say the exact thing (or list of things) I reckon!<p>Technically &quot;serverless&quot; should mean &quot;no server&quot; which means &quot;no process fielding network requests&quot; i.e. &quot;unable to accept inbound network requests&quot; - so some kind of batch processing system, or scheduled lambdas :-)</div><br/></div></div></div></div></div></div><div id="35853744" class="c"><input type="checkbox" id="c-35853744" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35856621">prev</a><span>|</span><a href="#35856837">next</a><span>|</span><label class="collapse" for="c-35853744">[-]</label><label class="expand" for="c-35853744">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Serverless first is a mistake. It should be &quot;serverless where it&#x27;s distinct advantages are actually useful&quot; which is way less common than people think.</i><p>Wouldn&#x27;t that approach take away the remaining advantages of Serverless while still leaving you with the cost?<p>My understanding was that Serverless is supposed to free you from the burden of maintaining a complete software stack, including configuring the db, server, application runtime etc and just focus on the business logic - a bit like one of the old &quot;sharehost&quot;&#x2F;LAMPP setups from a few decades ago.<p>If that is true, then you&#x27;d be well-advised to either go all-in and structure your entire application as lambda functions, or don&#x27;t use functions at all and go with a &quot;traditional&quot; kubernetes deployment.<p>As both strategies come with considerable complexity cost, combining them would give you the cost of both. I think you&#x27;d want to avoid that if possible.</div><br/><div id="35854063" class="c"><input type="checkbox" id="c-35854063" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853744">parent</a><span>|</span><a href="#35854605">next</a><span>|</span><label class="collapse" for="c-35854063">[-]</label><label class="expand" for="c-35854063">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat. I think if I was to ever use serverless for something it would be in concert with a traditional setup so in a way yes, you pay 2x the deployment complexity because now you are orchestrating 2 environments.<p>However if you have a usecase that is absolutely a perfect fit for serverless i.e incredibly bursty, unpredicable, very short runtime. To the point it would be to the detriment of other services hosted on the same infrastructure i.e would need say an isolated cluster anyway then yeah, serverless could be a cost worth paying.</div><br/></div></div><div id="35854605" class="c"><input type="checkbox" id="c-35854605" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853744">parent</a><span>|</span><a href="#35854063">prev</a><span>|</span><a href="#35856837">next</a><span>|</span><label class="collapse" for="c-35854605">[-]</label><label class="expand" for="c-35854605">[1 more]</label></div><br/><div class="children"><div class="content">Main issue of lambda and similar offerings is that you&#x27;re pretty much bound to the cloud.<p>Kubernetes is much more open standard. It&#x27;s much easier to move to other cloud or self-host.<p>It&#x27;s more about insurance and keeping other options.<p>Managed Kubernetes, managed databases are a thing and you should use them if you can. Just don&#x27;t depend on cloud-specific stuff too much.</div><br/></div></div></div></div><div id="35856837" class="c"><input type="checkbox" id="c-35856837" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853744">prev</a><span>|</span><a href="#35857999">next</a><span>|</span><label class="collapse" for="c-35856837">[-]</label><label class="expand" for="c-35856837">[3 more]</label></div><br/><div class="children"><div class="content">I’m going to have to disagree with this.<p>There are different shades of serverless, and you don’t start at an R620 plugged into a colo rack. You grow into it OR start with a large enough problem to demand it.<p>You start with GitHub pages or Cloudflare pages where all you have is CSS, HTML, and JS served from the equivalent of a global CDN that you didn’t have to build for essentially free.<p>For a mom and pop shop, how many times are they going to have to contact you over the next 20 years for a piece of software doing its job running on GitHub pages? Practically zero, unless it’s a feature request. Can’t say the same for a Linux box plugged into the wall under your desk or an R620 at the colo downtown.<p>Then you graduate to sprinkling a little bit of persistent state in. When you need a little bit of persistent state for a small mom and pop, deciding to vet colo vendors and signing that shop up to be responsible for sysadmining an R620 with a Linux kernel is irresponsible. You find a serverless vendor for your DB layer (like the Firebase of yore) or a set of CRUD handlers written on infra that fully manages the language runtime, operating system, kernel, and infra for your customer (like Cloudflare workers).<p>How many times is the customer going to need to contact you over the next 20 years for your Cloudflare worker? Probably only a handful. Odds are, significantly less than an R620 plugged into a server rack at the colo downtown.<p>If you outgrow this, you probably are starting to look at VMs or colo.<p>Serverless is real. It’s not lambda. It’s pervasive. It’s provides substantial value in ongoing maintenance and engineering costs if you pick the right vendor. And a majority of the market demands it as a starting point.<p>An engineer is expensive and most customers aren’t in a position to practice the craft themselves. The best service we can provide is to minimize their dependence on our field.</div><br/><div id="35856873" class="c"><input type="checkbox" id="c-35856873" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856837">parent</a><span>|</span><a href="#35857999">next</a><span>|</span><label class="collapse" for="c-35856873">[-]</label><label class="expand" for="c-35856873">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How many times is the customer going to need to contact you over the next 20 years for your Cloudflare worker? Probably only a handful. Odds are, significantly less than an R620 plugged into a server rack at the colo downtown.<p>This has nothing to do with &quot;serverless&quot;. Heroku did the same thing well before serverless was available.<p>Keeping a simple app running on heroku over the past 15 years has required about 3 hours admin total since I set it up (moving from an old stack to a newer one).</div><br/><div id="35857212" class="c"><input type="checkbox" id="c-35857212" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856873">parent</a><span>|</span><a href="#35857999">next</a><span>|</span><label class="collapse" for="c-35857212">[-]</label><label class="expand" for="c-35857212">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Serverless is a spectrum. Heroku for sure sits on that spectrum.<p>At it core serverless is about delegation of responsibility and how much responsibility you can push across the vendor boundary.</div><br/></div></div></div></div></div></div><div id="35857999" class="c"><input type="checkbox" id="c-35857999" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35856837">prev</a><span>|</span><a href="#35853698">next</a><span>|</span><label class="collapse" for="c-35857999">[-]</label><label class="expand" for="c-35857999">[1 more]</label></div><br/><div class="children"><div class="content">IMO serverless is incredibly useful when latency isn&#x27;t important. Backend stuff, metrics, analytics, APIs, etc should be serverless. It allows you to scale incredibly easily at basically 0 cost.<p>For everything else, you have to test and examine the use cases and performance requirements. In general if there&#x27;s a UI that&#x27;s doing work it shouldn&#x27;t be serverless. Work = latency = bad.</div><br/></div></div><div id="35853698" class="c"><input type="checkbox" id="c-35853698" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35857999">prev</a><span>|</span><a href="#35856317">next</a><span>|</span><label class="collapse" for="c-35853698">[-]</label><label class="expand" for="c-35853698">[8 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t JVM here result in some amount of &quot;dicking around&quot; with respect to which JVM language to use? Or do you mean that it doesn&#x27;t matter, as long as it&#x27;s all JVM? Or do you mean to just pick java?<p>One thing I&#x27;ve seen in my experience generally buying this &quot;standardize on boring tech&quot; take, is that it&#x27;s really common these days for a company to be doing some amount of &quot;serious&quot; data science work, and most people seem to really want to do that in python, and it also seems to benefit pretty significantly from some kind of OLAP database system. So adding those things onto your &quot;boring&quot; stack becomes JVM+psql+k8s+python+snowflake&#x2F;databricks&#x2F;duckdb(?).<p>But I agree with your real point about serverless.</div><br/><div id="35854558" class="c"><input type="checkbox" id="c-35854558" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853698">parent</a><span>|</span><a href="#35853913">next</a><span>|</span><label class="collapse" for="c-35854558">[-]</label><label class="expand" for="c-35854558">[3 more]</label></div><br/><div class="children"><div class="content">For backend, JVM implies Java. Although Kotlin is safe choice as well, it&#x27;s not as popular so I wouldn&#x27;t suggest to use it, unless you have good reasons to (like team of Android developers who decided to build backend).</div><br/><div id="35855227" class="c"><input type="checkbox" id="c-35855227" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854558">parent</a><span>|</span><a href="#35856491">next</a><span>|</span><label class="collapse" for="c-35855227">[-]</label><label class="expand" for="c-35855227">[1 more]</label></div><br/><div class="children"><div class="content">I actually use Kotlin. :)<p>I am happy with either Kotlin or Java though.<p>Reasons for Kotlin is mostly nullability typing though @NotNull gets you pretty far in Java these days with the tooling configured correctly.<p>I like the syntax a bit more and extension functions are a nice sugar vs util classes with static functions.<p>The main reason however is I have a lot more luck convincing Typescript developers to try Kotlin than Java which is relevant when most of my colleagues have primarily done Typescript.<p>Either or though IMO, both are great choices for backend development and they interoperate really well.</div><br/></div></div><div id="35856491" class="c"><input type="checkbox" id="c-35856491" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854558">parent</a><span>|</span><a href="#35855227">prev</a><span>|</span><a href="#35853913">next</a><span>|</span><label class="collapse" for="c-35856491">[-]</label><label class="expand" for="c-35856491">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For backend, JVM implies Java.<p>... no it doesn&#x27;t.</div><br/></div></div></div></div><div id="35853913" class="c"><input type="checkbox" id="c-35853913" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853698">parent</a><span>|</span><a href="#35854558">prev</a><span>|</span><a href="#35856317">next</a><span>|</span><label class="collapse" for="c-35853913">[-]</label><label class="expand" for="c-35853913">[4 more]</label></div><br/><div class="children"><div class="content">Generally speaking your data-science stuff wouldn&#x27;t fit into the serverless bucket anyway though.<p>Also generally Python is just used for terminal processing in the Big Data world, all the pieces in between are JVM anyway.</div><br/><div id="35854225" class="c"><input type="checkbox" id="c-35854225" checked=""/><div class="controls bullet"><span class="by">disgruntledphd2</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853913">parent</a><span>|</span><a href="#35856583">next</a><span>|</span><label class="collapse" for="c-35854225">[-]</label><label class="expand" for="c-35854225">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I mean if you&#x27;re already a JVM shop then you could probably run Spark yourself (which can be painful) and use SparkSQL to dump to Python (maybe on databricks, though I&#x27;m not a massive fan) and do your fancy ML stuff there.<p>Alternatively, you could just use a read-only PG replica and Python here, which would suffice for most DS needs (unless your core product is DS related or you have huuuuuggggggggeeee data (which you probably don&#x27;t)).</div><br/><div id="35854559" class="c"><input type="checkbox" id="c-35854559" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35854225">parent</a><span>|</span><a href="#35856583">next</a><span>|</span><label class="collapse" for="c-35854559">[-]</label><label class="expand" for="c-35854559">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that is fair too. Most people have tiny data. Then there is places I have worked... where 10TB qualified as small data that you &quot;just query with Presto&quot; and where more exotic things were needed for actually interacting with the &quot;big data&quot;.<p>All relative in the end.</div><br/></div></div></div></div><div id="35856583" class="c"><input type="checkbox" id="c-35856583" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35853913">parent</a><span>|</span><a href="#35854225">prev</a><span>|</span><a href="#35856317">next</a><span>|</span><label class="collapse" for="c-35856583">[-]</label><label class="expand" for="c-35856583">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t mesh with my experience of the current breakdown in usage between python and the jvm for these use cases.</div><br/></div></div></div></div></div></div><div id="35856317" class="c"><input type="checkbox" id="c-35856317" checked=""/><div class="controls bullet"><span class="by">optimuspaul</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35853698">prev</a><span>|</span><a href="#35855363">next</a><span>|</span><label class="collapse" for="c-35856317">[-]</label><label class="expand" for="c-35856317">[2 more]</label></div><br/><div class="children"><div class="content">I disagree very much. I don&#x27;t think any blanket statement like that makes sense.<p>I recently started building a service and need to keep costs down. Serverless is perfect for it. My service has low to moderate traffic, costs pennies to run on AWS Lambda and MongoDB Atlas. If I had gone the boring route of JVM + PG + k8s, putting aside the time it would take to defamiliarize myself with anything on the JVM, the cost to run this service would have been in the hundreds of dollars a month vs the pennies. Interestingly the most expensive part of my current setup is the NAT Router on my VPC. With JVM + PG + k8s it would have been PG or K8S depending on where I ran PG.<p>I do agree that there is a misconception with containers taking longer than server less. I don&#x27;t think either takes longer considering the current tooling available.<p>Seems like you got burned on Serverless at some point, I&#x27;m sorry that happened, but for many people and teams it is a productivity multiplier and can be a big cost cutting solution.</div><br/><div id="35856653" class="c"><input type="checkbox" id="c-35856653" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35856317">parent</a><span>|</span><a href="#35855363">next</a><span>|</span><label class="collapse" for="c-35856653">[-]</label><label class="expand" for="c-35856653">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the cost to run this service would have been in the hundreds of dollars a month vs the pennies<p>And maybe this again proves the initial comment&#x27;s point.<p>&gt; I do agree that there is a misconception with containers taking longer than server less. I don&#x27;t think either takes longer considering the current tooling available.<p>And (the misconception) that it costs more.<p>&gt; AWS Lambda and MongoDB Atlas<p>If you take a managed database with a free tier and compare it there are similarly managed databases (SQL) based with a free tier. Not really fair to say PG will cost more.<p>This also comes down to the world is not just AWS. k8s is cheap in a lot of places and definitely not hundreds a month.</div><br/></div></div></div></div><div id="35855363" class="c"><input type="checkbox" id="c-35855363" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35853565">parent</a><span>|</span><a href="#35856317">prev</a><span>|</span><a href="#35854059">next</a><span>|</span><label class="collapse" for="c-35855363">[-]</label><label class="expand" for="c-35855363">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but laugh at this when I think of how easy it is to imagine the exact same tenor in a post dismissing Kubernetes as newfangled, overcomplicated garbage.</div><br/><div id="35855683" class="c"><input type="checkbox" id="c-35855683" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#35853565">root</a><span>|</span><a href="#35855363">parent</a><span>|</span><a href="#35854059">next</a><span>|</span><label class="collapse" for="c-35855683">[-]</label><label class="expand" for="c-35855683">[1 more]</label></div><br/><div class="children"><div class="content">Yeah there probably were people that wrote those. Not me though, I had been through the whole wringer before k8s so I knew what it was when I saw it.<p>I was working on a competitor to k8s at the time though so my knowledge of the subject matter definitely influenced my opinion of it.<p>I thought it was unstable though, largely due to dependency on etcd which was also unstable at the time. Thankfully that got sorted out though.</div><br/></div></div></div></div></div></div><div id="35854059" class="c"><input type="checkbox" id="c-35854059" checked=""/><div class="controls bullet"><span class="by">mellosouls</span><span>|</span><a href="#35853565">prev</a><span>|</span><label class="collapse" for="c-35854059">[-]</label><label class="expand" for="c-35854059">[1 more]</label></div><br/><div class="children"><div class="content">The nth posting of this story.<p><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=false&amp;query=Primevideo&amp;sort=byDate&amp;type=story" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=fal...</a></div><br/></div></div></div></div></div></div></div></body></html>