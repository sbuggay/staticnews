<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685523667010" as="style"/><link rel="stylesheet" href="styles.css?v=1685523667010"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ericsink.com/entries/fsharp_chasm.html">Why F# evangelism isn&#x27;t working (2015)</a> <span class="domain">(<a href="https://ericsink.com">ericsink.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>143 comments</span></div><br/><div><div id="36134212" class="c"><input type="checkbox" id="c-36134212" checked=""/><div class="controls bullet"><span class="by">ericsink</span><span>|</span><a href="#36133371">next</a><span>|</span><label class="collapse" for="c-36134212">[-]</label><label class="expand" for="c-36134212">[36 more]</label></div><br/><div class="children"><div class="content">(Author here)<p>Well this is a blast from the past.<p>Back when I wrote this, I kinda hoped F# would surprise me and gain more traction than I expected.  But 8 years later, if anything, it seems like the dominance of C# in the .NET ecosystem has grown.<p>F# is still a great language, but the main fact hasn&#x27;t changed:  C# isn&#x27;t bad enough for F# to thrive.</div><br/><div id="36136090" class="c"><input type="checkbox" id="c-36136090" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134672">next</a><span>|</span><label class="collapse" for="c-36136090">[-]</label><label class="expand" for="c-36136090">[1 more]</label></div><br/><div class="children"><div class="content">F# also tried to pivot into data science of lately, only to have Microsoft themselves jumping into Python and being the entity that finally managed to convince Guido and others to invest into improving CPython&#x27;s performance, and possible JIT integration.<p>Basically having the pivot efforts being sabotaged by the same company.</div><br/></div></div><div id="36134672" class="c"><input type="checkbox" id="c-36134672" checked=""/><div class="controls bullet"><span class="by">lambdaxymox</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36136090">prev</a><span>|</span><a href="#36134461">next</a><span>|</span><label class="collapse" for="c-36134672">[-]</label><label class="expand" for="c-36134672">[6 more]</label></div><br/><div class="children"><div class="content">F# always struck me as one of the most terribly underrated languages. I&#x27;m a lover of MLs in general, but F# lands on one of the sweet spots in PL space with ample expressive power without being prone to floating off into abstraction orbit (&quot;pragmatic functional&quot; is the term I believe). It is basically feature complete to boot.</div><br/><div id="36134736" class="c"><input type="checkbox" id="c-36134736" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134672">parent</a><span>|</span><a href="#36134461">next</a><span>|</span><label class="collapse" for="c-36134736">[-]</label><label class="expand" for="c-36134736">[5 more]</label></div><br/><div class="children"><div class="content">&gt; without being prone to floating off into abstraction orbit<p>What do you mean by this?</div><br/><div id="36135129" class="c"><input type="checkbox" id="c-36135129" checked=""/><div class="controls bullet"><span class="by">c00lio</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134736">parent</a><span>|</span><a href="#36134461">next</a><span>|</span><label class="collapse" for="c-36135129">[-]</label><label class="expand" for="c-36135129">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Oh, you _also_ need to print something? Lets stack a few monad transformers...&quot;<p>&quot;But remember that you need the TemplateExplicative and NullUnderstanding compiler extensions!&quot;</div><br/><div id="36135686" class="c"><input type="checkbox" id="c-36135686" checked=""/><div class="controls bullet"><span class="by">momentoftop</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135129">parent</a><span>|</span><a href="#36135399">next</a><span>|</span><label class="collapse" for="c-36135686">[-]</label><label class="expand" for="c-36135686">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re thinking of Haskell. F# was modelled after OCaml, which doesn&#x27;t attract monad transformer stacks, and doesn&#x27;t have a zoo of compiler extensions.</div><br/></div></div><div id="36135399" class="c"><input type="checkbox" id="c-36135399" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135129">parent</a><span>|</span><a href="#36135686">prev</a><span>|</span><a href="#36134461">next</a><span>|</span><label class="collapse" for="c-36135399">[-]</label><label class="expand" for="c-36135399">[2 more]</label></div><br/><div class="children"><div class="content">&gt;NullUnderstanding compiler extension<p>brilliant! lol</div><br/><div id="36135406" class="c"><input type="checkbox" id="c-36135406" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135399">parent</a><span>|</span><a href="#36134461">next</a><span>|</span><label class="collapse" for="c-36135406">[-]</label><label class="expand" for="c-36135406">[1 more]</label></div><br/><div class="children"><div class="content">Is brilliant the best word? :P</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36134461" class="c"><input type="checkbox" id="c-36134461" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134672">prev</a><span>|</span><a href="#36135114">next</a><span>|</span><label class="collapse" for="c-36134461">[-]</label><label class="expand" for="c-36134461">[16 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it matters how good or bad C# is, Object Oriented Programming is a mess<p>Learning, how to use an Object System (a tree of objects&#x2F;classes) is inherently hard<p>The current problem with F# is that it doesnt do enough to shield you from objects, it does what it can, but still to use F# effectively, you still need to learn some C# and a lot of API that basically Objects inside Objects inside Objects calling Objects calling Objects and more Objects<p>OOP is bad because eventually OO systems becomes too complex, OO API is intimidation<p>Separating Data from Behavior manages complexity better<p>If the only flaw in C# is knowing which method calls requires the new keyword because its a constructor, and which dont because its a factory, that is bad enough to want to avoid it</div><br/><div id="36135537" class="c"><input type="checkbox" id="c-36135537" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134461">parent</a><span>|</span><a href="#36135085">next</a><span>|</span><label class="collapse" for="c-36135537">[-]</label><label class="expand" for="c-36135537">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OOP is bad because eventually OO systems becomes too complex, OO API is intimidation<p>This strikes me as a sort of ... reverse of survivorship bias.<p>You look around and see all complex systems are in OO, then you conclude that it is OO that is the cause of the complexity.<p>Have you considered that the non-OO designs are deficient in some way that prevents them from being used for the type of systems that you find to be examples of OO being bad?<p>Not that I am defending OO, I just want to know how you are differentiating between &quot;OO produces complex systems&quot; and &quot;OO is used for complex systems&quot;.</div><br/></div></div><div id="36135085" class="c"><input type="checkbox" id="c-36135085" checked=""/><div class="controls bullet"><span class="by">ThinkBeat</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134461">parent</a><span>|</span><a href="#36135537">prev</a><span>|</span><a href="#36135609">next</a><span>|</span><label class="collapse" for="c-36135085">[-]</label><label class="expand" for="c-36135085">[3 more]</label></div><br/><div class="children"><div class="content">Every system if allowed to become too complex.
No single paradigm of programming is perfect for all cases.<p>OO is one way to structure and model a system.<p>No matter what language you use will end up with some form of a struct,
a set of values that belong together 
Then you will have list of some structs and trees of some structs<p>You will almost certainly have to create list&#x2F;collections&#x2F;groupings of 
structs. Because those are quite useful and universal<p>How you act on those collections is different between different idioms.<p>In other words you will create a model of data one way or another
and you have to maintain it &#x2F; change it, as required over time.<p>The data structures themselves are rather often based on or more 
database schema where the data will be extracted and saved.</div><br/><div id="36135455" class="c"><input type="checkbox" id="c-36135455" checked=""/><div class="controls bullet"><span class="by">rgbgraph</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135085">parent</a><span>|</span><a href="#36135609">next</a><span>|</span><label class="collapse" for="c-36135455">[-]</label><label class="expand" for="c-36135455">[2 more]</label></div><br/><div class="children"><div class="content">Just like every language is able to be slow&#x2F;non-performant -- but OO in this case would be Python in a web context; it doesn&#x27;t invalidate that a good amount of OO codebases in the wild devolve into incomprehensible black boxes, where no one has any idea what anything does or how to make meaningful changes that fulfill the intent of (compare that to iterative programming, where you can atleast read it)<p>A list: I give you a vector. Plain and simple. Not this insanity: <a href="https:&#x2F;&#x2F;referencesource.microsoft.com&#x2F;#mscorlib&#x2F;system&#x2F;collections&#x2F;generic&#x2F;list.cs,cf7f4095e4de7646" rel="nofollow">https:&#x2F;&#x2F;referencesource.microsoft.com&#x2F;#mscorlib&#x2F;system&#x2F;colle...</a> [0] You do not need OO to create a vector (or even an array -- god forbid!)<p>As for trees: roll your own. They&#x27;re simple enough, yet tightly-coupled with context that no generic implementation exists that is flexible enough. You do not need OO to create a tree. C has been working with trees long before the current Frankensteination of OO was even a twinkle in Gosling&#x27;s eye.[1]<p>Data structures do not need inheritance -- they might need delegation (message passing that requires you to actually think about your system).<p>Data structures do not need encapsulation -- they most likely need namespaces. Realistically, most classes will be used as namespaces.<p>Data structures do not need polymorphism -- just implement the members you need, and name them appropriately (no 5+ word phrases, please. <i>Please!</i>)<p>What modern OO does is lower the barrier to productivity in the present, and then pays for it in the future. It&#x27;s no different than writing your &quot;planet scale&quot; backend system in JS.<p>[0] Compare to: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.6.3&#x2F;libstdc++&#x2F;api&#x2F;a01115_source.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.6.3&#x2F;libstdc++&#x2F;api&#x2F;a0111...</a><p>[1] If you want to know why we have Java: some guys that didn&#x27;t have the time to think about low-level (memory management specifically) things for their embedded applications, got sick of trying to learn C++, decided to make their own language. That&#x27;s it. There was no grand plan or thoughtful design -- it&#x27;s just a mismash of personal preference. The same people that described C++ as &quot;being too complex&quot; (fair) and using &quot;too much memory&quot; (lol)</div><br/><div id="36135980" class="c"><input type="checkbox" id="c-36135980" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135455">parent</a><span>|</span><a href="#36135609">next</a><span>|</span><label class="collapse" for="c-36135980">[-]</label><label class="expand" for="c-36135980">[1 more]</label></div><br/><div class="children"><div class="content">Numbering your citations from zero, ehe? I like the cut of your jib.</div><br/></div></div></div></div></div></div><div id="36135609" class="c"><input type="checkbox" id="c-36135609" checked=""/><div class="controls bullet"><span class="by">Zecc</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134461">parent</a><span>|</span><a href="#36135085">prev</a><span>|</span><a href="#36135306">next</a><span>|</span><label class="collapse" for="c-36135609">[-]</label><label class="expand" for="c-36135609">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If the only flaw in C# is knowing which method calls requires the new keyword because its a constructor, and which dont because its a factory, that is bad enough to want to avoid it<p>I&#x27;m sure this is just an example popping first out of your mind, but it seems like an oddly specific thing to mention. Specially since the answer is obvious if you know C#: the name of the method matches that of the type if and only if it is a constructor.<p>I won&#x27;t comment on the rest of your post as my experience with F# is minimal; but I think I understand where you&#x27;re coming from.<p>&gt; Separating Data from Behavior manages complexity better<p>There&#x27;s a sweet spot, and it varies. Sometimes it is difficult to find. API design can be difficult. Managing complexity is sometimes itself a complex process.</div><br/></div></div><div id="36135306" class="c"><input type="checkbox" id="c-36135306" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134461">parent</a><span>|</span><a href="#36135609">prev</a><span>|</span><a href="#36134630">next</a><span>|</span><label class="collapse" for="c-36135306">[-]</label><label class="expand" for="c-36135306">[1 more]</label></div><br/><div class="children"><div class="content">The worst part of OOP is that all the properties of an object can be a mishmash of values and are mutable. In any method, you never know if the object is in some undesirable state without checking properties within the method itself. Multiply that headache across all methods and all other classes and it becomes a mutable mess. It makes it weird that we pass around objects as types when they encapsulate so much state and logic. They aren’t really a concrete data types, they are an entire living village.<p>With functional languages, it tries to enforce some explicit type signatures in the function arguments so things are cleaner within the functions themselves.</div><br/></div></div><div id="36134630" class="c"><input type="checkbox" id="c-36134630" checked=""/><div class="controls bullet"><span class="by">CrimsonCape</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134461">parent</a><span>|</span><a href="#36135306">prev</a><span>|</span><a href="#36135114">next</a><span>|</span><label class="collapse" for="c-36134630">[-]</label><label class="expand" for="c-36134630">[9 more]</label></div><br/><div class="children"><div class="content">I empathize with your characterization of &quot;a tree of object&#x2F;classes&quot; and I yearn for an example of how else to model a complex, domain-specific system <i>not</i> using the aforementioned tree.</div><br/><div id="36134775" class="c"><input type="checkbox" id="c-36134775" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134630">parent</a><span>|</span><a href="#36134894">next</a><span>|</span><label class="collapse" for="c-36134775">[-]</label><label class="expand" for="c-36134775">[1 more]</label></div><br/><div class="children"><div class="content">Not the author of the comment, but based on how I understand the comment, I feel essentially the same way.<p>I would characterize it a bit differently, seeing as, for example (and to your point), a purely functional lisp program is a tree of lambdas and macros. The same could be said of Haskell.<p>For me the issue is that classes and objects are actually pretty complicated things for what they are. It’s easy to not notice when you’re in the habit of using them, but really pause and think about how complicated they are. They have both structure and machinery that probably aren’t required for most abstractions: regardless, in OOP they get shoehorned into every problem.<p>This is why OOP ends up with a bunch of well known design patterns, whereas in FP they’re not reaaaaally a thing (arguably).<p>A tree of functions is probably the simplest possible way to build programs, at a fundamental level: I am not speaking in terms of individual preferences here, but really mathematical simplicity.</div><br/></div></div><div id="36134894" class="c"><input type="checkbox" id="c-36134894" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134630">parent</a><span>|</span><a href="#36134775">prev</a><span>|</span><a href="#36135365">next</a><span>|</span><label class="collapse" for="c-36134894">[-]</label><label class="expand" for="c-36134894">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a tree though.
A tree doesn&#x27;t have connected leaves and branches. This is, however, common with classes that might get injected the same dependency</div><br/><div id="36135413" class="c"><input type="checkbox" id="c-36135413" checked=""/><div class="controls bullet"><span class="by">el_oni</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134894">parent</a><span>|</span><a href="#36135365">next</a><span>|</span><label class="collapse" for="c-36135413">[-]</label><label class="expand" for="c-36135413">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like missing the tree for the forest. Im not from a pure cs background (so forgive my mangling of terms) but isnt a tree essentially an acyclic graph with constraints, 1 parent 2 children for example? What you&#x27;re describing is adding some cycles into that graph no?</div><br/></div></div></div></div><div id="36135365" class="c"><input type="checkbox" id="c-36135365" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134630">parent</a><span>|</span><a href="#36134894">prev</a><span>|</span><a href="#36134882">next</a><span>|</span><label class="collapse" for="c-36135365">[-]</label><label class="expand" for="c-36135365">[1 more]</label></div><br/><div class="children"><div class="content">The big difference between C# and F# styles (yes you can do either style in both languages, but with varying degrees of friction) is if that tree is mutable or immutable.</div><br/></div></div><div id="36134882" class="c"><input type="checkbox" id="c-36134882" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134630">parent</a><span>|</span><a href="#36135365">prev</a><span>|</span><a href="#36134742">next</a><span>|</span><label class="collapse" for="c-36134882">[-]</label><label class="expand" for="c-36134882">[1 more]</label></div><br/><div class="children"><div class="content">relational model, like we always did and do everyday (in the db realm)<p>i am not saying we should not use trees ever, i am mainly saying, when the model is a very deep tree (or several deep trees and trees everywhere), its becomes overly complex<p>data models should be as flat as possible , and only nested when absolutely necessary</div><br/></div></div><div id="36134742" class="c"><input type="checkbox" id="c-36134742" checked=""/><div class="controls bullet"><span class="by">heywhatupboys</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134630">parent</a><span>|</span><a href="#36134882">prev</a><span>|</span><a href="#36135114">next</a><span>|</span><label class="collapse" for="c-36134742">[-]</label><label class="expand" for="c-36134742">[3 more]</label></div><br/><div class="children"><div class="content">well you see! What we can do is to namespace our functions, e.g. by naming them component_create, component_add_button, etc. We then create a plain dictionary with key value pairs that gets passed onto these functions! The functions then possibly return a new map, which is a modified map! This allows us to write code like<p><pre><code>  dog = dog_create({name: &quot;foo&quot;, age: 12})
  dog = dod_add_friend(dog2)
  print(dog[&quot;friends&quot;])
</code></pre>
and we can avoid OO completely.<p>oh... wait a minute</div><br/><div id="36134786" class="c"><input type="checkbox" id="c-36134786" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134742">parent</a><span>|</span><a href="#36135587">next</a><span>|</span><label class="collapse" for="c-36134786">[-]</label><label class="expand" for="c-36134786">[1 more]</label></div><br/><div class="children"><div class="content">This comment shows a total misunderstanding of what functional programming is…</div><br/></div></div><div id="36135587" class="c"><input type="checkbox" id="c-36135587" checked=""/><div class="controls bullet"><span class="by">tigershark</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134742">parent</a><span>|</span><a href="#36134786">prev</a><span>|</span><a href="#36135114">next</a><span>|</span><label class="collapse" for="c-36135587">[-]</label><label class="expand" for="c-36135587">[1 more]</label></div><br/><div class="children"><div class="content">This tells me that you never really looked at functional languages, not even used them.
The power of ADT, especially when using a comprehensive pattern matching expression, is pretty difficult to emulate in the OOP world without a ton of code.
But in this extremely simple case you just need a record.<p><pre><code>    let dogBar = {Name = “bar”; Age = 11; Friends = []}
    let dogFoo = {Name = “foo”; Age = 12; Friends = [dogBar]}
    printfn “%A” dogFoo.Friends 
</code></pre>
The advantage is that it’s immutable and it’s guaranteed to don’t have null in any fields.
C# only introduced records recently, while F# was born with them.
And C# still hasn’t got ADT because it’s missing the Union types as far as I remember.</div><br/></div></div></div></div></div></div></div></div><div id="36135114" class="c"><input type="checkbox" id="c-36135114" checked=""/><div class="controls bullet"><span class="by">ThinkBeat</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134461">prev</a><span>|</span><a href="#36135354">next</a><span>|</span><label class="collapse" for="c-36135114">[-]</label><label class="expand" for="c-36135114">[1 more]</label></div><br/><div class="children"><div class="content">C# in its current state has IMHO acquired many features from F#.
You can get close to writing purely functional code in C# now.<p>I think with all the changes and extensions over time to add ever
more features to C# so you can write whatever paradigm you want in
it is a bad idea.<p>I would much have preferred to keep C# OO and use F# when you want
to go functional.<p>Or just create G# which is the everything mashed together language
that C# is close to being.</div><br/></div></div><div id="36135354" class="c"><input type="checkbox" id="c-36135354" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36135114">prev</a><span>|</span><a href="#36134991">next</a><span>|</span><label class="collapse" for="c-36135354">[-]</label><label class="expand" for="c-36135354">[4 more]</label></div><br/><div class="children"><div class="content">I used to write lots of C#, but now I consider it a bad ecosystem. The problem is the amount of ceremony, silly OOP abstractions, dependency injection, etc. Just look at building a simple HTTP endpoint in C# compared to Node or even F#!</div><br/><div id="36135452" class="c"><input type="checkbox" id="c-36135452" checked=""/><div class="controls bullet"><span class="by">rawling</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135354">parent</a><span>|</span><a href="#36135503">next</a><span>|</span><label class="collapse" for="c-36135452">[-]</label><label class="expand" for="c-36135452">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Just look at building a simple HTTP endpoint in C# compared to Node or even F#!<p>It&#x27;s... basically the same? Include library, create server object, tell server object what request to handle and what to return, start server object.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;fundamentals&#x2F;minimal-apis?view=aspnetcore-7.0" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;fundamentals&#x2F;m...</a></div><br/><div id="36135526" class="c"><input type="checkbox" id="c-36135526" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135452">parent</a><span>|</span><a href="#36135503">next</a><span>|</span><label class="collapse" for="c-36135526">[-]</label><label class="expand" for="c-36135526">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you can get away with minimal C# stuff if you want. Mind you minimal API&#x27;s is a relatively new thing as of NetCore 6 so GP might not have had the chance to touch these new things yet.<p>Much of the older overdesigned pain of C# is that it used to be tied to how IIS wanted things to work, NetCore initially pivoted more to DI stuff before pivoting again to these minimal API&#x27;s but the DI stuff is definitely available(and used) still.<p>For pragmatic choices it&#x27;s all there, you can start off with minimal API&#x27;s and get far with it and once you start feeling pain-points as you want to re-implement things it might be time to add in the more &quot;frameworky&quot; parts.</div><br/></div></div></div></div><div id="36135503" class="c"><input type="checkbox" id="c-36135503" checked=""/><div class="controls bullet"><span class="by">michielr</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36135354">parent</a><span>|</span><a href="#36135452">prev</a><span>|</span><a href="#36134991">next</a><span>|</span><label class="collapse" for="c-36135503">[-]</label><label class="expand" for="c-36135503">[1 more]</label></div><br/><div class="children"><div class="content">I agree this was a problem, but with the current Minimal API&#x27;s, there is no boilerplate, looks a lot like Express to me!<p><pre><code>  var builder = WebApplication.CreateBuilder(args);
  var app = builder.Build();
  app.MapGet(&quot;&#x2F;&quot;, () =&gt; &quot;Hello World!&quot;);
  app.Run();</code></pre></div><br/></div></div></div></div><div id="36134991" class="c"><input type="checkbox" id="c-36134991" checked=""/><div class="controls bullet"><span class="by">caseysoftware</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36135354">prev</a><span>|</span><a href="#36134634">next</a><span>|</span><label class="collapse" for="c-36134991">[-]</label><label class="expand" for="c-36134991">[1 more]</label></div><br/><div class="children"><div class="content">Another &quot;blast from the past&quot; for me too..<p>Your &quot;career calculus&quot; article has been top of mind for me recently as I&#x27;ve talked about it a bunch of people. Amusing how those core concepts don&#x27;t change much.</div><br/></div></div><div id="36134634" class="c"><input type="checkbox" id="c-36134634" checked=""/><div class="controls bullet"><span class="by">CrimsonCape</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134991">prev</a><span>|</span><a href="#36134815">next</a><span>|</span><label class="collapse" for="c-36134634">[-]</label><label class="expand" for="c-36134634">[3 more]</label></div><br/><div class="children"><div class="content">If you had to chose right now and abandon the other, would you pick LINQ or discriminated unions?</div><br/><div id="36134888" class="c"><input type="checkbox" id="c-36134888" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134634">parent</a><span>|</span><a href="#36134815">next</a><span>|</span><label class="collapse" for="c-36134888">[-]</label><label class="expand" for="c-36134888">[2 more]</label></div><br/><div class="children"><div class="content">Not OP but I would choose discriminated unions.<p>Why? because Linq is basically just syntactic sugar for regular IEnumerable methods, while discriminated unions have no equivalent at all.<p>Even if you wanted to claim that those IEnumerable methods ARE linq, then it would still be possible to implement them with a library while discriminated unions have to be a compiler feature.</div><br/><div id="36135383" class="c"><input type="checkbox" id="c-36135383" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134888">parent</a><span>|</span><a href="#36134815">next</a><span>|</span><label class="collapse" for="c-36135383">[-]</label><label class="expand" for="c-36135383">[1 more]</label></div><br/><div class="children"><div class="content">Yep, Linq could be replaced by the more general Computation Expressions in F#</div><br/></div></div></div></div></div></div><div id="36134815" class="c"><input type="checkbox" id="c-36134815" checked=""/><div class="controls bullet"><span class="by">mastazi</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134634">prev</a><span>|</span><a href="#36134442">next</a><span>|</span><label class="collapse" for="c-36134815">[-]</label><label class="expand" for="c-36134815">[2 more]</label></div><br/><div class="children"><div class="content">Also, you correctly anticipated that Swift would become mainstream long before F#, which happened. Of course hindsight is 20&#x2F;20, but this wasn&#x27;t that obvious back in 2015. Your reasoning was sound.</div><br/><div id="36135763" class="c"><input type="checkbox" id="c-36135763" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36134212">root</a><span>|</span><a href="#36134815">parent</a><span>|</span><a href="#36134442">next</a><span>|</span><label class="collapse" for="c-36135763">[-]</label><label class="expand" for="c-36135763">[1 more]</label></div><br/><div class="children"><div class="content">Swift is still very much a niche language. Its a big niche, but niche nevertheless.</div><br/></div></div></div></div><div id="36134442" class="c"><input type="checkbox" id="c-36134442" checked=""/><div class="controls bullet"><span class="by">Andys</span><span>|</span><a href="#36134212">parent</a><span>|</span><a href="#36134815">prev</a><span>|</span><a href="#36133371">next</a><span>|</span><label class="collapse" for="c-36134442">[-]</label><label class="expand" for="c-36134442">[1 more]</label></div><br/><div class="children"><div class="content">Seeing your name pop up was a blast from the past for me too - I used to read back in the &quot;The Business of Software&quot; days.. circa 2005 I think?</div><br/></div></div></div></div><div id="36133371" class="c"><input type="checkbox" id="c-36133371" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36134212">prev</a><span>|</span><a href="#36133830">next</a><span>|</span><label class="collapse" for="c-36133371">[-]</label><label class="expand" for="c-36133371">[50 more]</label></div><br/><div class="children"><div class="content">This is a nicely written essay and, I think, completely wrong.  (One person&#x27;s experience here, just as a disclaimer.)<p>I&#x27;ve interviewed a lot of functional candidates in a decade-long stint of functional programming professionally.  My interview approach is always the same.  All practical exercises, no leetcode here.  You can do the exercises in the language you&#x27;re most comfortable in.<p>If I had to pick a language that predicted you&#x27;ll do poorly on a practical interview exercise, I would pick F# every time.  For some reason the candidates just do not do well.  Now I can think of some confounders - maybe the types of people who would apply to a job with some dynamic programming requirements and people who are good at F# just have no overlap.  I&#x27;ve thought about that.<p>But it seems like this line<p><pre><code>    Pragmatists don&#x27;t make technology decisions on the basis of what is better. They prefer the safety of the herd.
</code></pre>
Implies that if someone just saw some code in F# and realized what people can do in it, they would be super impressed.  I have not found that to be the case.  If that&#x27;s a general problem and not just a quirk of my personal experience, that has to be fixed first.</div><br/><div id="36133772" class="c"><input type="checkbox" id="c-36133772" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36134429">next</a><span>|</span><label class="collapse" for="c-36133772">[-]</label><label class="expand" for="c-36133772">[10 more]</label></div><br/><div class="children"><div class="content">I think F# programmers lack that gamut because they get comfortable in the eager execution type safe world and stay there with no particular reason to learn dynamic programming techniques. There is also the effect that it allows less advanced functional programmers to be productive so that in randomly sampling currently active functional programmers the F# programmer is less likely to be advanced.<p>Scala developers were referred to a Java refugees, Swift developers to Objective C refugees, and F# as C# refugees. A weird side effect of Microsoft doing a better job with C# is that there less of a push to F#. Plus F# by virtue of being in Dev Div had the core value proposition (Ocaml on .Net) undermined by the Win vs Dev Div internal battles that tried and failed to kill .Net.</div><br/><div id="36135924" class="c"><input type="checkbox" id="c-36135924" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133772">parent</a><span>|</span><a href="#36133888">next</a><span>|</span><label class="collapse" for="c-36135924">[-]</label><label class="expand" for="c-36135924">[1 more]</label></div><br/><div class="children"><div class="content">They keep trying to kill .NET, just check how much WinDev keeps doubling on COM and pushing subpar frameworks like C++&#x2F;WinRT.<p>One would expect that by now, out-of-process COM would be supported across all OS extension points, instead it is still pretty much in-process COM, with the related .NET restrictions.<p>Then there is the whole issue that since Longhorn, most OS APIs are based on COM (or WinRT), not always with .NET bindings, and even VB 6 had better ways to use COM than .NET on its current state (.NET Core lost COM tooling).</div><br/></div></div><div id="36133888" class="c"><input type="checkbox" id="c-36133888" checked=""/><div class="controls bullet"><span class="by">JoeyJoJoJr</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133772">parent</a><span>|</span><a href="#36135924">prev</a><span>|</span><a href="#36134429">next</a><span>|</span><label class="collapse" for="c-36133888">[-]</label><label class="expand" for="c-36133888">[8 more]</label></div><br/><div class="children"><div class="content">I have been programming for 20 years, and yet despite having used dynamic languages I don’t actually know what it means to leverage dynamic programming techniques. For instance, I’ve never encountered a JavaScript codebase that I have thought couldn’t benefit from just being statically typed with Typescript. I get the impression that dynamic programming, besides the odd untyped line of code, is best used only for extremely specific cases?</div><br/><div id="36134227" class="c"><input type="checkbox" id="c-36134227" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133888">parent</a><span>|</span><a href="#36133932">next</a><span>|</span><label class="collapse" for="c-36134227">[-]</label><label class="expand" for="c-36134227">[1 more]</label></div><br/><div class="children"><div class="content">The problem is the word dynamic is overloaded, and I&#x27;m not at all sure which one your parent comment meant.<p>&quot;Dynamic programming&quot; traditionally has nothing to do with dynamic languages but is instead a class of algorithms that are &quot;dynamic&quot; in the sense that they represent time.[0] This might be what your parent was referring to because these algorithms lend themselves well to Haskell&#x27;s lazy evaluation, and they reference F# as being eager.<p>That said, they also talk about F# as being type safe, so they could also be referring to dynamic programming languages. The grandparent was definitely referring to this one, but &quot;dynamic programming techniques&quot; sounds much more like the algorithmic meaning.<p>[0] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming</a></div><br/></div></div><div id="36133932" class="c"><input type="checkbox" id="c-36133932" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133888">parent</a><span>|</span><a href="#36134227">prev</a><span>|</span><a href="#36134057">next</a><span>|</span><label class="collapse" for="c-36133932">[-]</label><label class="expand" for="c-36133932">[1 more]</label></div><br/><div class="children"><div class="content">To be clear I wasn&#x27;t referring &#x27;dynamic programming&#x27; but as you say, the use of a dynamic language, or programming without types, mimicking what I assumed the original poster I replied to meant.<p>My guess is that interviewees wishing to return to the typed world they are comfortable with would first try to type the JSON they are working with. Given that the JSON is messy this could be an unbounded amount of work that is unlikely to pay-off within the span of an interview.</div><br/></div></div><div id="36134057" class="c"><input type="checkbox" id="c-36134057" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133888">parent</a><span>|</span><a href="#36133932">prev</a><span>|</span><a href="#36134429">next</a><span>|</span><label class="collapse" for="c-36134057">[-]</label><label class="expand" for="c-36134057">[5 more]</label></div><br/><div class="children"><div class="content">There is much naïveté among the strongly typed herd.  When tasked to create glue code translating between two opposing type systems, which is a very common data engineering task, reaching for a strongly typed language is never the best option for code complexity and speed of development.  Yet the hammer will often succeed if you hit hard enough and club the nail back to shape when you invariably bend it.</div><br/><div id="36134204" class="c"><input type="checkbox" id="c-36134204" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134057">parent</a><span>|</span><a href="#36135422">next</a><span>|</span><label class="collapse" for="c-36134204">[-]</label><label class="expand" for="c-36134204">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    There is much naïveté among the strongly typed herd.
</code></pre>
Is exactly the reverse also true?  Let me try: &quot;There is much naïveté among the weakly typed herd.&quot;  For every person who thinks Python or Ruby can be used for everything, there is another person who thinks the same for C++ or Rust.<p>Also, the example that you gave is incredibly specific:<p><pre><code>    When tasked to create glue code translating between two opposing type systems, which is a very common data engineering task
</code></pre>
Can you provide a concrete example?  And what is &quot;data engineering&quot;?  I never heard that term before this post.</div><br/><div id="36134372" class="c"><input type="checkbox" id="c-36134372" checked=""/><div class="controls bullet"><span class="by">Hasnep</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134204">parent</a><span>|</span><a href="#36134624">next</a><span>|</span><label class="collapse" for="c-36134372">[-]</label><label class="expand" for="c-36134372">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a data engineer, it&#x27;s a fairly new role so it&#x27;s not well defined yet, but most data engineers write data pipelines to ingest data into a data warehouse and then transform it for the business to use.<p>I&#x27;m not sure why using a static language would make translating data types difficult, but I add as many typehints as possible to my Python so I rarely do anything with dynamic types. I guess they&#x27;re saying for small tasks where you&#x27;re working with lots of types, when using a static language most of your code will be type definitions, so a dynamic language will let you focus on writing the transformation code.</div><br/></div></div><div id="36134624" class="c"><input type="checkbox" id="c-36134624" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134204">parent</a><span>|</span><a href="#36134372">prev</a><span>|</span><a href="#36135422">next</a><span>|</span><label class="collapse" for="c-36134624">[-]</label><label class="expand" for="c-36134624">[1 more]</label></div><br/><div class="children"><div class="content">If you are truly interested in understanding my point of view -- a great way to do it would be to learn how to use this Clojure DSL:  <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;specter">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;specter</a>
You could also think about why Nathan Marz may have bothered to create it.
As for data engineering, I think ChatGPT could tell you <i>a lot</i>, and its training is dated from 2021.</div><br/></div></div></div></div><div id="36135422" class="c"><input type="checkbox" id="c-36135422" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134057">parent</a><span>|</span><a href="#36134204">prev</a><span>|</span><a href="#36134429">next</a><span>|</span><label class="collapse" for="c-36135422">[-]</label><label class="expand" for="c-36135422">[1 more]</label></div><br/><div class="children"><div class="content">I have found that types are a benefit when it comes to debugging complex data systems because it moves component failures closer to the root cause.<p>Relevant blog post is Parse don&#x27;t Verify</div><br/></div></div></div></div></div></div></div></div><div id="36134429" class="c"><input type="checkbox" id="c-36134429" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133772">prev</a><span>|</span><a href="#36134140">next</a><span>|</span><label class="collapse" for="c-36134429">[-]</label><label class="expand" for="c-36134429">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s weird. I use F# <i>because</i> of its pragmaticism. Every other language tacks on feature after feature. I would say my F# code is boring, which is what I love about F#. And it&#x27;s especially boring compared to other functional languages. The other pragmatic functional languages are Erlang and Elixir.<p>I would consider most popular languages, like C#, Java, and Python decidely unpragmatic as languages. There&#x27;s way too many hoops to jump through to concisely describe the problem domain. In F#, I define some types that describe the domain, write some functions, and move on. It&#x27;s that easy.</div><br/></div></div><div id="36134140" class="c"><input type="checkbox" id="c-36134140" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36134429">prev</a><span>|</span><a href="#36134024">next</a><span>|</span><label class="collapse" for="c-36134140">[-]</label><label class="expand" for="c-36134140">[1 more]</label></div><br/><div class="children"><div class="content">Really?<p>In my experience, the worst performance is by C++ candidates.<p>Why? Not because C++ is bad, or attracts bad programmers.<p>Rather, because if that&#x27;s the language you reach for a quick solve, you probably don&#x27;t know very much, and that says something.</div><br/></div></div><div id="36134024" class="c"><input type="checkbox" id="c-36134024" checked=""/><div class="controls bullet"><span class="by">bloaf</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36134140">prev</a><span>|</span><a href="#36133485">next</a><span>|</span><label class="collapse" for="c-36134024">[-]</label><label class="expand" for="c-36134024">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, because I&#x27;ve tried to use F# several times, and never really felt comfortable.  I&#x27;ve written in a bunch of different languages and F# is probably the most disappointing because of how much I want to like it.<p>I feel like F# deceptively presents itself as simple, when in reality it is closer to C# in complexity.  I&#x27;ve written in languages that are actually simple (tcl) and it is a joy.  I&#x27;ve written in languages that are unashamedly complex (Wolfram language) and that is also fun.  But F# occupies that weird middle ground where it <i>seems</i> easy to do what you want, but for some reason you trip over your own shoelaces every time you take a step.</div><br/><div id="36134152" class="c"><input type="checkbox" id="c-36134152" checked=""/><div class="controls bullet"><span class="by">AdeptusAquinas</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134024">parent</a><span>|</span><a href="#36134341">next</a><span>|</span><label class="collapse" for="c-36134152">[-]</label><label class="expand" for="c-36134152">[4 more]</label></div><br/><div class="children"><div class="content">I wrote F# for a long time, and there were definite phases to learning and becoming comfortable with it. For example, it&#x27;s often pitched as a functional language but in reality its a functional-first hybrid language on the .NET framework - to be efficient with it is to embrace this and write imperatively when you need to.<p>Pure syntax wise, its pretty nice, though having a single pass compiler makes it a bit dated feeling compared to other languages.</div><br/><div id="36134191" class="c"><input type="checkbox" id="c-36134191" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134152">parent</a><span>|</span><a href="#36134341">next</a><span>|</span><label class="collapse" for="c-36134191">[-]</label><label class="expand" for="c-36134191">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    though having a single pass compiler makes it a bit dated feeling compared to other languages
</code></pre>
Can you please share how F# could improve with a multi-pass compiler?</div><br/><div id="36134390" class="c"><input type="checkbox" id="c-36134390" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134191">parent</a><span>|</span><a href="#36134341">next</a><span>|</span><label class="collapse" for="c-36134390">[-]</label><label class="expand" for="c-36134390">[2 more]</label></div><br/><div class="children"><div class="content">You could have out of order function declarations.</div><br/><div id="36134437" class="c"><input type="checkbox" id="c-36134437" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134390">parent</a><span>|</span><a href="#36134341">next</a><span>|</span><label class="collapse" for="c-36134437">[-]</label><label class="expand" for="c-36134437">[1 more]</label></div><br/><div class="children"><div class="content">Forcing linear dependence of files and definitions is considered a feature of F#. In codebases that allow out of order definitions, things get wild real quick.</div><br/></div></div></div></div></div></div></div></div><div id="36134341" class="c"><input type="checkbox" id="c-36134341" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134024">parent</a><span>|</span><a href="#36134152">prev</a><span>|</span><a href="#36133485">next</a><span>|</span><label class="collapse" for="c-36134341">[-]</label><label class="expand" for="c-36134341">[2 more]</label></div><br/><div class="children"><div class="content">Ergonomics matter<p>F# always came across as very weird in the syntax area</div><br/><div id="36134729" class="c"><input type="checkbox" id="c-36134729" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36134341">parent</a><span>|</span><a href="#36133485">next</a><span>|</span><label class="collapse" for="c-36134729">[-]</label><label class="expand" for="c-36134729">[1 more]</label></div><br/><div class="children"><div class="content">Each to his&#x2F;her own. I&#x27;ve been programming since the 80s and still find C and C-style languages the weirdest of all.</div><br/></div></div></div></div></div></div><div id="36133485" class="c"><input type="checkbox" id="c-36133485" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36134024">prev</a><span>|</span><a href="#36136018">next</a><span>|</span><label class="collapse" for="c-36133485">[-]</label><label class="expand" for="c-36133485">[4 more]</label></div><br/><div class="children"><div class="content">I disagree on almost every count: it&#x27;s a badly written essay, but it makes a valid point.<p>&gt; I&#x27;ve interviewed a lot of functional candidates in a decade-long stint of functional programming professionally. My interview approach is always the same. All practical exercises, no leetcode here.<p>Does this mean that you&#x27;re measuring, like, how fast someone can deploy a CRUD webapp in the given language? I can imagine F# would do poorly on that kind of metric; it&#x27;s optimized for maintainability and doesn&#x27;t take unprincipled shortcuts, whereas something like Ruby lets you type one line and it will blat out a bunch of defaults via unmaintainable magic.<p>&gt; Implies that if someone just saw some code in F# and realized what people can do in it, they would be super impressed. I have not found that to be the case. If that&#x27;s a general problem and not just a quirk of my personal experience, that has to be fixed first.<p>I don&#x27;t think it&#x27;s a general problem; almost everyone who spends any significant time working in F# returns to C# reluctantly if at all. It&#x27;s already a &quot;better&quot; language in the sense of how nice it is to program in and how productive a programmer feels when doing so. But those aren&#x27;t the metrics that matter.</div><br/><div id="36133859" class="c"><input type="checkbox" id="c-36133859" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133485">parent</a><span>|</span><a href="#36136018">next</a><span>|</span><label class="collapse" for="c-36133859">[-]</label><label class="expand" for="c-36133859">[3 more]</label></div><br/><div class="children"><div class="content">Rails has generators you’re talking about not ruby, and I’ve seen and worked on some very maintainable rails apps.</div><br/><div id="36133913" class="c"><input type="checkbox" id="c-36133913" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133859">parent</a><span>|</span><a href="#36136018">next</a><span>|</span><label class="collapse" for="c-36133913">[-]</label><label class="expand" for="c-36133913">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rails has generators you’re talking about not ruby<p>They may not be built into Ruby-the-language but they&#x27;re very much part of Ruby-the-development-community.<p>&gt; I’ve seen and worked on some very maintainable rails apps<p>I&#x27;ve seen far more upgrade breakages in apps built on rails than any other stack.</div><br/><div id="36134698" class="c"><input type="checkbox" id="c-36134698" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133913">parent</a><span>|</span><a href="#36136018">next</a><span>|</span><label class="collapse" for="c-36134698">[-]</label><label class="expand" for="c-36134698">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve seen far more upgrade breakages in apps built on rails than any other stack.<p>React Native would like to argue with you on that point</div><br/></div></div></div></div></div></div></div></div><div id="36136018" class="c"><input type="checkbox" id="c-36136018" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133485">prev</a><span>|</span><a href="#36133413">next</a><span>|</span><label class="collapse" for="c-36136018">[-]</label><label class="expand" for="c-36136018">[1 more]</label></div><br/><div class="children"><div class="content">There should be a thing call &quot;Yeetcode&quot; that rewards you for deleting as much code as you can and still solving the problem.</div><br/></div></div><div id="36133413" class="c"><input type="checkbox" id="c-36133413" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36136018">prev</a><span>|</span><a href="#36133550">next</a><span>|</span><label class="collapse" for="c-36133413">[-]</label><label class="expand" for="c-36133413">[11 more]</label></div><br/><div class="children"><div class="content">I found F# great for dynamic programming, do you recall what tripped them up?</div><br/><div id="36133560" class="c"><input type="checkbox" id="c-36133560" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133413">parent</a><span>|</span><a href="#36133550">next</a><span>|</span><label class="collapse" for="c-36133560">[-]</label><label class="expand" for="c-36133560">[10 more]</label></div><br/><div class="children"><div class="content">Parsing realistic (messy) JSON, usually.  I would have expected F# to shine at that due to type providers, so it was doubly surprising to me.  The F# candidates I&#x27;ve seen spend most of the interview manipulating the data.</div><br/><div id="36133690" class="c"><input type="checkbox" id="c-36133690" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133706">next</a><span>|</span><label class="collapse" for="c-36133690">[-]</label><label class="expand" for="c-36133690">[1 more]</label></div><br/><div class="children"><div class="content">This is likely because people don&#x27;t have enough real-world experience with functional programming paradigm techniques like &#x27;parse, don&#x27;t validate&#x27; and modelling only the parts needed to handle dynamic input, e.g. as shown here <a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;01&#x2F;19&#x2F;no-dynamic-type-systems-are-not-inherently-more-open&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;01&#x2F;19&#x2F;no-dynamic-typ...</a><p>It&#x27;s unfortunate that they decided to pick F# on such problems when they didn&#x27;t have the (mental) toolkit to tackle them, but I think it speaks more to people being really eager to communicate their enthusiasm for FP. I wouldn&#x27;t try to ascribe any higher meaning to it.</div><br/></div></div><div id="36133706" class="c"><input type="checkbox" id="c-36133706" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133690">prev</a><span>|</span><a href="#36133907">next</a><span>|</span><label class="collapse" for="c-36133706">[-]</label><label class="expand" for="c-36133706">[2 more]</label></div><br/><div class="children"><div class="content">TypeProviders don&#x27;t do well with messy JSON and are finicky at the best of time, the last thing I&#x27;d rely on during an interview.<p>Depends on what you mean by messy? Non-conforming JSON? A custom FParsec parser might be able to sensibly extract the data. If it is conforming to JSON then you&#x27;d use normal F# code to work with the standard JSON parsers.</div><br/><div id="36133767" class="c"><input type="checkbox" id="c-36133767" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133706">parent</a><span>|</span><a href="#36133907">next</a><span>|</span><label class="collapse" for="c-36133767">[-]</label><label class="expand" for="c-36133767">[1 more]</label></div><br/><div class="children"><div class="content">It’s syntactically valid JSON.</div><br/></div></div></div></div><div id="36133907" class="c"><input type="checkbox" id="c-36133907" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133706">prev</a><span>|</span><a href="#36133695">next</a><span>|</span><label class="collapse" for="c-36133907">[-]</label><label class="expand" for="c-36133907">[1 more]</label></div><br/><div class="children"><div class="content">I find I spend a lot of time building records for JSON data. Type providers are nice but I&#x27;ve found them to be a little untrustworthy.<p>Normally now I ask Chat GPT to create an F# record from the JSON. Then go through and check everything line by line, redo the types to something sane and use that.<p>But if it were a quick script to do a one off then a type provider will work well.</div><br/></div></div><div id="36133695" class="c"><input type="checkbox" id="c-36133695" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133907">prev</a><span>|</span><a href="#36133627">next</a><span>|</span><label class="collapse" for="c-36133695">[-]</label><label class="expand" for="c-36133695">[1 more]</label></div><br/><div class="children"><div class="content">This is, from a distance, fascinating anecdata. I would expect F# itself to excel in this area (type oriented development being a huge selling point), and people who’ve chosen it to be attracted to those parts of F# which should excel for it. I’m often surprised when my at-a-distance expectations don’t meet reality, but not so often astonished by it.</div><br/></div></div><div id="36133627" class="c"><input type="checkbox" id="c-36133627" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133695">prev</a><span>|</span><a href="#36133771">next</a><span>|</span><label class="collapse" for="c-36133627">[-]</label><label class="expand" for="c-36133627">[1 more]</label></div><br/><div class="children"><div class="content">Those F# candidates would have been be better to use C# to do the adhoc data wrangling and F# for algorithmic part of the program.</div><br/></div></div><div id="36133771" class="c"><input type="checkbox" id="c-36133771" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133627">prev</a><span>|</span><a href="#36133667">next</a><span>|</span><label class="collapse" for="c-36133771">[-]</label><label class="expand" for="c-36133771">[2 more]</label></div><br/><div class="children"><div class="content">How messy is the JSON exactly? Type providers are awesome when the schema is consistent.<p>But tbh, from what little I know, I&#x27;d be expecting you to expect me to solve the issue from first principles. So using a &quot;and then magic&quot; technique might be something interviewees shy from.</div><br/><div id="36134430" class="c"><input type="checkbox" id="c-36134430" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133771">parent</a><span>|</span><a href="#36133667">next</a><span>|</span><label class="collapse" for="c-36134430">[-]</label><label class="expand" for="c-36134430">[1 more]</label></div><br/><div class="children"><div class="content">Hahaha, &quot;when the schema is consistent&quot;.  The strong typing herd keeps thinking it can smash reality into a square hole.</div><br/></div></div></div></div><div id="36133667" class="c"><input type="checkbox" id="c-36133667" checked=""/><div class="controls bullet"><span class="by">throwa18991900</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133560">parent</a><span>|</span><a href="#36133771">prev</a><span>|</span><a href="#36133550">next</a><span>|</span><label class="collapse" for="c-36133667">[-]</label><label class="expand" for="c-36133667">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen the opposite, and have seen some pretty big fast large professional systems being built in it. Admittedly most of them are closed source, and the community contribution allowed to be made is small. Most of the developers using it normally just market themselves as C# developers when they change job because of some of the above opinions they see online. Have seen speed comparisons compared to other similar tiered languages internally where F# shines with less code as well particuarly around math (C# is just starting to catch up here). Even seen dynamic problems solved in it to your point in a professional setting to speed up very often run calculations to a large customer base.<p>However technical capability and efficiency of the tool isn&#x27;t the only concern picking up the comments in this thread so far. The herd effect sadly can make people nervous creating a barrier for people to try it especially if career is in it. What other people think of it, and their preconceived notion can matter.</div><br/></div></div></div></div></div></div><div id="36133550" class="c"><input type="checkbox" id="c-36133550" checked=""/><div class="controls bullet"><span class="by">jacamera</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133413">prev</a><span>|</span><a href="#36133843">next</a><span>|</span><label class="collapse" for="c-36133550">[-]</label><label class="expand" for="c-36133550">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to know what dynamic programming exercises you&#x27;re asking interviewees to complete in the timespan of an interview that wouldn&#x27;t show up on LeetCode.</div><br/><div id="36133575" class="c"><input type="checkbox" id="c-36133575" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133550">parent</a><span>|</span><a href="#36133578">next</a><span>|</span><label class="collapse" for="c-36133575">[-]</label><label class="expand" for="c-36133575">[1 more]</label></div><br/><div class="children"><div class="content">I think they meant it in the literal sense; &quot;programming requirements that are dynamic&quot;, not dynamic programming algorithms you&#x27;d use for the knapsack problem :)</div><br/></div></div><div id="36133578" class="c"><input type="checkbox" id="c-36133578" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133550">parent</a><span>|</span><a href="#36133575">prev</a><span>|</span><a href="#36133843">next</a><span>|</span><label class="collapse" for="c-36133578">[-]</label><label class="expand" for="c-36133578">[4 more]</label></div><br/><div class="children"><div class="content">It involves a lot of preparation on my part.  The ask for the candidate is usually a small service that does some trivial thing in our business domain.  The interview problem is usually making a script to manipulate the data, or serve an API endpoint that calls my API and transform the data to match a certain output shape.</div><br/><div id="36133648" class="c"><input type="checkbox" id="c-36133648" checked=""/><div class="controls bullet"><span class="by">jacamera</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133578">parent</a><span>|</span><a href="#36133843">next</a><span>|</span><label class="collapse" for="c-36133648">[-]</label><label class="expand" for="c-36133648">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. So is actually executing the script, server, or API call without errors part of the interview? Is that what makes them &quot;practical&quot; or is it because the data structures and algorithms are related to your business domain?<p>Not trying to nitpick, your comment just piqued my curiosity because you made the point of distinguishing your exercises from leetcode and also stated that those who chose F# were generally poor performers.</div><br/><div id="36133755" class="c"><input type="checkbox" id="c-36133755" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133648">parent</a><span>|</span><a href="#36133843">next</a><span>|</span><label class="collapse" for="c-36133755">[-]</label><label class="expand" for="c-36133755">[2 more]</label></div><br/><div class="children"><div class="content">It is, but I’m very forgiving of scripts&#x2F;services that don’t run right the first time if it’s clear the logic is on the right track.  If your logic is sound and you’re stuck on an esoteric error, I usually count that the same as completing the exercise.  (There have been cases where the person shows no debugging ability at all, which I do treat as a problem.  But if you’re reading the error and there’s just not enough time for a fix, eh you were close enough.)</div><br/><div id="36134781" class="c"><input type="checkbox" id="c-36134781" checked=""/><div class="controls bullet"><span class="by">listenallyall</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133755">parent</a><span>|</span><a href="#36133843">next</a><span>|</span><label class="collapse" for="c-36134781">[-]</label><label class="expand" for="c-36134781">[1 more]</label></div><br/><div class="children"><div class="content">jacamera is on point. Perhaps it&#x27;s not &quot;leetcode&quot; but it&#x27;s a seemingly one-dimensional, time-constrained quiz on a specific skill, parsing messy JSON (your words), with you as the sole judge. Personally from experience, when I approach a new API, I recognize it&#x27;s likely to take a few iterations, based on how that API&#x27;s data integrates with the rest of my program, to determine the best way to deserialize the API&#x27;s responses into objects. If I&#x27;ve only got 45 minutes, yea, I&#x27;m just going to map it quick and dirty and it&#x27;s going to look ugly.<p>Your observation about F# may be valid, but this does appear to be a test of one specific use case for a language, not how productive people are when building entire applications with them.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36133843" class="c"><input type="checkbox" id="c-36133843" checked=""/><div class="controls bullet"><span class="by">Fervicus</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133550">prev</a><span>|</span><a href="#36133873">next</a><span>|</span><label class="collapse" for="c-36133843">[-]</label><label class="expand" for="c-36133843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Implies that if someone just saw some code in F# and realized what people can do in it, they would be super impressed. I have not found that to be the case. If that&#x27;s a general problem and not just a quirk of my personal experience, that has to be fixed first.<p>Maybe I am mistaken here, but it seems to me that the line you are quoting from the essay implies the opposite of what you said.</div><br/></div></div><div id="36133873" class="c"><input type="checkbox" id="c-36133873" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133843">prev</a><span>|</span><a href="#36133995">next</a><span>|</span><label class="collapse" for="c-36133873">[-]</label><label class="expand" for="c-36133873">[3 more]</label></div><br/><div class="children"><div class="content">&gt;If I had to pick a language that predicted you&#x27;ll do poorly on a practical interview exercise, I would pick F# every time<p>As someone that has just spent a while learning F# and really enjoys it, this makes me sad. I hope that I don&#x27;t have some trait that drew me to F# that also causes me to be less competent.</div><br/><div id="36134356" class="c"><input type="checkbox" id="c-36134356" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133873">parent</a><span>|</span><a href="#36134986">next</a><span>|</span><label class="collapse" for="c-36134356">[-]</label><label class="expand" for="c-36134356">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be sad. This is definitely a skewed perspective from a single person which makes it worse than useless as a way to gauge a random persons competence.<p>I&#x27;m sure you could find a person who would claim this same exact thing for any language if you searched around a bit.<p>To derive a useful conclusion you would need to control for all of the factors involved in the interviews and objectively measure their performance compared to other people&#x27;s, anything less than that is completely useless at best.</div><br/></div></div><div id="36134986" class="c"><input type="checkbox" id="c-36134986" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133873">parent</a><span>|</span><a href="#36134356">prev</a><span>|</span><a href="#36133995">next</a><span>|</span><label class="collapse" for="c-36134986">[-]</label><label class="expand" for="c-36134986">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think you have any good reason to think you’re inherently less competent.<p>The most important thing is to always be learning. You’ll never be done, embrace that and rejoice in it. Most people more or less stop learning in early adulthood: don’t do that, and you’ll eventually be ahead of the pack.</div><br/></div></div></div></div><div id="36133995" class="c"><input type="checkbox" id="c-36133995" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133873">prev</a><span>|</span><a href="#36133474">next</a><span>|</span><label class="collapse" for="c-36133995">[-]</label><label class="expand" for="c-36133995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They prefer the safety of the herd<p>I.e. social proof</div><br/></div></div><div id="36133474" class="c"><input type="checkbox" id="c-36133474" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133995">prev</a><span>|</span><a href="#36134566">next</a><span>|</span><label class="collapse" for="c-36133474">[-]</label><label class="expand" for="c-36133474">[2 more]</label></div><br/><div class="children"><div class="content">Are you implying this is a F# problem? What language do candidates do well in?<p>Is F# too approachable due to its closeness to C#, popular with C# professionals, and therefore not approached as a functional programming language as much as a C# extension?</div><br/><div id="36133544" class="c"><input type="checkbox" id="c-36133544" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#36133371">root</a><span>|</span><a href="#36133474">parent</a><span>|</span><a href="#36134566">next</a><span>|</span><label class="collapse" for="c-36133544">[-]</label><label class="expand" for="c-36133544">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen Elixir, Python, Javascript, Java, Scala, Clojure, C#, Go, and more; not sure who is at the top, but F# is 100% at the bottom (just in my personal experience.)  I wouldn&#x27;t chalk it up to being too approachable.</div><br/></div></div></div></div><div id="36134566" class="c"><input type="checkbox" id="c-36134566" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36133371">parent</a><span>|</span><a href="#36133474">prev</a><span>|</span><a href="#36133830">next</a><span>|</span><label class="collapse" for="c-36134566">[-]</label><label class="expand" for="c-36134566">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if that is because people who pick obscure languages are more interested in looking cool than getting the job done.<p>Like in an interview setting, even if they say you can choose any language, it is probably a safer bet to go with something the interviewer has probably seen before.</div><br/></div></div></div></div><div id="36133830" class="c"><input type="checkbox" id="c-36133830" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133371">prev</a><span>|</span><a href="#36133775">next</a><span>|</span><label class="collapse" for="c-36133830">[-]</label><label class="expand" for="c-36133830">[5 more]</label></div><br/><div class="children"><div class="content">I love F#, I use it professionally. But I agree with everything written in this post. I hate that F# is not a safe choice yet. I wish that it were but it doesn&#x27;t have the critical mass. That means hiring others is not going to be as easy as finding an existing F# developer.<p>Functional programing is different. I don&#x27;t think it&#x27;s hard but it&#x27;s not what most developers have spent years practicing. So there is a learning curve to get over.<p>Critical mass is a problem for all new languages and often it&#x27;s not the best language that will win critical mass. It&#x27;s the one that gets adopted for reasons that aren&#x27;t always merit (see javascript).<p>I pick F# because it&#x27;s easier for me to avoid silly mistakes. I find my code is easier to change and it&#x27;s harder to write some classes of bugs. It&#x27;s also very pleasant to use.<p>But C# is pretty good at all of these things, F# is just a little bit nicer. But that little bit comes at a big cost of being very different.</div><br/><div id="36133882" class="c"><input type="checkbox" id="c-36133882" checked=""/><div class="controls bullet"><span class="by">2h</span><span>|</span><a href="#36133830">parent</a><span>|</span><a href="#36133775">next</a><span>|</span><label class="collapse" for="c-36133882">[-]</label><label class="expand" for="c-36133882">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Functional programing is different.<p>I think the problem with this line of thinking is that some people insist on using functional tactics EVERYWHERE, even when it doesn&#x27;t make sense. I get that its ugly to mix functional and imperative code, and maybe some languages dont even allow that. but they should. thats why I like Go, because sometimes a simple for&#x2F;while loop IS the correct answer.</div><br/><div id="36133931" class="c"><input type="checkbox" id="c-36133931" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133830">root</a><span>|</span><a href="#36133882">parent</a><span>|</span><a href="#36135017">next</a><span>|</span><label class="collapse" for="c-36133931">[-]</label><label class="expand" for="c-36133931">[1 more]</label></div><br/><div class="children"><div class="content">Yes I think the The Functional Core, Imperative Shell Pattern is a good way to do things.<p>But somethings take a bit of ramping up. Like the option type, it is great and works well with pattern matching. If you don&#x27;t know why exhaustive pattern matching with union types and options instead of nulls is amazing then it just feels like coding with your hands tied.</div><br/></div></div><div id="36135017" class="c"><input type="checkbox" id="c-36135017" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36133830">root</a><span>|</span><a href="#36133882">parent</a><span>|</span><a href="#36133931">prev</a><span>|</span><a href="#36135472">next</a><span>|</span><label class="collapse" for="c-36135017">[-]</label><label class="expand" for="c-36135017">[1 more]</label></div><br/><div class="children"><div class="content">&gt; some people insist on using functional tactics EVERYWHERE<p>It’s difficult to relate to this without specific examples (I don’t think I agree with the sentiment on balance, but I could also imagine all kinds of obviously-bad things), but FP really does transcend other programming paradigms. Languages such as Java and C++ code definitely do benefit from FP approaches, even if these languages are perhaps not the best at facilitating the approach.</div><br/></div></div><div id="36135472" class="c"><input type="checkbox" id="c-36135472" checked=""/><div class="controls bullet"><span class="by">chromoblob</span><span>|</span><a href="#36133830">root</a><span>|</span><a href="#36133882">parent</a><span>|</span><a href="#36135017">prev</a><span>|</span><a href="#36133775">next</a><span>|</span><label class="collapse" for="c-36135472">[-]</label><label class="expand" for="c-36135472">[1 more]</label></div><br/><div class="children"><div class="content">Loops aren&#x27;t inherently imperative or functional, they can be easily expressed in both imperative and functional paradigms, with or without side effects. Although using map (loops without dependencies between iterations) is more easily parallelizable.</div><br/></div></div></div></div></div></div><div id="36133775" class="c"><input type="checkbox" id="c-36133775" checked=""/><div class="controls bullet"><span class="by">muglug</span><span>|</span><a href="#36133830">prev</a><span>|</span><a href="#36134041">next</a><span>|</span><label class="collapse" for="c-36133775">[-]</label><label class="expand" for="c-36133775">[17 more]</label></div><br/><div class="children"><div class="content">Progamming language evangelism is basically a zero-sum game.<p>Some languages don&#x27;t really intrude on one another&#x27;s territory — e.g. not that many people are rewriting Ruby programs in Rust — but some very directly compete.<p>So if you want to convince someone to use F#, you have to convince them it&#x27;s significantly better than some other closely-related language. And that&#x27;s hard!<p>I have a strong suspicion that the next decade will see a reduction in programming language diversity. JavaScript&#x2F;TypeScript and Python will become even more popular, to the detriment of everything but Go, C++, and Rust.<p>Platform-specific languages like Swift will persevere, as will Java, which is unkillable, but the vast array of languages will become less vast.</div><br/><div id="36134037" class="c"><input type="checkbox" id="c-36134037" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36134606">next</a><span>|</span><label class="collapse" for="c-36134037">[-]</label><label class="expand" for="c-36134037">[2 more]</label></div><br/><div class="children"><div class="content">&gt; not that many people are rewriting Ruby programs in Rust<p>Just an anecdote (and definitely not &quot;many&quot;) but one thing we&#x27;ve found is that ruby and rust actually fit fairly well together. The way I express something in Ruby (often FP stuff like `map` and `filter`) translates very well in Rust. Much better than it translates into (as an example) golang.<p>Beyond expression, the tooling in rust (cargo) feels very familiar and intuitive. Ruby -&gt; Rust in that regard has felt much more natural than Ruby -&gt; JVM&#x2F;golang&#x2F;C++.<p>Don&#x27;t get me wrong, it&#x27;s not a trivial jump, but I&#x27;ve been pleasantly surprised by much of the developer experience.</div><br/><div id="36134701" class="c"><input type="checkbox" id="c-36134701" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36134037">parent</a><span>|</span><a href="#36134606">next</a><span>|</span><label class="collapse" for="c-36134701">[-]</label><label class="expand" for="c-36134701">[1 more]</label></div><br/><div class="children"><div class="content">You might find it interesting to know that Yehuda Katz, author of bundler, was hired to write cargo. There has been a lot of cross pollination between the Ruby and Rust communities.</div><br/></div></div></div></div><div id="36134606" class="c"><input type="checkbox" id="c-36134606" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36134037">prev</a><span>|</span><a href="#36134614">next</a><span>|</span><label class="collapse" for="c-36134606">[-]</label><label class="expand" for="c-36134606">[2 more]</label></div><br/><div class="children"><div class="content">Languages are so fundamental, it&#x27;s philosophy, and tools of expression. Debating better ways of doing these things is something that naturally happens in our heads and by extension in discours - the motivations aren&#x27;t necessarily extrinsic.<p>Even if your suspicion is right - since so many new programmers enter the field, absolute community sizes can still easily grow and hence we get more real-world viable languages.<p>Personally I think we&#x27;ve witnessed an acceleration in the coming and going of languages. Go, Rust, TypeScript, Clojure, Elixir, Zig, etc. And C++ is being dethroned in many more application areas than seemed likely only few years ago. And the GPU realm is still nearly entirely untouched territory. Plus the AI craze may yet stir the soup significantly.</div><br/><div id="36134941" class="c"><input type="checkbox" id="c-36134941" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36134606">parent</a><span>|</span><a href="#36134614">next</a><span>|</span><label class="collapse" for="c-36134941">[-]</label><label class="expand" for="c-36134941">[1 more]</label></div><br/><div class="children"><div class="content">The thing about AI generated code is it may do what you want or it may do something else. It&#x27;s hard to know which is the case. That means you the human programmer must verify the AI generated code. And to be able to do that, you must understand the code written by AI. That suggests that languages which are easy to read )i.e. to understand) will have an advantage in the AI era.</div><br/></div></div></div></div><div id="36134614" class="c"><input type="checkbox" id="c-36134614" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36134606">prev</a><span>|</span><a href="#36133809">next</a><span>|</span><label class="collapse" for="c-36134614">[-]</label><label class="expand" for="c-36134614">[1 more]</label></div><br/><div class="children"><div class="content">C# will stay because Microsoft will push it.  Honestly what makes Go so special?  I could see another language or even Java or C# get their AOT story together and retake what was lost to Go.</div><br/></div></div><div id="36133809" class="c"><input type="checkbox" id="c-36133809" checked=""/><div class="controls bullet"><span class="by">Semaphor</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36134614">prev</a><span>|</span><a href="#36133853">next</a><span>|</span><label class="collapse" for="c-36133809">[-]</label><label class="expand" for="c-36133809">[5 more]</label></div><br/><div class="children"><div class="content">&gt; JavaScript&#x2F;TypeScript and Python will become even more popular, to the detriment of everything but Go, C++, and Rust.<p>Why do you see the popularity of C# waning?</div><br/><div id="36133965" class="c"><input type="checkbox" id="c-36133965" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36133809">parent</a><span>|</span><a href="#36133853">next</a><span>|</span><label class="collapse" for="c-36133965">[-]</label><label class="expand" for="c-36133965">[4 more]</label></div><br/><div class="children"><div class="content">Rust might take its place if the tooling would be on par. Personally I&#x27;d jump.</div><br/><div id="36134253" class="c"><input type="checkbox" id="c-36134253" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36133965">parent</a><span>|</span><a href="#36133853">next</a><span>|</span><label class="collapse" for="c-36134253">[-]</label><label class="expand" for="c-36134253">[3 more]</label></div><br/><div class="children"><div class="content">You are the first person I have heard mention the desire to transition from C# to Rust.  Usually, it is C++ to Rust, or Java to C#.<p><pre><code>    if the tooling would be on par
</code></pre>
I am betting person, and I say: &quot;It never will be.&quot;  It is easy to overlook the importance of better developer tooling.  It directly translates into higher developer productivity.  Every time I am forced to use a language with worse developer tooling, I am reminded of this performance hit.  This is why Microsoft spends so much time and efforts on its developer tools.  Also: Better tooling means below average developers can level-up to average.  This is most of corporate computing, so a win for the bean counters.<p>Also: There is not single, commercial, controlling force behind Rust, like Java and DotNet.<p>Don&#x27;t interpret this post as anything against Rust.  I think it is a brilliant language.</div><br/><div id="36135592" class="c"><input type="checkbox" id="c-36135592" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36134253">parent</a><span>|</span><a href="#36133853">next</a><span>|</span><label class="collapse" for="c-36135592">[-]</label><label class="expand" for="c-36135592">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, I think people are sleeping on the relative disparities in tooling between langs, and it will only get worse.<p>I feel this daily as a Clojure programmer. I&#x27;ve been playing with Copilot, and it&#x27;s astonishing how much worse Copilot is at generating Clojure code, than say, Js. The difference is probably due to training volume, and if AI-assisted coding is worth it at all, the benefits will primarily accrue to the largest languages.</div><br/><div id="36135790" class="c"><input type="checkbox" id="c-36135790" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36135592">parent</a><span>|</span><a href="#36133853">next</a><span>|</span><label class="collapse" for="c-36135790">[-]</label><label class="expand" for="c-36135790">[1 more]</label></div><br/><div class="children"><div class="content">At the office, a teammate and I recently had to write some C# again using Visual Studio.  (Normally, we write Python and Java using JetBrains&#x27; IntelliJ.)  Even then, we could both notice the developer experience was <i>slightly</i> worse in Visual Studio, than IntelliJ.  That said, there are lots of nice (new) language features in C# to make-up for the difference!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36133853" class="c"><input type="checkbox" id="c-36133853" checked=""/><div class="controls bullet"><span class="by">BSEdlMMldESB</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36133809">prev</a><span>|</span><a href="#36133813">next</a><span>|</span><label class="collapse" for="c-36133853">[-]</label><label class="expand" for="c-36133853">[1 more]</label></div><br/><div class="children"><div class="content">but also, some languages really overlap directly, like elixir and ruby, or C and java and javascript.
so maybe is not &quot;zero sum&quot; between every langauge<p>and even more so for beginners, most languages only show their differences at a much deeper level.</div><br/></div></div><div id="36133813" class="c"><input type="checkbox" id="c-36133813" checked=""/><div class="controls bullet"><span class="by">local_crmdgeon</span><span>|</span><a href="#36133775">parent</a><span>|</span><a href="#36133853">prev</a><span>|</span><a href="#36134041">next</a><span>|</span><label class="collapse" for="c-36133813">[-]</label><label class="expand" for="c-36133813">[5 more]</label></div><br/><div class="children"><div class="content">Agreed. Tweaks: I don&#x27;t think C++ is going to be relevant for much longer, Rust solves the problem space better.<p>Python ... maybe? It&#x27;s so different than the rest, I can see it going the way of Ruby once AI bindings improve in other languages. I can also see Julia dominating the AI space.<p>The &quot;better than X&quot; languages though? C#, F#, Scala? Done. I don&#x27;t even hear about Kotlin that much anymore, Java is starting to adopt the good stuff from them.</div><br/><div id="36134710" class="c"><input type="checkbox" id="c-36134710" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36133813">parent</a><span>|</span><a href="#36134633">next</a><span>|</span><label class="collapse" for="c-36134710">[-]</label><label class="expand" for="c-36134710">[1 more]</label></div><br/><div class="children"><div class="content">I would <i>love</i> for Rust to take over C&#x2F;C++, but in embedded it&#x27;s still got a while to go, and it&#x27;s not even really Rust&#x27;s fault per se. It&#x27;s the tooling and third party driver problem that&#x27;s the real issue. It&#x27;s getting there, sure, but it&#x27;s getting there by rebuilding the world, which is... like I said, it&#x27;s a while away, IMO.</div><br/></div></div><div id="36134633" class="c"><input type="checkbox" id="c-36134633" checked=""/><div class="controls bullet"><span class="by">Tehdasi</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36133813">parent</a><span>|</span><a href="#36134710">prev</a><span>|</span><a href="#36134045">next</a><span>|</span><label class="collapse" for="c-36134633">[-]</label><label class="expand" for="c-36134633">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Agreed. Tweaks: I don&#x27;t think C++ is going to be relevant for much longer, Rust solves the problem space better.<p>I would say that in the domain of game development C++ (which is where I&#x27;m guessing that most new C++ development is done) has such a moat that Rust in it&#x27;s current form will not be able to displace it.</div><br/></div></div><div id="36134045" class="c"><input type="checkbox" id="c-36134045" checked=""/><div class="controls bullet"><span class="by">ta-run</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36133813">parent</a><span>|</span><a href="#36134633">prev</a><span>|</span><a href="#36134041">next</a><span>|</span><label class="collapse" for="c-36134045">[-]</label><label class="expand" for="c-36134045">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also MojoLang[0] that brands itself as a alternative to Python, and Google will look to release Carbon soon as well. It&#x27;ll be interesting to see how these two grow.<p>There&#x27;s also Odin[1] that looks promising.<p>I don&#x27;t think C# is going anywhere, F# on the other hand :shrug: is at the mercy of MS - they always seem to be on the fence about it.<p>[0] - <a href="https:&#x2F;&#x2F;www.modular.com&#x2F;mojo" rel="nofollow">https:&#x2F;&#x2F;www.modular.com&#x2F;mojo</a><p>[1] - <a href="http:&#x2F;&#x2F;odin-lang.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;odin-lang.org&#x2F;</a></div><br/><div id="36135451" class="c"><input type="checkbox" id="c-36135451" checked=""/><div class="controls bullet"><span class="by">abstractcontrol</span><span>|</span><a href="#36133775">root</a><span>|</span><a href="#36134045">parent</a><span>|</span><a href="#36134041">next</a><span>|</span><label class="collapse" for="c-36135451">[-]</label><label class="expand" for="c-36135451">[1 more]</label></div><br/><div class="children"><div class="content">Mojo is a language that thinks it will impress the Python programmers with its ability to implement matrix multiplies directly in it. I don&#x27;t think it will be that easy, but it might replace Cython.</div><br/></div></div></div></div></div></div></div></div><div id="36134041" class="c"><input type="checkbox" id="c-36134041" checked=""/><div class="controls bullet"><span class="by">ideasman42</span><span>|</span><a href="#36133775">prev</a><span>|</span><a href="#36133536">next</a><span>|</span><label class="collapse" for="c-36134041">[-]</label><label class="expand" for="c-36134041">[2 more]</label></div><br/><div class="children"><div class="content">This article misses that there are pragmatists are not the kind of technology-disinterested &quot;normal&quot; people.<p>An individual may have the same values as an early adopter, while having to make the decision to used tried and true systems for various reasons out of their control - one of which might be that you depend heavily on the continued development &amp; support of surrounding ecosystems. Or that large code-bases can&#x27;t simply switch to a new technology without it being a massive multi-year undertaking which is difficult to justify.<p>So while the article makes some reasonable points, I think it doesn&#x27;t fully take into account that pragmatists often use what they use for better reasons than &quot;following the herd&quot;.</div><br/><div id="36134875" class="c"><input type="checkbox" id="c-36134875" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#36134041">parent</a><span>|</span><a href="#36133536">next</a><span>|</span><label class="collapse" for="c-36134875">[-]</label><label class="expand" for="c-36134875">[1 more]</label></div><br/><div class="children"><div class="content">I read both your examples as instances of &quot;following the herd&quot;. The expression has negative connotations in litterature and net circles, but that&#x27;s exactly a pragmatic behavior most of the time.<p>I&#x27;m also &quot;following the herd&quot; when choosing a platform that will make it easier&#x2F;cheaper to hire (there is an existing &quot;herd&quot; of developpers), or has wide support by multiple vendors etc .</div><br/></div></div></div></div><div id="36133536" class="c"><input type="checkbox" id="c-36133536" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#36134041">prev</a><span>|</span><a href="#36133596">next</a><span>|</span><label class="collapse" for="c-36133536">[-]</label><label class="expand" for="c-36133536">[11 more]</label></div><br/><div class="children"><div class="content">just as true today as 2015 when the article was written, except C# got even better.<p>While I like the F# language, I don&#x27;t like the (understandably) abandonware of the small community.  I&#x27;ve ported most of my F# stuff to C#, and it&#x27;s not that much different in that you can program in a functional style in C#.  Probably the nicest thing in F# that C# doesn&#x27;t have is computation expressions.</div><br/><div id="36136094" class="c"><input type="checkbox" id="c-36136094" checked=""/><div class="controls bullet"><span class="by">el_oni</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36133746">next</a><span>|</span><label class="collapse" for="c-36136094">[-]</label><label class="expand" for="c-36136094">[1 more]</label></div><br/><div class="children"><div class="content">The abandonware is the problem i have with all the niche languages I enjoy using. If you go down the communities &quot;hot path&quot; there are usually well maintained stuff. But the second you want to go off the path you find a lot of libraries not maintained for a few years. I like to think &quot;oh the library is just complete&quot;, but you then use them in your project and get crashes. And i don&#x27;t think i&#x27;m good enough yet at the language to go in and fix the problems.</div><br/></div></div><div id="36133746" class="c"><input type="checkbox" id="c-36133746" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36136094">prev</a><span>|</span><a href="#36133818">next</a><span>|</span><label class="collapse" for="c-36133746">[-]</label><label class="expand" for="c-36133746">[3 more]</label></div><br/><div class="children"><div class="content">On top of your answer and the other, I still think Discriminated Unions are still a big hole in c#. I know they are supposedly working on it, but until they officially release it I&#x27;m not believing them.</div><br/><div id="36134264" class="c"><input type="checkbox" id="c-36134264" checked=""/><div class="controls bullet"><span class="by">ericsink</span><span>|</span><a href="#36133536">root</a><span>|</span><a href="#36133746">parent</a><span>|</span><a href="#36134090">next</a><span>|</span><label class="collapse" for="c-36134264">[-]</label><label class="expand" for="c-36134264">[1 more]</label></div><br/><div class="children"><div class="content">I too miss discriminated unions in C#.<p>But even more often, I find myself wishing C# blocks were expressions.<p>In F#, I could do this:<p><pre><code>  let x =
      let z = whatever
      ...
      value
</code></pre>
and z is inside a local scope.<p>So in C#, I want to do:<p><pre><code>  var x =
  {
      var z = whatever;
      ...
      value
  };
</code></pre>
Maybe it&#x27;s just me.</div><br/></div></div><div id="36134090" class="c"><input type="checkbox" id="c-36134090" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#36133536">root</a><span>|</span><a href="#36133746">parent</a><span>|</span><a href="#36134264">prev</a><span>|</span><a href="#36133818">next</a><span>|</span><label class="collapse" for="c-36134090">[-]</label><label class="expand" for="c-36134090">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy enough to do DUs, they are working on it, but they are just syntactic sugar for abstract class&#x2F;subclass<p>for instance, as an example for this <a href="https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;posts&#x2F;designing-for-correctness&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;posts&#x2F;designing-for-correc...</a> where a C# solution is suggested and done with DUs in F#,  I wrote the equivalent DU solution in C#...  <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;keithn&#x2F;ceeeed5f7eb567e1b2333747065d10dd" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;keithn&#x2F;ceeeed5f7eb567e1b2333747065d1...</a><p>Only thing you don&#x27;t have is exhaustive checking, which I personally don&#x27;t think is much of a problem pragmatically.</div><br/></div></div></div></div><div id="36133818" class="c"><input type="checkbox" id="c-36133818" checked=""/><div class="controls bullet"><span class="by">throwa18991900</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36133746">prev</a><span>|</span><a href="#36133988">next</a><span>|</span><label class="collapse" for="c-36133818">[-]</label><label class="expand" for="c-36133818">[1 more]</label></div><br/><div class="children"><div class="content">For my domains personally the static math functions are still clunky to me in C#, and the forced compiler time inlining can really help some algorithms with massive perf gains (experienced firsthand) especially with some of the newer .NET features (e.g. ref&#x27;s). IMO to me the nicest thing is the terse syntax, and that I need less IDE as a result. There just seems to be less refactoring tools required to get started and onboard people.<p>I think the abandonware thing is expected. But I think this is the cost of a language that is a child&#x27;s to a main ecosystem and doesn&#x27;t just apply to F#. Unless its specific to FP&#x2F;the F# domain it will be written in C# or whatever the common language is for that platform. Ironically the language with the least features is the one to write in (LCD) so it targets the most people. Why would I just target one language on the platform when I can target all languages? Especially if I&#x27;m paying a team to write the library. Most bang for buck so to speak.<p>Hence most things in these side languages are either wrappers to make them more idiomatic and&#x2F;or pattern libraries that are specific to the extra value add the language has and usually don&#x27;t need to change much once implemented. I think that&#x27;s fine and pragmatic, why reinvent something that works?</div><br/></div></div><div id="36133988" class="c"><input type="checkbox" id="c-36133988" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36133818">prev</a><span>|</span><a href="#36133986">next</a><span>|</span><label class="collapse" for="c-36133988">[-]</label><label class="expand" for="c-36133988">[1 more]</label></div><br/><div class="children"><div class="content">Yes you get abandonware but in other fast moving language you get so out of date that you might as well have been abandoned. Unless you&#x27;re spending a lot of time upgrading.</div><br/></div></div><div id="36133986" class="c"><input type="checkbox" id="c-36133986" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36133988">prev</a><span>|</span><a href="#36133631">next</a><span>|</span><label class="collapse" for="c-36133986">[-]</label><label class="expand" for="c-36133986">[1 more]</label></div><br/><div class="children"><div class="content">I found both Linq expressions and F# computation expressions to be limited (as in: subsets of corresponding languages exclude too much) for the few purposes I tried them on.</div><br/></div></div><div id="36133631" class="c"><input type="checkbox" id="c-36133631" checked=""/><div class="controls bullet"><span class="by">KurtMueller</span><span>|</span><a href="#36133536">parent</a><span>|</span><a href="#36133986">prev</a><span>|</span><a href="#36133596">next</a><span>|</span><label class="collapse" for="c-36133631">[-]</label><label class="expand" for="c-36133631">[3 more]</label></div><br/><div class="children"><div class="content">... or units of measure</div><br/><div id="36133731" class="c"><input type="checkbox" id="c-36133731" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36133536">root</a><span>|</span><a href="#36133631">parent</a><span>|</span><a href="#36134165">next</a><span>|</span><label class="collapse" for="c-36133731">[-]</label><label class="expand" for="c-36133731">[1 more]</label></div><br/><div class="children"><div class="content">This is a surprising gap for most non-ML type systems from what I’ve gathered. I don’t understand  the gap, tbh. Most of us aren’t slinging primitive values with no particular domain in mind, it’s weird that we have to encode most of the domain in naming conventions and docs.</div><br/></div></div><div id="36134165" class="c"><input type="checkbox" id="c-36134165" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#36133536">root</a><span>|</span><a href="#36133631">parent</a><span>|</span><a href="#36133731">prev</a><span>|</span><a href="#36133596">next</a><span>|</span><label class="collapse" for="c-36134165">[-]</label><label class="expand" for="c-36134165">[1 more]</label></div><br/><div class="children"><div class="content">while I like it, it doesn&#x27;t actually seem that useful.... and given I work on IoT systems measuring all kinds of things in all kinds of units, it isn&#x27;t at all useful for that.  Kind of cool for when you are using F# as a calculator though</div><br/></div></div></div></div></div></div><div id="36133596" class="c"><input type="checkbox" id="c-36133596" checked=""/><div class="controls bullet"><span class="by">jacamera</span><span>|</span><a href="#36133536">prev</a><span>|</span><a href="#36134315">next</a><span>|</span><label class="collapse" for="c-36133596">[-]</label><label class="expand" for="c-36133596">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this article is dead on. It&#x27;s old but the principles still hold true.<p>&gt; Because C# is really, really good.<p>The first language I learned was VB.net because I thought &quot;Visual Basic&quot; sounded easy. I quickly moved to C# because it was more popular. I&#x27;ve always been curious about F# but never invested the time to learn it exactly because C# never caused me enough pain.</div><br/></div></div><div id="36134315" class="c"><input type="checkbox" id="c-36134315" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#36133596">prev</a><span>|</span><a href="#36133594">next</a><span>|</span><label class="collapse" for="c-36134315">[-]</label><label class="expand" for="c-36134315">[2 more]</label></div><br/><div class="children"><div class="content">This is all very true.<p>Mostly what I have seen happening is people really loving F# convert to using C#.  The tooling being the main reason.<p>What this article isn’t saying is that F# is awful at interoping with C# and windows APIs in general. Mostly that F# functions cannot be used as Func&lt;&gt; objects. So even in a C# environment, bringing some F# is a pain. Definitely didn’t help the adoption.</div><br/><div id="36135018" class="c"><input type="checkbox" id="c-36135018" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36134315">parent</a><span>|</span><a href="#36133594">next</a><span>|</span><label class="collapse" for="c-36135018">[-]</label><label class="expand" for="c-36135018">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it would actually help so much if F# libraries could be painlessly used in C#, it might be all that was needed.
Unfortunately it&#x27;s not the case.
Maybe if discriminated unions are ever added to C# some real cross compatibility could be made,</div><br/></div></div></div></div><div id="36133594" class="c"><input type="checkbox" id="c-36133594" checked=""/><div class="controls bullet"><span class="by">slfjw____</span><span>|</span><a href="#36134315">prev</a><span>|</span><a href="#36133983">next</a><span>|</span><label class="collapse" for="c-36133594">[-]</label><label class="expand" for="c-36133594">[5 more]</label></div><br/><div class="children"><div class="content">Likely will never use again<p>* two async models present: task (C#) &amp; async (f#)<p>* horrible async performance: perhaps fixed by native task &amp; FSM transformation<p>* two error handling models: Result (monadic but without do notation) &amp; C# style Exceptions<p>* not rich in community libraries, like a desert &amp; abandonware</div><br/><div id="36133993" class="c"><input type="checkbox" id="c-36133993" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36133594">parent</a><span>|</span><a href="#36134002">next</a><span>|</span><label class="collapse" for="c-36133993">[-]</label><label class="expand" for="c-36133993">[2 more]</label></div><br/><div class="children"><div class="content">&gt; not rich in community libraries, like a desert &amp; abandonware<p>You have access to the entire .net ecosystem?</div><br/><div id="36134648" class="c"><input type="checkbox" id="c-36134648" checked=""/><div class="controls bullet"><span class="by">jasdfwef</span><span>|</span><a href="#36133594">root</a><span>|</span><a href="#36133993">parent</a><span>|</span><a href="#36134002">next</a><span>|</span><label class="collapse" for="c-36134648">[-]</label><label class="expand" for="c-36134648">[1 more]</label></div><br/><div class="children"><div class="content">They may have meant F# packages</div><br/></div></div></div></div><div id="36134002" class="c"><input type="checkbox" id="c-36134002" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#36133594">parent</a><span>|</span><a href="#36133993">prev</a><span>|</span><a href="#36134234">next</a><span>|</span><label class="collapse" for="c-36134002">[-]</label><label class="expand" for="c-36134002">[1 more]</label></div><br/><div class="children"><div class="content">* the complexity of the compiler makes it hard to make it better</div><br/></div></div><div id="36134234" class="c"><input type="checkbox" id="c-36134234" checked=""/><div class="controls bullet"><span class="by">pbiggar</span><span>|</span><a href="#36133594">parent</a><span>|</span><a href="#36134002">prev</a><span>|</span><a href="#36133983">next</a><span>|</span><label class="collapse" for="c-36134234">[-]</label><label class="expand" for="c-36134234">[1 more]</label></div><br/><div class="children"><div class="content">Tasks are native and I&#x27;ve never had the use async. Performance is great.<p>Agree that exceptions are frustrating that they exist, sadly there&#x27;s little option due to C# exception model. Same thing in OCaml though less excuse over there.<p>I basically use C# libraries directly, and it hasn&#x27;t been annoying at all.</div><br/></div></div></div></div><div id="36133983" class="c"><input type="checkbox" id="c-36133983" checked=""/><div class="controls bullet"><span class="by">chrfrasco</span><span>|</span><a href="#36133594">prev</a><span>|</span><a href="#36133902">next</a><span>|</span><label class="collapse" for="c-36133983">[-]</label><label class="expand" for="c-36133983">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is how a new product gets across the chasm. Find a pragmatist in pain. Do whatever-it-takes to make them happy with your product. Then go back and do it again.<p>Good advice, I think the useful idea is: An excellent product in competition with a very good incumbent is a bad idea. A mediocre product in competition with an absent or terrible incumbent is a great idea</div><br/></div></div><div id="36133902" class="c"><input type="checkbox" id="c-36133902" checked=""/><div class="controls bullet"><span class="by">Fervicus</span><span>|</span><a href="#36133983">prev</a><span>|</span><a href="#36134391">next</a><span>|</span><label class="collapse" for="c-36133902">[-]</label><label class="expand" for="c-36133902">[2 more]</label></div><br/><div class="children"><div class="content">I love C# and it keeps getting better and better, but I don&#x27;t get the same level of satisfaction with it that I do with F#</div><br/><div id="36135553" class="c"><input type="checkbox" id="c-36135553" checked=""/><div class="controls bullet"><span class="by">arwhatever</span><span>|</span><a href="#36133902">parent</a><span>|</span><a href="#36134391">next</a><span>|</span><label class="collapse" for="c-36135553">[-]</label><label class="expand" for="c-36135553">[1 more]</label></div><br/><div class="children"><div class="content">Im pretty fond of C# as well, but pretty often the type system feels like it leaks like a sieve compared to F#.</div><br/></div></div></div></div><div id="36134391" class="c"><input type="checkbox" id="c-36134391" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#36133902">prev</a><span>|</span><a href="#36133763">next</a><span>|</span><label class="collapse" for="c-36134391">[-]</label><label class="expand" for="c-36134391">[1 more]</label></div><br/><div class="children"><div class="content">I loved the marketing bell curve.  But there were terrible opinions here which show other relevant chasms that were not detailed.  Parroting C#&#x27;s supposed superiority to Objective-C shows an embarrassing lack of understanding of the languages differences, development ecosystems and strengths.  I would never use C# where I needed to interact with native code -- Objective-C can do so with immense power and practicality.</div><br/></div></div><div id="36133763" class="c"><input type="checkbox" id="c-36133763" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#36134391">prev</a><span>|</span><a href="#36134221">next</a><span>|</span><label class="collapse" for="c-36133763">[-]</label><label class="expand" for="c-36133763">[1 more]</label></div><br/><div class="children"><div class="content">Needs a (2015) tag, but seems awfully relevant even today.</div><br/></div></div><div id="36134221" class="c"><input type="checkbox" id="c-36134221" checked=""/><div class="controls bullet"><span class="by">banashark</span><span>|</span><a href="#36133763">prev</a><span>|</span><a href="#36134114">next</a><span>|</span><label class="collapse" for="c-36134221">[-]</label><label class="expand" for="c-36134221">[2 more]</label></div><br/><div class="children"><div class="content">I find it interesting to compare F# with Kotlin.<p>F# had Jet as the one large success story of a full f# shop, but outside of that there weren&#x27;t many large companies using a lot of F# (except microsoft internally, and they didn&#x27;t blog about it _too_ much).<p>Kotlin on the other hand is seeing server-side adoption in quite a few large companies. Google is recommending it as the server-side JVM language for new services going forward. Airbnb and a handful of other large companies blog about having kotlin services in their architecture.<p>There&#x27;s a few reasons I think Kotlin is succeeding where F# hasn&#x27;t been able to:<p>* JVM + tooling is a proven and great ecosystem. First-class support for most of your cloud tooling and databases (AWS, Kafka, ElasticSearch, Cassandra, etc).<p>* It has fantastic editor tooling (given that an IDE company created and maintains it). F# for quite a while has had less-than-average tooling (it&#x27;s gotten better now with newer versions of FSAC, Ionide, and Rider, but it was _rough_ for a while). It&#x27;s hard to move to something new that&#x27;s supposed to be safer when your language server has memory leaks or breaks every X hours. I remember stretches of time where I was just writing F# in vim without syntax highlighting because any editor I tried would constantly throw errors in the middle of me coding. That hasn&#x27;t happened to me with Kotlin.<p>* It&#x27;s close-enough looking to a scripting language with nice features that it&#x27;s more approachable. Classes and functions look similar to other languages. It even has block parameters that are inviting for rubyists (although the implementation is different). It also has some syntactic sugar to make some things very ergonomic to work with.<p>* All of the above just works. No big fiddling necessary. The pain points in working with the Java ecosystem are written about and known (largest that come to my mind are coroutines interacting with java threading, exceptions in mixed coroutine&#x2F;threading environments, and null&#x2F;optional which Kotlin has some great features built-in to work around).<p>There&#x27;s also things like arrow-kt and http4k for those desiring the more functional side of things.<p>The one thing that continues to baffle me is how little I see in people talking about kotlin in various communities (slack, discord, reddit, etc) compared to how many people are writing it (both for android and for server-side concerns).<p>The one upside I&#x27;ll give is that fable has been much better IME than my experience with Kotlin&#x2F;js. I also prefer F# from a purely language standpoint, but Kotlin is just better to work with.</div><br/><div id="36135058" class="c"><input type="checkbox" id="c-36135058" checked=""/><div class="controls bullet"><span class="by">throw868788</span><span>|</span><a href="#36134221">parent</a><span>|</span><a href="#36134114">next</a><span>|</span><label class="collapse" for="c-36135058">[-]</label><label class="expand" for="c-36135058">[1 more]</label></div><br/><div class="children"><div class="content">Seems like a common theme that people prefer the F# language, but try to explain reasons why it hasn&#x27;t succeeded from a technical view. I think the reasons IMO aren&#x27;t technical but what the author has stated - C# is probably worse (that&#x27;s my opinion) but people who are working in it don&#x27;t see the pain. Its marketing, the vibe, etc. Most of the tech issues people state wouldn&#x27;t be there if adoption was bigger.<p>This is in contrast to Java which for a significant time wasn&#x27;t showing any evolution which sparked many alt langs on that platform. Sometimes things succeed but silently, and sometimes things that should succeed just don&#x27;t and maybe there isn&#x27;t a real explanation. In fact I think the latter across most products is actually the most common outcome, not just in programming languages.<p>TL;DR I agree with the article, it suffers from an adoption chasm. Pain and herd safety are important especially when people are considering their career progression.<p>To your dot points:<p>* I think F# has .NET which is a &quot;proven&quot; and good enough ecosystem as well. You won&#x27;t get stuck by picking F# even if it means using a C# library. Have to do the same in Scala&#x2F;Kotlin and the like typically as well.<p>* Editor has caught up, my surprise is that you can write with Vim and kinda get away with it - only find that works in terser&#x2F;scripting like languages anyway unlike C#. It has wrappers and libraries for doing things in a more F# FP manner if you wish although when I was doing F# I avoided them (i.e. I avoid things like ScalaX most of the time too).<p>* F# has a good scripting story; I&#x27;ve seen F# scripts used quite often by people even if coding in C# to check things and REPL program.<p>* These days F# just works too mostly. `dotnet new webapi&#x2F;console&#x2F;etc -lang F#` and you have a webapi for example.<p>* There are F# libraries around for similar things (Http, Collections, Async seq, etc). They are probably maintained to the level they realistically need to be, I would argue they still do their singular job quite well. At some point a library just does what it needs to do.<p>There&#x27;s things I prefer in the .NET ecosystem as well - value types, inlining, etc. Having said that I seen quite a few people use it professionally to good success but they often don&#x27;t brag about it and are usually quite senior and reserved about their language choice often citing other worries&#x2F;risks to a project&#x27;s success.</div><br/></div></div></div></div><div id="36134114" class="c"><input type="checkbox" id="c-36134114" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36134221">prev</a><span>|</span><a href="#36133001">next</a><span>|</span><label class="collapse" for="c-36134114">[-]</label><label class="expand" for="c-36134114">[1 more]</label></div><br/><div class="children"><div class="content">Discussed (a bit) at the time:<p><i>Why F# evangelism isn&#x27;t working</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8841534" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8841534</a> - Jan 2015 (5 comments)</div><br/></div></div><div id="36133001" class="c"><input type="checkbox" id="c-36133001" checked=""/><div class="controls bullet"><span class="by">dzdt</span><span>|</span><a href="#36134114">prev</a><span>|</span><a href="#36133696">next</a><span>|</span><label class="collapse" for="c-36133001">[-]</label><label class="expand" for="c-36133001">[2 more]</label></div><br/><div class="children"><div class="content">(2015)</div><br/><div id="36133498" class="c"><input type="checkbox" id="c-36133498" checked=""/><div class="controls bullet"><span class="by">aaronbrethorst</span><span>|</span><a href="#36133001">parent</a><span>|</span><a href="#36133696">next</a><span>|</span><label class="collapse" for="c-36133498">[-]</label><label class="expand" for="c-36133498">[1 more]</label></div><br/><div class="children"><div class="content">I really scratched my head at this one, at first. &quot;Why your F# evangelism isn&#x27;t working&quot; — uhh, maybe because it&#x27;s a decade late?</div><br/></div></div></div></div><div id="36133696" class="c"><input type="checkbox" id="c-36133696" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#36133001">prev</a><span>|</span><a href="#36133651">next</a><span>|</span><label class="collapse" for="c-36133696">[-]</label><label class="expand" for="c-36133696">[1 more]</label></div><br/><div class="children"><div class="content">2015</div><br/></div></div><div id="36133651" class="c"><input type="checkbox" id="c-36133651" checked=""/><div class="controls bullet"><span class="by">wly_cdgr</span><span>|</span><a href="#36133696">prev</a><span>|</span><label class="collapse" for="c-36133651">[-]</label><label class="expand" for="c-36133651">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t help that C# has a much, much better name for the purposes of appealing to Pragmatists (in the article&#x27;s terminology). Every Pragmatist knows that C is a trusted and proven language. So, something that is an improvement or iteration on C is probably fine, too. But what is F? No one knows.</div><br/><div id="36136049" class="c"><input type="checkbox" id="c-36136049" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#36133651">parent</a><span>|</span><label class="collapse" for="c-36136049">[-]</label><label class="expand" for="c-36136049">[1 more]</label></div><br/><div class="children"><div class="content">When I first saw it mentioned, I assumed a Microsoft version of Fortran :-|</div><br/></div></div></div></div></div></div></div></div></div></body></html>