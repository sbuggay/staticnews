<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700730064108" as="style"/><link rel="stylesheet" href="styles.css?v=1700730064108"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jmmv.dev/2020/03/test-bracket.html">test, [, and [[ (2020)</a> <span class="domain">(<a href="https://jmmv.dev">jmmv.dev</a>)</span></div><div class="subtext"><span>mattrighetti</span> | <span>119 comments</span></div><br/><div><div id="38390846" class="c"><input type="checkbox" id="c-38390846" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#38387879">next</a><span>|</span><label class="collapse" for="c-38390846">[-]</label><label class="expand" for="c-38390846">[1 more]</label></div><br/><div class="children"><div class="content">Taking the last point one step further, we can also dispense with the if block entirely:<p><pre><code>    if [ a = b ]; then
        echo &quot;Oops!&quot;
    else
        echo &quot;Expected; phew!&quot;
    fi
</code></pre>
becomes<p><pre><code>    [ a = b ] &amp;&amp; echo &quot;Oops!&quot; || echo &quot;Expected; phew!&quot;
</code></pre>
I&#x27;m not sure how often you should do this but sometimes it comes in handy for things like<p><pre><code>    [ &quot;$debug&quot; ] &amp;&amp; echo &quot;what&#x27;s going on&quot; &gt;&amp;2
</code></pre>
to conditionally print debug output to stderr.</div><br/></div></div><div id="38387879" class="c"><input type="checkbox" id="c-38387879" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#38390846">prev</a><span>|</span><a href="#38390843">next</a><span>|</span><label class="collapse" for="c-38387879">[-]</label><label class="expand" for="c-38387879">[4 more]</label></div><br/><div class="children"><div class="content">Hey, original author here. Thanks for sharing this and making it rise to the front page! :) By the way, the title probably deserves a (2020) and it would be nice if &quot;test&quot; wasn&#x27;t capitalized, because it actually refers to the command.<p>Here is something related from 2021 that also touches on bash&#x27;s [[ operator and that I think you might enjoy in this context: <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2021&#x2F;08&#x2F;useless-use-of-gnu.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jmmv.dev&#x2F;2021&#x2F;08&#x2F;useless-use-of-gnu.html</a></div><br/><div id="38390798" class="c"><input type="checkbox" id="c-38390798" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#38387879">parent</a><span>|</span><a href="#38390033">next</a><span>|</span><label class="collapse" for="c-38390798">[-]</label><label class="expand" for="c-38390798">[1 more]</label></div><br/><div class="children"><div class="content">This article complains that using the extended GNU features (--ignore-case, set -o pipefail etc) makes scripts less portable. Fair enough.<p>What it doesn&#x27;t explain is why a Linux user should much care about portability. OpenBSD and FreeBSD are alive and well, but the number of users seems so small that they aren&#x27;t a particular concern. Maybe you could argue that we &quot;should&quot; consider these OSes out of a sense of fairness, but where does that stop? Do I also need to consider something obscure like vxWorks?<p>BusyBox (Alpine) is more interesting, but the changes there are so significant that a port will almost always be needed anyway.<p>Are there other compelling reasons to care about the non-GNU ecosystem?</div><br/></div></div><div id="38390033" class="c"><input type="checkbox" id="c-38390033" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38387879">parent</a><span>|</span><a href="#38390798">prev</a><span>|</span><a href="#38388310">next</a><span>|</span><label class="collapse" for="c-38390033">[-]</label><label class="expand" for="c-38390033">[1 more]</label></div><br/><div class="children"><div class="content">Ok, I&#x27;ve lowercased the leading &#x27;t&#x27;. We never do that but for this, ok :)</div><br/></div></div><div id="38388310" class="c"><input type="checkbox" id="c-38388310" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38387879">parent</a><span>|</span><a href="#38390033">prev</a><span>|</span><a href="#38390843">next</a><span>|</span><label class="collapse" for="c-38388310">[-]</label><label class="expand" for="c-38388310">[1 more]</label></div><br/><div class="children"><div class="content">[[ is not really a builtin, it&#x27;s fundamentally syntactical (but presumably uses a mostly-inaccessible builtin internally). Fun fact, `]]` is also a reserved word despite never being allowed in a context where reserved words matter.<p>In some non-bash shells, the `function` keyword is needed to declare certain types of function.<p>For make `$(shell)`, if you&#x27;re building a lot of targets the performance difference can be measurable. Still, it loses in the nop case, so you should actually usually do `include` to trigger re-making.<p>GNU is completely right to ignore POSIX, since POSIX is not useful for solving most real problems.</div><br/></div></div></div></div><div id="38390689" class="c"><input type="checkbox" id="c-38390689" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#38390843">prev</a><span>|</span><a href="#38387976">next</a><span>|</span><label class="collapse" for="c-38390689">[-]</label><label class="expand" for="c-38390689">[1 more]</label></div><br/><div class="children"><div class="content">I had no idea [ was a program and the fact that it checks if the last argument is a closing bracket is kinda funny to me.<p>But at least it explains why you need spaces on both sides of the brackets.</div><br/></div></div><div id="38387976" class="c"><input type="checkbox" id="c-38387976" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38390689">prev</a><span>|</span><a href="#38388001">next</a><span>|</span><label class="collapse" for="c-38387976">[-]</label><label class="expand" for="c-38387976">[20 more]</label></div><br/><div class="children"><div class="content">The biggest footgun in `[` and `test` is the single argument behavior. For example, you might attempt to check if a variable is nonempty like so:<p><pre><code>     [ -n $FOO ]
</code></pre>
but if FOO is unset, it expands to nothing (as opposed to the empty string), so this is equvalent to:<p><pre><code>     [ -n ]
</code></pre>
and POSIX requires that the one-argument form of `[` succeed if that argument (here, &quot;-n&quot;) is non-empty. So this will falsely report that $FOO is non-empty.<p>Remember to quote your variables!</div><br/><div id="38390654" class="c"><input type="checkbox" id="c-38390654" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#38387976">parent</a><span>|</span><a href="#38388065">next</a><span>|</span><label class="collapse" for="c-38390654">[-]</label><label class="expand" for="c-38390654">[1 more]</label></div><br/><div class="children"><div class="content">I think your last sentence needs to go first. Quote your variables! There&#x27;s no actual footgun in the specification of the test builtin -- the footgun is shell itself. The behaviour that you mention makes sense because<p><pre><code>   [ &quot;$FOO&quot; ]
</code></pre>
is always the non-empty check regardless what it contains (could be &quot;-n&quot;).</div><br/></div></div><div id="38388065" class="c"><input type="checkbox" id="c-38388065" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#38387976">parent</a><span>|</span><a href="#38390654">prev</a><span>|</span><a href="#38389287">next</a><span>|</span><label class="collapse" for="c-38388065">[-]</label><label class="expand" for="c-38388065">[11 more]</label></div><br/><div class="children"><div class="content">ShellCheck your scripts!</div><br/><div id="38388361" class="c"><input type="checkbox" id="c-38388361" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388065">parent</a><span>|</span><a href="#38389287">next</a><span>|</span><label class="collapse" for="c-38388361">[-]</label><label class="expand" for="c-38388361">[10 more]</label></div><br/><div class="children"><div class="content">Or use set -u to fail early.<p>Or use  [ -n ${FOO-} ] which will replace the unset variable with an empty string.</div><br/><div id="38388747" class="c"><input type="checkbox" id="c-38388747" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388361">parent</a><span>|</span><a href="#38390386">next</a><span>|</span><label class="collapse" for="c-38388747">[-]</label><label class="expand" for="c-38388747">[5 more]</label></div><br/><div class="children"><div class="content">That is false. There is no difference between ${FOO} and ${FOO-}. Both disappear if unquoted, and FOO is unset or blank:<p><pre><code>  $ printf &quot;&lt;%s&gt;\n&quot; alpha ${beta} omega
  &lt;alpha&gt;
  &lt;omega&gt;
  $ printf &quot;&lt;%s&gt;\n&quot; alpha ${beta-} omega
  &lt;alpha&gt;
  &lt;omega&gt;
</code></pre>
The form ${var-} form is useful for safely evaluating a variable that might be unset, when &quot;set -u&quot; mode is in effect, and for whatever reason we cannot just fix the script so that the variable is set.</div><br/><div id="38388887" class="c"><input type="checkbox" id="c-38388887" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388747">parent</a><span>|</span><a href="#38390386">next</a><span>|</span><label class="collapse" for="c-38388887">[-]</label><label class="expand" for="c-38388887">[4 more]</label></div><br/><div class="children"><div class="content">They meant &quot;${FOO:-}&quot; which should still be quoted.<p>The general form is &quot;${FOO:-default}&quot; where default can itself be another variable or whatever string you want.<p>I usually prefer to set default values at the top of a script though using this idiom:<p><pre><code>   : &quot;${FOO:=bar}&quot;
</code></pre>
And when creating a local variable I&#x27;ll immediately set it to an empty string if there&#x27;s a chance it won&#x27;t be assigned later:<p><pre><code>  local foo=&quot;&quot;</code></pre></div><br/><div id="38389228" class="c"><input type="checkbox" id="c-38389228" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388887">parent</a><span>|</span><a href="#38390386">next</a><span>|</span><label class="collapse" for="c-38389228">[-]</label><label class="expand" for="c-38389228">[3 more]</label></div><br/><div class="children"><div class="content">That colon makes no difference if the replacement is blank.</div><br/><div id="38389774" class="c"><input type="checkbox" id="c-38389774" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38389228">parent</a><span>|</span><a href="#38390386">next</a><span>|</span><label class="collapse" for="c-38389774">[-]</label><label class="expand" for="c-38389774">[2 more]</label></div><br/><div class="children"><div class="content">Holy crap, 25 years of writing shell scripts and I just learned the difference:<p>With colon, tests variable for unset or empty. Without the colon tests only for unset. It&#x27;s POSIX too:<p><a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;V3_chap02.html#tag_18_06_02" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;V...</a></div><br/><div id="38390074" class="c"><input type="checkbox" id="c-38390074" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38389774">parent</a><span>|</span><a href="#38390386">next</a><span>|</span><label class="collapse" for="c-38390074">[-]</label><label class="expand" for="c-38390074">[1 more]</label></div><br/><div class="children"><div class="content">So ${foo-bar} will not expand to bar if foo exists, but is empty. The empty value will prevail. ${foo:-bar} will expand to bar.<p>If we have nothing in place of bar, they are effectively same.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38390386" class="c"><input type="checkbox" id="c-38390386" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388361">parent</a><span>|</span><a href="#38388747">prev</a><span>|</span><a href="#38388412">next</a><span>|</span><label class="collapse" for="c-38390386">[-]</label><label class="expand" for="c-38390386">[1 more]</label></div><br/><div class="children"><div class="content">&quot;set -x&quot; is a life saver for debugging. Also &quot;set -euo pipefail&quot; so a script just exits on errors or unexpected behavior. If done well you can really reign in squirrely behavior.<p>Bash has some odd behaviors and footguns but it can also be surprisingly reliable and versatile. Ive caught some seriously messed up stuff that I couldn&#x27;t figure out otherwise, using set -x. Also shellcheck will forcefully hammer good practice into your head and catch a ton of hangups that are hard to know before making the mistakes.<p>also setting backup variables is a good idea like:
pictures=&quot;${pics_dir:-$HOME&#x2F;Pictures}&quot;</div><br/></div></div><div id="38388412" class="c"><input type="checkbox" id="c-38388412" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388361">parent</a><span>|</span><a href="#38390386">prev</a><span>|</span><a href="#38388404">next</a><span>|</span><label class="collapse" for="c-38388412">[-]</label><label class="expand" for="c-38388412">[1 more]</label></div><br/><div class="children"><div class="content">That bottom one will also fail. The empty string is not treated as a shell word.<p>You need double quotes.</div><br/></div></div><div id="38388404" class="c"><input type="checkbox" id="c-38388404" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388361">parent</a><span>|</span><a href="#38388412">prev</a><span>|</span><a href="#38390350">next</a><span>|</span><label class="collapse" for="c-38388404">[-]</label><label class="expand" for="c-38388404">[1 more]</label></div><br/><div class="children"><div class="content">Preferably you&#x27;d use set -u to avoid certain problems, and <i>also</i> keep using shellcheck for all the other things it can catch.</div><br/></div></div><div id="38390350" class="c"><input type="checkbox" id="c-38390350" checked=""/><div class="controls bullet"><span class="by">Xiol32</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38388361">parent</a><span>|</span><a href="#38388404">prev</a><span>|</span><a href="#38389287">next</a><span>|</span><label class="collapse" for="c-38390350">[-]</label><label class="expand" for="c-38390350">[1 more]</label></div><br/><div class="children"><div class="content">set -euo pipefail<p>Effectively strict mode for shell scripts.</div><br/></div></div></div></div></div></div><div id="38389287" class="c"><input type="checkbox" id="c-38389287" checked=""/><div class="controls bullet"><span class="by">dixie_land</span><span>|</span><a href="#38387976">parent</a><span>|</span><a href="#38388065">prev</a><span>|</span><a href="#38390273">next</a><span>|</span><label class="collapse" for="c-38389287">[-]</label><label class="expand" for="c-38389287">[4 more]</label></div><br/><div class="children"><div class="content">[ x&quot;$FOO&quot; != x&quot;&quot; ]</div><br/><div id="38390148" class="c"><input type="checkbox" id="c-38390148" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38389287">parent</a><span>|</span><a href="#38389780">next</a><span>|</span><label class="collapse" for="c-38390148">[-]</label><label class="expand" for="c-38390148">[1 more]</label></div><br/><div class="children"><div class="content">Please stop with tricks like this and just quote your variables. Everywhere.</div><br/></div></div><div id="38389780" class="c"><input type="checkbox" id="c-38389780" checked=""/><div class="controls bullet"><span class="by">overtomanu</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38389287">parent</a><span>|</span><a href="#38390148">prev</a><span>|</span><a href="#38389561">next</a><span>|</span><label class="collapse" for="c-38389780">[-]</label><label class="expand" for="c-38389780">[1 more]</label></div><br/><div class="children"><div class="content">whoa, lot of history in this trick<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26776956">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26776956</a></div><br/></div></div><div id="38389561" class="c"><input type="checkbox" id="c-38389561" checked=""/><div class="controls bullet"><span class="by">andrewshadura</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38389287">parent</a><span>|</span><a href="#38389780">prev</a><span>|</span><a href="#38390273">next</a><span>|</span><label class="collapse" for="c-38389561">[-]</label><label class="expand" for="c-38389561">[1 more]</label></div><br/><div class="children"><div class="content">No. This hasn&#x27;t been necessary for decades.</div><br/></div></div></div></div><div id="38390273" class="c"><input type="checkbox" id="c-38390273" checked=""/><div class="controls bullet"><span class="by">mattrighetti</span><span>|</span><a href="#38387976">parent</a><span>|</span><a href="#38389287">prev</a><span>|</span><a href="#38390238">next</a><span>|</span><label class="collapse" for="c-38390273">[-]</label><label class="expand" for="c-38390273">[2 more]</label></div><br/><div class="children"><div class="content">In this case I would use [ -n &quot;${FOO?}&quot; ] so that the script will immediately stop if $FOO is null or unset</div><br/><div id="38390423" class="c"><input type="checkbox" id="c-38390423" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#38387976">root</a><span>|</span><a href="#38390273">parent</a><span>|</span><a href="#38390238">next</a><span>|</span><label class="collapse" for="c-38390423">[-]</label><label class="expand" for="c-38390423">[1 more]</label></div><br/><div class="children"><div class="content">Set -xufo pipefail<p>Or whatever the magic string is. Enable all the errors at the start of the script</div><br/></div></div></div></div></div></div><div id="38388001" class="c"><input type="checkbox" id="c-38388001" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#38387976">prev</a><span>|</span><a href="#38388159">next</a><span>|</span><label class="collapse" for="c-38388001">[-]</label><label class="expand" for="c-38388001">[1 more]</label></div><br/><div class="children"><div class="content">chubot has written an interesting document¹ exploring more of the nuance with test&#x2F;[&#x2F;[[, and many of the other entries in that blog have intriguing explanations of the oddities of our shells(a random example²).<p>¹ <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2017&#x2F;08&#x2F;31.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2017&#x2F;08&#x2F;31.html</a><p>² <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;11&#x2F;18.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;11&#x2F;18.html</a></div><br/></div></div><div id="38388159" class="c"><input type="checkbox" id="c-38388159" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#38388001">prev</a><span>|</span><a href="#38388841">next</a><span>|</span><label class="collapse" for="c-38388159">[-]</label><label class="expand" for="c-38388159">[6 more]</label></div><br/><div class="children"><div class="content">I stopped using [ a few years ago because ‘test’ reinforces the idea that this is just a command like any other, not syntax.  Also, “man test” is much more pleasant that sifting through “man bash”.</div><br/><div id="38390791" class="c"><input type="checkbox" id="c-38390791" checked=""/><div class="controls bullet"><span class="by">tuyiown</span><span>|</span><a href="#38388159">parent</a><span>|</span><a href="#38388286">next</a><span>|</span><label class="collapse" for="c-38390791">[-]</label><label class="expand" for="c-38390791">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you, the [ (and [[ bashism) introduces lots of confusions about what is really happening, I could never manage any real confidence.<p>That said, [[ being guaranteed to be built-in certainly had its purpose at ages where shell script performance had any kind of relevance, and that was no so long ago.</div><br/></div></div><div id="38388286" class="c"><input type="checkbox" id="c-38388286" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38388159">parent</a><span>|</span><a href="#38390791">prev</a><span>|</span><a href="#38388841">next</a><span>|</span><label class="collapse" for="c-38388286">[-]</label><label class="expand" for="c-38388286">[4 more]</label></div><br/><div class="children"><div class="content">Your comment makes no sense. GNU Coreutils has a &quot;man [&quot; as well as &quot;man test&quot; man page.<p>Bash has &quot;help test&quot; for a quick cheatsheet.<p>The [ command is very old; it was already present in Version 7 Unix in 1979.</div><br/><div id="38390488" class="c"><input type="checkbox" id="c-38390488" checked=""/><div class="controls bullet"><span class="by">c0l0</span><span>|</span><a href="#38388159">root</a><span>|</span><a href="#38388286">parent</a><span>|</span><a href="#38388841">next</a><span>|</span><label class="collapse" for="c-38390488">[-]</label><label class="expand" for="c-38390488">[3 more]</label></div><br/><div class="children"><div class="content">Parts of the comment make a LOT of sense actually, when you look at shell scripts written by the uninitated. Often times, I see constructs like<p><pre><code>    while [ 1 ]; do ...; done
</code></pre>
which are a pretty clear indication of the author&#x27;s misconception about the perceived nature of <i>[ ]</i>, I think.</div><br/><div id="38390589" class="c"><input type="checkbox" id="c-38390589" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38388159">root</a><span>|</span><a href="#38390488">parent</a><span>|</span><a href="#38388841">next</a><span>|</span><label class="collapse" for="c-38390589">[-]</label><label class="expand" for="c-38390589">[2 more]</label></div><br/><div class="children"><div class="content">The nice way to write that isn&#x27;t any kind of <i>test</i> command but:<p><pre><code>   while true; do ...; done
</code></pre>
There is never any reason to use <i>test</i>, other than portability to some broken environment that is missing <i>[</i> but not missing <i>test</i>.</div><br/><div id="38390802" class="c"><input type="checkbox" id="c-38390802" checked=""/><div class="controls bullet"><span class="by">tuyiown</span><span>|</span><a href="#38388159">root</a><span>|</span><a href="#38390589">parent</a><span>|</span><a href="#38388841">next</a><span>|</span><label class="collapse" for="c-38390802">[-]</label><label class="expand" for="c-38390802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is never any reason to use test<p>What&#x27;s the reason for always using <i>[</i> ?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38388841" class="c"><input type="checkbox" id="c-38388841" checked=""/><div class="controls bullet"><span class="by">user261</span><span>|</span><a href="#38388159">prev</a><span>|</span><a href="#38387789">next</a><span>|</span><label class="collapse" for="c-38388841">[-]</label><label class="expand" for="c-38388841">[1 more]</label></div><br/><div class="children"><div class="content">I really didn&#x27;t understand why the last if statement is confusing. Is it because when starting out with shell scripting one would usually assume that the [ is a part of the bash scripting language not just another program? If it&#x27;s then I think I get it now. Otherwise please mention why it&#x27;s surprising. Also, @author thanks for a nice article. was a good reed.</div><br/></div></div><div id="38387789" class="c"><input type="checkbox" id="c-38387789" checked=""/><div class="controls bullet"><span class="by">neverrroot</span><span>|</span><a href="#38388841">prev</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38387789">[-]</label><label class="expand" for="c-38387789">[36 more]</label></div><br/><div class="children"><div class="content">[[ is bash only. If you know you’ll only use bash, use it.
For details, the article is nice.</div><br/><div id="38387896" class="c"><input type="checkbox" id="c-38387896" checked=""/><div class="controls bullet"><span class="by">re</span><span>|</span><a href="#38387789">parent</a><span>|</span><a href="#38389509">next</a><span>|</span><label class="collapse" for="c-38387896">[-]</label><label class="expand" for="c-38387896">[3 more]</label></div><br/><div class="children"><div class="content">Well, zsh too :)<p><a href="https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Conditional-Expressions.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Conditional-Expressio...</a></div><br/><div id="38390470" class="c"><input type="checkbox" id="c-38390470" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387896">parent</a><span>|</span><a href="#38389100">next</a><span>|</span><label class="collapse" for="c-38390470">[-]</label><label class="expand" for="c-38390470">[1 more]</label></div><br/><div class="children"><div class="content">&quot;bash only&quot; typically refers to &quot;bashisms&quot;, that is, bash features not present in the plain Bourne shell (or Bourne-compatible interpreters such as dash).<p>Confirming my facts for this comment, #TIL that &quot;dash&quot; is the &quot;Debian Alquist Shell&quot;, that is, Debian&#x27;s &quot;ash&quot; shell:<p>&lt;<a href="https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Guide_to_Unix&#x2F;Explanations&#x2F;Choice_of_Shell" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Guide_to_Unix&#x2F;Explanations&#x2F;Cho...</a>&gt;</div><br/></div></div><div id="38389100" class="c"><input type="checkbox" id="c-38389100" checked=""/><div class="controls bullet"><span class="by">bgm1975</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387896">parent</a><span>|</span><a href="#38390470">prev</a><span>|</span><a href="#38389509">next</a><span>|</span><label class="collapse" for="c-38389100">[-]</label><label class="expand" for="c-38389100">[1 more]</label></div><br/><div class="children"><div class="content">And ksh (ksh88 &amp; later)</div><br/></div></div></div></div><div id="38389509" class="c"><input type="checkbox" id="c-38389509" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38387789">parent</a><span>|</span><a href="#38387896">prev</a><span>|</span><a href="#38387811">next</a><span>|</span><label class="collapse" for="c-38389509">[-]</label><label class="expand" for="c-38389509">[2 more]</label></div><br/><div class="children"><div class="content">Always use [[<p>zsh and ksh have it; in fact I&#x27;m pretty sure it originated with ksh in 1988 or earlier.</div><br/><div id="38390278" class="c"><input type="checkbox" id="c-38390278" checked=""/><div class="controls bullet"><span class="by">OmarAssadi</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389509">parent</a><span>|</span><a href="#38387811">next</a><span>|</span><label class="collapse" for="c-38390278">[-]</label><label class="expand" for="c-38390278">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Always use [[<p>While zsh, bash, mksh, ksh93, probably others have it, sure. But many don&#x27;t -- and not totally irrelevant ones either. Debian&#x27;s default, dash, for example, does not support `[[`.<p>IMO, unless you&#x27;re writing something like shell-specific dotfiles, avoid non-POSIX features.<p>It&#x27;s usually pretty trivial to avoid them, especially if you&#x27;re willing to call other mandated commands like awk, etc. But often, with a bit of creative thinking, most non-standard features can be replicated with some combination of `set`, separate functions and&#x2F;or subshells.<p>Shell scripts, in general, have dozens of footguns, are pretty much impossible to statically analyze, difficult to make truly robust, and many of the shells themselves -- e.g., bash -- have huge, borderline inauditable codebases.<p>I can think of a dozen reasons not to write shell scripts. Yet still, there is incredible value in the fact that some form of POSIX-compliant&#x2F;compliant-enough shell can usually be found on most systems.<p>All of that value goes out the window, though, the moment you start relying on non-standard features.</div><br/></div></div></div></div><div id="38387811" class="c"><input type="checkbox" id="c-38387811" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38387789">parent</a><span>|</span><a href="#38389509">prev</a><span>|</span><a href="#38387859">next</a><span>|</span><label class="collapse" for="c-38387811">[-]</label><label class="expand" for="c-38387811">[1 more]</label></div><br/><div class="children"><div class="content">That is, test and [ are specified by POSIX and usually are physical binaries (but might also be masked by shell builtins). Whereas [[ is not specified by POSIX and usually only exists as a shell builtin.</div><br/></div></div><div id="38387859" class="c"><input type="checkbox" id="c-38387859" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38387789">parent</a><span>|</span><a href="#38387811">prev</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38387859">[-]</label><label class="expand" for="c-38387859">[29 more]</label></div><br/><div class="children"><div class="content">Why would you not use Bash (unless you are using completely different shell like Fish explicitly?).<p>It feels like some completely archaic concern to target the minimal common shell denominator.</div><br/><div id="38390506" class="c"><input type="checkbox" id="c-38390506" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38387910">next</a><span>|</span><label class="collapse" for="c-38390506">[-]</label><label class="expand" for="c-38390506">[1 more]</label></div><br/><div class="children"><div class="content">Writing Bourne-compliant scripts ensures maximum portability.<p>As many here have noted, bash <i>isn&#x27;t</i> universally available, with another possible issue being OpenWRT devices.  Stock&#x2F;base images tend to use a Bourne-compatible shell, not full Bash.  Though the latter&#x27;s installable through opkg, for sufficiently small devices (typical of consumer kit), you simply won&#x27;t have the space to install them.<p>There&#x27;s also the slight PITA that Apple&#x27;s OSX ships with a <i>very old</i>, pre-GPLv2 Bash, out of licensing concerns.  (Apple is phenomenally averse to GPL-based code, much as some *BSDs are, such as OpenBSD.)<p>And if you&#x27;re dealing with legacy systems (which tend to be extraordinarily and stubbornly persistently legacy), you&#x27;ll often find that either bash isn&#x27;t present or is quite dated.<p>I freely confess that I tend to write fairly recent-feature bash scripts myself by default, and appreciate many of the newer features.  But if and when I <i>am</i> writing portable code, I&#x27;ll go back to Bourne-compatibility.<p>But <i>when writing system level code</i>, an appreciation for standards and the very long tail of legacy standards and the limitations they impose <i>is</i> in fact a large component of professional maturity.</div><br/></div></div><div id="38387910" class="c"><input type="checkbox" id="c-38387910" checked=""/><div class="controls bullet"><span class="by">mikem170</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38390506">prev</a><span>|</span><a href="#38387880">next</a><span>|</span><label class="collapse" for="c-38387910">[-]</label><label class="expand" for="c-38387910">[3 more]</label></div><br/><div class="children"><div class="content">Bash seems to be about as archaic as sh.<p>I write my shell scripts in sh, because it comes with every unix-like os by default.<p>I know that bash has more features, but I&#x27;ve never really missed them. I switch from sh to perl for more complicated tasks.<p>To each their own, right?</div><br/><div id="38388392" class="c"><input type="checkbox" id="c-38388392" checked=""/><div class="controls bullet"><span class="by">15457345234</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387910">parent</a><span>|</span><a href="#38387880">next</a><span>|</span><label class="collapse" for="c-38388392">[-]</label><label class="expand" for="c-38388392">[2 more]</label></div><br/><div class="children"><div class="content">This to me seems like good practice, it&#x27;s better to use a &#x27;real&#x27; programming language when you&#x27;re crossing the boundary from &#x27;script&#x27; to &#x27;program&#x27;<p>Shellscript has way too many idiosyncracies and weirdnesses that would have been beaten out of a proper programming language by now. (I know that talking about weirdnesses is amusing in relation to perl which also has a whole armload of them.)</div><br/><div id="38390458" class="c"><input type="checkbox" id="c-38390458" checked=""/><div class="controls bullet"><span class="by">hnbad</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388392">parent</a><span>|</span><a href="#38387880">next</a><span>|</span><label class="collapse" for="c-38390458">[-]</label><label class="expand" for="c-38390458">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This to me seems like good practice, it&#x27;s better to use a &#x27;real&#x27; programming language when you&#x27;re crossing the boundary from &#x27;script&#x27; to &#x27;program&#x27;<p>PowerShell would like a word with you.</div><br/></div></div></div></div></div></div><div id="38387880" class="c"><input type="checkbox" id="c-38387880" checked=""/><div class="controls bullet"><span class="by">LambdaComplex</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38387910">prev</a><span>|</span><a href="#38387934">next</a><span>|</span><label class="collapse" for="c-38387880">[-]</label><label class="expand" for="c-38387880">[8 more]</label></div><br/><div class="children"><div class="content">Not installed by default on BSDs. Sometimes not installed in minimal environments, e.g. where BusyBox is all you have available. Maybe not installed by default on Unixes? Not sure</div><br/><div id="38388281" class="c"><input type="checkbox" id="c-38388281" checked=""/><div class="controls bullet"><span class="by">loa_in_</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387880">parent</a><span>|</span><a href="#38387934">next</a><span>|</span><label class="collapse" for="c-38388281">[-]</label><label class="expand" for="c-38388281">[7 more]</label></div><br/><div class="children"><div class="content">Honestly, installing bash into environments seems like less work than avoiding it. It&#x27;s not hard to do.</div><br/><div id="38390404" class="c"><input type="checkbox" id="c-38390404" checked=""/><div class="controls bullet"><span class="by">OmarAssadi</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388281">parent</a><span>|</span><a href="#38388937">next</a><span>|</span><label class="collapse" for="c-38390404">[-]</label><label class="expand" for="c-38390404">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not usually hard to do, no, but it is &gt;130K of C alone, excluding whitespace, comments, tests, examples, etc. I don&#x27;t want it on my system from a security perspective alone.<p>Add in the bootstrapping pain it imposes due to autoconf and other stuff, I think there are many valid reasons to avoid it and choose another shell that is more auditable yet still has just as many eyeballs on it (e.g., mksh - the default on Android; dash - default on Debian; BusyBox - every embedded system).</div><br/></div></div><div id="38388937" class="c"><input type="checkbox" id="c-38388937" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388281">parent</a><span>|</span><a href="#38390404">prev</a><span>|</span><a href="#38389289">next</a><span>|</span><label class="collapse" for="c-38388937">[-]</label><label class="expand" for="c-38388937">[2 more]</label></div><br/><div class="children"><div class="content">When your script will be running on customer machines, you often don&#x27;t have the luxury (and sometimes it&#x27;s not technically possible because it doesn&#x27;t exist) of installing bash into the environment.</div><br/><div id="38389149" class="c"><input type="checkbox" id="c-38389149" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388937">parent</a><span>|</span><a href="#38389289">next</a><span>|</span><label class="collapse" for="c-38389149">[-]</label><label class="expand" for="c-38389149">[1 more]</label></div><br/><div class="children"><div class="content">Time to find better customers.</div><br/></div></div></div></div><div id="38389289" class="c"><input type="checkbox" id="c-38389289" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388281">parent</a><span>|</span><a href="#38388937">prev</a><span>|</span><a href="#38387934">next</a><span>|</span><label class="collapse" for="c-38389289">[-]</label><label class="expand" for="c-38389289">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t always have a package manager, root access to even be able to install anything, network access, etc.<p>&quot;Just install bash&quot; is not always easy, and is not even necessary when posix shell can easily do what most people use bash-specific syntax for.</div><br/><div id="38389523" class="c"><input type="checkbox" id="c-38389523" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389289">parent</a><span>|</span><a href="#38387934">next</a><span>|</span><label class="collapse" for="c-38389523">[-]</label><label class="expand" for="c-38389523">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the sort of yak-shaving I will never do.  I&#x27;d rather just not use such a primitive unix and&#x2F;or be in a job where one of pdksh&#x2F;ksh&#x2F;zsh&#x2F;bash is not available at all.</div><br/><div id="38390116" class="c"><input type="checkbox" id="c-38390116" checked=""/><div class="controls bullet"><span class="by">isatty</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389523">parent</a><span>|</span><a href="#38387934">next</a><span>|</span><label class="collapse" for="c-38390116">[-]</label><label class="expand" for="c-38390116">[1 more]</label></div><br/><div class="children"><div class="content">Well it’s good that you have the choice to; but it’s also not all that difficult to understand that not everyone who needs to use your script, has that choice.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38387934" class="c"><input type="checkbox" id="c-38387934" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38387880">prev</a><span>|</span><a href="#38388921">next</a><span>|</span><label class="collapse" for="c-38387934">[-]</label><label class="expand" for="c-38387934">[3 more]</label></div><br/><div class="children"><div class="content">IIRC Debian uses dash as &#x2F;bin&#x2F;sh because it&#x27;s faster (execution speed) than bash.</div><br/><div id="38389537" class="c"><input type="checkbox" id="c-38389537" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387934">parent</a><span>|</span><a href="#38388921">next</a><span>|</span><label class="collapse" for="c-38389537">[-]</label><label class="expand" for="c-38389537">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like using a horse instead of a mule.  Just not worth it.  Move away from the whole equine world and use a real programming language.</div><br/><div id="38389791" class="c"><input type="checkbox" id="c-38389791" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389537">parent</a><span>|</span><a href="#38388921">next</a><span>|</span><label class="collapse" for="c-38389791">[-]</label><label class="expand" for="c-38389791">[1 more]</label></div><br/><div class="children"><div class="content">Eh, there are things that shell is really good at, and there are things that other languages are good at. I will grant that shell is best for glue code; my personal heuristic is that I stick to POSIX sh, and if that hurts then I take that as a sign that I should be considering moving to Python or whatever. But avoiding it completely strikes me as a poor choice, because for the &quot;glue together separate programs and manipulate files&quot; tasks that it&#x27;s meant for, it&#x27;s <i>really</i> good and IMO everything else still falls short.</div><br/></div></div></div></div></div></div><div id="38388921" class="c"><input type="checkbox" id="c-38388921" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38387934">prev</a><span>|</span><a href="#38389701">next</a><span>|</span><label class="collapse" for="c-38388921">[-]</label><label class="expand" for="c-38388921">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on several modern projects that needed to be able to run on a wide variety of Unix platforms, several of which didn&#x27;t have bash. Writing for the common shell denominator was important, not archaic.</div><br/><div id="38389464" class="c"><input type="checkbox" id="c-38389464" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388921">parent</a><span>|</span><a href="#38389701">next</a><span>|</span><label class="collapse" for="c-38389464">[-]</label><label class="expand" for="c-38389464">[1 more]</label></div><br/><div class="children"><div class="content">Still sounds archaic that it&#x27;s a problem today that needs to even be addressed.</div><br/></div></div></div></div><div id="38389701" class="c"><input type="checkbox" id="c-38389701" checked=""/><div class="controls bullet"><span class="by">csydas</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38388921">prev</a><span>|</span><a href="#38388066">next</a><span>|</span><label class="collapse" for="c-38389701">[-]</label><label class="expand" for="c-38389701">[1 more]</label></div><br/><div class="children"><div class="content">it’s contextual as most things. need to actually use and work on the machine? use whatever shell you want to make your life easier.<p>need a script to run on many different systems and&#x2F;or need to write a script to be managed automatically by a service account? probably you want a shell with syntax that is guaranteed to be the same on all your systems.</div><br/></div></div><div id="38388066" class="c"><input type="checkbox" id="c-38388066" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38389701">prev</a><span>|</span><a href="#38388026">next</a><span>|</span><label class="collapse" for="c-38388066">[-]</label><label class="expand" for="c-38388066">[3 more]</label></div><br/><div class="children"><div class="content">IIRC, &#x2F;bin&#x2F;sh on Ubuntu defaults to dash</div><br/><div id="38388121" class="c"><input type="checkbox" id="c-38388121" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388066">parent</a><span>|</span><a href="#38389648">next</a><span>|</span><label class="collapse" for="c-38388121">[-]</label><label class="expand" for="c-38388121">[1 more]</label></div><br/><div class="children"><div class="content">That is from Debian and all child distros inherit it by default, not just Ubuntu.</div><br/></div></div><div id="38389648" class="c"><input type="checkbox" id="c-38389648" checked=""/><div class="controls bullet"><span class="by">andrewshadura</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388066">parent</a><span>|</span><a href="#38388121">prev</a><span>|</span><a href="#38388026">next</a><span>|</span><label class="collapse" for="c-38389648">[-]</label><label class="expand" for="c-38389648">[1 more]</label></div><br/><div class="children"><div class="content">In fact, only dash is supported as &#x2F;bin&#x2F;sh on Debian and Ubuntu.</div><br/></div></div></div></div><div id="38388026" class="c"><input type="checkbox" id="c-38388026" checked=""/><div class="controls bullet"><span class="by">driggs</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38387859">parent</a><span>|</span><a href="#38388066">prev</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38388026">[-]</label><label class="expand" for="c-38388026">[7 more]</label></div><br/><div class="children"><div class="content">Because Apple switched the default macOS shell from the GNU-licensed `bash` to the BSD-licensed `zsh`?</div><br/><div id="38389192" class="c"><input type="checkbox" id="c-38389192" checked=""/><div class="controls bullet"><span class="by">bgm1975</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38388026">parent</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38389192">[-]</label><label class="expand" for="c-38389192">[6 more]</label></div><br/><div class="children"><div class="content">Apple switched when bash switched from GPL2 to GPL3 which they didn’t like.  The older bash is still available.</div><br/><div id="38389684" class="c"><input type="checkbox" id="c-38389684" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389192">parent</a><span>|</span><a href="#38389650">next</a><span>|</span><label class="collapse" for="c-38389684">[-]</label><label class="expand" for="c-38389684">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Apple switched when bash switched from GPL2 to GPL3<p>Apple just didn’t update. It took them years to finally switch to switch to zsh.<p>&gt; The older bash is still available.<p>Aside from it being bash (a great reason not to use it as far as I’m concerned) it’s now a 17 years old version of bash.</div><br/><div id="38389739" class="c"><input type="checkbox" id="c-38389739" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389684">parent</a><span>|</span><a href="#38389650">next</a><span>|</span><label class="collapse" for="c-38389739">[-]</label><label class="expand" for="c-38389739">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Aside from it being bash (a great reason not to use it as far as I’m concerned) it’s now a 17 years old version of bash.<p>I thought people liked macOs for its vintage feel? Remember a time when computers could only render a single menu bar in a fixed location, feel the experience of SYN floods, run a version of bash that is old enough to vote in the next presidential election.</div><br/><div id="38390552" class="c"><input type="checkbox" id="c-38390552" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389739">parent</a><span>|</span><a href="#38389650">next</a><span>|</span><label class="collapse" for="c-38390552">[-]</label><label class="expand" for="c-38390552">[1 more]</label></div><br/><div class="children"><div class="content">Honestly this is such a waste of time every time I have to argue with developers about installing up to date homebrew (or whatever) versions of the coreutils that I wish Apple would simply DELETE all these ancient versions of tools from MacOS.
As a bonus, homebrew does not offer --with-default-names any more and some tools (like make) are posted into different paths so you need to add your own symlinks or add multiple paths to your PATH.</div><br/></div></div></div></div></div></div><div id="38389650" class="c"><input type="checkbox" id="c-38389650" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389192">parent</a><span>|</span><a href="#38389684">prev</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38389650">[-]</label><label class="expand" for="c-38389650">[2 more]</label></div><br/><div class="children"><div class="content">According to the interwebs, zsh became default with Catalina in 2019 [1]; ten years after bash 4 was released with gpl v3 or later.<p>Also, the interwebs suggest Apple used to use tcsh as the default shell[2]; I don&#x27;t know when they changed that, but it may have been after bash 4 released? (Thanks, 10.3 was in 2003, so several years before the license changed)<p>[1] <a href="https:&#x2F;&#x2F;www.theverge.com&#x2F;2019&#x2F;6&#x2F;4&#x2F;18651872&#x2F;apple-macos-catalina-zsh-bash-shell-replacement-features" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.theverge.com&#x2F;2019&#x2F;6&#x2F;4&#x2F;18651872&#x2F;apple-macos-catal...</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18853318">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18853318</a></div><br/><div id="38389698" class="c"><input type="checkbox" id="c-38389698" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38387789">root</a><span>|</span><a href="#38389650">parent</a><span>|</span><a href="#38388238">next</a><span>|</span><label class="collapse" for="c-38389698">[-]</label><label class="expand" for="c-38389698">[1 more]</label></div><br/><div class="children"><div class="content">bash became the default shell in 10.3. tcsh was the default before then.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38388238" class="c"><input type="checkbox" id="c-38388238" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38387789">prev</a><span>|</span><a href="#38387801">next</a><span>|</span><label class="collapse" for="c-38388238">[-]</label><label class="expand" for="c-38388238">[9 more]</label></div><br/><div class="children"><div class="content">I have strong opinions about shell and they don&#x27;t actually line up with the rest of the world...<p>I believe that [ should never be used, only &quot;test&quot; because [ gives the illusion that the mechanism is some part of the language syntax when it is just another &quot;program&quot; (I&#x27;m including built-ins and functions in &quot;program&quot;).<p>(if &#x2F; || &#x2F; &amp;&amp; look at exit status; a program can&#x27;t see the exit status of other things other than looking at the magic variable $? which is just another string once expanded; case looks at strings but doesn&#x27;t operate based on exit status and doesn&#x27;t set an exit status as part of the case ... esac operation; &quot;programs&quot; set an exit status)<p>I also believe that [ &#x2F; test should only ever be used for evaluating filesystem constructs -- test -f &#x2F;dev&#x2F;null and if you&#x27;ve got string evaluations use case.<p>Unsurprisingly, most scripts make me itchy, and scripts that I write people find weird.<p>[edited to add the explanation of &quot;program&quot; vs &quot;syntax&quot; opinion]</div><br/><div id="38388444" class="c"><input type="checkbox" id="c-38388444" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38388238">parent</a><span>|</span><a href="#38390820">next</a><span>|</span><label class="collapse" for="c-38388444">[-]</label><label class="expand" for="c-38388444">[1 more]</label></div><br/><div class="children"><div class="content">Joke&#x27;s on me; that&#x27;s the point of the article.<p>I prefer, when writing in shell, to do this:<p><pre><code>    if 
      program
    then
      something
    else
      otherthing
    fi
</code></pre>
To <i>emphasize</i> that the thing after the if is just &quot;look at the exit status of the last command before the then.&quot;<p><pre><code>    if
      ls &#x2F;tmp&#x2F;goober
      test -d &#x2F;tmp&#x2F;goober
      echo &quot;I&#x27;ll always execute the then clause because echo will always return a 0 return code&quot;
    then
      echo &quot;this always gets run&quot;
    else
      echo &quot;this never gets run&quot;
    fi
</code></pre>
because the &quot;if&quot; is just looking at the exit status of &quot;echo&quot;.<p>[edited to do code blocks]</div><br/></div></div><div id="38390820" class="c"><input type="checkbox" id="c-38390820" checked=""/><div class="controls bullet"><span class="by">tuyiown</span><span>|</span><a href="#38388238">parent</a><span>|</span><a href="#38388444">prev</a><span>|</span><a href="#38389023">next</a><span>|</span><label class="collapse" for="c-38390820">[-]</label><label class="expand" for="c-38390820">[1 more]</label></div><br/><div class="children"><div class="content">Reading the comments here it looks like there are somehow <i>dozens</i> of us using test only. Dozens !</div><br/></div></div><div id="38389023" class="c"><input type="checkbox" id="c-38389023" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38388238">parent</a><span>|</span><a href="#38390820">prev</a><span>|</span><a href="#38388806">next</a><span>|</span><label class="collapse" for="c-38389023">[-]</label><label class="expand" for="c-38389023">[5 more]</label></div><br/><div class="children"><div class="content">Hello fellow traveler. I&#x27;ve got 8 years of scripts with `test` in them to prove I agree with you. It&#x27;s a lonely road out there... I blame the Google shell style guide.<p>I picked up the habit of preferring `test` when I was writing scripts that needed to run in both `sh` and `bash`, but I kept it because it makes more semantic sense to me than treating a character like `[` as a command. It&#x27;s also weird that `]` is an argument to `[` rather than also being a binary. I mean, I understand the technical reasoning... but it feels like a hack.</div><br/><div id="38389227" class="c"><input type="checkbox" id="c-38389227" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#38388238">root</a><span>|</span><a href="#38389023">parent</a><span>|</span><a href="#38389704">next</a><span>|</span><label class="collapse" for="c-38389227">[-]</label><label class="expand" for="c-38389227">[3 more]</label></div><br/><div class="children"><div class="content">Hello fellow traveler. I&#x27;ve got 20 years of scripts with `if test` in them. I only use `[[` when I need functionality it provides that `test` does not (pattern or regex matching, typically, and for pattern matching I&#x27;ll generally use a case statement instead).</div><br/><div id="38389299" class="c"><input type="checkbox" id="c-38389299" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38388238">root</a><span>|</span><a href="#38389227">parent</a><span>|</span><a href="#38389704">next</a><span>|</span><label class="collapse" for="c-38389299">[-]</label><label class="expand" for="c-38389299">[2 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s when I use it too. I figure if I&#x27;ve already given into the temptations of Bash, I may as well go all the way. Sometimes if I&#x27;m feeling extra frisky I even do [[ .. ]] || { echo &quot;error!&quot; ; exit 1 }</div><br/><div id="38389368" class="c"><input type="checkbox" id="c-38389368" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38388238">root</a><span>|</span><a href="#38389299">parent</a><span>|</span><a href="#38389704">next</a><span>|</span><label class="collapse" for="c-38389368">[-]</label><label class="expand" for="c-38389368">[1 more]</label></div><br/><div class="children"><div class="content">I imagine most people have sets of macros they habitually add to any sufficiently complex script they&#x27;re modifying...<p><pre><code>  yelp(){
    es=$1
    shift
    echo &quot;$@&quot; &gt;&amp;2
    exit $es
  }
  
  test -d &#x2F;tmp&#x2F;goober || yelp 33 &quot;couldn&#x27;t find goober!&quot;
</code></pre>
(yes, I&#x27;m sure there are standards for exit status ranges and 33 is not such a thing)</div><br/></div></div></div></div></div></div><div id="38389704" class="c"><input type="checkbox" id="c-38389704" checked=""/><div class="controls bullet"><span class="by">quicklime</span><span>|</span><a href="#38388238">root</a><span>|</span><a href="#38389023">parent</a><span>|</span><a href="#38389227">prev</a><span>|</span><a href="#38388806">next</a><span>|</span><label class="collapse" for="c-38389704">[-]</label><label class="expand" for="c-38389704">[1 more]</label></div><br/><div class="children"><div class="content">The Google style guide doesn’t  disagree with you, it says to code exclusively for bash where possible (ie mostly everywhere inside Google) and to prefer [[ over [ and test:<p><a href="https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;shellguide.html#s6.3-tests" rel="nofollow noreferrer">https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;shellguide.html#s6.3-tes...</a><p>In a scenario where you also need to support shells other than bash, Google’s shell style guide doesn’t say to use [ over test.</div><br/></div></div></div></div></div></div><div id="38387801" class="c"><input type="checkbox" id="c-38387801" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#38388238">prev</a><span>|</span><a href="#38389721">next</a><span>|</span><label class="collapse" for="c-38387801">[-]</label><label class="expand" for="c-38387801">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve learned to only use [[ when I want to do a regex match, e.g.<p><pre><code>  if [[ &quot;${foo}&quot; =~ ^bar$ ]]; then echo Yes; fi
</code></pre>
Otherwise, just stick with &quot;test&quot; or &quot;[&quot;.<p>85,000 lines of bash and counting... Not saying bash is great, but it&#x27;s still meeting my needs for a lot of stuff.  Shrug.</div><br/><div id="38390295" class="c"><input type="checkbox" id="c-38390295" checked=""/><div class="controls bullet"><span class="by">penguin_booze</span><span>|</span><a href="#38387801">parent</a><span>|</span><a href="#38388569">next</a><span>|</span><label class="collapse" for="c-38390295">[-]</label><label class="expand" for="c-38390295">[1 more]</label></div><br/><div class="children"><div class="content">The fact that the regex is written bare and unquoted, got me a while ago. I&#x27;m someone who religiously quotes everything; it took me a while before I figured out why my stupidly simple regex doesn&#x27;t match.</div><br/></div></div><div id="38388569" class="c"><input type="checkbox" id="c-38388569" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38387801">parent</a><span>|</span><a href="#38390295">prev</a><span>|</span><a href="#38387914">next</a><span>|</span><label class="collapse" for="c-38388569">[-]</label><label class="expand" for="c-38388569">[1 more]</label></div><br/><div class="children"><div class="content">If you want to do (relatively) simple pattern matching in a posix-compliant way, `expr`[1] can match BREs, and even return a capture group.<p>1: <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;expr.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;e...</a></div><br/></div></div><div id="38387914" class="c"><input type="checkbox" id="c-38387914" checked=""/><div class="controls bullet"><span class="by">cvccvroomvroom</span><span>|</span><a href="#38387801">parent</a><span>|</span><a href="#38388569">prev</a><span>|</span><a href="#38389721">next</a><span>|</span><label class="collapse" for="c-38387914">[-]</label><label class="expand" for="c-38387914">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a pointless example.<p><pre><code>    [ &quot;$foo&quot; = bar ] &amp;&amp; echo Yes
</code></pre>
For substring matches, [ and * globs are generally good enough.<p><pre><code>    [ &quot;$bar&quot; = extra* ] &amp;&amp; echo &#x27;$bar began with extra&#x27;
</code></pre>
Bash&#x27;s regex dialect is primitive and rarely worth fussing over. For anything complicated, use another tool be it grep, awk, perl, or such. There are diminishing returns of obsessing over doing everything in bash when a complicated task demands more capabilities suitable to another tool with greater reusability, modularity, and intrinsic types.</div><br/><div id="38388079" class="c"><input type="checkbox" id="c-38388079" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38387801">root</a><span>|</span><a href="#38387914">parent</a><span>|</span><a href="#38389721">next</a><span>|</span><label class="collapse" for="c-38388079">[-]</label><label class="expand" for="c-38388079">[1 more]</label></div><br/><div class="children"><div class="content">I thought regex inside [[ was the same as egrep?</div><br/></div></div></div></div></div></div><div id="38389721" class="c"><input type="checkbox" id="c-38389721" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#38387801">prev</a><span>|</span><a href="#38388303">next</a><span>|</span><label class="collapse" for="c-38389721">[-]</label><label class="expand" for="c-38389721">[1 more]</label></div><br/><div class="children"><div class="content">One place where you learn not to use [ or [[, or be <i>very</i> careful about them is autoconf shell scripts (and that applies to more than `if`, like globs, sed, awk, etc.). Because square brackets are quote characters in autoconf. <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;savannah-checkouts&#x2F;gnu&#x2F;autoconf&#x2F;manual&#x2F;autoconf-2.71&#x2F;html_node&#x2F;Active-Characters.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;savannah-checkouts&#x2F;gnu&#x2F;autoconf&#x2F;manual&#x2F;a...</a></div><br/></div></div><div id="38388303" class="c"><input type="checkbox" id="c-38388303" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#38389721">prev</a><span>|</span><a href="#38387972">next</a><span>|</span><label class="collapse" for="c-38388303">[-]</label><label class="expand" for="c-38388303">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;031" rel="nofollow noreferrer">https:&#x2F;&#x2F;mywiki.wooledge.org&#x2F;BashFAQ&#x2F;031</a></div><br/></div></div><div id="38387972" class="c"><input type="checkbox" id="c-38387972" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38388303">prev</a><span>|</span><a href="#38390084">next</a><span>|</span><label class="collapse" for="c-38387972">[-]</label><label class="expand" for="c-38387972">[5 more]</label></div><br/><div class="children"><div class="content">I actually thought [ and test were <i>sym</i>links, but that might just be from Alpine Linux where they&#x27;re both symlinks to busybox.</div><br/><div id="38388201" class="c"><input type="checkbox" id="c-38388201" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#38387972">parent</a><span>|</span><a href="#38390084">next</a><span>|</span><label class="collapse" for="c-38388201">[-]</label><label class="expand" for="c-38388201">[4 more]</label></div><br/><div class="children"><div class="content">Hardlinks actually, but who&#x27;s counting? plus in real world usage you will hit the shell builtin anyway.<p><pre><code>  ls -li &#x2F;bin&#x2F;\[ &#x2F;bin&#x2F;test
  26016 -r-xr-xr-x  2 root  bin  133256 Mar 25  2023 &#x2F;bin&#x2F;[
  26016 -r-xr-xr-x  2 root  bin  133256 Mar 25  2023 &#x2F;bin&#x2F;test
</code></pre>
I have to admit I avoid &quot;[&quot; in my scripts, it is a weird hack trying to make a command look like syntax and this really bothers me for some reason.</div><br/><div id="38388287" class="c"><input type="checkbox" id="c-38388287" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38387972">root</a><span>|</span><a href="#38388201">parent</a><span>|</span><a href="#38389275">next</a><span>|</span><label class="collapse" for="c-38388287">[-]</label><label class="expand" for="c-38388287">[2 more]</label></div><br/><div class="children"><div class="content">No, Alpine uses symlinks:<p><pre><code>    $ docker run --rm -ti alpine
    &#x2F; # ls -l &#x2F;usr&#x2F;bin&#x2F;test &#x2F;usr&#x2F;bin&#x2F;[
    lrwxrwxrwx    1 root     root            12 Sep 28 11:18 &#x2F;usr&#x2F;bin&#x2F;[ -&gt; &#x2F;bin&#x2F;busybox
    lrwxrwxrwx    1 root     root            12 Sep 28 11:18 &#x2F;usr&#x2F;bin&#x2F;test -&gt; &#x2F;bin&#x2F;busybox
    &#x2F; # ls -li &#x2F;usr&#x2F;bin&#x2F;test &#x2F;usr&#x2F;bin&#x2F;[
     495254 lrwxrwxrwx    1 root     root            12 Sep 28 11:18 &#x2F;usr&#x2F;bin&#x2F;[ -&gt; &#x2F;bin&#x2F;busybox
     495360 lrwxrwxrwx    1 root     root            12 Sep 28 11:18 &#x2F;usr&#x2F;bin&#x2F;test -&gt; &#x2F;bin&#x2F;busybox
    &#x2F; #</code></pre></div><br/><div id="38390054" class="c"><input type="checkbox" id="c-38390054" checked=""/><div class="controls bullet"><span class="by">figmert</span><span>|</span><a href="#38387972">root</a><span>|</span><a href="#38388287">parent</a><span>|</span><a href="#38389275">next</a><span>|</span><label class="collapse" for="c-38390054">[-]</label><label class="expand" for="c-38390054">[1 more]</label></div><br/><div class="children"><div class="content">This is different. Alpine uses busybox, where everything is implemented in the busybox binary, thus everything is symlinked to it.<p>In other distributions, test is a separate binary, and [ is a link.</div><br/></div></div></div></div><div id="38389275" class="c"><input type="checkbox" id="c-38389275" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38387972">root</a><span>|</span><a href="#38388201">parent</a><span>|</span><a href="#38388287">prev</a><span>|</span><a href="#38390084">next</a><span>|</span><label class="collapse" for="c-38389275">[-]</label><label class="expand" for="c-38389275">[1 more]</label></div><br/><div class="children"><div class="content">What bothers me is that you can write equivalent code with `test` and `[`, but when using `[` you need to terminate your conditional expression with `]`. <i>Why?</i> Isn&#x27;t it the same binary? Why is the shell adding this extraneous requirement, just to surface &quot;syntax errors&quot; rather than simply treating `]` as a no-op?</div><br/></div></div></div></div></div></div><div id="38390084" class="c"><input type="checkbox" id="c-38390084" checked=""/><div class="controls bullet"><span class="by">stn_za</span><span>|</span><a href="#38387972">prev</a><span>|</span><a href="#38387838">next</a><span>|</span><label class="collapse" for="c-38390084">[-]</label><label class="expand" for="c-38390084">[1 more]</label></div><br/><div class="children"><div class="content">js frontend dev masses ripping on bash here.  lulz</div><br/></div></div><div id="38387838" class="c"><input type="checkbox" id="c-38387838" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38390084">prev</a><span>|</span><a href="#38390117">next</a><span>|</span><label class="collapse" for="c-38387838">[-]</label><label class="expand" for="c-38387838">[9 more]</label></div><br/><div class="children"><div class="content"><i>&gt; And now for the final lolz. I’ve said above that these are the commands you use to evaluate expressions… but the shell also has expressions of its own via the !, &amp;&amp;, and || operators—all of which work on command exit statuses.</i><p>It works for simulating very basic boolean expressions, but it gets ugly quickly if you need some more complex combos of NOT, OR and AND. I wish Bash had proper boolean expressions support.</div><br/><div id="38387988" class="c"><input type="checkbox" id="c-38387988" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38387838">parent</a><span>|</span><a href="#38387958">next</a><span>|</span><label class="collapse" for="c-38387988">[-]</label><label class="expand" for="c-38387988">[3 more]</label></div><br/><div class="children"><div class="content">It works fine, you can satisfy your boolean logic needs with bash tests and exit codes.<p>You&#x27;d be amazed at how much of the world runs (just fine!) on bash conditionals.</div><br/><div id="38389037" class="c"><input type="checkbox" id="c-38389037" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#38387838">root</a><span>|</span><a href="#38387988">parent</a><span>|</span><a href="#38387958">next</a><span>|</span><label class="collapse" for="c-38389037">[-]</label><label class="expand" for="c-38389037">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;d be surprised how much of the world runs on cobol and Fortran.<p>Doesn&#x27;t mean those are good or even okay or that people should choose to use them.</div><br/></div></div></div></div><div id="38387958" class="c"><input type="checkbox" id="c-38387958" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#38387838">parent</a><span>|</span><a href="#38387988">prev</a><span>|</span><a href="#38388084">next</a><span>|</span><label class="collapse" for="c-38387958">[-]</label><label class="expand" for="c-38387958">[4 more]</label></div><br/><div class="children"><div class="content">What do you mean? Bash does have (), {}, !, &amp;&amp;, ||<p>What else do you need for &quot;proper Boolean expressions support&quot;?</div><br/><div id="38388253" class="c"><input type="checkbox" id="c-38388253" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38387838">root</a><span>|</span><a href="#38387958">parent</a><span>|</span><a href="#38388084">next</a><span>|</span><label class="collapse" for="c-38388253">[-]</label><label class="expand" for="c-38388253">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can assign boolean variables to boolean expressions, becasue there is no boolean type.<p>Something like this won&#x27;t work to become false:<p><pre><code>    foo=true
    bar=false

    baz=$foo &amp;&amp; $bar
    echo $baz
</code></pre>
Or even simply:<p><pre><code>    foo=! $foo
</code></pre>
With numeric expressions, you can at least use $((...))</div><br/><div id="38389592" class="c"><input type="checkbox" id="c-38389592" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38387838">root</a><span>|</span><a href="#38388253">parent</a><span>|</span><a href="#38388084">next</a><span>|</span><label class="collapse" for="c-38389592">[-]</label><label class="expand" for="c-38389592">[2 more]</label></div><br/><div class="children"><div class="content">Yeh you&#x27;d have to do something like<p><pre><code>    foo=true
    bar=false

    $($foo) &amp;&amp; $($bar); baz=$?
    case $baz in
    1) echo false;;
    0) echo true;;
    esac
</code></pre>
It just ain&#x27;t worth it.</div><br/><div id="38390680" class="c"><input type="checkbox" id="c-38390680" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38387838">root</a><span>|</span><a href="#38389592">parent</a><span>|</span><a href="#38388084">next</a><span>|</span><label class="collapse" for="c-38390680">[-]</label><label class="expand" for="c-38390680">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s very convoluted. It would be useful to have some context for boolean expressions, similarly how $((...)) works for numeric ones.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38390117" class="c"><input type="checkbox" id="c-38390117" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#38387838">prev</a><span>|</span><a href="#38388151">next</a><span>|</span><label class="collapse" for="c-38390117">[-]</label><label class="expand" for="c-38390117">[7 more]</label></div><br/><div class="children"><div class="content">Writing bash scripts seems like the ideal use case for Chat-GPT style programming.<p>The programs are fairly short, examples are common in the corpus, and the syntax and execution model are so inscrutable that only a machine can pretend to understand what’s going on.</div><br/><div id="38390765" class="c"><input type="checkbox" id="c-38390765" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38390117">parent</a><span>|</span><a href="#38390160">next</a><span>|</span><label class="collapse" for="c-38390765">[-]</label><label class="expand" for="c-38390765">[1 more]</label></div><br/><div class="children"><div class="content">I tried doing this and it made a bunch of mistakes with handing spaces and whatnot that makes shell scripts often brittle. Of course, a human would probably make the same mistakes, because who actually knows how to do that correctly? But it doesn’t really make me comfortable using it for anything but the smallest of automation tasks.</div><br/></div></div><div id="38390160" class="c"><input type="checkbox" id="c-38390160" checked=""/><div class="controls bullet"><span class="by">croo</span><span>|</span><a href="#38390117">parent</a><span>|</span><a href="#38390765">prev</a><span>|</span><a href="#38390204">next</a><span>|</span><label class="collapse" for="c-38390160">[-]</label><label class="expand" for="c-38390160">[2 more]</label></div><br/><div class="children"><div class="content">I already tried to customize my command line prompt with it. All the arcane colouring character decodings and random character escaping missions became a &quot;put git branch names in parenthesis and make it cyan&quot;.</div><br/><div id="38390229" class="c"><input type="checkbox" id="c-38390229" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#38390117">root</a><span>|</span><a href="#38390160">parent</a><span>|</span><a href="#38390204">next</a><span>|</span><label class="collapse" for="c-38390229">[-]</label><label class="expand" for="c-38390229">[1 more]</label></div><br/><div class="children"><div class="content">What’s so arcane about `echo &quot;$(tput setaf 6)cyan$(tput sgr0)&quot;`?</div><br/></div></div></div></div><div id="38390204" class="c"><input type="checkbox" id="c-38390204" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#38390117">parent</a><span>|</span><a href="#38390160">prev</a><span>|</span><a href="#38390208">next</a><span>|</span><label class="collapse" for="c-38390204">[-]</label><label class="expand" for="c-38390204">[1 more]</label></div><br/><div class="children"><div class="content">For sure:<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;spullara&#x2F;0fc3e88150f66179017b9aa1758d49d2" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;spullara&#x2F;0fc3e88150f66179017b9aa1758...</a></div><br/></div></div><div id="38390208" class="c"><input type="checkbox" id="c-38390208" checked=""/><div class="controls bullet"><span class="by">rjblackman</span><span>|</span><a href="#38390117">parent</a><span>|</span><a href="#38390204">prev</a><span>|</span><a href="#38390237">next</a><span>|</span><label class="collapse" for="c-38390208">[-]</label><label class="expand" for="c-38390208">[1 more]</label></div><br/><div class="children"><div class="content">yes, this is the best use case I have found for chat gpt. I&#x27;ve been automating away all of my little annoyances with powershell.</div><br/></div></div></div></div><div id="38388271" class="c"><input type="checkbox" id="c-38388271" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#38388151">prev</a><span>|</span><label class="collapse" for="c-38388271">[-]</label><label class="expand" for="c-38388271">[8 more]</label></div><br/><div class="children"><div class="content">&gt; But if you know your script is going to be Bash-specific anyway, you are probably better served by using [[ unconditionally and consistently<p>Honestly, I think writing a Bash script is just a terrible idea. Use a real language, and all of these nightmares go away.<p>For me, lately, that&#x27;s been Zx (which uses Node), but there are other fine choices too.</div><br/><div id="38388857" class="c"><input type="checkbox" id="c-38388857" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#38388271">parent</a><span>|</span><a href="#38388457">next</a><span>|</span><label class="collapse" for="c-38388857">[-]</label><label class="expand" for="c-38388857">[6 more]</label></div><br/><div class="children"><div class="content">Bash is &quot;real language&quot; <i>if you treat it as such</i>. Yes, there are plenty of spaghetti scripts out there, riddled with global variables and full of side-effects, but if you write shell in a principled manner, you can solve some pretty big problems with ease, and you can write maintainable code.<p>I wouldn&#x27;t start new projects in shell, of course, but one area in which I think the shell shines is in writing integration tests for tools. More on this in a recent post I wrote: <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;10&#x2F;unit-testing-with-shtk.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;10&#x2F;unit-testing-with-shtk.html</a></div><br/><div id="38389551" class="c"><input type="checkbox" id="c-38389551" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38388271">root</a><span>|</span><a href="#38388857">parent</a><span>|</span><a href="#38389885">next</a><span>|</span><label class="collapse" for="c-38389551">[-]</label><label class="expand" for="c-38389551">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Bash is &quot;real language&quot; if you treat it as such. Yes, there are plenty of spaghetti scripts out there, riddled with global variables and full of side-effects, but if you write shell in a principled manner, you can solve some pretty big problems with ease, and you can write maintainable code.<p>Even carefully written bash code tends to be much less maintainable than code in better languages. It&#x27;s just badly designed on multiple levels, like the famous post about PHP. Yes, if you&#x27;re really careful you can write decent code in Malbolge - but why would you?<p>&gt; I wouldn&#x27;t start new projects in shell, of course, but one area in which I think the shell shines is in writing integration tests for tools. More on this in a recent post I wrote: <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;10&#x2F;unit-testing-with-shtk.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;10&#x2F;unit-testing-with-shtk.html</a><p>The fact that you&#x27;ve written something that compiles to shell scripts rather than writing shell scripts rather undermines your claim that shell is a decent language. Integration tests of tools are important, but I&#x27;d still find e.g. TCL a much better way to write them.</div><br/></div></div><div id="38389885" class="c"><input type="checkbox" id="c-38389885" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#38388271">root</a><span>|</span><a href="#38388857">parent</a><span>|</span><a href="#38389551">prev</a><span>|</span><a href="#38389378">next</a><span>|</span><label class="collapse" for="c-38389885">[-]</label><label class="expand" for="c-38389885">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but if you write shell in a principled manner, you can solve some pretty big problems with ease, and you can write maintainable code.<p>So if you are extremely good at writing shell, and you write it extremely carefully, then you can achieve basically what you can do in other languages without those caveats?<p>It sounds like we both agree that shell is not a sensible choice for scripting, for most people, then.</div><br/></div></div><div id="38389378" class="c"><input type="checkbox" id="c-38389378" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#38388271">root</a><span>|</span><a href="#38388857">parent</a><span>|</span><a href="#38389885">prev</a><span>|</span><a href="#38388457">next</a><span>|</span><label class="collapse" for="c-38389378">[-]</label><label class="expand" for="c-38389378">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but if you write shell in a principled manner<p>The same can be said about QBasic as well, honestly. And here&#x27;s the catch: people who are inclined to write anything in a principled manner are likely the ones who&#x27;d write things in a principled language instead of e.g. shell. Or to put it in another way, if someone chosen to write in shell (or failed to consider an alternative, which also happens quite often), they&#x27;re quite likely exactly the person to not write anything in a principled manner.</div><br/><div id="38389547" class="c"><input type="checkbox" id="c-38389547" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#38388271">root</a><span>|</span><a href="#38389378">parent</a><span>|</span><a href="#38388457">next</a><span>|</span><label class="collapse" for="c-38389547">[-]</label><label class="expand" for="c-38389547">[2 more]</label></div><br/><div class="children"><div class="content">Oftentimes, the constraints around what you have to do dictate what language(s) you can use. So you do what you can with them and you try to get the best out of them. <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;11&#x2F;why-do-i-know-shell-and-how-can-you.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;11&#x2F;why-do-i-know-shell-and-how-can-you...</a></div><br/><div id="38390109" class="c"><input type="checkbox" id="c-38390109" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#38388271">root</a><span>|</span><a href="#38389547">parent</a><span>|</span><a href="#38388457">next</a><span>|</span><label class="collapse" for="c-38390109">[-]</label><label class="expand" for="c-38390109">[1 more]</label></div><br/><div class="children"><div class="content">I think one of the Rust&#x27;s creators (or was it Go&#x27;s?) said that they wanted to get the C++ developers to switch to their language but that didn&#x27;t happend, they unexpectedly got Python developers instead but retrospectively it makes sense to them: people who wanted to switch from C++ <i>and could afford to</i> had done so already, so the C++ developers are the people who either don&#x27;t mind C++ or the people who have to write it.<p>Which brings me back to my point: yes, technically you can write decent code even in a sloppy language but that misses the bigger picture which is that most of the code written in a sloppy language will inevitably be sloppy because most of the people who write it won&#x27;t care, due to the dynamics described.<p>Heck, the Ops department in my org was <i>forced</i> by the security guys to globally enable ShellCheck on commit for their internal repos, and those security guys still have to drop by about every 2-3 months to rip away their &quot;# shellcheck disable&quot; pragmas and force them to actually fix their broken code because those people in the ops <i>actively</i> don&#x27;t care. The Ruby scripts they write end up slightly less broken because Ruby itself is a slightly more principled language, not because they suddenly care more when they write Ruby.<p>Not to mention myself: I&#x27;ve spent quite some time and energy on learning shell&#x27;s semantics and tricks and quirks and DOs and DONTs but it&#x27;s such an infinite, never-ending descent into abyss with rewards of dubious value that nowadays I just don&#x27;t care. Whenever I have to write a one-off script, I give up even before I start and write it however sloppy, with minimal quoting, to save my time; and only when it breaks, <i>or</i> when I have to reuse it, <i>or</i> when I have to share it — which happens quite rarely — then I re-write it in a proper language. On the whole, that definitely saved me both my time and my sanity. As for the cases when I <i>have</i> to write properly behaving shell script, well, those are almost arise in the course of the tasks that can be delegated to our ops team and now that&#x27;s their problem.<p>P.S. I found that re-writing naive but broken shell scripts in a proper language is quite easy: the intended semantics is generally obvious, it&#x27;s just the shell that actually requires quirkier syntax to propely express it; re-writing the (mostly) non-broken shell scripts is much harder: you have to decipher the intended meaining from the quirky syntax while keeping in mind that the original author still could have gotten it wrong by not knowing about a particular quirk you&#x27;re aware about (or vice versa).</div><br/></div></div></div></div></div></div></div></div><div id="38388457" class="c"><input type="checkbox" id="c-38388457" checked=""/><div class="controls bullet"><span class="by">LegibleCrimson</span><span>|</span><a href="#38388271">parent</a><span>|</span><a href="#38388857">prev</a><span>|</span><label class="collapse" for="c-38388457">[-]</label><label class="expand" for="c-38388457">[1 more]</label></div><br/><div class="children"><div class="content">I agree. If a POSIX shell script serves your needs, use it. If it doesn&#x27;t, you shouldn&#x27;t be reaching for a more powerful shell, but an actual language. I&#x27;d reach for Perl before Bash, and I can&#x27;t stand Perl.</div><br/></div></div></div></div></div></div></div></div></div></body></html>