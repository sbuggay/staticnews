<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689584451521" as="style"/><link rel="stylesheet" href="styles.css?v=1689584451521"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://denizaksimsek.com/2023/xpath/">Using XPath in 2023</a> <span class="domain">(<a href="https://denizaksimsek.com">denizaksimsek.com</a>)</span></div><div class="subtext"><span>recursivedoubts</span> | <span>43 comments</span></div><br/><div><div id="36755639" class="c"><input type="checkbox" id="c-36755639" checked=""/><div class="controls bullet"><span class="by">raphinou</span><span>|</span><a href="#36755299">next</a><span>|</span><label class="collapse" for="c-36755639">[-]</label><label class="expand" for="c-36755639">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using Playwright [1] (dotnet version) to test my web app, and I mainly use XPath to identify elements on a page. I found it to be to the best choice in my use case, mainly because it is composable. I can define an XPAth to a table `tableXPath` and then reuse it to identify a cell in the table like eg $&quot;&quot;&quot;{tableXPath}&#x2F;&#x2F;td[text()=&quot;my value&quot;]&quot;&quot;&quot;, and I can further reuse that to identify a sibling cell which might trigger an action.<p>1: <a href="https:&#x2F;&#x2F;playwright.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;playwright.dev</a></div><br/></div></div><div id="36755299" class="c"><input type="checkbox" id="c-36755299" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#36755639">prev</a><span>|</span><a href="#36754439">next</a><span>|</span><label class="collapse" for="c-36755299">[-]</label><label class="expand" for="c-36755299">[5 more]</label></div><br/><div class="children"><div class="content">A major pain point of using XPath in isolation (not embedded in XSLT or something else) is those damn namespace bindings. Ugly enough as xmlns: pseudo attributes, in the absence of XML you&#x27;d have to use freaking XPointer bindings (as in &quot;xmlns(bla=uri)&#x2F;&#x2F;bla:xpathexpr&#x2F;bla:following[@here]&quot;, interpret HTML as XHTML with implicit namespaces, and similar tricks I thought HTML5 left behind for good. Bit surprised htmx falls into the XML nostalgia trap.</div><br/><div id="36755429" class="c"><input type="checkbox" id="c-36755429" checked=""/><div class="controls bullet"><span class="by">arethuza</span><span>|</span><a href="#36755299">parent</a><span>|</span><a href="#36754439">next</a><span>|</span><label class="collapse" for="c-36755429">[-]</label><label class="expand" for="c-36755429">[4 more]</label></div><br/><div class="children"><div class="content">Namespaces always seemed to be the ugliest part of the XML ecosystem - I know why they were required, but they always seemed to be horrible to work with.</div><br/><div id="36755525" class="c"><input type="checkbox" id="c-36755525" checked=""/><div class="controls bullet"><span class="by">yrro</span><span>|</span><a href="#36755299">root</a><span>|</span><a href="#36755429">parent</a><span>|</span><a href="#36754439">next</a><span>|</span><label class="collapse" for="c-36755525">[-]</label><label class="expand" for="c-36755525">[3 more]</label></div><br/><div class="children"><div class="content">I just can&#x27;t fathom why they chose to use URLs--with a protocol--to define namespaces? By all means use the DNS, but bar.foo.example.com would have been such a better choice than <a href="http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar" rel="nofollow noreferrer">http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar</a>!</div><br/><div id="36755627" class="c"><input type="checkbox" id="c-36755627" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#36755299">root</a><span>|</span><a href="#36755525">parent</a><span>|</span><a href="#36754439">next</a><span>|</span><label class="collapse" for="c-36755627">[-]</label><label class="expand" for="c-36755627">[2 more]</label></div><br/><div class="children"><div class="content">Even the original designers of XML (those responsible for subsetting XML from SGML, and those responsible for dropping the ball by adding XML namespaces on top ;) aren&#x27;t happy with it [1].<p>As to why URIs, I completely agree. I think URIs&#x2F;URLs were introduced by TBL as arguably <i>the</i> major feat of HTML over generic SGML along with &lt;a&gt; and so phenomenally successful every W3C mechanism of name resolution and namespacing had to make use if it; RDF is littered with namespaces as well.<p>[1]: <a href="https:&#x2F;&#x2F;blog.jclark.com&#x2F;2010&#x2F;01&#x2F;xml-namespaces.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.jclark.com&#x2F;2010&#x2F;01&#x2F;xml-namespaces.html</a></div><br/><div id="36755673" class="c"><input type="checkbox" id="c-36755673" checked=""/><div class="controls bullet"><span class="by">arethuza</span><span>|</span><a href="#36755299">root</a><span>|</span><a href="#36755627">parent</a><span>|</span><a href="#36754439">next</a><span>|</span><label class="collapse" for="c-36755673">[-]</label><label class="expand" for="c-36755673">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite fascinating - shows how you can have a design process where every step is completely reasonable but the end-result can still be horrible!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36754439" class="c"><input type="checkbox" id="c-36754439" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#36755299">prev</a><span>|</span><a href="#36752968">next</a><span>|</span><label class="collapse" for="c-36754439">[-]</label><label class="expand" for="c-36754439">[4 more]</label></div><br/><div class="children"><div class="content">My personal homepage in the 2000&#x27;s was a simple XML document, automatically translated with XSLT. IE supported that using &lt;?xml-stylesheet?&gt; pre-processor tag. When you tried to view its source, you&#x27;d only see a weird XML markup. Surprised a few I&#x27;m sure as this predates Firebug and similar DOM inspectors :)<p>I actually liked XML + XSLT + XPath combo a lot, and kept using them with my projects at Microsoft.</div><br/><div id="36754761" class="c"><input type="checkbox" id="c-36754761" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#36754439">parent</a><span>|</span><a href="#36754496">next</a><span>|</span><label class="collapse" for="c-36754761">[-]</label><label class="expand" for="c-36754761">[1 more]</label></div><br/><div class="children"><div class="content">One of the first places I worked ended up creating quite a nice framework where components would ask for data that was all put in a single SHAPE query, and the view layer was just XSLT (which is a perfectly nice functional language once you understand it). Was pretty productive.</div><br/></div></div><div id="36754496" class="c"><input type="checkbox" id="c-36754496" checked=""/><div class="controls bullet"><span class="by">MrOxiMoron</span><span>|</span><a href="#36754439">parent</a><span>|</span><a href="#36754761">prev</a><span>|</span><a href="#36754559">next</a><span>|</span><label class="collapse" for="c-36754496">[-]</label><label class="expand" for="c-36754496">[1 more]</label></div><br/><div class="children"><div class="content">I did the same, and then allowed logged in users to define their own stylesheet. Thought it was pretty cool at the time.</div><br/></div></div><div id="36754559" class="c"><input type="checkbox" id="c-36754559" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#36754439">parent</a><span>|</span><a href="#36754496">prev</a><span>|</span><a href="#36752968">next</a><span>|</span><label class="collapse" for="c-36754559">[-]</label><label class="expand" for="c-36754559">[1 more]</label></div><br/><div class="children"><div class="content">This is still supported in the like of Chrome&#x2F;Safari. It just sucks as they never upgraded past XSL&#x2F;T 1.0.</div><br/></div></div></div></div><div id="36752968" class="c"><input type="checkbox" id="c-36752968" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#36754439">prev</a><span>|</span><a href="#36753812">next</a><span>|</span><label class="collapse" for="c-36752968">[-]</label><label class="expand" for="c-36752968">[14 more]</label></div><br/><div class="children"><div class="content">All those devs who skipped xpath&#x2F;xquery&#x2F;xslt from the bad old days of xml are going to get a panic attack.</div><br/><div id="36754515" class="c"><input type="checkbox" id="c-36754515" checked=""/><div class="controls bullet"><span class="by">ketralnis</span><span>|</span><a href="#36752968">parent</a><span>|</span><a href="#36754600">next</a><span>|</span><label class="collapse" for="c-36754515">[-]</label><label class="expand" for="c-36754515">[1 more]</label></div><br/><div class="children"><div class="content">XML had a bad rap and was certainly abused. But the wealth and quality of the tools for working with it is really unmatched even today.</div><br/></div></div><div id="36754600" class="c"><input type="checkbox" id="c-36754600" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishc</span><span>|</span><a href="#36752968">parent</a><span>|</span><a href="#36754515">prev</a><span>|</span><a href="#36753534">next</a><span>|</span><label class="collapse" for="c-36754600">[-]</label><label class="expand" for="c-36754600">[3 more]</label></div><br/><div class="children"><div class="content">Domenic Denicola (aka the man who ruined promises) probably will as well.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;dom&#x2F;issues&#x2F;67">https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;dom&#x2F;issues&#x2F;67</a></div><br/><div id="36754890" class="c"><input type="checkbox" id="c-36754890" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36754600">parent</a><span>|</span><a href="#36754907">next</a><span>|</span><label class="collapse" for="c-36754890">[-]</label><label class="expand" for="c-36754890">[1 more]</label></div><br/><div class="children"><div class="content">That made me chuckle.<p>For those not familiar with the promise design controversy:<p><a href="http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;category_theory_promisesaplus" rel="nofollow noreferrer">http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;category_theory_promisesaplus</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;promises-aplus&#x2F;constructor-spec&#x2F;issues&#x2F;24">https:&#x2F;&#x2F;github.com&#x2F;promises-aplus&#x2F;constructor-spec&#x2F;issues&#x2F;24</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;promises-aplus&#x2F;promises-spec&#x2F;issues&#x2F;94">https:&#x2F;&#x2F;github.com&#x2F;promises-aplus&#x2F;promises-spec&#x2F;issues&#x2F;94</a></div><br/></div></div><div id="36754907" class="c"><input type="checkbox" id="c-36754907" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36754600">parent</a><span>|</span><a href="#36754890">prev</a><span>|</span><a href="#36753534">next</a><span>|</span><label class="collapse" for="c-36754907">[-]</label><label class="expand" for="c-36754907">[1 more]</label></div><br/><div class="children"><div class="content">How did he ruin it?<p>EDIT: Thanks, sibling!</div><br/></div></div></div></div><div id="36753534" class="c"><input type="checkbox" id="c-36753534" checked=""/><div class="controls bullet"><span class="by">MilStdJunkie</span><span>|</span><a href="#36752968">parent</a><span>|</span><a href="#36754600">prev</a><span>|</span><a href="#36753649">next</a><span>|</span><label class="collapse" for="c-36753534">[-]</label><label class="expand" for="c-36753534">[4 more]</label></div><br/><div class="children"><div class="content">Xquery, for me, was and remains a core tool for dealing with XML specifications of surreal complexity that verge on madness. BaseX is the &quot;Microsoft Access&quot; xquery application, while eXist is sort of like a full framework, with package management, deployment, and that sort of thing. Other query languages might be more cutting edge, but they either 1) have a lot of stuff I don&#x27;t need, or, more likely, 2) require a more permissive InfoSec setup than I am typically allowed. &quot;Docker and any other form of virtualization are not permitted on ANY company network regardless of circumstances&quot;. Well, ok then.<p>Generally the next stop after xquery, for me, is text mining, either on R+Python or on Orange ML. If a miner doesn&#x27;t cut it, then LLM shenanigans.<p>Also, xpath? It&#x27;s pretty great. XQuery? Does the job. XSLT? Ok, so NOW that&#x27;s the feeling of a panic attack. I&#x27;ve been doing XSLT for literal decades, and I still don&#x27;t know what I&#x27;m doing when wrenching on a giant pile of FOP generating funhouse madness. When I am tagged into a data transformation job, I always stress that xquery is the right tool, rather than a confounding nested directory of XSLT using different parsers and different passes like a figure-8 interstate off-ramp. For FOP, though, there&#x27;s really just one game in town for that. Although, having said that, me and a bunch of others are doing our damndest to show that what you&#x27;re trying to do with XSLT&#x2F;FO can be done way way <i>way</i> easier with CSS and Paged Media (either via Paged.js or Vivliostyle or any of the other zillion PMM implementations). The downside is you have to wrench some CSS yourself, but honestly, that&#x27;s probably going to be easier than wrenching on DocBook-XSL or the DITA-OT or one of the MIL-STD XSL packages.</div><br/><div id="36753904" class="c"><input type="checkbox" id="c-36753904" checked=""/><div class="controls bullet"><span class="by">mcswell</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36753534">parent</a><span>|</span><a href="#36753836">next</a><span>|</span><label class="collapse" for="c-36753904">[-]</label><label class="expand" for="c-36753904">[1 more]</label></div><br/><div class="children"><div class="content">Glad to hear that someone else thinks of XSLT the way I do.  I had to write some to deal with converting DocBook XML to LaTeX (building on dblatex, but adding some specializations), and besides being verbose (as another commenter here says), I found it virtually impossible to debug.  I&#x27;d much rather write in Prolog.</div><br/></div></div><div id="36753836" class="c"><input type="checkbox" id="c-36753836" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36753534">parent</a><span>|</span><a href="#36753904">prev</a><span>|</span><a href="#36753649">next</a><span>|</span><label class="collapse" for="c-36753836">[-]</label><label class="expand" for="c-36753836">[2 more]</label></div><br/><div class="children"><div class="content">The problem with XSLT is how incredibly verbose it is, but maybe that&#x27;s just the problem with XML.  jq is to JSON as XSLT&#x2F;XPath is to XML, which shows you can have pithiness.</div><br/><div id="36755034" class="c"><input type="checkbox" id="c-36755034" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36753836">parent</a><span>|</span><a href="#36753649">next</a><span>|</span><label class="collapse" for="c-36755034">[-]</label><label class="expand" for="c-36755034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; maybe that&#x27;s just the problem with XML<p>It’s the problem from having built XSLT out of XML, that was completely unnecessary.<p>And then with XSLT being so verbose, having cheaped out and made the current node (“.”) so implicit. And the confusion from the dual use of templates as both match&#x2F;patch and function constructs (it would have worked fine as a <i>shortcut</i>, but it makes grokking how things fit much harder than necessary).<p>I wouldn’t say jq is really comparable to xslt though, xslt has much more transformative flexibility. It’s closer to xquery.</div><br/></div></div></div></div></div></div><div id="36753649" class="c"><input type="checkbox" id="c-36753649" checked=""/><div class="controls bullet"><span class="by">AbraKdabra</span><span>|</span><a href="#36752968">parent</a><span>|</span><a href="#36753534">prev</a><span>|</span><a href="#36752978">next</a><span>|</span><label class="collapse" for="c-36753649">[-]</label><label class="expand" for="c-36753649">[1 more]</label></div><br/><div class="children"><div class="content">I had that skip until two years ago when I had to use it to parse the OpenVAS API output. I wish I never had to put a stop to that skip, I hated every second of my life working with XPath.</div><br/></div></div><div id="36752978" class="c"><input type="checkbox" id="c-36752978" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#36752968">parent</a><span>|</span><a href="#36753649">prev</a><span>|</span><a href="#36753812">next</a><span>|</span><label class="collapse" for="c-36752978">[-]</label><label class="expand" for="c-36752978">[4 more]</label></div><br/><div class="children"><div class="content">IME their opinions are split between trauma and nostalgia.</div><br/><div id="36753033" class="c"><input type="checkbox" id="c-36753033" checked=""/><div class="controls bullet"><span class="by">smrtinsert</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36752978">parent</a><span>|</span><a href="#36753812">next</a><span>|</span><label class="collapse" for="c-36753033">[-]</label><label class="expand" for="c-36753033">[3 more]</label></div><br/><div class="children"><div class="content">Xslt and xml apis could do neat things.  I didn&#x27;t mind the era</div><br/><div id="36753386" class="c"><input type="checkbox" id="c-36753386" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36753033">parent</a><span>|</span><a href="#36753812">next</a><span>|</span><label class="collapse" for="c-36753386">[-]</label><label class="expand" for="c-36753386">[2 more]</label></div><br/><div class="children"><div class="content">Starting to see more use of JSON Schemas in my job and can&#x27;t help but think ... &quot;we had something for this previously&quot;.</div><br/><div id="36753821" class="c"><input type="checkbox" id="c-36753821" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36752968">root</a><span>|</span><a href="#36753386">parent</a><span>|</span><a href="#36753812">next</a><span>|</span><label class="collapse" for="c-36753821">[-]</label><label class="expand" for="c-36753821">[1 more]</label></div><br/><div class="children"><div class="content">jq is the XSLT&#x2F;XPath of JSON.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36753812" class="c"><input type="checkbox" id="c-36753812" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#36752968">prev</a><span>|</span><a href="#36755440">next</a><span>|</span><label class="collapse" for="c-36753812">[-]</label><label class="expand" for="c-36753812">[5 more]</label></div><br/><div class="children"><div class="content">I use xpath literally every time I need to look for something on a webpage before resorting to scraping.</div><br/><div id="36754546" class="c"><input type="checkbox" id="c-36754546" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36753812">parent</a><span>|</span><a href="#36754389">next</a><span>|</span><label class="collapse" for="c-36754546">[-]</label><label class="expand" for="c-36754546">[3 more]</label></div><br/><div class="children"><div class="content">What &#x2F; how do you use it? I&#x27;ve only ever used xpath <i>for</i> scraping, and I don&#x27;t know how it can be useful outside of scraping.</div><br/><div id="36755423" class="c"><input type="checkbox" id="c-36755423" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#36753812">root</a><span>|</span><a href="#36754546">parent</a><span>|</span><a href="#36754996">next</a><span>|</span><label class="collapse" for="c-36755423">[-]</label><label class="expand" for="c-36755423">[1 more]</label></div><br/><div class="children"><div class="content">I think you can use it in the browser&#x27;s inspector.</div><br/></div></div><div id="36754996" class="c"><input type="checkbox" id="c-36754996" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36753812">root</a><span>|</span><a href="#36754546">parent</a><span>|</span><a href="#36755423">prev</a><span>|</span><a href="#36754389">next</a><span>|</span><label class="collapse" for="c-36754996">[-]</label><label class="expand" for="c-36754996">[1 more]</label></div><br/><div class="children"><div class="content">End to end testing comes to mind, for UI testing.</div><br/></div></div></div></div><div id="36754389" class="c"><input type="checkbox" id="c-36754389" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36753812">parent</a><span>|</span><a href="#36754546">prev</a><span>|</span><a href="#36755440">next</a><span>|</span><label class="collapse" for="c-36754389">[-]</label><label class="expand" for="c-36754389">[1 more]</label></div><br/><div class="children"><div class="content">I am the opposite. The only time I use xpath is for scraping.</div><br/></div></div></div></div><div id="36755440" class="c"><input type="checkbox" id="c-36755440" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#36753812">prev</a><span>|</span><a href="#36753410">next</a><span>|</span><label class="collapse" for="c-36755440">[-]</label><label class="expand" for="c-36755440">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me to check out SXPath [1] at some point.<p>[1]: <a href="https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;Scheme&#x2F;xml.html#SXPath" rel="nofollow noreferrer">https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;Scheme&#x2F;xml.html#SXPath</a></div><br/></div></div><div id="36753410" class="c"><input type="checkbox" id="c-36753410" checked=""/><div class="controls bullet"><span class="by">solardev</span><span>|</span><a href="#36755440">prev</a><span>|</span><a href="#36755179">next</a><span>|</span><label class="collapse" for="c-36753410">[-]</label><label class="expand" for="c-36753410">[3 more]</label></div><br/><div class="children"><div class="content">These are still really useful in Jest&#x2F;Playwright tests when you don&#x27;t have an easy CSS selector or ID&#x2F;class to choose from. XPath is super powerful, especially for dynamic pages&#x2F;apps where the DOM isn&#x27;t necessarily predictable but the relative positions of items (like a card in a list) are.</div><br/><div id="36753742" class="c"><input type="checkbox" id="c-36753742" checked=""/><div class="controls bullet"><span class="by">cmehdy</span><span>|</span><a href="#36753410">parent</a><span>|</span><a href="#36754128">next</a><span>|</span><label class="collapse" for="c-36753742">[-]</label><label class="expand" for="c-36753742">[1 more]</label></div><br/><div class="children"><div class="content">XPath is also good if you think of it in adversarial terms (i.e. QA). I don&#x27;t care what you div is - I care what text is on the page or whether something is saying what I expect under a title. That&#x27;s where I got familiar with it (writing automation frameworks for selenium&#x2F;appium for ff&#x2F;chrome&#x2F;ios&#x2F;android) and it did a great job at it - regardless of drivers&#x27; performance. When your eyes parse a webpage, you don&#x27;t really care whether you&#x27;re at a div or a paragraph or basically anything else - it&#x27;s the software&#x27;s job (the dev&#x27;s job) to think of it for you. Is it nested inside something with this accessibility marker? What do I start to read first? How many levels deep do I have to look? And so on and so forth.<p>I&#x27;m looking forward to those new things in htmx because it seems like it extends  what we know of html. And I can&#x27;t yet quite say if that is going to stick (by being integrated into IDEs, work with frameworks easily, be the go-to way to do this and that, etc). Time wil tell, but it&#x27;s cool to see new proposals to improve the status quo out there.</div><br/></div></div><div id="36754128" class="c"><input type="checkbox" id="c-36754128" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#36753410">parent</a><span>|</span><a href="#36753742">prev</a><span>|</span><a href="#36755179">next</a><span>|</span><label class="collapse" for="c-36754128">[-]</label><label class="expand" for="c-36754128">[1 more]</label></div><br/><div class="children"><div class="content">Using xpath in a test on a dynamic and unpredictable DOM is a painful road to flaky, brittle tests. If you&#x27;re writing tests for a system you have no control over maybe you have no choice, but if you do then I&#x27;d recommend changing the output to be something robust and testable.</div><br/></div></div></div></div><div id="36755179" class="c"><input type="checkbox" id="c-36755179" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#36753410">prev</a><span>|</span><a href="#36755059">next</a><span>|</span><label class="collapse" for="c-36755179">[-]</label><label class="expand" for="c-36755179">[2 more]</label></div><br/><div class="children"><div class="content">I used XML&#x2F;XPath&#x2F;XQuery in the early 2000s to define a custom binary protocol. It was so fantastic to have a single source of truth, and use transformations to generate both document (spec) and C serialization&#x2F;deserialization code.<p>I have never experienced that again. :(</div><br/><div id="36755219" class="c"><input type="checkbox" id="c-36755219" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36755179">parent</a><span>|</span><a href="#36755059">next</a><span>|</span><label class="collapse" for="c-36755219">[-]</label><label class="expand" for="c-36755219">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, like any popular technology, it experienced its fair share of use and abuse (people wanted XML database, XLST, XML in Scala, etc.). It&#x27;s a much-maligned tech, and with a few tweaks to the robustness, it could be pretty nice (see <a href="https:&#x2F;&#x2F;annevankesteren.nl&#x2F;2007&#x2F;10&#x2F;xml5" rel="nofollow noreferrer">https:&#x2F;&#x2F;annevankesteren.nl&#x2F;2007&#x2F;10&#x2F;xml5</a>).<p>I&#x27;d take it over YAML any day. And I speak from a YAML parser implementer perspective. Making a 1.2&#x2F;1.3 YAML parser is hard. The number of edge cases and states is absurd, while the specification needs to be on HTML&#x2F;XML level.<p>E.g. When I started working on YAML parser I didn&#x27;t expect to be fixing errors in spec. But here I am.</div><br/></div></div></div></div><div id="36755059" class="c"><input type="checkbox" id="c-36755059" checked=""/><div class="controls bullet"><span class="by">npteljes</span><span>|</span><a href="#36755179">prev</a><span>|</span><a href="#36753273">next</a><span>|</span><label class="collapse" for="c-36755059">[-]</label><label class="expand" for="c-36755059">[1 more]</label></div><br/><div class="children"><div class="content">I love XPath, I&#x27;d say that alongside of regular expressions, SQL and Excel functions, they helped in my IT career a ton.</div><br/></div></div><div id="36753273" class="c"><input type="checkbox" id="c-36753273" checked=""/><div class="controls bullet"><span class="by">tbeseda</span><span>|</span><a href="#36755059">prev</a><span>|</span><a href="#36754561">next</a><span>|</span><label class="collapse" for="c-36753273">[-]</label><label class="expand" for="c-36753273">[3 more]</label></div><br/><div class="children"><div class="content">Interesting! What are the limits of `evaluate()` in browsers? I see it is available in 95% of users&#x27; browsers [1], but is it consistent in its implementation of XPath?
How does its performance compare to `querySelector[All]`?
Might be interesting to see if JS libraries that do a lot of DOM searching could get some perf gains. Maybe they already utilize evaluate?<p>[1] <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;?search=evaluate" rel="nofollow noreferrer">https:&#x2F;&#x2F;caniuse.com&#x2F;?search=evaluate</a></div><br/><div id="36754321" class="c"><input type="checkbox" id="c-36754321" checked=""/><div class="controls bullet"><span class="by">err4nt</span><span>|</span><a href="#36753273">parent</a><span>|</span><a href="#36754561">next</a><span>|</span><label class="collapse" for="c-36754321">[-]</label><label class="expand" for="c-36754321">[2 more]</label></div><br/><div class="children"><div class="content">CSS is designed to be very fast, and because of that design choice it&#x27;s less expressive. XPath is not going to beat CSS in speed, but it allows you to move through the document in any direction (up and down in the DOM tree of elements, forward&#x2F;back among siblings in the DOM tree, and forward and backward in document appearance order).<p>We use XPath at work from CSS with custom plugins, and use XPath in JavaScript for targeting elements that otherwise wouldn&#x27;t be straightforward to select with CSS.<p>Another cool thing XPath does is have awareness of the text content of elements! &#x2F;&#x2F;li[contains(.,&quot;example&quot;)] would target all &lt;li&gt; elements with text content containing &quot;example&quot;.</div><br/><div id="36755055" class="c"><input type="checkbox" id="c-36755055" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36753273">root</a><span>|</span><a href="#36754321">parent</a><span>|</span><a href="#36754561">next</a><span>|</span><label class="collapse" for="c-36755055">[-]</label><label class="expand" for="c-36755055">[1 more]</label></div><br/><div class="children"><div class="content">FWIW CSS now has “:has” which provides a form of general purpose predication, although afaik it still doesn’t have a :contains (that was proposed for CSS3 or something but I don’t think it got accepted).<p>A huge part of XPath’s power though, and something you AFAIK can’t do in browsers, is extensibility.<p>For instance selecting an element on the basis of a class is absolute hell in XPath 1.0 (and not great in 2.0 either, XPath 3.1’s `contains-token` finally made that not hell). But server-side you don’t care because pretty much all implementations allow installing your own functions so you can add your own `contains-token` or even `has-class` predicate and be on your way.</div><br/></div></div></div></div></div></div><div id="36754561" class="c"><input type="checkbox" id="c-36754561" checked=""/><div class="controls bullet"><span class="by">sonium</span><span>|</span><a href="#36753273">prev</a><span>|</span><a href="#36755041">next</a><span>|</span><label class="collapse" for="c-36754561">[-]</label><label class="expand" for="c-36754561">[1 more]</label></div><br/><div class="children"><div class="content">There is also a JSON analog which if found quite handy sometimes to extract some values deeply nested in an API response. Its also natively supported by some databases that have JSON datatypes like mysql.</div><br/></div></div><div id="36755041" class="c"><input type="checkbox" id="c-36755041" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#36754561">prev</a><span>|</span><a href="#36753137">next</a><span>|</span><label class="collapse" for="c-36755041">[-]</label><label class="expand" for="c-36755041">[1 more]</label></div><br/><div class="children"><div class="content">You can simply use this in the browser console to get a friendly XPath API:<p><pre><code>    $x(&quot;&#x2F;&#x2F;my&#x2F;selector&quot;)
</code></pre>
Very handy for testing XPath expressions for Selenium or Playwright tests, if there is no data-testid attribute.</div><br/></div></div></div></div></div></div></div></body></html>