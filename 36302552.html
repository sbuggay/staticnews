<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686733268785" as="style"/><link rel="stylesheet" href="styles.css?v=1686733268785"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://theleo.zone/posts/hashmap-in-c/">A simple hash table in C</a> <span class="domain">(<a href="https://theleo.zone">theleo.zone</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>61 comments</span></div><br/><div><div id="36317297" class="c"><input type="checkbox" id="c-36317297" checked=""/><div class="controls bullet"><span class="by">coffeeri</span><span>|</span><a href="#36318446">next</a><span>|</span><label class="collapse" for="c-36317297">[-]</label><label class="expand" for="c-36317297">[21 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had lately a look at QEMUs internals and saw their thread safe implementation of a hash table, capable of concurrent reads: qht [0].<p>If the author sees this, you might want to take a look at it.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;qemu&#x2F;qemu&#x2F;blob&#x2F;master&#x2F;util&#x2F;qht.c">https:&#x2F;&#x2F;github.com&#x2F;qemu&#x2F;qemu&#x2F;blob&#x2F;master&#x2F;util&#x2F;qht.c</a></div><br/><div id="36321769" class="c"><input type="checkbox" id="c-36321769" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#36317297">parent</a><span>|</span><a href="#36318559">next</a><span>|</span><label class="collapse" for="c-36321769">[-]</label><label class="expand" for="c-36321769">[3 more]</label></div><br/><div class="children"><div class="content">Curious why concurrent reads would ever be an issue. As long as there are no writes during those reads... everything should be stable, no?</div><br/><div id="36323070" class="c"><input type="checkbox" id="c-36323070" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36321769">parent</a><span>|</span><a href="#36321867">next</a><span>|</span><label class="collapse" for="c-36323070">[-]</label><label class="expand" for="c-36323070">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really know that though.<p>Without appropriate memory barriers, you can end up with an inconsistent view of the memory due to out-of-order execution and other weird stuff the CPU does behind the scenes.<p>There&#x27;s significant footguns around low level concurrency primitives.</div><br/></div></div><div id="36321867" class="c"><input type="checkbox" id="c-36321867" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36321769">parent</a><span>|</span><a href="#36323070">prev</a><span>|</span><a href="#36318559">next</a><span>|</span><label class="collapse" for="c-36321867">[-]</label><label class="expand" for="c-36321867">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t seem to be very curious because your questions are clarified literally in the very first comment in OP&#x27;s link.</div><br/></div></div></div></div><div id="36318559" class="c"><input type="checkbox" id="c-36318559" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#36317297">parent</a><span>|</span><a href="#36321769">prev</a><span>|</span><a href="#36318446">next</a><span>|</span><label class="collapse" for="c-36318559">[-]</label><label class="expand" for="c-36318559">[17 more]</label></div><br/><div class="children"><div class="content">OP doesn&#x27;t include a license, but OP author&#x27;s GitHub is mostly MIT or CC-BY.<p>Since QEMU&#x27;s implementation is GPL, it&#x27;s probably best if OP author does <i>not</i> take a look at it.</div><br/><div id="36320059" class="c"><input type="checkbox" id="c-36320059" checked=""/><div class="controls bullet"><span class="by">haileys</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318559">parent</a><span>|</span><a href="#36318829">next</a><span>|</span><label class="collapse" for="c-36320059">[-]</label><label class="expand" for="c-36320059">[3 more]</label></div><br/><div class="children"><div class="content">This is such a case of lawyer brain.<p>The OP wrote this as a learning exercise. With the goal of learning in mind, I would suggest that it&#x27;s probably best for the OP to go and read as much code as they possibly can, no matter the license!</div><br/><div id="36321887" class="c"><input type="checkbox" id="c-36321887" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36320059">parent</a><span>|</span><a href="#36322318">next</a><span>|</span><label class="collapse" for="c-36321887">[-]</label><label class="expand" for="c-36321887">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is such a case of lawyer brain.<p>I&#x27;m not sure you are fully aware of the implications. In fact, it seems you&#x27;re dismissing easily avoidable risks by arguing you&#x27;d never be caught.<p>You can read plenty of code without risking accusations of license agreement violations.</div><br/></div></div><div id="36322318" class="c"><input type="checkbox" id="c-36322318" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36320059">parent</a><span>|</span><a href="#36321887">prev</a><span>|</span><a href="#36318829">next</a><span>|</span><label class="collapse" for="c-36322318">[-]</label><label class="expand" for="c-36322318">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but lawyers can ruin your life. If you ask me, it&#x27;s a travesty that the law is so complex nobody in this thread can agree if this is good advice or paranoia run out of control. That&#x27;s the world lawyers have created for us, and like it or not, we live in their world.</div><br/></div></div></div></div><div id="36318829" class="c"><input type="checkbox" id="c-36318829" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318559">parent</a><span>|</span><a href="#36320059">prev</a><span>|</span><a href="#36318446">next</a><span>|</span><label class="collapse" for="c-36318829">[-]</label><label class="expand" for="c-36318829">[13 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how software licenses work.</div><br/><div id="36318855" class="c"><input type="checkbox" id="c-36318855" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318829">parent</a><span>|</span><a href="#36318446">next</a><span>|</span><label class="collapse" for="c-36318855">[-]</label><label class="expand" for="c-36318855">[12 more]</label></div><br/><div class="children"><div class="content">Yes, actually, it is.<p>&quot;Software licenses&quot; aren&#x27;t their own subject. They are instruments of copyright law. Without copyright, there is nothing to be licensed. And clean room implementations are the best way to ensure that no copyright violation has occurred.</div><br/><div id="36319341" class="c"><input type="checkbox" id="c-36319341" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318855">parent</a><span>|</span><a href="#36319107">next</a><span>|</span><label class="collapse" for="c-36319341">[-]</label><label class="expand" for="c-36319341">[9 more]</label></div><br/><div class="children"><div class="content">Looking at GPL code doesn&#x27;t poison your mind forever.  Of course, you cannot directly copy GPL code and call it MIT.  And you arguably cannot have GPL code open in one window and write your version in a separate window.  Copyright protects a specific set of symbols in some order, not an underlying idea or algorithm.  You can look at a GPL hashtable one day and write an MIT one the next, no problem.</div><br/><div id="36321957" class="c"><input type="checkbox" id="c-36321957" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36319341">parent</a><span>|</span><a href="#36319868">next</a><span>|</span><label class="collapse" for="c-36321957">[-]</label><label class="expand" for="c-36321957">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Looking at GPL code doesn&#x27;t poison your mind forever.<p>If you purposely go through the source code of a project to get inspiration and afterwards you are so inspired that you end up implementing the same thing in your code, you&#x27;re literally reusing the code. If the project that inspired you so much does not grant you the right to reuse the code in the way you are reusing it, you&#x27;re violating the licensing terms.<p>&quot;Clean room implementation&quot; does not mean &quot;I may or may not have copy&#x2F;pasted the code&quot;.  It literally means replicating a design without infringing copyright related to the work you&#x27;re replicating. Directly accessing the code and lift the good parts in different degrees of verbatim-ness is the textbook definition of copyright violation.</div><br/><div id="36322285" class="c"><input type="checkbox" id="c-36322285" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36321957">parent</a><span>|</span><a href="#36319868">next</a><span>|</span><label class="collapse" for="c-36322285">[-]</label><label class="expand" for="c-36322285">[1 more]</label></div><br/><div class="children"><div class="content">Clean room reimplementation is a sufficient but not necessary way to avoid copyright violations.<p>If what you&#x27;re proposing was true no corporate counsel would ever suggest hiring someone who had worked at a different company.</div><br/></div></div></div></div><div id="36319868" class="c"><input type="checkbox" id="c-36319868" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36319341">parent</a><span>|</span><a href="#36321957">prev</a><span>|</span><a href="#36319468">next</a><span>|</span><label class="collapse" for="c-36319868">[-]</label><label class="expand" for="c-36319868">[5 more]</label></div><br/><div class="children"><div class="content">Yes, that is all correct.<p>However, it is my opinion that having a project posted on HN, being directed to look at the &quot;internals&quot; of another software project (such project being licensed under the GPL), and subsequently modifying your own project with what you&#x27;ve learned, is legally risky.<p>Specifically, if I were corporate counsel at a company looking to use MIT-licensed code in a product of ours, and our due diligence uncovered that just such a thing had happened, I would advise against using that code. The risk—that is, likelihood multiplied by the magnitude of the severity of the consequences—of being compelled to license our software under the GPL would be far too high.<p>As a result, I stand by my assessment that it is <i>probably best</i>—albeit not mandatory—for the OP author not to take a look at how GPL&#x27;d code accomplishes what OP author is trying to accomplish.</div><br/><div id="36320163" class="c"><input type="checkbox" id="c-36320163" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36319868">parent</a><span>|</span><a href="#36321762">next</a><span>|</span><label class="collapse" for="c-36320163">[-]</label><label class="expand" for="c-36320163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Specifically, if I were corporate counsel at a company looking to use MIT-licensed code in a product of ours, and our due diligence uncovered that just such a thing had happened, I would advise against using that code.<p>I get that corporate counsel is extremely conservative (do you practice in this area?) and often insensitive to the costs of following their advice (as opposed to the costs of not following it) and you may well be right that this is what they would advise if asked explicitly.  But I don&#x27;t think the end result is good advice for an engineer.<p>&gt; The risk—that is, likelihood multiplied by the magnitude of the severity of the consequences—of being compelled to license our software under the GPL would be far too high.<p>I think you&#x27;re overestimating both likelihood and severity.  Likelihood -- I mean, your internal hash table is never going to see GPL enforcement action.  Severity -- the least expensive path to remediation is unlikely to be GPL&#x27;ing your software.  You could replace the component, for example.<p>I appreciate the discussion, by the way.  Thanks!</div><br/></div></div><div id="36321762" class="c"><input type="checkbox" id="c-36321762" checked=""/><div class="controls bullet"><span class="by">detrites</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36319868">parent</a><span>|</span><a href="#36320163">prev</a><span>|</span><a href="#36322841">next</a><span>|</span><label class="collapse" for="c-36321762">[-]</label><label class="expand" for="c-36321762">[1 more]</label></div><br/><div class="children"><div class="content">What if they, unknowingly, had an LLM &quot;look at&quot; incompatibly-licensed code they later used?<p>And if that provided any immunity, what&#x27;s to stop someone from claiming it happened to avoid issue?</div><br/></div></div><div id="36322841" class="c"><input type="checkbox" id="c-36322841" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36319868">parent</a><span>|</span><a href="#36321762">prev</a><span>|</span><a href="#36320047">next</a><span>|</span><label class="collapse" for="c-36322841">[-]</label><label class="expand" for="c-36322841">[1 more]</label></div><br/><div class="children"><div class="content">A human beings right to enlighten themselves trumps any other human beings right to enrich themselves.<p>You&#x27;re calling for a reduction in agency over a potential for legal action - self-censorship, essentially - in a way, forming a pre-judiciary &quot;pre-crime&quot; conclusion of guilt.<p>Code is language.  Restrictions on its use are human rights violations, no matter what legal-ese can be trotted out to FUD the arena.</div><br/></div></div></div></div></div></div><div id="36319107" class="c"><input type="checkbox" id="c-36319107" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318855">parent</a><span>|</span><a href="#36319341">prev</a><span>|</span><a href="#36319342">next</a><span>|</span><label class="collapse" for="c-36319107">[-]</label><label class="expand" for="c-36319107">[1 more]</label></div><br/><div class="children"><div class="content">A clean room implementation is not the <i>only</i> way to avoid violating copyright.</div><br/></div></div><div id="36319342" class="c"><input type="checkbox" id="c-36319342" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36317297">root</a><span>|</span><a href="#36318855">parent</a><span>|</span><a href="#36319107">prev</a><span>|</span><a href="#36318446">next</a><span>|</span><label class="collapse" for="c-36319342">[-]</label><label class="expand" for="c-36319342">[1 more]</label></div><br/><div class="children"><div class="content">Software licenses are the greatest legal psych out of my lifetime. US law permits anyone who has a legally acquired copy of a piece of software to copy it further[1], such<p><pre><code>  that such a new copy or adaptation is created as an essential step in the utilization of the computer program in conjunction with a machine and that it is used in no other manner
</code></pre>
As anyone can see, this completely obviates any need to be licensed to use software once the seller has lawfully sold you a copy. It&#x27;s yours and you can execute it as you see fit. Interestingly, this doesn&#x27;t really affect the GPL because the GPL doesn&#x27;t attempt to kick in unless you further redistribute. And that, of course, is not protected by section 117 and does require a license.<p>Of course we live in a regime where the process is the punishment, so if you&#x27;re high profile you&#x27;ll probably get hit with a ruinous lawsuit anyhow. C&#x27;est la vie.<p>[1] <a href="https:&#x2F;&#x2F;www.law.cornell.edu&#x2F;uscode&#x2F;text&#x2F;17&#x2F;117" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.law.cornell.edu&#x2F;uscode&#x2F;text&#x2F;17&#x2F;117</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36318446" class="c"><input type="checkbox" id="c-36318446" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#36317297">prev</a><span>|</span><a href="#36317586">next</a><span>|</span><label class="collapse" for="c-36318446">[-]</label><label class="expand" for="c-36318446">[7 more]</label></div><br/><div class="children"><div class="content">This hashtable sure mallocs a lot!<p>Look here for example:<p>Entry *newVal = malloc(sizeof(Entry)); newVal-&gt;key = strdup(key);<p>Why not:<p>Entry* e = malloc(sizeof(Entry) + strlen(key));<p>Now you can also skip the pointer to the key, saving 8 bytes for each entry. Also, just return the hashtable by value, it&#x27;s so small.<p>I think that if we&#x27;re coding in C, C++ or Zig, then it can be fun to actually use the lower level power to our advantage :).</div><br/><div id="36319235" class="c"><input type="checkbox" id="c-36319235" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#36318446">parent</a><span>|</span><a href="#36320802">next</a><span>|</span><label class="collapse" for="c-36319235">[-]</label><label class="expand" for="c-36319235">[3 more]</label></div><br/><div class="children"><div class="content">&gt; malloc(sizeof(Entry) + strlen(key));<p>Don&#x27;t forget +1 for the terminator.<p>I also think a linked list is not a great data structure in practice. Having the buckets be one of those amortized-O(1)-append heap allocations would be kinder on CPU caches. But, if you are making the string part of the entry, that would also require padding the string length to word boundaries so that the struct gets aligned.<p>Note also if you kept the length of the string somewhere (which you would need to for my above paragraph&#x27;s suggestion), you could avoid strcmp-ing hash collisions where the string has different length. Strcmp is going to add up to an expensive thing in this code.<p>This code also never checks the return value of malloc. Color me unimpressed with this code. (Cue people arguing that checking for malloc failure is a bad idea ... Linux oom killer and high level languages have you spoiled, there i said it! &#x2F;s)</div><br/><div id="36320236" class="c"><input type="checkbox" id="c-36320236" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36318446">root</a><span>|</span><a href="#36319235">parent</a><span>|</span><a href="#36322466">next</a><span>|</span><label class="collapse" for="c-36320236">[-]</label><label class="expand" for="c-36320236">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; malloc(sizeof(Entry) + strlen(key));<p>&gt; Don&#x27;t forget +1 for the terminator.<p>Also should check for arithmetic overflow, or at least static_assert that sizeof(Entry) is &quot;too small&quot; to matter. (Hopefully the process of deciding what &quot;too small&quot; should be results in just adding the overflow check.)</div><br/></div></div><div id="36322466" class="c"><input type="checkbox" id="c-36322466" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#36318446">root</a><span>|</span><a href="#36319235">parent</a><span>|</span><a href="#36320236">prev</a><span>|</span><a href="#36320802">next</a><span>|</span><label class="collapse" for="c-36322466">[-]</label><label class="expand" for="c-36322466">[1 more]</label></div><br/><div class="children"><div class="content">&gt;But, if you are making the string part of the entry, that would also require padding the string length to word boundaries so that the struct gets aligned.<p>It also makes deletion a far more complicated situation. You&#x27;d essentially be implementing your own allocator then.</div><br/></div></div></div></div><div id="36320802" class="c"><input type="checkbox" id="c-36320802" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36318446">parent</a><span>|</span><a href="#36319235">prev</a><span>|</span><a href="#36318569">next</a><span>|</span><label class="collapse" for="c-36320802">[-]</label><label class="expand" for="c-36320802">[2 more]</label></div><br/><div class="children"><div class="content">When writing C code, which for me is rare these days, the language doesn&#x27;t give me enough guardrails in the type system (e.g. unique_ptr) and at compile time that I&#x27;d prefer to write straightforward and dumb code. And that means code that does a lot of malloc()s with no surprises. If I have a char* that cannot be free()d, such as pointing to the middle of a longer string, I don&#x27;t even let that escape the scope of a single function. Leave the memory management trickeries to more modern languages like C++, or, better yet, Rust.</div><br/><div id="36321619" class="c"><input type="checkbox" id="c-36321619" checked=""/><div class="controls bullet"><span class="by">amstan</span><span>|</span><a href="#36318446">root</a><span>|</span><a href="#36320802">parent</a><span>|</span><a href="#36318569">next</a><span>|</span><label class="collapse" for="c-36321619">[-]</label><label class="expand" for="c-36321619">[1 more]</label></div><br/><div class="children"><div class="content">I think parent was criticizing the multiple use of mallocs when one would be cleaner and easier. This wouldn&#x27;t really make a difference to the library users, besides perhaps more heap fragmentation in the old version.</div><br/></div></div></div></div><div id="36318569" class="c"><input type="checkbox" id="c-36318569" checked=""/><div class="controls bullet"><span class="by">aloisklink</span><span>|</span><a href="#36318446">parent</a><span>|</span><a href="#36320802">prev</a><span>|</span><a href="#36317586">next</a><span>|</span><label class="collapse" for="c-36318569">[-]</label><label class="expand" for="c-36318569">[1 more]</label></div><br/><div class="children"><div class="content">Even better, you can use [C99 Flexible array members][1], e.g. something like:<p><pre><code>    struct KeyedEntry {
      struct Entry entry;
      char key[]; &#x2F;&#x2F; flexible array member
    };
</code></pre>
It&#x27;s not too much more useful when just using `char`, but for other data types, it&#x27;s a bit cleaner, since it handles alignment&#x2F;padding better.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flexible_array_member" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Flexible_array_member</a>, or <a href="https:&#x2F;&#x2F;beej.us&#x2F;guide&#x2F;bgc&#x2F;html&#x2F;split&#x2F;structs-ii-more-fun-with-structs.html#flexible-array-members" rel="nofollow noreferrer">https:&#x2F;&#x2F;beej.us&#x2F;guide&#x2F;bgc&#x2F;html&#x2F;split&#x2F;structs-ii-more-fun-wit...</a><p>_Edit_: Something like this might not be suitable for the author, since they did mention how they wanted each `struct` to have a fixed size.</div><br/></div></div></div></div><div id="36317586" class="c"><input type="checkbox" id="c-36317586" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36318446">prev</a><span>|</span><a href="#36317803">next</a><span>|</span><label class="collapse" for="c-36317586">[-]</label><label class="expand" for="c-36317586">[7 more]</label></div><br/><div class="children"><div class="content">I was surprised recently when looking at different hash tables that have been implemented in C to discover that the standard library includes its own hash table.  They are even part of POSIX.  There is a reason you have never heard of it, or if you have you have never used it.  In true POSIX fashion they are close to useless.  The implementation doesn&#x27;t allow you to modify the table after it has been created, you have to pass in all the data when you create the table.  There is no add or delete and you can&#x27;t change any value you pull from the table.  It also stores the data in a static area local to the function so you can only use a single table in a program at a time.  It doggedly commits every C stdlib sin possible.</div><br/><div id="36317683" class="c"><input type="checkbox" id="c-36317683" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36317586">parent</a><span>|</span><a href="#36322897">next</a><span>|</span><label class="collapse" for="c-36317683">[-]</label><label class="expand" for="c-36317683">[4 more]</label></div><br/><div class="children"><div class="content">there are no hash tables in the Standard C Library - POSIX does not define Standard C.<p>more info: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6118539&#x2F;why-are-there-no-hashtables-in-the-c-standard-library" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6118539&#x2F;why-are-there-no...</a></div><br/><div id="36319169" class="c"><input type="checkbox" id="c-36319169" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36317586">root</a><span>|</span><a href="#36317683">parent</a><span>|</span><a href="#36320447">next</a><span>|</span><label class="collapse" for="c-36319169">[-]</label><label class="expand" for="c-36319169">[2 more]</label></div><br/><div class="children"><div class="content">Interesting that the manpage claims it conforms to POSIX.1-2001.<p><a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;hcreate" rel="nofollow noreferrer">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;hcreate</a></div><br/><div id="36319517" class="c"><input type="checkbox" id="c-36319517" checked=""/><div class="controls bullet"><span class="by">jlarocco</span><span>|</span><a href="#36317586">root</a><span>|</span><a href="#36319169">parent</a><span>|</span><a href="#36320447">next</a><span>|</span><label class="collapse" for="c-36319517">[-]</label><label class="expand" for="c-36319517">[1 more]</label></div><br/><div class="children"><div class="content">POSIX is the standard for Unix, not for C.</div><br/></div></div></div></div><div id="36320447" class="c"><input type="checkbox" id="c-36320447" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36317586">root</a><span>|</span><a href="#36317683">parent</a><span>|</span><a href="#36319169">prev</a><span>|</span><a href="#36322897">next</a><span>|</span><label class="collapse" for="c-36320447">[-]</label><label class="expand" for="c-36320447">[1 more]</label></div><br/><div class="children"><div class="content">I think GP is talking about, e.g., glibc, or any libc you might find on a POSIX system, rather than the abstract C standard library.  I agree that as a point of clarity, POSIX isn&#x27;t standard C and the crappy hashtable described is in POSIX, not standard C.</div><br/></div></div></div></div><div id="36322897" class="c"><input type="checkbox" id="c-36322897" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#36317586">parent</a><span>|</span><a href="#36317683">prev</a><span>|</span><a href="#36319458">next</a><span>|</span><label class="collapse" for="c-36322897">[-]</label><label class="expand" for="c-36322897">[1 more]</label></div><br/><div class="children"><div class="content">Come on, this is a straw man argument.  That function was built for a specific purpose, and the fact you had to hunt for it means its not meant for general purpose use.<p>Besides which, this statement is just inflammatory:<p>&quot;In true POSIX fashion they are close to useless.&quot;<p>The straw man does not support the conclusion .. POSIX is <i>full</i> of utility.</div><br/></div></div><div id="36319458" class="c"><input type="checkbox" id="c-36319458" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#36317586">parent</a><span>|</span><a href="#36322897">prev</a><span>|</span><a href="#36317803">next</a><span>|</span><label class="collapse" for="c-36319458">[-]</label><label class="expand" for="c-36319458">[1 more]</label></div><br/><div class="children"><div class="content">You can add with hsearch; set ACTION=ENTER<p>Also you could &#x27;delete&#x27; with item.data set to some sentinel.</div><br/></div></div></div></div><div id="36317803" class="c"><input type="checkbox" id="c-36317803" checked=""/><div class="controls bullet"><span class="by">jmacjmac</span><span>|</span><a href="#36317586">prev</a><span>|</span><a href="#36322687">next</a><span>|</span><label class="collapse" for="c-36317803">[-]</label><label class="expand" for="c-36317803">[2 more]</label></div><br/><div class="children"><div class="content">Nice article! I think eventually you need to move to macros to support multiple key&#x2F;value types in C. Just leaving some macro implementations for reference:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;klib&#x2F;blob&#x2F;master&#x2F;khash.h">https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;klib&#x2F;blob&#x2F;master&#x2F;khash.h</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;tezc&#x2F;sc&#x2F;tree&#x2F;master&#x2F;map">https:&#x2F;&#x2F;github.com&#x2F;tezc&#x2F;sc&#x2F;tree&#x2F;master&#x2F;map</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;troydhanson&#x2F;uthash">https:&#x2F;&#x2F;github.com&#x2F;troydhanson&#x2F;uthash</a></div><br/><div id="36318705" class="c"><input type="checkbox" id="c-36318705" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#36317803">parent</a><span>|</span><a href="#36322687">next</a><span>|</span><label class="collapse" for="c-36318705">[-]</label><label class="expand" for="c-36318705">[1 more]</label></div><br/><div class="children"><div class="content">I think uthash is the one I used long ago. Fun and easy.</div><br/></div></div></div></div><div id="36322687" class="c"><input type="checkbox" id="c-36322687" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#36317803">prev</a><span>|</span><a href="#36317760">next</a><span>|</span><label class="collapse" for="c-36322687">[-]</label><label class="expand" for="c-36322687">[5 more]</label></div><br/><div class="children"><div class="content">Why using a good or better hash table, when you can implement the worst by yourself? OMG</div><br/><div id="36322851" class="c"><input type="checkbox" id="c-36322851" checked=""/><div class="controls bullet"><span class="by">naillo</span><span>|</span><a href="#36322687">parent</a><span>|</span><a href="#36322753">next</a><span>|</span><label class="collapse" for="c-36322851">[-]</label><label class="expand" for="c-36322851">[1 more]</label></div><br/><div class="children"><div class="content">Well these things are what everyone has to do in college anyway because it&#x27;s helpful for training you. And if you didn&#x27;t get to do that in your algo courses or you didn&#x27;t do college or haven&#x27;t done it yet then articles like this are super useful.</div><br/></div></div><div id="36322753" class="c"><input type="checkbox" id="c-36322753" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36322687">parent</a><span>|</span><a href="#36322851">prev</a><span>|</span><a href="#36322860">next</a><span>|</span><label class="collapse" for="c-36322753">[-]</label><label class="expand" for="c-36322753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Solving it helped me gain better intuition around hash functions, pointers, and memory segments like the stack and the heap.</div><br/></div></div><div id="36322860" class="c"><input type="checkbox" id="c-36322860" checked=""/><div class="controls bullet"><span class="by">detrites</span><span>|</span><a href="#36322687">parent</a><span>|</span><a href="#36322753">prev</a><span>|</span><a href="#36317760">next</a><span>|</span><label class="collapse" for="c-36322860">[-]</label><label class="expand" for="c-36322860">[2 more]</label></div><br/><div class="children"><div class="content">Can you at least list some good or better hash tables?</div><br/><div id="36323036" class="c"><input type="checkbox" id="c-36323036" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#36322687">root</a><span>|</span><a href="#36322860">parent</a><span>|</span><a href="#36317760">next</a><span>|</span><label class="collapse" for="c-36323036">[-]</label><label class="expand" for="c-36323036">[1 more]</label></div><br/><div class="children"><div class="content">search for htable or hashtable in thousands of open source projects. only a minority has worse hashtables than this one (clisp, perl5 e.g.).<p>For better ones I would point to my linked list implementation: <a href="https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;ctl&#x2F;blob&#x2F;master&#x2F;ctl&#x2F;unordered_set.h">https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;ctl&#x2F;blob&#x2F;master&#x2F;ctl&#x2F;unordered_set....</a> (because it has various security policies, nobody else has)
or <a href="https:&#x2F;&#x2F;github.com&#x2F;LIMachi&#x2F;swiss-table">https:&#x2F;&#x2F;github.com&#x2F;LIMachi&#x2F;swiss-table</a> (all in C)</div><br/></div></div></div></div></div></div><div id="36317760" class="c"><input type="checkbox" id="c-36317760" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36322687">prev</a><span>|</span><a href="#36317675">next</a><span>|</span><label class="collapse" for="c-36317760">[-]</label><label class="expand" for="c-36317760">[5 more]</label></div><br/><div class="children"><div class="content">Thank you for this article.<p>I have been working on trying to design a contiguous hash table data structure that has these two mutual requirements:<p>a) allows deep clones (due to contiguous memory copyable with memcpy)<p>b) supports arbitrarily nestable hash tables<p>The closest library I know about is smolworld ( <a href="https:&#x2F;&#x2F;github.com&#x2F;snej&#x2F;smol_world">https:&#x2F;&#x2F;github.com&#x2F;snej&#x2F;smol_world</a> ) but I don&#x27;t know how easy it can be cloned.<p>These requirements rules out multiple mallocs: I do one single malloc and expect that to be enough for the entire hashmap.<p>I&#x27;m not sure if these constraints might also force a fixed number of buckets and a fixed capacity.<p>The clonable property requires interior mutability be limited, because if you memcpy pointers they would cause structure sharing, that I&#x27;m trying to avoid, hence a deep clone.<p>Rationale: these are the use cases I have for such a data structure. The first is cheap copy on write. I also have a left-right concurrency control hashmap, but I feel the properties of this data structure are even better. The first is a sharding in multithreading design: do a cheap memcpy for each thread and shard the processing and merge at the end, without any synchronization cost while the threads are working. I know that deep cloning is slow in Java and presumably C if you do it with loops rather than memcpy. Another use case is efficient serialization for network.<p>In other words, a protobuf but easily deep clonable without loops.</div><br/><div id="36318332" class="c"><input type="checkbox" id="c-36318332" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#36317760">parent</a><span>|</span><a href="#36322045">next</a><span>|</span><label class="collapse" for="c-36318332">[-]</label><label class="expand" for="c-36318332">[2 more]</label></div><br/><div class="children"><div class="content">If you pre-allocate a large enough buffer, you can keep a pointer to mark the boundary between the part where you have already stored data and the part still empty. Then re-implement malloc() to just move such pointer. Of course you must check for running out of allocated memory, etc. This simple approach assumes that you seldom delete entries, because it never reclaims the room occupied by deleted entries.</div><br/><div id="36319510" class="c"><input type="checkbox" id="c-36319510" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#36317760">root</a><span>|</span><a href="#36318332">parent</a><span>|</span><a href="#36322045">next</a><span>|</span><label class="collapse" for="c-36319510">[-]</label><label class="expand" for="c-36319510">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a simple example of the bump allocator part of this!<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;williamcotton&#x2F;99ab6e8efa3c4b6c07a149d1262dfccf" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;williamcotton&#x2F;99ab6e8efa3c4b6c07a149...</a></div><br/></div></div></div></div><div id="36322045" class="c"><input type="checkbox" id="c-36322045" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#36317760">parent</a><span>|</span><a href="#36318332">prev</a><span>|</span><a href="#36317675">next</a><span>|</span><label class="collapse" for="c-36322045">[-]</label><label class="expand" for="c-36322045">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  because if you memcpy pointers they would cause structure sharing, that I&#x27;m trying to avoid, hence a deep clone.<p>I&#x27;m probably that guy that pipes up when he doesn&#x27;t know what he&#x27;s talking about but.<p>You can store offsets instead of pointers.  You can then just memcpy the whole thing and it&#x27;ll just work as long as everything is self contained.</div><br/><div id="36322730" class="c"><input type="checkbox" id="c-36322730" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36317760">root</a><span>|</span><a href="#36322045">parent</a><span>|</span><a href="#36317675">next</a><span>|</span><label class="collapse" for="c-36322730">[-]</label><label class="expand" for="c-36322730">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your reply, you&#x27;re right. You know what you&#x27;re talking about.<p>This is what smol_world does, it uses 32 bit indexes.<p>I really like the idea of smol_world, I just don&#x27;t know if you can easily .clone() it.</div><br/></div></div></div></div></div></div><div id="36317675" class="c"><input type="checkbox" id="c-36317675" checked=""/><div class="controls bullet"><span class="by">version_five</span><span>|</span><a href="#36317760">prev</a><span>|</span><a href="#36317676">next</a><span>|</span><label class="collapse" for="c-36317675">[-]</label><label class="expand" for="c-36317675">[4 more]</label></div><br/><div class="children"><div class="content">I was looking for something like this a few months ago and found this which also may be of interest:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26590234">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26590234</a><p>How to implement a hash table in C (benhoyt.com)
302 points by benhoyt on March 26, 2021, 158 comments</div><br/><div id="36317734" class="c"><input type="checkbox" id="c-36317734" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#36317675">parent</a><span>|</span><a href="#36317676">next</a><span>|</span><label class="collapse" for="c-36317734">[-]</label><label class="expand" for="c-36317734">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing! I do like the OP&#x27;s article, but the more the merrier! My &quot;How to implement a hash table in C&quot; article [1] is for whatever reason one of my most popular articles. If only C had a slightly better standard library. :-)<p>In my article I use &quot;open addressing&quot; [2] instead of linked lists for collisions, as 1) it tends to be simpler, as you only have one data structure to manage (array, rather than array and linked list), and 2) it tends to be faster, as linked lists are slow on modern CPUs because they require jumping around in memory.<p>[1] <a href="https:&#x2F;&#x2F;benhoyt.com&#x2F;writings&#x2F;hash-table-in-c&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;benhoyt.com&#x2F;writings&#x2F;hash-table-in-c&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Open_addressing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Open_addressing</a></div><br/><div id="36323237" class="c"><input type="checkbox" id="c-36323237" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#36317675">root</a><span>|</span><a href="#36317734">parent</a><span>|</span><a href="#36317877">next</a><span>|</span><label class="collapse" for="c-36323237">[-]</label><label class="expand" for="c-36323237">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think open addressing with linear probing is definitely the paradigm I&#x27;d choose if I wanted to build a &quot;simple&quot; hash table for educational purposes.<p>It well enough and is conceptually probably the easiest approach to grok with relatively few pitfalls.</div><br/></div></div><div id="36317877" class="c"><input type="checkbox" id="c-36317877" checked=""/><div class="controls bullet"><span class="by">version_five</span><span>|</span><a href="#36317675">root</a><span>|</span><a href="#36317734">parent</a><span>|</span><a href="#36323237">prev</a><span>|</span><a href="#36317676">next</a><span>|</span><label class="collapse" for="c-36317877">[-]</label><label class="expand" for="c-36317877">[1 more]</label></div><br/><div class="children"><div class="content">Hey, thanks for writing it up! Like I said, I was looking for exactly this a few months ago, and between the explanation and the code it was a big help.</div><br/></div></div></div></div></div></div><div id="36321066" class="c"><input type="checkbox" id="c-36321066" checked=""/><div class="controls bullet"><span class="by">michaelcampbell</span><span>|</span><a href="#36317676">prev</a><span>|</span><a href="#36320896">next</a><span>|</span><label class="collapse" for="c-36321066">[-]</label><label class="expand" for="c-36321066">[1 more]</label></div><br/><div class="children"><div class="content">I &#x27;invented&#x27; a hash table like this many years ago.  I&#x27;m sure I wasn&#x27;t anywhere near the first, either, but at the time I thought it was pretty hot shit using a linked list as the thing to deal with collisions.<p>It&#x27;s funny how many people come up with the same ideas.</div><br/></div></div><div id="36320896" class="c"><input type="checkbox" id="c-36320896" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#36321066">prev</a><span>|</span><a href="#36317583">next</a><span>|</span><label class="collapse" for="c-36320896">[-]</label><label class="expand" for="c-36320896">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s performance like when each bucket is an array instead of a linked list?<p>Another question-- at the moment where one would normally decide to resize the table for performance reasons (i.e., buckets are getting too full), how would the array-bucket style perform compared to the linked-list bucket style?</div><br/></div></div><div id="36317583" class="c"><input type="checkbox" id="c-36317583" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36320896">prev</a><span>|</span><a href="#36320211">next</a><span>|</span><label class="collapse" for="c-36317583">[-]</label><label class="expand" for="c-36317583">[4 more]</label></div><br/><div class="children"><div class="content">if the initial array is going to be of fixed size, why not:<p><pre><code>    typedef struct HashTable {
        Entry *buckets[4];
        int nBuckets;
    } HashTable;
</code></pre>
which removes one layer of dynamic memory management.</div><br/><div id="36317789" class="c"><input type="checkbox" id="c-36317789" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#36317583">parent</a><span>|</span><a href="#36320211">next</a><span>|</span><label class="collapse" for="c-36317789">[-]</label><label class="expand" for="c-36317789">[3 more]</label></div><br/><div class="children"><div class="content">&gt;resize the buckets array once it gets too full<p>Because of that, basically.</div><br/><div id="36317887" class="c"><input type="checkbox" id="c-36317887" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36317583">root</a><span>|</span><a href="#36317789">parent</a><span>|</span><a href="#36320211">next</a><span>|</span><label class="collapse" for="c-36317887">[-]</label><label class="expand" for="c-36317887">[2 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t see where in his code this is done. possibly me being stupid.</div><br/><div id="36318659" class="c"><input type="checkbox" id="c-36318659" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#36317583">root</a><span>|</span><a href="#36317887">parent</a><span>|</span><a href="#36320211">next</a><span>|</span><label class="collapse" for="c-36318659">[-]</label><label class="expand" for="c-36318659">[1 more]</label></div><br/><div class="children"><div class="content">Oh sorry, it&#x27;s from &quot;future improvements&quot; :), I assumed that was the train of thought. You&#x27;re entirely correct, however.</div><br/></div></div></div></div></div></div></div></div><div id="36317411" class="c"><input type="checkbox" id="c-36317411" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#36320211">prev</a><span>|</span><label class="collapse" for="c-36317411">[-]</label><label class="expand" for="c-36317411">[1 more]</label></div><br/><div class="children"><div class="content">1. Implement simple hash table in C<p>2. Implement bloom filter<p>3. Download list of Bitcoin wallets with non-zero amount of BTC<p>4. Generate long list of random key pairs<p>5. ???<p>6. Profit</div><br/></div></div></div></div></div></div></div></body></html>