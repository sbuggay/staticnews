<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699779654698" as="style"/><link rel="stylesheet" href="styles.css?v=1699779654698"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://threadreaderapp.com/thread/1723398619313603068.html">CTF Writeup: Abusing select() to factor RSA</a> <span class="domain">(<a href="https://threadreaderapp.com">threadreaderapp.com</a>)</span></div><div class="subtext"><span>moyix</span> | <span>27 comments</span></div><br/><div><div id="38237121" class="c"><input type="checkbox" id="c-38237121" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38234394">next</a><span>|</span><label class="collapse" for="c-38237121">[-]</label><label class="expand" for="c-38237121">[1 more]</label></div><br/><div class="children"><div class="content">Apple&#x27;s libc has a pretty wild feature (guarded by _DARWIN_UNLIMITED_SELECT, on by default) which allows fds above FD_SETSIZE. It works by checking the address of the fd_set: if it&#x27;s within the current thread&#x27;s stack, then the call will fail, under the assumption that it&#x27;s a stack-allocated fd_set.<p>But if the address is NOT within the current thread&#x27;s stack, select() assumes you know what you&#x27;re doing and will allow the call, trusting you have allocated sufficient memory for the high fds in the fd_set.<p>No opinion if this is a good decision or not, I just think it&#x27;s interesting!</div><br/></div></div><div id="38234394" class="c"><input type="checkbox" id="c-38234394" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#38237121">prev</a><span>|</span><a href="#38234806">next</a><span>|</span><label class="collapse" for="c-38234394">[-]</label><label class="expand" for="c-38234394">[7 more]</label></div><br/><div class="children"><div class="content">select() ought to just fail with EINVAL if nfds is too large. There&#x27;s probably an argument for the macros as well to fail by default if the file descriptor given is too large.</div><br/><div id="38234536" class="c"><input type="checkbox" id="c-38234536" checked=""/><div class="controls bullet"><span class="by">moyix</span><span>|</span><a href="#38234394">parent</a><span>|</span><a href="#38234806">next</a><span>|</span><label class="collapse" for="c-38234536">[-]</label><label class="expand" for="c-38234536">[6 more]</label></div><br/><div class="children"><div class="content">As one safety measure, compiling with -DFORTIFY_SOURCE &gt; 0 will enable checks on the FD_SET etc macros:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;a0f33f996f7986dbf37631a4577f8565b42df29e">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;commit&#x2F;a0f33f996f7986dbf3763...</a><p>The kernel side interface probably won&#x27;t change because apparently legitimate apps have been allocating fd_sets on the heap to monitor fds &gt; 1024 and they don&#x27;t want to break those:<p><a href="https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=10352#c7" rel="nofollow noreferrer">https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=10352#c7</a><p>The underlying problem was also discussed in an article by Lennart Poettering (of systemd fame) and posted to HN back in 2021:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27215690">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27215690</a><p><a href="https:&#x2F;&#x2F;0pointer.net&#x2F;blog&#x2F;file-descriptor-limits.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;0pointer.net&#x2F;blog&#x2F;file-descriptor-limits.html</a></div><br/><div id="38234633" class="c"><input type="checkbox" id="c-38234633" checked=""/><div class="controls bullet"><span class="by">warpspin</span><span>|</span><a href="#38234394">root</a><span>|</span><a href="#38234536">parent</a><span>|</span><a href="#38236274">next</a><span>|</span><label class="collapse" for="c-38234633">[-]</label><label class="expand" for="c-38234633">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The kernel side interface probably won&#x27;t change because apparently legitimate apps have been allocating fd_sets on the heap to monitor fds &gt; 1024 and they don&#x27;t want to break those<p>Rightly so. Before libev, AIO or whatever where a thing, I used to run network servers 10 or 15 years or so ago with a redefined __FD_SETSIZE set to 16384 without any problems on Linux (plus appropriate proc and ulimit settings). The whole stack properly supported it, even if not officially supported.<p>The real problem nowadays is, people can easily receive a fd &gt;= 1024 as you do not control them, and then put them into fd sets only supporting values up to 1023 and then you have a security problem. Plus of course, the later APIs also simply scale better beyond 16k connections.</div><br/><div id="38234879" class="c"><input type="checkbox" id="c-38234879" checked=""/><div class="controls bullet"><span class="by">syncsynchalt</span><span>|</span><a href="#38234394">root</a><span>|</span><a href="#38234633">parent</a><span>|</span><a href="#38236274">next</a><span>|</span><label class="collapse" for="c-38234879">[-]</label><label class="expand" for="c-38234879">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing you didn&#x27;t&#x2F;couldn&#x27;t use poll(2) because of the performance hit (both user and kernel side) of parsing&#x2F;checking the less compact data structure?<p>I both miss and don&#x27;t miss the days before epoll(2) et al.</div><br/><div id="38235916" class="c"><input type="checkbox" id="c-38235916" checked=""/><div class="controls bullet"><span class="by">warpspin</span><span>|</span><a href="#38234394">root</a><span>|</span><a href="#38234879">parent</a><span>|</span><a href="#38236274">next</a><span>|</span><label class="collapse" for="c-38235916">[-]</label><label class="expand" for="c-38235916">[1 more]</label></div><br/><div class="children"><div class="content">Originally, we did not use it because it did not exist. That service existed already in a time before poll(2) was a thing on Linux and when we still had 256 fds only. The increase to 1024 and then to basically unlimited came just in time for us back then, and we were glad a simple recompile with a #define was all we needed to scale it.<p>If my memory serves me right, we did try poll(2) though a while after it became available (and we already ran the 16k selects) but it was simply less performant.<p>Later on, when java.nio came around and Java finally could &quot;compete&quot; for network services therefore, we switched from C to Java completely for that service.</div><br/></div></div></div></div></div></div><div id="38236274" class="c"><input type="checkbox" id="c-38236274" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#38234394">root</a><span>|</span><a href="#38234536">parent</a><span>|</span><a href="#38234633">prev</a><span>|</span><a href="#38234806">next</a><span>|</span><label class="collapse" for="c-38236274">[-]</label><label class="expand" for="c-38236274">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, I wonder if there are any Linux distros that are built with this flag enabled?</div><br/><div id="38236961" class="c"><input type="checkbox" id="c-38236961" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#38234394">root</a><span>|</span><a href="#38236274">parent</a><span>|</span><a href="#38234806">next</a><span>|</span><label class="collapse" for="c-38236961">[-]</label><label class="expand" for="c-38236961">[1 more]</label></div><br/><div class="children"><div class="content">Fortify source has been enabled in many distros for package builds, including popular ones like Ubuntu [1], for quite a while.<p>[1] <a href="https:&#x2F;&#x2F;wiki.ubuntu.com&#x2F;ToolChain&#x2F;CompilerFlags#A-D_FORTIFY_SOURCE.3D2" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.ubuntu.com&#x2F;ToolChain&#x2F;CompilerFlags#A-D_FORTIFY_...</a></div><br/></div></div></div></div></div></div></div></div><div id="38234806" class="c"><input type="checkbox" id="c-38234806" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#38234394">prev</a><span>|</span><a href="#38237796">next</a><span>|</span><label class="collapse" for="c-38234806">[-]</label><label class="expand" for="c-38234806">[1 more]</label></div><br/><div class="children"><div class="content">CTF writeups are so fun. Here&#x27;s another I enjoyed, written by a teammate: <a href="https:&#x2F;&#x2F;zackorndorff.com&#x2F;2022&#x2F;08&#x2F;06&#x2F;blazin-etudes-hack-a-sat-3-quals-2022-writeup&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zackorndorff.com&#x2F;2022&#x2F;08&#x2F;06&#x2F;blazin-etudes-hack-a-sat...</a></div><br/></div></div><div id="38237796" class="c"><input type="checkbox" id="c-38237796" checked=""/><div class="controls bullet"><span class="by">EdSchouten</span><span>|</span><a href="#38234806">prev</a><span>|</span><a href="#38234739">next</a><span>|</span><label class="collapse" for="c-38237796">[-]</label><label class="expand" for="c-38237796">[3 more]</label></div><br/><div class="children"><div class="content">I really think that this is a quality of implementation issue.<p>Even though most implementations do so, there is no requirement to implement fd_set as a bitmap. It could also be an array of integers. Though this still won’t allow you to select() against an infinite number of file descriptors, it at least allows file descriptor numbers to span the full range of int.<p>Furthermore, there’s also no requirement that FD_*() corrupt your memory. I get it that these macros can’t return errors back to the caller, but they can always set some kind of flag in the fd_set to indicate that insertion was unsuccessful. select() could check that flag and bail out if set.</div><br/><div id="38238567" class="c"><input type="checkbox" id="c-38238567" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#38237796">parent</a><span>|</span><a href="#38238524">next</a><span>|</span><label class="collapse" for="c-38238567">[-]</label><label class="expand" for="c-38238567">[1 more]</label></div><br/><div class="children"><div class="content">Windows implements fd_set as an array. <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winsock&#x2F;ns-winsock-fd_set" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winsock&#x2F;...</a></div><br/></div></div></div></div><div id="38234739" class="c"><input type="checkbox" id="c-38234739" checked=""/><div class="controls bullet"><span class="by">kelsey9876543</span><span>|</span><a href="#38237796">prev</a><span>|</span><a href="#38234562">next</a><span>|</span><label class="collapse" for="c-38234739">[-]</label><label class="expand" for="c-38234739">[1 more]</label></div><br/><div class="children"><div class="content">Excellent writeup. Thank you.</div><br/></div></div><div id="38234562" class="c"><input type="checkbox" id="c-38234562" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#38234739">prev</a><span>|</span><a href="#38235621">next</a><span>|</span><label class="collapse" for="c-38234562">[-]</label><label class="expand" for="c-38234562">[11 more]</label></div><br/><div class="children"><div class="content">I love well designed POSIX APIs, such as &quot;this will silently corrupt memory if you use an FD above FD_SETSIZE, which you have no control over and have no sane way of remapping if it does happen&quot;.</div><br/><div id="38235004" class="c"><input type="checkbox" id="c-38235004" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38234562">parent</a><span>|</span><a href="#38235939">next</a><span>|</span><label class="collapse" for="c-38235004">[-]</label><label class="expand" for="c-38235004">[5 more]</label></div><br/><div class="children"><div class="content">…right?<p>The API design is patently insane, but why can&#x27;t there be a simple<p><pre><code>  if(nfds &gt; FD_SETSIZE) {
    errno = EINVAL;
    return -1;
  }
</code></pre>
… or something to prevent &quot;the API is garbage&quot; from escalating all the way into &quot;and now your memory is corrupt and the hackers are in&quot;…?</div><br/><div id="38235737" class="c"><input type="checkbox" id="c-38235737" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235004">parent</a><span>|</span><a href="#38235817">next</a><span>|</span><label class="collapse" for="c-38235737">[-]</label><label class="expand" for="c-38235737">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really what the problem is. The actual code is fine.<p>The issue is that the definition of `fd_set` has a constant size [1]. If you allocate the memory yourself, the select() system call will work with as many file descriptors as you care to pass to it. You can see that both glibc [2] and the kernel [3] support arbitrarily large arrays (well, in the kernel case you&#x27;ll run into other limitations... but no memory corruption).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;master&#x2F;misc&#x2F;sys&#x2F;select.h#L59">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;master&#x2F;misc&#x2F;sys&#x2F;select....</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;master&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;select.c#L32">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;master&#x2F;sysdeps&#x2F;unix&#x2F;sys...</a><p>[3] <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;fs&#x2F;select.c#n625" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div><div id="38235817" class="c"><input type="checkbox" id="c-38235817" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235004">parent</a><span>|</span><a href="#38235737">prev</a><span>|</span><a href="#38235345">next</a><span>|</span><label class="collapse" for="c-38235817">[-]</label><label class="expand" for="c-38235817">[1 more]</label></div><br/><div class="children"><div class="content">Because 1024 files ought to be enough for anyone? People wanted to write software to handle more files than that.</div><br/></div></div><div id="38235345" class="c"><input type="checkbox" id="c-38235345" checked=""/><div class="controls bullet"><span class="by">95014_refugee</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235004">parent</a><span>|</span><a href="#38235817">prev</a><span>|</span><a href="#38235939">next</a><span>|</span><label class="collapse" for="c-38235345">[-]</label><label class="expand" for="c-38235345">[2 more]</label></div><br/><div class="children"><div class="content">Because the code was written before unit tests were a thing, and nobody is willing to take the risk &#x2F; do the work to fix it, especially when &quot;it&#x27;s been shipping for years and nobody has ever complained&quot;.</div><br/><div id="38235596" class="c"><input type="checkbox" id="c-38235596" checked=""/><div class="controls bullet"><span class="by">raldi</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235345">parent</a><span>|</span><a href="#38235939">next</a><span>|</span><label class="collapse" for="c-38235596">[-]</label><label class="expand" for="c-38235596">[1 more]</label></div><br/><div class="children"><div class="content">It’s been shipping for decades and people have been complaining the whole time.</div><br/></div></div></div></div></div></div><div id="38235939" class="c"><input type="checkbox" id="c-38235939" checked=""/><div class="controls bullet"><span class="by">klempner</span><span>|</span><a href="#38234562">parent</a><span>|</span><a href="#38235004">prev</a><span>|</span><a href="#38235426">next</a><span>|</span><label class="collapse" for="c-38235939">[-]</label><label class="expand" for="c-38235939">[1 more]</label></div><br/><div class="children"><div class="content">The funny thing is that select&#x27;s APIs are compatible with a non-broken implementation, such as something that heap allocates if above a constant size. My recollection is that some implementations (winsock?) even do this.<p>Of course, that&#x27;s never going to actually happen on implementations people care about between ABI breaking on the one hand and the existence of poll&#x2F;epoll on the other.<p>(My biggest concern in practice is random shitty libraries using select behind the scenes and then silently corrupting memory in processes that have more than a few file descriptors.)</div><br/></div></div><div id="38235426" class="c"><input type="checkbox" id="c-38235426" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#38234562">parent</a><span>|</span><a href="#38235939">prev</a><span>|</span><a href="#38235607">next</a><span>|</span><label class="collapse" for="c-38235426">[-]</label><label class="expand" for="c-38235426">[3 more]</label></div><br/><div class="children"><div class="content">&gt; which you have no control over<p>It&#x27;s not quite that bad: UNIX has always guaranteed open() will return the lowest unused file descriptor. So in practice, it just limits you to 1024 total open files in the process, which in all fairness probably seemed like an absurdly large number at the time it was designed.</div><br/><div id="38235960" class="c"><input type="checkbox" id="c-38235960" checked=""/><div class="controls bullet"><span class="by">klempner</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235426">parent</a><span>|</span><a href="#38235607">next</a><span>|</span><label class="collapse" for="c-38235960">[-]</label><label class="expand" for="c-38235960">[2 more]</label></div><br/><div class="children"><div class="content">And of course that guarantee has its own problem, namely that (especially in a multithreaded process) a use-after-close error is vastly more likely to cause corruption via a write to a newly opened file in the old file descriptor.<p>And in all fairness, nobody was thinking of multithreading when these APIs were designed. We&#x27;re lucky enough that errno mostly works as a thread local rather than a global.</div><br/><div id="38236152" class="c"><input type="checkbox" id="c-38236152" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38234562">root</a><span>|</span><a href="#38235960">parent</a><span>|</span><a href="#38235607">next</a><span>|</span><label class="collapse" for="c-38236152">[-]</label><label class="expand" for="c-38236152">[1 more]</label></div><br/><div class="children"><div class="content">Use after close is, of course, tons of fun. But the guaranteed order also means open and accept require a per-process lock.</div><br/></div></div></div></div></div></div></div></div><div id="38235621" class="c"><input type="checkbox" id="c-38235621" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38234562">prev</a><span>|</span><label class="collapse" for="c-38235621">[-]</label><label class="expand" for="c-38235621">[2 more]</label></div><br/><div class="children"><div class="content">Memory corruption might die out as we secure our software stacks but I’m glad to see that weebs are eternal.</div><br/></div></div></div></div></div></div></div></body></html>