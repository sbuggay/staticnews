<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704445253794" as="style"/><link rel="stylesheet" href="styles.css?v=1704445253794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gist.github.com/FeepingCreature/5dff669aad380a123b15659e195fb96c">Don&#x27;t pass structs bigger than 16 bytes on AMD64</a> <span class="domain">(<a href="https://gist.github.com">gist.github.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>46 comments</span></div><br/><div><div id="38875950" class="c"><input type="checkbox" id="c-38875950" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38875837">next</a><span>|</span><label class="collapse" for="c-38875950">[-]</label><label class="expand" for="c-38875950">[2 more]</label></div><br/><div class="children"><div class="content">The issue here is the SysV amd64 ABI.  You could also just make your language-internal ABI not be SysV?  As long as these aren&#x27;t exposed to SysV C callers, you can use any calling convention you want.<p><a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#calling-conventions" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#calling-conventions</a><p>For those curious, the relevant diff in neatlang is: <a href="https:&#x2F;&#x2F;github.com&#x2F;Neat-Lang&#x2F;neat&#x2F;commit&#x2F;f4ba38cefc1e26631a50a57dad17fca076af4b57">https:&#x2F;&#x2F;github.com&#x2F;Neat-Lang&#x2F;neat&#x2F;commit&#x2F;f4ba38cefc1e26631a5...</a>. It looks much more involved than changing the emitted LLVM calling conventions.  Possibly the author wants these types exposed with some deterministic calling convention to C programs.</div><br/><div id="38875992" class="c"><input type="checkbox" id="c-38875992" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38875950">parent</a><span>|</span><a href="#38875837">next</a><span>|</span><label class="collapse" for="c-38875992">[-]</label><label class="expand" for="c-38875992">[1 more]</label></div><br/><div class="children"><div class="content">Or ABIs in general, really.<p>As any Asm programmer can tell you, this is one of the low-hanging fruits that compilers can easily be beaten at --- don&#x27;t blindly follow convention, do what makes the most sense in a specific scenario.</div><br/></div></div></div></div><div id="38875837" class="c"><input type="checkbox" id="c-38875837" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38875950">prev</a><span>|</span><a href="#38876747">next</a><span>|</span><label class="collapse" for="c-38875837">[-]</label><label class="expand" for="c-38875837">[23 more]</label></div><br/><div class="children"><div class="content">The cost of argument passing is rarely well-understood, and I&#x27;m glad someone wrote this.  People routinely pass 24-byte objects by value in places like Google, and the cost of that practice doesn&#x27;t show up on a profiler because it&#x27;s spread out on every function.</div><br/><div id="38876557" class="c"><input type="checkbox" id="c-38876557" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#38875837">parent</a><span>|</span><a href="#38875897">next</a><span>|</span><label class="collapse" for="c-38876557">[-]</label><label class="expand" for="c-38876557">[4 more]</label></div><br/><div class="children"><div class="content">Pass by value &#x2F; pass by ref is quite a bit of mental overhead as it effectively affects your ABI&#x2F;API. Zig tries to not force this so as long as you &quot;pass by value&quot;, the compiler can actually decide to pass it by reference. It does expose this kind of footgun though <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5973#issuecomment-1330743975">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5973#issuecomment-1330...</a></div><br/><div id="38876602" class="c"><input type="checkbox" id="c-38876602" checked=""/><div class="controls bullet"><span class="by">gnulinux</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876557">parent</a><span>|</span><a href="#38875897">next</a><span>|</span><label class="collapse" for="c-38876602">[-]</label><label class="expand" for="c-38876602">[3 more]</label></div><br/><div class="children"><div class="content">Oof that&#x27;s a very nasty bug. Is this still relevant in Zig or is there a workaround in the language? I&#x27;m not familiar with Zig, heard some good things about it, but this looks like a showstopper.</div><br/><div id="38876871" class="c"><input type="checkbox" id="c-38876871" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876602">parent</a><span>|</span><a href="#38875897">next</a><span>|</span><label class="collapse" for="c-38876871">[-]</label><label class="expand" for="c-38876871">[2 more]</label></div><br/><div class="children"><div class="content">still relevant today, but as someone who writes a lot of Zig code I haven&#x27;t ever really encountered it in the wild. You definitely could, though, and it&#x27;d be wildly confusing.<p>Luckily, the Zig core team has recognized it is an issue and plan to address it before 1.0 :)</div><br/><div id="38876894" class="c"><input type="checkbox" id="c-38876894" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876871">parent</a><span>|</span><a href="#38875897">next</a><span>|</span><label class="collapse" for="c-38876894">[-]</label><label class="expand" for="c-38876894">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s rare to hit it, but if you do, having it happen silently is not ideal for sure.</div><br/></div></div></div></div></div></div></div></div><div id="38875897" class="c"><input type="checkbox" id="c-38875897" checked=""/><div class="controls bullet"><span class="by">elromulous</span><span>|</span><a href="#38875837">parent</a><span>|</span><a href="#38876557">prev</a><span>|</span><a href="#38876008">next</a><span>|</span><label class="collapse" for="c-38875897">[-]</label><label class="expand" for="c-38875897">[13 more]</label></div><br/><div class="children"><div class="content">&quot;in places like Google&quot;.<p>Are you speaking from experience?<p>As a former googler, I can say with certainty that the guidelines for passing any non primitive is pointer or ref.<p>string_view might be the only exception I can think of.</div><br/><div id="38875995" class="c"><input type="checkbox" id="c-38875995" checked=""/><div class="controls bullet"><span class="by">e____g</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875897">parent</a><span>|</span><a href="#38877048">prev</a><span>|</span><a href="#38876882">next</a><span>|</span><label class="collapse" for="c-38875995">[-]</label><label class="expand" for="c-38875995">[8 more]</label></div><br/><div class="children"><div class="content">I saw std::function and std::string (e.g. TotW 127, <a href="https:&#x2F;&#x2F;abseil.io&#x2F;tips&#x2F;117" rel="nofollow">https:&#x2F;&#x2F;abseil.io&#x2F;tips&#x2F;117</a>) being passed by value a lot in newer google3 code. Both are larger than 16 bytes.</div><br/><div id="38876143" class="c"><input type="checkbox" id="c-38876143" checked=""/><div class="controls bullet"><span class="by">eco</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875995">parent</a><span>|</span><a href="#38876136">next</a><span>|</span><label class="collapse" for="c-38876143">[-]</label><label class="expand" for="c-38876143">[3 more]</label></div><br/><div class="children"><div class="content">This is done so you can use std::move to take ownership of the allocated memory in these objects rather than do a new allocation. Passing by value rather than rvalue reference let&#x27;s your function be more flexible at the call site. You can pass an rvalue&#x2F;move or just make a copy at the call site which means the caller (who actually knows if a copy or a move is more appropriate) gets to control how the memory gets allocated.<p>An unnecessary memory allocation is much more of a performance hit than suboptimal calling convention.</div><br/><div id="38877013" class="c"><input type="checkbox" id="c-38877013" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876143">parent</a><span>|</span><a href="#38876136">next</a><span>|</span><label class="collapse" for="c-38877013">[-]</label><label class="expand" for="c-38877013">[2 more]</label></div><br/><div class="children"><div class="content">In that case, the optimal interface should take std::string&amp;&amp; no? But it&#x27;s awkward.</div><br/><div id="38877053" class="c"><input type="checkbox" id="c-38877053" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38877013">parent</a><span>|</span><a href="#38876136">next</a><span>|</span><label class="collapse" for="c-38877053">[-]</label><label class="expand" for="c-38877053">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this be very annoying to work with, because now you have to explicitly move or copy the string whenever you want to construct one of these objects?</div><br/></div></div></div></div></div></div><div id="38876136" class="c"><input type="checkbox" id="c-38876136" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875995">parent</a><span>|</span><a href="#38876143">prev</a><span>|</span><a href="#38876910">next</a><span>|</span><label class="collapse" for="c-38876136">[-]</label><label class="expand" for="c-38876136">[1 more]</label></div><br/><div class="children"><div class="content">Passing std::function by value is almost definitely wrong these days with absl::AnyInvocable (if you need to store the type) and absl::FunctionRef (if you don&#x27;t). Rough analogues in the standard are std::move_only_function (C++23) and std::function_ref (C++26).<p>std::string in the case you cited is only really relevant if you std::move() into it and you would otherwise incur a string copy. Yes, it&#x27;s bigger than 16 bytes (24 bytes), but that pales in comparison to the alternative.<p>(Taking std::string&amp;&amp; would eliminate the possibility of misuse &#x2F; accidental copies, but that pattern is generally discouraged by Google&#x27;s style guide for various reasons.)<p>Also, just because you see a certain pattern an awful lot even at Google doesn&#x27;t mean that it&#x27;s best practice -- there are plenty of instances of protobufs being passed by value...</div><br/></div></div><div id="38876910" class="c"><input type="checkbox" id="c-38876910" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875995">parent</a><span>|</span><a href="#38876136">prev</a><span>|</span><a href="#38876099">next</a><span>|</span><label class="collapse" for="c-38876910">[-]</label><label class="expand" for="c-38876910">[1 more]</label></div><br/><div class="children"><div class="content">not trivially copyable types are never passed in registers regardless of size</div><br/></div></div><div id="38876099" class="c"><input type="checkbox" id="c-38876099" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875995">parent</a><span>|</span><a href="#38876910">prev</a><span>|</span><a href="#38876882">next</a><span>|</span><label class="collapse" for="c-38876099">[-]</label><label class="expand" for="c-38876099">[2 more]</label></div><br/><div class="children"><div class="content">Google builds non-PIE, non-PIC, static, profile-guided, link-time-optimized, and post-link-optimized binaries and probably DGAF about calling conventions.</div><br/><div id="38876110" class="c"><input type="checkbox" id="c-38876110" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876099">parent</a><span>|</span><a href="#38876882">next</a><span>|</span><label class="collapse" for="c-38876110">[-]</label><label class="expand" for="c-38876110">[1 more]</label></div><br/><div class="children"><div class="content">I have seen the assembly output of Google code, and I will say that my previous comment still stands.</div><br/></div></div></div></div></div></div><div id="38876882" class="c"><input type="checkbox" id="c-38876882" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875897">parent</a><span>|</span><a href="#38875995">prev</a><span>|</span><a href="#38876091">next</a><span>|</span><label class="collapse" for="c-38876882">[-]</label><label class="expand" for="c-38876882">[1 more]</label></div><br/><div class="children"><div class="content">&gt; string_view might be the only exception I can think of.<p>What about std::span? std::optional? etc.</div><br/></div></div><div id="38876091" class="c"><input type="checkbox" id="c-38876091" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38875897">parent</a><span>|</span><a href="#38876882">prev</a><span>|</span><a href="#38876008">next</a><span>|</span><label class="collapse" for="c-38876091">[-]</label><label class="expand" for="c-38876091">[2 more]</label></div><br/><div class="children"><div class="content">Yes.  A lot of 24-byte structs at Google are passed by value.</div><br/><div id="38876641" class="c"><input type="checkbox" id="c-38876641" checked=""/><div class="controls bullet"><span class="by">japanman185</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876091">parent</a><span>|</span><a href="#38876008">next</a><span>|</span><label class="collapse" for="c-38876641">[-]</label><label class="expand" for="c-38876641">[1 more]</label></div><br/><div class="children"><div class="content">Indeed they are. I read about it from hackernews.</div><br/></div></div></div></div></div></div><div id="38876008" class="c"><input type="checkbox" id="c-38876008" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38875837">parent</a><span>|</span><a href="#38875897">prev</a><span>|</span><a href="#38876747">next</a><span>|</span><label class="collapse" for="c-38876008">[-]</label><label class="expand" for="c-38876008">[5 more]</label></div><br/><div class="children"><div class="content">Does the C++ ABI also spill 24-byte objects to the stack for each call?  I guess I don&#x27;t expect std::string or std::function parameters to be fast but it&#x27;s still surprising.</div><br/><div id="38876341" class="c"><input type="checkbox" id="c-38876341" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876008">parent</a><span>|</span><a href="#38876747">next</a><span>|</span><label class="collapse" for="c-38876341">[-]</label><label class="expand" for="c-38876341">[4 more]</label></div><br/><div class="children"><div class="content">Spilling big objects up the call stack is often not nearly as bad.  Most of the time this happens, the object being spilled is constructed during the function, so the copy on return is actually elided.</div><br/><div id="38876534" class="c"><input type="checkbox" id="c-38876534" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876341">parent</a><span>|</span><a href="#38876747">next</a><span>|</span><label class="collapse" for="c-38876534">[-]</label><label class="expand" for="c-38876534">[3 more]</label></div><br/><div class="children"><div class="content">That’s only true if the function takes no argument. Otherwise the copy on return is unavoidable.</div><br/><div id="38876977" class="c"><input type="checkbox" id="c-38876977" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876534">parent</a><span>|</span><a href="#38876551">next</a><span>|</span><label class="collapse" for="c-38876977">[-]</label><label class="expand" for="c-38876977">[1 more]</label></div><br/><div class="children"><div class="content">In AMD64 ABI, anything larger (that doesn&#x27;t fit in register) will be returned by basically output pointer argument. Caller reserves space for the return value and gives pointer to the function which then fills it with the return value. Both sides are easy to optimize and no unnecessary copies are made. Function can directly construct return value to the given address and caller can directly give a pointer to a variable if function return value is used to initialise variable.</div><br/></div></div><div id="38876551" class="c"><input type="checkbox" id="c-38876551" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38875837">root</a><span>|</span><a href="#38876534">parent</a><span>|</span><a href="#38876977">prev</a><span>|</span><a href="#38876747">next</a><span>|</span><label class="collapse" for="c-38876551">[-]</label><label class="expand" for="c-38876551">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not actually true: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;copy_elision" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;copy_elision</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38876747" class="c"><input type="checkbox" id="c-38876747" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#38875837">prev</a><span>|</span><a href="#38875891">next</a><span>|</span><label class="collapse" for="c-38876747">[-]</label><label class="expand" for="c-38876747">[2 more]</label></div><br/><div class="children"><div class="content">When I first transitioned to x64, I was concerned about graphics vec3 objects (3xfloat) expanding to sizeof()=16 bytes (instead of 12) that I benchmarked the hell out of my graphics engines. Unsuprisingly, using 16 bytes ended up being faster than 12, due to aligning 8 byte reads (internal and on GPU).  So a vec3 silently became a vec4 (even though a vec4 also exists).<p>As always, do global, not local benchmarking.</div><br/><div id="38876978" class="c"><input type="checkbox" id="c-38876978" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#38876747">parent</a><span>|</span><a href="#38875891">next</a><span>|</span><label class="collapse" for="c-38876978">[-]</label><label class="expand" for="c-38876978">[1 more]</label></div><br/><div class="children"><div class="content">Probably not a lot faster? And apart from what you&#x27;re doing with this data, isn&#x27;t this also going to depend a lot on the CPU? I can see that with 16 bytes, a lot of accesses could be 2x aligned 8 bytes (or 1x16) instead of 3x4 bytes. Some other accesses, maybe not so much. And there is also the issue of increased cache pressure.</div><br/></div></div></div></div><div id="38875891" class="c"><input type="checkbox" id="c-38875891" checked=""/><div class="controls bullet"><span class="by">countWSS</span><span>|</span><a href="#38876747">prev</a><span>|</span><a href="#38876075">next</a><span>|</span><label class="collapse" for="c-38875891">[-]</label><label class="expand" for="c-38875891">[3 more]</label></div><br/><div class="children"><div class="content">Its common sense: anything passed in registers(preloaded due spec execution)
 will outperform stack writes and stack wrangling will outperform heap allocated stuff.
That why ugly spaghetti code with tons of globals runs blazingly fast and
your elegant recursive functions and tuple&#x2F;struct&#x2F;lists arguments are incredibly slow, the first one
is much easier to optimize into tight assembly loops.</div><br/><div id="38876716" class="c"><input type="checkbox" id="c-38876716" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38875891">parent</a><span>|</span><a href="#38876648">next</a><span>|</span><label class="collapse" for="c-38876716">[-]</label><label class="expand" for="c-38876716">[1 more]</label></div><br/><div class="children"><div class="content">Of course, that assumes that your spaghetti code implements the same algorithm as your elegant code.<p>If the elegant code is O(n) and the spaghetti code is O(n^2) you might notice the difference.<p>And, of course, there&#x27;s also maintenance to consider.<p>In some sense, compiler are there exactly to turn our elegant solutions into spaghetti code.</div><br/></div></div><div id="38876648" class="c"><input type="checkbox" id="c-38876648" checked=""/><div class="controls bullet"><span class="by">japanman185</span><span>|</span><a href="#38875891">parent</a><span>|</span><a href="#38876716">prev</a><span>|</span><a href="#38876075">next</a><span>|</span><label class="collapse" for="c-38876648">[-]</label><label class="expand" for="c-38876648">[1 more]</label></div><br/><div class="children"><div class="content">But what about my academic mental exercise. You mean I learned all these tools and techniques for nothing? How will my manager know if I am a top engineer or not if my code is not impenetrable with ridiculous concepts applied irrationally.</div><br/></div></div></div></div><div id="38876075" class="c"><input type="checkbox" id="c-38876075" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#38875891">prev</a><span>|</span><a href="#38876226">next</a><span>|</span><label class="collapse" for="c-38876075">[-]</label><label class="expand" for="c-38876075">[7 more]</label></div><br/><div class="children"><div class="content">In the provided example, you can fix it without affecting any caller by changing the parameter types from “struct Vector” to “const struct Vector &amp;” pass-by-reference.  A lot C++ code that I have seen where pointer bugs existed needlessly used pointers even when passing by reference could have worked while being easier and safer to use.</div><br/><div id="38877031" class="c"><input type="checkbox" id="c-38877031" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#38876075">parent</a><span>|</span><a href="#38876108">next</a><span>|</span><label class="collapse" for="c-38877031">[-]</label><label class="expand" for="c-38877031">[1 more]</label></div><br/><div class="children"><div class="content">No. Actually that is the whole problem here. That is pretty much exactly what the compiler does thanks to ABI. ABI says that the value must be passed by pointer so it has to store it somewhere to get the pointer, which is exactly the same that would happen if we made that explicit by using const-ref. By changing to use separate arguments for the struct values, arguments can be passed in registers instead.</div><br/></div></div><div id="38876108" class="c"><input type="checkbox" id="c-38876108" checked=""/><div class="controls bullet"><span class="by">giovannibajo1</span><span>|</span><a href="#38876075">parent</a><span>|</span><a href="#38877031">prev</a><span>|</span><a href="#38876226">next</a><span>|</span><label class="collapse" for="c-38876108">[-]</label><label class="expand" for="c-38876108">[5 more]</label></div><br/><div class="children"><div class="content">That will still require the compiler to serialize the three registers to the stack, to be able to pass the pointer to the structure to the callee. It seems like the described benefit is avoiding any serialization from registers to stack, which cannot be avoided with pass-by-reference.</div><br/><div id="38876995" class="c"><input type="checkbox" id="c-38876995" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38876075">root</a><span>|</span><a href="#38876108">parent</a><span>|</span><a href="#38876219">next</a><span>|</span><label class="collapse" for="c-38876995">[-]</label><label class="expand" for="c-38876995">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>That will still require the compiler to serialize the three registers to the stack, to be able to pass the pointer to the structure to the callee.</i><p>why can&#x27;t it simply pass a pointer to the struct (it&#x27;s probably already on the stack) without rewriting the struct to the stack? isn&#x27;t that what a reference is?</div><br/><div id="38877064" class="c"><input type="checkbox" id="c-38877064" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#38876075">root</a><span>|</span><a href="#38876995">parent</a><span>|</span><a href="#38876219">next</a><span>|</span><label class="collapse" for="c-38877064">[-]</label><label class="expand" for="c-38877064">[1 more]</label></div><br/><div class="children"><div class="content">But it often isn&#x27;t in the stack. This is a vector type so it is often modified and used as part of math operations. Each vector field is probably in some register because it was used to calculate something and then has to be stored back to stack to get valid data for the reference.</div><br/></div></div></div></div><div id="38876219" class="c"><input type="checkbox" id="c-38876219" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#38876075">root</a><span>|</span><a href="#38876108">parent</a><span>|</span><a href="#38876995">prev</a><span>|</span><a href="#38876226">next</a><span>|</span><label class="collapse" for="c-38876219">[-]</label><label class="expand" for="c-38876219">[2 more]</label></div><br/><div class="children"><div class="content">But that would only be possible if you write out all the struct fields you are accessing into function parameters. If the struct is complex with a lot of fields, then you would end up with a messy function signature. Also, I am sure there is a limit to how many parameters you can have before this optimization stops working.</div><br/><div id="38876696" class="c"><input type="checkbox" id="c-38876696" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38876075">root</a><span>|</span><a href="#38876219">parent</a><span>|</span><a href="#38876226">next</a><span>|</span><label class="collapse" for="c-38876696">[-]</label><label class="expand" for="c-38876696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But that would only be possible if you write out all the struct fields you are accessing into function parameters. If the struct is complex with a lot of fields, then you would end up with a messy function signature.<p>This is the approach the article&#x27;s author took.</div><br/></div></div></div></div></div></div></div></div><div id="38876226" class="c"><input type="checkbox" id="c-38876226" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38876075">prev</a><span>|</span><a href="#38875979">next</a><span>|</span><label class="collapse" for="c-38876226">[-]</label><label class="expand" for="c-38876226">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s perfectly fine to pass and return structs bigger than 16 bytes by value on amd64 even with the sysv amd64 abi; it&#x27;s just slow.  but it&#x27;s often worth it to make your code clearer.  not in this case, of course, but as loeg points out, inside your own language you can just use a custom abi, as for example each c++ compiler, golang, ocaml, and sbcl do</div><br/></div></div><div id="38875979" class="c"><input type="checkbox" id="c-38875979" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#38876226">prev</a><span>|</span><a href="#38876499">next</a><span>|</span><label class="collapse" for="c-38875979">[-]</label><label class="expand" for="c-38875979">[1 more]</label></div><br/><div class="children"><div class="content">On Windows with the default cdecl calling convention structs bigger than 8 bytes don’t get passed in registers [1].<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;x64-calling-convention?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;x64-calling-conv...</a></div><br/></div></div><div id="38876209" class="c"><input type="checkbox" id="c-38876209" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38876499">prev</a><span>|</span><a href="#38875855">next</a><span>|</span><label class="collapse" for="c-38876209">[-]</label><label class="expand" for="c-38876209">[4 more]</label></div><br/><div class="children"><div class="content">I classify this kind of article as &quot;just enough knowledge to be a pain in the ass&quot;. Even if you compile it separately per the instructions, trying to force the compiler to generate ABI-callable functions, you can still undo this error with LTO. Building this program with LTO is dramatically faster in both modes compared to either mode of the non-LTO program.<p>If your program is performance-sensitive, profile it, peak-optimize it, and <i>only then</i> commit jackassery such as unpacking structs into arguments.</div><br/><div id="38876427" class="c"><input type="checkbox" id="c-38876427" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38876209">parent</a><span>|</span><a href="#38875855">next</a><span>|</span><label class="collapse" for="c-38876427">[-]</label><label class="expand" for="c-38876427">[3 more]</label></div><br/><div class="children"><div class="content">That would be good advice except I’ve yet to see a compiler that can make this kind of stuff visible. First it’s distributed throughout your codebase and I’ve not seen  any profiler that can show that impact unless you’re lucky and this becomes a hotspot. This applies to nearly all compiler generated code. Valgrind can measure it (sampling profiler probably can’t) but there’s no tooling to highlight diffuse code gen problems</div><br/><div id="38876496" class="c"><input type="checkbox" id="c-38876496" checked=""/><div class="controls bullet"><span class="by">bugbuddy</span><span>|</span><a href="#38876209">root</a><span>|</span><a href="#38876427">parent</a><span>|</span><a href="#38875855">next</a><span>|</span><label class="collapse" for="c-38876496">[-]</label><label class="expand" for="c-38876496">[2 more]</label></div><br/><div class="children"><div class="content">This is clearly a hot path and not inlining a hot path call is probably the first thing any engineer worth his salt would attempt to fix. If and how it can be fixed is a different question.</div><br/><div id="38876726" class="c"><input type="checkbox" id="c-38876726" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38876209">root</a><span>|</span><a href="#38876496">parent</a><span>|</span><a href="#38875855">next</a><span>|</span><label class="collapse" for="c-38876726">[-]</label><label class="expand" for="c-38876726">[1 more]</label></div><br/><div class="children"><div class="content">Just because something is in the hot path does not mean a profiler will be able to highlight this as a hotspot.</div><br/></div></div></div></div></div></div></div></div><div id="38875855" class="c"><input type="checkbox" id="c-38875855" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#38876209">prev</a><span>|</span><label class="collapse" for="c-38875855">[-]</label><label class="expand" for="c-38875855">[1 more]</label></div><br/><div class="children"><div class="content">This makes me super happy that my C array types are only 16 bytes.</div><br/></div></div></div></div></div></div></div></body></html>