<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696842083411" as="style"/><link rel="stylesheet" href="styles.css?v=1696842083411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.frankel.ch/rust-from-python/">Calling Rust from Python</a> <span class="domain">(<a href="https://blog.frankel.ch">blog.frankel.ch</a>)</span></div><div class="subtext"><span>RebootStr</span> | <span>30 comments</span></div><br/><div><div id="37813465" class="c"><input type="checkbox" id="c-37813465" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37815173">next</a><span>|</span><label class="collapse" for="c-37813465">[-]</label><label class="expand" for="c-37813465">[24 more]</label></div><br/><div class="children"><div class="content">I would not recommend FFI + ctypes. Maintaining the bindings is tedious and error-prone. Also, Rust FFI&#x2F;unsafe can be tricky even for experienced Rust devs.<p>Instead PyO3 [1] lets you &quot;write a native Python module in Rust&quot;, and it works great. A much better choice IMO.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3">https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3</a></div><br/><div id="37814180" class="c"><input type="checkbox" id="c-37814180" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813924">next</a><span>|</span><label class="collapse" for="c-37814180">[-]</label><label class="expand" for="c-37814180">[3 more]</label></div><br/><div class="children"><div class="content">Right now FFI + ctypes has one big advantage: it supports true parallelism with GIL-per-subinterpreter in Python 3.12. AFAIK all the higher-level binding libraries&#x2F;tools (PyO3, pybind11, nanobind, Cython) don&#x27;t support this yet; and in fact can&#x27;t really support it without API-breaking fundamental design changes.</div><br/><div id="37814549" class="c"><input type="checkbox" id="c-37814549" checked=""/><div class="controls bullet"><span class="by">rdedev</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814180">parent</a><span>|</span><a href="#37814388">next</a><span>|</span><label class="collapse" for="c-37814549">[-]</label><label class="expand" for="c-37814549">[1 more]</label></div><br/><div class="children"><div class="content">But wasn&#x27;t the whole point to drop down to a lower language, release the GIL and then do parallel processing? Gil per subinterpretee makes things easy python side but I&#x27;m not sure how much of it&#x27;s relevant if you are using something like pyO3</div><br/></div></div><div id="37814388" class="c"><input type="checkbox" id="c-37814388" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814180">parent</a><span>|</span><a href="#37814549">prev</a><span>|</span><a href="#37813924">next</a><span>|</span><label class="collapse" for="c-37814388">[-]</label><label class="expand" for="c-37814388">[1 more]</label></div><br/><div class="children"><div class="content">Do you know what kind of design changes would be needed?</div><br/></div></div></div></div><div id="37813924" class="c"><input type="checkbox" id="c-37813924" checked=""/><div class="controls bullet"><span class="by">nhatcher</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37814180">prev</a><span>|</span><a href="#37813521">next</a><span>|</span><label class="collapse" for="c-37813924">[-]</label><label class="expand" for="c-37813924">[3 more]</label></div><br/><div class="children"><div class="content">I think you are right. But as a proof of concept is an interesting read. I&#x27;ve work extensively with Rust and PyO3 and Maturin and even for a medium to large project is great. I wrote a bit about that here:<p><a href="https:&#x2F;&#x2F;www.nhatcher.com&#x2F;post&#x2F;rust-in-anger&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nhatcher.com&#x2F;post&#x2F;rust-in-anger&#x2F;</a></div><br/><div id="37813998" class="c"><input type="checkbox" id="c-37813998" checked=""/><div class="controls bullet"><span class="by">wiktor-k</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813924">parent</a><span>|</span><a href="#37814655">next</a><span>|</span><label class="collapse" for="c-37813998">[-]</label><label class="expand" for="c-37813998">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also recommend PyO3 and Maturin. The amount of help these crates give is mind boggling (automatic type marshaling and even github CI jobs for creating cross platform precompiled wheels).<p>I&#x27;ve created a library using this crate (<a href="https:&#x2F;&#x2F;github.com&#x2F;wiktor-k&#x2F;pysequoia&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;wiktor-k&#x2F;pysequoia&#x2F;</a>) and most of the time I could just focus on the problem domain instead of technical details of the bindings.<p>There are just a couple of smaller issues (eg. Python to Rust async is not built in) but overall it&#x27;s really nice.</div><br/></div></div><div id="37814655" class="c"><input type="checkbox" id="c-37814655" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813924">parent</a><span>|</span><a href="#37813998">prev</a><span>|</span><a href="#37813521">next</a><span>|</span><label class="collapse" for="c-37814655">[-]</label><label class="expand" for="c-37814655">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. It&#x27;s also instructive to look at how C extensions are written for the CPython.<p>I wouldn&#x27;t necessarily expect a demo; but not mentioning it at all seems like it could lead readers down a path where they choose the &quot;most performant&quot; option presented (FFI + ctypes). The post has a &quot;To go further:&quot; link section where even a quick link to PyO3 would go a long way. So I thought I&#x27;d mention the downsides and an alternative on HN.</div><br/></div></div></div></div><div id="37813521" class="c"><input type="checkbox" id="c-37813521" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813924">prev</a><span>|</span><a href="#37813497">next</a><span>|</span><label class="collapse" for="c-37813521">[-]</label><label class="expand" for="c-37813521">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely, I was surprised anyone would recommend ctypes for Python&#x2F;Rust today. I&#x27;ve written a few Python libraries using Rust to do the slow parts, and PyO3&#x2F;maturin is a great experience.</div><br/><div id="37814012" class="c"><input type="checkbox" id="c-37814012" checked=""/><div class="controls bullet"><span class="by">anonacct37</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813521">parent</a><span>|</span><a href="#37813497">next</a><span>|</span><label class="collapse" for="c-37814012">[-]</label><label class="expand" for="c-37814012">[1 more]</label></div><br/><div class="children"><div class="content">Even a decade ago I was seeing projects stop using ctypes and instead use things like cffi. Honestly I couldn&#x27;t tell you exactly why ctypes is so bad but I do know that cffi integrates a little closer with the c compiler and has better header support.</div><br/></div></div></div></div><div id="37813497" class="c"><input type="checkbox" id="c-37813497" checked=""/><div class="controls bullet"><span class="by">sonthonax</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813521">prev</a><span>|</span><a href="#37813918">next</a><span>|</span><label class="collapse" for="c-37813497">[-]</label><label class="expand" for="c-37813497">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t PyO3 just a set of macros and helpers around FFI and ctypes?</div><br/><div id="37813611" class="c"><input type="checkbox" id="c-37813611" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813497">parent</a><span>|</span><a href="#37814412">next</a><span>|</span><label class="collapse" for="c-37813611">[-]</label><label class="expand" for="c-37813611">[1 more]</label></div><br/><div class="children"><div class="content">&quot;just&quot; undersells it a bit, mainly around type conversions.<p>Also, there is no ctypes involved, as the result is a CPython extension that just loads on the Python side.</div><br/></div></div><div id="37814412" class="c"><input type="checkbox" id="c-37814412" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813497">parent</a><span>|</span><a href="#37813611">prev</a><span>|</span><a href="#37813918">next</a><span>|</span><label class="collapse" for="c-37814412">[-]</label><label class="expand" for="c-37814412">[1 more]</label></div><br/><div class="children"><div class="content">In the same sense that rust is just a set of macros and helpers around assembly.<p>Also no ctypes.</div><br/></div></div></div></div><div id="37813918" class="c"><input type="checkbox" id="c-37813918" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813497">prev</a><span>|</span><a href="#37814609">next</a><span>|</span><label class="collapse" for="c-37813918">[-]</label><label class="expand" for="c-37813918">[1 more]</label></div><br/><div class="children"><div class="content">Some related past threads:<p><i>How to write Python extensions in Rust with PyO3</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34968186">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34968186</a> - Feb 2023 (9 comments)<p><i>PyO3 – Python Extensions in Rust</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32247452">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32247452</a> - July 2022 (1 comment)<p><i>Calling Rust from Python using PyO3</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29368530">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29368530</a> - Nov 2021 (49 comments)<p><i>PyO3: Rust Bindings for the Python Interpreter</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25956502">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25956502</a> - Jan 2021 (77 comments)<p><i>Writing Python Extensions in Rust Using PyO3</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17423013">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17423013</a> - June 2018 (1 comment)<p><i>PyO3: Python  Rust binding</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14859844">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14859844</a> - July 2017 (15 comments)<p><i>(First Release) PyO3:  a Python-Rust Binding Library</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14846606">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14846606</a> - July 2017 (1 comment)</div><br/></div></div><div id="37814609" class="c"><input type="checkbox" id="c-37814609" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813918">prev</a><span>|</span><a href="#37813722">next</a><span>|</span><label class="collapse" for="c-37814609">[-]</label><label class="expand" for="c-37814609">[2 more]</label></div><br/><div class="children"><div class="content">PyO3 is great. I have been using it to rewrite some slow python code. My only complaint is that documentation is a bit rough. For someone who understands python, but not rust, there was a pretty big hill to climb to understand type conversions.<p>There are also things I am still struggling with. For example, there is a rust function I want to repeatedly call from python, that takes in a large unchanging python array. How can I pass the array from python to rust only once, i.e do the type conversion just once, so I don&#x27;t have to pay that cost repeatedly.</div><br/><div id="37814646" class="c"><input type="checkbox" id="c-37814646" checked=""/><div class="controls bullet"><span class="by">dsheets</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814609">parent</a><span>|</span><a href="#37813722">next</a><span>|</span><label class="collapse" for="c-37814646">[-]</label><label class="expand" for="c-37814646">[1 more]</label></div><br/><div class="children"><div class="content">I recommend creating a pyclass over a struct that stores the converted data. Instantiate it once and then repeatedly call a function on it in a pymethods impl with the parameters that differ.</div><br/></div></div></div></div><div id="37813722" class="c"><input type="checkbox" id="c-37813722" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37814609">prev</a><span>|</span><a href="#37815944">next</a><span>|</span><label class="collapse" for="c-37813722">[-]</label><label class="expand" for="c-37813722">[3 more]</label></div><br/><div class="children"><div class="content">Just looking at the function signatures there:<p><pre><code>   fn string_sum(_py: Python&lt;&#x27;_&gt;, m: &amp;PyModule)
</code></pre>
is the idea that the `Python` type represents the GIL and you&#x27;re actually acquiring it from within your Rust application?</div><br/><div id="37813833" class="c"><input type="checkbox" id="c-37813833" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813722">parent</a><span>|</span><a href="#37815944">next</a><span>|</span><label class="collapse" for="c-37813833">[-]</label><label class="expand" for="c-37813833">[2 more]</label></div><br/><div class="children"><div class="content">Edit: Yes it does, as ynik rightly points out, and documented here <a href="https:&#x2F;&#x2F;pyo3.rs&#x2F;v0.19.2&#x2F;types#gil-lifetimes-mutability-and-python-object-types" rel="nofollow noreferrer">https:&#x2F;&#x2F;pyo3.rs&#x2F;v0.19.2&#x2F;types#gil-lifetimes-mutability-and-p...</a> or here <a href="https:&#x2F;&#x2F;docs.rs&#x2F;pyo3&#x2F;0.19.2&#x2F;pyo3&#x2F;marker&#x2F;struct.Python.html#obtaining-a-python-token" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;pyo3&#x2F;0.19.2&#x2F;pyo3&#x2F;marker&#x2F;struct.Python.html#o...</a></div><br/><div id="37814130" class="c"><input type="checkbox" id="c-37814130" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37813833">parent</a><span>|</span><a href="#37815944">next</a><span>|</span><label class="collapse" for="c-37814130">[-]</label><label class="expand" for="c-37814130">[1 more]</label></div><br/><div class="children"><div class="content">The Python&lt;&#x27;_&gt; type appearing as a parameter means the caller has already acquired the GIL for you. The GIL is held when Python calls into extension modules, and PyO3 doesn&#x27;t automatically release it (but you can do so yourself).<p>It&#x27;s essentially a dummy parameter that serves as proof that the GIL is held. You need to provide it to PyO3 when calling back into the Python runtime, that way the compiler ensures the GIL is still held where required.</div><br/></div></div></div></div></div></div><div id="37815944" class="c"><input type="checkbox" id="c-37815944" checked=""/><div class="controls bullet"><span class="by">WiSaGaN</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37813722">prev</a><span>|</span><a href="#37816565">next</a><span>|</span><label class="collapse" for="c-37815944">[-]</label><label class="expand" for="c-37815944">[1 more]</label></div><br/><div class="children"><div class="content">I have used PyO3 for my Rust code to calling into a Python SDK api. It works like a charm.</div><br/></div></div><div id="37816565" class="c"><input type="checkbox" id="c-37816565" checked=""/><div class="controls bullet"><span class="by">vietvu</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37815944">prev</a><span>|</span><a href="#37814413">next</a><span>|</span><label class="collapse" for="c-37816565">[-]</label><label class="expand" for="c-37816565">[1 more]</label></div><br/><div class="children"><div class="content">Polars uses PyO3 too, looks quite simple.</div><br/></div></div><div id="37814413" class="c"><input type="checkbox" id="c-37814413" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37813465">parent</a><span>|</span><a href="#37816565">prev</a><span>|</span><a href="#37815173">next</a><span>|</span><label class="collapse" for="c-37814413">[-]</label><label class="expand" for="c-37814413">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I would not recommend FFI + ctypes.<p>Well it depends. C is the lingua franca of Computer Science. These days I write a lot of code that needs to be accessible to a variety of languages and environments. Python, C#, C++, Matlab, Unity, Unreal, etc.<p>Write a C API and your code can be used <i>anywhere</i>. Now if you know you only ever need to support Python then sure look into PyO3. But if you have mixed use you can’t be the flexibility of a C API.</div><br/><div id="37814602" class="c"><input type="checkbox" id="c-37814602" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814413">parent</a><span>|</span><a href="#37815173">next</a><span>|</span><label class="collapse" for="c-37814602">[-]</label><label class="expand" for="c-37814602">[3 more]</label></div><br/><div class="children"><div class="content">Honestly though, I would likely still choose to implement the logic in Rust as a crate&#x2F;library in a workspace, the (C)Python extensions as a PyO3 dylib&#x2F;separate crate, and a C FFI dylib as yet another crate.<p>The benefit is that you only need to ship the CPython extension, you can build it with cargo, and everything&#x27;s in one place. I&#x27;ve maintained bindings for Python and C# to native libraries, and it&#x27;s usually a pain for various reasons.<p>The C API might be able to be used anywhere, but that doesn&#x27;t mean it&#x27;s ergonomic, easy to use, or safe.</div><br/><div id="37814735" class="c"><input type="checkbox" id="c-37814735" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814602">parent</a><span>|</span><a href="#37815173">next</a><span>|</span><label class="collapse" for="c-37814735">[-]</label><label class="expand" for="c-37814735">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The C API might be able to be used anywhere, but that doesn&#x27;t mean it&#x27;s ergonomic, easy to use, or safe.<p>Definitely true. That said I think there is an under appreciated beautiy to a clean C API.<p>It’s easy to “upgrade” a C API with  per-language&#x2F;environment bindings. It can be near impossible to “downgrade” a high-level API to C.</div><br/><div id="37818065" class="c"><input type="checkbox" id="c-37818065" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#37813465">root</a><span>|</span><a href="#37814735">parent</a><span>|</span><a href="#37815173">next</a><span>|</span><label class="collapse" for="c-37818065">[-]</label><label class="expand" for="c-37818065">[1 more]</label></div><br/><div class="children"><div class="content">And Rust just uses the C ABI, so wouldn’t your comments include “in Rust”?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37815173" class="c"><input type="checkbox" id="c-37815173" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#37813465">prev</a><span>|</span><a href="#37817835">next</a><span>|</span><label class="collapse" for="c-37815173">[-]</label><label class="expand" for="c-37815173">[1 more]</label></div><br/><div class="children"><div class="content">Small note for the author: I was a bit confused at first by the use of &quot;Nix-based&quot; to mean POSIX-compliant [1] since Nix is the name of a package manager that NixOS is based on. I&#x27;ve only seen &quot;*nix&quot; to refer to Unix-like systems.<p>[1] Which seems like the right condition here? since I believe Unix domain sockets are required by POSIX.</div><br/></div></div><div id="37817835" class="c"><input type="checkbox" id="c-37817835" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#37815173">prev</a><span>|</span><a href="#37815848">next</a><span>|</span><label class="collapse" for="c-37817835">[-]</label><label class="expand" for="c-37817835">[1 more]</label></div><br/><div class="children"><div class="content">as long as you don&#x27;t need to cross compile pyO3 makes calling python from rust in ffi extremely simple and convenient as it&#x27;s abstracts away so the ffi, ctypes parts</div><br/></div></div><div id="37815848" class="c"><input type="checkbox" id="c-37815848" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#37817835">prev</a><span>|</span><a href="#37814801">next</a><span>|</span><label class="collapse" for="c-37815848">[-]</label><label class="expand" for="c-37815848">[1 more]</label></div><br/><div class="children"><div class="content">I read <a href="https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2016&#x2F;fine_grained_language_composition.html#14462460" rel="nofollow noreferrer">https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2016&#x2F;fine_grained_language_com...</a> this week, and now I’m obsessed with how all three of the techniques presented here suck, and we should just be able to mix languages freely.</div><br/></div></div><div id="37814801" class="c"><input type="checkbox" id="c-37814801" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37815848">prev</a><span>|</span><a href="#37814064">next</a><span>|</span><label class="collapse" for="c-37814801">[-]</label><label class="expand" for="c-37814801">[1 more]</label></div><br/><div class="children"><div class="content">As others have pointed out: none of these three “generic” methods is appropriate when a more precise one (such as dedicated bindings between a pair of languages) exists.<p>PyO3 is practical evidence of Rust’s claims around holistic security: a user can write safe Rust <i>and</i> safe Python without having to directly unsafely traverse the C ABI between them, or take a potentially unacceptable performance hit from RPC or IPC.</div><br/></div></div><div id="37814064" class="c"><input type="checkbox" id="c-37814064" checked=""/><div class="controls bullet"><span class="by">pmkelly4444</span><span>|</span><a href="#37814801">prev</a><span>|</span><label class="collapse" for="c-37814064">[-]</label><label class="expand" for="c-37814064">[1 more]</label></div><br/><div class="children"><div class="content">check out uniffi for a complete workflow for FFI in many languages: <a href="https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;uniffi-rs">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;uniffi-rs</a></div><br/></div></div></div></div></div></div></div></body></html>